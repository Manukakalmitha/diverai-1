function vG(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();function wC(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function SG(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var q1={exports:{}},hf={};var hR;function TG(){if(hR)return hf;hR=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,r,i){var a=null;if(i!==void 0&&(a=""+i),r.key!==void 0&&(a=""+r.key),"key"in r){i={};for(var o in r)o!=="key"&&(i[o]=r[o])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:a,ref:r!==void 0?r:null,props:i}}return hf.Fragment=e,hf.jsx=t,hf.jsxs=t,hf}var dR;function CG(){return dR||(dR=1,q1.exports=TG()),q1.exports}var xe=CG(),K1={exports:{}},Je={};var fR;function NG(){if(fR)return Je;fR=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function y(P){return P===null||typeof P!="object"?null:(P=m&&P[m]||P["@@iterator"],typeof P=="function"?P:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function S(P,H,ne){this.props=P,this.context=H,this.refs=w,this.updater=ne||b}S.prototype.isReactComponent={},S.prototype.setState=function(P,H){if(typeof P!="object"&&typeof P!="function"&&P!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,P,H,"setState")},S.prototype.forceUpdate=function(P){this.updater.enqueueForceUpdate(this,P,"forceUpdate")};function C(){}C.prototype=S.prototype;function N(P,H,ne){this.props=P,this.context=H,this.refs=w,this.updater=ne||b}var k=N.prototype=new C;k.constructor=N,x(k,S.prototype),k.isPureReactComponent=!0;var E=Array.isArray;function _(){}var R={H:null,A:null,T:null,S:null},O=Object.prototype.hasOwnProperty;function F(P,H,ne){var ce=ne.ref;return{$$typeof:n,type:P,key:H,ref:ce!==void 0?ce:null,props:ne}}function L(P,H){return F(P.type,H,P.props)}function A(P){return typeof P=="object"&&P!==null&&P.$$typeof===n}function U(P){var H={"=":"=0",":":"=2"};return"$"+P.replace(/[=:]/g,function(ne){return H[ne]})}var Y=/\/+/g;function te(P,H){return typeof P=="object"&&P!==null&&P.key!=null?U(""+P.key):H.toString(36)}function Z(P){switch(P.status){case"fulfilled":return P.value;case"rejected":throw P.reason;default:switch(typeof P.status=="string"?P.then(_,_):(P.status="pending",P.then(function(H){P.status==="pending"&&(P.status="fulfilled",P.value=H)},function(H){P.status==="pending"&&(P.status="rejected",P.reason=H)})),P.status){case"fulfilled":return P.value;case"rejected":throw P.reason}}throw P}function B(P,H,ne,ce,me){var de=typeof P;(de==="undefined"||de==="boolean")&&(P=null);var Se=!1;if(P===null)Se=!0;else switch(de){case"bigint":case"string":case"number":Se=!0;break;case"object":switch(P.$$typeof){case n:case e:Se=!0;break;case d:return Se=P._init,B(Se(P._payload),H,ne,ce,me)}}if(Se)return me=me(P),Se=ce===""?"."+te(P,0):ce,E(me)?(ne="",Se!=null&&(ne=Se.replace(Y,"$&/")+"/"),B(me,H,ne,"",function(Ve){return Ve})):me!=null&&(A(me)&&(me=L(me,ne+(me.key==null||P&&P.key===me.key?"":(""+me.key).replace(Y,"$&/")+"/")+Se)),H.push(me)),1;Se=0;var Te=ce===""?".":ce+":";if(E(P))for(var Ee=0;Ee<P.length;Ee++)ce=P[Ee],de=Te+te(ce,Ee),Se+=B(ce,H,ne,de,me);else if(Ee=y(P),typeof Ee=="function")for(P=Ee.call(P),Ee=0;!(ce=P.next()).done;)ce=ce.value,de=Te+te(ce,Ee++),Se+=B(ce,H,ne,de,me);else if(de==="object"){if(typeof P.then=="function")return B(Z(P),H,ne,ce,me);throw H=String(P),Error("Objects are not valid as a React child (found: "+(H==="[object Object]"?"object with keys {"+Object.keys(P).join(", ")+"}":H)+"). If you meant to render a collection of children, use an array instead.")}return Se}function V(P,H,ne){if(P==null)return P;var ce=[],me=0;return B(P,ce,"","",function(de){return H.call(ne,de,me++)}),ce}function j(P){if(P._status===-1){var H=P._result;H=H(),H.then(function(ne){(P._status===0||P._status===-1)&&(P._status=1,P._result=ne)},function(ne){(P._status===0||P._status===-1)&&(P._status=2,P._result=ne)}),P._status===-1&&(P._status=0,P._result=H)}if(P._status===1)return P._result.default;throw P._result}var ee=typeof reportError=="function"?reportError:function(P){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var H=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof P=="object"&&P!==null&&typeof P.message=="string"?String(P.message):String(P),error:P});if(!window.dispatchEvent(H))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",P);return}console.error(P)},ae={map:V,forEach:function(P,H,ne){V(P,function(){H.apply(this,arguments)},ne)},count:function(P){var H=0;return V(P,function(){H++}),H},toArray:function(P){return V(P,function(H){return H})||[]},only:function(P){if(!A(P))throw Error("React.Children.only expected to receive a single React element child.");return P}};return Je.Activity=p,Je.Children=ae,Je.Component=S,Je.Fragment=t,Je.Profiler=r,Je.PureComponent=N,Je.StrictMode=s,Je.Suspense=u,Je.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=R,Je.__COMPILER_RUNTIME={__proto__:null,c:function(P){return R.H.useMemoCache(P)}},Je.cache=function(P){return function(){return P.apply(null,arguments)}},Je.cacheSignal=function(){return null},Je.cloneElement=function(P,H,ne){if(P==null)throw Error("The argument must be a React element, but you passed "+P+".");var ce=x({},P.props),me=P.key;if(H!=null)for(de in H.key!==void 0&&(me=""+H.key),H)!O.call(H,de)||de==="key"||de==="__self"||de==="__source"||de==="ref"&&H.ref===void 0||(ce[de]=H[de]);var de=arguments.length-2;if(de===1)ce.children=ne;else if(1<de){for(var Se=Array(de),Te=0;Te<de;Te++)Se[Te]=arguments[Te+2];ce.children=Se}return F(P.type,me,ce)},Je.createContext=function(P){return P={$$typeof:a,_currentValue:P,_currentValue2:P,_threadCount:0,Provider:null,Consumer:null},P.Provider=P,P.Consumer={$$typeof:i,_context:P},P},Je.createElement=function(P,H,ne){var ce,me={},de=null;if(H!=null)for(ce in H.key!==void 0&&(de=""+H.key),H)O.call(H,ce)&&ce!=="key"&&ce!=="__self"&&ce!=="__source"&&(me[ce]=H[ce]);var Se=arguments.length-2;if(Se===1)me.children=ne;else if(1<Se){for(var Te=Array(Se),Ee=0;Ee<Se;Ee++)Te[Ee]=arguments[Ee+2];me.children=Te}if(P&&P.defaultProps)for(ce in Se=P.defaultProps,Se)me[ce]===void 0&&(me[ce]=Se[ce]);return F(P,de,me)},Je.createRef=function(){return{current:null}},Je.forwardRef=function(P){return{$$typeof:o,render:P}},Je.isValidElement=A,Je.lazy=function(P){return{$$typeof:d,_payload:{_status:-1,_result:P},_init:j}},Je.memo=function(P,H){return{$$typeof:h,type:P,compare:H===void 0?null:H}},Je.startTransition=function(P){var H=R.T,ne={};R.T=ne;try{var ce=P(),me=R.S;me!==null&&me(ne,ce),typeof ce=="object"&&ce!==null&&typeof ce.then=="function"&&ce.then(_,ee)}catch(de){ee(de)}finally{H!==null&&ne.types!==null&&(H.types=ne.types),R.T=H}},Je.unstable_useCacheRefresh=function(){return R.H.useCacheRefresh()},Je.use=function(P){return R.H.use(P)},Je.useActionState=function(P,H,ne){return R.H.useActionState(P,H,ne)},Je.useCallback=function(P,H){return R.H.useCallback(P,H)},Je.useContext=function(P){return R.H.useContext(P)},Je.useDebugValue=function(){},Je.useDeferredValue=function(P,H){return R.H.useDeferredValue(P,H)},Je.useEffect=function(P,H){return R.H.useEffect(P,H)},Je.useEffectEvent=function(P){return R.H.useEffectEvent(P)},Je.useId=function(){return R.H.useId()},Je.useImperativeHandle=function(P,H,ne){return R.H.useImperativeHandle(P,H,ne)},Je.useInsertionEffect=function(P,H){return R.H.useInsertionEffect(P,H)},Je.useLayoutEffect=function(P,H){return R.H.useLayoutEffect(P,H)},Je.useMemo=function(P,H){return R.H.useMemo(P,H)},Je.useOptimistic=function(P,H){return R.H.useOptimistic(P,H)},Je.useReducer=function(P,H,ne){return R.H.useReducer(P,H,ne)},Je.useRef=function(P){return R.H.useRef(P)},Je.useState=function(P){return R.H.useState(P)},Je.useSyncExternalStore=function(P,H,ne){return R.H.useSyncExternalStore(P,H,ne)},Je.useTransition=function(){return R.H.useTransition()},Je.version="19.2.3",Je}var pR;function vC(){return pR||(pR=1,K1.exports=NG()),K1.exports}var ke=vC();const kG=wC(ke);var X1={exports:{}},df={},Y1={exports:{}},J1={};var mR;function EG(){return mR||(mR=1,(function(n){function e(B,V){var j=B.length;B.push(V);e:for(;0<j;){var ee=j-1>>>1,ae=B[ee];if(0<r(ae,V))B[ee]=V,B[j]=ae,j=ee;else break e}}function t(B){return B.length===0?null:B[0]}function s(B){if(B.length===0)return null;var V=B[0],j=B.pop();if(j!==V){B[0]=j;e:for(var ee=0,ae=B.length,P=ae>>>1;ee<P;){var H=2*(ee+1)-1,ne=B[H],ce=H+1,me=B[ce];if(0>r(ne,j))ce<ae&&0>r(me,ne)?(B[ee]=me,B[ce]=j,ee=ce):(B[ee]=ne,B[H]=j,ee=H);else if(ce<ae&&0>r(me,j))B[ee]=me,B[ce]=j,ee=ce;else break e}}return V}function r(B,V){var j=B.sortIndex-V.sortIndex;return j!==0?j:B.id-V.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var u=[],h=[],d=1,p=null,m=3,y=!1,b=!1,x=!1,w=!1,S=typeof setTimeout=="function"?setTimeout:null,C=typeof clearTimeout=="function"?clearTimeout:null,N=typeof setImmediate<"u"?setImmediate:null;function k(B){for(var V=t(h);V!==null;){if(V.callback===null)s(h);else if(V.startTime<=B)s(h),V.sortIndex=V.expirationTime,e(u,V);else break;V=t(h)}}function E(B){if(x=!1,k(B),!b)if(t(u)!==null)b=!0,_||(_=!0,U());else{var V=t(h);V!==null&&Z(E,V.startTime-B)}}var _=!1,R=-1,O=5,F=-1;function L(){return w?!0:!(n.unstable_now()-F<O)}function A(){if(w=!1,_){var B=n.unstable_now();F=B;var V=!0;try{e:{b=!1,x&&(x=!1,C(R),R=-1),y=!0;var j=m;try{t:{for(k(B),p=t(u);p!==null&&!(p.expirationTime>B&&L());){var ee=p.callback;if(typeof ee=="function"){p.callback=null,m=p.priorityLevel;var ae=ee(p.expirationTime<=B);if(B=n.unstable_now(),typeof ae=="function"){p.callback=ae,k(B),V=!0;break t}p===t(u)&&s(u),k(B)}else s(u);p=t(u)}if(p!==null)V=!0;else{var P=t(h);P!==null&&Z(E,P.startTime-B),V=!1}}break e}finally{p=null,m=j,y=!1}V=void 0}}finally{V?U():_=!1}}}var U;if(typeof N=="function")U=function(){N(A)};else if(typeof MessageChannel<"u"){var Y=new MessageChannel,te=Y.port2;Y.port1.onmessage=A,U=function(){te.postMessage(null)}}else U=function(){S(A,0)};function Z(B,V){R=S(function(){B(n.unstable_now())},V)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(B){B.callback=null},n.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):O=0<B?Math.floor(1e3/B):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(B){switch(m){case 1:case 2:case 3:var V=3;break;default:V=m}var j=m;m=V;try{return B()}finally{m=j}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(B,V){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var j=m;m=B;try{return V()}finally{m=j}},n.unstable_scheduleCallback=function(B,V,j){var ee=n.unstable_now();switch(typeof j=="object"&&j!==null?(j=j.delay,j=typeof j=="number"&&0<j?ee+j:ee):j=ee,B){case 1:var ae=-1;break;case 2:ae=250;break;case 5:ae=1073741823;break;case 4:ae=1e4;break;default:ae=5e3}return ae=j+ae,B={id:d++,callback:V,priorityLevel:B,startTime:j,expirationTime:ae,sortIndex:-1},j>ee?(B.sortIndex=j,e(h,B),t(u)===null&&B===t(h)&&(x?(C(R),R=-1):x=!0,Z(E,j-ee))):(B.sortIndex=ae,e(u,B),b||y||(b=!0,_||(_=!0,U()))),B},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(B){var V=m;return function(){var j=m;m=V;try{return B.apply(this,arguments)}finally{m=j}}}})(J1)),J1}var gR;function $G(){return gR||(gR=1,Y1.exports=EG()),Y1.exports}var Z1={exports:{}},ds={};var yR;function IG(){if(yR)return ds;yR=1;var n=vC();function e(u){var h="https://react.dev/errors/"+u;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+u+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(u,h,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:u,containerInfo:h,implementation:d}}var a=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(u,h){if(u==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return ds.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,ds.createPortal=function(u,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(e(299));return i(u,h,null,d)},ds.flushSync=function(u){var h=a.T,d=s.p;try{if(a.T=null,s.p=2,u)return u()}finally{a.T=h,s.p=d,s.d.f()}},ds.preconnect=function(u,h){typeof u=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(u,h))},ds.prefetchDNS=function(u){typeof u=="string"&&s.d.D(u)},ds.preinit=function(u,h){if(typeof u=="string"&&h&&typeof h.as=="string"){var d=h.as,p=o(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(u,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(u,{crossOrigin:p,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},ds.preinitModule=function(u,h){if(typeof u=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=o(h.as,h.crossOrigin);s.d.M(u,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(u)},ds.preload=function(u,h){if(typeof u=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,p=o(d,h.crossOrigin);s.d.L(u,d,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},ds.preloadModule=function(u,h){if(typeof u=="string")if(h){var d=o(h.as,h.crossOrigin);s.d.m(u,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(u)},ds.requestFormReset=function(u){s.d.r(u)},ds.unstable_batchedUpdates=function(u,h){return u(h)},ds.useFormState=function(u,h,d){return a.H.useFormState(u,h,d)},ds.useFormStatus=function(){return a.H.useHostTransitionStatus()},ds.version="19.2.3",ds}var bR;function _G(){if(bR)return Z1.exports;bR=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),Z1.exports=IG(),Z1.exports}var xR;function AG(){if(xR)return df;xR=1;var n=$G(),e=vC(),t=_G();function s(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)c+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function i(l){var c=l,f=l;if(l.alternate)for(;c.return;)c=c.return;else{l=c;do c=l,(c.flags&4098)!==0&&(f=c.return),l=c.return;while(l)}return c.tag===3?f:null}function a(l){if(l.tag===13){var c=l.memoizedState;if(c===null&&(l=l.alternate,l!==null&&(c=l.memoizedState)),c!==null)return c.dehydrated}return null}function o(l){if(l.tag===31){var c=l.memoizedState;if(c===null&&(l=l.alternate,l!==null&&(c=l.memoizedState)),c!==null)return c.dehydrated}return null}function u(l){if(i(l)!==l)throw Error(s(188))}function h(l){var c=l.alternate;if(!c){if(c=i(l),c===null)throw Error(s(188));return c!==l?null:l}for(var f=l,g=c;;){var v=f.return;if(v===null)break;var T=v.alternate;if(T===null){if(g=v.return,g!==null){f=g;continue}break}if(v.child===T.child){for(T=v.child;T;){if(T===f)return u(v),l;if(T===g)return u(v),c;T=T.sibling}throw Error(s(188))}if(f.return!==g.return)f=v,g=T;else{for(var I=!1,z=v.child;z;){if(z===f){I=!0,f=v,g=T;break}if(z===g){I=!0,g=v,f=T;break}z=z.sibling}if(!I){for(z=T.child;z;){if(z===f){I=!0,f=T,g=v;break}if(z===g){I=!0,g=T,f=v;break}z=z.sibling}if(!I)throw Error(s(189))}}if(f.alternate!==g)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?l:c}function d(l){var c=l.tag;if(c===5||c===26||c===27||c===6)return l;for(l=l.child;l!==null;){if(c=d(l),c!==null)return c;l=l.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),C=Symbol.for("react.consumer"),N=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),R=Symbol.for("react.memo"),O=Symbol.for("react.lazy"),F=Symbol.for("react.activity"),L=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function U(l){return l===null||typeof l!="object"?null:(l=A&&l[A]||l["@@iterator"],typeof l=="function"?l:null)}var Y=Symbol.for("react.client.reference");function te(l){if(l==null)return null;if(typeof l=="function")return l.$$typeof===Y?null:l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case x:return"Fragment";case S:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case _:return"SuspenseList";case F:return"Activity"}if(typeof l=="object")switch(l.$$typeof){case b:return"Portal";case N:return l.displayName||"Context";case C:return(l._context.displayName||"Context")+".Consumer";case k:var c=l.render;return l=l.displayName,l||(l=c.displayName||c.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case R:return c=l.displayName||null,c!==null?c:te(l.type)||"Memo";case O:c=l._payload,l=l._init;try{return te(l(c))}catch{}}return null}var Z=Array.isArray,B=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,j={pending:!1,data:null,method:null,action:null},ee=[],ae=-1;function P(l){return{current:l}}function H(l){0>ae||(l.current=ee[ae],ee[ae]=null,ae--)}function ne(l,c){ae++,ee[ae]=l.current,l.current=c}var ce=P(null),me=P(null),de=P(null),Se=P(null);function Te(l,c){switch(ne(de,c),ne(me,l),ne(ce,null),c.nodeType){case 9:case 11:l=(l=c.documentElement)&&(l=l.namespaceURI)?OA(l):0;break;default:if(l=c.tagName,c=c.namespaceURI)c=OA(c),l=FA(c,l);else switch(l){case"svg":l=1;break;case"math":l=2;break;default:l=0}}H(ce),ne(ce,l)}function Ee(){H(ce),H(me),H(de)}function Ve(l){l.memoizedState!==null&&ne(Se,l);var c=ce.current,f=FA(c,l.type);c!==f&&(ne(me,l),ne(ce,f))}function je(l){me.current===l&&(H(ce),H(me)),Se.current===l&&(H(Se),of._currentValue=j)}var Ye,ft;function bt(l){if(Ye===void 0)try{throw Error()}catch(f){var c=f.stack.trim().match(/\n( *(at )?)/);Ye=c&&c[1]||"",ft=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Ye+l+ft}var St=!1;function xt(l,c){if(!l||St)return"";St=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(c){var be=function(){throw Error()};if(Object.defineProperty(be.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(be,[])}catch(fe){var ue=fe}Reflect.construct(l,[],be)}else{try{be.call()}catch(fe){ue=fe}l.call(be.prototype)}}else{try{throw Error()}catch(fe){ue=fe}(be=l())&&typeof be.catch=="function"&&be.catch(function(){})}}catch(fe){if(fe&&ue&&typeof fe.stack=="string")return[fe.stack,ue.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var v=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");v&&v.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var T=g.DetermineComponentFrameRoot(),I=T[0],z=T[1];if(I&&z){var q=I.split(`
`),le=z.split(`
`);for(v=g=0;g<q.length&&!q[g].includes("DetermineComponentFrameRoot");)g++;for(;v<le.length&&!le[v].includes("DetermineComponentFrameRoot");)v++;if(g===q.length||v===le.length)for(g=q.length-1,v=le.length-1;1<=g&&0<=v&&q[g]!==le[v];)v--;for(;1<=g&&0<=v;g--,v--)if(q[g]!==le[v]){if(g!==1||v!==1)do if(g--,v--,0>v||q[g]!==le[v]){var ge=`
`+q[g].replace(" at new "," at ");return l.displayName&&ge.includes("<anonymous>")&&(ge=ge.replace("<anonymous>",l.displayName)),ge}while(1<=g&&0<=v);break}}}finally{St=!1,Error.prepareStackTrace=f}return(f=l?l.displayName||l.name:"")?bt(f):""}function Pt(l,c){switch(l.tag){case 26:case 27:case 5:return bt(l.type);case 16:return bt("Lazy");case 13:return l.child!==c&&c!==null?bt("Suspense Fallback"):bt("Suspense");case 19:return bt("SuspenseList");case 0:case 15:return xt(l.type,!1);case 11:return xt(l.type.render,!1);case 1:return xt(l.type,!0);case 31:return bt("Activity");default:return""}}function _t(l){try{var c="",f=null;do c+=Pt(l,f),f=l,l=l.return;while(l);return c}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var nr=Object.prototype.hasOwnProperty,nn=n.unstable_scheduleCallback,kr=n.unstable_cancelCallback,Ts=n.unstable_shouldYield,Xi=n.unstable_requestPaint,Vt=n.unstable_now,Xr=n.unstable_getCurrentPriorityLevel,Yr=n.unstable_ImmediatePriority,Jr=n.unstable_UserBlockingPriority,sr=n.unstable_NormalPriority,Xo=n.unstable_LowPriority,Nu=n.unstable_IdlePriority,bd=n.log,Ow=n.unstable_setDisableYieldValue,Ti=null,Cs=null;function Ci(l){if(typeof bd=="function"&&Ow(l),Cs&&typeof Cs.setStrictMode=="function")try{Cs.setStrictMode(Ti,l)}catch{}}var rr=Math.clz32?Math.clz32:oj,ij=Math.log,aj=Math.LN2;function oj(l){return l>>>=0,l===0?32:31-(ij(l)/aj|0)|0}var lg=256,ug=262144,cg=4194304;function Yo(l){var c=l&42;if(c!==0)return c;switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return l&261888;case 262144:case 524288:case 1048576:case 2097152:return l&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return l&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return l}}function hg(l,c,f){var g=l.pendingLanes;if(g===0)return 0;var v=0,T=l.suspendedLanes,I=l.pingedLanes;l=l.warmLanes;var z=g&134217727;return z!==0?(g=z&~T,g!==0?v=Yo(g):(I&=z,I!==0?v=Yo(I):f||(f=z&~l,f!==0&&(v=Yo(f))))):(z=g&~T,z!==0?v=Yo(z):I!==0?v=Yo(I):f||(f=g&~l,f!==0&&(v=Yo(f)))),v===0?0:c!==0&&c!==v&&(c&T)===0&&(T=v&-v,f=c&-c,T>=f||T===32&&(f&4194048)!==0)?c:v}function xd(l,c){return(l.pendingLanes&~(l.suspendedLanes&~l.pingedLanes)&c)===0}function lj(l,c){switch(l){case 1:case 2:case 4:case 8:case 64:return c+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function m$(){var l=cg;return cg<<=1,(cg&62914560)===0&&(cg=4194304),l}function Fw(l){for(var c=[],f=0;31>f;f++)c.push(l);return c}function wd(l,c){l.pendingLanes|=c,c!==268435456&&(l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0)}function uj(l,c,f,g,v,T){var I=l.pendingLanes;l.pendingLanes=f,l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0,l.expiredLanes&=f,l.entangledLanes&=f,l.errorRecoveryDisabledLanes&=f,l.shellSuspendCounter=0;var z=l.entanglements,q=l.expirationTimes,le=l.hiddenUpdates;for(f=I&~f;0<f;){var ge=31-rr(f),be=1<<ge;z[ge]=0,q[ge]=-1;var ue=le[ge];if(ue!==null)for(le[ge]=null,ge=0;ge<ue.length;ge++){var fe=ue[ge];fe!==null&&(fe.lane&=-536870913)}f&=~be}g!==0&&g$(l,g,0),T!==0&&v===0&&l.tag!==0&&(l.suspendedLanes|=T&~(I&~c))}function g$(l,c,f){l.pendingLanes|=c,l.suspendedLanes&=~c;var g=31-rr(c);l.entangledLanes|=c,l.entanglements[g]=l.entanglements[g]|1073741824|f&261930}function y$(l,c){var f=l.entangledLanes|=c;for(l=l.entanglements;f;){var g=31-rr(f),v=1<<g;v&c|l[g]&c&&(l[g]|=c),f&=~v}}function b$(l,c){var f=c&-c;return f=(f&42)!==0?1:Lw(f),(f&(l.suspendedLanes|c))!==0?0:f}function Lw(l){switch(l){case 2:l=1;break;case 8:l=4;break;case 32:l=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:l=128;break;case 268435456:l=134217728;break;default:l=0}return l}function Mw(l){return l&=-l,2<l?8<l?(l&134217727)!==0?32:268435456:8:2}function x$(){var l=V.p;return l!==0?l:(l=window.event,l===void 0?32:rR(l.type))}function w$(l,c){var f=V.p;try{return V.p=l,c()}finally{V.p=f}}var Va=Math.random().toString(36).slice(2),ns="__reactFiber$"+Va,Ls="__reactProps$"+Va,ku="__reactContainer$"+Va,zw="__reactEvents$"+Va,cj="__reactListeners$"+Va,hj="__reactHandles$"+Va,v$="__reactResources$"+Va,vd="__reactMarker$"+Va;function Pw(l){delete l[ns],delete l[Ls],delete l[zw],delete l[cj],delete l[hj]}function Eu(l){var c=l[ns];if(c)return c;for(var f=l.parentNode;f;){if(c=f[ku]||f[ns]){if(f=c.alternate,c.child!==null||f!==null&&f.child!==null)for(l=UA(l);l!==null;){if(f=l[ns])return f;l=UA(l)}return c}l=f,f=l.parentNode}return null}function $u(l){if(l=l[ns]||l[ku]){var c=l.tag;if(c===5||c===6||c===13||c===31||c===26||c===27||c===3)return l}return null}function Sd(l){var c=l.tag;if(c===5||c===26||c===27||c===6)return l.stateNode;throw Error(s(33))}function Iu(l){var c=l[v$];return c||(c=l[v$]={hoistableStyles:new Map,hoistableScripts:new Map}),c}function jn(l){l[vd]=!0}var S$=new Set,T$={};function Jo(l,c){_u(l,c),_u(l+"Capture",c)}function _u(l,c){for(T$[l]=c,l=0;l<c.length;l++)S$.add(c[l])}var dj=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),C$={},N$={};function fj(l){return nr.call(N$,l)?!0:nr.call(C$,l)?!1:dj.test(l)?N$[l]=!0:(C$[l]=!0,!1)}function dg(l,c,f){if(fj(c))if(f===null)l.removeAttribute(c);else{switch(typeof f){case"undefined":case"function":case"symbol":l.removeAttribute(c);return;case"boolean":var g=c.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){l.removeAttribute(c);return}}l.setAttribute(c,""+f)}}function fg(l,c,f){if(f===null)l.removeAttribute(c);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(c);return}l.setAttribute(c,""+f)}}function Yi(l,c,f,g){if(g===null)l.removeAttribute(f);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(f);return}l.setAttributeNS(c,f,""+g)}}function Er(l){switch(typeof l){case"bigint":case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function k$(l){var c=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function pj(l,c,f){var g=Object.getOwnPropertyDescriptor(l.constructor.prototype,c);if(!l.hasOwnProperty(c)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var v=g.get,T=g.set;return Object.defineProperty(l,c,{configurable:!0,get:function(){return v.call(this)},set:function(I){f=""+I,T.call(this,I)}}),Object.defineProperty(l,c,{enumerable:g.enumerable}),{getValue:function(){return f},setValue:function(I){f=""+I},stopTracking:function(){l._valueTracker=null,delete l[c]}}}}function Bw(l){if(!l._valueTracker){var c=k$(l)?"checked":"value";l._valueTracker=pj(l,c,""+l[c])}}function E$(l){if(!l)return!1;var c=l._valueTracker;if(!c)return!0;var f=c.getValue(),g="";return l&&(g=k$(l)?l.checked?"true":"false":l.value),l=g,l!==f?(c.setValue(l),!0):!1}function pg(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}var mj=/[\n"\\]/g;function $r(l){return l.replace(mj,function(c){return"\\"+c.charCodeAt(0).toString(16)+" "})}function Vw(l,c,f,g,v,T,I,z){l.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?l.type=I:l.removeAttribute("type"),c!=null?I==="number"?(c===0&&l.value===""||l.value!=c)&&(l.value=""+Er(c)):l.value!==""+Er(c)&&(l.value=""+Er(c)):I!=="submit"&&I!=="reset"||l.removeAttribute("value"),c!=null?Uw(l,I,Er(c)):f!=null?Uw(l,I,Er(f)):g!=null&&l.removeAttribute("value"),v==null&&T!=null&&(l.defaultChecked=!!T),v!=null&&(l.checked=v&&typeof v!="function"&&typeof v!="symbol"),z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?l.name=""+Er(z):l.removeAttribute("name")}function $$(l,c,f,g,v,T,I,z){if(T!=null&&typeof T!="function"&&typeof T!="symbol"&&typeof T!="boolean"&&(l.type=T),c!=null||f!=null){if(!(T!=="submit"&&T!=="reset"||c!=null)){Bw(l);return}f=f!=null?""+Er(f):"",c=c!=null?""+Er(c):f,z||c===l.value||(l.value=c),l.defaultValue=c}g=g??v,g=typeof g!="function"&&typeof g!="symbol"&&!!g,l.checked=z?l.checked:!!g,l.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(l.name=I),Bw(l)}function Uw(l,c,f){c==="number"&&pg(l.ownerDocument)===l||l.defaultValue===""+f||(l.defaultValue=""+f)}function Au(l,c,f,g){if(l=l.options,c){c={};for(var v=0;v<f.length;v++)c["$"+f[v]]=!0;for(f=0;f<l.length;f++)v=c.hasOwnProperty("$"+l[f].value),l[f].selected!==v&&(l[f].selected=v),v&&g&&(l[f].defaultSelected=!0)}else{for(f=""+Er(f),c=null,v=0;v<l.length;v++){if(l[v].value===f){l[v].selected=!0,g&&(l[v].defaultSelected=!0);return}c!==null||l[v].disabled||(c=l[v])}c!==null&&(c.selected=!0)}}function I$(l,c,f){if(c!=null&&(c=""+Er(c),c!==l.value&&(l.value=c),f==null)){l.defaultValue!==c&&(l.defaultValue=c);return}l.defaultValue=f!=null?""+Er(f):""}function _$(l,c,f,g){if(c==null){if(g!=null){if(f!=null)throw Error(s(92));if(Z(g)){if(1<g.length)throw Error(s(93));g=g[0]}f=g}f==null&&(f=""),c=f}f=Er(c),l.defaultValue=f,g=l.textContent,g===f&&g!==""&&g!==null&&(l.value=g),Bw(l)}function Ru(l,c){if(c){var f=l.firstChild;if(f&&f===l.lastChild&&f.nodeType===3){f.nodeValue=c;return}}l.textContent=c}var gj=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function A$(l,c,f){var g=c.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?g?l.setProperty(c,""):c==="float"?l.cssFloat="":l[c]="":g?l.setProperty(c,f):typeof f!="number"||f===0||gj.has(c)?c==="float"?l.cssFloat=f:l[c]=(""+f).trim():l[c]=f+"px"}function R$(l,c,f){if(c!=null&&typeof c!="object")throw Error(s(62));if(l=l.style,f!=null){for(var g in f)!f.hasOwnProperty(g)||c!=null&&c.hasOwnProperty(g)||(g.indexOf("--")===0?l.setProperty(g,""):g==="float"?l.cssFloat="":l[g]="");for(var v in c)g=c[v],c.hasOwnProperty(v)&&f[v]!==g&&A$(l,v,g)}else for(var T in c)c.hasOwnProperty(T)&&A$(l,T,c[T])}function jw(l){if(l.indexOf("-")===-1)return!1;switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var yj=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),bj=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function mg(l){return bj.test(""+l)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":l}function Ji(){}var Ww=null;function Gw(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var Du=null,Ou=null;function D$(l){var c=$u(l);if(c&&(l=c.stateNode)){var f=l[Ls]||null;e:switch(l=c.stateNode,c.type){case"input":if(Vw(l,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),c=f.name,f.type==="radio"&&c!=null){for(f=l;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+$r(""+c)+'"][type="radio"]'),c=0;c<f.length;c++){var g=f[c];if(g!==l&&g.form===l.form){var v=g[Ls]||null;if(!v)throw Error(s(90));Vw(g,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name)}}for(c=0;c<f.length;c++)g=f[c],g.form===l.form&&E$(g)}break e;case"textarea":I$(l,f.value,f.defaultValue);break e;case"select":c=f.value,c!=null&&Au(l,!!f.multiple,c,!1)}}}var Hw=!1;function O$(l,c,f){if(Hw)return l(c,f);Hw=!0;try{var g=l(c);return g}finally{if(Hw=!1,(Du!==null||Ou!==null)&&(ny(),Du&&(c=Du,l=Ou,Ou=Du=null,D$(c),l)))for(c=0;c<l.length;c++)D$(l[c])}}function Td(l,c){var f=l.stateNode;if(f===null)return null;var g=f[Ls]||null;if(g===null)return null;f=g[c];e:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(l=l.type,g=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!g;break e;default:l=!1}if(l)return null;if(f&&typeof f!="function")throw Error(s(231,c,typeof f));return f}var Zi=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),qw=!1;if(Zi)try{var Cd={};Object.defineProperty(Cd,"passive",{get:function(){qw=!0}}),window.addEventListener("test",Cd,Cd),window.removeEventListener("test",Cd,Cd)}catch{qw=!1}var Ua=null,Kw=null,gg=null;function F$(){if(gg)return gg;var l,c=Kw,f=c.length,g,v="value"in Ua?Ua.value:Ua.textContent,T=v.length;for(l=0;l<f&&c[l]===v[l];l++);var I=f-l;for(g=1;g<=I&&c[f-g]===v[T-g];g++);return gg=v.slice(l,1<g?1-g:void 0)}function yg(l){var c=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&c===13&&(l=13)):l=c,l===10&&(l=13),32<=l||l===13?l:0}function bg(){return!0}function L$(){return!1}function Ms(l){function c(f,g,v,T,I){this._reactName=f,this._targetInst=v,this.type=g,this.nativeEvent=T,this.target=I,this.currentTarget=null;for(var z in l)l.hasOwnProperty(z)&&(f=l[z],this[z]=f?f(T):T[z]);return this.isDefaultPrevented=(T.defaultPrevented!=null?T.defaultPrevented:T.returnValue===!1)?bg:L$,this.isPropagationStopped=L$,this}return p(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=bg)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=bg)},persist:function(){},isPersistent:bg}),c}var Zo={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},xg=Ms(Zo),Nd=p({},Zo,{view:0,detail:0}),xj=Ms(Nd),Xw,Yw,kd,wg=p({},Nd,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Zw,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==kd&&(kd&&l.type==="mousemove"?(Xw=l.screenX-kd.screenX,Yw=l.screenY-kd.screenY):Yw=Xw=0,kd=l),Xw)},movementY:function(l){return"movementY"in l?l.movementY:Yw}}),M$=Ms(wg),wj=p({},wg,{dataTransfer:0}),vj=Ms(wj),Sj=p({},Nd,{relatedTarget:0}),Jw=Ms(Sj),Tj=p({},Zo,{animationName:0,elapsedTime:0,pseudoElement:0}),Cj=Ms(Tj),Nj=p({},Zo,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),kj=Ms(Nj),Ej=p({},Zo,{data:0}),z$=Ms(Ej),$j={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Ij={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},_j={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Aj(l){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(l):(l=_j[l])?!!c[l]:!1}function Zw(){return Aj}var Rj=p({},Nd,{key:function(l){if(l.key){var c=$j[l.key]||l.key;if(c!=="Unidentified")return c}return l.type==="keypress"?(l=yg(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?Ij[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Zw,charCode:function(l){return l.type==="keypress"?yg(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?yg(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),Dj=Ms(Rj),Oj=p({},wg,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),P$=Ms(Oj),Fj=p({},Nd,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Zw}),Lj=Ms(Fj),Mj=p({},Zo,{propertyName:0,elapsedTime:0,pseudoElement:0}),zj=Ms(Mj),Pj=p({},wg,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),Bj=Ms(Pj),Vj=p({},Zo,{newState:0,oldState:0}),Uj=Ms(Vj),jj=[9,13,27,32],Qw=Zi&&"CompositionEvent"in window,Ed=null;Zi&&"documentMode"in document&&(Ed=document.documentMode);var Wj=Zi&&"TextEvent"in window&&!Ed,B$=Zi&&(!Qw||Ed&&8<Ed&&11>=Ed),V$=" ",U$=!1;function j$(l,c){switch(l){case"keyup":return jj.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function W$(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var Fu=!1;function Gj(l,c){switch(l){case"compositionend":return W$(c);case"keypress":return c.which!==32?null:(U$=!0,V$);case"textInput":return l=c.data,l===V$&&U$?null:l;default:return null}}function Hj(l,c){if(Fu)return l==="compositionend"||!Qw&&j$(l,c)?(l=F$(),gg=Kw=Ua=null,Fu=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return B$&&c.locale!=="ko"?null:c.data;default:return null}}var qj={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function G$(l){var c=l&&l.nodeName&&l.nodeName.toLowerCase();return c==="input"?!!qj[l.type]:c==="textarea"}function H$(l,c,f,g){Du?Ou?Ou.push(g):Ou=[g]:Du=g,c=uy(c,"onChange"),0<c.length&&(f=new xg("onChange","change",null,f,g),l.push({event:f,listeners:c}))}var $d=null,Id=null;function Kj(l){$A(l,0)}function vg(l){var c=Sd(l);if(E$(c))return l}function q$(l,c){if(l==="change")return c}var K$=!1;if(Zi){var ev;if(Zi){var tv="oninput"in document;if(!tv){var X$=document.createElement("div");X$.setAttribute("oninput","return;"),tv=typeof X$.oninput=="function"}ev=tv}else ev=!1;K$=ev&&(!document.documentMode||9<document.documentMode)}function Y$(){$d&&($d.detachEvent("onpropertychange",J$),Id=$d=null)}function J$(l){if(l.propertyName==="value"&&vg(Id)){var c=[];H$(c,Id,l,Gw(l)),O$(Kj,c)}}function Xj(l,c,f){l==="focusin"?(Y$(),$d=c,Id=f,$d.attachEvent("onpropertychange",J$)):l==="focusout"&&Y$()}function Yj(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return vg(Id)}function Jj(l,c){if(l==="click")return vg(c)}function Zj(l,c){if(l==="input"||l==="change")return vg(c)}function Qj(l,c){return l===c&&(l!==0||1/l===1/c)||l!==l&&c!==c}var ir=typeof Object.is=="function"?Object.is:Qj;function _d(l,c){if(ir(l,c))return!0;if(typeof l!="object"||l===null||typeof c!="object"||c===null)return!1;var f=Object.keys(l),g=Object.keys(c);if(f.length!==g.length)return!1;for(g=0;g<f.length;g++){var v=f[g];if(!nr.call(c,v)||!ir(l[v],c[v]))return!1}return!0}function Z$(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function Q$(l,c){var f=Z$(l);l=0;for(var g;f;){if(f.nodeType===3){if(g=l+f.textContent.length,l<=c&&g>=c)return{node:f,offset:c-l};l=g}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=Z$(f)}}function eI(l,c){return l&&c?l===c?!0:l&&l.nodeType===3?!1:c&&c.nodeType===3?eI(l,c.parentNode):"contains"in l?l.contains(c):l.compareDocumentPosition?!!(l.compareDocumentPosition(c)&16):!1:!1}function tI(l){l=l!=null&&l.ownerDocument!=null&&l.ownerDocument.defaultView!=null?l.ownerDocument.defaultView:window;for(var c=pg(l.document);c instanceof l.HTMLIFrameElement;){try{var f=typeof c.contentWindow.location.href=="string"}catch{f=!1}if(f)l=c.contentWindow;else break;c=pg(l.document)}return c}function nv(l){var c=l&&l.nodeName&&l.nodeName.toLowerCase();return c&&(c==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||c==="textarea"||l.contentEditable==="true")}var eW=Zi&&"documentMode"in document&&11>=document.documentMode,Lu=null,sv=null,Ad=null,rv=!1;function nI(l,c,f){var g=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;rv||Lu==null||Lu!==pg(g)||(g=Lu,"selectionStart"in g&&nv(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),Ad&&_d(Ad,g)||(Ad=g,g=uy(sv,"onSelect"),0<g.length&&(c=new xg("onSelect","select",null,c,f),l.push({event:c,listeners:g}),c.target=Lu)))}function Qo(l,c){var f={};return f[l.toLowerCase()]=c.toLowerCase(),f["Webkit"+l]="webkit"+c,f["Moz"+l]="moz"+c,f}var Mu={animationend:Qo("Animation","AnimationEnd"),animationiteration:Qo("Animation","AnimationIteration"),animationstart:Qo("Animation","AnimationStart"),transitionrun:Qo("Transition","TransitionRun"),transitionstart:Qo("Transition","TransitionStart"),transitioncancel:Qo("Transition","TransitionCancel"),transitionend:Qo("Transition","TransitionEnd")},iv={},sI={};Zi&&(sI=document.createElement("div").style,"AnimationEvent"in window||(delete Mu.animationend.animation,delete Mu.animationiteration.animation,delete Mu.animationstart.animation),"TransitionEvent"in window||delete Mu.transitionend.transition);function el(l){if(iv[l])return iv[l];if(!Mu[l])return l;var c=Mu[l],f;for(f in c)if(c.hasOwnProperty(f)&&f in sI)return iv[l]=c[f];return l}var rI=el("animationend"),iI=el("animationiteration"),aI=el("animationstart"),tW=el("transitionrun"),nW=el("transitionstart"),sW=el("transitioncancel"),oI=el("transitionend"),lI=new Map,av="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");av.push("scrollEnd");function Zr(l,c){lI.set(l,c),Jo(c,[l])}var Sg=typeof reportError=="function"?reportError:function(l){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var c=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof l=="object"&&l!==null&&typeof l.message=="string"?String(l.message):String(l),error:l});if(!window.dispatchEvent(c))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",l);return}console.error(l)},Ir=[],zu=0,ov=0;function Tg(){for(var l=zu,c=ov=zu=0;c<l;){var f=Ir[c];Ir[c++]=null;var g=Ir[c];Ir[c++]=null;var v=Ir[c];Ir[c++]=null;var T=Ir[c];if(Ir[c++]=null,g!==null&&v!==null){var I=g.pending;I===null?v.next=v:(v.next=I.next,I.next=v),g.pending=v}T!==0&&uI(f,v,T)}}function Cg(l,c,f,g){Ir[zu++]=l,Ir[zu++]=c,Ir[zu++]=f,Ir[zu++]=g,ov|=g,l.lanes|=g,l=l.alternate,l!==null&&(l.lanes|=g)}function lv(l,c,f,g){return Cg(l,c,f,g),Ng(l)}function tl(l,c){return Cg(l,null,null,c),Ng(l)}function uI(l,c,f){l.lanes|=f;var g=l.alternate;g!==null&&(g.lanes|=f);for(var v=!1,T=l.return;T!==null;)T.childLanes|=f,g=T.alternate,g!==null&&(g.childLanes|=f),T.tag===22&&(l=T.stateNode,l===null||l._visibility&1||(v=!0)),l=T,T=T.return;return l.tag===3?(T=l.stateNode,v&&c!==null&&(v=31-rr(f),l=T.hiddenUpdates,g=l[v],g===null?l[v]=[c]:g.push(c),c.lane=f|536870912),T):null}function Ng(l){if(50<Qd)throw Qd=0,y1=null,Error(s(185));for(var c=l.return;c!==null;)l=c,c=l.return;return l.tag===3?l.stateNode:null}var Pu={};function rW(l,c,f,g){this.tag=l,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ar(l,c,f,g){return new rW(l,c,f,g)}function uv(l){return l=l.prototype,!(!l||!l.isReactComponent)}function Qi(l,c){var f=l.alternate;return f===null?(f=ar(l.tag,c,l.key,l.mode),f.elementType=l.elementType,f.type=l.type,f.stateNode=l.stateNode,f.alternate=l,l.alternate=f):(f.pendingProps=c,f.type=l.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=l.flags&65011712,f.childLanes=l.childLanes,f.lanes=l.lanes,f.child=l.child,f.memoizedProps=l.memoizedProps,f.memoizedState=l.memoizedState,f.updateQueue=l.updateQueue,c=l.dependencies,f.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},f.sibling=l.sibling,f.index=l.index,f.ref=l.ref,f.refCleanup=l.refCleanup,f}function cI(l,c){l.flags&=65011714;var f=l.alternate;return f===null?(l.childLanes=0,l.lanes=c,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=f.childLanes,l.lanes=f.lanes,l.child=f.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=f.memoizedProps,l.memoizedState=f.memoizedState,l.updateQueue=f.updateQueue,l.type=f.type,c=f.dependencies,l.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext}),l}function kg(l,c,f,g,v,T){var I=0;if(g=l,typeof l=="function")uv(l)&&(I=1);else if(typeof l=="string")I=uG(l,f,ce.current)?26:l==="html"||l==="head"||l==="body"?27:5;else e:switch(l){case F:return l=ar(31,f,c,v),l.elementType=F,l.lanes=T,l;case x:return nl(f.children,v,T,c);case w:I=8,v|=24;break;case S:return l=ar(12,f,c,v|2),l.elementType=S,l.lanes=T,l;case E:return l=ar(13,f,c,v),l.elementType=E,l.lanes=T,l;case _:return l=ar(19,f,c,v),l.elementType=_,l.lanes=T,l;default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case N:I=10;break e;case C:I=9;break e;case k:I=11;break e;case R:I=14;break e;case O:I=16,g=null;break e}I=29,f=Error(s(130,l===null?"null":typeof l,"")),g=null}return c=ar(I,f,c,v),c.elementType=l,c.type=g,c.lanes=T,c}function nl(l,c,f,g){return l=ar(7,l,g,c),l.lanes=f,l}function cv(l,c,f){return l=ar(6,l,null,c),l.lanes=f,l}function hI(l){var c=ar(18,null,null,0);return c.stateNode=l,c}function hv(l,c,f){return c=ar(4,l.children!==null?l.children:[],l.key,c),c.lanes=f,c.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},c}var dI=new WeakMap;function _r(l,c){if(typeof l=="object"&&l!==null){var f=dI.get(l);return f!==void 0?f:(c={value:l,source:c,stack:_t(c)},dI.set(l,c),c)}return{value:l,source:c,stack:_t(c)}}var Bu=[],Vu=0,Eg=null,Rd=0,Ar=[],Rr=0,ja=null,Ni=1,ki="";function ea(l,c){Bu[Vu++]=Rd,Bu[Vu++]=Eg,Eg=l,Rd=c}function fI(l,c,f){Ar[Rr++]=Ni,Ar[Rr++]=ki,Ar[Rr++]=ja,ja=l;var g=Ni;l=ki;var v=32-rr(g)-1;g&=~(1<<v),f+=1;var T=32-rr(c)+v;if(30<T){var I=v-v%5;T=(g&(1<<I)-1).toString(32),g>>=I,v-=I,Ni=1<<32-rr(c)+v|f<<v|g,ki=T+l}else Ni=1<<T|f<<v|g,ki=l}function dv(l){l.return!==null&&(ea(l,1),fI(l,1,0))}function fv(l){for(;l===Eg;)Eg=Bu[--Vu],Bu[Vu]=null,Rd=Bu[--Vu],Bu[Vu]=null;for(;l===ja;)ja=Ar[--Rr],Ar[Rr]=null,ki=Ar[--Rr],Ar[Rr]=null,Ni=Ar[--Rr],Ar[Rr]=null}function pI(l,c){Ar[Rr++]=Ni,Ar[Rr++]=ki,Ar[Rr++]=ja,Ni=c.id,ki=c.overflow,ja=l}var ss=null,Ut=null,pt=!1,Wa=null,Dr=!1,pv=Error(s(519));function Ga(l){var c=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Dd(_r(c,l)),pv}function mI(l){var c=l.stateNode,f=l.type,g=l.memoizedProps;switch(c[ns]=l,c[Ls]=g,f){case"dialog":lt("cancel",c),lt("close",c);break;case"iframe":case"object":case"embed":lt("load",c);break;case"video":case"audio":for(f=0;f<tf.length;f++)lt(tf[f],c);break;case"source":lt("error",c);break;case"img":case"image":case"link":lt("error",c),lt("load",c);break;case"details":lt("toggle",c);break;case"input":lt("invalid",c),$$(c,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":lt("invalid",c);break;case"textarea":lt("invalid",c),_$(c,g.value,g.defaultValue,g.children)}f=g.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||c.textContent===""+f||g.suppressHydrationWarning===!0||RA(c.textContent,f)?(g.popover!=null&&(lt("beforetoggle",c),lt("toggle",c)),g.onScroll!=null&&lt("scroll",c),g.onScrollEnd!=null&&lt("scrollend",c),g.onClick!=null&&(c.onclick=Ji),c=!0):c=!1,c||Ga(l,!0)}function gI(l){for(ss=l.return;ss;)switch(ss.tag){case 5:case 31:case 13:Dr=!1;return;case 27:case 3:Dr=!0;return;default:ss=ss.return}}function Uu(l){if(l!==ss)return!1;if(!pt)return gI(l),pt=!0,!1;var c=l.tag,f;if((f=c!==3&&c!==27)&&((f=c===5)&&(f=l.type,f=!(f!=="form"&&f!=="button")||R1(l.type,l.memoizedProps)),f=!f),f&&Ut&&Ga(l),gI(l),c===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(317));Ut=VA(l)}else if(c===31){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(317));Ut=VA(l)}else c===27?(c=Ut,io(l.type)?(l=M1,M1=null,Ut=l):Ut=c):Ut=ss?Fr(l.stateNode.nextSibling):null;return!0}function sl(){Ut=ss=null,pt=!1}function mv(){var l=Wa;return l!==null&&(Vs===null?Vs=l:Vs.push.apply(Vs,l),Wa=null),l}function Dd(l){Wa===null?Wa=[l]:Wa.push(l)}var gv=P(null),rl=null,ta=null;function Ha(l,c,f){ne(gv,c._currentValue),c._currentValue=f}function na(l){l._currentValue=gv.current,H(gv)}function yv(l,c,f){for(;l!==null;){var g=l.alternate;if((l.childLanes&c)!==c?(l.childLanes|=c,g!==null&&(g.childLanes|=c)):g!==null&&(g.childLanes&c)!==c&&(g.childLanes|=c),l===f)break;l=l.return}}function bv(l,c,f,g){var v=l.child;for(v!==null&&(v.return=l);v!==null;){var T=v.dependencies;if(T!==null){var I=v.child;T=T.firstContext;e:for(;T!==null;){var z=T;T=v;for(var q=0;q<c.length;q++)if(z.context===c[q]){T.lanes|=f,z=T.alternate,z!==null&&(z.lanes|=f),yv(T.return,f,l),g||(I=null);break e}T=z.next}}else if(v.tag===18){if(I=v.return,I===null)throw Error(s(341));I.lanes|=f,T=I.alternate,T!==null&&(T.lanes|=f),yv(I,f,l),I=null}else I=v.child;if(I!==null)I.return=v;else for(I=v;I!==null;){if(I===l){I=null;break}if(v=I.sibling,v!==null){v.return=I.return,I=v;break}I=I.return}v=I}}function ju(l,c,f,g){l=null;for(var v=c,T=!1;v!==null;){if(!T){if((v.flags&524288)!==0)T=!0;else if((v.flags&262144)!==0)break}if(v.tag===10){var I=v.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var z=v.type;ir(v.pendingProps.value,I.value)||(l!==null?l.push(z):l=[z])}}else if(v===Se.current){if(I=v.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==v.memoizedState.memoizedState&&(l!==null?l.push(of):l=[of])}v=v.return}l!==null&&bv(c,l,f,g),c.flags|=262144}function $g(l){for(l=l.firstContext;l!==null;){if(!ir(l.context._currentValue,l.memoizedValue))return!0;l=l.next}return!1}function il(l){rl=l,ta=null,l=l.dependencies,l!==null&&(l.firstContext=null)}function rs(l){return yI(rl,l)}function Ig(l,c){return rl===null&&il(l),yI(l,c)}function yI(l,c){var f=c._currentValue;if(c={context:c,memoizedValue:f,next:null},ta===null){if(l===null)throw Error(s(308));ta=c,l.dependencies={lanes:0,firstContext:c},l.flags|=524288}else ta=ta.next=c;return f}var iW=typeof AbortController<"u"?AbortController:function(){var l=[],c=this.signal={aborted:!1,addEventListener:function(f,g){l.push(g)}};this.abort=function(){c.aborted=!0,l.forEach(function(f){return f()})}},aW=n.unstable_scheduleCallback,oW=n.unstable_NormalPriority,wn={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function xv(){return{controller:new iW,data:new Map,refCount:0}}function Od(l){l.refCount--,l.refCount===0&&aW(oW,function(){l.controller.abort()})}var Fd=null,wv=0,Wu=0,Gu=null;function lW(l,c){if(Fd===null){var f=Fd=[];wv=0,Wu=T1(),Gu={status:"pending",value:void 0,then:function(g){f.push(g)}}}return wv++,c.then(bI,bI),c}function bI(){if(--wv===0&&Fd!==null){Gu!==null&&(Gu.status="fulfilled");var l=Fd;Fd=null,Wu=0,Gu=null;for(var c=0;c<l.length;c++)(0,l[c])()}}function uW(l,c){var f=[],g={status:"pending",value:null,reason:null,then:function(v){f.push(v)}};return l.then(function(){g.status="fulfilled",g.value=c;for(var v=0;v<f.length;v++)(0,f[v])(c)},function(v){for(g.status="rejected",g.reason=v,v=0;v<f.length;v++)(0,f[v])(void 0)}),g}var xI=B.S;B.S=function(l,c){nA=Vt(),typeof c=="object"&&c!==null&&typeof c.then=="function"&&lW(l,c),xI!==null&&xI(l,c)};var al=P(null);function vv(){var l=al.current;return l!==null?l:Ft.pooledCache}function _g(l,c){c===null?ne(al,al.current):ne(al,c.pool)}function wI(){var l=vv();return l===null?null:{parent:wn._currentValue,pool:l}}var Hu=Error(s(460)),Sv=Error(s(474)),Ag=Error(s(542)),Rg={then:function(){}};function vI(l){return l=l.status,l==="fulfilled"||l==="rejected"}function SI(l,c,f){switch(f=l[f],f===void 0?l.push(c):f!==c&&(c.then(Ji,Ji),c=f),c.status){case"fulfilled":return c.value;case"rejected":throw l=c.reason,CI(l),l;default:if(typeof c.status=="string")c.then(Ji,Ji);else{if(l=Ft,l!==null&&100<l.shellSuspendCounter)throw Error(s(482));l=c,l.status="pending",l.then(function(g){if(c.status==="pending"){var v=c;v.status="fulfilled",v.value=g}},function(g){if(c.status==="pending"){var v=c;v.status="rejected",v.reason=g}})}switch(c.status){case"fulfilled":return c.value;case"rejected":throw l=c.reason,CI(l),l}throw ll=c,Hu}}function ol(l){try{var c=l._init;return c(l._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(ll=f,Hu):f}}var ll=null;function TI(){if(ll===null)throw Error(s(459));var l=ll;return ll=null,l}function CI(l){if(l===Hu||l===Ag)throw Error(s(483))}var qu=null,Ld=0;function Dg(l){var c=Ld;return Ld+=1,qu===null&&(qu=[]),SI(qu,l,c)}function Md(l,c){c=c.props.ref,l.ref=c!==void 0?c:null}function Og(l,c){throw c.$$typeof===m?Error(s(525)):(l=Object.prototype.toString.call(c),Error(s(31,l==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":l)))}function NI(l){function c(re,Q){if(l){var oe=re.deletions;oe===null?(re.deletions=[Q],re.flags|=16):oe.push(Q)}}function f(re,Q){if(!l)return null;for(;Q!==null;)c(re,Q),Q=Q.sibling;return null}function g(re){for(var Q=new Map;re!==null;)re.key!==null?Q.set(re.key,re):Q.set(re.index,re),re=re.sibling;return Q}function v(re,Q){return re=Qi(re,Q),re.index=0,re.sibling=null,re}function T(re,Q,oe){return re.index=oe,l?(oe=re.alternate,oe!==null?(oe=oe.index,oe<Q?(re.flags|=67108866,Q):oe):(re.flags|=67108866,Q)):(re.flags|=1048576,Q)}function I(re){return l&&re.alternate===null&&(re.flags|=67108866),re}function z(re,Q,oe,ye){return Q===null||Q.tag!==6?(Q=cv(oe,re.mode,ye),Q.return=re,Q):(Q=v(Q,oe),Q.return=re,Q)}function q(re,Q,oe,ye){var Be=oe.type;return Be===x?ge(re,Q,oe.props.children,ye,oe.key):Q!==null&&(Q.elementType===Be||typeof Be=="object"&&Be!==null&&Be.$$typeof===O&&ol(Be)===Q.type)?(Q=v(Q,oe.props),Md(Q,oe),Q.return=re,Q):(Q=kg(oe.type,oe.key,oe.props,null,re.mode,ye),Md(Q,oe),Q.return=re,Q)}function le(re,Q,oe,ye){return Q===null||Q.tag!==4||Q.stateNode.containerInfo!==oe.containerInfo||Q.stateNode.implementation!==oe.implementation?(Q=hv(oe,re.mode,ye),Q.return=re,Q):(Q=v(Q,oe.children||[]),Q.return=re,Q)}function ge(re,Q,oe,ye,Be){return Q===null||Q.tag!==7?(Q=nl(oe,re.mode,ye,Be),Q.return=re,Q):(Q=v(Q,oe),Q.return=re,Q)}function be(re,Q,oe){if(typeof Q=="string"&&Q!==""||typeof Q=="number"||typeof Q=="bigint")return Q=cv(""+Q,re.mode,oe),Q.return=re,Q;if(typeof Q=="object"&&Q!==null){switch(Q.$$typeof){case y:return oe=kg(Q.type,Q.key,Q.props,null,re.mode,oe),Md(oe,Q),oe.return=re,oe;case b:return Q=hv(Q,re.mode,oe),Q.return=re,Q;case O:return Q=ol(Q),be(re,Q,oe)}if(Z(Q)||U(Q))return Q=nl(Q,re.mode,oe,null),Q.return=re,Q;if(typeof Q.then=="function")return be(re,Dg(Q),oe);if(Q.$$typeof===N)return be(re,Ig(re,Q),oe);Og(re,Q)}return null}function ue(re,Q,oe,ye){var Be=Q!==null?Q.key:null;if(typeof oe=="string"&&oe!==""||typeof oe=="number"||typeof oe=="bigint")return Be!==null?null:z(re,Q,""+oe,ye);if(typeof oe=="object"&&oe!==null){switch(oe.$$typeof){case y:return oe.key===Be?q(re,Q,oe,ye):null;case b:return oe.key===Be?le(re,Q,oe,ye):null;case O:return oe=ol(oe),ue(re,Q,oe,ye)}if(Z(oe)||U(oe))return Be!==null?null:ge(re,Q,oe,ye,null);if(typeof oe.then=="function")return ue(re,Q,Dg(oe),ye);if(oe.$$typeof===N)return ue(re,Q,Ig(re,oe),ye);Og(re,oe)}return null}function fe(re,Q,oe,ye,Be){if(typeof ye=="string"&&ye!==""||typeof ye=="number"||typeof ye=="bigint")return re=re.get(oe)||null,z(Q,re,""+ye,Be);if(typeof ye=="object"&&ye!==null){switch(ye.$$typeof){case y:return re=re.get(ye.key===null?oe:ye.key)||null,q(Q,re,ye,Be);case b:return re=re.get(ye.key===null?oe:ye.key)||null,le(Q,re,ye,Be);case O:return ye=ol(ye),fe(re,Q,oe,ye,Be)}if(Z(ye)||U(ye))return re=re.get(oe)||null,ge(Q,re,ye,Be,null);if(typeof ye.then=="function")return fe(re,Q,oe,Dg(ye),Be);if(ye.$$typeof===N)return fe(re,Q,oe,Ig(Q,ye),Be);Og(Q,ye)}return null}function Re(re,Q,oe,ye){for(var Be=null,wt=null,Le=Q,tt=Q=0,dt=null;Le!==null&&tt<oe.length;tt++){Le.index>tt?(dt=Le,Le=null):dt=Le.sibling;var vt=ue(re,Le,oe[tt],ye);if(vt===null){Le===null&&(Le=dt);break}l&&Le&&vt.alternate===null&&c(re,Le),Q=T(vt,Q,tt),wt===null?Be=vt:wt.sibling=vt,wt=vt,Le=dt}if(tt===oe.length)return f(re,Le),pt&&ea(re,tt),Be;if(Le===null){for(;tt<oe.length;tt++)Le=be(re,oe[tt],ye),Le!==null&&(Q=T(Le,Q,tt),wt===null?Be=Le:wt.sibling=Le,wt=Le);return pt&&ea(re,tt),Be}for(Le=g(Le);tt<oe.length;tt++)dt=fe(Le,re,tt,oe[tt],ye),dt!==null&&(l&&dt.alternate!==null&&Le.delete(dt.key===null?tt:dt.key),Q=T(dt,Q,tt),wt===null?Be=dt:wt.sibling=dt,wt=dt);return l&&Le.forEach(function(co){return c(re,co)}),pt&&ea(re,tt),Be}function Ue(re,Q,oe,ye){if(oe==null)throw Error(s(151));for(var Be=null,wt=null,Le=Q,tt=Q=0,dt=null,vt=oe.next();Le!==null&&!vt.done;tt++,vt=oe.next()){Le.index>tt?(dt=Le,Le=null):dt=Le.sibling;var co=ue(re,Le,vt.value,ye);if(co===null){Le===null&&(Le=dt);break}l&&Le&&co.alternate===null&&c(re,Le),Q=T(co,Q,tt),wt===null?Be=co:wt.sibling=co,wt=co,Le=dt}if(vt.done)return f(re,Le),pt&&ea(re,tt),Be;if(Le===null){for(;!vt.done;tt++,vt=oe.next())vt=be(re,vt.value,ye),vt!==null&&(Q=T(vt,Q,tt),wt===null?Be=vt:wt.sibling=vt,wt=vt);return pt&&ea(re,tt),Be}for(Le=g(Le);!vt.done;tt++,vt=oe.next())vt=fe(Le,re,tt,vt.value,ye),vt!==null&&(l&&vt.alternate!==null&&Le.delete(vt.key===null?tt:vt.key),Q=T(vt,Q,tt),wt===null?Be=vt:wt.sibling=vt,wt=vt);return l&&Le.forEach(function(wG){return c(re,wG)}),pt&&ea(re,tt),Be}function Dt(re,Q,oe,ye){if(typeof oe=="object"&&oe!==null&&oe.type===x&&oe.key===null&&(oe=oe.props.children),typeof oe=="object"&&oe!==null){switch(oe.$$typeof){case y:e:{for(var Be=oe.key;Q!==null;){if(Q.key===Be){if(Be=oe.type,Be===x){if(Q.tag===7){f(re,Q.sibling),ye=v(Q,oe.props.children),ye.return=re,re=ye;break e}}else if(Q.elementType===Be||typeof Be=="object"&&Be!==null&&Be.$$typeof===O&&ol(Be)===Q.type){f(re,Q.sibling),ye=v(Q,oe.props),Md(ye,oe),ye.return=re,re=ye;break e}f(re,Q);break}else c(re,Q);Q=Q.sibling}oe.type===x?(ye=nl(oe.props.children,re.mode,ye,oe.key),ye.return=re,re=ye):(ye=kg(oe.type,oe.key,oe.props,null,re.mode,ye),Md(ye,oe),ye.return=re,re=ye)}return I(re);case b:e:{for(Be=oe.key;Q!==null;){if(Q.key===Be)if(Q.tag===4&&Q.stateNode.containerInfo===oe.containerInfo&&Q.stateNode.implementation===oe.implementation){f(re,Q.sibling),ye=v(Q,oe.children||[]),ye.return=re,re=ye;break e}else{f(re,Q);break}else c(re,Q);Q=Q.sibling}ye=hv(oe,re.mode,ye),ye.return=re,re=ye}return I(re);case O:return oe=ol(oe),Dt(re,Q,oe,ye)}if(Z(oe))return Re(re,Q,oe,ye);if(U(oe)){if(Be=U(oe),typeof Be!="function")throw Error(s(150));return oe=Be.call(oe),Ue(re,Q,oe,ye)}if(typeof oe.then=="function")return Dt(re,Q,Dg(oe),ye);if(oe.$$typeof===N)return Dt(re,Q,Ig(re,oe),ye);Og(re,oe)}return typeof oe=="string"&&oe!==""||typeof oe=="number"||typeof oe=="bigint"?(oe=""+oe,Q!==null&&Q.tag===6?(f(re,Q.sibling),ye=v(Q,oe),ye.return=re,re=ye):(f(re,Q),ye=cv(oe,re.mode,ye),ye.return=re,re=ye),I(re)):f(re,Q)}return function(re,Q,oe,ye){try{Ld=0;var Be=Dt(re,Q,oe,ye);return qu=null,Be}catch(Le){if(Le===Hu||Le===Ag)throw Le;var wt=ar(29,Le,null,re.mode);return wt.lanes=ye,wt.return=re,wt}}}var ul=NI(!0),kI=NI(!1),qa=!1;function Tv(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Cv(l,c){l=l.updateQueue,c.updateQueue===l&&(c.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,callbacks:null})}function Ka(l){return{lane:l,tag:0,payload:null,callback:null,next:null}}function Xa(l,c,f){var g=l.updateQueue;if(g===null)return null;if(g=g.shared,(Tt&2)!==0){var v=g.pending;return v===null?c.next=c:(c.next=v.next,v.next=c),g.pending=c,c=Ng(l),uI(l,null,f),c}return Cg(l,g,c,f),Ng(l)}function zd(l,c,f){if(c=c.updateQueue,c!==null&&(c=c.shared,(f&4194048)!==0)){var g=c.lanes;g&=l.pendingLanes,f|=g,c.lanes=f,y$(l,f)}}function Nv(l,c){var f=l.updateQueue,g=l.alternate;if(g!==null&&(g=g.updateQueue,f===g)){var v=null,T=null;if(f=f.firstBaseUpdate,f!==null){do{var I={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};T===null?v=T=I:T=T.next=I,f=f.next}while(f!==null);T===null?v=T=c:T=T.next=c}else v=T=c;f={baseState:g.baseState,firstBaseUpdate:v,lastBaseUpdate:T,shared:g.shared,callbacks:g.callbacks},l.updateQueue=f;return}l=f.lastBaseUpdate,l===null?f.firstBaseUpdate=c:l.next=c,f.lastBaseUpdate=c}var kv=!1;function Pd(){if(kv){var l=Gu;if(l!==null)throw l}}function Bd(l,c,f,g){kv=!1;var v=l.updateQueue;qa=!1;var T=v.firstBaseUpdate,I=v.lastBaseUpdate,z=v.shared.pending;if(z!==null){v.shared.pending=null;var q=z,le=q.next;q.next=null,I===null?T=le:I.next=le,I=q;var ge=l.alternate;ge!==null&&(ge=ge.updateQueue,z=ge.lastBaseUpdate,z!==I&&(z===null?ge.firstBaseUpdate=le:z.next=le,ge.lastBaseUpdate=q))}if(T!==null){var be=v.baseState;I=0,ge=le=q=null,z=T;do{var ue=z.lane&-536870913,fe=ue!==z.lane;if(fe?(ht&ue)===ue:(g&ue)===ue){ue!==0&&ue===Wu&&(kv=!0),ge!==null&&(ge=ge.next={lane:0,tag:z.tag,payload:z.payload,callback:null,next:null});e:{var Re=l,Ue=z;ue=c;var Dt=f;switch(Ue.tag){case 1:if(Re=Ue.payload,typeof Re=="function"){be=Re.call(Dt,be,ue);break e}be=Re;break e;case 3:Re.flags=Re.flags&-65537|128;case 0:if(Re=Ue.payload,ue=typeof Re=="function"?Re.call(Dt,be,ue):Re,ue==null)break e;be=p({},be,ue);break e;case 2:qa=!0}}ue=z.callback,ue!==null&&(l.flags|=64,fe&&(l.flags|=8192),fe=v.callbacks,fe===null?v.callbacks=[ue]:fe.push(ue))}else fe={lane:ue,tag:z.tag,payload:z.payload,callback:z.callback,next:null},ge===null?(le=ge=fe,q=be):ge=ge.next=fe,I|=ue;if(z=z.next,z===null){if(z=v.shared.pending,z===null)break;fe=z,z=fe.next,fe.next=null,v.lastBaseUpdate=fe,v.shared.pending=null}}while(!0);ge===null&&(q=be),v.baseState=q,v.firstBaseUpdate=le,v.lastBaseUpdate=ge,T===null&&(v.shared.lanes=0),eo|=I,l.lanes=I,l.memoizedState=be}}function EI(l,c){if(typeof l!="function")throw Error(s(191,l));l.call(c)}function $I(l,c){var f=l.callbacks;if(f!==null)for(l.callbacks=null,l=0;l<f.length;l++)EI(f[l],c)}var Ku=P(null),Fg=P(0);function II(l,c){l=ha,ne(Fg,l),ne(Ku,c),ha=l|c.baseLanes}function Ev(){ne(Fg,ha),ne(Ku,Ku.current)}function $v(){ha=Fg.current,H(Ku),H(Fg)}var or=P(null),Or=null;function Ya(l){var c=l.alternate;ne(fn,fn.current&1),ne(or,l),Or===null&&(c===null||Ku.current!==null||c.memoizedState!==null)&&(Or=l)}function Iv(l){ne(fn,fn.current),ne(or,l),Or===null&&(Or=l)}function _I(l){l.tag===22?(ne(fn,fn.current),ne(or,l),Or===null&&(Or=l)):Ja()}function Ja(){ne(fn,fn.current),ne(or,or.current)}function lr(l){H(or),Or===l&&(Or=null),H(fn)}var fn=P(0);function Lg(l){for(var c=l;c!==null;){if(c.tag===13){var f=c.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||F1(f)||L1(f)))return c}else if(c.tag===19&&(c.memoizedProps.revealOrder==="forwards"||c.memoizedProps.revealOrder==="backwards"||c.memoizedProps.revealOrder==="unstable_legacy-backwards"||c.memoizedProps.revealOrder==="together")){if((c.flags&128)!==0)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===l)break;for(;c.sibling===null;){if(c.return===null||c.return===l)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}var sa=0,et=null,At=null,vn=null,Mg=!1,Xu=!1,cl=!1,zg=0,Vd=0,Yu=null,cW=0;function sn(){throw Error(s(321))}function _v(l,c){if(c===null)return!1;for(var f=0;f<c.length&&f<l.length;f++)if(!ir(l[f],c[f]))return!1;return!0}function Av(l,c,f,g,v,T){return sa=T,et=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,B.H=l===null||l.memoizedState===null?f_:Hv,cl=!1,T=f(g,v),cl=!1,Xu&&(T=RI(c,f,g,v)),AI(l),T}function AI(l){B.H=Wd;var c=At!==null&&At.next!==null;if(sa=0,vn=At=et=null,Mg=!1,Vd=0,Yu=null,c)throw Error(s(300));l===null||Sn||(l=l.dependencies,l!==null&&$g(l)&&(Sn=!0))}function RI(l,c,f,g){et=l;var v=0;do{if(Xu&&(Yu=null),Vd=0,Xu=!1,25<=v)throw Error(s(301));if(v+=1,vn=At=null,l.updateQueue!=null){var T=l.updateQueue;T.lastEffect=null,T.events=null,T.stores=null,T.memoCache!=null&&(T.memoCache.index=0)}B.H=p_,T=c(f,g)}while(Xu);return T}function hW(){var l=B.H,c=l.useState()[0];return c=typeof c.then=="function"?Ud(c):c,l=l.useState()[0],(At!==null?At.memoizedState:null)!==l&&(et.flags|=1024),c}function Rv(){var l=zg!==0;return zg=0,l}function Dv(l,c,f){c.updateQueue=l.updateQueue,c.flags&=-2053,l.lanes&=~f}function Ov(l){if(Mg){for(l=l.memoizedState;l!==null;){var c=l.queue;c!==null&&(c.pending=null),l=l.next}Mg=!1}sa=0,vn=At=et=null,Xu=!1,Vd=zg=0,Yu=null}function Ns(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return vn===null?et.memoizedState=vn=l:vn=vn.next=l,vn}function pn(){if(At===null){var l=et.alternate;l=l!==null?l.memoizedState:null}else l=At.next;var c=vn===null?et.memoizedState:vn.next;if(c!==null)vn=c,At=l;else{if(l===null)throw et.alternate===null?Error(s(467)):Error(s(310));At=l,l={memoizedState:At.memoizedState,baseState:At.baseState,baseQueue:At.baseQueue,queue:At.queue,next:null},vn===null?et.memoizedState=vn=l:vn=vn.next=l}return vn}function Pg(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Ud(l){var c=Vd;return Vd+=1,Yu===null&&(Yu=[]),l=SI(Yu,l,c),c=et,(vn===null?c.memoizedState:vn.next)===null&&(c=c.alternate,B.H=c===null||c.memoizedState===null?f_:Hv),l}function Bg(l){if(l!==null&&typeof l=="object"){if(typeof l.then=="function")return Ud(l);if(l.$$typeof===N)return rs(l)}throw Error(s(438,String(l)))}function Fv(l){var c=null,f=et.updateQueue;if(f!==null&&(c=f.memoCache),c==null){var g=et.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(c={data:g.data.map(function(v){return v.slice()}),index:0})))}if(c==null&&(c={data:[],index:0}),f===null&&(f=Pg(),et.updateQueue=f),f.memoCache=c,f=c.data[c.index],f===void 0)for(f=c.data[c.index]=Array(l),g=0;g<l;g++)f[g]=L;return c.index++,f}function ra(l,c){return typeof c=="function"?c(l):c}function Vg(l){var c=pn();return Lv(c,At,l)}function Lv(l,c,f){var g=l.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=f;var v=l.baseQueue,T=g.pending;if(T!==null){if(v!==null){var I=v.next;v.next=T.next,T.next=I}c.baseQueue=v=T,g.pending=null}if(T=l.baseState,v===null)l.memoizedState=T;else{c=v.next;var z=I=null,q=null,le=c,ge=!1;do{var be=le.lane&-536870913;if(be!==le.lane?(ht&be)===be:(sa&be)===be){var ue=le.revertLane;if(ue===0)q!==null&&(q=q.next={lane:0,revertLane:0,gesture:null,action:le.action,hasEagerState:le.hasEagerState,eagerState:le.eagerState,next:null}),be===Wu&&(ge=!0);else if((sa&ue)===ue){le=le.next,ue===Wu&&(ge=!0);continue}else be={lane:0,revertLane:le.revertLane,gesture:null,action:le.action,hasEagerState:le.hasEagerState,eagerState:le.eagerState,next:null},q===null?(z=q=be,I=T):q=q.next=be,et.lanes|=ue,eo|=ue;be=le.action,cl&&f(T,be),T=le.hasEagerState?le.eagerState:f(T,be)}else ue={lane:be,revertLane:le.revertLane,gesture:le.gesture,action:le.action,hasEagerState:le.hasEagerState,eagerState:le.eagerState,next:null},q===null?(z=q=ue,I=T):q=q.next=ue,et.lanes|=be,eo|=be;le=le.next}while(le!==null&&le!==c);if(q===null?I=T:q.next=z,!ir(T,l.memoizedState)&&(Sn=!0,ge&&(f=Gu,f!==null)))throw f;l.memoizedState=T,l.baseState=I,l.baseQueue=q,g.lastRenderedState=T}return v===null&&(g.lanes=0),[l.memoizedState,g.dispatch]}function Mv(l){var c=pn(),f=c.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=l;var g=f.dispatch,v=f.pending,T=c.memoizedState;if(v!==null){f.pending=null;var I=v=v.next;do T=l(T,I.action),I=I.next;while(I!==v);ir(T,c.memoizedState)||(Sn=!0),c.memoizedState=T,c.baseQueue===null&&(c.baseState=T),f.lastRenderedState=T}return[T,g]}function DI(l,c,f){var g=et,v=pn(),T=pt;if(T){if(f===void 0)throw Error(s(407));f=f()}else f=c();var I=!ir((At||v).memoizedState,f);if(I&&(v.memoizedState=f,Sn=!0),v=v.queue,Bv(LI.bind(null,g,v,l),[l]),v.getSnapshot!==c||I||vn!==null&&vn.memoizedState.tag&1){if(g.flags|=2048,Ju(9,{destroy:void 0},FI.bind(null,g,v,f,c),null),Ft===null)throw Error(s(349));T||(sa&127)!==0||OI(g,c,f)}return f}function OI(l,c,f){l.flags|=16384,l={getSnapshot:c,value:f},c=et.updateQueue,c===null?(c=Pg(),et.updateQueue=c,c.stores=[l]):(f=c.stores,f===null?c.stores=[l]:f.push(l))}function FI(l,c,f,g){c.value=f,c.getSnapshot=g,MI(c)&&zI(l)}function LI(l,c,f){return f(function(){MI(c)&&zI(l)})}function MI(l){var c=l.getSnapshot;l=l.value;try{var f=c();return!ir(l,f)}catch{return!0}}function zI(l){var c=tl(l,2);c!==null&&Us(c,l,2)}function zv(l){var c=Ns();if(typeof l=="function"){var f=l;if(l=f(),cl){Ci(!0);try{f()}finally{Ci(!1)}}}return c.memoizedState=c.baseState=l,c.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ra,lastRenderedState:l},c}function PI(l,c,f,g){return l.baseState=f,Lv(l,At,typeof g=="function"?g:ra)}function dW(l,c,f,g,v){if(Wg(l))throw Error(s(485));if(l=c.action,l!==null){var T={payload:v,action:l,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){T.listeners.push(I)}};B.T!==null?f(!0):T.isTransition=!1,g(T),f=c.pending,f===null?(T.next=c.pending=T,BI(c,T)):(T.next=f.next,c.pending=f.next=T)}}function BI(l,c){var f=c.action,g=c.payload,v=l.state;if(c.isTransition){var T=B.T,I={};B.T=I;try{var z=f(v,g),q=B.S;q!==null&&q(I,z),VI(l,c,z)}catch(le){Pv(l,c,le)}finally{T!==null&&I.types!==null&&(T.types=I.types),B.T=T}}else try{T=f(v,g),VI(l,c,T)}catch(le){Pv(l,c,le)}}function VI(l,c,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(g){UI(l,c,g)},function(g){return Pv(l,c,g)}):UI(l,c,f)}function UI(l,c,f){c.status="fulfilled",c.value=f,jI(c),l.state=f,c=l.pending,c!==null&&(f=c.next,f===c?l.pending=null:(f=f.next,c.next=f,BI(l,f)))}function Pv(l,c,f){var g=l.pending;if(l.pending=null,g!==null){g=g.next;do c.status="rejected",c.reason=f,jI(c),c=c.next;while(c!==g)}l.action=null}function jI(l){l=l.listeners;for(var c=0;c<l.length;c++)(0,l[c])()}function WI(l,c){return c}function GI(l,c){if(pt){var f=Ft.formState;if(f!==null){e:{var g=et;if(pt){if(Ut){t:{for(var v=Ut,T=Dr;v.nodeType!==8;){if(!T){v=null;break t}if(v=Fr(v.nextSibling),v===null){v=null;break t}}T=v.data,v=T==="F!"||T==="F"?v:null}if(v){Ut=Fr(v.nextSibling),g=v.data==="F!";break e}}Ga(g)}g=!1}g&&(c=f[0])}}return f=Ns(),f.memoizedState=f.baseState=c,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:WI,lastRenderedState:c},f.queue=g,f=c_.bind(null,et,g),g.dispatch=f,g=zv(!1),T=Gv.bind(null,et,!1,g.queue),g=Ns(),v={state:c,dispatch:null,action:l,pending:null},g.queue=v,f=dW.bind(null,et,v,T,f),v.dispatch=f,g.memoizedState=l,[c,f,!1]}function HI(l){var c=pn();return qI(c,At,l)}function qI(l,c,f){if(c=Lv(l,c,WI)[0],l=Vg(ra)[0],typeof c=="object"&&c!==null&&typeof c.then=="function")try{var g=Ud(c)}catch(I){throw I===Hu?Ag:I}else g=c;c=pn();var v=c.queue,T=v.dispatch;return f!==c.memoizedState&&(et.flags|=2048,Ju(9,{destroy:void 0},fW.bind(null,v,f),null)),[g,T,l]}function fW(l,c){l.action=c}function KI(l){var c=pn(),f=At;if(f!==null)return qI(c,f,l);pn(),c=c.memoizedState,f=pn();var g=f.queue.dispatch;return f.memoizedState=l,[c,g,!1]}function Ju(l,c,f,g){return l={tag:l,create:f,deps:g,inst:c,next:null},c=et.updateQueue,c===null&&(c=Pg(),et.updateQueue=c),f=c.lastEffect,f===null?c.lastEffect=l.next=l:(g=f.next,f.next=l,l.next=g,c.lastEffect=l),l}function XI(){return pn().memoizedState}function Ug(l,c,f,g){var v=Ns();et.flags|=l,v.memoizedState=Ju(1|c,{destroy:void 0},f,g===void 0?null:g)}function jg(l,c,f,g){var v=pn();g=g===void 0?null:g;var T=v.memoizedState.inst;At!==null&&g!==null&&_v(g,At.memoizedState.deps)?v.memoizedState=Ju(c,T,f,g):(et.flags|=l,v.memoizedState=Ju(1|c,T,f,g))}function YI(l,c){Ug(8390656,8,l,c)}function Bv(l,c){jg(2048,8,l,c)}function pW(l){et.flags|=4;var c=et.updateQueue;if(c===null)c=Pg(),et.updateQueue=c,c.events=[l];else{var f=c.events;f===null?c.events=[l]:f.push(l)}}function JI(l){var c=pn().memoizedState;return pW({ref:c,nextImpl:l}),function(){if((Tt&2)!==0)throw Error(s(440));return c.impl.apply(void 0,arguments)}}function ZI(l,c){return jg(4,2,l,c)}function QI(l,c){return jg(4,4,l,c)}function e_(l,c){if(typeof c=="function"){l=l();var f=c(l);return function(){typeof f=="function"?f():c(null)}}if(c!=null)return l=l(),c.current=l,function(){c.current=null}}function t_(l,c,f){f=f!=null?f.concat([l]):null,jg(4,4,e_.bind(null,c,l),f)}function Vv(){}function n_(l,c){var f=pn();c=c===void 0?null:c;var g=f.memoizedState;return c!==null&&_v(c,g[1])?g[0]:(f.memoizedState=[l,c],l)}function s_(l,c){var f=pn();c=c===void 0?null:c;var g=f.memoizedState;if(c!==null&&_v(c,g[1]))return g[0];if(g=l(),cl){Ci(!0);try{l()}finally{Ci(!1)}}return f.memoizedState=[g,c],g}function Uv(l,c,f){return f===void 0||(sa&1073741824)!==0&&(ht&261930)===0?l.memoizedState=c:(l.memoizedState=f,l=rA(),et.lanes|=l,eo|=l,f)}function r_(l,c,f,g){return ir(f,c)?f:Ku.current!==null?(l=Uv(l,f,g),ir(l,c)||(Sn=!0),l):(sa&42)===0||(sa&1073741824)!==0&&(ht&261930)===0?(Sn=!0,l.memoizedState=f):(l=rA(),et.lanes|=l,eo|=l,c)}function i_(l,c,f,g,v){var T=V.p;V.p=T!==0&&8>T?T:8;var I=B.T,z={};B.T=z,Gv(l,!1,c,f);try{var q=v(),le=B.S;if(le!==null&&le(z,q),q!==null&&typeof q=="object"&&typeof q.then=="function"){var ge=uW(q,g);jd(l,c,ge,hr(l))}else jd(l,c,g,hr(l))}catch(be){jd(l,c,{then:function(){},status:"rejected",reason:be},hr())}finally{V.p=T,I!==null&&z.types!==null&&(I.types=z.types),B.T=I}}function mW(){}function jv(l,c,f,g){if(l.tag!==5)throw Error(s(476));var v=a_(l).queue;i_(l,v,c,j,f===null?mW:function(){return o_(l),f(g)})}function a_(l){var c=l.memoizedState;if(c!==null)return c;c={memoizedState:j,baseState:j,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ra,lastRenderedState:j},next:null};var f={};return c.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ra,lastRenderedState:f},next:null},l.memoizedState=c,l=l.alternate,l!==null&&(l.memoizedState=c),c}function o_(l){var c=a_(l);c.next===null&&(c=l.alternate.memoizedState),jd(l,c.next.queue,{},hr())}function Wv(){return rs(of)}function l_(){return pn().memoizedState}function u_(){return pn().memoizedState}function gW(l){for(var c=l.return;c!==null;){switch(c.tag){case 24:case 3:var f=hr();l=Ka(f);var g=Xa(c,l,f);g!==null&&(Us(g,c,f),zd(g,c,f)),c={cache:xv()},l.payload=c;return}c=c.return}}function yW(l,c,f){var g=hr();f={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},Wg(l)?h_(c,f):(f=lv(l,c,f,g),f!==null&&(Us(f,l,g),d_(f,c,g)))}function c_(l,c,f){var g=hr();jd(l,c,f,g)}function jd(l,c,f,g){var v={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(Wg(l))h_(c,v);else{var T=l.alternate;if(l.lanes===0&&(T===null||T.lanes===0)&&(T=c.lastRenderedReducer,T!==null))try{var I=c.lastRenderedState,z=T(I,f);if(v.hasEagerState=!0,v.eagerState=z,ir(z,I))return Cg(l,c,v,0),Ft===null&&Tg(),!1}catch{}if(f=lv(l,c,v,g),f!==null)return Us(f,l,g),d_(f,c,g),!0}return!1}function Gv(l,c,f,g){if(g={lane:2,revertLane:T1(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},Wg(l)){if(c)throw Error(s(479))}else c=lv(l,f,g,2),c!==null&&Us(c,l,2)}function Wg(l){var c=l.alternate;return l===et||c!==null&&c===et}function h_(l,c){Xu=Mg=!0;var f=l.pending;f===null?c.next=c:(c.next=f.next,f.next=c),l.pending=c}function d_(l,c,f){if((f&4194048)!==0){var g=c.lanes;g&=l.pendingLanes,f|=g,c.lanes=f,y$(l,f)}}var Wd={readContext:rs,use:Bg,useCallback:sn,useContext:sn,useEffect:sn,useImperativeHandle:sn,useLayoutEffect:sn,useInsertionEffect:sn,useMemo:sn,useReducer:sn,useRef:sn,useState:sn,useDebugValue:sn,useDeferredValue:sn,useTransition:sn,useSyncExternalStore:sn,useId:sn,useHostTransitionStatus:sn,useFormState:sn,useActionState:sn,useOptimistic:sn,useMemoCache:sn,useCacheRefresh:sn};Wd.useEffectEvent=sn;var f_={readContext:rs,use:Bg,useCallback:function(l,c){return Ns().memoizedState=[l,c===void 0?null:c],l},useContext:rs,useEffect:YI,useImperativeHandle:function(l,c,f){f=f!=null?f.concat([l]):null,Ug(4194308,4,e_.bind(null,c,l),f)},useLayoutEffect:function(l,c){return Ug(4194308,4,l,c)},useInsertionEffect:function(l,c){Ug(4,2,l,c)},useMemo:function(l,c){var f=Ns();c=c===void 0?null:c;var g=l();if(cl){Ci(!0);try{l()}finally{Ci(!1)}}return f.memoizedState=[g,c],g},useReducer:function(l,c,f){var g=Ns();if(f!==void 0){var v=f(c);if(cl){Ci(!0);try{f(c)}finally{Ci(!1)}}}else v=c;return g.memoizedState=g.baseState=v,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:v},g.queue=l,l=l.dispatch=yW.bind(null,et,l),[g.memoizedState,l]},useRef:function(l){var c=Ns();return l={current:l},c.memoizedState=l},useState:function(l){l=zv(l);var c=l.queue,f=c_.bind(null,et,c);return c.dispatch=f,[l.memoizedState,f]},useDebugValue:Vv,useDeferredValue:function(l,c){var f=Ns();return Uv(f,l,c)},useTransition:function(){var l=zv(!1);return l=i_.bind(null,et,l.queue,!0,!1),Ns().memoizedState=l,[!1,l]},useSyncExternalStore:function(l,c,f){var g=et,v=Ns();if(pt){if(f===void 0)throw Error(s(407));f=f()}else{if(f=c(),Ft===null)throw Error(s(349));(ht&127)!==0||OI(g,c,f)}v.memoizedState=f;var T={value:f,getSnapshot:c};return v.queue=T,YI(LI.bind(null,g,T,l),[l]),g.flags|=2048,Ju(9,{destroy:void 0},FI.bind(null,g,T,f,c),null),f},useId:function(){var l=Ns(),c=Ft.identifierPrefix;if(pt){var f=ki,g=Ni;f=(g&~(1<<32-rr(g)-1)).toString(32)+f,c="_"+c+"R_"+f,f=zg++,0<f&&(c+="H"+f.toString(32)),c+="_"}else f=cW++,c="_"+c+"r_"+f.toString(32)+"_";return l.memoizedState=c},useHostTransitionStatus:Wv,useFormState:GI,useActionState:GI,useOptimistic:function(l){var c=Ns();c.memoizedState=c.baseState=l;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return c.queue=f,c=Gv.bind(null,et,!0,f),f.dispatch=c,[l,c]},useMemoCache:Fv,useCacheRefresh:function(){return Ns().memoizedState=gW.bind(null,et)},useEffectEvent:function(l){var c=Ns(),f={impl:l};return c.memoizedState=f,function(){if((Tt&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},Hv={readContext:rs,use:Bg,useCallback:n_,useContext:rs,useEffect:Bv,useImperativeHandle:t_,useInsertionEffect:ZI,useLayoutEffect:QI,useMemo:s_,useReducer:Vg,useRef:XI,useState:function(){return Vg(ra)},useDebugValue:Vv,useDeferredValue:function(l,c){var f=pn();return r_(f,At.memoizedState,l,c)},useTransition:function(){var l=Vg(ra)[0],c=pn().memoizedState;return[typeof l=="boolean"?l:Ud(l),c]},useSyncExternalStore:DI,useId:l_,useHostTransitionStatus:Wv,useFormState:HI,useActionState:HI,useOptimistic:function(l,c){var f=pn();return PI(f,At,l,c)},useMemoCache:Fv,useCacheRefresh:u_};Hv.useEffectEvent=JI;var p_={readContext:rs,use:Bg,useCallback:n_,useContext:rs,useEffect:Bv,useImperativeHandle:t_,useInsertionEffect:ZI,useLayoutEffect:QI,useMemo:s_,useReducer:Mv,useRef:XI,useState:function(){return Mv(ra)},useDebugValue:Vv,useDeferredValue:function(l,c){var f=pn();return At===null?Uv(f,l,c):r_(f,At.memoizedState,l,c)},useTransition:function(){var l=Mv(ra)[0],c=pn().memoizedState;return[typeof l=="boolean"?l:Ud(l),c]},useSyncExternalStore:DI,useId:l_,useHostTransitionStatus:Wv,useFormState:KI,useActionState:KI,useOptimistic:function(l,c){var f=pn();return At!==null?PI(f,At,l,c):(f.baseState=l,[l,f.queue.dispatch])},useMemoCache:Fv,useCacheRefresh:u_};p_.useEffectEvent=JI;function qv(l,c,f,g){c=l.memoizedState,f=f(g,c),f=f==null?c:p({},c,f),l.memoizedState=f,l.lanes===0&&(l.updateQueue.baseState=f)}var Kv={enqueueSetState:function(l,c,f){l=l._reactInternals;var g=hr(),v=Ka(g);v.payload=c,f!=null&&(v.callback=f),c=Xa(l,v,g),c!==null&&(Us(c,l,g),zd(c,l,g))},enqueueReplaceState:function(l,c,f){l=l._reactInternals;var g=hr(),v=Ka(g);v.tag=1,v.payload=c,f!=null&&(v.callback=f),c=Xa(l,v,g),c!==null&&(Us(c,l,g),zd(c,l,g))},enqueueForceUpdate:function(l,c){l=l._reactInternals;var f=hr(),g=Ka(f);g.tag=2,c!=null&&(g.callback=c),c=Xa(l,g,f),c!==null&&(Us(c,l,f),zd(c,l,f))}};function m_(l,c,f,g,v,T,I){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(g,T,I):c.prototype&&c.prototype.isPureReactComponent?!_d(f,g)||!_d(v,T):!0}function g_(l,c,f,g){l=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(f,g),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(f,g),c.state!==l&&Kv.enqueueReplaceState(c,c.state,null)}function hl(l,c){var f=c;if("ref"in c){f={};for(var g in c)g!=="ref"&&(f[g]=c[g])}if(l=l.defaultProps){f===c&&(f=p({},f));for(var v in l)f[v]===void 0&&(f[v]=l[v])}return f}function y_(l){Sg(l)}function b_(l){console.error(l)}function x_(l){Sg(l)}function Gg(l,c){try{var f=l.onUncaughtError;f(c.value,{componentStack:c.stack})}catch(g){setTimeout(function(){throw g})}}function w_(l,c,f){try{var g=l.onCaughtError;g(f.value,{componentStack:f.stack,errorBoundary:c.tag===1?c.stateNode:null})}catch(v){setTimeout(function(){throw v})}}function Xv(l,c,f){return f=Ka(f),f.tag=3,f.payload={element:null},f.callback=function(){Gg(l,c)},f}function v_(l){return l=Ka(l),l.tag=3,l}function S_(l,c,f,g){var v=f.type.getDerivedStateFromError;if(typeof v=="function"){var T=g.value;l.payload=function(){return v(T)},l.callback=function(){w_(c,f,g)}}var I=f.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(l.callback=function(){w_(c,f,g),typeof v!="function"&&(to===null?to=new Set([this]):to.add(this));var z=g.stack;this.componentDidCatch(g.value,{componentStack:z!==null?z:""})})}function bW(l,c,f,g,v){if(f.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(c=f.alternate,c!==null&&ju(c,f,v,!0),f=or.current,f!==null){switch(f.tag){case 31:case 13:return Or===null?sy():f.alternate===null&&rn===0&&(rn=3),f.flags&=-257,f.flags|=65536,f.lanes=v,g===Rg?f.flags|=16384:(c=f.updateQueue,c===null?f.updateQueue=new Set([g]):c.add(g),w1(l,g,v)),!1;case 22:return f.flags|=65536,g===Rg?f.flags|=16384:(c=f.updateQueue,c===null?(c={transitions:null,markerInstances:null,retryQueue:new Set([g])},f.updateQueue=c):(f=c.retryQueue,f===null?c.retryQueue=new Set([g]):f.add(g)),w1(l,g,v)),!1}throw Error(s(435,f.tag))}return w1(l,g,v),sy(),!1}if(pt)return c=or.current,c!==null?((c.flags&65536)===0&&(c.flags|=256),c.flags|=65536,c.lanes=v,g!==pv&&(l=Error(s(422),{cause:g}),Dd(_r(l,f)))):(g!==pv&&(c=Error(s(423),{cause:g}),Dd(_r(c,f))),l=l.current.alternate,l.flags|=65536,v&=-v,l.lanes|=v,g=_r(g,f),v=Xv(l.stateNode,g,v),Nv(l,v),rn!==4&&(rn=2)),!1;var T=Error(s(520),{cause:g});if(T=_r(T,f),Zd===null?Zd=[T]:Zd.push(T),rn!==4&&(rn=2),c===null)return!0;g=_r(g,f),f=c;do{switch(f.tag){case 3:return f.flags|=65536,l=v&-v,f.lanes|=l,l=Xv(f.stateNode,g,l),Nv(f,l),!1;case 1:if(c=f.type,T=f.stateNode,(f.flags&128)===0&&(typeof c.getDerivedStateFromError=="function"||T!==null&&typeof T.componentDidCatch=="function"&&(to===null||!to.has(T))))return f.flags|=65536,v&=-v,f.lanes|=v,v=v_(v),S_(v,l,f,g),Nv(f,v),!1}f=f.return}while(f!==null);return!1}var Yv=Error(s(461)),Sn=!1;function is(l,c,f,g){c.child=l===null?kI(c,null,f,g):ul(c,l.child,f,g)}function T_(l,c,f,g,v){f=f.render;var T=c.ref;if("ref"in g){var I={};for(var z in g)z!=="ref"&&(I[z]=g[z])}else I=g;return il(c),g=Av(l,c,f,I,T,v),z=Rv(),l!==null&&!Sn?(Dv(l,c,v),ia(l,c,v)):(pt&&z&&dv(c),c.flags|=1,is(l,c,g,v),c.child)}function C_(l,c,f,g,v){if(l===null){var T=f.type;return typeof T=="function"&&!uv(T)&&T.defaultProps===void 0&&f.compare===null?(c.tag=15,c.type=T,N_(l,c,T,g,v)):(l=kg(f.type,null,g,c,c.mode,v),l.ref=c.ref,l.return=c,c.child=l)}if(T=l.child,!r1(l,v)){var I=T.memoizedProps;if(f=f.compare,f=f!==null?f:_d,f(I,g)&&l.ref===c.ref)return ia(l,c,v)}return c.flags|=1,l=Qi(T,g),l.ref=c.ref,l.return=c,c.child=l}function N_(l,c,f,g,v){if(l!==null){var T=l.memoizedProps;if(_d(T,g)&&l.ref===c.ref)if(Sn=!1,c.pendingProps=g=T,r1(l,v))(l.flags&131072)!==0&&(Sn=!0);else return c.lanes=l.lanes,ia(l,c,v)}return Jv(l,c,f,g,v)}function k_(l,c,f,g){var v=g.children,T=l!==null?l.memoizedState:null;if(l===null&&c.stateNode===null&&(c.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((c.flags&128)!==0){if(T=T!==null?T.baseLanes|f:f,l!==null){for(g=c.child=l.child,v=0;g!==null;)v=v|g.lanes|g.childLanes,g=g.sibling;g=v&~T}else g=0,c.child=null;return E_(l,c,T,f,g)}if((f&536870912)!==0)c.memoizedState={baseLanes:0,cachePool:null},l!==null&&_g(c,T!==null?T.cachePool:null),T!==null?II(c,T):Ev(),_I(c);else return g=c.lanes=536870912,E_(l,c,T!==null?T.baseLanes|f:f,f,g)}else T!==null?(_g(c,T.cachePool),II(c,T),Ja(),c.memoizedState=null):(l!==null&&_g(c,null),Ev(),Ja());return is(l,c,v,f),c.child}function Gd(l,c){return l!==null&&l.tag===22||c.stateNode!==null||(c.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),c.sibling}function E_(l,c,f,g,v){var T=vv();return T=T===null?null:{parent:wn._currentValue,pool:T},c.memoizedState={baseLanes:f,cachePool:T},l!==null&&_g(c,null),Ev(),_I(c),l!==null&&ju(l,c,g,!0),c.childLanes=v,null}function Hg(l,c){return c=Kg({mode:c.mode,children:c.children},l.mode),c.ref=l.ref,l.child=c,c.return=l,c}function $_(l,c,f){return ul(c,l.child,null,f),l=Hg(c,c.pendingProps),l.flags|=2,lr(c),c.memoizedState=null,l}function xW(l,c,f){var g=c.pendingProps,v=(c.flags&128)!==0;if(c.flags&=-129,l===null){if(pt){if(g.mode==="hidden")return l=Hg(c,g),c.lanes=536870912,Gd(null,l);if(Iv(c),(l=Ut)?(l=BA(l,Dr),l=l!==null&&l.data==="&"?l:null,l!==null&&(c.memoizedState={dehydrated:l,treeContext:ja!==null?{id:Ni,overflow:ki}:null,retryLane:536870912,hydrationErrors:null},f=hI(l),f.return=c,c.child=f,ss=c,Ut=null)):l=null,l===null)throw Ga(c);return c.lanes=536870912,null}return Hg(c,g)}var T=l.memoizedState;if(T!==null){var I=T.dehydrated;if(Iv(c),v)if(c.flags&256)c.flags&=-257,c=$_(l,c,f);else if(c.memoizedState!==null)c.child=l.child,c.flags|=128,c=null;else throw Error(s(558));else if(Sn||ju(l,c,f,!1),v=(f&l.childLanes)!==0,Sn||v){if(g=Ft,g!==null&&(I=b$(g,f),I!==0&&I!==T.retryLane))throw T.retryLane=I,tl(l,I),Us(g,l,I),Yv;sy(),c=$_(l,c,f)}else l=T.treeContext,Ut=Fr(I.nextSibling),ss=c,pt=!0,Wa=null,Dr=!1,l!==null&&pI(c,l),c=Hg(c,g),c.flags|=4096;return c}return l=Qi(l.child,{mode:g.mode,children:g.children}),l.ref=c.ref,c.child=l,l.return=c,l}function qg(l,c){var f=c.ref;if(f===null)l!==null&&l.ref!==null&&(c.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(l===null||l.ref!==f)&&(c.flags|=4194816)}}function Jv(l,c,f,g,v){return il(c),f=Av(l,c,f,g,void 0,v),g=Rv(),l!==null&&!Sn?(Dv(l,c,v),ia(l,c,v)):(pt&&g&&dv(c),c.flags|=1,is(l,c,f,v),c.child)}function I_(l,c,f,g,v,T){return il(c),c.updateQueue=null,f=RI(c,g,f,v),AI(l),g=Rv(),l!==null&&!Sn?(Dv(l,c,T),ia(l,c,T)):(pt&&g&&dv(c),c.flags|=1,is(l,c,f,T),c.child)}function __(l,c,f,g,v){if(il(c),c.stateNode===null){var T=Pu,I=f.contextType;typeof I=="object"&&I!==null&&(T=rs(I)),T=new f(g,T),c.memoizedState=T.state!==null&&T.state!==void 0?T.state:null,T.updater=Kv,c.stateNode=T,T._reactInternals=c,T=c.stateNode,T.props=g,T.state=c.memoizedState,T.refs={},Tv(c),I=f.contextType,T.context=typeof I=="object"&&I!==null?rs(I):Pu,T.state=c.memoizedState,I=f.getDerivedStateFromProps,typeof I=="function"&&(qv(c,f,I,g),T.state=c.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof T.getSnapshotBeforeUpdate=="function"||typeof T.UNSAFE_componentWillMount!="function"&&typeof T.componentWillMount!="function"||(I=T.state,typeof T.componentWillMount=="function"&&T.componentWillMount(),typeof T.UNSAFE_componentWillMount=="function"&&T.UNSAFE_componentWillMount(),I!==T.state&&Kv.enqueueReplaceState(T,T.state,null),Bd(c,g,T,v),Pd(),T.state=c.memoizedState),typeof T.componentDidMount=="function"&&(c.flags|=4194308),g=!0}else if(l===null){T=c.stateNode;var z=c.memoizedProps,q=hl(f,z);T.props=q;var le=T.context,ge=f.contextType;I=Pu,typeof ge=="object"&&ge!==null&&(I=rs(ge));var be=f.getDerivedStateFromProps;ge=typeof be=="function"||typeof T.getSnapshotBeforeUpdate=="function",z=c.pendingProps!==z,ge||typeof T.UNSAFE_componentWillReceiveProps!="function"&&typeof T.componentWillReceiveProps!="function"||(z||le!==I)&&g_(c,T,g,I),qa=!1;var ue=c.memoizedState;T.state=ue,Bd(c,g,T,v),Pd(),le=c.memoizedState,z||ue!==le||qa?(typeof be=="function"&&(qv(c,f,be,g),le=c.memoizedState),(q=qa||m_(c,f,q,g,ue,le,I))?(ge||typeof T.UNSAFE_componentWillMount!="function"&&typeof T.componentWillMount!="function"||(typeof T.componentWillMount=="function"&&T.componentWillMount(),typeof T.UNSAFE_componentWillMount=="function"&&T.UNSAFE_componentWillMount()),typeof T.componentDidMount=="function"&&(c.flags|=4194308)):(typeof T.componentDidMount=="function"&&(c.flags|=4194308),c.memoizedProps=g,c.memoizedState=le),T.props=g,T.state=le,T.context=I,g=q):(typeof T.componentDidMount=="function"&&(c.flags|=4194308),g=!1)}else{T=c.stateNode,Cv(l,c),I=c.memoizedProps,ge=hl(f,I),T.props=ge,be=c.pendingProps,ue=T.context,le=f.contextType,q=Pu,typeof le=="object"&&le!==null&&(q=rs(le)),z=f.getDerivedStateFromProps,(le=typeof z=="function"||typeof T.getSnapshotBeforeUpdate=="function")||typeof T.UNSAFE_componentWillReceiveProps!="function"&&typeof T.componentWillReceiveProps!="function"||(I!==be||ue!==q)&&g_(c,T,g,q),qa=!1,ue=c.memoizedState,T.state=ue,Bd(c,g,T,v),Pd();var fe=c.memoizedState;I!==be||ue!==fe||qa||l!==null&&l.dependencies!==null&&$g(l.dependencies)?(typeof z=="function"&&(qv(c,f,z,g),fe=c.memoizedState),(ge=qa||m_(c,f,ge,g,ue,fe,q)||l!==null&&l.dependencies!==null&&$g(l.dependencies))?(le||typeof T.UNSAFE_componentWillUpdate!="function"&&typeof T.componentWillUpdate!="function"||(typeof T.componentWillUpdate=="function"&&T.componentWillUpdate(g,fe,q),typeof T.UNSAFE_componentWillUpdate=="function"&&T.UNSAFE_componentWillUpdate(g,fe,q)),typeof T.componentDidUpdate=="function"&&(c.flags|=4),typeof T.getSnapshotBeforeUpdate=="function"&&(c.flags|=1024)):(typeof T.componentDidUpdate!="function"||I===l.memoizedProps&&ue===l.memoizedState||(c.flags|=4),typeof T.getSnapshotBeforeUpdate!="function"||I===l.memoizedProps&&ue===l.memoizedState||(c.flags|=1024),c.memoizedProps=g,c.memoizedState=fe),T.props=g,T.state=fe,T.context=q,g=ge):(typeof T.componentDidUpdate!="function"||I===l.memoizedProps&&ue===l.memoizedState||(c.flags|=4),typeof T.getSnapshotBeforeUpdate!="function"||I===l.memoizedProps&&ue===l.memoizedState||(c.flags|=1024),g=!1)}return T=g,qg(l,c),g=(c.flags&128)!==0,T||g?(T=c.stateNode,f=g&&typeof f.getDerivedStateFromError!="function"?null:T.render(),c.flags|=1,l!==null&&g?(c.child=ul(c,l.child,null,v),c.child=ul(c,null,f,v)):is(l,c,f,v),c.memoizedState=T.state,l=c.child):l=ia(l,c,v),l}function A_(l,c,f,g){return sl(),c.flags|=256,is(l,c,f,g),c.child}var Zv={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Qv(l){return{baseLanes:l,cachePool:wI()}}function e1(l,c,f){return l=l!==null?l.childLanes&~f:0,c&&(l|=cr),l}function R_(l,c,f){var g=c.pendingProps,v=!1,T=(c.flags&128)!==0,I;if((I=T)||(I=l!==null&&l.memoizedState===null?!1:(fn.current&2)!==0),I&&(v=!0,c.flags&=-129),I=(c.flags&32)!==0,c.flags&=-33,l===null){if(pt){if(v?Ya(c):Ja(),(l=Ut)?(l=BA(l,Dr),l=l!==null&&l.data!=="&"?l:null,l!==null&&(c.memoizedState={dehydrated:l,treeContext:ja!==null?{id:Ni,overflow:ki}:null,retryLane:536870912,hydrationErrors:null},f=hI(l),f.return=c,c.child=f,ss=c,Ut=null)):l=null,l===null)throw Ga(c);return L1(l)?c.lanes=32:c.lanes=536870912,null}var z=g.children;return g=g.fallback,v?(Ja(),v=c.mode,z=Kg({mode:"hidden",children:z},v),g=nl(g,v,f,null),z.return=c,g.return=c,z.sibling=g,c.child=z,g=c.child,g.memoizedState=Qv(f),g.childLanes=e1(l,I,f),c.memoizedState=Zv,Gd(null,g)):(Ya(c),t1(c,z))}var q=l.memoizedState;if(q!==null&&(z=q.dehydrated,z!==null)){if(T)c.flags&256?(Ya(c),c.flags&=-257,c=n1(l,c,f)):c.memoizedState!==null?(Ja(),c.child=l.child,c.flags|=128,c=null):(Ja(),z=g.fallback,v=c.mode,g=Kg({mode:"visible",children:g.children},v),z=nl(z,v,f,null),z.flags|=2,g.return=c,z.return=c,g.sibling=z,c.child=g,ul(c,l.child,null,f),g=c.child,g.memoizedState=Qv(f),g.childLanes=e1(l,I,f),c.memoizedState=Zv,c=Gd(null,g));else if(Ya(c),L1(z)){if(I=z.nextSibling&&z.nextSibling.dataset,I)var le=I.dgst;I=le,g=Error(s(419)),g.stack="",g.digest=I,Dd({value:g,source:null,stack:null}),c=n1(l,c,f)}else if(Sn||ju(l,c,f,!1),I=(f&l.childLanes)!==0,Sn||I){if(I=Ft,I!==null&&(g=b$(I,f),g!==0&&g!==q.retryLane))throw q.retryLane=g,tl(l,g),Us(I,l,g),Yv;F1(z)||sy(),c=n1(l,c,f)}else F1(z)?(c.flags|=192,c.child=l.child,c=null):(l=q.treeContext,Ut=Fr(z.nextSibling),ss=c,pt=!0,Wa=null,Dr=!1,l!==null&&pI(c,l),c=t1(c,g.children),c.flags|=4096);return c}return v?(Ja(),z=g.fallback,v=c.mode,q=l.child,le=q.sibling,g=Qi(q,{mode:"hidden",children:g.children}),g.subtreeFlags=q.subtreeFlags&65011712,le!==null?z=Qi(le,z):(z=nl(z,v,f,null),z.flags|=2),z.return=c,g.return=c,g.sibling=z,c.child=g,Gd(null,g),g=c.child,z=l.child.memoizedState,z===null?z=Qv(f):(v=z.cachePool,v!==null?(q=wn._currentValue,v=v.parent!==q?{parent:q,pool:q}:v):v=wI(),z={baseLanes:z.baseLanes|f,cachePool:v}),g.memoizedState=z,g.childLanes=e1(l,I,f),c.memoizedState=Zv,Gd(l.child,g)):(Ya(c),f=l.child,l=f.sibling,f=Qi(f,{mode:"visible",children:g.children}),f.return=c,f.sibling=null,l!==null&&(I=c.deletions,I===null?(c.deletions=[l],c.flags|=16):I.push(l)),c.child=f,c.memoizedState=null,f)}function t1(l,c){return c=Kg({mode:"visible",children:c},l.mode),c.return=l,l.child=c}function Kg(l,c){return l=ar(22,l,null,c),l.lanes=0,l}function n1(l,c,f){return ul(c,l.child,null,f),l=t1(c,c.pendingProps.children),l.flags|=2,c.memoizedState=null,l}function D_(l,c,f){l.lanes|=c;var g=l.alternate;g!==null&&(g.lanes|=c),yv(l.return,c,f)}function s1(l,c,f,g,v,T){var I=l.memoizedState;I===null?l.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:g,tail:f,tailMode:v,treeForkCount:T}:(I.isBackwards=c,I.rendering=null,I.renderingStartTime=0,I.last=g,I.tail=f,I.tailMode=v,I.treeForkCount=T)}function O_(l,c,f){var g=c.pendingProps,v=g.revealOrder,T=g.tail;g=g.children;var I=fn.current,z=(I&2)!==0;if(z?(I=I&1|2,c.flags|=128):I&=1,ne(fn,I),is(l,c,g,f),g=pt?Rd:0,!z&&l!==null&&(l.flags&128)!==0)e:for(l=c.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&D_(l,f,c);else if(l.tag===19)D_(l,f,c);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===c)break e;for(;l.sibling===null;){if(l.return===null||l.return===c)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}switch(v){case"forwards":for(f=c.child,v=null;f!==null;)l=f.alternate,l!==null&&Lg(l)===null&&(v=f),f=f.sibling;f=v,f===null?(v=c.child,c.child=null):(v=f.sibling,f.sibling=null),s1(c,!1,v,f,T,g);break;case"backwards":case"unstable_legacy-backwards":for(f=null,v=c.child,c.child=null;v!==null;){if(l=v.alternate,l!==null&&Lg(l)===null){c.child=v;break}l=v.sibling,v.sibling=f,f=v,v=l}s1(c,!0,f,null,T,g);break;case"together":s1(c,!1,null,null,void 0,g);break;default:c.memoizedState=null}return c.child}function ia(l,c,f){if(l!==null&&(c.dependencies=l.dependencies),eo|=c.lanes,(f&c.childLanes)===0)if(l!==null){if(ju(l,c,f,!1),(f&c.childLanes)===0)return null}else return null;if(l!==null&&c.child!==l.child)throw Error(s(153));if(c.child!==null){for(l=c.child,f=Qi(l,l.pendingProps),c.child=f,f.return=c;l.sibling!==null;)l=l.sibling,f=f.sibling=Qi(l,l.pendingProps),f.return=c;f.sibling=null}return c.child}function r1(l,c){return(l.lanes&c)!==0?!0:(l=l.dependencies,!!(l!==null&&$g(l)))}function wW(l,c,f){switch(c.tag){case 3:Te(c,c.stateNode.containerInfo),Ha(c,wn,l.memoizedState.cache),sl();break;case 27:case 5:Ve(c);break;case 4:Te(c,c.stateNode.containerInfo);break;case 10:Ha(c,c.type,c.memoizedProps.value);break;case 31:if(c.memoizedState!==null)return c.flags|=128,Iv(c),null;break;case 13:var g=c.memoizedState;if(g!==null)return g.dehydrated!==null?(Ya(c),c.flags|=128,null):(f&c.child.childLanes)!==0?R_(l,c,f):(Ya(c),l=ia(l,c,f),l!==null?l.sibling:null);Ya(c);break;case 19:var v=(l.flags&128)!==0;if(g=(f&c.childLanes)!==0,g||(ju(l,c,f,!1),g=(f&c.childLanes)!==0),v){if(g)return O_(l,c,f);c.flags|=128}if(v=c.memoizedState,v!==null&&(v.rendering=null,v.tail=null,v.lastEffect=null),ne(fn,fn.current),g)break;return null;case 22:return c.lanes=0,k_(l,c,f,c.pendingProps);case 24:Ha(c,wn,l.memoizedState.cache)}return ia(l,c,f)}function F_(l,c,f){if(l!==null)if(l.memoizedProps!==c.pendingProps)Sn=!0;else{if(!r1(l,f)&&(c.flags&128)===0)return Sn=!1,wW(l,c,f);Sn=(l.flags&131072)!==0}else Sn=!1,pt&&(c.flags&1048576)!==0&&fI(c,Rd,c.index);switch(c.lanes=0,c.tag){case 16:e:{var g=c.pendingProps;if(l=ol(c.elementType),c.type=l,typeof l=="function")uv(l)?(g=hl(l,g),c.tag=1,c=__(null,c,l,g,f)):(c.tag=0,c=Jv(null,c,l,g,f));else{if(l!=null){var v=l.$$typeof;if(v===k){c.tag=11,c=T_(null,c,l,g,f);break e}else if(v===R){c.tag=14,c=C_(null,c,l,g,f);break e}}throw c=te(l)||l,Error(s(306,c,""))}}return c;case 0:return Jv(l,c,c.type,c.pendingProps,f);case 1:return g=c.type,v=hl(g,c.pendingProps),__(l,c,g,v,f);case 3:e:{if(Te(c,c.stateNode.containerInfo),l===null)throw Error(s(387));g=c.pendingProps;var T=c.memoizedState;v=T.element,Cv(l,c),Bd(c,g,null,f);var I=c.memoizedState;if(g=I.cache,Ha(c,wn,g),g!==T.cache&&bv(c,[wn],f,!0),Pd(),g=I.element,T.isDehydrated)if(T={element:g,isDehydrated:!1,cache:I.cache},c.updateQueue.baseState=T,c.memoizedState=T,c.flags&256){c=A_(l,c,g,f);break e}else if(g!==v){v=_r(Error(s(424)),c),Dd(v),c=A_(l,c,g,f);break e}else for(l=c.stateNode.containerInfo,l.nodeType===9?l=l.body:l=l.nodeName==="HTML"?l.ownerDocument.body:l,Ut=Fr(l.firstChild),ss=c,pt=!0,Wa=null,Dr=!0,f=kI(c,null,g,f),c.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(sl(),g===v){c=ia(l,c,f);break e}is(l,c,g,f)}c=c.child}return c;case 26:return qg(l,c),l===null?(f=HA(c.type,null,c.pendingProps,null))?c.memoizedState=f:pt||(f=c.type,l=c.pendingProps,g=cy(de.current).createElement(f),g[ns]=c,g[Ls]=l,as(g,f,l),jn(g),c.stateNode=g):c.memoizedState=HA(c.type,l.memoizedProps,c.pendingProps,l.memoizedState),null;case 27:return Ve(c),l===null&&pt&&(g=c.stateNode=jA(c.type,c.pendingProps,de.current),ss=c,Dr=!0,v=Ut,io(c.type)?(M1=v,Ut=Fr(g.firstChild)):Ut=v),is(l,c,c.pendingProps.children,f),qg(l,c),l===null&&(c.flags|=4194304),c.child;case 5:return l===null&&pt&&((v=g=Ut)&&(g=YW(g,c.type,c.pendingProps,Dr),g!==null?(c.stateNode=g,ss=c,Ut=Fr(g.firstChild),Dr=!1,v=!0):v=!1),v||Ga(c)),Ve(c),v=c.type,T=c.pendingProps,I=l!==null?l.memoizedProps:null,g=T.children,R1(v,T)?g=null:I!==null&&R1(v,I)&&(c.flags|=32),c.memoizedState!==null&&(v=Av(l,c,hW,null,null,f),of._currentValue=v),qg(l,c),is(l,c,g,f),c.child;case 6:return l===null&&pt&&((l=f=Ut)&&(f=JW(f,c.pendingProps,Dr),f!==null?(c.stateNode=f,ss=c,Ut=null,l=!0):l=!1),l||Ga(c)),null;case 13:return R_(l,c,f);case 4:return Te(c,c.stateNode.containerInfo),g=c.pendingProps,l===null?c.child=ul(c,null,g,f):is(l,c,g,f),c.child;case 11:return T_(l,c,c.type,c.pendingProps,f);case 7:return is(l,c,c.pendingProps,f),c.child;case 8:return is(l,c,c.pendingProps.children,f),c.child;case 12:return is(l,c,c.pendingProps.children,f),c.child;case 10:return g=c.pendingProps,Ha(c,c.type,g.value),is(l,c,g.children,f),c.child;case 9:return v=c.type._context,g=c.pendingProps.children,il(c),v=rs(v),g=g(v),c.flags|=1,is(l,c,g,f),c.child;case 14:return C_(l,c,c.type,c.pendingProps,f);case 15:return N_(l,c,c.type,c.pendingProps,f);case 19:return O_(l,c,f);case 31:return xW(l,c,f);case 22:return k_(l,c,f,c.pendingProps);case 24:return il(c),g=rs(wn),l===null?(v=vv(),v===null&&(v=Ft,T=xv(),v.pooledCache=T,T.refCount++,T!==null&&(v.pooledCacheLanes|=f),v=T),c.memoizedState={parent:g,cache:v},Tv(c),Ha(c,wn,v)):((l.lanes&f)!==0&&(Cv(l,c),Bd(c,null,null,f),Pd()),v=l.memoizedState,T=c.memoizedState,v.parent!==g?(v={parent:g,cache:g},c.memoizedState=v,c.lanes===0&&(c.memoizedState=c.updateQueue.baseState=v),Ha(c,wn,g)):(g=T.cache,Ha(c,wn,g),g!==v.cache&&bv(c,[wn],f,!0))),is(l,c,c.pendingProps.children,f),c.child;case 29:throw c.pendingProps}throw Error(s(156,c.tag))}function aa(l){l.flags|=4}function i1(l,c,f,g,v){if((c=(l.mode&32)!==0)&&(c=!1),c){if(l.flags|=16777216,(v&335544128)===v)if(l.stateNode.complete)l.flags|=8192;else if(lA())l.flags|=8192;else throw ll=Rg,Sv}else l.flags&=-16777217}function L_(l,c){if(c.type!=="stylesheet"||(c.state.loading&4)!==0)l.flags&=-16777217;else if(l.flags|=16777216,!JA(c))if(lA())l.flags|=8192;else throw ll=Rg,Sv}function Xg(l,c){c!==null&&(l.flags|=4),l.flags&16384&&(c=l.tag!==22?m$():536870912,l.lanes|=c,tc|=c)}function Hd(l,c){if(!pt)switch(l.tailMode){case"hidden":c=l.tail;for(var f=null;c!==null;)c.alternate!==null&&(f=c),c=c.sibling;f===null?l.tail=null:f.sibling=null;break;case"collapsed":f=l.tail;for(var g=null;f!==null;)f.alternate!==null&&(g=f),f=f.sibling;g===null?c||l.tail===null?l.tail=null:l.tail.sibling=null:g.sibling=null}}function jt(l){var c=l.alternate!==null&&l.alternate.child===l.child,f=0,g=0;if(c)for(var v=l.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags&65011712,g|=v.flags&65011712,v.return=l,v=v.sibling;else for(v=l.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags,g|=v.flags,v.return=l,v=v.sibling;return l.subtreeFlags|=g,l.childLanes=f,c}function vW(l,c,f){var g=c.pendingProps;switch(fv(c),c.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jt(c),null;case 1:return jt(c),null;case 3:return f=c.stateNode,g=null,l!==null&&(g=l.memoizedState.cache),c.memoizedState.cache!==g&&(c.flags|=2048),na(wn),Ee(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(l===null||l.child===null)&&(Uu(c)?aa(c):l===null||l.memoizedState.isDehydrated&&(c.flags&256)===0||(c.flags|=1024,mv())),jt(c),null;case 26:var v=c.type,T=c.memoizedState;return l===null?(aa(c),T!==null?(jt(c),L_(c,T)):(jt(c),i1(c,v,null,g,f))):T?T!==l.memoizedState?(aa(c),jt(c),L_(c,T)):(jt(c),c.flags&=-16777217):(l=l.memoizedProps,l!==g&&aa(c),jt(c),i1(c,v,l,g,f)),null;case 27:if(je(c),f=de.current,v=c.type,l!==null&&c.stateNode!=null)l.memoizedProps!==g&&aa(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return jt(c),null}l=ce.current,Uu(c)?mI(c):(l=jA(v,g,f),c.stateNode=l,aa(c))}return jt(c),null;case 5:if(je(c),v=c.type,l!==null&&c.stateNode!=null)l.memoizedProps!==g&&aa(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return jt(c),null}if(T=ce.current,Uu(c))mI(c);else{var I=cy(de.current);switch(T){case 1:T=I.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:T=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":T=I.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":T=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":T=I.createElement("div"),T.innerHTML="<script><\/script>",T=T.removeChild(T.firstChild);break;case"select":T=typeof g.is=="string"?I.createElement("select",{is:g.is}):I.createElement("select"),g.multiple?T.multiple=!0:g.size&&(T.size=g.size);break;default:T=typeof g.is=="string"?I.createElement(v,{is:g.is}):I.createElement(v)}}T[ns]=c,T[Ls]=g;e:for(I=c.child;I!==null;){if(I.tag===5||I.tag===6)T.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===c)break e;for(;I.sibling===null;){if(I.return===null||I.return===c)break e;I=I.return}I.sibling.return=I.return,I=I.sibling}c.stateNode=T;e:switch(as(T,v,g),v){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break e;case"img":g=!0;break e;default:g=!1}g&&aa(c)}}return jt(c),i1(c,c.type,l===null?null:l.memoizedProps,c.pendingProps,f),null;case 6:if(l&&c.stateNode!=null)l.memoizedProps!==g&&aa(c);else{if(typeof g!="string"&&c.stateNode===null)throw Error(s(166));if(l=de.current,Uu(c)){if(l=c.stateNode,f=c.memoizedProps,g=null,v=ss,v!==null)switch(v.tag){case 27:case 5:g=v.memoizedProps}l[ns]=c,l=!!(l.nodeValue===f||g!==null&&g.suppressHydrationWarning===!0||RA(l.nodeValue,f)),l||Ga(c,!0)}else l=cy(l).createTextNode(g),l[ns]=c,c.stateNode=l}return jt(c),null;case 31:if(f=c.memoizedState,l===null||l.memoizedState!==null){if(g=Uu(c),f!==null){if(l===null){if(!g)throw Error(s(318));if(l=c.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(s(557));l[ns]=c}else sl(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;jt(c),l=!1}else f=mv(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=f),l=!0;if(!l)return c.flags&256?(lr(c),c):(lr(c),null);if((c.flags&128)!==0)throw Error(s(558))}return jt(c),null;case 13:if(g=c.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(v=Uu(c),g!==null&&g.dehydrated!==null){if(l===null){if(!v)throw Error(s(318));if(v=c.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(s(317));v[ns]=c}else sl(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;jt(c),v=!1}else v=mv(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=v),v=!0;if(!v)return c.flags&256?(lr(c),c):(lr(c),null)}return lr(c),(c.flags&128)!==0?(c.lanes=f,c):(f=g!==null,l=l!==null&&l.memoizedState!==null,f&&(g=c.child,v=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(v=g.alternate.memoizedState.cachePool.pool),T=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(T=g.memoizedState.cachePool.pool),T!==v&&(g.flags|=2048)),f!==l&&f&&(c.child.flags|=8192),Xg(c,c.updateQueue),jt(c),null);case 4:return Ee(),l===null&&E1(c.stateNode.containerInfo),jt(c),null;case 10:return na(c.type),jt(c),null;case 19:if(H(fn),g=c.memoizedState,g===null)return jt(c),null;if(v=(c.flags&128)!==0,T=g.rendering,T===null)if(v)Hd(g,!1);else{if(rn!==0||l!==null&&(l.flags&128)!==0)for(l=c.child;l!==null;){if(T=Lg(l),T!==null){for(c.flags|=128,Hd(g,!1),l=T.updateQueue,c.updateQueue=l,Xg(c,l),c.subtreeFlags=0,l=f,f=c.child;f!==null;)cI(f,l),f=f.sibling;return ne(fn,fn.current&1|2),pt&&ea(c,g.treeForkCount),c.child}l=l.sibling}g.tail!==null&&Vt()>ey&&(c.flags|=128,v=!0,Hd(g,!1),c.lanes=4194304)}else{if(!v)if(l=Lg(T),l!==null){if(c.flags|=128,v=!0,l=l.updateQueue,c.updateQueue=l,Xg(c,l),Hd(g,!0),g.tail===null&&g.tailMode==="hidden"&&!T.alternate&&!pt)return jt(c),null}else 2*Vt()-g.renderingStartTime>ey&&f!==536870912&&(c.flags|=128,v=!0,Hd(g,!1),c.lanes=4194304);g.isBackwards?(T.sibling=c.child,c.child=T):(l=g.last,l!==null?l.sibling=T:c.child=T,g.last=T)}return g.tail!==null?(l=g.tail,g.rendering=l,g.tail=l.sibling,g.renderingStartTime=Vt(),l.sibling=null,f=fn.current,ne(fn,v?f&1|2:f&1),pt&&ea(c,g.treeForkCount),l):(jt(c),null);case 22:case 23:return lr(c),$v(),g=c.memoizedState!==null,l!==null?l.memoizedState!==null!==g&&(c.flags|=8192):g&&(c.flags|=8192),g?(f&536870912)!==0&&(c.flags&128)===0&&(jt(c),c.subtreeFlags&6&&(c.flags|=8192)):jt(c),f=c.updateQueue,f!==null&&Xg(c,f.retryQueue),f=null,l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),g=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(g=c.memoizedState.cachePool.pool),g!==f&&(c.flags|=2048),l!==null&&H(al),null;case 24:return f=null,l!==null&&(f=l.memoizedState.cache),c.memoizedState.cache!==f&&(c.flags|=2048),na(wn),jt(c),null;case 25:return null;case 30:return null}throw Error(s(156,c.tag))}function SW(l,c){switch(fv(c),c.tag){case 1:return l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 3:return na(wn),Ee(),l=c.flags,(l&65536)!==0&&(l&128)===0?(c.flags=l&-65537|128,c):null;case 26:case 27:case 5:return je(c),null;case 31:if(c.memoizedState!==null){if(lr(c),c.alternate===null)throw Error(s(340));sl()}return l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 13:if(lr(c),l=c.memoizedState,l!==null&&l.dehydrated!==null){if(c.alternate===null)throw Error(s(340));sl()}return l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 19:return H(fn),null;case 4:return Ee(),null;case 10:return na(c.type),null;case 22:case 23:return lr(c),$v(),l!==null&&H(al),l=c.flags,l&65536?(c.flags=l&-65537|128,c):null;case 24:return na(wn),null;case 25:return null;default:return null}}function M_(l,c){switch(fv(c),c.tag){case 3:na(wn),Ee();break;case 26:case 27:case 5:je(c);break;case 4:Ee();break;case 31:c.memoizedState!==null&&lr(c);break;case 13:lr(c);break;case 19:H(fn);break;case 10:na(c.type);break;case 22:case 23:lr(c),$v(),l!==null&&H(al);break;case 24:na(wn)}}function qd(l,c){try{var f=c.updateQueue,g=f!==null?f.lastEffect:null;if(g!==null){var v=g.next;f=v;do{if((f.tag&l)===l){g=void 0;var T=f.create,I=f.inst;g=T(),I.destroy=g}f=f.next}while(f!==v)}}catch(z){Et(c,c.return,z)}}function Za(l,c,f){try{var g=c.updateQueue,v=g!==null?g.lastEffect:null;if(v!==null){var T=v.next;g=T;do{if((g.tag&l)===l){var I=g.inst,z=I.destroy;if(z!==void 0){I.destroy=void 0,v=c;var q=f,le=z;try{le()}catch(ge){Et(v,q,ge)}}}g=g.next}while(g!==T)}}catch(ge){Et(c,c.return,ge)}}function z_(l){var c=l.updateQueue;if(c!==null){var f=l.stateNode;try{$I(c,f)}catch(g){Et(l,l.return,g)}}}function P_(l,c,f){f.props=hl(l.type,l.memoizedProps),f.state=l.memoizedState;try{f.componentWillUnmount()}catch(g){Et(l,c,g)}}function Kd(l,c){try{var f=l.ref;if(f!==null){switch(l.tag){case 26:case 27:case 5:var g=l.stateNode;break;case 30:g=l.stateNode;break;default:g=l.stateNode}typeof f=="function"?l.refCleanup=f(g):f.current=g}}catch(v){Et(l,c,v)}}function Ei(l,c){var f=l.ref,g=l.refCleanup;if(f!==null)if(typeof g=="function")try{g()}catch(v){Et(l,c,v)}finally{l.refCleanup=null,l=l.alternate,l!=null&&(l.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(v){Et(l,c,v)}else f.current=null}function B_(l){var c=l.type,f=l.memoizedProps,g=l.stateNode;try{e:switch(c){case"button":case"input":case"select":case"textarea":f.autoFocus&&g.focus();break e;case"img":f.src?g.src=f.src:f.srcSet&&(g.srcset=f.srcSet)}}catch(v){Et(l,l.return,v)}}function a1(l,c,f){try{var g=l.stateNode;WW(g,l.type,f,c),g[Ls]=c}catch(v){Et(l,l.return,v)}}function V_(l){return l.tag===5||l.tag===3||l.tag===26||l.tag===27&&io(l.type)||l.tag===4}function o1(l){e:for(;;){for(;l.sibling===null;){if(l.return===null||V_(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.tag===27&&io(l.type)||l.flags&2||l.child===null||l.tag===4)continue e;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function l1(l,c,f){var g=l.tag;if(g===5||g===6)l=l.stateNode,c?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(l,c):(c=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,c.appendChild(l),f=f._reactRootContainer,f!=null||c.onclick!==null||(c.onclick=Ji));else if(g!==4&&(g===27&&io(l.type)&&(f=l.stateNode,c=null),l=l.child,l!==null))for(l1(l,c,f),l=l.sibling;l!==null;)l1(l,c,f),l=l.sibling}function Yg(l,c,f){var g=l.tag;if(g===5||g===6)l=l.stateNode,c?f.insertBefore(l,c):f.appendChild(l);else if(g!==4&&(g===27&&io(l.type)&&(f=l.stateNode),l=l.child,l!==null))for(Yg(l,c,f),l=l.sibling;l!==null;)Yg(l,c,f),l=l.sibling}function U_(l){var c=l.stateNode,f=l.memoizedProps;try{for(var g=l.type,v=c.attributes;v.length;)c.removeAttributeNode(v[0]);as(c,g,f),c[ns]=l,c[Ls]=f}catch(T){Et(l,l.return,T)}}var oa=!1,Tn=!1,u1=!1,j_=typeof WeakSet=="function"?WeakSet:Set,Wn=null;function TW(l,c){if(l=l.containerInfo,_1=yy,l=tI(l),nv(l)){if("selectionStart"in l)var f={start:l.selectionStart,end:l.selectionEnd};else e:{f=(f=l.ownerDocument)&&f.defaultView||window;var g=f.getSelection&&f.getSelection();if(g&&g.rangeCount!==0){f=g.anchorNode;var v=g.anchorOffset,T=g.focusNode;g=g.focusOffset;try{f.nodeType,T.nodeType}catch{f=null;break e}var I=0,z=-1,q=-1,le=0,ge=0,be=l,ue=null;t:for(;;){for(var fe;be!==f||v!==0&&be.nodeType!==3||(z=I+v),be!==T||g!==0&&be.nodeType!==3||(q=I+g),be.nodeType===3&&(I+=be.nodeValue.length),(fe=be.firstChild)!==null;)ue=be,be=fe;for(;;){if(be===l)break t;if(ue===f&&++le===v&&(z=I),ue===T&&++ge===g&&(q=I),(fe=be.nextSibling)!==null)break;be=ue,ue=be.parentNode}be=fe}f=z===-1||q===-1?null:{start:z,end:q}}else f=null}f=f||{start:0,end:0}}else f=null;for(A1={focusedElem:l,selectionRange:f},yy=!1,Wn=c;Wn!==null;)if(c=Wn,l=c.child,(c.subtreeFlags&1028)!==0&&l!==null)l.return=c,Wn=l;else for(;Wn!==null;){switch(c=Wn,T=c.alternate,l=c.flags,c.tag){case 0:if((l&4)!==0&&(l=c.updateQueue,l=l!==null?l.events:null,l!==null))for(f=0;f<l.length;f++)v=l[f],v.ref.impl=v.nextImpl;break;case 11:case 15:break;case 1:if((l&1024)!==0&&T!==null){l=void 0,f=c,v=T.memoizedProps,T=T.memoizedState,g=f.stateNode;try{var Re=hl(f.type,v);l=g.getSnapshotBeforeUpdate(Re,T),g.__reactInternalSnapshotBeforeUpdate=l}catch(Ue){Et(f,f.return,Ue)}}break;case 3:if((l&1024)!==0){if(l=c.stateNode.containerInfo,f=l.nodeType,f===9)O1(l);else if(f===1)switch(l.nodeName){case"HEAD":case"HTML":case"BODY":O1(l);break;default:l.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((l&1024)!==0)throw Error(s(163))}if(l=c.sibling,l!==null){l.return=c.return,Wn=l;break}Wn=c.return}}function W_(l,c,f){var g=f.flags;switch(f.tag){case 0:case 11:case 15:ua(l,f),g&4&&qd(5,f);break;case 1:if(ua(l,f),g&4)if(l=f.stateNode,c===null)try{l.componentDidMount()}catch(I){Et(f,f.return,I)}else{var v=hl(f.type,c.memoizedProps);c=c.memoizedState;try{l.componentDidUpdate(v,c,l.__reactInternalSnapshotBeforeUpdate)}catch(I){Et(f,f.return,I)}}g&64&&z_(f),g&512&&Kd(f,f.return);break;case 3:if(ua(l,f),g&64&&(l=f.updateQueue,l!==null)){if(c=null,f.child!==null)switch(f.child.tag){case 27:case 5:c=f.child.stateNode;break;case 1:c=f.child.stateNode}try{$I(l,c)}catch(I){Et(f,f.return,I)}}break;case 27:c===null&&g&4&&U_(f);case 26:case 5:ua(l,f),c===null&&g&4&&B_(f),g&512&&Kd(f,f.return);break;case 12:ua(l,f);break;case 31:ua(l,f),g&4&&q_(l,f);break;case 13:ua(l,f),g&4&&K_(l,f),g&64&&(l=f.memoizedState,l!==null&&(l=l.dehydrated,l!==null&&(f=RW.bind(null,f),ZW(l,f))));break;case 22:if(g=f.memoizedState!==null||oa,!g){c=c!==null&&c.memoizedState!==null||Tn,v=oa;var T=Tn;oa=g,(Tn=c)&&!T?ca(l,f,(f.subtreeFlags&8772)!==0):ua(l,f),oa=v,Tn=T}break;case 30:break;default:ua(l,f)}}function G_(l){var c=l.alternate;c!==null&&(l.alternate=null,G_(c)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(c=l.stateNode,c!==null&&Pw(c)),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}var Ht=null,zs=!1;function la(l,c,f){for(f=f.child;f!==null;)H_(l,c,f),f=f.sibling}function H_(l,c,f){if(Cs&&typeof Cs.onCommitFiberUnmount=="function")try{Cs.onCommitFiberUnmount(Ti,f)}catch{}switch(f.tag){case 26:Tn||Ei(f,c),la(l,c,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:Tn||Ei(f,c);var g=Ht,v=zs;io(f.type)&&(Ht=f.stateNode,zs=!1),la(l,c,f),sf(f.stateNode),Ht=g,zs=v;break;case 5:Tn||Ei(f,c);case 6:if(g=Ht,v=zs,Ht=null,la(l,c,f),Ht=g,zs=v,Ht!==null)if(zs)try{(Ht.nodeType===9?Ht.body:Ht.nodeName==="HTML"?Ht.ownerDocument.body:Ht).removeChild(f.stateNode)}catch(T){Et(f,c,T)}else try{Ht.removeChild(f.stateNode)}catch(T){Et(f,c,T)}break;case 18:Ht!==null&&(zs?(l=Ht,zA(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,f.stateNode),uc(l)):zA(Ht,f.stateNode));break;case 4:g=Ht,v=zs,Ht=f.stateNode.containerInfo,zs=!0,la(l,c,f),Ht=g,zs=v;break;case 0:case 11:case 14:case 15:Za(2,f,c),Tn||Za(4,f,c),la(l,c,f);break;case 1:Tn||(Ei(f,c),g=f.stateNode,typeof g.componentWillUnmount=="function"&&P_(f,c,g)),la(l,c,f);break;case 21:la(l,c,f);break;case 22:Tn=(g=Tn)||f.memoizedState!==null,la(l,c,f),Tn=g;break;default:la(l,c,f)}}function q_(l,c){if(c.memoizedState===null&&(l=c.alternate,l!==null&&(l=l.memoizedState,l!==null))){l=l.dehydrated;try{uc(l)}catch(f){Et(c,c.return,f)}}}function K_(l,c){if(c.memoizedState===null&&(l=c.alternate,l!==null&&(l=l.memoizedState,l!==null&&(l=l.dehydrated,l!==null))))try{uc(l)}catch(f){Et(c,c.return,f)}}function CW(l){switch(l.tag){case 31:case 13:case 19:var c=l.stateNode;return c===null&&(c=l.stateNode=new j_),c;case 22:return l=l.stateNode,c=l._retryCache,c===null&&(c=l._retryCache=new j_),c;default:throw Error(s(435,l.tag))}}function Jg(l,c){var f=CW(l);c.forEach(function(g){if(!f.has(g)){f.add(g);var v=DW.bind(null,l,g);g.then(v,v)}})}function Ps(l,c){var f=c.deletions;if(f!==null)for(var g=0;g<f.length;g++){var v=f[g],T=l,I=c,z=I;e:for(;z!==null;){switch(z.tag){case 27:if(io(z.type)){Ht=z.stateNode,zs=!1;break e}break;case 5:Ht=z.stateNode,zs=!1;break e;case 3:case 4:Ht=z.stateNode.containerInfo,zs=!0;break e}z=z.return}if(Ht===null)throw Error(s(160));H_(T,I,v),Ht=null,zs=!1,T=v.alternate,T!==null&&(T.return=null),v.return=null}if(c.subtreeFlags&13886)for(c=c.child;c!==null;)X_(c,l),c=c.sibling}var Qr=null;function X_(l,c){var f=l.alternate,g=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:Ps(c,l),Bs(l),g&4&&(Za(3,l,l.return),qd(3,l),Za(5,l,l.return));break;case 1:Ps(c,l),Bs(l),g&512&&(Tn||f===null||Ei(f,f.return)),g&64&&oa&&(l=l.updateQueue,l!==null&&(g=l.callbacks,g!==null&&(f=l.shared.hiddenCallbacks,l.shared.hiddenCallbacks=f===null?g:f.concat(g))));break;case 26:var v=Qr;if(Ps(c,l),Bs(l),g&512&&(Tn||f===null||Ei(f,f.return)),g&4){var T=f!==null?f.memoizedState:null;if(g=l.memoizedState,f===null)if(g===null)if(l.stateNode===null){e:{g=l.type,f=l.memoizedProps,v=v.ownerDocument||v;t:switch(g){case"title":T=v.getElementsByTagName("title")[0],(!T||T[vd]||T[ns]||T.namespaceURI==="http://www.w3.org/2000/svg"||T.hasAttribute("itemprop"))&&(T=v.createElement(g),v.head.insertBefore(T,v.querySelector("head > title"))),as(T,g,f),T[ns]=l,jn(T),g=T;break e;case"link":var I=XA("link","href",v).get(g+(f.href||""));if(I){for(var z=0;z<I.length;z++)if(T=I[z],T.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&T.getAttribute("rel")===(f.rel==null?null:f.rel)&&T.getAttribute("title")===(f.title==null?null:f.title)&&T.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){I.splice(z,1);break t}}T=v.createElement(g),as(T,g,f),v.head.appendChild(T);break;case"meta":if(I=XA("meta","content",v).get(g+(f.content||""))){for(z=0;z<I.length;z++)if(T=I[z],T.getAttribute("content")===(f.content==null?null:""+f.content)&&T.getAttribute("name")===(f.name==null?null:f.name)&&T.getAttribute("property")===(f.property==null?null:f.property)&&T.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&T.getAttribute("charset")===(f.charSet==null?null:f.charSet)){I.splice(z,1);break t}}T=v.createElement(g),as(T,g,f),v.head.appendChild(T);break;default:throw Error(s(468,g))}T[ns]=l,jn(T),g=T}l.stateNode=g}else YA(v,l.type,l.stateNode);else l.stateNode=KA(v,g,l.memoizedProps);else T!==g?(T===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):T.count--,g===null?YA(v,l.type,l.stateNode):KA(v,g,l.memoizedProps)):g===null&&l.stateNode!==null&&a1(l,l.memoizedProps,f.memoizedProps)}break;case 27:Ps(c,l),Bs(l),g&512&&(Tn||f===null||Ei(f,f.return)),f!==null&&g&4&&a1(l,l.memoizedProps,f.memoizedProps);break;case 5:if(Ps(c,l),Bs(l),g&512&&(Tn||f===null||Ei(f,f.return)),l.flags&32){v=l.stateNode;try{Ru(v,"")}catch(Re){Et(l,l.return,Re)}}g&4&&l.stateNode!=null&&(v=l.memoizedProps,a1(l,v,f!==null?f.memoizedProps:v)),g&1024&&(u1=!0);break;case 6:if(Ps(c,l),Bs(l),g&4){if(l.stateNode===null)throw Error(s(162));g=l.memoizedProps,f=l.stateNode;try{f.nodeValue=g}catch(Re){Et(l,l.return,Re)}}break;case 3:if(fy=null,v=Qr,Qr=hy(c.containerInfo),Ps(c,l),Qr=v,Bs(l),g&4&&f!==null&&f.memoizedState.isDehydrated)try{uc(c.containerInfo)}catch(Re){Et(l,l.return,Re)}u1&&(u1=!1,Y_(l));break;case 4:g=Qr,Qr=hy(l.stateNode.containerInfo),Ps(c,l),Bs(l),Qr=g;break;case 12:Ps(c,l),Bs(l);break;case 31:Ps(c,l),Bs(l),g&4&&(g=l.updateQueue,g!==null&&(l.updateQueue=null,Jg(l,g)));break;case 13:Ps(c,l),Bs(l),l.child.flags&8192&&l.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(Qg=Vt()),g&4&&(g=l.updateQueue,g!==null&&(l.updateQueue=null,Jg(l,g)));break;case 22:v=l.memoizedState!==null;var q=f!==null&&f.memoizedState!==null,le=oa,ge=Tn;if(oa=le||v,Tn=ge||q,Ps(c,l),Tn=ge,oa=le,Bs(l),g&8192)e:for(c=l.stateNode,c._visibility=v?c._visibility&-2:c._visibility|1,v&&(f===null||q||oa||Tn||dl(l)),f=null,c=l;;){if(c.tag===5||c.tag===26){if(f===null){q=f=c;try{if(T=q.stateNode,v)I=T.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{z=q.stateNode;var be=q.memoizedProps.style,ue=be!=null&&be.hasOwnProperty("display")?be.display:null;z.style.display=ue==null||typeof ue=="boolean"?"":(""+ue).trim()}}catch(Re){Et(q,q.return,Re)}}}else if(c.tag===6){if(f===null){q=c;try{q.stateNode.nodeValue=v?"":q.memoizedProps}catch(Re){Et(q,q.return,Re)}}}else if(c.tag===18){if(f===null){q=c;try{var fe=q.stateNode;v?PA(fe,!0):PA(q.stateNode,!1)}catch(Re){Et(q,q.return,Re)}}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===l)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===l)break e;for(;c.sibling===null;){if(c.return===null||c.return===l)break e;f===c&&(f=null),c=c.return}f===c&&(f=null),c.sibling.return=c.return,c=c.sibling}g&4&&(g=l.updateQueue,g!==null&&(f=g.retryQueue,f!==null&&(g.retryQueue=null,Jg(l,f))));break;case 19:Ps(c,l),Bs(l),g&4&&(g=l.updateQueue,g!==null&&(l.updateQueue=null,Jg(l,g)));break;case 30:break;case 21:break;default:Ps(c,l),Bs(l)}}function Bs(l){var c=l.flags;if(c&2){try{for(var f,g=l.return;g!==null;){if(V_(g)){f=g;break}g=g.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var v=f.stateNode,T=o1(l);Yg(l,T,v);break;case 5:var I=f.stateNode;f.flags&32&&(Ru(I,""),f.flags&=-33);var z=o1(l);Yg(l,z,I);break;case 3:case 4:var q=f.stateNode.containerInfo,le=o1(l);l1(l,le,q);break;default:throw Error(s(161))}}catch(ge){Et(l,l.return,ge)}l.flags&=-3}c&4096&&(l.flags&=-4097)}function Y_(l){if(l.subtreeFlags&1024)for(l=l.child;l!==null;){var c=l;Y_(c),c.tag===5&&c.flags&1024&&c.stateNode.reset(),l=l.sibling}}function ua(l,c){if(c.subtreeFlags&8772)for(c=c.child;c!==null;)W_(l,c.alternate,c),c=c.sibling}function dl(l){for(l=l.child;l!==null;){var c=l;switch(c.tag){case 0:case 11:case 14:case 15:Za(4,c,c.return),dl(c);break;case 1:Ei(c,c.return);var f=c.stateNode;typeof f.componentWillUnmount=="function"&&P_(c,c.return,f),dl(c);break;case 27:sf(c.stateNode);case 26:case 5:Ei(c,c.return),dl(c);break;case 22:c.memoizedState===null&&dl(c);break;case 30:dl(c);break;default:dl(c)}l=l.sibling}}function ca(l,c,f){for(f=f&&(c.subtreeFlags&8772)!==0,c=c.child;c!==null;){var g=c.alternate,v=l,T=c,I=T.flags;switch(T.tag){case 0:case 11:case 15:ca(v,T,f),qd(4,T);break;case 1:if(ca(v,T,f),g=T,v=g.stateNode,typeof v.componentDidMount=="function")try{v.componentDidMount()}catch(le){Et(g,g.return,le)}if(g=T,v=g.updateQueue,v!==null){var z=g.stateNode;try{var q=v.shared.hiddenCallbacks;if(q!==null)for(v.shared.hiddenCallbacks=null,v=0;v<q.length;v++)EI(q[v],z)}catch(le){Et(g,g.return,le)}}f&&I&64&&z_(T),Kd(T,T.return);break;case 27:U_(T);case 26:case 5:ca(v,T,f),f&&g===null&&I&4&&B_(T),Kd(T,T.return);break;case 12:ca(v,T,f);break;case 31:ca(v,T,f),f&&I&4&&q_(v,T);break;case 13:ca(v,T,f),f&&I&4&&K_(v,T);break;case 22:T.memoizedState===null&&ca(v,T,f),Kd(T,T.return);break;case 30:break;default:ca(v,T,f)}c=c.sibling}}function c1(l,c){var f=null;l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(f=l.memoizedState.cachePool.pool),l=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(l=c.memoizedState.cachePool.pool),l!==f&&(l!=null&&l.refCount++,f!=null&&Od(f))}function h1(l,c){l=null,c.alternate!==null&&(l=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==l&&(c.refCount++,l!=null&&Od(l))}function ei(l,c,f,g){if(c.subtreeFlags&10256)for(c=c.child;c!==null;)J_(l,c,f,g),c=c.sibling}function J_(l,c,f,g){var v=c.flags;switch(c.tag){case 0:case 11:case 15:ei(l,c,f,g),v&2048&&qd(9,c);break;case 1:ei(l,c,f,g);break;case 3:ei(l,c,f,g),v&2048&&(l=null,c.alternate!==null&&(l=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==l&&(c.refCount++,l!=null&&Od(l)));break;case 12:if(v&2048){ei(l,c,f,g),l=c.stateNode;try{var T=c.memoizedProps,I=T.id,z=T.onPostCommit;typeof z=="function"&&z(I,c.alternate===null?"mount":"update",l.passiveEffectDuration,-0)}catch(q){Et(c,c.return,q)}}else ei(l,c,f,g);break;case 31:ei(l,c,f,g);break;case 13:ei(l,c,f,g);break;case 23:break;case 22:T=c.stateNode,I=c.alternate,c.memoizedState!==null?T._visibility&2?ei(l,c,f,g):Xd(l,c):T._visibility&2?ei(l,c,f,g):(T._visibility|=2,Zu(l,c,f,g,(c.subtreeFlags&10256)!==0||!1)),v&2048&&c1(I,c);break;case 24:ei(l,c,f,g),v&2048&&h1(c.alternate,c);break;default:ei(l,c,f,g)}}function Zu(l,c,f,g,v){for(v=v&&((c.subtreeFlags&10256)!==0||!1),c=c.child;c!==null;){var T=l,I=c,z=f,q=g,le=I.flags;switch(I.tag){case 0:case 11:case 15:Zu(T,I,z,q,v),qd(8,I);break;case 23:break;case 22:var ge=I.stateNode;I.memoizedState!==null?ge._visibility&2?Zu(T,I,z,q,v):Xd(T,I):(ge._visibility|=2,Zu(T,I,z,q,v)),v&&le&2048&&c1(I.alternate,I);break;case 24:Zu(T,I,z,q,v),v&&le&2048&&h1(I.alternate,I);break;default:Zu(T,I,z,q,v)}c=c.sibling}}function Xd(l,c){if(c.subtreeFlags&10256)for(c=c.child;c!==null;){var f=l,g=c,v=g.flags;switch(g.tag){case 22:Xd(f,g),v&2048&&c1(g.alternate,g);break;case 24:Xd(f,g),v&2048&&h1(g.alternate,g);break;default:Xd(f,g)}c=c.sibling}}var Yd=8192;function Qu(l,c,f){if(l.subtreeFlags&Yd)for(l=l.child;l!==null;)Z_(l,c,f),l=l.sibling}function Z_(l,c,f){switch(l.tag){case 26:Qu(l,c,f),l.flags&Yd&&l.memoizedState!==null&&cG(f,Qr,l.memoizedState,l.memoizedProps);break;case 5:Qu(l,c,f);break;case 3:case 4:var g=Qr;Qr=hy(l.stateNode.containerInfo),Qu(l,c,f),Qr=g;break;case 22:l.memoizedState===null&&(g=l.alternate,g!==null&&g.memoizedState!==null?(g=Yd,Yd=16777216,Qu(l,c,f),Yd=g):Qu(l,c,f));break;default:Qu(l,c,f)}}function Q_(l){var c=l.alternate;if(c!==null&&(l=c.child,l!==null)){c.child=null;do c=l.sibling,l.sibling=null,l=c;while(l!==null)}}function Jd(l){var c=l.deletions;if((l.flags&16)!==0){if(c!==null)for(var f=0;f<c.length;f++){var g=c[f];Wn=g,tA(g,l)}Q_(l)}if(l.subtreeFlags&10256)for(l=l.child;l!==null;)eA(l),l=l.sibling}function eA(l){switch(l.tag){case 0:case 11:case 15:Jd(l),l.flags&2048&&Za(9,l,l.return);break;case 3:Jd(l);break;case 12:Jd(l);break;case 22:var c=l.stateNode;l.memoizedState!==null&&c._visibility&2&&(l.return===null||l.return.tag!==13)?(c._visibility&=-3,Zg(l)):Jd(l);break;default:Jd(l)}}function Zg(l){var c=l.deletions;if((l.flags&16)!==0){if(c!==null)for(var f=0;f<c.length;f++){var g=c[f];Wn=g,tA(g,l)}Q_(l)}for(l=l.child;l!==null;){switch(c=l,c.tag){case 0:case 11:case 15:Za(8,c,c.return),Zg(c);break;case 22:f=c.stateNode,f._visibility&2&&(f._visibility&=-3,Zg(c));break;default:Zg(c)}l=l.sibling}}function tA(l,c){for(;Wn!==null;){var f=Wn;switch(f.tag){case 0:case 11:case 15:Za(8,f,c);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var g=f.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Od(f.memoizedState.cache)}if(g=f.child,g!==null)g.return=f,Wn=g;else e:for(f=l;Wn!==null;){g=Wn;var v=g.sibling,T=g.return;if(G_(g),g===f){Wn=null;break e}if(v!==null){v.return=T,Wn=v;break e}Wn=T}}}var NW={getCacheForType:function(l){var c=rs(wn),f=c.data.get(l);return f===void 0&&(f=l(),c.data.set(l,f)),f},cacheSignal:function(){return rs(wn).controller.signal}},kW=typeof WeakMap=="function"?WeakMap:Map,Tt=0,Ft=null,ot=null,ht=0,kt=0,ur=null,Qa=!1,ec=!1,d1=!1,ha=0,rn=0,eo=0,fl=0,f1=0,cr=0,tc=0,Zd=null,Vs=null,p1=!1,Qg=0,nA=0,ey=1/0,ty=null,to=null,Rn=0,no=null,nc=null,da=0,m1=0,g1=null,sA=null,Qd=0,y1=null;function hr(){return(Tt&2)!==0&&ht!==0?ht&-ht:B.T!==null?T1():x$()}function rA(){if(cr===0)if((ht&536870912)===0||pt){var l=ug;ug<<=1,(ug&3932160)===0&&(ug=262144),cr=l}else cr=536870912;return l=or.current,l!==null&&(l.flags|=32),cr}function Us(l,c,f){(l===Ft&&(kt===2||kt===9)||l.cancelPendingCommit!==null)&&(sc(l,0),so(l,ht,cr,!1)),wd(l,f),((Tt&2)===0||l!==Ft)&&(l===Ft&&((Tt&2)===0&&(fl|=f),rn===4&&so(l,ht,cr,!1)),$i(l))}function iA(l,c,f){if((Tt&6)!==0)throw Error(s(327));var g=!f&&(c&127)===0&&(c&l.expiredLanes)===0||xd(l,c),v=g?IW(l,c):x1(l,c,!0),T=g;do{if(v===0){ec&&!g&&so(l,c,0,!1);break}else{if(f=l.current.alternate,T&&!EW(f)){v=x1(l,c,!1),T=!1;continue}if(v===2){if(T=c,l.errorRecoveryDisabledLanes&T)var I=0;else I=l.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){c=I;e:{var z=l;v=Zd;var q=z.current.memoizedState.isDehydrated;if(q&&(sc(z,I).flags|=256),I=x1(z,I,!1),I!==2){if(d1&&!q){z.errorRecoveryDisabledLanes|=T,fl|=T,v=4;break e}T=Vs,Vs=v,T!==null&&(Vs===null?Vs=T:Vs.push.apply(Vs,T))}v=I}if(T=!1,v!==2)continue}}if(v===1){sc(l,0),so(l,c,0,!0);break}e:{switch(g=l,T=v,T){case 0:case 1:throw Error(s(345));case 4:if((c&4194048)!==c)break;case 6:so(g,c,cr,!Qa);break e;case 2:Vs=null;break;case 3:case 5:break;default:throw Error(s(329))}if((c&62914560)===c&&(v=Qg+300-Vt(),10<v)){if(so(g,c,cr,!Qa),hg(g,0,!0)!==0)break e;da=c,g.timeoutHandle=LA(aA.bind(null,g,f,Vs,ty,p1,c,cr,fl,tc,Qa,T,"Throttled",-0,0),v);break e}aA(g,f,Vs,ty,p1,c,cr,fl,tc,Qa,T,null,-0,0)}}break}while(!0);$i(l)}function aA(l,c,f,g,v,T,I,z,q,le,ge,be,ue,fe){if(l.timeoutHandle=-1,be=c.subtreeFlags,be&8192||(be&16785408)===16785408){be={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Ji},Z_(c,T,be);var Re=(T&62914560)===T?Qg-Vt():(T&4194048)===T?nA-Vt():0;if(Re=hG(be,Re),Re!==null){da=T,l.cancelPendingCommit=Re(pA.bind(null,l,c,T,f,g,v,I,z,q,ge,be,null,ue,fe)),so(l,T,I,!le);return}}pA(l,c,T,f,g,v,I,z,q)}function EW(l){for(var c=l;;){var f=c.tag;if((f===0||f===11||f===15)&&c.flags&16384&&(f=c.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var g=0;g<f.length;g++){var v=f[g],T=v.getSnapshot;v=v.value;try{if(!ir(T(),v))return!1}catch{return!1}}if(f=c.child,c.subtreeFlags&16384&&f!==null)f.return=c,c=f;else{if(c===l)break;for(;c.sibling===null;){if(c.return===null||c.return===l)return!0;c=c.return}c.sibling.return=c.return,c=c.sibling}}return!0}function so(l,c,f,g){c&=~f1,c&=~fl,l.suspendedLanes|=c,l.pingedLanes&=~c,g&&(l.warmLanes|=c),g=l.expirationTimes;for(var v=c;0<v;){var T=31-rr(v),I=1<<T;g[T]=-1,v&=~I}f!==0&&g$(l,f,c)}function ny(){return(Tt&6)===0?(ef(0),!1):!0}function b1(){if(ot!==null){if(kt===0)var l=ot.return;else l=ot,ta=rl=null,Ov(l),qu=null,Ld=0,l=ot;for(;l!==null;)M_(l.alternate,l),l=l.return;ot=null}}function sc(l,c){var f=l.timeoutHandle;f!==-1&&(l.timeoutHandle=-1,qW(f)),f=l.cancelPendingCommit,f!==null&&(l.cancelPendingCommit=null,f()),da=0,b1(),Ft=l,ot=f=Qi(l.current,null),ht=c,kt=0,ur=null,Qa=!1,ec=xd(l,c),d1=!1,tc=cr=f1=fl=eo=rn=0,Vs=Zd=null,p1=!1,(c&8)!==0&&(c|=c&32);var g=l.entangledLanes;if(g!==0)for(l=l.entanglements,g&=c;0<g;){var v=31-rr(g),T=1<<v;c|=l[v],g&=~T}return ha=c,Tg(),f}function oA(l,c){et=null,B.H=Wd,c===Hu||c===Ag?(c=TI(),kt=3):c===Sv?(c=TI(),kt=4):kt=c===Yv?8:c!==null&&typeof c=="object"&&typeof c.then=="function"?6:1,ur=c,ot===null&&(rn=1,Gg(l,_r(c,l.current)))}function lA(){var l=or.current;return l===null?!0:(ht&4194048)===ht?Or===null:(ht&62914560)===ht||(ht&536870912)!==0?l===Or:!1}function uA(){var l=B.H;return B.H=Wd,l===null?Wd:l}function cA(){var l=B.A;return B.A=NW,l}function sy(){rn=4,Qa||(ht&4194048)!==ht&&or.current!==null||(ec=!0),(eo&134217727)===0&&(fl&134217727)===0||Ft===null||so(Ft,ht,cr,!1)}function x1(l,c,f){var g=Tt;Tt|=2;var v=uA(),T=cA();(Ft!==l||ht!==c)&&(ty=null,sc(l,c)),c=!1;var I=rn;e:do try{if(kt!==0&&ot!==null){var z=ot,q=ur;switch(kt){case 8:b1(),I=6;break e;case 3:case 2:case 9:case 6:or.current===null&&(c=!0);var le=kt;if(kt=0,ur=null,rc(l,z,q,le),f&&ec){I=0;break e}break;default:le=kt,kt=0,ur=null,rc(l,z,q,le)}}$W(),I=rn;break}catch(ge){oA(l,ge)}while(!0);return c&&l.shellSuspendCounter++,ta=rl=null,Tt=g,B.H=v,B.A=T,ot===null&&(Ft=null,ht=0,Tg()),I}function $W(){for(;ot!==null;)hA(ot)}function IW(l,c){var f=Tt;Tt|=2;var g=uA(),v=cA();Ft!==l||ht!==c?(ty=null,ey=Vt()+500,sc(l,c)):ec=xd(l,c);e:do try{if(kt!==0&&ot!==null){c=ot;var T=ur;t:switch(kt){case 1:kt=0,ur=null,rc(l,c,T,1);break;case 2:case 9:if(vI(T)){kt=0,ur=null,dA(c);break}c=function(){kt!==2&&kt!==9||Ft!==l||(kt=7),$i(l)},T.then(c,c);break e;case 3:kt=7;break e;case 4:kt=5;break e;case 7:vI(T)?(kt=0,ur=null,dA(c)):(kt=0,ur=null,rc(l,c,T,7));break;case 5:var I=null;switch(ot.tag){case 26:I=ot.memoizedState;case 5:case 27:var z=ot;if(I?JA(I):z.stateNode.complete){kt=0,ur=null;var q=z.sibling;if(q!==null)ot=q;else{var le=z.return;le!==null?(ot=le,ry(le)):ot=null}break t}}kt=0,ur=null,rc(l,c,T,5);break;case 6:kt=0,ur=null,rc(l,c,T,6);break;case 8:b1(),rn=6;break e;default:throw Error(s(462))}}_W();break}catch(ge){oA(l,ge)}while(!0);return ta=rl=null,B.H=g,B.A=v,Tt=f,ot!==null?0:(Ft=null,ht=0,Tg(),rn)}function _W(){for(;ot!==null&&!Ts();)hA(ot)}function hA(l){var c=F_(l.alternate,l,ha);l.memoizedProps=l.pendingProps,c===null?ry(l):ot=c}function dA(l){var c=l,f=c.alternate;switch(c.tag){case 15:case 0:c=I_(f,c,c.pendingProps,c.type,void 0,ht);break;case 11:c=I_(f,c,c.pendingProps,c.type.render,c.ref,ht);break;case 5:Ov(c);default:M_(f,c),c=ot=cI(c,ha),c=F_(f,c,ha)}l.memoizedProps=l.pendingProps,c===null?ry(l):ot=c}function rc(l,c,f,g){ta=rl=null,Ov(c),qu=null,Ld=0;var v=c.return;try{if(bW(l,v,c,f,ht)){rn=1,Gg(l,_r(f,l.current)),ot=null;return}}catch(T){if(v!==null)throw ot=v,T;rn=1,Gg(l,_r(f,l.current)),ot=null;return}c.flags&32768?(pt||g===1?l=!0:ec||(ht&536870912)!==0?l=!1:(Qa=l=!0,(g===2||g===9||g===3||g===6)&&(g=or.current,g!==null&&g.tag===13&&(g.flags|=16384))),fA(c,l)):ry(c)}function ry(l){var c=l;do{if((c.flags&32768)!==0){fA(c,Qa);return}l=c.return;var f=vW(c.alternate,c,ha);if(f!==null){ot=f;return}if(c=c.sibling,c!==null){ot=c;return}ot=c=l}while(c!==null);rn===0&&(rn=5)}function fA(l,c){do{var f=SW(l.alternate,l);if(f!==null){f.flags&=32767,ot=f;return}if(f=l.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!c&&(l=l.sibling,l!==null)){ot=l;return}ot=l=f}while(l!==null);rn=6,ot=null}function pA(l,c,f,g,v,T,I,z,q){l.cancelPendingCommit=null;do iy();while(Rn!==0);if((Tt&6)!==0)throw Error(s(327));if(c!==null){if(c===l.current)throw Error(s(177));if(T=c.lanes|c.childLanes,T|=ov,uj(l,f,T,I,z,q),l===Ft&&(ot=Ft=null,ht=0),nc=c,no=l,da=f,m1=T,g1=v,sA=g,(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?(l.callbackNode=null,l.callbackPriority=0,OW(sr,function(){return xA(),null})):(l.callbackNode=null,l.callbackPriority=0),g=(c.flags&13878)!==0,(c.subtreeFlags&13878)!==0||g){g=B.T,B.T=null,v=V.p,V.p=2,I=Tt,Tt|=4;try{TW(l,c,f)}finally{Tt=I,V.p=v,B.T=g}}Rn=1,mA(),gA(),yA()}}function mA(){if(Rn===1){Rn=0;var l=no,c=nc,f=(c.flags&13878)!==0;if((c.subtreeFlags&13878)!==0||f){f=B.T,B.T=null;var g=V.p;V.p=2;var v=Tt;Tt|=4;try{X_(c,l);var T=A1,I=tI(l.containerInfo),z=T.focusedElem,q=T.selectionRange;if(I!==z&&z&&z.ownerDocument&&eI(z.ownerDocument.documentElement,z)){if(q!==null&&nv(z)){var le=q.start,ge=q.end;if(ge===void 0&&(ge=le),"selectionStart"in z)z.selectionStart=le,z.selectionEnd=Math.min(ge,z.value.length);else{var be=z.ownerDocument||document,ue=be&&be.defaultView||window;if(ue.getSelection){var fe=ue.getSelection(),Re=z.textContent.length,Ue=Math.min(q.start,Re),Dt=q.end===void 0?Ue:Math.min(q.end,Re);!fe.extend&&Ue>Dt&&(I=Dt,Dt=Ue,Ue=I);var re=Q$(z,Ue),Q=Q$(z,Dt);if(re&&Q&&(fe.rangeCount!==1||fe.anchorNode!==re.node||fe.anchorOffset!==re.offset||fe.focusNode!==Q.node||fe.focusOffset!==Q.offset)){var oe=be.createRange();oe.setStart(re.node,re.offset),fe.removeAllRanges(),Ue>Dt?(fe.addRange(oe),fe.extend(Q.node,Q.offset)):(oe.setEnd(Q.node,Q.offset),fe.addRange(oe))}}}}for(be=[],fe=z;fe=fe.parentNode;)fe.nodeType===1&&be.push({element:fe,left:fe.scrollLeft,top:fe.scrollTop});for(typeof z.focus=="function"&&z.focus(),z=0;z<be.length;z++){var ye=be[z];ye.element.scrollLeft=ye.left,ye.element.scrollTop=ye.top}}yy=!!_1,A1=_1=null}finally{Tt=v,V.p=g,B.T=f}}l.current=c,Rn=2}}function gA(){if(Rn===2){Rn=0;var l=no,c=nc,f=(c.flags&8772)!==0;if((c.subtreeFlags&8772)!==0||f){f=B.T,B.T=null;var g=V.p;V.p=2;var v=Tt;Tt|=4;try{W_(l,c.alternate,c)}finally{Tt=v,V.p=g,B.T=f}}Rn=3}}function yA(){if(Rn===4||Rn===3){Rn=0,Xi();var l=no,c=nc,f=da,g=sA;(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?Rn=5:(Rn=0,nc=no=null,bA(l,l.pendingLanes));var v=l.pendingLanes;if(v===0&&(to=null),Mw(f),c=c.stateNode,Cs&&typeof Cs.onCommitFiberRoot=="function")try{Cs.onCommitFiberRoot(Ti,c,void 0,(c.current.flags&128)===128)}catch{}if(g!==null){c=B.T,v=V.p,V.p=2,B.T=null;try{for(var T=l.onRecoverableError,I=0;I<g.length;I++){var z=g[I];T(z.value,{componentStack:z.stack})}}finally{B.T=c,V.p=v}}(da&3)!==0&&iy(),$i(l),v=l.pendingLanes,(f&261930)!==0&&(v&42)!==0?l===y1?Qd++:(Qd=0,y1=l):Qd=0,ef(0)}}function bA(l,c){(l.pooledCacheLanes&=c)===0&&(c=l.pooledCache,c!=null&&(l.pooledCache=null,Od(c)))}function iy(){return mA(),gA(),yA(),xA()}function xA(){if(Rn!==5)return!1;var l=no,c=m1;m1=0;var f=Mw(da),g=B.T,v=V.p;try{V.p=32>f?32:f,B.T=null,f=g1,g1=null;var T=no,I=da;if(Rn=0,nc=no=null,da=0,(Tt&6)!==0)throw Error(s(331));var z=Tt;if(Tt|=4,eA(T.current),J_(T,T.current,I,f),Tt=z,ef(0,!1),Cs&&typeof Cs.onPostCommitFiberRoot=="function")try{Cs.onPostCommitFiberRoot(Ti,T)}catch{}return!0}finally{V.p=v,B.T=g,bA(l,c)}}function wA(l,c,f){c=_r(f,c),c=Xv(l.stateNode,c,2),l=Xa(l,c,2),l!==null&&(wd(l,2),$i(l))}function Et(l,c,f){if(l.tag===3)wA(l,l,f);else for(;c!==null;){if(c.tag===3){wA(c,l,f);break}else if(c.tag===1){var g=c.stateNode;if(typeof c.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(to===null||!to.has(g))){l=_r(f,l),f=v_(2),g=Xa(c,f,2),g!==null&&(S_(f,g,c,l),wd(g,2),$i(g));break}}c=c.return}}function w1(l,c,f){var g=l.pingCache;if(g===null){g=l.pingCache=new kW;var v=new Set;g.set(c,v)}else v=g.get(c),v===void 0&&(v=new Set,g.set(c,v));v.has(f)||(d1=!0,v.add(f),l=AW.bind(null,l,c,f),c.then(l,l))}function AW(l,c,f){var g=l.pingCache;g!==null&&g.delete(c),l.pingedLanes|=l.suspendedLanes&f,l.warmLanes&=~f,Ft===l&&(ht&f)===f&&(rn===4||rn===3&&(ht&62914560)===ht&&300>Vt()-Qg?(Tt&2)===0&&sc(l,0):f1|=f,tc===ht&&(tc=0)),$i(l)}function vA(l,c){c===0&&(c=m$()),l=tl(l,c),l!==null&&(wd(l,c),$i(l))}function RW(l){var c=l.memoizedState,f=0;c!==null&&(f=c.retryLane),vA(l,f)}function DW(l,c){var f=0;switch(l.tag){case 31:case 13:var g=l.stateNode,v=l.memoizedState;v!==null&&(f=v.retryLane);break;case 19:g=l.stateNode;break;case 22:g=l.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(c),vA(l,f)}function OW(l,c){return nn(l,c)}var ay=null,ic=null,v1=!1,oy=!1,S1=!1,ro=0;function $i(l){l!==ic&&l.next===null&&(ic===null?ay=ic=l:ic=ic.next=l),oy=!0,v1||(v1=!0,LW())}function ef(l,c){if(!S1&&oy){S1=!0;do for(var f=!1,g=ay;g!==null;){if(l!==0){var v=g.pendingLanes;if(v===0)var T=0;else{var I=g.suspendedLanes,z=g.pingedLanes;T=(1<<31-rr(42|l)+1)-1,T&=v&~(I&~z),T=T&201326741?T&201326741|1:T?T|2:0}T!==0&&(f=!0,NA(g,T))}else T=ht,T=hg(g,g===Ft?T:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(T&3)===0||xd(g,T)||(f=!0,NA(g,T));g=g.next}while(f);S1=!1}}function FW(){SA()}function SA(){oy=v1=!1;var l=0;ro!==0&&HW()&&(l=ro);for(var c=Vt(),f=null,g=ay;g!==null;){var v=g.next,T=TA(g,c);T===0?(g.next=null,f===null?ay=v:f.next=v,v===null&&(ic=f)):(f=g,(l!==0||(T&3)!==0)&&(oy=!0)),g=v}Rn!==0&&Rn!==5||ef(l),ro!==0&&(ro=0)}function TA(l,c){for(var f=l.suspendedLanes,g=l.pingedLanes,v=l.expirationTimes,T=l.pendingLanes&-62914561;0<T;){var I=31-rr(T),z=1<<I,q=v[I];q===-1?((z&f)===0||(z&g)!==0)&&(v[I]=lj(z,c)):q<=c&&(l.expiredLanes|=z),T&=~z}if(c=Ft,f=ht,f=hg(l,l===c?f:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),g=l.callbackNode,f===0||l===c&&(kt===2||kt===9)||l.cancelPendingCommit!==null)return g!==null&&g!==null&&kr(g),l.callbackNode=null,l.callbackPriority=0;if((f&3)===0||xd(l,f)){if(c=f&-f,c===l.callbackPriority)return c;switch(g!==null&&kr(g),Mw(f)){case 2:case 8:f=Jr;break;case 32:f=sr;break;case 268435456:f=Nu;break;default:f=sr}return g=CA.bind(null,l),f=nn(f,g),l.callbackPriority=c,l.callbackNode=f,c}return g!==null&&g!==null&&kr(g),l.callbackPriority=2,l.callbackNode=null,2}function CA(l,c){if(Rn!==0&&Rn!==5)return l.callbackNode=null,l.callbackPriority=0,null;var f=l.callbackNode;if(iy()&&l.callbackNode!==f)return null;var g=ht;return g=hg(l,l===Ft?g:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),g===0?null:(iA(l,g,c),TA(l,Vt()),l.callbackNode!=null&&l.callbackNode===f?CA.bind(null,l):null)}function NA(l,c){if(iy())return null;iA(l,c,!0)}function LW(){KW(function(){(Tt&6)!==0?nn(Yr,FW):SA()})}function T1(){if(ro===0){var l=Wu;l===0&&(l=lg,lg<<=1,(lg&261888)===0&&(lg=256)),ro=l}return ro}function kA(l){return l==null||typeof l=="symbol"||typeof l=="boolean"?null:typeof l=="function"?l:mg(""+l)}function EA(l,c){var f=c.ownerDocument.createElement("input");return f.name=c.name,f.value=c.value,l.id&&f.setAttribute("form",l.id),c.parentNode.insertBefore(f,c),l=new FormData(l),f.parentNode.removeChild(f),l}function MW(l,c,f,g,v){if(c==="submit"&&f&&f.stateNode===v){var T=kA((v[Ls]||null).action),I=g.submitter;I&&(c=(c=I[Ls]||null)?kA(c.formAction):I.getAttribute("formAction"),c!==null&&(T=c,I=null));var z=new xg("action","action",null,g,v);l.push({event:z,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(ro!==0){var q=I?EA(v,I):new FormData(v);jv(f,{pending:!0,data:q,method:v.method,action:T},null,q)}}else typeof T=="function"&&(z.preventDefault(),q=I?EA(v,I):new FormData(v),jv(f,{pending:!0,data:q,method:v.method,action:T},T,q))},currentTarget:v}]})}}for(var C1=0;C1<av.length;C1++){var N1=av[C1],zW=N1.toLowerCase(),PW=N1[0].toUpperCase()+N1.slice(1);Zr(zW,"on"+PW)}Zr(rI,"onAnimationEnd"),Zr(iI,"onAnimationIteration"),Zr(aI,"onAnimationStart"),Zr("dblclick","onDoubleClick"),Zr("focusin","onFocus"),Zr("focusout","onBlur"),Zr(tW,"onTransitionRun"),Zr(nW,"onTransitionStart"),Zr(sW,"onTransitionCancel"),Zr(oI,"onTransitionEnd"),_u("onMouseEnter",["mouseout","mouseover"]),_u("onMouseLeave",["mouseout","mouseover"]),_u("onPointerEnter",["pointerout","pointerover"]),_u("onPointerLeave",["pointerout","pointerover"]),Jo("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Jo("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Jo("onBeforeInput",["compositionend","keypress","textInput","paste"]),Jo("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Jo("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Jo("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var tf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),BW=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(tf));function $A(l,c){c=(c&4)!==0;for(var f=0;f<l.length;f++){var g=l[f],v=g.event;g=g.listeners;e:{var T=void 0;if(c)for(var I=g.length-1;0<=I;I--){var z=g[I],q=z.instance,le=z.currentTarget;if(z=z.listener,q!==T&&v.isPropagationStopped())break e;T=z,v.currentTarget=le;try{T(v)}catch(ge){Sg(ge)}v.currentTarget=null,T=q}else for(I=0;I<g.length;I++){if(z=g[I],q=z.instance,le=z.currentTarget,z=z.listener,q!==T&&v.isPropagationStopped())break e;T=z,v.currentTarget=le;try{T(v)}catch(ge){Sg(ge)}v.currentTarget=null,T=q}}}}function lt(l,c){var f=c[zw];f===void 0&&(f=c[zw]=new Set);var g=l+"__bubble";f.has(g)||(IA(c,l,2,!1),f.add(g))}function k1(l,c,f){var g=0;c&&(g|=4),IA(f,l,g,c)}var ly="_reactListening"+Math.random().toString(36).slice(2);function E1(l){if(!l[ly]){l[ly]=!0,S$.forEach(function(f){f!=="selectionchange"&&(BW.has(f)||k1(f,!1,l),k1(f,!0,l))});var c=l.nodeType===9?l:l.ownerDocument;c===null||c[ly]||(c[ly]=!0,k1("selectionchange",!1,c))}}function IA(l,c,f,g){switch(rR(c)){case 2:var v=pG;break;case 8:v=mG;break;default:v=U1}f=v.bind(null,c,f,l),v=void 0,!qw||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||(v=!0),g?v!==void 0?l.addEventListener(c,f,{capture:!0,passive:v}):l.addEventListener(c,f,!0):v!==void 0?l.addEventListener(c,f,{passive:v}):l.addEventListener(c,f,!1)}function $1(l,c,f,g,v){var T=g;if((c&1)===0&&(c&2)===0&&g!==null)e:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var z=g.stateNode.containerInfo;if(z===v)break;if(I===4)for(I=g.return;I!==null;){var q=I.tag;if((q===3||q===4)&&I.stateNode.containerInfo===v)return;I=I.return}for(;z!==null;){if(I=Eu(z),I===null)return;if(q=I.tag,q===5||q===6||q===26||q===27){g=T=I;continue e}z=z.parentNode}}g=g.return}O$(function(){var le=T,ge=Gw(f),be=[];e:{var ue=lI.get(l);if(ue!==void 0){var fe=xg,Re=l;switch(l){case"keypress":if(yg(f)===0)break e;case"keydown":case"keyup":fe=Dj;break;case"focusin":Re="focus",fe=Jw;break;case"focusout":Re="blur",fe=Jw;break;case"beforeblur":case"afterblur":fe=Jw;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":fe=M$;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":fe=vj;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":fe=Lj;break;case rI:case iI:case aI:fe=Cj;break;case oI:fe=zj;break;case"scroll":case"scrollend":fe=xj;break;case"wheel":fe=Bj;break;case"copy":case"cut":case"paste":fe=kj;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":fe=P$;break;case"toggle":case"beforetoggle":fe=Uj}var Ue=(c&4)!==0,Dt=!Ue&&(l==="scroll"||l==="scrollend"),re=Ue?ue!==null?ue+"Capture":null:ue;Ue=[];for(var Q=le,oe;Q!==null;){var ye=Q;if(oe=ye.stateNode,ye=ye.tag,ye!==5&&ye!==26&&ye!==27||oe===null||re===null||(ye=Td(Q,re),ye!=null&&Ue.push(nf(Q,ye,oe))),Dt)break;Q=Q.return}0<Ue.length&&(ue=new fe(ue,Re,null,f,ge),be.push({event:ue,listeners:Ue}))}}if((c&7)===0){e:{if(ue=l==="mouseover"||l==="pointerover",fe=l==="mouseout"||l==="pointerout",ue&&f!==Ww&&(Re=f.relatedTarget||f.fromElement)&&(Eu(Re)||Re[ku]))break e;if((fe||ue)&&(ue=ge.window===ge?ge:(ue=ge.ownerDocument)?ue.defaultView||ue.parentWindow:window,fe?(Re=f.relatedTarget||f.toElement,fe=le,Re=Re?Eu(Re):null,Re!==null&&(Dt=i(Re),Ue=Re.tag,Re!==Dt||Ue!==5&&Ue!==27&&Ue!==6)&&(Re=null)):(fe=null,Re=le),fe!==Re)){if(Ue=M$,ye="onMouseLeave",re="onMouseEnter",Q="mouse",(l==="pointerout"||l==="pointerover")&&(Ue=P$,ye="onPointerLeave",re="onPointerEnter",Q="pointer"),Dt=fe==null?ue:Sd(fe),oe=Re==null?ue:Sd(Re),ue=new Ue(ye,Q+"leave",fe,f,ge),ue.target=Dt,ue.relatedTarget=oe,ye=null,Eu(ge)===le&&(Ue=new Ue(re,Q+"enter",Re,f,ge),Ue.target=oe,Ue.relatedTarget=Dt,ye=Ue),Dt=ye,fe&&Re)t:{for(Ue=VW,re=fe,Q=Re,oe=0,ye=re;ye;ye=Ue(ye))oe++;ye=0;for(var Be=Q;Be;Be=Ue(Be))ye++;for(;0<oe-ye;)re=Ue(re),oe--;for(;0<ye-oe;)Q=Ue(Q),ye--;for(;oe--;){if(re===Q||Q!==null&&re===Q.alternate){Ue=re;break t}re=Ue(re),Q=Ue(Q)}Ue=null}else Ue=null;fe!==null&&_A(be,ue,fe,Ue,!1),Re!==null&&Dt!==null&&_A(be,Dt,Re,Ue,!0)}}e:{if(ue=le?Sd(le):window,fe=ue.nodeName&&ue.nodeName.toLowerCase(),fe==="select"||fe==="input"&&ue.type==="file")var wt=q$;else if(G$(ue))if(K$)wt=Zj;else{wt=Yj;var Le=Xj}else fe=ue.nodeName,!fe||fe.toLowerCase()!=="input"||ue.type!=="checkbox"&&ue.type!=="radio"?le&&jw(le.elementType)&&(wt=q$):wt=Jj;if(wt&&(wt=wt(l,le))){H$(be,wt,f,ge);break e}Le&&Le(l,ue,le),l==="focusout"&&le&&ue.type==="number"&&le.memoizedProps.value!=null&&Uw(ue,"number",ue.value)}switch(Le=le?Sd(le):window,l){case"focusin":(G$(Le)||Le.contentEditable==="true")&&(Lu=Le,sv=le,Ad=null);break;case"focusout":Ad=sv=Lu=null;break;case"mousedown":rv=!0;break;case"contextmenu":case"mouseup":case"dragend":rv=!1,nI(be,f,ge);break;case"selectionchange":if(eW)break;case"keydown":case"keyup":nI(be,f,ge)}var tt;if(Qw)e:{switch(l){case"compositionstart":var dt="onCompositionStart";break e;case"compositionend":dt="onCompositionEnd";break e;case"compositionupdate":dt="onCompositionUpdate";break e}dt=void 0}else Fu?j$(l,f)&&(dt="onCompositionEnd"):l==="keydown"&&f.keyCode===229&&(dt="onCompositionStart");dt&&(B$&&f.locale!=="ko"&&(Fu||dt!=="onCompositionStart"?dt==="onCompositionEnd"&&Fu&&(tt=F$()):(Ua=ge,Kw="value"in Ua?Ua.value:Ua.textContent,Fu=!0)),Le=uy(le,dt),0<Le.length&&(dt=new z$(dt,l,null,f,ge),be.push({event:dt,listeners:Le}),tt?dt.data=tt:(tt=W$(f),tt!==null&&(dt.data=tt)))),(tt=Wj?Gj(l,f):Hj(l,f))&&(dt=uy(le,"onBeforeInput"),0<dt.length&&(Le=new z$("onBeforeInput","beforeinput",null,f,ge),be.push({event:Le,listeners:dt}),Le.data=tt)),MW(be,l,le,f,ge)}$A(be,c)})}function nf(l,c,f){return{instance:l,listener:c,currentTarget:f}}function uy(l,c){for(var f=c+"Capture",g=[];l!==null;){var v=l,T=v.stateNode;if(v=v.tag,v!==5&&v!==26&&v!==27||T===null||(v=Td(l,f),v!=null&&g.unshift(nf(l,v,T)),v=Td(l,c),v!=null&&g.push(nf(l,v,T))),l.tag===3)return g;l=l.return}return[]}function VW(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5&&l.tag!==27);return l||null}function _A(l,c,f,g,v){for(var T=c._reactName,I=[];f!==null&&f!==g;){var z=f,q=z.alternate,le=z.stateNode;if(z=z.tag,q!==null&&q===g)break;z!==5&&z!==26&&z!==27||le===null||(q=le,v?(le=Td(f,T),le!=null&&I.unshift(nf(f,le,q))):v||(le=Td(f,T),le!=null&&I.push(nf(f,le,q)))),f=f.return}I.length!==0&&l.push({event:c,listeners:I})}var UW=/\r\n?/g,jW=/\u0000|\uFFFD/g;function AA(l){return(typeof l=="string"?l:""+l).replace(UW,`
`).replace(jW,"")}function RA(l,c){return c=AA(c),AA(l)===c}function Rt(l,c,f,g,v,T){switch(f){case"children":typeof g=="string"?c==="body"||c==="textarea"&&g===""||Ru(l,g):(typeof g=="number"||typeof g=="bigint")&&c!=="body"&&Ru(l,""+g);break;case"className":fg(l,"class",g);break;case"tabIndex":fg(l,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":fg(l,f,g);break;case"style":R$(l,g,T);break;case"data":if(c!=="object"){fg(l,"data",g);break}case"src":case"href":if(g===""&&(c!=="a"||f!=="href")){l.removeAttribute(f);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){l.removeAttribute(f);break}g=mg(""+g),l.setAttribute(f,g);break;case"action":case"formAction":if(typeof g=="function"){l.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof T=="function"&&(f==="formAction"?(c!=="input"&&Rt(l,c,"name",v.name,v,null),Rt(l,c,"formEncType",v.formEncType,v,null),Rt(l,c,"formMethod",v.formMethod,v,null),Rt(l,c,"formTarget",v.formTarget,v,null)):(Rt(l,c,"encType",v.encType,v,null),Rt(l,c,"method",v.method,v,null),Rt(l,c,"target",v.target,v,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){l.removeAttribute(f);break}g=mg(""+g),l.setAttribute(f,g);break;case"onClick":g!=null&&(l.onclick=Ji);break;case"onScroll":g!=null&&lt("scroll",l);break;case"onScrollEnd":g!=null&&lt("scrollend",l);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));l.innerHTML=f}}break;case"multiple":l.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":l.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){l.removeAttribute("xlink:href");break}f=mg(""+g),l.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?l.setAttribute(f,""+g):l.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?l.setAttribute(f,""):l.removeAttribute(f);break;case"capture":case"download":g===!0?l.setAttribute(f,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?l.setAttribute(f,g):l.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?l.setAttribute(f,g):l.removeAttribute(f);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?l.removeAttribute(f):l.setAttribute(f,g);break;case"popover":lt("beforetoggle",l),lt("toggle",l),dg(l,"popover",g);break;case"xlinkActuate":Yi(l,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":Yi(l,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":Yi(l,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":Yi(l,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":Yi(l,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":Yi(l,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":Yi(l,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":Yi(l,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":Yi(l,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":dg(l,"is",g);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=yj.get(f)||f,dg(l,f,g))}}function I1(l,c,f,g,v,T){switch(f){case"style":R$(l,g,T);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));l.innerHTML=f}}break;case"children":typeof g=="string"?Ru(l,g):(typeof g=="number"||typeof g=="bigint")&&Ru(l,""+g);break;case"onScroll":g!=null&&lt("scroll",l);break;case"onScrollEnd":g!=null&&lt("scrollend",l);break;case"onClick":g!=null&&(l.onclick=Ji);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!T$.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(v=f.endsWith("Capture"),c=f.slice(2,v?f.length-7:void 0),T=l[Ls]||null,T=T!=null?T[f]:null,typeof T=="function"&&l.removeEventListener(c,T,v),typeof g=="function")){typeof T!="function"&&T!==null&&(f in l?l[f]=null:l.hasAttribute(f)&&l.removeAttribute(f)),l.addEventListener(c,g,v);break e}f in l?l[f]=g:g===!0?l.setAttribute(f,""):dg(l,f,g)}}}function as(l,c,f){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":lt("error",l),lt("load",l);var g=!1,v=!1,T;for(T in f)if(f.hasOwnProperty(T)){var I=f[T];if(I!=null)switch(T){case"src":g=!0;break;case"srcSet":v=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:Rt(l,c,T,I,f,null)}}v&&Rt(l,c,"srcSet",f.srcSet,f,null),g&&Rt(l,c,"src",f.src,f,null);return;case"input":lt("invalid",l);var z=T=I=v=null,q=null,le=null;for(g in f)if(f.hasOwnProperty(g)){var ge=f[g];if(ge!=null)switch(g){case"name":v=ge;break;case"type":I=ge;break;case"checked":q=ge;break;case"defaultChecked":le=ge;break;case"value":T=ge;break;case"defaultValue":z=ge;break;case"children":case"dangerouslySetInnerHTML":if(ge!=null)throw Error(s(137,c));break;default:Rt(l,c,g,ge,f,null)}}$$(l,T,z,q,le,I,v,!1);return;case"select":lt("invalid",l),g=I=T=null;for(v in f)if(f.hasOwnProperty(v)&&(z=f[v],z!=null))switch(v){case"value":T=z;break;case"defaultValue":I=z;break;case"multiple":g=z;default:Rt(l,c,v,z,f,null)}c=T,f=I,l.multiple=!!g,c!=null?Au(l,!!g,c,!1):f!=null&&Au(l,!!g,f,!0);return;case"textarea":lt("invalid",l),T=v=g=null;for(I in f)if(f.hasOwnProperty(I)&&(z=f[I],z!=null))switch(I){case"value":g=z;break;case"defaultValue":v=z;break;case"children":T=z;break;case"dangerouslySetInnerHTML":if(z!=null)throw Error(s(91));break;default:Rt(l,c,I,z,f,null)}_$(l,g,v,T);return;case"option":for(q in f)f.hasOwnProperty(q)&&(g=f[q],g!=null)&&(q==="selected"?l.selected=g&&typeof g!="function"&&typeof g!="symbol":Rt(l,c,q,g,f,null));return;case"dialog":lt("beforetoggle",l),lt("toggle",l),lt("cancel",l),lt("close",l);break;case"iframe":case"object":lt("load",l);break;case"video":case"audio":for(g=0;g<tf.length;g++)lt(tf[g],l);break;case"image":lt("error",l),lt("load",l);break;case"details":lt("toggle",l);break;case"embed":case"source":case"link":lt("error",l),lt("load",l);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(le in f)if(f.hasOwnProperty(le)&&(g=f[le],g!=null))switch(le){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:Rt(l,c,le,g,f,null)}return;default:if(jw(c)){for(ge in f)f.hasOwnProperty(ge)&&(g=f[ge],g!==void 0&&I1(l,c,ge,g,f,void 0));return}}for(z in f)f.hasOwnProperty(z)&&(g=f[z],g!=null&&Rt(l,c,z,g,f,null))}function WW(l,c,f,g){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var v=null,T=null,I=null,z=null,q=null,le=null,ge=null;for(fe in f){var be=f[fe];if(f.hasOwnProperty(fe)&&be!=null)switch(fe){case"checked":break;case"value":break;case"defaultValue":q=be;default:g.hasOwnProperty(fe)||Rt(l,c,fe,null,g,be)}}for(var ue in g){var fe=g[ue];if(be=f[ue],g.hasOwnProperty(ue)&&(fe!=null||be!=null))switch(ue){case"type":T=fe;break;case"name":v=fe;break;case"checked":le=fe;break;case"defaultChecked":ge=fe;break;case"value":I=fe;break;case"defaultValue":z=fe;break;case"children":case"dangerouslySetInnerHTML":if(fe!=null)throw Error(s(137,c));break;default:fe!==be&&Rt(l,c,ue,fe,g,be)}}Vw(l,I,z,q,le,ge,T,v);return;case"select":fe=I=z=ue=null;for(T in f)if(q=f[T],f.hasOwnProperty(T)&&q!=null)switch(T){case"value":break;case"multiple":fe=q;default:g.hasOwnProperty(T)||Rt(l,c,T,null,g,q)}for(v in g)if(T=g[v],q=f[v],g.hasOwnProperty(v)&&(T!=null||q!=null))switch(v){case"value":ue=T;break;case"defaultValue":z=T;break;case"multiple":I=T;default:T!==q&&Rt(l,c,v,T,g,q)}c=z,f=I,g=fe,ue!=null?Au(l,!!f,ue,!1):!!g!=!!f&&(c!=null?Au(l,!!f,c,!0):Au(l,!!f,f?[]:"",!1));return;case"textarea":fe=ue=null;for(z in f)if(v=f[z],f.hasOwnProperty(z)&&v!=null&&!g.hasOwnProperty(z))switch(z){case"value":break;case"children":break;default:Rt(l,c,z,null,g,v)}for(I in g)if(v=g[I],T=f[I],g.hasOwnProperty(I)&&(v!=null||T!=null))switch(I){case"value":ue=v;break;case"defaultValue":fe=v;break;case"children":break;case"dangerouslySetInnerHTML":if(v!=null)throw Error(s(91));break;default:v!==T&&Rt(l,c,I,v,g,T)}I$(l,ue,fe);return;case"option":for(var Re in f)ue=f[Re],f.hasOwnProperty(Re)&&ue!=null&&!g.hasOwnProperty(Re)&&(Re==="selected"?l.selected=!1:Rt(l,c,Re,null,g,ue));for(q in g)ue=g[q],fe=f[q],g.hasOwnProperty(q)&&ue!==fe&&(ue!=null||fe!=null)&&(q==="selected"?l.selected=ue&&typeof ue!="function"&&typeof ue!="symbol":Rt(l,c,q,ue,g,fe));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Ue in f)ue=f[Ue],f.hasOwnProperty(Ue)&&ue!=null&&!g.hasOwnProperty(Ue)&&Rt(l,c,Ue,null,g,ue);for(le in g)if(ue=g[le],fe=f[le],g.hasOwnProperty(le)&&ue!==fe&&(ue!=null||fe!=null))switch(le){case"children":case"dangerouslySetInnerHTML":if(ue!=null)throw Error(s(137,c));break;default:Rt(l,c,le,ue,g,fe)}return;default:if(jw(c)){for(var Dt in f)ue=f[Dt],f.hasOwnProperty(Dt)&&ue!==void 0&&!g.hasOwnProperty(Dt)&&I1(l,c,Dt,void 0,g,ue);for(ge in g)ue=g[ge],fe=f[ge],!g.hasOwnProperty(ge)||ue===fe||ue===void 0&&fe===void 0||I1(l,c,ge,ue,g,fe);return}}for(var re in f)ue=f[re],f.hasOwnProperty(re)&&ue!=null&&!g.hasOwnProperty(re)&&Rt(l,c,re,null,g,ue);for(be in g)ue=g[be],fe=f[be],!g.hasOwnProperty(be)||ue===fe||ue==null&&fe==null||Rt(l,c,be,ue,g,fe)}function DA(l){switch(l){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function GW(){if(typeof performance.getEntriesByType=="function"){for(var l=0,c=0,f=performance.getEntriesByType("resource"),g=0;g<f.length;g++){var v=f[g],T=v.transferSize,I=v.initiatorType,z=v.duration;if(T&&z&&DA(I)){for(I=0,z=v.responseEnd,g+=1;g<f.length;g++){var q=f[g],le=q.startTime;if(le>z)break;var ge=q.transferSize,be=q.initiatorType;ge&&DA(be)&&(q=q.responseEnd,I+=ge*(q<z?1:(z-le)/(q-le)))}if(--g,c+=8*(T+I)/(v.duration/1e3),l++,10<l)break}}if(0<l)return c/l/1e6}return navigator.connection&&(l=navigator.connection.downlink,typeof l=="number")?l:5}var _1=null,A1=null;function cy(l){return l.nodeType===9?l:l.ownerDocument}function OA(l){switch(l){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function FA(l,c){if(l===0)switch(c){case"svg":return 1;case"math":return 2;default:return 0}return l===1&&c==="foreignObject"?0:l}function R1(l,c){return l==="textarea"||l==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.children=="bigint"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var D1=null;function HW(){var l=window.event;return l&&l.type==="popstate"?l===D1?!1:(D1=l,!0):(D1=null,!1)}var LA=typeof setTimeout=="function"?setTimeout:void 0,qW=typeof clearTimeout=="function"?clearTimeout:void 0,MA=typeof Promise=="function"?Promise:void 0,KW=typeof queueMicrotask=="function"?queueMicrotask:typeof MA<"u"?function(l){return MA.resolve(null).then(l).catch(XW)}:LA;function XW(l){setTimeout(function(){throw l})}function io(l){return l==="head"}function zA(l,c){var f=c,g=0;do{var v=f.nextSibling;if(l.removeChild(f),v&&v.nodeType===8)if(f=v.data,f==="/$"||f==="/&"){if(g===0){l.removeChild(v),uc(c);return}g--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")g++;else if(f==="html")sf(l.ownerDocument.documentElement);else if(f==="head"){f=l.ownerDocument.head,sf(f);for(var T=f.firstChild;T;){var I=T.nextSibling,z=T.nodeName;T[vd]||z==="SCRIPT"||z==="STYLE"||z==="LINK"&&T.rel.toLowerCase()==="stylesheet"||f.removeChild(T),T=I}}else f==="body"&&sf(l.ownerDocument.body);f=v}while(f);uc(c)}function PA(l,c){var f=l;l=0;do{var g=f.nextSibling;if(f.nodeType===1?c?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(c?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),g&&g.nodeType===8)if(f=g.data,f==="/$"){if(l===0)break;l--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||l++;f=g}while(f)}function O1(l){var c=l.firstChild;for(c&&c.nodeType===10&&(c=c.nextSibling);c;){var f=c;switch(c=c.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":O1(f),Pw(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}l.removeChild(f)}}function YW(l,c,f,g){for(;l.nodeType===1;){var v=f;if(l.nodeName.toLowerCase()!==c.toLowerCase()){if(!g&&(l.nodeName!=="INPUT"||l.type!=="hidden"))break}else if(g){if(!l[vd])switch(c){case"meta":if(!l.hasAttribute("itemprop"))break;return l;case"link":if(T=l.getAttribute("rel"),T==="stylesheet"&&l.hasAttribute("data-precedence"))break;if(T!==v.rel||l.getAttribute("href")!==(v.href==null||v.href===""?null:v.href)||l.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin)||l.getAttribute("title")!==(v.title==null?null:v.title))break;return l;case"style":if(l.hasAttribute("data-precedence"))break;return l;case"script":if(T=l.getAttribute("src"),(T!==(v.src==null?null:v.src)||l.getAttribute("type")!==(v.type==null?null:v.type)||l.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin))&&T&&l.hasAttribute("async")&&!l.hasAttribute("itemprop"))break;return l;default:return l}}else if(c==="input"&&l.type==="hidden"){var T=v.name==null?null:""+v.name;if(v.type==="hidden"&&l.getAttribute("name")===T)return l}else return l;if(l=Fr(l.nextSibling),l===null)break}return null}function JW(l,c,f){if(c==="")return null;for(;l.nodeType!==3;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!f||(l=Fr(l.nextSibling),l===null))return null;return l}function BA(l,c){for(;l.nodeType!==8;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!c||(l=Fr(l.nextSibling),l===null))return null;return l}function F1(l){return l.data==="$?"||l.data==="$~"}function L1(l){return l.data==="$!"||l.data==="$?"&&l.ownerDocument.readyState!=="loading"}function ZW(l,c){var f=l.ownerDocument;if(l.data==="$~")l._reactRetry=c;else if(l.data!=="$?"||f.readyState!=="loading")c();else{var g=function(){c(),f.removeEventListener("DOMContentLoaded",g)};f.addEventListener("DOMContentLoaded",g),l._reactRetry=g}}function Fr(l){for(;l!=null;l=l.nextSibling){var c=l.nodeType;if(c===1||c===3)break;if(c===8){if(c=l.data,c==="$"||c==="$!"||c==="$?"||c==="$~"||c==="&"||c==="F!"||c==="F")break;if(c==="/$"||c==="/&")return null}}return l}var M1=null;function VA(l){l=l.nextSibling;for(var c=0;l;){if(l.nodeType===8){var f=l.data;if(f==="/$"||f==="/&"){if(c===0)return Fr(l.nextSibling);c--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||c++}l=l.nextSibling}return null}function UA(l){l=l.previousSibling;for(var c=0;l;){if(l.nodeType===8){var f=l.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(c===0)return l;c--}else f!=="/$"&&f!=="/&"||c++}l=l.previousSibling}return null}function jA(l,c,f){switch(c=cy(f),l){case"html":if(l=c.documentElement,!l)throw Error(s(452));return l;case"head":if(l=c.head,!l)throw Error(s(453));return l;case"body":if(l=c.body,!l)throw Error(s(454));return l;default:throw Error(s(451))}}function sf(l){for(var c=l.attributes;c.length;)l.removeAttributeNode(c[0]);Pw(l)}var Lr=new Map,WA=new Set;function hy(l){return typeof l.getRootNode=="function"?l.getRootNode():l.nodeType===9?l:l.ownerDocument}var fa=V.d;V.d={f:QW,r:eG,D:tG,C:nG,L:sG,m:rG,X:aG,S:iG,M:oG};function QW(){var l=fa.f(),c=ny();return l||c}function eG(l){var c=$u(l);c!==null&&c.tag===5&&c.type==="form"?o_(c):fa.r(l)}var ac=typeof document>"u"?null:document;function GA(l,c,f){var g=ac;if(g&&typeof c=="string"&&c){var v=$r(c);v='link[rel="'+l+'"][href="'+v+'"]',typeof f=="string"&&(v+='[crossorigin="'+f+'"]'),WA.has(v)||(WA.add(v),l={rel:l,crossOrigin:f,href:c},g.querySelector(v)===null&&(c=g.createElement("link"),as(c,"link",l),jn(c),g.head.appendChild(c)))}}function tG(l){fa.D(l),GA("dns-prefetch",l,null)}function nG(l,c){fa.C(l,c),GA("preconnect",l,c)}function sG(l,c,f){fa.L(l,c,f);var g=ac;if(g&&l&&c){var v='link[rel="preload"][as="'+$r(c)+'"]';c==="image"&&f&&f.imageSrcSet?(v+='[imagesrcset="'+$r(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(v+='[imagesizes="'+$r(f.imageSizes)+'"]')):v+='[href="'+$r(l)+'"]';var T=v;switch(c){case"style":T=oc(l);break;case"script":T=lc(l)}Lr.has(T)||(l=p({rel:"preload",href:c==="image"&&f&&f.imageSrcSet?void 0:l,as:c},f),Lr.set(T,l),g.querySelector(v)!==null||c==="style"&&g.querySelector(rf(T))||c==="script"&&g.querySelector(af(T))||(c=g.createElement("link"),as(c,"link",l),jn(c),g.head.appendChild(c)))}}function rG(l,c){fa.m(l,c);var f=ac;if(f&&l){var g=c&&typeof c.as=="string"?c.as:"script",v='link[rel="modulepreload"][as="'+$r(g)+'"][href="'+$r(l)+'"]',T=v;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":T=lc(l)}if(!Lr.has(T)&&(l=p({rel:"modulepreload",href:l},c),Lr.set(T,l),f.querySelector(v)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(af(T)))return}g=f.createElement("link"),as(g,"link",l),jn(g),f.head.appendChild(g)}}}function iG(l,c,f){fa.S(l,c,f);var g=ac;if(g&&l){var v=Iu(g).hoistableStyles,T=oc(l);c=c||"default";var I=v.get(T);if(!I){var z={loading:0,preload:null};if(I=g.querySelector(rf(T)))z.loading=5;else{l=p({rel:"stylesheet",href:l,"data-precedence":c},f),(f=Lr.get(T))&&z1(l,f);var q=I=g.createElement("link");jn(q),as(q,"link",l),q._p=new Promise(function(le,ge){q.onload=le,q.onerror=ge}),q.addEventListener("load",function(){z.loading|=1}),q.addEventListener("error",function(){z.loading|=2}),z.loading|=4,dy(I,c,g)}I={type:"stylesheet",instance:I,count:1,state:z},v.set(T,I)}}}function aG(l,c){fa.X(l,c);var f=ac;if(f&&l){var g=Iu(f).hoistableScripts,v=lc(l),T=g.get(v);T||(T=f.querySelector(af(v)),T||(l=p({src:l,async:!0},c),(c=Lr.get(v))&&P1(l,c),T=f.createElement("script"),jn(T),as(T,"link",l),f.head.appendChild(T)),T={type:"script",instance:T,count:1,state:null},g.set(v,T))}}function oG(l,c){fa.M(l,c);var f=ac;if(f&&l){var g=Iu(f).hoistableScripts,v=lc(l),T=g.get(v);T||(T=f.querySelector(af(v)),T||(l=p({src:l,async:!0,type:"module"},c),(c=Lr.get(v))&&P1(l,c),T=f.createElement("script"),jn(T),as(T,"link",l),f.head.appendChild(T)),T={type:"script",instance:T,count:1,state:null},g.set(v,T))}}function HA(l,c,f,g){var v=(v=de.current)?hy(v):null;if(!v)throw Error(s(446));switch(l){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(c=oc(f.href),f=Iu(v).hoistableStyles,g=f.get(c),g||(g={type:"style",instance:null,count:0,state:null},f.set(c,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){l=oc(f.href);var T=Iu(v).hoistableStyles,I=T.get(l);if(I||(v=v.ownerDocument||v,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},T.set(l,I),(T=v.querySelector(rf(l)))&&!T._p&&(I.instance=T,I.state.loading=5),Lr.has(l)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},Lr.set(l,f),T||lG(v,l,f,I.state))),c&&g===null)throw Error(s(528,""));return I}if(c&&g!==null)throw Error(s(529,""));return null;case"script":return c=f.async,f=f.src,typeof f=="string"&&c&&typeof c!="function"&&typeof c!="symbol"?(c=lc(f),f=Iu(v).hoistableScripts,g=f.get(c),g||(g={type:"script",instance:null,count:0,state:null},f.set(c,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,l))}}function oc(l){return'href="'+$r(l)+'"'}function rf(l){return'link[rel="stylesheet"]['+l+"]"}function qA(l){return p({},l,{"data-precedence":l.precedence,precedence:null})}function lG(l,c,f,g){l.querySelector('link[rel="preload"][as="style"]['+c+"]")?g.loading=1:(c=l.createElement("link"),g.preload=c,c.addEventListener("load",function(){return g.loading|=1}),c.addEventListener("error",function(){return g.loading|=2}),as(c,"link",f),jn(c),l.head.appendChild(c))}function lc(l){return'[src="'+$r(l)+'"]'}function af(l){return"script[async]"+l}function KA(l,c,f){if(c.count++,c.instance===null)switch(c.type){case"style":var g=l.querySelector('style[data-href~="'+$r(f.href)+'"]');if(g)return c.instance=g,jn(g),g;var v=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return g=(l.ownerDocument||l).createElement("style"),jn(g),as(g,"style",v),dy(g,f.precedence,l),c.instance=g;case"stylesheet":v=oc(f.href);var T=l.querySelector(rf(v));if(T)return c.state.loading|=4,c.instance=T,jn(T),T;g=qA(f),(v=Lr.get(v))&&z1(g,v),T=(l.ownerDocument||l).createElement("link"),jn(T);var I=T;return I._p=new Promise(function(z,q){I.onload=z,I.onerror=q}),as(T,"link",g),c.state.loading|=4,dy(T,f.precedence,l),c.instance=T;case"script":return T=lc(f.src),(v=l.querySelector(af(T)))?(c.instance=v,jn(v),v):(g=f,(v=Lr.get(T))&&(g=p({},f),P1(g,v)),l=l.ownerDocument||l,v=l.createElement("script"),jn(v),as(v,"link",g),l.head.appendChild(v),c.instance=v);case"void":return null;default:throw Error(s(443,c.type))}else c.type==="stylesheet"&&(c.state.loading&4)===0&&(g=c.instance,c.state.loading|=4,dy(g,f.precedence,l));return c.instance}function dy(l,c,f){for(var g=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),v=g.length?g[g.length-1]:null,T=v,I=0;I<g.length;I++){var z=g[I];if(z.dataset.precedence===c)T=z;else if(T!==v)break}T?T.parentNode.insertBefore(l,T.nextSibling):(c=f.nodeType===9?f.head:f,c.insertBefore(l,c.firstChild))}function z1(l,c){l.crossOrigin==null&&(l.crossOrigin=c.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=c.referrerPolicy),l.title==null&&(l.title=c.title)}function P1(l,c){l.crossOrigin==null&&(l.crossOrigin=c.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=c.referrerPolicy),l.integrity==null&&(l.integrity=c.integrity)}var fy=null;function XA(l,c,f){if(fy===null){var g=new Map,v=fy=new Map;v.set(f,g)}else v=fy,g=v.get(f),g||(g=new Map,v.set(f,g));if(g.has(l))return g;for(g.set(l,null),f=f.getElementsByTagName(l),v=0;v<f.length;v++){var T=f[v];if(!(T[vd]||T[ns]||l==="link"&&T.getAttribute("rel")==="stylesheet")&&T.namespaceURI!=="http://www.w3.org/2000/svg"){var I=T.getAttribute(c)||"";I=l+I;var z=g.get(I);z?z.push(T):g.set(I,[T])}}return g}function YA(l,c,f){l=l.ownerDocument||l,l.head.insertBefore(f,c==="title"?l.querySelector("head > title"):null)}function uG(l,c,f){if(f===1||c.itemProp!=null)return!1;switch(l){case"meta":case"title":return!0;case"style":if(typeof c.precedence!="string"||typeof c.href!="string"||c.href==="")break;return!0;case"link":if(typeof c.rel!="string"||typeof c.href!="string"||c.href===""||c.onLoad||c.onError)break;return c.rel==="stylesheet"?(l=c.disabled,typeof c.precedence=="string"&&l==null):!0;case"script":if(c.async&&typeof c.async!="function"&&typeof c.async!="symbol"&&!c.onLoad&&!c.onError&&c.src&&typeof c.src=="string")return!0}return!1}function JA(l){return!(l.type==="stylesheet"&&(l.state.loading&3)===0)}function cG(l,c,f,g){if(f.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var v=oc(g.href),T=c.querySelector(rf(v));if(T){c=T._p,c!==null&&typeof c=="object"&&typeof c.then=="function"&&(l.count++,l=py.bind(l),c.then(l,l)),f.state.loading|=4,f.instance=T,jn(T);return}T=c.ownerDocument||c,g=qA(g),(v=Lr.get(v))&&z1(g,v),T=T.createElement("link"),jn(T);var I=T;I._p=new Promise(function(z,q){I.onload=z,I.onerror=q}),as(T,"link",g),f.instance=T}l.stylesheets===null&&(l.stylesheets=new Map),l.stylesheets.set(f,c),(c=f.state.preload)&&(f.state.loading&3)===0&&(l.count++,f=py.bind(l),c.addEventListener("load",f),c.addEventListener("error",f))}}var B1=0;function hG(l,c){return l.stylesheets&&l.count===0&&gy(l,l.stylesheets),0<l.count||0<l.imgCount?function(f){var g=setTimeout(function(){if(l.stylesheets&&gy(l,l.stylesheets),l.unsuspend){var T=l.unsuspend;l.unsuspend=null,T()}},6e4+c);0<l.imgBytes&&B1===0&&(B1=62500*GW());var v=setTimeout(function(){if(l.waitingForImages=!1,l.count===0&&(l.stylesheets&&gy(l,l.stylesheets),l.unsuspend)){var T=l.unsuspend;l.unsuspend=null,T()}},(l.imgBytes>B1?50:800)+c);return l.unsuspend=f,function(){l.unsuspend=null,clearTimeout(g),clearTimeout(v)}}:null}function py(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)gy(this,this.stylesheets);else if(this.unsuspend){var l=this.unsuspend;this.unsuspend=null,l()}}}var my=null;function gy(l,c){l.stylesheets=null,l.unsuspend!==null&&(l.count++,my=new Map,c.forEach(dG,l),my=null,py.call(l))}function dG(l,c){if(!(c.state.loading&4)){var f=my.get(l);if(f)var g=f.get(null);else{f=new Map,my.set(l,f);for(var v=l.querySelectorAll("link[data-precedence],style[data-precedence]"),T=0;T<v.length;T++){var I=v[T];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(f.set(I.dataset.precedence,I),g=I)}g&&f.set(null,g)}v=c.instance,I=v.getAttribute("data-precedence"),T=f.get(I)||g,T===g&&f.set(null,v),f.set(I,v),this.count++,g=py.bind(this),v.addEventListener("load",g),v.addEventListener("error",g),T?T.parentNode.insertBefore(v,T.nextSibling):(l=l.nodeType===9?l.head:l,l.insertBefore(v,l.firstChild)),c.state.loading|=4}}var of={$$typeof:N,Provider:null,Consumer:null,_currentValue:j,_currentValue2:j,_threadCount:0};function fG(l,c,f,g,v,T,I,z,q){this.tag=1,this.containerInfo=l,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Fw(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Fw(0),this.hiddenUpdates=Fw(null),this.identifierPrefix=g,this.onUncaughtError=v,this.onCaughtError=T,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=q,this.incompleteTransitions=new Map}function ZA(l,c,f,g,v,T,I,z,q,le,ge,be){return l=new fG(l,c,f,I,q,le,ge,be,z),c=1,T===!0&&(c|=24),T=ar(3,null,null,c),l.current=T,T.stateNode=l,c=xv(),c.refCount++,l.pooledCache=c,c.refCount++,T.memoizedState={element:g,isDehydrated:f,cache:c},Tv(T),l}function QA(l){return l?(l=Pu,l):Pu}function eR(l,c,f,g,v,T){v=QA(v),g.context===null?g.context=v:g.pendingContext=v,g=Ka(c),g.payload={element:f},T=T===void 0?null:T,T!==null&&(g.callback=T),f=Xa(l,g,c),f!==null&&(Us(f,l,c),zd(f,l,c))}function tR(l,c){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var f=l.retryLane;l.retryLane=f!==0&&f<c?f:c}}function V1(l,c){tR(l,c),(l=l.alternate)&&tR(l,c)}function nR(l){if(l.tag===13||l.tag===31){var c=tl(l,67108864);c!==null&&Us(c,l,67108864),V1(l,67108864)}}function sR(l){if(l.tag===13||l.tag===31){var c=hr();c=Lw(c);var f=tl(l,c);f!==null&&Us(f,l,c),V1(l,c)}}var yy=!0;function pG(l,c,f,g){var v=B.T;B.T=null;var T=V.p;try{V.p=2,U1(l,c,f,g)}finally{V.p=T,B.T=v}}function mG(l,c,f,g){var v=B.T;B.T=null;var T=V.p;try{V.p=8,U1(l,c,f,g)}finally{V.p=T,B.T=v}}function U1(l,c,f,g){if(yy){var v=j1(g);if(v===null)$1(l,c,g,by,f),iR(l,g);else if(yG(v,l,c,f,g))g.stopPropagation();else if(iR(l,g),c&4&&-1<gG.indexOf(l)){for(;v!==null;){var T=$u(v);if(T!==null)switch(T.tag){case 3:if(T=T.stateNode,T.current.memoizedState.isDehydrated){var I=Yo(T.pendingLanes);if(I!==0){var z=T;for(z.pendingLanes|=2,z.entangledLanes|=2;I;){var q=1<<31-rr(I);z.entanglements[1]|=q,I&=~q}$i(T),(Tt&6)===0&&(ey=Vt()+500,ef(0))}}break;case 31:case 13:z=tl(T,2),z!==null&&Us(z,T,2),ny(),V1(T,2)}if(T=j1(g),T===null&&$1(l,c,g,by,f),T===v)break;v=T}v!==null&&g.stopPropagation()}else $1(l,c,g,null,f)}}function j1(l){return l=Gw(l),W1(l)}var by=null;function W1(l){if(by=null,l=Eu(l),l!==null){var c=i(l);if(c===null)l=null;else{var f=c.tag;if(f===13){if(l=a(c),l!==null)return l;l=null}else if(f===31){if(l=o(c),l!==null)return l;l=null}else if(f===3){if(c.stateNode.current.memoizedState.isDehydrated)return c.tag===3?c.stateNode.containerInfo:null;l=null}else c!==l&&(l=null)}}return by=l,null}function rR(l){switch(l){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Xr()){case Yr:return 2;case Jr:return 8;case sr:case Xo:return 32;case Nu:return 268435456;default:return 32}default:return 32}}var G1=!1,ao=null,oo=null,lo=null,lf=new Map,uf=new Map,uo=[],gG="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function iR(l,c){switch(l){case"focusin":case"focusout":ao=null;break;case"dragenter":case"dragleave":oo=null;break;case"mouseover":case"mouseout":lo=null;break;case"pointerover":case"pointerout":lf.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":uf.delete(c.pointerId)}}function cf(l,c,f,g,v,T){return l===null||l.nativeEvent!==T?(l={blockedOn:c,domEventName:f,eventSystemFlags:g,nativeEvent:T,targetContainers:[v]},c!==null&&(c=$u(c),c!==null&&nR(c)),l):(l.eventSystemFlags|=g,c=l.targetContainers,v!==null&&c.indexOf(v)===-1&&c.push(v),l)}function yG(l,c,f,g,v){switch(c){case"focusin":return ao=cf(ao,l,c,f,g,v),!0;case"dragenter":return oo=cf(oo,l,c,f,g,v),!0;case"mouseover":return lo=cf(lo,l,c,f,g,v),!0;case"pointerover":var T=v.pointerId;return lf.set(T,cf(lf.get(T)||null,l,c,f,g,v)),!0;case"gotpointercapture":return T=v.pointerId,uf.set(T,cf(uf.get(T)||null,l,c,f,g,v)),!0}return!1}function aR(l){var c=Eu(l.target);if(c!==null){var f=i(c);if(f!==null){if(c=f.tag,c===13){if(c=a(f),c!==null){l.blockedOn=c,w$(l.priority,function(){sR(f)});return}}else if(c===31){if(c=o(f),c!==null){l.blockedOn=c,w$(l.priority,function(){sR(f)});return}}else if(c===3&&f.stateNode.current.memoizedState.isDehydrated){l.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}l.blockedOn=null}function xy(l){if(l.blockedOn!==null)return!1;for(var c=l.targetContainers;0<c.length;){var f=j1(l.nativeEvent);if(f===null){f=l.nativeEvent;var g=new f.constructor(f.type,f);Ww=g,f.target.dispatchEvent(g),Ww=null}else return c=$u(f),c!==null&&nR(c),l.blockedOn=f,!1;c.shift()}return!0}function oR(l,c,f){xy(l)&&f.delete(c)}function bG(){G1=!1,ao!==null&&xy(ao)&&(ao=null),oo!==null&&xy(oo)&&(oo=null),lo!==null&&xy(lo)&&(lo=null),lf.forEach(oR),uf.forEach(oR)}function wy(l,c){l.blockedOn===c&&(l.blockedOn=null,G1||(G1=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,bG)))}var vy=null;function lR(l){vy!==l&&(vy=l,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){vy===l&&(vy=null);for(var c=0;c<l.length;c+=3){var f=l[c],g=l[c+1],v=l[c+2];if(typeof g!="function"){if(W1(g||f)===null)continue;break}var T=$u(f);T!==null&&(l.splice(c,3),c-=3,jv(T,{pending:!0,data:v,method:f.method,action:g},g,v))}}))}function uc(l){function c(q){return wy(q,l)}ao!==null&&wy(ao,l),oo!==null&&wy(oo,l),lo!==null&&wy(lo,l),lf.forEach(c),uf.forEach(c);for(var f=0;f<uo.length;f++){var g=uo[f];g.blockedOn===l&&(g.blockedOn=null)}for(;0<uo.length&&(f=uo[0],f.blockedOn===null);)aR(f),f.blockedOn===null&&uo.shift();if(f=(l.ownerDocument||l).$$reactFormReplay,f!=null)for(g=0;g<f.length;g+=3){var v=f[g],T=f[g+1],I=v[Ls]||null;if(typeof T=="function")I||lR(f);else if(I){var z=null;if(T&&T.hasAttribute("formAction")){if(v=T,I=T[Ls]||null)z=I.formAction;else if(W1(v)!==null)continue}else z=I.action;typeof z=="function"?f[g+1]=z:(f.splice(g,3),g-=3),lR(f)}}}function uR(){function l(T){T.canIntercept&&T.info==="react-transition"&&T.intercept({handler:function(){return new Promise(function(I){return v=I})},focusReset:"manual",scroll:"manual"})}function c(){v!==null&&(v(),v=null),g||setTimeout(f,20)}function f(){if(!g&&!navigation.transition){var T=navigation.currentEntry;T&&T.url!=null&&navigation.navigate(T.url,{state:T.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,v=null;return navigation.addEventListener("navigate",l),navigation.addEventListener("navigatesuccess",c),navigation.addEventListener("navigateerror",c),setTimeout(f,100),function(){g=!0,navigation.removeEventListener("navigate",l),navigation.removeEventListener("navigatesuccess",c),navigation.removeEventListener("navigateerror",c),v!==null&&(v(),v=null)}}}function H1(l){this._internalRoot=l}Sy.prototype.render=H1.prototype.render=function(l){var c=this._internalRoot;if(c===null)throw Error(s(409));var f=c.current,g=hr();eR(f,g,l,c,null,null)},Sy.prototype.unmount=H1.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var c=l.containerInfo;eR(l.current,2,null,l,null,null),ny(),c[ku]=null}};function Sy(l){this._internalRoot=l}Sy.prototype.unstable_scheduleHydration=function(l){if(l){var c=x$();l={blockedOn:null,target:l,priority:c};for(var f=0;f<uo.length&&c!==0&&c<uo[f].priority;f++);uo.splice(f,0,l),f===0&&aR(l)}};var cR=e.version;if(cR!=="19.2.3")throw Error(s(527,cR,"19.2.3"));V.findDOMNode=function(l){var c=l._reactInternals;if(c===void 0)throw typeof l.render=="function"?Error(s(188)):(l=Object.keys(l).join(","),Error(s(268,l)));return l=h(c),l=l!==null?d(l):null,l=l===null?null:l.stateNode,l};var xG={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:B,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Ty=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Ty.isDisabled&&Ty.supportsFiber)try{Ti=Ty.inject(xG),Cs=Ty}catch{}}return df.createRoot=function(l,c){if(!r(l))throw Error(s(299));var f=!1,g="",v=y_,T=b_,I=x_;return c!=null&&(c.unstable_strictMode===!0&&(f=!0),c.identifierPrefix!==void 0&&(g=c.identifierPrefix),c.onUncaughtError!==void 0&&(v=c.onUncaughtError),c.onCaughtError!==void 0&&(T=c.onCaughtError),c.onRecoverableError!==void 0&&(I=c.onRecoverableError)),c=ZA(l,1,!1,null,null,f,g,null,v,T,I,uR),l[ku]=c.current,E1(l),new H1(c)},df.hydrateRoot=function(l,c,f){if(!r(l))throw Error(s(299));var g=!1,v="",T=y_,I=b_,z=x_,q=null;return f!=null&&(f.unstable_strictMode===!0&&(g=!0),f.identifierPrefix!==void 0&&(v=f.identifierPrefix),f.onUncaughtError!==void 0&&(T=f.onUncaughtError),f.onCaughtError!==void 0&&(I=f.onCaughtError),f.onRecoverableError!==void 0&&(z=f.onRecoverableError),f.formState!==void 0&&(q=f.formState)),c=ZA(l,1,!0,c,f??null,g,v,q,T,I,z,uR),c.context=QA(null),f=c.current,g=hr(),g=Lw(g),v=Ka(g),v.callback=null,Xa(f,v,g),f=g,c.current.lanes=f,wd(c,f),$i(c),l[ku]=c.current,E1(l),new Sy(c)},df.version="19.2.3",df}var wR;function RG(){if(wR)return X1.exports;wR=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),X1.exports=AG(),X1.exports}var DG=RG();const OG=wC(DG),SC=ke.createContext({});function TC(n){const e=ke.useRef(null);return e.current===null&&(e.current=n()),e.current}const CC=typeof window<"u",J3=CC?ke.useLayoutEffect:ke.useEffect,sb=ke.createContext(null);function NC(n,e){n.indexOf(e)===-1&&n.push(e)}function kC(n,e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}const va=(n,e,t)=>t>e?e:t<n?n:t;let EC=()=>{};const Sa={},Z3=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function Q3(n){return typeof n=="object"&&n!==null}const eF=n=>/^0[^.\s]+$/u.test(n);function $C(n){let e;return()=>(e===void 0&&(e=n()),e)}const Wr=n=>n,FG=(n,e)=>t=>e(n(t)),mp=(...n)=>n.reduce(FG),Mf=(n,e,t)=>{const s=e-n;return s===0?1:(t-n)/s};class IC{constructor(){this.subscriptions=[]}add(e){return NC(this.subscriptions,e),()=>kC(this.subscriptions,e)}notify(e,t,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](e,t,s);else for(let i=0;i<r;i++){const a=this.subscriptions[i];a&&a(e,t,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const Oi=n=>n*1e3,Vr=n=>n/1e3;function tF(n,e){return e?n*(1e3/e):0}const nF=(n,e,t)=>(((1-3*t+3*e)*n+(3*t-6*e))*n+3*e)*n,LG=1e-7,MG=12;function zG(n,e,t,s,r){let i,a,o=0;do a=e+(t-e)/2,i=nF(a,s,r)-n,i>0?t=a:e=a;while(Math.abs(i)>LG&&++o<MG);return a}function gp(n,e,t,s){if(n===e&&t===s)return Wr;const r=i=>zG(i,0,1,n,t);return i=>i===0||i===1?i:nF(r(i),e,s)}const sF=n=>e=>e<=.5?n(2*e)/2:(2-n(2*(1-e)))/2,rF=n=>e=>1-n(1-e),iF=gp(.33,1.53,.69,.99),_C=rF(iF),aF=sF(_C),oF=n=>(n*=2)<1?.5*_C(n):.5*(2-Math.pow(2,-10*(n-1))),AC=n=>1-Math.sin(Math.acos(n)),lF=rF(AC),uF=sF(AC),PG=gp(.42,0,1,1),BG=gp(0,0,.58,1),cF=gp(.42,0,.58,1),VG=n=>Array.isArray(n)&&typeof n[0]!="number",hF=n=>Array.isArray(n)&&typeof n[0]=="number",UG={linear:Wr,easeIn:PG,easeInOut:cF,easeOut:BG,circIn:AC,circInOut:uF,circOut:lF,backIn:_C,backInOut:aF,backOut:iF,anticipate:oF},jG=n=>typeof n=="string",vR=n=>{if(hF(n)){EC(n.length===4);const[e,t,s,r]=n;return gp(e,t,s,r)}else if(jG(n))return UG[n];return n},Cy=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function WG(n,e){let t=new Set,s=new Set,r=!1,i=!1;const a=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1};function u(d){a.has(d)&&(h.schedule(d),n()),d(o)}const h={schedule:(d,p=!1,m=!1)=>{const b=m&&r?t:s;return p&&a.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),a.delete(d)},process:d=>{if(o=d,r){i=!0;return}r=!0,[t,s]=[s,t],t.forEach(u),t.clear(),r=!1,i&&(i=!1,h.process(d))}};return h}const GG=40;function dF(n,e){let t=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},i=()=>t=!0,a=Cy.reduce((N,k)=>(N[k]=WG(i),N),{}),{setup:o,read:u,resolveKeyframes:h,preUpdate:d,update:p,preRender:m,render:y,postRender:b}=a,x=()=>{const N=Sa.useManualTiming?r.timestamp:performance.now();t=!1,Sa.useManualTiming||(r.delta=s?1e3/60:Math.max(Math.min(N-r.timestamp,GG),1)),r.timestamp=N,r.isProcessing=!0,o.process(r),u.process(r),h.process(r),d.process(r),p.process(r),m.process(r),y.process(r),b.process(r),r.isProcessing=!1,t&&e&&(s=!1,n(x))},w=()=>{t=!0,s=!0,r.isProcessing||n(x)};return{schedule:Cy.reduce((N,k)=>{const E=a[k];return N[k]=(_,R=!1,O=!1)=>(t||w(),E.schedule(_,R,O)),N},{}),cancel:N=>{for(let k=0;k<Cy.length;k++)a[Cy[k]].cancel(N)},state:r,steps:a}}const{schedule:Xt,cancel:No,state:us,steps:Q1}=dF(typeof requestAnimationFrame<"u"?requestAnimationFrame:Wr,!0);let qy;function HG(){qy=void 0}const Xs={now:()=>(qy===void 0&&Xs.set(us.isProcessing||Sa.useManualTiming?us.timestamp:performance.now()),qy),set:n=>{qy=n,queueMicrotask(HG)}},fF=n=>e=>typeof e=="string"&&e.startsWith(n),pF=fF("--"),qG=fF("var(--"),RC=n=>qG(n)?KG.test(n.split("/*")[0].trim()):!1,KG=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Jc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},zf={...Jc,transform:n=>va(0,1,n)},Ny={...Jc,default:1},_f=n=>Math.round(n*1e5)/1e5,DC=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function XG(n){return n==null}const YG=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,OC=(n,e)=>t=>!!(typeof t=="string"&&YG.test(t)&&t.startsWith(n)||e&&!XG(t)&&Object.prototype.hasOwnProperty.call(t,e)),mF=(n,e,t)=>s=>{if(typeof s!="string")return s;const[r,i,a,o]=s.match(DC);return{[n]:parseFloat(r),[e]:parseFloat(i),[t]:parseFloat(a),alpha:o!==void 0?parseFloat(o):1}},JG=n=>va(0,255,n),eS={...Jc,transform:n=>Math.round(JG(n))},_l={test:OC("rgb","red"),parse:mF("red","green","blue"),transform:({red:n,green:e,blue:t,alpha:s=1})=>"rgba("+eS.transform(n)+", "+eS.transform(e)+", "+eS.transform(t)+", "+_f(zf.transform(s))+")"};function ZG(n){let e="",t="",s="",r="";return n.length>5?(e=n.substring(1,3),t=n.substring(3,5),s=n.substring(5,7),r=n.substring(7,9)):(e=n.substring(1,2),t=n.substring(2,3),s=n.substring(3,4),r=n.substring(4,5),e+=e,t+=t,s+=s,r+=r),{red:parseInt(e,16),green:parseInt(t,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const jS={test:OC("#"),parse:ZG,transform:_l.transform},yp=n=>({test:e=>typeof e=="string"&&e.endsWith(n)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${n}`}),ho=yp("deg"),Fi=yp("%"),qe=yp("px"),QG=yp("vh"),eH=yp("vw"),SR={...Fi,parse:n=>Fi.parse(n)/100,transform:n=>Fi.transform(n*100)},Cc={test:OC("hsl","hue"),parse:mF("hue","saturation","lightness"),transform:({hue:n,saturation:e,lightness:t,alpha:s=1})=>"hsla("+Math.round(n)+", "+Fi.transform(_f(e))+", "+Fi.transform(_f(t))+", "+_f(zf.transform(s))+")"},Nn={test:n=>_l.test(n)||jS.test(n)||Cc.test(n),parse:n=>_l.test(n)?_l.parse(n):Cc.test(n)?Cc.parse(n):jS.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?_l.transform(n):Cc.transform(n),getAnimatableNone:n=>{const e=Nn.parse(n);return e.alpha=0,Nn.transform(e)}},tH=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function nH(n){return isNaN(n)&&typeof n=="string"&&(n.match(DC)?.length||0)+(n.match(tH)?.length||0)>0}const gF="number",yF="color",sH="var",rH="var(",TR="${}",iH=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Pf(n){const e=n.toString(),t=[],s={color:[],number:[],var:[]},r=[];let i=0;const o=e.replace(iH,u=>(Nn.test(u)?(s.color.push(i),r.push(yF),t.push(Nn.parse(u))):u.startsWith(rH)?(s.var.push(i),r.push(sH),t.push(u)):(s.number.push(i),r.push(gF),t.push(parseFloat(u))),++i,TR)).split(TR);return{values:t,split:o,indexes:s,types:r}}function bF(n){return Pf(n).values}function xF(n){const{split:e,types:t}=Pf(n),s=e.length;return r=>{let i="";for(let a=0;a<s;a++)if(i+=e[a],r[a]!==void 0){const o=t[a];o===gF?i+=_f(r[a]):o===yF?i+=Nn.transform(r[a]):i+=r[a]}return i}}const aH=n=>typeof n=="number"?0:Nn.test(n)?Nn.getAnimatableNone(n):n;function oH(n){const e=bF(n);return xF(n)(e.map(aH))}const ko={test:nH,parse:bF,createTransformer:xF,getAnimatableNone:oH};function tS(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function lH({hue:n,saturation:e,lightness:t,alpha:s}){n/=360,e/=100,t/=100;let r=0,i=0,a=0;if(!e)r=i=a=t;else{const o=t<.5?t*(1+e):t+e-t*e,u=2*t-o;r=tS(u,o,n+1/3),i=tS(u,o,n),a=tS(u,o,n-1/3)}return{red:Math.round(r*255),green:Math.round(i*255),blue:Math.round(a*255),alpha:s}}function f0(n,e){return t=>t>0?e:n}const en=(n,e,t)=>n+(e-n)*t,nS=(n,e,t)=>{const s=n*n,r=t*(e*e-s)+s;return r<0?0:Math.sqrt(r)},uH=[jS,_l,Cc],cH=n=>uH.find(e=>e.test(n));function CR(n){const e=cH(n);if(!e)return!1;let t=e.parse(n);return e===Cc&&(t=lH(t)),t}const NR=(n,e)=>{const t=CR(n),s=CR(e);if(!t||!s)return f0(n,e);const r={...t};return i=>(r.red=nS(t.red,s.red,i),r.green=nS(t.green,s.green,i),r.blue=nS(t.blue,s.blue,i),r.alpha=en(t.alpha,s.alpha,i),_l.transform(r))},WS=new Set(["none","hidden"]);function hH(n,e){return WS.has(n)?t=>t<=0?n:e:t=>t>=1?e:n}function dH(n,e){return t=>en(n,e,t)}function FC(n){return typeof n=="number"?dH:typeof n=="string"?RC(n)?f0:Nn.test(n)?NR:mH:Array.isArray(n)?wF:typeof n=="object"?Nn.test(n)?NR:fH:f0}function wF(n,e){const t=[...n],s=t.length,r=n.map((i,a)=>FC(i)(i,e[a]));return i=>{for(let a=0;a<s;a++)t[a]=r[a](i);return t}}function fH(n,e){const t={...n,...e},s={};for(const r in t)n[r]!==void 0&&e[r]!==void 0&&(s[r]=FC(n[r])(n[r],e[r]));return r=>{for(const i in s)t[i]=s[i](r);return t}}function pH(n,e){const t=[],s={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const i=e.types[r],a=n.indexes[i][s[i]],o=n.values[a]??0;t[r]=o,s[i]++}return t}const mH=(n,e)=>{const t=ko.createTransformer(e),s=Pf(n),r=Pf(e);return s.indexes.var.length===r.indexes.var.length&&s.indexes.color.length===r.indexes.color.length&&s.indexes.number.length>=r.indexes.number.length?WS.has(n)&&!r.values.length||WS.has(e)&&!s.values.length?hH(n,e):mp(wF(pH(s,r),r.values),t):f0(n,e)};function vF(n,e,t){return typeof n=="number"&&typeof e=="number"&&typeof t=="number"?en(n,e,t):FC(n)(n,e)}const gH=n=>{const e=({timestamp:t})=>n(t);return{start:(t=!0)=>Xt.update(e,t),stop:()=>No(e),now:()=>us.isProcessing?us.timestamp:Xs.now()}},SF=(n,e,t=10)=>{let s="";const r=Math.max(Math.round(e/t),2);for(let i=0;i<r;i++)s+=Math.round(n(i/(r-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},p0=2e4;function LC(n){let e=0;const t=50;let s=n.next(e);for(;!s.done&&e<p0;)e+=t,s=n.next(e);return e>=p0?1/0:e}function yH(n,e=100,t){const s=t({...n,keyframes:[0,e]}),r=Math.min(LC(s),p0);return{type:"keyframes",ease:i=>s.next(r*i).value/e,duration:Vr(r)}}const bH=5;function TF(n,e,t){const s=Math.max(e-bH,0);return tF(t-n(s),e-s)}const on={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},sS=.001;function xH({duration:n=on.duration,bounce:e=on.bounce,velocity:t=on.velocity,mass:s=on.mass}){let r,i,a=1-e;a=va(on.minDamping,on.maxDamping,a),n=va(on.minDuration,on.maxDuration,Vr(n)),a<1?(r=h=>{const d=h*a,p=d*n,m=d-t,y=GS(h,a),b=Math.exp(-p);return sS-m/y*b},i=h=>{const p=h*a*n,m=p*t+t,y=Math.pow(a,2)*Math.pow(h,2)*n,b=Math.exp(-p),x=GS(Math.pow(h,2),a);return(-r(h)+sS>0?-1:1)*((m-y)*b)/x}):(r=h=>{const d=Math.exp(-h*n),p=(h-t)*n+1;return-sS+d*p},i=h=>{const d=Math.exp(-h*n),p=(t-h)*(n*n);return d*p});const o=5/n,u=vH(r,i,o);if(n=Oi(n),isNaN(u))return{stiffness:on.stiffness,damping:on.damping,duration:n};{const h=Math.pow(u,2)*s;return{stiffness:h,damping:a*2*Math.sqrt(s*h),duration:n}}}const wH=12;function vH(n,e,t){let s=t;for(let r=1;r<wH;r++)s=s-n(s)/e(s);return s}function GS(n,e){return n*Math.sqrt(1-e*e)}const SH=["duration","bounce"],TH=["stiffness","damping","mass"];function kR(n,e){return e.some(t=>n[t]!==void 0)}function CH(n){let e={velocity:on.velocity,stiffness:on.stiffness,damping:on.damping,mass:on.mass,isResolvedFromDuration:!1,...n};if(!kR(n,TH)&&kR(n,SH))if(n.visualDuration){const t=n.visualDuration,s=2*Math.PI/(t*1.2),r=s*s,i=2*va(.05,1,1-(n.bounce||0))*Math.sqrt(r);e={...e,mass:on.mass,stiffness:r,damping:i}}else{const t=xH(n);e={...e,...t,mass:on.mass},e.isResolvedFromDuration=!0}return e}function m0(n=on.visualDuration,e=on.bounce){const t=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:e}:n;let{restSpeed:s,restDelta:r}=t;const i=t.keyframes[0],a=t.keyframes[t.keyframes.length-1],o={done:!1,value:i},{stiffness:u,damping:h,mass:d,duration:p,velocity:m,isResolvedFromDuration:y}=CH({...t,velocity:-Vr(t.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(u*d)),w=a-i,S=Vr(Math.sqrt(u/d)),C=Math.abs(w)<5;s||(s=C?on.restSpeed.granular:on.restSpeed.default),r||(r=C?on.restDelta.granular:on.restDelta.default);let N;if(x<1){const E=GS(S,x);N=_=>{const R=Math.exp(-x*S*_);return a-R*((b+x*S*w)/E*Math.sin(E*_)+w*Math.cos(E*_))}}else if(x===1)N=E=>a-Math.exp(-S*E)*(w+(b+S*w)*E);else{const E=S*Math.sqrt(x*x-1);N=_=>{const R=Math.exp(-x*S*_),O=Math.min(E*_,300);return a-R*((b+x*S*w)*Math.sinh(O)+E*w*Math.cosh(O))/E}}const k={calculatedDuration:y&&p||null,next:E=>{const _=N(E);if(y)o.done=E>=p;else{let R=E===0?b:0;x<1&&(R=E===0?Oi(b):TF(N,E,_));const O=Math.abs(R)<=s,F=Math.abs(a-_)<=r;o.done=O&&F}return o.value=o.done?a:_,o},toString:()=>{const E=Math.min(LC(k),p0),_=SF(R=>k.next(E*R).value,E,30);return E+"ms "+_},toTransition:()=>{}};return k}m0.applyToOptions=n=>{const e=yH(n,100,m0);return n.ease=e.ease,n.duration=Oi(e.duration),n.type="keyframes",n};function HS({keyframes:n,velocity:e=0,power:t=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:i=500,modifyTarget:a,min:o,max:u,restDelta:h=.5,restSpeed:d}){const p=n[0],m={done:!1,value:p},y=O=>o!==void 0&&O<o||u!==void 0&&O>u,b=O=>o===void 0?u:u===void 0||Math.abs(o-O)<Math.abs(u-O)?o:u;let x=t*e;const w=p+x,S=a===void 0?w:a(w);S!==w&&(x=S-p);const C=O=>-x*Math.exp(-O/s),N=O=>S+C(O),k=O=>{const F=C(O),L=N(O);m.done=Math.abs(F)<=h,m.value=m.done?S:L};let E,_;const R=O=>{y(m.value)&&(E=O,_=m0({keyframes:[m.value,b(m.value)],velocity:TF(N,O,m.value),damping:r,stiffness:i,restDelta:h,restSpeed:d}))};return R(0),{calculatedDuration:null,next:O=>{let F=!1;return!_&&E===void 0&&(F=!0,k(O),R(O)),E!==void 0&&O>=E?_.next(O-E):(!F&&k(O),m)}}}function NH(n,e,t){const s=[],r=t||Sa.mix||vF,i=n.length-1;for(let a=0;a<i;a++){let o=r(n[a],n[a+1]);if(e){const u=Array.isArray(e)?e[a]||Wr:e;o=mp(u,o)}s.push(o)}return s}function kH(n,e,{clamp:t=!0,ease:s,mixer:r}={}){const i=n.length;if(EC(i===e.length),i===1)return()=>e[0];if(i===2&&e[0]===e[1])return()=>e[1];const a=n[0]===n[1];n[0]>n[i-1]&&(n=[...n].reverse(),e=[...e].reverse());const o=NH(e,s,r),u=o.length,h=d=>{if(a&&d<n[0])return e[0];let p=0;if(u>1)for(;p<n.length-2&&!(d<n[p+1]);p++);const m=Mf(n[p],n[p+1],d);return o[p](m)};return t?d=>h(va(n[0],n[i-1],d)):h}function EH(n,e){const t=n[n.length-1];for(let s=1;s<=e;s++){const r=Mf(0,e,s);n.push(en(t,1,r))}}function $H(n){const e=[0];return EH(e,n.length-1),e}function IH(n,e){return n.map(t=>t*e)}function _H(n,e){return n.map(()=>e||cF).splice(0,n.length-1)}function Af({duration:n=300,keyframes:e,times:t,ease:s="easeInOut"}){const r=VG(s)?s.map(vR):vR(s),i={done:!1,value:e[0]},a=IH(t&&t.length===e.length?t:$H(e),n),o=kH(a,e,{ease:Array.isArray(r)?r:_H(e,r)});return{calculatedDuration:n,next:u=>(i.value=o(u),i.done=u>=n,i)}}const AH=n=>n!==null;function MC(n,{repeat:e,repeatType:t="loop"},s,r=1){const i=n.filter(AH),o=r<0||e&&t!=="loop"&&e%2===1?0:i.length-1;return!o||s===void 0?i[o]:s}const RH={decay:HS,inertia:HS,tween:Af,keyframes:Af,spring:m0};function CF(n){typeof n.type=="string"&&(n.type=RH[n.type])}class zC{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,t){return this.finished.then(e,t)}}const DH=n=>n/100;class PC extends zC{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:t}=this.options;t&&t.updatedAt!==Xs.now()&&this.tick(Xs.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;CF(e);const{type:t=Af,repeat:s=0,repeatDelay:r=0,repeatType:i,velocity:a=0}=e;let{keyframes:o}=e;const u=t||Af;u!==Af&&typeof o[0]!="number"&&(this.mixKeyframes=mp(DH,vF(o[0],o[1])),o=[0,100]);const h=u({...e,keyframes:o});i==="mirror"&&(this.mirroredGenerator=u({...e,keyframes:[...o].reverse(),velocity:-a})),h.calculatedDuration===null&&(h.calculatedDuration=LC(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+r,this.totalDuration=this.resolvedDuration*(s+1)-r,this.generator=h}updateTime(e){const t=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=t}tick(e,t=!1){const{generator:s,totalDuration:r,mixKeyframes:i,mirroredGenerator:a,resolvedDuration:o,calculatedDuration:u}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:p,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-r/this.speed,this.startTime)),t?this.currentTime=e:this.updateTime(e);const S=this.currentTime-h*(this.playbackSpeed>=0?1:-1),C=this.playbackSpeed>=0?S<0:S>r;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=r);let N=this.currentTime,k=s;if(p){const O=Math.min(this.currentTime,r)/o;let F=Math.floor(O),L=O%1;!L&&O>=1&&(L=1),L===1&&F--,F=Math.min(F,p+1),F%2&&(m==="reverse"?(L=1-L,y&&(L-=y/o)):m==="mirror"&&(k=a)),N=va(0,1,L)*o}const E=C?{done:!1,value:d[0]}:k.next(N);i&&(E.value=i(E.value));let{done:_}=E;!C&&u!==null&&(_=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const R=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&_);return R&&b!==HS&&(E.value=MC(d,this.options,w,this.speed)),x&&x(E.value),R&&this.finish(),E}then(e,t){return this.finished.then(e,t)}get duration(){return Vr(this.calculatedDuration)}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+Vr(e)}get time(){return Vr(this.currentTime)}set time(e){e=Oi(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(Xs.now());const t=this.playbackSpeed!==e;this.playbackSpeed=e,t&&(this.time=Vr(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=gH,startTime:t}=this.options;this.driver||(this.driver=e(r=>this.tick(r))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=t??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Xs.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),e.observe(this)}}function OH(n){for(let e=1;e<n.length;e++)n[e]??(n[e]=n[e-1])}const Al=n=>n*180/Math.PI,qS=n=>{const e=Al(Math.atan2(n[1],n[0]));return KS(e)},FH={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:qS,rotateZ:qS,skewX:n=>Al(Math.atan(n[1])),skewY:n=>Al(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},KS=n=>(n=n%360,n<0&&(n+=360),n),ER=qS,$R=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),IR=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),LH={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:$R,scaleY:IR,scale:n=>($R(n)+IR(n))/2,rotateX:n=>KS(Al(Math.atan2(n[6],n[5]))),rotateY:n=>KS(Al(Math.atan2(-n[2],n[0]))),rotateZ:ER,rotate:ER,skewX:n=>Al(Math.atan(n[4])),skewY:n=>Al(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function XS(n){return n.includes("scale")?1:0}function YS(n,e){if(!n||n==="none")return XS(e);const t=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,r;if(t)s=LH,r=t;else{const o=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=FH,r=o}if(!r)return XS(e);const i=s[e],a=r[1].split(",").map(zH);return typeof i=="function"?i(a):a[i]}const MH=(n,e)=>{const{transform:t="none"}=getComputedStyle(n);return YS(t,e)};function zH(n){return parseFloat(n.trim())}const Zc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Qc=new Set(Zc),_R=n=>n===Jc||n===qe,PH=new Set(["x","y","z"]),BH=Zc.filter(n=>!PH.has(n));function VH(n){const e=[];return BH.forEach(t=>{const s=n.getValue(t);s!==void 0&&(e.push([t,s.get()]),s.set(t.startsWith("scale")?1:0))}),e}const Ml={width:({x:n},{paddingLeft:e="0",paddingRight:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),height:({y:n},{paddingTop:e="0",paddingBottom:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),top:(n,{top:e})=>parseFloat(e),left:(n,{left:e})=>parseFloat(e),bottom:({y:n},{top:e})=>parseFloat(e)+(n.max-n.min),right:({x:n},{left:e})=>parseFloat(e)+(n.max-n.min),x:(n,{transform:e})=>YS(e,"x"),y:(n,{transform:e})=>YS(e,"y")};Ml.translateX=Ml.x;Ml.translateY=Ml.y;const zl=new Set;let JS=!1,ZS=!1,QS=!1;function NF(){if(ZS){const n=Array.from(zl).filter(s=>s.needsMeasurement),e=new Set(n.map(s=>s.element)),t=new Map;e.forEach(s=>{const r=VH(s);r.length&&(t.set(s,r),s.render())}),n.forEach(s=>s.measureInitialState()),e.forEach(s=>{s.render();const r=t.get(s);r&&r.forEach(([i,a])=>{s.getValue(i)?.set(a)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}ZS=!1,JS=!1,zl.forEach(n=>n.complete(QS)),zl.clear()}function kF(){zl.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(ZS=!0)})}function UH(){QS=!0,kF(),NF(),QS=!1}class BC{constructor(e,t,s,r,i,a=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...e],this.onComplete=t,this.name=s,this.motionValue=r,this.element=i,this.isAsync=a}scheduleResolve(){this.state="scheduled",this.isAsync?(zl.add(this),JS||(JS=!0,Xt.read(kF),Xt.resolveKeyframes(NF))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:t,element:s,motionValue:r}=this;if(e[0]===null){const i=r?.get(),a=e[e.length-1];if(i!==void 0)e[0]=i;else if(s&&t){const o=s.readValue(t,a);o!=null&&(e[0]=o)}e[0]===void 0&&(e[0]=a),r&&i===void 0&&r.set(e[0])}OH(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),zl.delete(this)}cancel(){this.state==="scheduled"&&(zl.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const jH=n=>n.startsWith("--");function WH(n,e,t){jH(e)?n.style.setProperty(e,t):n.style[e]=t}const GH=$C(()=>window.ScrollTimeline!==void 0),HH={};function qH(n,e){const t=$C(n);return()=>HH[e]??t()}const EF=qH(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),xf=([n,e,t,s])=>`cubic-bezier(${n}, ${e}, ${t}, ${s})`,AR={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:xf([0,.65,.55,1]),circOut:xf([.55,0,1,.45]),backIn:xf([.31,.01,.66,-.59]),backOut:xf([.33,1.53,.69,.99])};function $F(n,e){if(n)return typeof n=="function"?EF()?SF(n,e):"ease-out":hF(n)?xf(n):Array.isArray(n)?n.map(t=>$F(t,e)||AR.easeOut):AR[n]}function KH(n,e,t,{delay:s=0,duration:r=300,repeat:i=0,repeatType:a="loop",ease:o="easeOut",times:u}={},h=void 0){const d={[e]:t};u&&(d.offset=u);const p=$F(o,r);Array.isArray(p)&&(d.easing=p);const m={delay:s,duration:r,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:i+1,direction:a==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function IF(n){return typeof n=="function"&&"applyToOptions"in n}function XH({type:n,...e}){return IF(n)&&EF()?n.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class YH extends zC{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:t,name:s,keyframes:r,pseudoElement:i,allowFlatten:a=!1,finalKeyframe:o,onComplete:u}=e;this.isPseudoElement=!!i,this.allowFlatten=a,this.options=e,EC(typeof e.type!="string");const h=XH(e);this.animation=KH(t,s,r,h,i),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!i){const d=MC(r,this.options,o,this.speed);this.updateMotionValue?this.updateMotionValue(d):WH(t,s,d),this.animation.cancel()}u?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const e=this.animation.effect?.getComputedTiming?.().duration||0;return Vr(Number(e))}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+Vr(e)}get time(){return Vr(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=Oi(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:t}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,e&&GH()?(this.animation.timeline=e,Wr):t(this)}}const _F={anticipate:oF,backInOut:aF,circInOut:uF};function JH(n){return n in _F}function ZH(n){typeof n.ease=="string"&&JH(n.ease)&&(n.ease=_F[n.ease])}const RR=10;class QH extends YH{constructor(e){ZH(e),CF(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:t,onUpdate:s,onComplete:r,element:i,...a}=this.options;if(!t)return;if(e!==void 0){t.set(e);return}const o=new PC({...a,autoplay:!1}),u=Oi(this.finishedTime??this.time);t.setWithVelocity(o.sample(u-RR).value,o.sample(u).value,RR),o.stop()}}const DR=(n,e)=>e==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(ko.test(n)||n==="0")&&!n.startsWith("url("));function e5(n){const e=n[0];if(n.length===1)return!0;for(let t=0;t<n.length;t++)if(n[t]!==e)return!0}function t5(n,e,t,s){const r=n[0];if(r===null)return!1;if(e==="display"||e==="visibility")return!0;const i=n[n.length-1],a=DR(r,e),o=DR(i,e);return!a||!o?!1:e5(n)||(t==="spring"||IF(t))&&s}function eT(n){n.duration=0,n.type="keyframes"}const n5=new Set(["opacity","clipPath","filter","transform"]),s5=$C(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function r5(n){const{motionValue:e,name:t,repeatDelay:s,repeatType:r,damping:i,type:a}=n;if(!(e?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:u,transformTemplate:h}=e.owner.getProps();return s5()&&t&&n5.has(t)&&(t!=="transform"||!h)&&!u&&!s&&r!=="mirror"&&i!==0&&a!=="inertia"}const i5=40;class a5 extends zC{constructor({autoplay:e=!0,delay:t=0,type:s="keyframes",repeat:r=0,repeatDelay:i=0,repeatType:a="loop",keyframes:o,name:u,motionValue:h,element:d,...p}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Xs.now();const m={autoplay:e,delay:t,type:s,repeat:r,repeatDelay:i,repeatType:a,name:u,motionValue:h,element:d,...p},y=d?.KeyframeResolver||BC;this.keyframeResolver=new y(o,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),u,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(e,t,s,r){this.keyframeResolver=void 0;const{name:i,type:a,velocity:o,delay:u,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Xs.now(),t5(e,i,a,o)||((Sa.instantAnimations||!u)&&d?.(MC(e,s,t)),e[0]=e[e.length-1],eT(s),s.repeat=0);const m={startTime:r?this.resolvedAt?this.resolvedAt-this.createdAt>i5?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:t,...s,keyframes:e},y=!h&&r5(m)?new QH({...m,element:m.motionValue.owner.current}):new PC(m);y.finished.then(()=>this.notifyFinished()).catch(Wr),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(e,t){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),UH()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const o5=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function l5(n){const e=o5.exec(n);if(!e)return[,];const[,t,s,r]=e;return[`--${t??s}`,r]}function AF(n,e,t=1){const[s,r]=l5(n);if(!s)return;const i=window.getComputedStyle(e).getPropertyValue(s);if(i){const a=i.trim();return Z3(a)?parseFloat(a):a}return RC(r)?AF(r,e,t+1):r}function VC(n,e){return n?.[e]??n?.default??n}const RF=new Set(["width","height","top","left","right","bottom",...Zc]),u5={test:n=>n==="auto",parse:n=>n},DF=n=>e=>e.test(n),OF=[Jc,qe,Fi,ho,eH,QG,u5],OR=n=>OF.find(DF(n));function c5(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||eF(n):!0}const h5=new Set(["brightness","contrast","saturate","opacity"]);function d5(n){const[e,t]=n.slice(0,-1).split("(");if(e==="drop-shadow")return n;const[s]=t.match(DC)||[];if(!s)return n;const r=t.replace(s,"");let i=h5.has(e)?1:0;return s!==t&&(i*=100),e+"("+i+r+")"}const f5=/\b([a-z-]*)\(.*?\)/gu,tT={...ko,getAnimatableNone:n=>{const e=n.match(f5);return e?e.map(d5).join(" "):n}},FR={...Jc,transform:Math.round},p5={rotate:ho,rotateX:ho,rotateY:ho,rotateZ:ho,scale:Ny,scaleX:Ny,scaleY:Ny,scaleZ:Ny,skew:ho,skewX:ho,skewY:ho,distance:qe,translateX:qe,translateY:qe,translateZ:qe,x:qe,y:qe,z:qe,perspective:qe,transformPerspective:qe,opacity:zf,originX:SR,originY:SR,originZ:qe},UC={borderWidth:qe,borderTopWidth:qe,borderRightWidth:qe,borderBottomWidth:qe,borderLeftWidth:qe,borderRadius:qe,radius:qe,borderTopLeftRadius:qe,borderTopRightRadius:qe,borderBottomRightRadius:qe,borderBottomLeftRadius:qe,width:qe,maxWidth:qe,height:qe,maxHeight:qe,top:qe,right:qe,bottom:qe,left:qe,padding:qe,paddingTop:qe,paddingRight:qe,paddingBottom:qe,paddingLeft:qe,margin:qe,marginTop:qe,marginRight:qe,marginBottom:qe,marginLeft:qe,backgroundPositionX:qe,backgroundPositionY:qe,...p5,zIndex:FR,fillOpacity:zf,strokeOpacity:zf,numOctaves:FR},m5={...UC,color:Nn,backgroundColor:Nn,outlineColor:Nn,fill:Nn,stroke:Nn,borderColor:Nn,borderTopColor:Nn,borderRightColor:Nn,borderBottomColor:Nn,borderLeftColor:Nn,filter:tT,WebkitFilter:tT},FF=n=>m5[n];function LF(n,e){let t=FF(n);return t!==tT&&(t=ko),t.getAnimatableNone?t.getAnimatableNone(e):void 0}const g5=new Set(["auto","none","0"]);function y5(n,e,t){let s=0,r;for(;s<n.length&&!r;){const i=n[s];typeof i=="string"&&!g5.has(i)&&Pf(i).values.length&&(r=n[s]),s++}if(r&&t)for(const i of e)n[i]=LF(t,r)}class b5 extends BC{constructor(e,t,s,r,i){super(e,t,s,r,i,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:t,name:s}=this;if(!t||!t.current)return;super.readKeyframes();for(let u=0;u<e.length;u++){let h=e[u];if(typeof h=="string"&&(h=h.trim(),RC(h))){const d=AF(h,t.current);d!==void 0&&(e[u]=d),u===e.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!RF.has(s)||e.length!==2)return;const[r,i]=e,a=OR(r),o=OR(i);if(a!==o)if(_R(a)&&_R(o))for(let u=0;u<e.length;u++){const h=e[u];typeof h=="string"&&(e[u]=parseFloat(h))}else Ml[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:t}=this,s=[];for(let r=0;r<e.length;r++)(e[r]===null||c5(e[r]))&&s.push(r);s.length&&y5(e,s,t)}measureInitialState(){const{element:e,unresolvedKeyframes:t,name:s}=this;if(!e||!e.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=Ml[s](e.measureViewportBox(),window.getComputedStyle(e.current)),t[0]=this.measuredOrigin;const r=t[t.length-1];r!==void 0&&e.getValue(s,r).jump(r,!1)}measureEndState(){const{element:e,name:t,unresolvedKeyframes:s}=this;if(!e||!e.current)return;const r=e.getValue(t);r&&r.jump(this.measuredOrigin,!1);const i=s.length-1,a=s[i];s[i]=Ml[t](e.measureViewportBox(),window.getComputedStyle(e.current)),a!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=a),this.removedTransforms?.length&&this.removedTransforms.forEach(([o,u])=>{e.getValue(o).set(u)}),this.resolveNoneKeyframes()}}function x5(n,e,t){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const r=t?.[n]??s.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}const MF=(n,e)=>e&&typeof n=="number"?e.transform(n):n;function zF(n){return Q3(n)&&"offsetHeight"in n}const LR=30,w5=n=>!isNaN(parseFloat(n));class v5{constructor(e,t={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const r=Xs.now();if(this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const i of this.dependents)i.dirty()},this.hasAnimated=!1,this.setCurrent(e),this.owner=t.owner}setCurrent(e){this.current=e,this.updatedAt=Xs.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=w5(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new IC);const s=this.events[e].add(t);return e==="change"?()=>{s(),Xt.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e){this.passiveEffect?this.passiveEffect(e,this.updateAndNotify):this.updateAndNotify(e)}setWithVelocity(e,t,s){this.set(t),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-s}jump(e,t=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,t&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(e){this.dependents||(this.dependents=new Set),this.dependents.add(e)}removeDependent(e){this.dependents&&this.dependents.delete(e)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=Xs.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>LR)return 0;const t=Math.min(this.updatedAt-this.prevUpdatedAt,LR);return tF(parseFloat(this.current)-parseFloat(this.prevFrameValue),t)}start(e){return this.stop(),new Promise(t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Fc(n,e){return new v5(n,e)}const{schedule:jC}=dF(queueMicrotask,!1),ri={x:!1,y:!1};function PF(){return ri.x||ri.y}function S5(n){return n==="x"||n==="y"?ri[n]?null:(ri[n]=!0,()=>{ri[n]=!1}):ri.x||ri.y?null:(ri.x=ri.y=!0,()=>{ri.x=ri.y=!1})}function BF(n,e){const t=x5(n),s=new AbortController,r={passive:!0,...e,signal:s.signal};return[t,r,()=>s.abort()]}function MR(n){return!(n.pointerType==="touch"||PF())}function T5(n,e,t={}){const[s,r,i]=BF(n,t),a=o=>{if(!MR(o))return;const{target:u}=o,h=e(u,o);if(typeof h!="function"||!u)return;const d=p=>{MR(p)&&(h(p),u.removeEventListener("pointerleave",d))};u.addEventListener("pointerleave",d,r)};return s.forEach(o=>{o.addEventListener("pointerenter",a,r)}),i}const VF=(n,e)=>e?n===e?!0:VF(n,e.parentElement):!1,WC=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,C5=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function N5(n){return C5.has(n.tagName)||n.tabIndex!==-1}const Ky=new WeakSet;function zR(n){return e=>{e.key==="Enter"&&n(e)}}function rS(n,e){n.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const k5=(n,e)=>{const t=n.currentTarget;if(!t)return;const s=zR(()=>{if(Ky.has(t))return;rS(t,"down");const r=zR(()=>{rS(t,"up")}),i=()=>rS(t,"cancel");t.addEventListener("keyup",r,e),t.addEventListener("blur",i,e)});t.addEventListener("keydown",s,e),t.addEventListener("blur",()=>t.removeEventListener("keydown",s),e)};function PR(n){return WC(n)&&!PF()}function E5(n,e,t={}){const[s,r,i]=BF(n,t),a=o=>{const u=o.currentTarget;if(!PR(o))return;Ky.add(u);const h=e(u,o),d=(y,b)=>{window.removeEventListener("pointerup",p),window.removeEventListener("pointercancel",m),Ky.has(u)&&Ky.delete(u),PR(y)&&typeof h=="function"&&h(y,{success:b})},p=y=>{d(y,u===window||u===document||t.useGlobalTarget||VF(u,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",p,r),window.addEventListener("pointercancel",m,r)};return s.forEach(o=>{(t.useGlobalTarget?window:o).addEventListener("pointerdown",a,r),zF(o)&&(o.addEventListener("focus",h=>k5(h,r)),!N5(o)&&!o.hasAttribute("tabindex")&&(o.tabIndex=0))}),i}function UF(n){return Q3(n)&&"ownerSVGElement"in n}function $5(n){return UF(n)&&n.tagName==="svg"}const ys=n=>!!(n&&n.getVelocity),I5=[...OF,Nn,ko],_5=n=>I5.find(DF(n)),GC=ke.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function BR(n,e){if(typeof n=="function")return n(e);n!=null&&(n.current=e)}function A5(...n){return e=>{let t=!1;const s=n.map(r=>{const i=BR(r,e);return!t&&typeof i=="function"&&(t=!0),i});if(t)return()=>{for(let r=0;r<s.length;r++){const i=s[r];typeof i=="function"?i():BR(n[r],null)}}}}function R5(...n){return ke.useCallback(A5(...n),n)}class D5 extends ke.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const s=t.offsetParent,r=zF(s)&&s.offsetWidth||0,i=this.props.sizeRef.current;i.height=t.offsetHeight||0,i.width=t.offsetWidth||0,i.top=t.offsetTop,i.left=t.offsetLeft,i.right=r-i.width-i.left}return null}componentDidUpdate(){}render(){return this.props.children}}function O5({children:n,isPresent:e,anchorX:t,root:s}){const r=ke.useId(),i=ke.useRef(null),a=ke.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:o}=ke.useContext(GC),u=R5(i,n?.ref);return ke.useInsertionEffect(()=>{const{width:h,height:d,top:p,left:m,right:y}=a.current;if(e||!i.current||!h||!d)return;const b=t==="left"?`left: ${m}`:`right: ${y}`;i.current.dataset.motionPopId=r;const x=document.createElement("style");o&&(x.nonce=o);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${p}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[e]),xe.jsx(D5,{isPresent:e,childRef:i,sizeRef:a,children:ke.cloneElement(n,{ref:u})})}const F5=({children:n,initial:e,isPresent:t,onExitComplete:s,custom:r,presenceAffectsLayout:i,mode:a,anchorX:o,root:u})=>{const h=TC(L5),d=ke.useId();let p=!0,m=ke.useMemo(()=>(p=!1,{id:d,initial:e,isPresent:t,custom:r,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[t,h,s]);return i&&p&&(m={...m}),ke.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[t]),ke.useEffect(()=>{!t&&!h.size&&s&&s()},[t]),a==="popLayout"&&(n=xe.jsx(O5,{isPresent:t,anchorX:o,root:u,children:n})),xe.jsx(sb.Provider,{value:m,children:n})};function L5(){return new Map}function jF(n=!0){const e=ke.useContext(sb);if(e===null)return[!0,null];const{isPresent:t,onExitComplete:s,register:r}=e,i=ke.useId();ke.useEffect(()=>{if(n)return r(i)},[n]);const a=ke.useCallback(()=>n&&s&&s(i),[i,s,n]);return!t&&s?[!1,a]:[!0]}const ky=n=>n.key||"";function VR(n){const e=[];return ke.Children.forEach(n,t=>{ke.isValidElement(t)&&e.push(t)}),e}const M5=({children:n,custom:e,initial:t=!0,onExitComplete:s,presenceAffectsLayout:r=!0,mode:i="sync",propagate:a=!1,anchorX:o="left",root:u})=>{const[h,d]=jF(a),p=ke.useMemo(()=>VR(n),[n]),m=a&&!h?[]:p.map(ky),y=ke.useRef(!0),b=ke.useRef(p),x=TC(()=>new Map),[w,S]=ke.useState(p),[C,N]=ke.useState(p);J3(()=>{y.current=!1,b.current=p;for(let _=0;_<C.length;_++){const R=ky(C[_]);m.includes(R)?x.delete(R):x.get(R)!==!0&&x.set(R,!1)}},[C,m.length,m.join("-")]);const k=[];if(p!==w){let _=[...p];for(let R=0;R<C.length;R++){const O=C[R],F=ky(O);m.includes(F)||(_.splice(R,0,O),k.push(O))}return i==="wait"&&k.length&&(_=k),N(VR(_)),S(p),null}const{forceRender:E}=ke.useContext(SC);return xe.jsx(xe.Fragment,{children:C.map(_=>{const R=ky(_),O=a&&!h?!1:p===C||m.includes(R),F=()=>{if(x.has(R))x.set(R,!0);else return;let L=!0;x.forEach(A=>{A||(L=!1)}),L&&(E?.(),N(b.current),a&&d?.(),s&&s())};return xe.jsx(F5,{isPresent:O,initial:!y.current||t?void 0:!1,custom:e,presenceAffectsLayout:r,mode:i,root:u,onExitComplete:O?void 0:F,anchorX:o,children:_},R)})})},WF=ke.createContext({strict:!1}),UR={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Lc={};for(const n in UR)Lc[n]={isEnabled:e=>UR[n].some(t=>!!e[t])};function z5(n){for(const e in n)Lc[e]={...Lc[e],...n[e]}}const P5=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function g0(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||P5.has(n)}let GF=n=>!g0(n);function B5(n){typeof n=="function"&&(GF=e=>e.startsWith("on")?!g0(e):n(e))}try{B5(require("@emotion/is-prop-valid").default)}catch{}function V5(n,e,t){const s={};for(const r in n)r==="values"&&typeof n.values=="object"||(GF(r)||t===!0&&g0(r)||!e&&!g0(r)||n.draggable&&r.startsWith("onDrag"))&&(s[r]=n[r]);return s}const rb=ke.createContext({});function ib(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function Bf(n){return typeof n=="string"||Array.isArray(n)}const HC=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],qC=["initial",...HC];function ab(n){return ib(n.animate)||qC.some(e=>Bf(n[e]))}function HF(n){return!!(ab(n)||n.variants)}function U5(n,e){if(ab(n)){const{initial:t,animate:s}=n;return{initial:t===!1||Bf(t)?t:void 0,animate:Bf(s)?s:void 0}}return n.inherit!==!1?e:{}}function j5(n){const{initial:e,animate:t}=U5(n,ke.useContext(rb));return ke.useMemo(()=>({initial:e,animate:t}),[jR(e),jR(t)])}function jR(n){return Array.isArray(n)?n.join(" "):n}function WR(n,e){return e.max===e.min?0:n/(e.max-e.min)*100}const ff={correct:(n,e)=>{if(!e.target)return n;if(typeof n=="string")if(qe.test(n))n=parseFloat(n);else return n;const t=WR(n,e.target.x),s=WR(n,e.target.y);return`${t}% ${s}%`}},W5={correct:(n,{treeScale:e,projectionDelta:t})=>{const s=n,r=ko.parse(n);if(r.length>5)return s;const i=ko.createTransformer(n),a=typeof r[0]!="number"?1:0,o=t.x.scale*e.x,u=t.y.scale*e.y;r[0+a]/=o,r[1+a]/=u;const h=en(o,u,.5);return typeof r[2+a]=="number"&&(r[2+a]/=h),typeof r[3+a]=="number"&&(r[3+a]/=h),i(r)}},nT={borderRadius:{...ff,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:ff,borderTopRightRadius:ff,borderBottomLeftRadius:ff,borderBottomRightRadius:ff,boxShadow:W5};function qF(n,{layout:e,layoutId:t}){return Qc.has(n)||n.startsWith("origin")||(e||t!==void 0)&&(!!nT[n]||n==="opacity")}const G5={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},H5=Zc.length;function q5(n,e,t){let s="",r=!0;for(let i=0;i<H5;i++){const a=Zc[i],o=n[a];if(o===void 0)continue;let u=!0;if(typeof o=="number"?u=o===(a.startsWith("scale")?1:0):u=parseFloat(o)===0,!u||t){const h=MF(o,UC[a]);if(!u){r=!1;const d=G5[a]||a;s+=`${d}(${h}) `}t&&(e[a]=h)}}return s=s.trim(),t?s=t(e,r?"":s):r&&(s="none"),s}function KC(n,e,t){const{style:s,vars:r,transformOrigin:i}=n;let a=!1,o=!1;for(const u in e){const h=e[u];if(Qc.has(u)){a=!0;continue}else if(pF(u)){r[u]=h;continue}else{const d=MF(h,UC[u]);u.startsWith("origin")?(o=!0,i[u]=d):s[u]=d}}if(e.transform||(a||t?s.transform=q5(e,n.transform,t):s.transform&&(s.transform="none")),o){const{originX:u="50%",originY:h="50%",originZ:d=0}=i;s.transformOrigin=`${u} ${h} ${d}`}}const XC=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function KF(n,e,t){for(const s in e)!ys(e[s])&&!qF(s,t)&&(n[s]=e[s])}function K5({transformTemplate:n},e){return ke.useMemo(()=>{const t=XC();return KC(t,e,n),Object.assign({},t.vars,t.style)},[e])}function X5(n,e){const t=n.style||{},s={};return KF(s,t,n),Object.assign(s,K5(n,e)),s}function Y5(n,e){const t={},s=X5(n,e);return n.drag&&n.dragListener!==!1&&(t.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(t.tabIndex=0),t.style=s,t}const J5={offset:"stroke-dashoffset",array:"stroke-dasharray"},Z5={offset:"strokeDashoffset",array:"strokeDasharray"};function Q5(n,e,t=1,s=0,r=!0){n.pathLength=1;const i=r?J5:Z5;n[i.offset]=qe.transform(-s);const a=qe.transform(e),o=qe.transform(t);n[i.array]=`${a} ${o}`}function XF(n,{attrX:e,attrY:t,attrScale:s,pathLength:r,pathSpacing:i=1,pathOffset:a=0,...o},u,h,d){if(KC(n,o,h),u){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:m}=n;p.transform&&(m.transform=p.transform,delete p.transform),(m.transform||p.transformOrigin)&&(m.transformOrigin=p.transformOrigin??"50% 50%",delete p.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete p.transformBox),e!==void 0&&(p.x=e),t!==void 0&&(p.y=t),s!==void 0&&(p.scale=s),r!==void 0&&Q5(p,r,i,a,!1)}const YF=()=>({...XC(),attrs:{}}),JF=n=>typeof n=="string"&&n.toLowerCase()==="svg";function e6(n,e,t,s){const r=ke.useMemo(()=>{const i=YF();return XF(i,e,JF(s),n.transformTemplate,n.style),{...i.attrs,style:{...i.style}}},[e]);if(n.style){const i={};KF(i,n.style,n),r.style={...i,...r.style}}return r}const t6=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function YC(n){return typeof n!="string"||n.includes("-")?!1:!!(t6.indexOf(n)>-1||/[A-Z]/u.test(n))}function n6(n,e,t,{latestValues:s},r,i=!1){const o=(YC(n)?e6:Y5)(e,s,r,n),u=V5(e,typeof n=="string",i),h=n!==ke.Fragment?{...u,...o,ref:t}:{},{children:d}=e,p=ke.useMemo(()=>ys(d)?d.get():d,[d]);return ke.createElement(n,{...h,children:p})}function GR(n){const e=[{},{}];return n?.values.forEach((t,s)=>{e[0][s]=t.get(),e[1][s]=t.getVelocity()}),e}function JC(n,e,t,s){if(typeof e=="function"){const[r,i]=GR(s);e=e(t!==void 0?t:n.custom,r,i)}if(typeof e=="string"&&(e=n.variants&&n.variants[e]),typeof e=="function"){const[r,i]=GR(s);e=e(t!==void 0?t:n.custom,r,i)}return e}function Xy(n){return ys(n)?n.get():n}function s6({scrapeMotionValuesFromProps:n,createRenderState:e},t,s,r){return{latestValues:r6(t,s,r,n),renderState:e()}}function r6(n,e,t,s){const r={},i=s(n,{});for(const m in i)r[m]=Xy(i[m]);let{initial:a,animate:o}=n;const u=ab(n),h=HF(n);e&&h&&!u&&n.inherit!==!1&&(a===void 0&&(a=e.initial),o===void 0&&(o=e.animate));let d=t?t.initial===!1:!1;d=d||a===!1;const p=d?o:a;if(p&&typeof p!="boolean"&&!ib(p)){const m=Array.isArray(p)?p:[p];for(let y=0;y<m.length;y++){const b=JC(n,m[y]);if(b){const{transitionEnd:x,transition:w,...S}=b;for(const C in S){let N=S[C];if(Array.isArray(N)){const k=d?N.length-1:0;N=N[k]}N!==null&&(r[C]=N)}for(const C in x)r[C]=x[C]}}}return r}const ZF=n=>(e,t)=>{const s=ke.useContext(rb),r=ke.useContext(sb),i=()=>s6(n,e,s,r);return t?i():TC(i)};function ZC(n,e,t){const{style:s}=n,r={};for(const i in s)(ys(s[i])||e.style&&ys(e.style[i])||qF(i,n)||t?.getValue(i)?.liveStyle!==void 0)&&(r[i]=s[i]);return r}const i6=ZF({scrapeMotionValuesFromProps:ZC,createRenderState:XC});function QF(n,e,t){const s=ZC(n,e,t);for(const r in n)if(ys(n[r])||ys(e[r])){const i=Zc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;s[i]=n[r]}return s}const a6=ZF({scrapeMotionValuesFromProps:QF,createRenderState:YF}),o6=Symbol.for("motionComponentSymbol");function Nc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function l6(n,e,t){return ke.useCallback(s=>{s&&n.onMount&&n.onMount(s),e&&(s?e.mount(s):e.unmount()),t&&(typeof t=="function"?t(s):Nc(t)&&(t.current=s))},[e])}const QC=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),u6="framerAppearId",eL="data-"+QC(u6),tL=ke.createContext({});function c6(n,e,t,s,r){const{visualElement:i}=ke.useContext(rb),a=ke.useContext(WF),o=ke.useContext(sb),u=ke.useContext(GC).reducedMotion,h=ke.useRef(null);s=s||a.renderer,!h.current&&s&&(h.current=s(n,{visualState:e,parent:i,props:t,presenceContext:o,blockInitialAnimation:o?o.initial===!1:!1,reducedMotionConfig:u}));const d=h.current,p=ke.useContext(tL);d&&!d.projection&&r&&(d.type==="html"||d.type==="svg")&&h6(h.current,t,r,p);const m=ke.useRef(!1);ke.useInsertionEffect(()=>{d&&m.current&&d.update(t,o)});const y=t[eL],b=ke.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return J3(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),ke.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function h6(n,e,t,s){const{layoutId:r,layout:i,drag:a,dragConstraints:o,layoutScroll:u,layoutRoot:h,layoutCrossfade:d}=e;n.projection=new t(n.latestValues,e["data-framer-portal-id"]?void 0:nL(n.parent)),n.projection.setOptions({layoutId:r,layout:i,alwaysMeasureLayout:!!a||o&&Nc(o),visualElement:n,animationType:typeof i=="string"?i:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:u,layoutRoot:h})}function nL(n){if(n)return n.options.allowProjection!==!1?n.projection:nL(n.parent)}function iS(n,{forwardMotionProps:e=!1}={},t,s){t&&z5(t);const r=YC(n)?a6:i6;function i(o,u){let h;const d={...ke.useContext(GC),...o,layoutId:d6(o)},{isStatic:p}=d,m=j5(o),y=r(o,p);if(!p&&CC){f6();const b=p6(d);h=b.MeasureLayout,m.visualElement=c6(n,y,d,s,b.ProjectionNode)}return xe.jsxs(rb.Provider,{value:m,children:[h&&m.visualElement?xe.jsx(h,{visualElement:m.visualElement,...d}):null,n6(n,o,l6(y,m.visualElement,u),y,p,e)]})}i.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const a=ke.forwardRef(i);return a[o6]=n,a}function d6({layoutId:n}){const e=ke.useContext(SC).id;return e&&n!==void 0?e+"-"+n:n}function f6(n,e){ke.useContext(WF).strict}function p6(n){const{drag:e,layout:t}=Lc;if(!e&&!t)return{};const s={...e,...t};return{MeasureLayout:e?.isEnabled(n)||t?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function m6(n,e){if(typeof Proxy>"u")return iS;const t=new Map,s=(i,a)=>iS(i,a,n,e),r=(i,a)=>s(i,a);return new Proxy(r,{get:(i,a)=>a==="create"?s:(t.has(a)||t.set(a,iS(a,void 0,n,e)),t.get(a))})}function sL({top:n,left:e,right:t,bottom:s}){return{x:{min:e,max:t},y:{min:n,max:s}}}function g6({x:n,y:e}){return{top:e.min,right:n.max,bottom:e.max,left:n.min}}function y6(n,e){if(!e)return n;const t=e({x:n.left,y:n.top}),s=e({x:n.right,y:n.bottom});return{top:t.y,left:t.x,bottom:s.y,right:s.x}}function aS(n){return n===void 0||n===1}function sT({scale:n,scaleX:e,scaleY:t}){return!aS(n)||!aS(e)||!aS(t)}function xl(n){return sT(n)||rL(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function rL(n){return HR(n.x)||HR(n.y)}function HR(n){return n&&n!=="0%"}function y0(n,e,t){const s=n-t,r=e*s;return t+r}function qR(n,e,t,s,r){return r!==void 0&&(n=y0(n,r,s)),y0(n,t,s)+e}function rT(n,e=0,t=1,s,r){n.min=qR(n.min,e,t,s,r),n.max=qR(n.max,e,t,s,r)}function iL(n,{x:e,y:t}){rT(n.x,e.translate,e.scale,e.originPoint),rT(n.y,t.translate,t.scale,t.originPoint)}const KR=.999999999999,XR=1.0000000000001;function b6(n,e,t,s=!1){const r=t.length;if(!r)return;e.x=e.y=1;let i,a;for(let o=0;o<r;o++){i=t[o],a=i.projectionDelta;const{visualElement:u}=i.options;u&&u.props.style&&u.props.style.display==="contents"||(s&&i.options.layoutScroll&&i.scroll&&i!==i.root&&Ec(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),a&&(e.x*=a.x.scale,e.y*=a.y.scale,iL(n,a)),s&&xl(i.latestValues)&&Ec(n,i.latestValues))}e.x<XR&&e.x>KR&&(e.x=1),e.y<XR&&e.y>KR&&(e.y=1)}function kc(n,e){n.min=n.min+e,n.max=n.max+e}function YR(n,e,t,s,r=.5){const i=en(n.min,n.max,r);rT(n,e,t,i,s)}function Ec(n,e){YR(n.x,e.x,e.scaleX,e.scale,e.originX),YR(n.y,e.y,e.scaleY,e.scale,e.originY)}function aL(n,e){return sL(y6(n.getBoundingClientRect(),e))}function x6(n,e,t){const s=aL(n,t),{scroll:r}=e;return r&&(kc(s.x,r.offset.x),kc(s.y,r.offset.y)),s}const JR=()=>({translate:0,scale:1,origin:0,originPoint:0}),$c=()=>({x:JR(),y:JR()}),ZR=()=>({min:0,max:0}),On=()=>({x:ZR(),y:ZR()}),iT={current:null},oL={current:!1};function w6(){if(oL.current=!0,!!CC)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),e=()=>iT.current=n.matches;n.addEventListener("change",e),e()}else iT.current=!1}const v6=new WeakMap;function S6(n,e,t){for(const s in e){const r=e[s],i=t[s];if(ys(r))n.addValue(s,r);else if(ys(i))n.addValue(s,Fc(r,{owner:n}));else if(i!==r)if(n.hasValue(s)){const a=n.getValue(s);a.liveStyle===!0?a.jump(r):a.hasAnimated||a.set(r)}else{const a=n.getStaticValue(s);n.addValue(s,Fc(a!==void 0?a:r,{owner:n}))}}for(const s in t)e[s]===void 0&&n.removeValue(s);return e}const QR=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class T6{scrapeMotionValuesFromProps(e,t,s){return{}}constructor({parent:e,props:t,presenceContext:s,reducedMotionConfig:r,blockInitialAnimation:i,visualState:a},o={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=BC,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Xs.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,Xt.render(this.render,!1,!0))};const{latestValues:u,renderState:h}=a;this.latestValues=u,this.baseTarget={...u},this.initialValues=t.initial?{...u}:{},this.renderState=h,this.parent=e,this.props=t,this.presenceContext=s,this.depth=e?e.depth+1:0,this.reducedMotionConfig=r,this.options=o,this.blockInitialAnimation=!!i,this.isControllingVariants=ab(t),this.isVariantNode=HF(t),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...p}=this.scrapeMotionValuesFromProps(t,{},this);for(const m in p){const y=p[m];u[m]!==void 0&&ys(y)&&y.set(u[m])}}mount(e){this.current=e,v6.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,s)=>this.bindToMotionValue(s,t)),oL.current||w6(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:iT.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),No(this.notifyUpdate),No(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const t=this.features[e];t&&(t.unmount(),t.isMounted=!1)}this.current=null}addChild(e){this.children.add(e),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(e)}removeChild(e){this.children.delete(e),this.enteringChildren&&this.enteringChildren.delete(e)}bindToMotionValue(e,t){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const s=Qc.has(e);s&&this.onBindTransform&&this.onBindTransform();const r=t.on("change",a=>{this.latestValues[e]=a,this.props.onUpdate&&Xt.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,e,t)),this.valueSubscriptions.set(e,()=>{r(),i&&i(),t.owner&&t.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in Lc){const t=Lc[e];if(!t)continue;const{isEnabled:s,Feature:r}=t;if(!this.features[e]&&r&&s(this.props)&&(this.features[e]=new r(this)),this.features[e]){const i=this.features[e];i.isMounted?i.update():(i.mount(),i.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):On()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let s=0;s<QR.length;s++){const r=QR[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const i="on"+r,a=e[i];a&&(this.propEventSubscriptions[r]=this.on(r,a))}this.prevMotionValues=S6(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){const s=this.values.get(e);t!==s&&(s&&this.removeValue(e),this.bindToMotionValue(e,t),this.values.set(e,t),this.latestValues[e]=t.get())}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let s=this.values.get(e);return s===void 0&&t!==void 0&&(s=Fc(t===null?void 0:t,{owner:this}),this.addValue(e,s)),s}readValue(e,t){let s=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return s!=null&&(typeof s=="string"&&(Z3(s)||eF(s))?s=parseFloat(s):!_5(s)&&ko.test(t)&&(s=LF(e,t)),this.setBaseTarget(e,ys(s)?s.get():s)),ys(s)?s.get():s}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){const{initial:t}=this.props;let s;if(typeof t=="string"||typeof t=="object"){const i=JC(this.props,t,this.presenceContext?.custom);i&&(s=i[e])}if(t&&s!==void 0)return s;const r=this.getBaseTargetFromProps(this.props,e);return r!==void 0&&!ys(r)?r:this.initialValues[e]!==void 0&&s===void 0?void 0:this.baseTarget[e]}on(e,t){return this.events[e]||(this.events[e]=new IC),this.events[e].add(t)}notify(e,...t){this.events[e]&&this.events[e].notify(...t)}scheduleRenderMicrotask(){jC.render(this.render)}}class lL extends T6{constructor(){super(...arguments),this.KeyframeResolver=b5}sortInstanceNodePosition(e,t){return e.compareDocumentPosition(t)&2?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,{vars:t,style:s}){delete t[e],delete s[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;ys(e)&&(this.childSubscription=e.on("change",t=>{this.current&&(this.current.textContent=`${t}`)}))}}function uL(n,{style:e,vars:t},s,r){const i=n.style;let a;for(a in e)i[a]=e[a];r?.applyProjectionStyles(i,s);for(a in t)i.setProperty(a,t[a])}function C6(n){return window.getComputedStyle(n)}class N6 extends lL{constructor(){super(...arguments),this.type="html",this.renderInstance=uL}readValueFromInstance(e,t){if(Qc.has(t))return this.projection?.isProjecting?XS(t):MH(e,t);{const s=C6(e),r=(pF(t)?s.getPropertyValue(t):s[t])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(e,{transformPagePoint:t}){return aL(e,t)}build(e,t,s){KC(e,t,s.transformTemplate)}scrapeMotionValuesFromProps(e,t,s){return ZC(e,t,s)}}const cL=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function k6(n,e,t,s){uL(n,e,void 0,s);for(const r in e.attrs)n.setAttribute(cL.has(r)?r:QC(r),e.attrs[r])}class E6 extends lL{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=On}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(Qc.has(t)){const s=FF(t);return s&&s.default||0}return t=cL.has(t)?t:QC(t),e.getAttribute(t)}scrapeMotionValuesFromProps(e,t,s){return QF(e,t,s)}build(e,t,s){XF(e,t,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(e,t,s,r){k6(e,t,s,r)}mount(e){this.isSVGTag=JF(e.tagName),super.mount(e)}}const $6=(n,e)=>YC(n)?new E6(e):new N6(e,{allowProjection:n!==ke.Fragment});function _c(n,e,t){const s=n.getProps();return JC(s,e,t!==void 0?t:s.custom,n)}const aT=n=>Array.isArray(n);function I6(n,e,t){n.hasValue(e)?n.getValue(e).set(t):n.addValue(e,Fc(t))}function _6(n){return aT(n)?n[n.length-1]||0:n}function A6(n,e){const t=_c(n,e);let{transitionEnd:s={},transition:r={},...i}=t||{};i={...i,...s};for(const a in i){const o=_6(i[a]);I6(n,a,o)}}function R6(n){return!!(ys(n)&&n.add)}function oT(n,e){const t=n.getValue("willChange");if(R6(t))return t.add(e);if(!t&&Sa.WillChange){const s=new Sa.WillChange("auto");n.addValue("willChange",s),s.add(e)}}function hL(n){return n.props[eL]}const D6=n=>n!==null;function O6(n,{repeat:e,repeatType:t="loop"},s){const r=n.filter(D6),i=e&&t!=="loop"&&e%2===1?0:r.length-1;return r[i]}const F6={type:"spring",stiffness:500,damping:25,restSpeed:10},L6=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),M6={type:"keyframes",duration:.8},z6={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},P6=(n,{keyframes:e})=>e.length>2?M6:Qc.has(n)?n.startsWith("scale")?L6(e[1]):F6:z6;function B6({when:n,delay:e,delayChildren:t,staggerChildren:s,staggerDirection:r,repeat:i,repeatType:a,repeatDelay:o,from:u,elapsed:h,...d}){return!!Object.keys(d).length}const e2=(n,e,t,s={},r,i)=>a=>{const o=VC(s,n)||{},u=o.delay||s.delay||0;let{elapsed:h=0}=s;h=h-Oi(u);const d={keyframes:Array.isArray(t)?t:[null,t],ease:"easeOut",velocity:e.getVelocity(),...o,delay:-h,onUpdate:m=>{e.set(m),o.onUpdate&&o.onUpdate(m)},onComplete:()=>{a(),o.onComplete&&o.onComplete()},name:n,motionValue:e,element:i?void 0:r};B6(o)||Object.assign(d,P6(n,d)),d.duration&&(d.duration=Oi(d.duration)),d.repeatDelay&&(d.repeatDelay=Oi(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let p=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(eT(d),d.delay===0&&(p=!0)),(Sa.instantAnimations||Sa.skipAnimations)&&(p=!0,eT(d),d.delay=0),d.allowFlatten=!o.type&&!o.ease,p&&!i&&e.get()!==void 0){const m=O6(d.keyframes,o);if(m!==void 0){Xt.update(()=>{d.onUpdate(m),d.onComplete()});return}}return o.isSync?new PC(d):new a5(d)};function V6({protectedKeys:n,needsAnimating:e},t){const s=n.hasOwnProperty(t)&&e[t]!==!0;return e[t]=!1,s}function dL(n,e,{delay:t=0,transitionOverride:s,type:r}={}){let{transition:i=n.getDefaultTransition(),transitionEnd:a,...o}=e;s&&(i=s);const u=[],h=r&&n.animationState&&n.animationState.getState()[r];for(const d in o){const p=n.getValue(d,n.latestValues[d]??null),m=o[d];if(m===void 0||h&&V6(h,d))continue;const y={delay:t,...VC(i||{},d)},b=p.get();if(b!==void 0&&!p.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=hL(n);if(S){const C=window.MotionHandoffAnimation(S,d,Xt);C!==null&&(y.startTime=C,x=!0)}}oT(n,d),p.start(e2(d,p,m,n.shouldReduceMotion&&RF.has(d)?{type:!1}:y,n,x));const w=p.animation;w&&u.push(w)}return a&&Promise.all(u).then(()=>{Xt.update(()=>{a&&A6(n,a)})}),u}function fL(n,e,t,s=0,r=1){const i=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(e),a=n.size,o=(a-1)*s;return typeof t=="function"?t(i,a):r===1?i*s:o-i*s}function lT(n,e,t={}){const s=_c(n,e,t.type==="exit"?n.presenceContext?.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=s||{};t.transitionOverride&&(r=t.transitionOverride);const i=s?()=>Promise.all(dL(n,s,t)):()=>Promise.resolve(),a=n.variantChildren&&n.variantChildren.size?(u=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:p}=r;return U6(n,e,u,h,d,p,t)}:()=>Promise.resolve(),{when:o}=r;if(o){const[u,h]=o==="beforeChildren"?[i,a]:[a,i];return u().then(()=>h())}else return Promise.all([i(),a(t.delay)])}function U6(n,e,t=0,s=0,r=0,i=1,a){const o=[];for(const u of n.variantChildren)u.notify("AnimationStart",e),o.push(lT(u,e,{...a,delay:t+(typeof s=="function"?0:s)+fL(n.variantChildren,u,s,r,i)}).then(()=>u.notify("AnimationComplete",e)));return Promise.all(o)}function j6(n,e,t={}){n.notify("AnimationStart",e);let s;if(Array.isArray(e)){const r=e.map(i=>lT(n,i,t));s=Promise.all(r)}else if(typeof e=="string")s=lT(n,e,t);else{const r=typeof e=="function"?_c(n,e,t.custom):e;s=Promise.all(dL(n,r,t))}return s.then(()=>{n.notify("AnimationComplete",e)})}function pL(n,e){if(!Array.isArray(e))return!1;const t=e.length;if(t!==n.length)return!1;for(let s=0;s<t;s++)if(e[s]!==n[s])return!1;return!0}const W6=qC.length;function mL(n){if(!n)return;if(!n.isControllingVariants){const t=n.parent?mL(n.parent)||{}:{};return n.props.initial!==void 0&&(t.initial=n.props.initial),t}const e={};for(let t=0;t<W6;t++){const s=qC[t],r=n.props[s];(Bf(r)||r===!1)&&(e[s]=r)}return e}const G6=[...HC].reverse(),H6=HC.length;function q6(n){return e=>Promise.all(e.map(({animation:t,options:s})=>j6(n,t,s)))}function K6(n){let e=q6(n),t=eD(),s=!0;const r=u=>(h,d)=>{const p=_c(n,d,u==="exit"?n.presenceContext?.custom:void 0);if(p){const{transition:m,transitionEnd:y,...b}=p;h={...h,...b,...y}}return h};function i(u){e=u(n)}function a(u){const{props:h}=n,d=mL(n.parent)||{},p=[],m=new Set;let y={},b=1/0;for(let w=0;w<H6;w++){const S=G6[w],C=t[S],N=h[S]!==void 0?h[S]:d[S],k=Bf(N),E=S===u?C.isActive:null;E===!1&&(b=w);let _=N===d[S]&&N!==h[S]&&k;if(_&&s&&n.manuallyAnimateOnMount&&(_=!1),C.protectedKeys={...y},!C.isActive&&E===null||!N&&!C.prevProp||ib(N)||typeof N=="boolean")continue;const R=X6(C.prevProp,N);let O=R||S===u&&C.isActive&&!_&&k||w>b&&k,F=!1;const L=Array.isArray(N)?N:[N];let A=L.reduce(r(S),{});E===!1&&(A={});const{prevResolvedValues:U={}}=C,Y={...U,...A},te=V=>{O=!0,m.has(V)&&(F=!0,m.delete(V)),C.needsAnimating[V]=!0;const j=n.getValue(V);j&&(j.liveStyle=!1)};for(const V in Y){const j=A[V],ee=U[V];if(y.hasOwnProperty(V))continue;let ae=!1;aT(j)&&aT(ee)?ae=!pL(j,ee):ae=j!==ee,ae?j!=null?te(V):m.add(V):j!==void 0&&m.has(V)?te(V):C.protectedKeys[V]=!0}C.prevProp=N,C.prevResolvedValues=A,C.isActive&&(y={...y,...A}),s&&n.blockInitialAnimation&&(O=!1);const Z=_&&R;O&&(!Z||F)&&p.push(...L.map(V=>{const j={type:S};if(typeof V=="string"&&s&&!Z&&n.manuallyAnimateOnMount&&n.parent){const{parent:ee}=n,ae=_c(ee,V);if(ee.enteringChildren&&ae){const{delayChildren:P}=ae.transition||{};j.delay=fL(ee.enteringChildren,n,P)}}return{animation:V,options:j}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const S=_c(n,Array.isArray(h.initial)?h.initial[0]:h.initial);S&&S.transition&&(w.transition=S.transition)}m.forEach(S=>{const C=n.getBaseTarget(S),N=n.getValue(S);N&&(N.liveStyle=!0),w[S]=C??null}),p.push({animation:w})}let x=!!p.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?e(p):Promise.resolve()}function o(u,h){if(t[u].isActive===h)return Promise.resolve();n.variantChildren?.forEach(p=>p.animationState?.setActive(u,h)),t[u].isActive=h;const d=a(u);for(const p in t)t[p].protectedKeys={};return d}return{animateChanges:a,setActive:o,setAnimateFunction:i,getState:()=>t,reset:()=>{t=eD()}}}function X6(n,e){return typeof e=="string"?e!==n:Array.isArray(e)?!pL(e,n):!1}function pl(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function eD(){return{animate:pl(!0),whileInView:pl(),whileHover:pl(),whileTap:pl(),whileDrag:pl(),whileFocus:pl(),exit:pl()}}class zo{constructor(e){this.isMounted=!1,this.node=e}update(){}}class Y6 extends zo{constructor(e){super(e),e.animationState||(e.animationState=K6(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();ib(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let J6=0;class Z6 extends zo{constructor(){super(...arguments),this.id=J6++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===s)return;const r=this.node.animationState.setActive("exit",!e);t&&!e&&r.then(()=>{t(this.id)})}mount(){const{register:e,onExitComplete:t}=this.node.presenceContext||{};t&&t(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const Q6={animation:{Feature:Y6},exit:{Feature:Z6}};function Vf(n,e,t,s={passive:!0}){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t)}function bp(n){return{point:{x:n.pageX,y:n.pageY}}}const eq=n=>e=>WC(e)&&n(e,bp(e));function Rf(n,e,t,s){return Vf(n,e,eq(t),s)}const gL=1e-4,tq=1-gL,nq=1+gL,yL=.01,sq=0-yL,rq=0+yL;function Es(n){return n.max-n.min}function iq(n,e,t){return Math.abs(n-e)<=t}function tD(n,e,t,s=.5){n.origin=s,n.originPoint=en(e.min,e.max,n.origin),n.scale=Es(t)/Es(e),n.translate=en(t.min,t.max,n.origin)-n.originPoint,(n.scale>=tq&&n.scale<=nq||isNaN(n.scale))&&(n.scale=1),(n.translate>=sq&&n.translate<=rq||isNaN(n.translate))&&(n.translate=0)}function Df(n,e,t,s){tD(n.x,e.x,t.x,s?s.originX:void 0),tD(n.y,e.y,t.y,s?s.originY:void 0)}function nD(n,e,t){n.min=t.min+e.min,n.max=n.min+Es(e)}function aq(n,e,t){nD(n.x,e.x,t.x),nD(n.y,e.y,t.y)}function sD(n,e,t){n.min=e.min-t.min,n.max=n.min+Es(e)}function b0(n,e,t){sD(n.x,e.x,t.x),sD(n.y,e.y,t.y)}function Pr(n){return[n("x"),n("y")]}const bL=({current:n})=>n?n.ownerDocument.defaultView:null,rD=(n,e)=>Math.abs(n-e);function oq(n,e){const t=rD(n.x,e.x),s=rD(n.y,e.y);return Math.sqrt(t**2+s**2)}class xL{constructor(e,t,{transformPagePoint:s,contextWindow:r=window,dragSnapToOrigin:i=!1,distanceThreshold:a=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=lS(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=oq(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=us;this.history.push({...x,timestamp:w});const{onStart:S,onMove:C}=this.handlers;y||(S&&S(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),C&&C(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=oS(y,this.transformPagePoint),Xt.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const S=lS(m.type==="pointercancel"?this.lastMoveEventInfo:oS(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,S),x&&x(m,S)},!WC(e))return;this.dragSnapToOrigin=i,this.handlers=t,this.transformPagePoint=s,this.distanceThreshold=a,this.contextWindow=r||window;const o=bp(e),u=oS(o,this.transformPagePoint),{point:h}=u,{timestamp:d}=us;this.history=[{...h,timestamp:d}];const{onSessionStart:p}=t;p&&p(e,lS(u,this.history)),this.removeListeners=mp(Rf(this.contextWindow,"pointermove",this.handlePointerMove),Rf(this.contextWindow,"pointerup",this.handlePointerUp),Rf(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),No(this.updatePoint)}}function oS(n,e){return e?{point:e(n.point)}:n}function iD(n,e){return{x:n.x-e.x,y:n.y-e.y}}function lS({point:n},e){return{point:n,delta:iD(n,wL(e)),offset:iD(n,lq(e)),velocity:uq(e,.1)}}function lq(n){return n[0]}function wL(n){return n[n.length-1]}function uq(n,e){if(n.length<2)return{x:0,y:0};let t=n.length-1,s=null;const r=wL(n);for(;t>=0&&(s=n[t],!(r.timestamp-s.timestamp>Oi(e)));)t--;if(!s)return{x:0,y:0};const i=Vr(r.timestamp-s.timestamp);if(i===0)return{x:0,y:0};const a={x:(r.x-s.x)/i,y:(r.y-s.y)/i};return a.x===1/0&&(a.x=0),a.y===1/0&&(a.y=0),a}function cq(n,{min:e,max:t},s){return e!==void 0&&n<e?n=s?en(e,n,s.min):Math.max(n,e):t!==void 0&&n>t&&(n=s?en(t,n,s.max):Math.min(n,t)),n}function aD(n,e,t){return{min:e!==void 0?n.min+e:void 0,max:t!==void 0?n.max+t-(n.max-n.min):void 0}}function hq(n,{top:e,left:t,bottom:s,right:r}){return{x:aD(n.x,t,r),y:aD(n.y,e,s)}}function oD(n,e){let t=e.min-n.min,s=e.max-n.max;return e.max-e.min<n.max-n.min&&([t,s]=[s,t]),{min:t,max:s}}function dq(n,e){return{x:oD(n.x,e.x),y:oD(n.y,e.y)}}function fq(n,e){let t=.5;const s=Es(n),r=Es(e);return r>s?t=Mf(e.min,e.max-s,n.min):s>r&&(t=Mf(n.min,n.max-r,e.min)),va(0,1,t)}function pq(n,e){const t={};return e.min!==void 0&&(t.min=e.min-n.min),e.max!==void 0&&(t.max=e.max-n.min),t}const uT=.35;function mq(n=uT){return n===!1?n=0:n===!0&&(n=uT),{x:lD(n,"left","right"),y:lD(n,"top","bottom")}}function lD(n,e,t){return{min:uD(n,e),max:uD(n,t)}}function uD(n,e){return typeof n=="number"?n:n[e]||0}const gq=new WeakMap;class yq{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=On(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=e}start(e,{snapToCursor:t=!1,distanceThreshold:s}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const i=p=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),t&&this.snapToCursor(bp(p).point)},a=(p,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=S5(y),!this.openDragLock))return;this.latestPointerEvent=p,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Pr(S=>{let C=this.getAxisMotionValue(S).get()||0;if(Fi.test(C)){const{projection:N}=this.visualElement;if(N&&N.layout){const k=N.layout.layoutBox[S];k&&(C=Es(k)*(parseFloat(C)/100))}}this.originPoint[S]=C}),x&&Xt.postRender(()=>x(p,m)),oT(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},o=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:S}=m;if(b&&this.currentDirection===null){this.currentDirection=bq(S),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,S),this.updateAxis("y",m.point,S),this.visualElement.render(),w&&w(p,m)},u=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m,this.stop(p,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>Pr(p=>this.getAnimationState(p)==="paused"&&this.getAxisMotionValue(p).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new xL(e,{onSessionStart:i,onStart:a,onMove:o,onSessionEnd:u,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:bL(this.visualElement)})}stop(e,t){const s=e||this.latestPointerEvent,r=t||this.latestPanInfo,i=this.isDragging;if(this.cancel(),!i||!r||!s)return;const{velocity:a}=r;this.startAnimation(a);const{onDragEnd:o}=this.getProps();o&&Xt.postRender(()=>o(s,r))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,s){const{drag:r}=this.getProps();if(!s||!Ey(e,r,this.currentDirection))return;const i=this.getAxisMotionValue(e);let a=this.originPoint[e]+s[e];this.constraints&&this.constraints[e]&&(a=cq(a,this.constraints[e],this.elastic[e])),i.set(a)}resolveConstraints(){const{dragConstraints:e,dragElastic:t}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;e&&Nc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&s?this.constraints=hq(s.layoutBox,e):this.constraints=!1,this.elastic=mq(t),r!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&Pr(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=pq(s.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!Nc(e))return!1;const s=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const i=x6(s,r.root,this.visualElement.getTransformPagePoint());let a=dq(r.layout.layoutBox,i);if(t){const o=t(g6(a));this.hasMutatedConstraints=!!o,o&&(a=sL(o))}return a}startAnimation(e){const{drag:t,dragMomentum:s,dragElastic:r,dragTransition:i,dragSnapToOrigin:a,onDragTransitionEnd:o}=this.getProps(),u=this.constraints||{},h=Pr(d=>{if(!Ey(d,t,this.currentDirection))return;let p=u&&u[d]||{};a&&(p={min:0,max:0});const m=r?200:1e6,y=r?40:1e7,b={type:"inertia",velocity:s?e[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...i,...p};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(o)}startAxisValueAnimation(e,t){const s=this.getAxisMotionValue(e);return oT(this.visualElement,e),s.start(e2(e,s,0,t,this.visualElement,!1))}stopAnimation(){Pr(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){Pr(e=>this.getAxisMotionValue(e).animation?.pause())}getAnimationState(e){return this.getAxisMotionValue(e).animation?.state}getAxisMotionValue(e){const t=`_drag${e.toUpperCase()}`,s=this.visualElement.getProps(),r=s[t];return r||this.visualElement.getValue(e,(s.initial?s.initial[e]:void 0)||0)}snapToCursor(e){Pr(t=>{const{drag:s}=this.getProps();if(!Ey(t,s,this.currentDirection))return;const{projection:r}=this.visualElement,i=this.getAxisMotionValue(t);if(r&&r.layout){const{min:a,max:o}=r.layout.layoutBox[t];i.set(e[t]-en(a,o,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:s}=this.visualElement;if(!Nc(t)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};Pr(a=>{const o=this.getAxisMotionValue(a);if(o&&this.constraints!==!1){const u=o.get();r[a]=fq({min:u,max:u},this.constraints[a])}});const{transformTemplate:i}=this.visualElement.getProps();this.visualElement.current.style.transform=i?i({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),Pr(a=>{if(!Ey(a,e,null))return;const o=this.getAxisMotionValue(a),{min:u,max:h}=this.constraints[a];o.set(en(u,h,r[a]))})}addListeners(){if(!this.visualElement.current)return;gq.set(this.visualElement,this);const e=this.visualElement.current,t=Rf(e,"pointerdown",u=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(u)}),s=()=>{const{dragConstraints:u}=this.getProps();Nc(u)&&u.current&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,i=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),Xt.read(s);const a=Vf(window,"resize",()=>this.scalePositionWithinConstraints()),o=r.addEventListener("didUpdate",(({delta:u,hasLayoutChanged:h})=>{this.isDragging&&h&&(Pr(d=>{const p=this.getAxisMotionValue(d);p&&(this.originPoint[d]+=u[d].translate,p.set(p.get()+u[d].translate))}),this.visualElement.render())}));return()=>{a(),t(),i(),o&&o()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:i=!1,dragElastic:a=uT,dragMomentum:o=!0}=e;return{...e,drag:t,dragDirectionLock:s,dragPropagation:r,dragConstraints:i,dragElastic:a,dragMomentum:o}}}function Ey(n,e,t){return(e===!0||e===n)&&(t===null||t===n)}function bq(n,e=10){let t=null;return Math.abs(n.y)>e?t="y":Math.abs(n.x)>e&&(t="x"),t}class xq extends zo{constructor(e){super(e),this.removeGroupControls=Wr,this.removeListeners=Wr,this.controls=new yq(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||Wr}unmount(){this.removeGroupControls(),this.removeListeners()}}const cD=n=>(e,t)=>{n&&Xt.postRender(()=>n(e,t))};class wq extends zo{constructor(){super(...arguments),this.removePointerDownListener=Wr}onPointerDown(e){this.session=new xL(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:bL(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:cD(e),onStart:cD(t),onMove:s,onEnd:(i,a)=>{delete this.session,r&&Xt.postRender(()=>r(i,a))}}}mount(){this.removePointerDownListener=Rf(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const Yy={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let uS=!1;class vq extends ke.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s,layoutId:r}=this.props,{projection:i}=e;i&&(t.group&&t.group.add(i),s&&s.register&&r&&s.register(i),uS&&i.root.didUpdate(),i.addEventListener("animationComplete",()=>{this.safeToRemove()}),i.setOptions({...i.options,onExitComplete:()=>this.safeToRemove()})),Yy.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:s,drag:r,isPresent:i}=this.props,{projection:a}=s;return a&&(a.isPresent=i,uS=!0,r||e.layoutDependency!==t||t===void 0||e.isPresent!==i?a.willUpdate():this.safeToRemove(),e.isPresent!==i&&(i?a.promote():a.relegate()||Xt.postRender(()=>{const o=a.getStack();(!o||!o.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),jC.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s}=this.props,{projection:r}=e;uS=!0,r&&(r.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function vL(n){const[e,t]=jF(),s=ke.useContext(SC);return xe.jsx(vq,{...n,layoutGroup:s,switchLayoutGroup:ke.useContext(tL),isPresent:e,safeToRemove:t})}function Sq(n,e,t){const s=ys(n)?n:Fc(n);return s.start(e2("",s,e,t)),s.animation}const Tq=(n,e)=>n.depth-e.depth;class Cq{constructor(){this.children=[],this.isDirty=!1}add(e){NC(this.children,e),this.isDirty=!0}remove(e){kC(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(Tq),this.isDirty=!1,this.children.forEach(e)}}function Nq(n,e){const t=Xs.now(),s=({timestamp:r})=>{const i=r-t;i>=e&&(No(s),n(i-e))};return Xt.setup(s,!0),()=>No(s)}const SL=["TopLeft","TopRight","BottomLeft","BottomRight"],kq=SL.length,hD=n=>typeof n=="string"?parseFloat(n):n,dD=n=>typeof n=="number"||qe.test(n);function Eq(n,e,t,s,r,i){r?(n.opacity=en(0,t.opacity??1,$q(s)),n.opacityExit=en(e.opacity??1,0,Iq(s))):i&&(n.opacity=en(e.opacity??1,t.opacity??1,s));for(let a=0;a<kq;a++){const o=`border${SL[a]}Radius`;let u=fD(e,o),h=fD(t,o);if(u===void 0&&h===void 0)continue;u||(u=0),h||(h=0),u===0||h===0||dD(u)===dD(h)?(n[o]=Math.max(en(hD(u),hD(h),s),0),(Fi.test(h)||Fi.test(u))&&(n[o]+="%")):n[o]=h}(e.rotate||t.rotate)&&(n.rotate=en(e.rotate||0,t.rotate||0,s))}function fD(n,e){return n[e]!==void 0?n[e]:n.borderRadius}const $q=TL(0,.5,lF),Iq=TL(.5,.95,Wr);function TL(n,e,t){return s=>s<n?0:s>e?1:t(Mf(n,e,s))}function pD(n,e){n.min=e.min,n.max=e.max}function ti(n,e){pD(n.x,e.x),pD(n.y,e.y)}function mD(n,e){n.translate=e.translate,n.scale=e.scale,n.originPoint=e.originPoint,n.origin=e.origin}function gD(n,e,t,s,r){return n-=e,n=y0(n,1/t,s),r!==void 0&&(n=y0(n,1/r,s)),n}function _q(n,e=0,t=1,s=.5,r,i=n,a=n){if(Fi.test(e)&&(e=parseFloat(e),e=en(a.min,a.max,e/100)-a.min),typeof e!="number")return;let o=en(i.min,i.max,s);n===i&&(o-=e),n.min=gD(n.min,e,t,o,r),n.max=gD(n.max,e,t,o,r)}function yD(n,e,[t,s,r],i,a){_q(n,e[t],e[s],e[r],e.scale,i,a)}const Aq=["x","scaleX","originX"],Rq=["y","scaleY","originY"];function bD(n,e,t,s){yD(n.x,e,Aq,t?t.x:void 0,s?s.x:void 0),yD(n.y,e,Rq,t?t.y:void 0,s?s.y:void 0)}function xD(n){return n.translate===0&&n.scale===1}function CL(n){return xD(n.x)&&xD(n.y)}function wD(n,e){return n.min===e.min&&n.max===e.max}function Dq(n,e){return wD(n.x,e.x)&&wD(n.y,e.y)}function vD(n,e){return Math.round(n.min)===Math.round(e.min)&&Math.round(n.max)===Math.round(e.max)}function NL(n,e){return vD(n.x,e.x)&&vD(n.y,e.y)}function SD(n){return Es(n.x)/Es(n.y)}function TD(n,e){return n.translate===e.translate&&n.scale===e.scale&&n.originPoint===e.originPoint}class Oq{constructor(){this.members=[]}add(e){NC(this.members,e),e.scheduleRender()}remove(e){if(kC(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(e){const t=this.members.findIndex(r=>e===r);if(t===0)return!1;let s;for(let r=t;r>=0;r--){const i=this.members[r];if(i.isPresent!==!1){s=i;break}}return s?(this.promote(s),!0):!1}promote(e,t){const s=this.lead;if(e!==s&&(this.prevLead=s,this.lead=e,e.show(),s)){s.instance&&s.scheduleRender(),e.scheduleRender(),e.resumeFrom=s,t&&(e.resumeFrom.preserveOpacity=!0),s.snapshot&&(e.snapshot=s.snapshot,e.snapshot.latestValues=s.animationValues||s.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:t,resumingFrom:s}=e;t.onExitComplete&&t.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function Fq(n,e,t){let s="";const r=n.x.translate/e.x,i=n.y.translate/e.y,a=t?.z||0;if((r||i||a)&&(s=`translate3d(${r}px, ${i}px, ${a}px) `),(e.x!==1||e.y!==1)&&(s+=`scale(${1/e.x}, ${1/e.y}) `),t){const{transformPerspective:h,rotate:d,rotateX:p,rotateY:m,skewX:y,skewY:b}=t;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),p&&(s+=`rotateX(${p}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const o=n.x.scale*e.x,u=n.y.scale*e.y;return(o!==1||u!==1)&&(s+=`scale(${o}, ${u})`),s||"none"}const cS=["","X","Y","Z"],Lq=1e3;let Mq=0;function hS(n,e,t,s){const{latestValues:r}=e;r[n]&&(t[n]=r[n],e.setStaticValue(n,0),s&&(s[n]=0))}function kL(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:e}=n.options;if(!e)return;const t=hL(e);if(window.MotionHasOptimisedAnimation(t,"transform")){const{layout:r,layoutId:i}=n.options;window.MotionCancelOptimisedAnimation(t,"transform",Xt,!(r||i))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&kL(s)}function EL({attachResizeListener:n,defaultParent:e,measureScroll:t,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(a={},o=e?.()){this.id=Mq++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(Bq),this.nodes.forEach(Wq),this.nodes.forEach(Gq),this.nodes.forEach(Vq)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=a,this.root=o?o.root||o:this,this.path=o?[...o.path,o]:[],this.parent=o,this.depth=o?o.depth+1:0;for(let u=0;u<this.path.length;u++)this.path[u].shouldResetTransform=!0;this.root===this&&(this.nodes=new Cq)}addEventListener(a,o){return this.eventHandlers.has(a)||this.eventHandlers.set(a,new IC),this.eventHandlers.get(a).add(o)}notifyListeners(a,...o){const u=this.eventHandlers.get(a);u&&u.notify(...o)}hasListeners(a){return this.eventHandlers.has(a)}mount(a){if(this.instance)return;this.isSVG=UF(a)&&!$5(a),this.instance=a;const{layoutId:o,layout:u,visualElement:h}=this.options;if(h&&!h.current&&h.mount(a),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(u||o)&&(this.isLayoutDirty=!0),n){let d,p=0;const m=()=>this.root.updateBlockedByResize=!1;Xt.read(()=>{p=window.innerWidth}),n(a,()=>{const y=window.innerWidth;y!==p&&(p=y,this.root.updateBlockedByResize=!0,d&&d(),d=Nq(m,250),Yy.hasAnimatedSinceResize&&(Yy.hasAnimatedSinceResize=!1,this.nodes.forEach(kD)))})}o&&this.root.registerSharedNode(o,this),this.options.animate!==!1&&h&&(o||u)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:p,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||Yq,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),S=!this.targetLayout||!NL(this.targetLayout,y),C=!p&&m;if(this.options.layoutRoot||this.resumeFrom||C||p&&(S||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const N={...VC(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(N.delay=0,N.type=!1),this.startAnimation(N),this.setAnimationOrigin(d,C)}else p||kD(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const a=this.getStack();a&&a.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),No(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Hq),this.animationId++)}getTransformTemplate(){const{visualElement:a}=this.options;return a&&a.getProps().transformTemplate}willUpdate(a=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&kL(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const p=this.path[d];p.shouldResetTransform=!0,p.updateScroll("snapshot"),p.options.layoutRoot&&p.willUpdate(!1)}const{layoutId:o,layout:u}=this.options;if(o===void 0&&!u)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),a&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(CD);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(ND);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(jq),this.nodes.forEach(zq),this.nodes.forEach(Pq)):this.nodes.forEach(ND),this.clearAllSnapshots();const o=Xs.now();us.delta=va(0,1e3/60,o-us.timestamp),us.timestamp=o,us.isProcessing=!0,Q1.update.process(us),Q1.preRender.process(us),Q1.render.process(us),us.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,jC.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Uq),this.sharedNodes.forEach(qq)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,Xt.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){Xt.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!Es(this.snapshot.measuredBox.x)&&!Es(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let u=0;u<this.path.length;u++)this.path[u].updateScroll();const a=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=On(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:o}=this.options;o&&o.notify("LayoutMeasure",this.layout.layoutBox,a?a.layoutBox:void 0)}updateScroll(a="measure"){let o=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===a&&(o=!1),o&&this.instance){const u=s(this.instance);this.scroll={animationId:this.root.animationId,phase:a,isRoot:u,offset:t(this.instance),wasRoot:this.scroll?this.scroll.isRoot:u}}}resetTransform(){if(!r)return;const a=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,o=this.projectionDelta&&!CL(this.projectionDelta),u=this.getTransformTemplate(),h=u?u(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;a&&this.instance&&(o||xl(this.latestValues)||d)&&(r(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(a=!0){const o=this.measurePageBox();let u=this.removeElementScroll(o);return a&&(u=this.removeTransform(u)),Jq(u),{animationId:this.root.animationId,measuredBox:o,layoutBox:u,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:a}=this.options;if(!a)return On();const o=a.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(Zq))){const{scroll:h}=this.root;h&&(kc(o.x,h.offset.x),kc(o.y,h.offset.y))}return o}removeElementScroll(a){const o=On();if(ti(o,a),this.scroll?.wasRoot)return o;for(let u=0;u<this.path.length;u++){const h=this.path[u],{scroll:d,options:p}=h;h!==this.root&&d&&p.layoutScroll&&(d.wasRoot&&ti(o,a),kc(o.x,d.offset.x),kc(o.y,d.offset.y))}return o}applyTransform(a,o=!1){const u=On();ti(u,a);for(let h=0;h<this.path.length;h++){const d=this.path[h];!o&&d.options.layoutScroll&&d.scroll&&d!==d.root&&Ec(u,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),xl(d.latestValues)&&Ec(u,d.latestValues)}return xl(this.latestValues)&&Ec(u,this.latestValues),u}removeTransform(a){const o=On();ti(o,a);for(let u=0;u<this.path.length;u++){const h=this.path[u];if(!h.instance||!xl(h.latestValues))continue;sT(h.latestValues)&&h.updateSnapshot();const d=On(),p=h.measurePageBox();ti(d,p),bD(o,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return xl(this.latestValues)&&bD(o,this.latestValues),o}setTargetDelta(a){this.targetDelta=a,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(a){this.options={...this.options,...a,crossfade:a.crossfade!==void 0?a.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==us.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(a=!1){const o=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=o.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=o.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=o.isSharedProjectionDirty);const u=!!this.resumingFrom||this!==o;if(!(a||u&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:p}=this.options;if(!this.layout||!(d||p))return;this.resolvedRelativeTargetAt=us.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=On(),this.targetWithTransforms=On()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),aq(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):ti(this.target,this.layout.layoutBox),iL(this.target,this.targetDelta)):ti(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||sT(this.parent.latestValues)||rL(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(a,o,u){this.relativeParent=a,this.linkedParentVersion=a.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=On(),this.relativeTargetOrigin=On(),b0(this.relativeTargetOrigin,o,u),ti(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const a=this.getLead(),o=!!this.resumingFrom||this!==a;let u=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(u=!1),o&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(u=!1),this.resolvedRelativeTargetAt===us.timestamp&&(u=!1),u)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;ti(this.layoutCorrected,this.layout.layoutBox);const p=this.treeScale.x,m=this.treeScale.y;b6(this.layoutCorrected,this.treeScale,this.path,o),a.layout&&!a.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(a.target=a.layout.layoutBox,a.targetWithTransforms=On());const{target:y}=a;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(mD(this.prevProjectionDelta.x,this.projectionDelta.x),mD(this.prevProjectionDelta.y,this.projectionDelta.y)),Df(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==p||this.treeScale.y!==m||!TD(this.projectionDelta.x,this.prevProjectionDelta.x)||!TD(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(a=!0){if(this.options.visualElement?.scheduleRender(),a){const o=this.getStack();o&&o.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=$c(),this.projectionDelta=$c(),this.projectionDeltaWithTransform=$c()}setAnimationOrigin(a,o=!1){const u=this.snapshot,h=u?u.latestValues:{},d={...this.latestValues},p=$c();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!o;const m=On(),y=u?u.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),S=!w||w.members.length<=1,C=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(Xq));this.animationProgress=0;let N;this.mixTargetDelta=k=>{const E=k/1e3;ED(p.x,a.x,E),ED(p.y,a.y,E),this.setTargetDelta(p),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(b0(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),Kq(this.relativeTarget,this.relativeTargetOrigin,m,E),N&&Dq(this.relativeTarget,N)&&(this.isProjectionDirty=!1),N||(N=On()),ti(N,this.relativeTarget)),x&&(this.animationValues=d,Eq(d,h,this.latestValues,E,C,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(a){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(No(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=Xt.update(()=>{Yy.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Fc(0)),this.currentAnimation=Sq(this.motionValue,[0,1e3],{...a,velocity:0,isSync:!0,onUpdate:o=>{this.mixTargetDelta(o),a.onUpdate&&a.onUpdate(o)},onStop:()=>{},onComplete:()=>{a.onComplete&&a.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const a=this.getStack();a&&a.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(Lq),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const a=this.getLead();let{targetWithTransforms:o,target:u,layout:h,latestValues:d}=a;if(!(!o||!u||!h)){if(this!==a&&this.layout&&h&&$L(this.options.animationType,this.layout.layoutBox,h.layoutBox)){u=this.target||On();const p=Es(this.layout.layoutBox.x);u.x.min=a.target.x.min,u.x.max=u.x.min+p;const m=Es(this.layout.layoutBox.y);u.y.min=a.target.y.min,u.y.max=u.y.min+m}ti(o,u),Ec(o,d),Df(this.projectionDeltaWithTransform,this.layoutCorrected,o,d)}}registerSharedNode(a,o){this.sharedNodes.has(a)||this.sharedNodes.set(a,new Oq),this.sharedNodes.get(a).add(o);const h=o.options.initialPromotionConfig;o.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(o):void 0})}isLead(){const a=this.getStack();return a?a.lead===this:!0}getLead(){const{layoutId:a}=this.options;return a?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:a}=this.options;return a?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:a}=this.options;if(a)return this.root.sharedNodes.get(a)}promote({needsReset:a,transition:o,preserveFollowOpacity:u}={}){const h=this.getStack();h&&h.promote(this,u),a&&(this.projectionDelta=void 0,this.needsReset=!0),o&&this.setOptions({transition:o})}relegate(){const a=this.getStack();return a?a.relegate(this):!1}resetSkewAndRotation(){const{visualElement:a}=this.options;if(!a)return;let o=!1;const{latestValues:u}=a;if((u.z||u.rotate||u.rotateX||u.rotateY||u.rotateZ||u.skewX||u.skewY)&&(o=!0),!o)return;const h={};u.z&&hS("z",a,h,this.animationValues);for(let d=0;d<cS.length;d++)hS(`rotate${cS[d]}`,a,h,this.animationValues),hS(`skew${cS[d]}`,a,h,this.animationValues);a.render();for(const d in h)a.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);a.scheduleRender()}applyProjectionStyles(a,o){if(!this.instance||this.isSVG)return;if(!this.isVisible){a.visibility="hidden";return}const u=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,a.visibility="",a.opacity="",a.pointerEvents=Xy(o?.pointerEvents)||"",a.transform=u?u(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(a.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,a.pointerEvents=Xy(o?.pointerEvents)||""),this.hasProjected&&!xl(this.latestValues)&&(a.transform=u?u({},""):"none",this.hasProjected=!1);return}a.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let p=Fq(this.projectionDeltaWithTransform,this.treeScale,d);u&&(p=u(d,p)),a.transform=p;const{x:m,y}=this.projectionDelta;a.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?a.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:a.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in nT){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:S}=nT[b],C=p==="none"?d[b]:x(d[b],h);if(w){const N=w.length;for(let k=0;k<N;k++)a[w[k]]=C}else S?this.options.visualElement.renderState.vars[b]=C:a[b]=C}this.options.layoutId&&(a.pointerEvents=h===this?Xy(o?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(a=>a.currentAnimation?.stop()),this.root.nodes.forEach(CD),this.root.sharedNodes.clear()}}}function zq(n){n.updateLayout()}function Pq(n){const e=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&e&&n.hasListeners("didUpdate")){const{layoutBox:t,measuredBox:s}=n.layout,{animationType:r}=n.options,i=e.source!==n.layout.source;r==="size"?Pr(d=>{const p=i?e.measuredBox[d]:e.layoutBox[d],m=Es(p);p.min=t[d].min,p.max=p.min+m}):$L(r,e.layoutBox,t)&&Pr(d=>{const p=i?e.measuredBox[d]:e.layoutBox[d],m=Es(t[d]);p.max=p.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const a=$c();Df(a,t,e.layoutBox);const o=$c();i?Df(o,n.applyTransform(s,!0),e.measuredBox):Df(o,t,e.layoutBox);const u=!CL(a);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:p,layout:m}=d;if(p&&m){const y=On();b0(y,e.layoutBox,p.layoutBox);const b=On();b0(b,t,m.layoutBox),NL(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:t,snapshot:e,delta:o,layoutDelta:a,hasLayoutChanged:u,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:t}=n.options;t&&t()}n.options.transition=void 0}function Bq(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Vq(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Uq(n){n.clearSnapshot()}function CD(n){n.clearMeasurements()}function ND(n){n.isLayoutDirty=!1}function jq(n){const{visualElement:e}=n.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),n.resetTransform()}function kD(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function Wq(n){n.resolveTargetDelta()}function Gq(n){n.calcProjection()}function Hq(n){n.resetSkewAndRotation()}function qq(n){n.removeLeadSnapshot()}function ED(n,e,t){n.translate=en(e.translate,0,t),n.scale=en(e.scale,1,t),n.origin=e.origin,n.originPoint=e.originPoint}function $D(n,e,t,s){n.min=en(e.min,t.min,s),n.max=en(e.max,t.max,s)}function Kq(n,e,t,s){$D(n.x,e.x,t.x,s),$D(n.y,e.y,t.y,s)}function Xq(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const Yq={duration:.45,ease:[.4,0,.1,1]},ID=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),_D=ID("applewebkit/")&&!ID("chrome/")?Math.round:Wr;function AD(n){n.min=_D(n.min),n.max=_D(n.max)}function Jq(n){AD(n.x),AD(n.y)}function $L(n,e,t){return n==="position"||n==="preserve-aspect"&&!iq(SD(e),SD(t),.2)}function Zq(n){return n!==n.root&&n.scroll?.wasRoot}const Qq=EL({attachResizeListener:(n,e)=>Vf(n,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),dS={current:void 0},IL=EL({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!dS.current){const n=new Qq({});n.mount(window),n.setOptions({layoutScroll:!0}),dS.current=n}return dS.current},resetTransform:(n,e)=>{n.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),e8={pan:{Feature:wq},drag:{Feature:xq,ProjectionNode:IL,MeasureLayout:vL}};function RD(n,e,t){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",t==="Start");const r="onHover"+t,i=s[r];i&&Xt.postRender(()=>i(e,bp(e)))}class t8 extends zo{mount(){const{current:e}=this.node;e&&(this.unmount=T5(e,(t,s)=>(RD(this.node,s,"Start"),r=>RD(this.node,r,"End"))))}unmount(){}}class n8 extends zo{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=mp(Vf(this.node.current,"focus",()=>this.onFocus()),Vf(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function DD(n,e,t){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",t==="Start");const r="onTap"+(t==="End"?"":t),i=s[r];i&&Xt.postRender(()=>i(e,bp(e)))}class s8 extends zo{mount(){const{current:e}=this.node;e&&(this.unmount=E5(e,(t,s)=>(DD(this.node,s,"Start"),(r,{success:i})=>DD(this.node,r,i?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const cT=new WeakMap,fS=new WeakMap,r8=n=>{const e=cT.get(n.target);e&&e(n)},i8=n=>{n.forEach(r8)};function a8({root:n,...e}){const t=n||document;fS.has(t)||fS.set(t,{});const s=fS.get(t),r=JSON.stringify(e);return s[r]||(s[r]=new IntersectionObserver(i8,{root:n,...e})),s[r]}function o8(n,e,t){const s=a8(e);return cT.set(n,t),s.observe(n),()=>{cT.delete(n),s.unobserve(n)}}const l8={some:0,all:1};class u8 extends zo{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:s,amount:r="some",once:i}=e,a={root:t?t.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:l8[r]},o=u=>{const{isIntersecting:h}=u;if(this.isInView===h||(this.isInView=h,i&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:p}=this.node.getProps(),m=h?d:p;m&&m(u)};return o8(this.node.current,a,o)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(c8(e,t))&&this.startObserver()}unmount(){}}function c8({viewport:n={}},{viewport:e={}}={}){return t=>n[t]!==e[t]}const h8={inView:{Feature:u8},tap:{Feature:s8},focus:{Feature:n8},hover:{Feature:t8}},d8={layout:{ProjectionNode:IL,MeasureLayout:vL}},f8={...Q6,...h8,...e8,...d8},cc=m6(f8,$6);const p8=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),m8=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,s)=>s?s.toUpperCase():t.toLowerCase()),OD=n=>{const e=m8(n);return e.charAt(0).toUpperCase()+e.slice(1)},_L=(...n)=>n.filter((e,t,s)=>!!e&&e.trim()!==""&&s.indexOf(e)===t).join(" ").trim(),g8=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var y8={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const b8=ke.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:t=2,absoluteStrokeWidth:s,className:r="",children:i,iconNode:a,...o},u)=>ke.createElement("svg",{ref:u,...y8,width:e,height:e,stroke:n,strokeWidth:s?Number(t)*24/Number(e):t,className:_L("lucide",r),...!i&&!g8(o)&&{"aria-hidden":"true"},...o},[...a.map(([h,d])=>ke.createElement(h,d)),...Array.isArray(i)?i:[i]]));const Hi=(n,e)=>{const t=ke.forwardRef(({className:s,...r},i)=>ke.createElement(b8,{ref:i,iconNode:e,className:_L(`lucide-${p8(OD(n))}`,`lucide-${n}`,s),...r}));return t.displayName=OD(n),t};const x8=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],w8=Hi("activity",x8);const v8=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],S8=Hi("cpu",v8);const T8=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],FD=Hi("history",T8);const C8=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],N8=Hi("lock",C8);const k8=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],E8=Hi("log-out",k8);const $8=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],I8=Hi("search",$8);const _8=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],LD=Hi("trending-down",_8);const A8=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],MD=Hi("trending-up",A8);const R8=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],D8=Hi("triangle-alert",R8);const O8=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],zD=Hi("zap",O8);function ob(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t}function F8(n,e,t,s){function r(i){return i instanceof t?i:new t(function(a){a(i)})}return new(t||(t=Promise))(function(i,a){function o(d){try{h(s.next(d))}catch(p){a(p)}}function u(d){try{h(s.throw(d))}catch(p){a(p)}}function h(d){d.done?i(d.value):r(d.value).then(o,u)}h((s=s.apply(n,e||[])).next())})}const L8=n=>n?(...e)=>n(...e):(...e)=>fetch(...e);class t2 extends Error{constructor(e,t="FunctionsError",s){super(e),this.name=t,this.context=s}}class M8 extends t2{constructor(e){super("Failed to send a request to the Edge Function","FunctionsFetchError",e)}}class PD extends t2{constructor(e){super("Relay Error invoking the Edge Function","FunctionsRelayError",e)}}class BD extends t2{constructor(e){super("Edge Function returned a non-2xx status code","FunctionsHttpError",e)}}var hT;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(hT||(hT={}));class z8{constructor(e,{headers:t={},customFetch:s,region:r=hT.Any}={}){this.url=e,this.headers=t,this.region=r,this.fetch=L8(s)}setAuth(e){this.headers.Authorization=`Bearer ${e}`}invoke(e){return F8(this,arguments,void 0,function*(t,s={}){var r;let i,a;try{const{headers:o,method:u,body:h,signal:d,timeout:p}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${t}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(o&&!Object.prototype.hasOwnProperty.call(o,"Content-Type")||!o)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;p&&(a=new AbortController,i=setTimeout(()=>a.abort(),p),d?(w=a.signal,d.addEventListener("abort",()=>a.abort())):w=a.signal);const S=yield this.fetch(b.toString(),{method:u||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),o),body:x,signal:w}).catch(E=>{throw new M8(E)}),C=S.headers.get("x-relay-error");if(C&&C==="true")throw new PD(S);if(!S.ok)throw new BD(S);let N=((r=S.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),k;return N==="application/json"?k=yield S.json():N==="application/octet-stream"||N==="application/pdf"?k=yield S.blob():N==="text/event-stream"?k=S:N==="multipart/form-data"?k=yield S.formData():k=yield S.text(),{data:k,error:null,response:S}}catch(o){return{data:null,error:o,response:o instanceof BD||o instanceof PD?o.context:void 0}}finally{i&&clearTimeout(i)}})}}var P8=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},B8=class{constructor(n){var e,t;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(e=n.shouldThrowOnError)!==null&&e!==void 0?e:!1,this.signal=n.signal,this.isMaybeSingle=(t=n.isMaybeSingle)!==null&&t!==void 0?t:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,e){return this.headers=new Headers(this.headers),this.headers.set(n,e),this}then(n,e){var t=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let r=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async i=>{let a=null,o=null,u=null,h=i.status,d=i.statusText;if(i.ok){var p,m;if(t.method!=="HEAD"){var y;const S=await i.text();S===""||(t.headers.get("Accept")==="text/csv"||t.headers.get("Accept")&&(!((y=t.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?o=S:o=JSON.parse(S))}const x=(p=t.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),w=(m=i.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(u=parseInt(w[1])),t.isMaybeSingle&&t.method==="GET"&&Array.isArray(o)&&(o.length>1?(a={code:"PGRST116",details:`Results contain ${o.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},o=null,u=null,h=406,d="Not Acceptable"):o.length===1?o=o[0]:o=null)}else{var b;const x=await i.text();try{a=JSON.parse(x),Array.isArray(a)&&i.status===404&&(o=[],a=null,h=200,d="OK")}catch{i.status===404&&x===""?(h=204,d="No Content"):a={message:x}}if(a&&t.isMaybeSingle&&(!(a==null||(b=a.details)===null||b===void 0)&&b.includes("0 rows"))&&(a=null,h=200,d="OK"),a&&t.shouldThrowOnError)throw new P8(a)}return{error:a,data:o,count:u,status:h,statusText:d}});return this.shouldThrowOnError||(r=r.catch(i=>{var a;let o="";const u=i?.cause;if(u){var h,d,p,m;const b=(h=u?.message)!==null&&h!==void 0?h:"",x=(d=u?.code)!==null&&d!==void 0?d:"";o=`${(p=i?.name)!==null&&p!==void 0?p:"FetchError"}: ${i?.message}`,o+=`

Caused by: ${(m=u?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(o+=` (${x})`),u?.stack&&(o+=`
${u.stack}`)}else{var y;o=(y=i?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(a=i?.name)!==null&&a!==void 0?a:"FetchError"}: ${i?.message}`,details:o,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(n,e)}returns(){return this}overrideTypes(){return this}},V8=class extends B8{select(n){let e=!1;const t=(n??"*").split("").map(s=>/\s/.test(s)&&!e?"":(s==='"'&&(e=!e),s)).join("");return this.url.searchParams.set("select",t),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:e=!0,nullsFirst:t,foreignTable:s,referencedTable:r=s}={}){const i=r?`${r}.order`:"order",a=this.url.searchParams.get(i);return this.url.searchParams.set(i,`${a?`${a},`:""}${n}.${e?"asc":"desc"}${t===void 0?"":t?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:e,referencedTable:t=e}={}){const s=typeof t>"u"?"limit":`${t}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,e,{foreignTable:t,referencedTable:s=t}={}){const r=typeof s>"u"?"offset":`${s}.offset`,i=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(r,`${n}`),this.url.searchParams.set(i,`${e-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:e=!1,settings:t=!1,buffers:s=!1,wal:r=!1,format:i="text"}={}){var a;const o=[n?"analyze":null,e?"verbose":null,t?"settings":null,s?"buffers":null,r?"wal":null].filter(Boolean).join("|"),u=(a=this.headers.get("Accept"))!==null&&a!==void 0?a:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${i}; for="${u}"; options=${o};`),i==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const VD=new RegExp("[,()]");var xc=class extends V8{eq(n,e){return this.url.searchParams.append(n,`eq.${e}`),this}neq(n,e){return this.url.searchParams.append(n,`neq.${e}`),this}gt(n,e){return this.url.searchParams.append(n,`gt.${e}`),this}gte(n,e){return this.url.searchParams.append(n,`gte.${e}`),this}lt(n,e){return this.url.searchParams.append(n,`lt.${e}`),this}lte(n,e){return this.url.searchParams.append(n,`lte.${e}`),this}like(n,e){return this.url.searchParams.append(n,`like.${e}`),this}likeAllOf(n,e){return this.url.searchParams.append(n,`like(all).{${e.join(",")}}`),this}likeAnyOf(n,e){return this.url.searchParams.append(n,`like(any).{${e.join(",")}}`),this}ilike(n,e){return this.url.searchParams.append(n,`ilike.${e}`),this}ilikeAllOf(n,e){return this.url.searchParams.append(n,`ilike(all).{${e.join(",")}}`),this}ilikeAnyOf(n,e){return this.url.searchParams.append(n,`ilike(any).{${e.join(",")}}`),this}regexMatch(n,e){return this.url.searchParams.append(n,`match.${e}`),this}regexIMatch(n,e){return this.url.searchParams.append(n,`imatch.${e}`),this}is(n,e){return this.url.searchParams.append(n,`is.${e}`),this}isDistinct(n,e){return this.url.searchParams.append(n,`isdistinct.${e}`),this}in(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&VD.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${t})`),this}notIn(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&VD.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${t})`),this}contains(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cs.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cs.{${e.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(e)}`),this}containedBy(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cd.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cd.{${e.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(e)}`),this}rangeGt(n,e){return this.url.searchParams.append(n,`sr.${e}`),this}rangeGte(n,e){return this.url.searchParams.append(n,`nxl.${e}`),this}rangeLt(n,e){return this.url.searchParams.append(n,`sl.${e}`),this}rangeLte(n,e){return this.url.searchParams.append(n,`nxr.${e}`),this}rangeAdjacent(n,e){return this.url.searchParams.append(n,`adj.${e}`),this}overlaps(n,e){return typeof e=="string"?this.url.searchParams.append(n,`ov.${e}`):this.url.searchParams.append(n,`ov.{${e.join(",")}}`),this}textSearch(n,e,{config:t,type:s}={}){let r="";s==="plain"?r="pl":s==="phrase"?r="ph":s==="websearch"&&(r="w");const i=t===void 0?"":`(${t})`;return this.url.searchParams.append(n,`${r}fts${i}.${e}`),this}match(n){return Object.entries(n).forEach(([e,t])=>{this.url.searchParams.append(e,`eq.${t}`)}),this}not(n,e,t){return this.url.searchParams.append(n,`not.${e}.${t}`),this}or(n,{foreignTable:e,referencedTable:t=e}={}){const s=t?`${t}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,e,t){return this.url.searchParams.append(n,`${e}.${t}`),this}},U8=class{constructor(n,{headers:e={},schema:t,fetch:s}){this.url=n,this.headers=new Headers(e),this.schema=t,this.fetch=s}select(n,e){const{head:t=!1,count:s}=e??{},r=t?"HEAD":"GET";let i=!1;const a=(n??"*").split("").map(o=>/\s/.test(o)&&!i?"":(o==='"'&&(i=!i),o)).join("");return this.url.searchParams.set("select",a),s&&this.headers.append("Prefer",`count=${s}`),new xc({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:e,defaultToNull:t=!0}={}){var s;const r="POST";if(e&&this.headers.append("Prefer",`count=${e}`),t||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const i=n.reduce((a,o)=>a.concat(Object.keys(o)),[]);if(i.length>0){const a=[...new Set(i)].map(o=>`"${o}"`);this.url.searchParams.set("columns",a.join(","))}}return new xc({method:r,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:e,ignoreDuplicates:t=!1,count:s,defaultToNull:r=!0}={}){var i;const a="POST";if(this.headers.append("Prefer",`resolution=${t?"ignore":"merge"}-duplicates`),e!==void 0&&this.url.searchParams.set("on_conflict",e),s&&this.headers.append("Prefer",`count=${s}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const o=n.reduce((u,h)=>u.concat(Object.keys(h)),[]);if(o.length>0){const u=[...new Set(o)].map(h=>`"${h}"`);this.url.searchParams.set("columns",u.join(","))}}return new xc({method:a,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}update(n,{count:e}={}){var t;const s="PATCH";return e&&this.headers.append("Prefer",`count=${e}`),new xc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}delete({count:n}={}){var e;const t="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new xc({method:t,url:this.url,headers:this.headers,schema:this.schema,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}},j8=class AL{constructor(e,{headers:t={},schema:s,fetch:r}={}){this.url=e,this.headers=new Headers(t),this.schemaName=s,this.fetch=r}from(e){if(!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new U8(new URL(`${this.url}/${e}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(e){return new AL(this.url,{headers:this.headers,schema:e,fetch:this.fetch})}rpc(e,t={},{head:s=!1,get:r=!1,count:i}={}){var a;let o;const u=new URL(`${this.url}/rpc/${e}`);let h;s||r?(o=s?"HEAD":"GET",Object.entries(t).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{u.searchParams.append(p,m)})):(o="POST",h=t);const d=new Headers(this.headers);return i&&d.set("Prefer",`count=${i}`),new xc({method:o,url:u,headers:d,schema:this.schemaName,body:h,fetch:(a=this.fetch)!==null&&a!==void 0?a:fetch})}};class W8{constructor(){}static detectEnvironment(){var e;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((e=navigator.userAgent)===null||e===void 0)&&e.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const t=process.versions;if(t&&t.node){const s=t.node,r=parseInt(s.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const e=this.detectEnvironment();if(e.constructor)return e.constructor;let t=e.error||"WebSocket not supported in this environment.";throw e.workaround&&(t+=`

Suggested solution: ${e.workaround}`),new Error(t)}static createWebSocket(e,t){const s=this.getWebSocketConstructor();return new s(e,t)}static isWebSocketSupported(){try{const e=this.detectEnvironment();return e.type==="native"||e.type==="ws"}catch{return!1}}}const G8="2.89.0",H8=`realtime-js/${G8}`,RL="1.0.0",q8="2.0.0",UD=RL,dT=1e4,K8=1e3,X8=100;var po;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(po||(po={}));var Dn;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(Dn||(Dn={}));var li;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(li||(li={}));var fT;(function(n){n.websocket="websocket"})(fT||(fT={}));var Tl;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(Tl||(Tl={}));class Y8{constructor(e){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=e??[]}encode(e,t){if(e.event===this.BROADCAST_EVENT&&!(e.payload instanceof ArrayBuffer)&&typeof e.payload.event=="string")return t(this._binaryEncodeUserBroadcastPush(e));let s=[e.join_ref,e.ref,e.topic,e.event,e.payload];return t(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(e){var t;return this._isArrayBuffer((t=e.payload)===null||t===void 0?void 0:t.payload)?this._encodeBinaryUserBroadcastPush(e):this._encodeJsonUserBroadcastPush(e)}_encodeBinaryUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(e,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:{},a=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(e,this.JSON_ENCODING,a)}_encodeUserBroadcastPush(e,t,s){var r,i;const a=e.topic,o=(r=e.ref)!==null&&r!==void 0?r:"",u=(i=e.join_ref)!==null&&i!==void 0?i:"",h=e.payload.event,d=this.allowedMetadataKeys?this._pick(e.payload,this.allowedMetadataKeys):{},p=Object.keys(d).length===0?"":JSON.stringify(d);if(u.length>255)throw new Error(`joinRef length ${u.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`ref length ${o.length} exceeds maximum of 255`);if(a.length>255)throw new Error(`topic length ${a.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+u.length+o.length+a.length+h.length+p.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,u.length),b.setUint8(x++,o.length),b.setUint8(x++,a.length),b.setUint8(x++,h.length),b.setUint8(x++,p.length),b.setUint8(x++,t),Array.from(u,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(o,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(a,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(h,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(p,S=>b.setUint8(x++,S.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(e,t){if(this._isArrayBuffer(e)){let s=this._binaryDecode(e);return t(s)}if(typeof e=="string"){const s=JSON.parse(e),[r,i,a,o,u]=s;return t({join_ref:r,ref:i,topic:a,event:o,payload:u})}return t({})}_binaryDecode(e){const t=new DataView(e),s=t.getUint8(0),r=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(e,t,r)}_decodeUserBroadcast(e,t,s){const r=t.getUint8(1),i=t.getUint8(2),a=t.getUint8(3),o=t.getUint8(4);let u=this.HEADER_LENGTH+4;const h=s.decode(e.slice(u,u+r));u=u+r;const d=s.decode(e.slice(u,u+i));u=u+i;const p=s.decode(e.slice(u,u+a));u=u+a;const m=e.slice(u,e.byteLength),y=o===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return a>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(e){var t;return e instanceof ArrayBuffer||((t=e?.constructor)===null||t===void 0?void 0:t.name)==="ArrayBuffer"}_pick(e,t){return!e||typeof e!="object"?{}:Object.fromEntries(Object.entries(e).filter(([s])=>t.includes(s)))}}class DL{constructor(e,t){this.callback=e,this.timerCalc=t,this.timer=void 0,this.tries=0,this.callback=e,this.timerCalc=t}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Bt;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Bt||(Bt={}));const jD=(n,e,t={})=>{var s;const r=(s=t.skipTypes)!==null&&s!==void 0?s:[];return e?Object.keys(e).reduce((i,a)=>(i[a]=J8(a,n,e,r),i),{}):{}},J8=(n,e,t,s)=>{const r=e.find(o=>o.name===n),i=r?.type,a=t[n];return i&&!s.includes(i)?OL(i,a):pT(a)},OL=(n,e)=>{if(n.charAt(0)==="_"){const t=n.slice(1,n.length);return tK(e,t)}switch(n){case Bt.bool:return Z8(e);case Bt.float4:case Bt.float8:case Bt.int2:case Bt.int4:case Bt.int8:case Bt.numeric:case Bt.oid:return Q8(e);case Bt.json:case Bt.jsonb:return eK(e);case Bt.timestamp:return nK(e);case Bt.abstime:case Bt.date:case Bt.daterange:case Bt.int4range:case Bt.int8range:case Bt.money:case Bt.reltime:case Bt.text:case Bt.time:case Bt.timestamptz:case Bt.timetz:case Bt.tsrange:case Bt.tstzrange:return pT(e);default:return pT(e)}},pT=n=>n,Z8=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},Q8=n=>{if(typeof n=="string"){const e=parseFloat(n);if(!Number.isNaN(e))return e}return n},eK=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},tK=(n,e)=>{if(typeof n!="string")return n;const t=n.length-1,s=n[t];if(n[0]==="{"&&s==="}"){let i;const a=n.slice(1,t);try{i=JSON.parse("["+a+"]")}catch{i=a?a.split(","):[]}return i.map(o=>OL(e,o))}return n},nK=n=>typeof n=="string"?n.replace(" ","T"):n,FL=n=>{const e=new URL(n);return e.protocol=e.protocol.replace(/^ws/i,"http"),e.pathname=e.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),e.pathname===""||e.pathname==="/"?e.pathname="/api/broadcast":e.pathname=e.pathname+"/api/broadcast",e.href};class pS{constructor(e,t,s={},r=dT){this.channel=e,this.event=t,this.payload=s,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(e){this.timeout=e,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(e){this.payload=Object.assign(Object.assign({},this.payload),e)}receive(e,t){var s;return this._hasReceived(e)&&t((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:e,callback:t}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const e=t=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=t,this._matchReceive(t)};this.channel._on(this.refEvent,{},e),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(e,t){this.refEvent&&this.channel._trigger(this.refEvent,{status:e,response:t})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:e,response:t}){this.recHooks.filter(s=>s.status===e).forEach(s=>s.callback(t))}_hasReceived(e){return this.receivedResp&&this.receivedResp.status===e}}var WD;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(WD||(WD={}));class Of{constructor(e,t){this.channel=e,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=t?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},r=>{const{onJoin:i,onLeave:a,onSync:o}=this.caller;this.joinRef=this.channel._joinRef(),this.state=Of.syncState(this.state,r,i,a),this.pendingDiffs.forEach(u=>{this.state=Of.syncDiff(this.state,u,i,a)}),this.pendingDiffs=[],o()}),this.channel._on(s.diff,{},r=>{const{onJoin:i,onLeave:a,onSync:o}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=Of.syncDiff(this.state,r,i,a),o())}),this.onJoin((r,i,a)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:i,newPresences:a})}),this.onLeave((r,i,a)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:i,leftPresences:a})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(e,t,s,r){const i=this.cloneDeep(e),a=this.transformState(t),o={},u={};return this.map(i,(h,d)=>{a[h]||(u[h]=d)}),this.map(a,(h,d)=>{const p=i[h];if(p){const m=d.map(w=>w.presence_ref),y=p.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=p.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(o[h]=b),x.length>0&&(u[h]=x)}else o[h]=d}),this.syncDiff(i,{joins:o,leaves:u},s,r)}static syncDiff(e,t,s,r){const{joins:i,leaves:a}={joins:this.transformState(t.joins),leaves:this.transformState(t.leaves)};return s||(s=()=>{}),r||(r=()=>{}),this.map(i,(o,u)=>{var h;const d=(h=e[o])!==null&&h!==void 0?h:[];if(e[o]=this.cloneDeep(u),d.length>0){const p=e[o].map(y=>y.presence_ref),m=d.filter(y=>p.indexOf(y.presence_ref)<0);e[o].unshift(...m)}s(o,d,u)}),this.map(a,(o,u)=>{let h=e[o];if(!h)return;const d=u.map(p=>p.presence_ref);h=h.filter(p=>d.indexOf(p.presence_ref)<0),e[o]=h,r(o,h,u),h.length===0&&delete e[o]}),e}static map(e,t){return Object.getOwnPropertyNames(e).map(s=>t(s,e[s]))}static transformState(e){return e=this.cloneDeep(e),Object.getOwnPropertyNames(e).reduce((t,s)=>{const r=e[s];return"metas"in r?t[s]=r.metas.map(i=>(i.presence_ref=i.phx_ref,delete i.phx_ref,delete i.phx_ref_prev,i)):t[s]=r,t},{})}static cloneDeep(e){return JSON.parse(JSON.stringify(e))}onJoin(e){this.caller.onJoin=e}onLeave(e){this.caller.onLeave=e}onSync(e){this.caller.onSync=e}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var GD;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(GD||(GD={}));var Ff;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(Ff||(Ff={}));var pa;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(pa||(pa={}));class Ic{constructor(e,t={config:{}},s){var r,i;if(this.topic=e,this.params=t,this.socket=s,this.bindings={},this.state=Dn.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=e.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},t.config),this.timeout=this.socket.timeout,this.joinPush=new pS(this,li.join,this.params,this.timeout),this.rejoinTimer=new DL(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Dn.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(a=>a.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=Dn.closed,this.socket._remove(this)}),this._onError(a=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,a),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",a=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,a),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this._on(li.reply,{},(a,o)=>{this._trigger(this._replyEventName(o),a)}),this.presence=new Of(this),this.broadcastEndpointURL=FL(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((i=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||i===void 0)&&i.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(e,t=this.timeout){var s,r,i;if(this.socket.isConnected()||this.socket.connect(),this.state==Dn.closed){const{config:{broadcast:a,presence:o,private:u}}=this.params,h=(r=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&r!==void 0?r:[],d=!!this.bindings[Ff.PRESENCE]&&this.bindings[Ff.PRESENCE].length>0||((i=this.params.config.presence)===null||i===void 0?void 0:i.enabled)===!0,p={},m={broadcast:a,presence:Object.assign(Object.assign({},o),{enabled:d}),postgres_changes:h,private:u};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(y=>e?.(pa.CHANNEL_ERROR,y)),this._onClose(()=>e?.(pa.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){e?.(pa.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,S=[];for(let C=0;C<w;C++){const N=x[C],{filter:{event:k,schema:E,table:_,filter:R}}=N,O=y&&y[C];if(O&&O.event===k&&Ic.isFilterValueEqual(O.schema,E)&&Ic.isFilterValueEqual(O.table,_)&&Ic.isFilterValueEqual(O.filter,R))S.push(Object.assign(Object.assign({},N),{id:O.id}));else{this.unsubscribe(),this.state=Dn.errored,e?.(pa.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=S,e&&e(pa.SUBSCRIBED);return}}).receive("error",y=>{this.state=Dn.errored,e?.(pa.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{e?.(pa.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(e,t={}){return await this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)}async untrack(e={}){return await this.send({type:"presence",event:"untrack"},e)}on(e,t,s){return this.state===Dn.joined&&e===Ff.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(e,t,s)}async httpSend(e,t,s={}){var r;if(t==null)return Promise.reject("Payload is required for httpSend()");const i={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(i.Authorization=`Bearer ${this.socket.accessTokenValue}`);const a={method:"POST",headers:i,body:JSON.stringify({messages:[{topic:this.subTopic,event:e,payload:t,private:this.private}]})},o=await this._fetchWithTimeout(this.broadcastEndpointURL,a,(r=s.timeout)!==null&&r!==void 0?r:this.timeout);if(o.status===202)return{success:!0};let u=o.statusText;try{const h=await o.json();u=h.error||h.message||u}catch{}return Promise.reject(new Error(u))}async send(e,t={}){var s,r;if(!this._canPush()&&e.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:i,payload:a}=e,o={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(o.Authorization=`Bearer ${this.socket.accessTokenValue}`);const u={method:"POST",headers:o,body:JSON.stringify({messages:[{topic:this.subTopic,event:i,payload:a,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,u,(s=t.timeout)!==null&&s!==void 0?s:this.timeout);return await((r=h.body)===null||r===void 0?void 0:r.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(i=>{var a,o,u;const h=this._push(e.type,e,t.timeout||this.timeout);e.type==="broadcast"&&!(!((u=(o=(a=this.params)===null||a===void 0?void 0:a.config)===null||o===void 0?void 0:o.broadcast)===null||u===void 0)&&u.ack)&&i("ok"),h.receive("ok",()=>i("ok")),h.receive("error",()=>i("error")),h.receive("timeout",()=>i("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=Dn.leaving;const t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(li.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(r=>{s=new pS(this,li.leave,{},e),s.receive("ok",()=>{t(),r("ok")}).receive("timeout",()=>{t(),r("timed out")}).receive("error",()=>{r("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(e=>e.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=Dn.closed,this.bindings={}}async _fetchWithTimeout(e,t,s){const r=new AbortController,i=setTimeout(()=>r.abort(),s),a=await this.socket.fetch(e,Object.assign(Object.assign({},t),{signal:r.signal}));return clearTimeout(i),a}_push(e,t,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new pS(this,e,t,s);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(e){if(e.startTimeout(),this.pushBuffer.push(e),this.pushBuffer.length>X8){const t=this.pushBuffer.shift();t&&(t.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${t.event}`,t.payload))}}_onMessage(e,t,s){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,s){var r,i;const a=e.toLocaleLowerCase(),{close:o,error:u,leave:h,join:d}=li;if(s&&[o,u,h,d].indexOf(a)>=0&&s!==this._joinRef())return;let m=this._onMessage(a,t,s);if(t&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(a)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===a}).map(y=>y.callback(m,s)):(i=this.bindings[a])===null||i===void 0||i.filter(y=>{var b,x,w,S,C,N;if(["broadcast","presence","postgres_changes"].includes(a))if("id"in y){const k=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return k&&((x=t.ids)===null||x===void 0?void 0:x.includes(k))&&(E==="*"||E?.toLocaleLowerCase()===((w=t.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const k=(C=(S=y?.filter)===null||S===void 0?void 0:S.event)===null||C===void 0?void 0:C.toLocaleLowerCase();return k==="*"||k===((N=t?.event)===null||N===void 0?void 0:N.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===a}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:S,type:C,errors:N}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:S,eventType:C,new:{},old:{},errors:N}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===Dn.closed}_isJoined(){return this.state===Dn.joined}_isJoining(){return this.state===Dn.joining}_isLeaving(){return this.state===Dn.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,s){const r=e.toLocaleLowerCase(),i={type:r,filter:t,callback:s};return this.bindings[r]?this.bindings[r].push(i):this.bindings[r]=[i],this}_off(e,t){const s=e.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(r=>{var i;return!(((i=r.type)===null||i===void 0?void 0:i.toLocaleLowerCase())===s&&Ic.isEqual(r.filter,t))})),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const s in e)if(e[s]!==t[s])return!1;return!0}static isFilterValueEqual(e,t){return(e??void 0)===(t??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(li.close,{},e)}_onError(e){this._on(li.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=Dn.joining,this.joinPush.resend(e))}_getPayloadRecords(e){const t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=jD(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=jD(e.columns,e.old_record)),t}}const mS=()=>{},$y={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},sK=[1e3,2e3,5e3,1e4],rK=1e4,iK=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class aK{constructor(e,t){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=dT,this.transport=null,this.heartbeatIntervalMs=$y.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=mS,this.ref=0,this.reconnectTimer=null,this.vsn=UD,this.logger=mS,this.conn=null,this.sendBuffer=[],this.serializer=new Y8,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...i)=>r(...i):(...i)=>fetch(...i),!(!((s=t?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=t.params.apikey,this.endPoint=`${e}/${fT.websocket}`,this.httpEndpoint=FL(e),this._initializeOptions(t),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(t?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=W8.createWebSocket(this.endpointURL())}catch(e){this._setConnectionState("disconnected");const t=e.message;throw t.includes("Node.js")?new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${t}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(e,t){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(e?this.conn.close(e,t??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,s){this.logger(e,t,s)}connectionState(){switch(this.conn&&this.conn.readyState){case po.connecting:return Tl.Connecting;case po.open:return Tl.Open;case po.closing:return Tl.Closing;default:return Tl.Closed}}isConnected(){return this.connectionState()===Tl.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(e,t={config:{}}){const s=`realtime:${e}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new Ic(`realtime:${e}`,t,this);return this.channels.push(i),i}}push(e){const{topic:t,event:s,payload:r,ref:i}=e,a=()=>{this.encode(e,o=>{var u;(u=this.conn)===null||u===void 0||u.send(o)})};this.log("push",`${t} ${s} (${i})`,r),this.isConnected()?a():this.sendBuffer.push(a)}async setAuth(e=null){this._authPromise=this._performAuth(e);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var e;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(t){this.log("error","error in heartbeat callback",t)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(t){this.log("error","error in heartbeat callback",t)}this._wasManualDisconnect=!1,(e=this.conn)===null||e===void 0||e.close(K8,"heartbeat timeout"),setTimeout(()=>{var t;this.isConnected()||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout()},$y.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(t){this.log("error","error in heartbeat callback",t)}this._setAuthSafely("heartbeat")}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(s=>s.topic===e&&(s._isJoined()||s._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}_onConnMessage(e){this.decode(e.data,t=>{if(t.topic==="phoenix"&&t.event==="phx_reply")try{this.heartbeatCallback(t.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}t.ref&&t.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:r,payload:i,ref:a}=t,o=a?`(${a})`:"",u=i.status||"";this.log("receive",`${u} ${s} ${r} ${o}`.trim(),i),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(r,i,a)),this._triggerStateCallbacks("message",t)})}_clearTimer(e){var t;e==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):e==="reconnect"&&((t=this.reconnectTimer)===null||t===void 0||t.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e),this.conn.readyState===po.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===po.open||this.conn.readyState===po.connecting)try{this.conn.close()}catch(e){this.log("error","Error closing connection",e)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(e=>e.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(t=>{this.log("error","error waiting for auth on connect",t),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this._terminateWorker()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(e){var t;this._setConnectionState("disconnected"),this.log("transport","close",e),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout(),this._triggerStateCallbacks("close",e)}_onConnError(e){this._setConnectionState("disconnected"),this.log("transport",`${e}`),this._triggerChanError(),this._triggerStateCallbacks("error",e)}_triggerChanError(){this.channels.forEach(e=>e._trigger(li.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const s=e.match(/\?/)?"&":"?",r=new URLSearchParams(t);return`${e}${s}${r}`}_workerObjectUrl(e){let t;if(e)t=e;else{const s=new Blob([iK],{type:"application/javascript"});t=URL.createObjectURL(s)}return t}_setConnectionState(e,t=!1){this._connectionState=e,e==="connecting"?this._wasManualDisconnect=!1:e==="disconnecting"&&(this._wasManualDisconnect=t)}async _performAuth(e=null){let t,s=!1;if(e)t=e,s=!0;else if(this.accessToken)try{t=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),t=this.accessTokenValue}else t=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(r=>{const i={access_token:t,version:H8};t&&r.updateJoinPayload(i),r.joinedOnce&&r._isJoined()&&r._push(li.access_token,{access_token:t})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(e="general"){this._isManualToken()||this.setAuth().catch(t=>{this.log("error",`Error setting auth in ${e}`,t)})}_triggerStateCallbacks(e,t){try{this.stateChangeCallbacks[e].forEach(s=>{try{s(t)}catch(r){this.log("error",`error in ${e} callback`,r)}})}catch(s){this.log("error",`error triggering ${e} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new DL(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},$y.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(e){var t,s,r,i,a,o,u,h,d,p,m,y;switch(this.transport=(t=e?.transport)!==null&&t!==void 0?t:null,this.timeout=(s=e?.timeout)!==null&&s!==void 0?s:dT,this.heartbeatIntervalMs=(r=e?.heartbeatIntervalMs)!==null&&r!==void 0?r:$y.HEARTBEAT_INTERVAL,this.worker=(i=e?.worker)!==null&&i!==void 0?i:!1,this.accessToken=(a=e?.accessToken)!==null&&a!==void 0?a:null,this.heartbeatCallback=(o=e?.heartbeatCallback)!==null&&o!==void 0?o:mS,this.vsn=(u=e?.vsn)!==null&&u!==void 0?u:UD,e?.params&&(this.params=e.params),e?.logger&&(this.logger=e.logger),(e?.logLevel||e?.log_level)&&(this.logLevel=e.logLevel||e.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=e?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>sK[b-1]||rK),this.vsn){case RL:this.encode=(d=e?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(p=e?.decode)!==null&&p!==void 0?p:((b,x)=>x(JSON.parse(b)));break;case q8:this.encode=(m=e?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=e?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=e?.workerUrl}}}var Uf=class extends Error{constructor(n,e){super(n),this.name="IcebergError",this.status=e.status,this.icebergType=e.icebergType,this.icebergCode=e.icebergCode,this.details=e.details,this.isCommitStateUnknown=e.icebergType==="CommitStateUnknownException"||[500,502,504].includes(e.status)&&e.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function oK(n,e,t){const s=new URL(e,n);if(t)for(const[r,i]of Object.entries(t))i!==void 0&&s.searchParams.set(r,i);return s.toString()}async function lK(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function uK(n){const e=n.fetchImpl??globalThis.fetch;return{async request({method:t,path:s,query:r,body:i,headers:a}){const o=oK(n.baseUrl,s,r),u=await lK(n.auth),h=await e(o,{method:t,headers:{...i?{"Content-Type":"application/json"}:{},...u,...a},body:i?JSON.stringify(i):void 0}),d=await h.text(),p=(h.headers.get("content-type")||"").includes("application/json"),m=p&&d?JSON.parse(d):d;if(!h.ok){const y=p?m:void 0,b=y?.error;throw new Uf(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function Iy(n){return n.join("")}var cK=class{constructor(n,e=""){this.client=n,this.prefix=e}async listNamespaces(n){const e=n?{parent:Iy(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:e})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,e){const t={namespace:n.namespace,properties:e?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:t})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${Iy(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${Iy(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${Iy(n.namespace)}`}),!0}catch(e){if(e instanceof Uf&&e.status===404)return!1;throw e}}async createNamespaceIfNotExists(n,e){try{return await this.createNamespace(n,e)}catch(t){if(t instanceof Uf&&t.status===409)return;throw t}}};function hc(n){return n.join("")}var hK=class{constructor(n,e="",t){this.client=n,this.prefix=e,this.accessDelegation=t}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${hc(n.namespace)}/tables`})).data.identifiers}async createTable(n,e){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${hc(n.namespace)}/tables`,body:e,headers:t})).data.metadata}async updateTable(n,e){const t=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${hc(n.namespace)}/tables/${n.name}`,body:e});return{"metadata-location":t.data["metadata-location"],metadata:t.data.metadata}}async dropTable(n,e){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${hc(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(e?.purge??!1)}})}async loadTable(n){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${hc(n.namespace)}/tables/${n.name}`,headers:e})).data.metadata}async tableExists(n){const e={};this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${hc(n.namespace)}/tables/${n.name}`,headers:e}),!0}catch(t){if(t instanceof Uf&&t.status===404)return!1;throw t}}async createTableIfNotExists(n,e){try{return await this.createTable(n,e)}catch(t){if(t instanceof Uf&&t.status===409)return await this.loadTable({namespace:n.namespace,name:e.name});throw t}}},dK=class{constructor(n){let e="v1";n.catalogName&&(e+=`/${n.catalogName}`);const t=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=uK({baseUrl:t,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new cK(this.client,e),this.tableOps=new hK(this.client,e,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,e){return this.namespaceOps.createNamespace(n,e)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,e){return this.tableOps.createTable(n,e)}async updateTable(n,e){return this.tableOps.updateTable(n,e)}async dropTable(n,e){await this.tableOps.dropTable(n,e)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,e){return this.namespaceOps.createNamespaceIfNotExists(n,e)}async createTableIfNotExists(n,e){return this.tableOps.createTableIfNotExists(n,e)}},lb=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function Qt(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var fK=class extends lb{constructor(n,e,t){super(n),this.name="StorageApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},mT=class extends lb{constructor(n,e){super(n),this.name="StorageUnknownError",this.originalError=e}};const n2=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),pK=()=>Response,gT=n=>{if(Array.isArray(n))return n.map(t=>gT(t));if(typeof n=="function"||n!==Object(n))return n;const e={};return Object.entries(n).forEach(([t,s])=>{const r=t.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));e[r]=gT(s)}),e},mK=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},gK=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function jf(n){"@babel/helpers - typeof";return jf=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},jf(n)}function yK(n,e){if(jf(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(jf(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function bK(n){var e=yK(n,"string");return jf(e)=="symbol"?e:e+""}function xK(n,e,t){return(e=bK(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function HD(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function Ge(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?HD(Object(t),!0).forEach(function(s){xK(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):HD(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const gS=n=>{var e;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(e=n.error)===null||e===void 0?void 0:e.message)||JSON.stringify(n)},wK=async(n,e,t)=>{n instanceof await pK()&&!t?.noResolveJson?n.json().then(s=>{const r=n.status||500,i=s?.statusCode||r+"";e(new fK(gS(s),r,i))}).catch(s=>{e(new mT(gS(s),s))}):e(new mT(gS(n),n))},vK=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"||!s?r:(mK(s)?(r.headers=Ge({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,e?.duplex&&(r.duplex=e.duplex),Ge(Ge({},r),t))};async function xp(n,e,t,s,r,i){return new Promise((a,o)=>{n(t,vK(e,s,r,i)).then(u=>{if(!u.ok)throw u;return s?.noResolveJson?u:u.json()}).then(u=>a(u)).catch(u=>wK(u,o,s))})}async function Wf(n,e,t,s){return xp(n,"GET",e,t,s)}async function ai(n,e,t,s,r){return xp(n,"POST",e,s,r,t)}async function yT(n,e,t,s,r){return xp(n,"PUT",e,s,r,t)}async function SK(n,e,t,s){return xp(n,"HEAD",e,Ge(Ge({},t),{},{noResolveJson:!0}),s)}async function s2(n,e,t,s,r){return xp(n,"DELETE",e,s,r,t)}var TK=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e}then(n,e){return this.execute().then(n,e)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Qt(e))return{data:null,error:e};throw e}}};let LL;LL=Symbol.toStringTag;var CK=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e,this[LL]="BlobDownloadBuilder",this.promise=null}asStream(){return new TK(this.downloadFn,this.shouldThrowOnError)}then(n,e){return this.getPromise().then(n,e)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Qt(e))return{data:null,error:e};throw e}}};const NK={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},qD={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var kK=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1,this.url=n,this.headers=e,this.bucketId=t,this.fetch=n2(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,e,t,s){var r=this;try{let i;const a=Ge(Ge({},qD),s);let o=Ge(Ge({},r.headers),n==="POST"&&{"x-upsert":String(a.upsert)});const u=a.metadata;typeof Blob<"u"&&t instanceof Blob?(i=new FormData,i.append("cacheControl",a.cacheControl),u&&i.append("metadata",r.encodeMetadata(u)),i.append("",t)):typeof FormData<"u"&&t instanceof FormData?(i=t,i.has("cacheControl")||i.append("cacheControl",a.cacheControl),u&&!i.has("metadata")&&i.append("metadata",r.encodeMetadata(u))):(i=t,o["cache-control"]=`max-age=${a.cacheControl}`,o["content-type"]=a.contentType,u&&(o["x-metadata"]=r.toBase64(r.encodeMetadata(u))),(typeof ReadableStream<"u"&&i instanceof ReadableStream||i&&typeof i=="object"&&"pipe"in i&&typeof i.pipe=="function")&&!a.duplex&&(a.duplex="half")),s?.headers&&(o=Ge(Ge({},o),s.headers));const h=r._removeEmptyFolders(e),d=r._getFinalPath(h),p=await(n=="PUT"?yT:ai)(r.fetch,`${r.url}/object/${d}`,i,Ge({headers:o},a?.duplex?{duplex:a.duplex}:{}));return{data:{path:h,id:p.Id,fullPath:p.Key},error:null}}catch(i){if(r.shouldThrowOnError)throw i;if(Qt(i))return{data:null,error:i};throw i}}async upload(n,e,t){return this.uploadOrUpdate("POST",n,e,t)}async uploadToSignedUrl(n,e,t,s){var r=this;const i=r._removeEmptyFolders(n),a=r._getFinalPath(i),o=new URL(r.url+`/object/upload/sign/${a}`);o.searchParams.set("token",e);try{let u;const h=Ge({upsert:qD.upsert},s),d=Ge(Ge({},r.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&t instanceof Blob?(u=new FormData,u.append("cacheControl",h.cacheControl),u.append("",t)):typeof FormData<"u"&&t instanceof FormData?(u=t,u.append("cacheControl",h.cacheControl)):(u=t,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:i,fullPath:(await yT(r.fetch,o.toString(),u,{headers:d})).Key},error:null}}catch(u){if(r.shouldThrowOnError)throw u;if(Qt(u))return{data:null,error:u};throw u}}async createSignedUploadUrl(n,e){var t=this;try{let s=t._getFinalPath(n);const r=Ge({},t.headers);e?.upsert&&(r["x-upsert"]="true");const i=await ai(t.fetch,`${t.url}/object/upload/sign/${s}`,{},{headers:r}),a=new URL(t.url+i.url),o=a.searchParams.get("token");if(!o)throw new lb("No token returned by API");return{data:{signedUrl:a.toString(),path:n,token:o},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async update(n,e,t){return this.uploadOrUpdate("PUT",n,e,t)}async move(n,e,t){var s=this;try{return{data:await ai(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers}),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async copy(n,e,t){var s=this;try{return{data:{path:(await ai(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async createSignedUrl(n,e,t){var s=this;try{let r=s._getFinalPath(n),i=await ai(s.fetch,`${s.url}/object/sign/${r}`,Ge({expiresIn:e},t?.transform?{transform:t.transform}:{}),{headers:s.headers});const a=t?.download?`&download=${t.download===!0?"":t.download}`:"";return i={signedUrl:encodeURI(`${s.url}${i.signedURL}${a}`)},{data:i,error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async createSignedUrls(n,e,t){var s=this;try{const r=await ai(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:e,paths:n},{headers:s.headers}),i=t?.download?`&download=${t.download===!0?"":t.download}`:"";return{data:r.map(a=>Ge(Ge({},a),{},{signedUrl:a.signedURL?encodeURI(`${s.url}${a.signedURL}${i}`):null})),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}download(n,e){const t=typeof e?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(e?.transform||{}),r=s?`?${s}`:"",i=this._getFinalPath(n),a=()=>Wf(this.fetch,`${this.url}/${t}/${i}${r}`,{headers:this.headers,noResolveJson:!0});return new CK(a,this.shouldThrowOnError)}async info(n){var e=this;const t=e._getFinalPath(n);try{return{data:gT(await Wf(e.fetch,`${e.url}/object/info/${t}`,{headers:e.headers})),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async exists(n){var e=this;const t=e._getFinalPath(n);try{return await SK(e.fetch,`${e.url}/object/${t}`,{headers:e.headers}),{data:!0,error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Qt(s)&&s instanceof mT){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,e){const t=this._getFinalPath(n),s=[],r=e?.download?`download=${e.download===!0?"":e.download}`:"";r!==""&&s.push(r);const i=typeof e?.transform<"u"?"render/image":"object",a=this.transformOptsToQueryString(e?.transform||{});a!==""&&s.push(a);let o=s.join("&");return o!==""&&(o=`?${o}`),{data:{publicUrl:encodeURI(`${this.url}/${i}/public/${t}${o}`)}}}async remove(n){var e=this;try{return{data:await s2(e.fetch,`${e.url}/object/${e.bucketId}`,{prefixes:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async list(n,e,t){var s=this;try{const r=Ge(Ge(Ge({},NK),e),{},{prefix:n||""});return{data:await ai(s.fetch,`${s.url}/object/list/${s.bucketId}`,r,{headers:s.headers},t),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async listV2(n,e){var t=this;try{const s=Ge({},n);return{data:await ai(t.fetch,`${t.url}/object/list-v2/${t.bucketId}`,s,{headers:t.headers},e),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const e=[];return n.width&&e.push(`width=${n.width}`),n.height&&e.push(`height=${n.height}`),n.resize&&e.push(`resize=${n.resize}`),n.format&&e.push(`format=${n.format}`),n.quality&&e.push(`quality=${n.quality}`),e.join("&")}};const ML="2.89.0",zL={"X-Client-Info":`storage-js/${ML}`};var EK=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1;const r=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=Ge(Ge({},zL),e),this.fetch=n2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var e=this;try{const t=e.listBucketOptionsToQueryString(n);return{data:await Wf(e.fetch,`${e.url}/bucket${t}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await Wf(e.fetch,`${e.url}/bucket/${n}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async createBucket(n,e={public:!1}){var t=this;try{return{data:await ai(t.fetch,`${t.url}/bucket`,{id:n,name:n,type:e.type,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async updateBucket(n,e){var t=this;try{return{data:await yT(t.fetch,`${t.url}/bucket/${n}`,{id:n,name:n,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async emptyBucket(n){var e=this;try{return{data:await ai(e.fetch,`${e.url}/bucket/${n}/empty`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await s2(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}listBucketOptionsToQueryString(n){const e={};return n&&("limit"in n&&(e.limit=String(n.limit)),"offset"in n&&(e.offset=String(n.offset)),n.search&&(e.search=n.search),n.sortColumn&&(e.sortColumn=n.sortColumn),n.sortOrder&&(e.sortOrder=n.sortOrder)),Object.keys(e).length>0?"?"+new URLSearchParams(e).toString():""}},$K=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},zL),e),this.fetch=n2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await ai(e.fetch,`${e.url}/bucket`,{name:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async listBuckets(n){var e=this;try{const t=new URLSearchParams;n?.limit!==void 0&&t.set("limit",n.limit.toString()),n?.offset!==void 0&&t.set("offset",n.offset.toString()),n?.sortColumn&&t.set("sortColumn",n.sortColumn),n?.sortOrder&&t.set("sortOrder",n.sortOrder),n?.search&&t.set("search",n.search);const s=t.toString(),r=s?`${e.url}/bucket?${s}`:`${e.url}/bucket`;return{data:await Wf(e.fetch,r,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await s2(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}from(n){var e=this;if(!gK(n))throw new lb("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const t=new dK({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>e.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(t,{get(r,i){const a=r[i];return typeof a!="function"?a:async(...o)=>{try{return{data:await a.apply(r,o),error:null}}catch(u){if(s)throw u;return{data:null,error:u}}}}})}};const r2={"X-Client-Info":`storage-js/${ML}`,"Content-Type":"application/json"};var PL=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function pr(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var yS=class extends PL{constructor(n,e,t){super(n),this.name="StorageVectorsApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},IK=class extends PL{constructor(n,e){super(n),this.name="StorageVectorsUnknownError",this.originalError=e}};const i2=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),_K=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},KD=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),AK=async(n,e,t)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!t?.noResolveJson){const s=n.status||500,r=n;if(typeof r.json=="function")r.json().then(i=>{const a=i?.statusCode||i?.code||s+"";e(new yS(KD(i),s,a))}).catch(()=>{const i=s+"";e(new yS(r.statusText||`HTTP ${s} error`,s,i))});else{const i=s+"";e(new yS(r.statusText||`HTTP ${s} error`,s,i))}}else e(new IK(KD(n),n))},RK=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return s?(_K(s)?(r.headers=Ge({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,Ge(Ge({},r),t)):r};async function DK(n,e,t,s,r,i){return new Promise((a,o)=>{n(t,RK(e,s,r,i)).then(u=>{if(!u.ok)throw u;if(s?.noResolveJson)return u;const h=u.headers.get("content-type");return!h||!h.includes("application/json")?{}:u.json()}).then(u=>a(u)).catch(u=>AK(u,o,s))})}async function mr(n,e,t,s,r){return DK(n,"POST",e,s,r,t)}var OK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},r2),e),this.fetch=i2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/CreateIndex`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getIndex(n,e){var t=this;try{return{data:await mr(t.fetch,`${t.url}/GetIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(pr(s))return{data:null,error:s};throw s}}async listIndexes(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/ListIndexes`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteIndex(n,e){var t=this;try{return{data:await mr(t.fetch,`${t.url}/DeleteIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers})||{},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(pr(s))return{data:null,error:s};throw s}}},FK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},r2),e),this.fetch=i2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var e=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await mr(e.fetch,`${e.url}/PutVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getVectors(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/GetVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async listVectors(n){var e=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await mr(e.fetch,`${e.url}/ListVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async queryVectors(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/QueryVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteVectors(n){var e=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await mr(e.fetch,`${e.url}/DeleteVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}},LK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},r2),e),this.fetch=i2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/GetVectorBucket`,{vectorBucketName:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async listBuckets(n={}){var e=this;try{return{data:await mr(e.fetch,`${e.url}/ListVectorBuckets`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}},MK=class extends LK{constructor(n,e={}){super(n,e.headers||{},e.fetch)}from(n){return new zK(this.url,this.headers,n,this.fetch)}async createBucket(n){var e=()=>super.createBucket,t=this;return e().call(t,n)}async getBucket(n){var e=()=>super.getBucket,t=this;return e().call(t,n)}async listBuckets(n={}){var e=()=>super.listBuckets,t=this;return e().call(t,n)}async deleteBucket(n){var e=()=>super.deleteBucket,t=this;return e().call(t,n)}},zK=class extends OK{constructor(n,e,t,s){super(n,e,s),this.vectorBucketName=t}async createIndex(n){var e=()=>super.createIndex,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName}))}async listIndexes(n={}){var e=()=>super.listIndexes,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName}))}async getIndex(n){var e=()=>super.getIndex,t=this;return e().call(t,t.vectorBucketName,n)}async deleteIndex(n){var e=()=>super.deleteIndex,t=this;return e().call(t,t.vectorBucketName,n)}index(n){return new PK(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},PK=class extends FK{constructor(n,e,t,s,r){super(n,e,r),this.vectorBucketName=t,this.indexName=s}async putVectors(n){var e=()=>super.putVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async getVectors(n){var e=()=>super.getVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async listVectors(n={}){var e=()=>super.listVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async queryVectors(n){var e=()=>super.queryVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async deleteVectors(n){var e=()=>super.deleteVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}},BK=class extends EK{constructor(n,e={},t,s){super(n,e,t,s)}from(n){return new kK(this.url,this.headers,n,this.fetch)}get vectors(){return new MK(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new $K(this.url+"/iceberg",this.headers,this.fetch)}};const BL="2.89.0",wc=30*1e3,bT=3,bS=bT*wc,VK="http://localhost:9999",UK="supabase.auth.token",jK={"X-Client-Info":`gotrue-js/${BL}`},xT="X-Supabase-Api-Version",VL={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},WK=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,GK=600*1e3;class Gf extends Error{constructor(e,t,s){super(e),this.__isAuthError=!0,this.name="AuthError",this.status=t,this.code=s}}function Pe(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class HK extends Gf{constructor(e,t,s){super(e,t,s),this.name="AuthApiError",this.status=t,this.code=s}}function qK(n){return Pe(n)&&n.name==="AuthApiError"}class Cl extends Gf{constructor(e,t){super(e),this.name="AuthUnknownError",this.originalError=t}}class _a extends Gf{constructor(e,t,s,r){super(e,s,r),this.name=t,this.status=s}}class dr extends _a{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function KK(n){return Pe(n)&&n.name==="AuthSessionMissingError"}class dc extends _a{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class _y extends _a{constructor(e){super(e,"AuthInvalidCredentialsError",400,void 0)}}class Ay extends _a{constructor(e,t=null){super(e,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function XK(n){return Pe(n)&&n.name==="AuthImplicitGrantRedirectError"}class XD extends _a{constructor(e,t=null){super(e,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class YK extends _a{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class wT extends _a{constructor(e,t){super(e,"AuthRetryableFetchError",t,void 0)}}function xS(n){return Pe(n)&&n.name==="AuthRetryableFetchError"}class YD extends _a{constructor(e,t,s){super(e,"AuthWeakPasswordError",t,"weak_password"),this.reasons=s}}class vT extends _a{constructor(e){super(e,"AuthInvalidJwtError",400,"invalid_jwt")}}const x0="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),JD=` 	
\r=`.split(""),JK=(()=>{const n=new Array(128);for(let e=0;e<n.length;e+=1)n[e]=-1;for(let e=0;e<JD.length;e+=1)n[JD[e].charCodeAt(0)]=-2;for(let e=0;e<x0.length;e+=1)n[x0[e].charCodeAt(0)]=e;return n})();function ZD(n,e,t){if(n!==null)for(e.queue=e.queue<<8|n,e.queuedBits+=8;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(x0[s]),e.queuedBits-=6}else if(e.queuedBits>0)for(e.queue=e.queue<<6-e.queuedBits,e.queuedBits=6;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(x0[s]),e.queuedBits-=6}}function UL(n,e,t){const s=JK[n];if(s>-1)for(e.queue=e.queue<<6|s,e.queuedBits+=6;e.queuedBits>=8;)t(e.queue>>e.queuedBits-8&255),e.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function QD(n){const e=[],t=a=>{e.push(String.fromCodePoint(a))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=a=>{e7(a,s,t)};for(let a=0;a<n.length;a+=1)UL(n.charCodeAt(a),r,i);return e.join("")}function ZK(n,e){if(n<=127){e(n);return}else if(n<=2047){e(192|n>>6),e(128|n&63);return}else if(n<=65535){e(224|n>>12),e(128|n>>6&63),e(128|n&63);return}else if(n<=1114111){e(240|n>>18),e(128|n>>12&63),e(128|n>>6&63),e(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function QK(n,e){for(let t=0;t<n.length;t+=1){let s=n.charCodeAt(t);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(t+1)-56320&65535|r)+65536,t+=1}ZK(s,e)}}function e7(n,e,t){if(e.utf8seq===0){if(n<=127){t(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){e.utf8seq=s;break}if(e.utf8seq===2)e.codepoint=n&31;else if(e.utf8seq===3)e.codepoint=n&15;else if(e.utf8seq===4)e.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");e.utf8seq-=1}else if(e.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");e.codepoint=e.codepoint<<6|n&63,e.utf8seq-=1,e.utf8seq===0&&t(e.codepoint)}}function Ac(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};for(let r=0;r<n.length;r+=1)UL(n.charCodeAt(r),t,s);return new Uint8Array(e)}function t7(n){const e=[];return QK(n,t=>e.push(t)),new Uint8Array(e)}function Rl(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};return n.forEach(r=>ZD(r,t,s)),ZD(null,t,s),e.join("")}function n7(n){return Math.round(Date.now()/1e3)+n}function s7(){return Symbol("auth-callback")}const ls=()=>typeof window<"u"&&typeof document<"u",ml={tested:!1,writable:!1},jL=()=>{if(!ls())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(ml.tested)return ml.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),ml.tested=!0,ml.writable=!0}catch{ml.tested=!0,ml.writable=!1}return ml.writable};function r7(n){const e={},t=new URL(n);if(t.hash&&t.hash[0]==="#")try{new URLSearchParams(t.hash.substring(1)).forEach((r,i)=>{e[i]=r})}catch{}return t.searchParams.forEach((s,r)=>{e[r]=s}),e}const WL=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),i7=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",vc=async(n,e,t)=>{await n.setItem(e,JSON.stringify(t))},gl=async(n,e)=>{const t=await n.getItem(e);if(!t)return null;try{return JSON.parse(t)}catch{return t}},os=async(n,e)=>{await n.removeItem(e)};class ub{constructor(){this.promise=new ub.promiseConstructor((e,t)=>{this.resolve=e,this.reject=t})}}ub.promiseConstructor=Promise;function wS(n){const e=n.split(".");if(e.length!==3)throw new vT("Invalid JWT structure");for(let s=0;s<e.length;s++)if(!WK.test(e[s]))throw new vT("JWT not in base64url format");return{header:JSON.parse(QD(e[0])),payload:JSON.parse(QD(e[1])),signature:Ac(e[2]),raw:{header:e[0],payload:e[1]}}}async function a7(n){return await new Promise(e=>{setTimeout(()=>e(null),n)})}function o7(n,e){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const a=await n(i);if(!e(i,null,a)){s(a);return}}catch(a){if(!e(i,a)){r(a);return}}})()})}function l7(n){return("0"+n.toString(16)).substr(-2)}function u7(){const e=new Uint32Array(56);if(typeof crypto>"u"){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=t.length;let r="";for(let i=0;i<56;i++)r+=t.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(e),Array.from(e,l7).join("")}async function c7(n){const t=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",t),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function h7(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const t=await c7(n);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function fc(n,e,t=!1){const s=u7();let r=s;t&&(r+="/PASSWORD_RECOVERY"),await vc(n,`${e}-code-verifier`,r);const i=await h7(s);return[i,s===i?"plain":"s256"]}const d7=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function f7(n){const e=n.headers.get(xT);if(!e||!e.match(d7))return null;try{return new Date(`${e}T00:00:00.0Z`)}catch{return null}}function p7(n){if(!n)throw new Error("Missing exp claim");const e=Math.floor(Date.now()/1e3);if(n<=e)throw new Error("JWT has expired")}function m7(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const g7=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function pc(n){if(!g7.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function vS(){const n={};return new Proxy(n,{get:(e,t)=>{if(t==="__isUserNotAvailableProxy")return!0;if(typeof t=="symbol"){const s=t.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`)},set:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function y7(n,e){return new Proxy(n,{get:(t,s,r)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const i=s.toString();if(i==="Symbol(Symbol.toPrimitive)"||i==="Symbol(Symbol.toStringTag)"||i==="Symbol(util.inspect.custom)"||i==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(t,s,r)}return!e.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),e.value=!0),Reflect.get(t,s,r)}})}function eO(n){return JSON.parse(JSON.stringify(n))}const wl=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),b7=[502,503,504];async function tO(n){var e;if(!i7(n))throw new wT(wl(n),0);if(b7.includes(n.status))throw new wT(wl(n),n.status);let t;try{t=await n.json()}catch(i){throw new Cl(wl(i),i)}let s;const r=f7(n);if(r&&r.getTime()>=VL["2024-01-01"].timestamp&&typeof t=="object"&&t&&typeof t.code=="string"?s=t.code:typeof t=="object"&&t&&typeof t.error_code=="string"&&(s=t.error_code),s){if(s==="weak_password")throw new YD(wl(t),n.status,((e=t.weak_password)===null||e===void 0?void 0:e.reasons)||[]);if(s==="session_not_found")throw new dr}else if(typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((i,a)=>i&&typeof a=="string",!0))throw new YD(wl(t),n.status,t.weak_password.reasons);throw new HK(wl(t),n.status||500,s)}const x7=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},e?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),t))};async function We(n,e,t,s){var r;const i=Object.assign({},s?.headers);i[xT]||(i[xT]=VL["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const a=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(a.redirect_to=s.redirectTo);const o=Object.keys(a).length?"?"+new URLSearchParams(a).toString():"",u=await w7(n,e,t+o,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(u):{data:Object.assign({},u),error:null}}async function w7(n,e,t,s,r,i){const a=x7(e,s,r,i);let o;try{o=await n(t,Object.assign({},a))}catch(u){throw console.error(u),new wT(wl(u),0)}if(o.ok||await tO(o),s?.noResolveJson)return o;try{return await o.json()}catch(u){await tO(u)}}function si(n){var e;let t=null;T7(n)&&(t=Object.assign({},n),n.expires_at||(t.expires_at=n7(n.expires_in)));const s=(e=n.user)!==null&&e!==void 0?e:n;return{data:{session:t,user:s},error:null}}function nO(n){const e=si(n);return!e.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((t,s)=>t&&typeof s=="string",!0)&&(e.data.weak_password=n.weak_password),e}function go(n){var e;return{data:{user:(e=n.user)!==null&&e!==void 0?e:n},error:null}}function v7(n){return{data:n,error:null}}function S7(n){const{action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i}=n,a=ob(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),o={action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i},u=Object.assign({},a);return{data:{properties:o,user:u},error:null}}function sO(n){return n}function T7(n){return n.access_token&&n.refresh_token&&n.expires_in}const SS=["global","local","others"];class C7{constructor({url:e="",headers:t={},fetch:s}){this.url=e,this.headers=t,this.fetch=WL(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(e,t=SS[0]){if(SS.indexOf(t)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${SS.join(", ")}`);try{return await We(this.fetch,"POST",`${this.url}/logout?scope=${t}`,{headers:this.headers,jwt:e,noResolveJson:!0}),{data:null,error:null}}catch(s){if(Pe(s))return{data:null,error:s};throw s}}async inviteUserByEmail(e,t={}){try{return await We(this.fetch,"POST",`${this.url}/invite`,{body:{email:e,data:t.data},headers:this.headers,redirectTo:t.redirectTo,xform:go})}catch(s){if(Pe(s))return{data:{user:null},error:s};throw s}}async generateLink(e){try{const{options:t}=e,s=ob(e,["options"]),r=Object.assign(Object.assign({},s),t);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await We(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:S7,redirectTo:t?.redirectTo})}catch(t){if(Pe(t))return{data:{properties:null,user:null},error:t};throw t}}async createUser(e){try{return await We(this.fetch,"POST",`${this.url}/admin/users`,{body:e,headers:this.headers,xform:go})}catch(t){if(Pe(t))return{data:{user:null},error:t};throw t}}async listUsers(e){var t,s,r,i,a,o,u;try{const h={nextPage:null,lastPage:0,total:0},d=await We(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:sO});if(d.error)throw d.error;const p=await d.json(),m=(a=d.headers.get("x-total-count"))!==null&&a!==void 0?a:0,y=(u=(o=d.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&u!==void 0?u:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Pe(h))return{data:{users:[]},error:h};throw h}}async getUserById(e){pc(e);try{return await We(this.fetch,"GET",`${this.url}/admin/users/${e}`,{headers:this.headers,xform:go})}catch(t){if(Pe(t))return{data:{user:null},error:t};throw t}}async updateUserById(e,t){pc(e);try{return await We(this.fetch,"PUT",`${this.url}/admin/users/${e}`,{body:t,headers:this.headers,xform:go})}catch(s){if(Pe(s))return{data:{user:null},error:s};throw s}}async deleteUser(e,t=!1){pc(e);try{return await We(this.fetch,"DELETE",`${this.url}/admin/users/${e}`,{headers:this.headers,body:{should_soft_delete:t},xform:go})}catch(s){if(Pe(s))return{data:{user:null},error:s};throw s}}async _listFactors(e){pc(e.userId);try{const{data:t,error:s}=await We(this.fetch,"GET",`${this.url}/admin/users/${e.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:t,error:s}}catch(t){if(Pe(t))return{data:null,error:t};throw t}}async _deleteFactor(e){pc(e.userId),pc(e.id);try{return{data:await We(this.fetch,"DELETE",`${this.url}/admin/users/${e.userId}/factors/${e.id}`,{headers:this.headers}),error:null}}catch(t){if(Pe(t))return{data:null,error:t};throw t}}async _listOAuthClients(e){var t,s,r,i,a,o,u;try{const h={nextPage:null,lastPage:0,total:0},d=await We(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:sO});if(d.error)throw d.error;const p=await d.json(),m=(a=d.headers.get("x-total-count"))!==null&&a!==void 0?a:0,y=(u=(o=d.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&u!==void 0?u:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Pe(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(e){try{return await We(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:e,headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Pe(t))return{data:null,error:t};throw t}}async _getOAuthClient(e){try{return await We(this.fetch,"GET",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Pe(t))return{data:null,error:t};throw t}}async _updateOAuthClient(e,t){try{return await We(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${e}`,{body:t,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(Pe(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(e){try{return await We(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(t){if(Pe(t))return{data:null,error:t};throw t}}async _regenerateOAuthClientSecret(e){try{return await We(this.fetch,"POST",`${this.url}/admin/oauth/clients/${e}/regenerate_secret`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Pe(t))return{data:null,error:t};throw t}}}function rO(n={}){return{getItem:e=>n[e]||null,setItem:(e,t)=>{n[e]=t},removeItem:e=>{delete n[e]}}}const mc={debug:!!(globalThis&&jL()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class GL extends Error{constructor(e){super(e),this.isAcquireTimeout=!0}}class N7 extends GL{}async function k7(n,e,t){mc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,e);const s=new globalThis.AbortController;return e>0&&setTimeout(()=>{s.abort(),mc.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},e),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,e===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){mc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await t()}finally{mc.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(e===0)throw mc.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new N7(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(mc.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await t()}}))}function E7(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function HL(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function $7(n){return parseInt(n,16)}function I7(n){const e=new TextEncoder().encode(n);return"0x"+Array.from(e,s=>s.toString(16).padStart(2,"0")).join("")}function _7(n){var e;const{chainId:t,domain:s,expirationTime:r,issuedAt:i=new Date,nonce:a,notBefore:o,requestId:u,resources:h,scheme:d,uri:p,version:m}=n;{if(!Number.isInteger(t))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${t}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(a&&a.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${a}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((e=n.statement)===null||e===void 0)&&e.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=HL(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let S=`URI: ${p}
Version: ${m}
Chain ID: ${t}${a?`
Nonce: ${a}`:""}
Issued At: ${i.toISOString()}`;if(r&&(S+=`
Expiration Time: ${r.toISOString()}`),o&&(S+=`
Not Before: ${o.toISOString()}`),u&&(S+=`
Request ID: ${u}`),h){let C=`
Resources:`;for(const N of h){if(!N||typeof N!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${N}`);C+=`
- ${N}`}S+=C}return`${w}
${S}`}class Cn extends Error{constructor({message:e,code:t,cause:s,name:r}){var i;super(e,{cause:s}),this.__isWebAuthnError=!0,this.name=(i=r??(s instanceof Error?s.name:void 0))!==null&&i!==void 0?i:"Unknown Error",this.code=t}}class w0 extends Cn{constructor(e,t){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:t,message:e}),this.name="WebAuthnUnknownError",this.originalError=t}}function A7({error:n,options:e}){var t,s,r;const{publicKey:i}=e;if(!i)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new Cn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((t=i.authenticatorSelection)===null||t===void 0?void 0:t.requireResidentKey)===!0)return new Cn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(e.mediation==="conditional"&&((s=i.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new Cn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((r=i.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new Cn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new Cn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new Cn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return i.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new Cn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new Cn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const a=window.location.hostname;if(qL(a)){if(i.rp.id!==a)return new Cn({message:`The RP ID "${i.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new Cn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new Cn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new Cn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new Cn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function R7({error:n,options:e}){const{publicKey:t}=e;if(!t)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new Cn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new Cn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(qL(s)){if(t.rpId!==s)return new Cn({message:`The RP ID "${t.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new Cn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new Cn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new Cn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class D7{createNewAbortSignal(){if(this.controller){const t=new Error("Cancelling existing WebAuthn API call for new one");t.name="AbortError",this.controller.abort(t)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}}const O7=new D7;function F7(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:e,user:t,excludeCredentials:s}=n,r=ob(n,["challenge","user","excludeCredentials"]),i=Ac(e).buffer,a=Object.assign(Object.assign({},t),{id:Ac(t.id).buffer}),o=Object.assign(Object.assign({},r),{challenge:i,user:a});if(s&&s.length>0){o.excludeCredentials=new Array(s.length);for(let u=0;u<s.length;u++){const h=s[u];o.excludeCredentials[u]=Object.assign(Object.assign({},h),{id:Ac(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return o}function L7(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:e,allowCredentials:t}=n,s=ob(n,["challenge","allowCredentials"]),r=Ac(e).buffer,i=Object.assign(Object.assign({},s),{challenge:r});if(t&&t.length>0){i.allowCredentials=new Array(t.length);for(let a=0;a<t.length;a++){const o=t[a];i.allowCredentials[a]=Object.assign(Object.assign({},o),{id:Ac(o.id).buffer,type:o.type||"public-key",transports:o.transports})}}return i}function M7(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n;return{id:n.id,rawId:n.id,response:{attestationObject:Rl(new Uint8Array(n.response.attestationObject)),clientDataJSON:Rl(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function z7(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n,s=n.getClientExtensionResults(),r=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:Rl(new Uint8Array(r.authenticatorData)),clientDataJSON:Rl(new Uint8Array(r.clientDataJSON)),signature:Rl(new Uint8Array(r.signature)),userHandle:r.userHandle?Rl(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function qL(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function iO(){var n,e;return!!(ls()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((e=navigator?.credentials)===null||e===void 0?void 0:e.get)=="function")}async function P7(n){try{const e=await navigator.credentials.create(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new w0("Browser returned unexpected credential type",e)}:{data:null,error:new w0("Empty credential response",e)}}catch(e){return{data:null,error:A7({error:e,options:n})}}}async function B7(n){try{const e=await navigator.credentials.get(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new w0("Browser returned unexpected credential type",e)}:{data:null,error:new w0("Empty credential response",e)}}catch(e){return{data:null,error:R7({error:e,options:n})}}}const V7={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},U7={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function v0(...n){const e=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),t=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),s={};for(const r of n)if(r)for(const i in r){const a=r[i];if(a!==void 0)if(Array.isArray(a))s[i]=a;else if(t(a))s[i]=a;else if(e(a)){const o=s[i];e(o)?s[i]=v0(o,a):s[i]=v0(a)}else s[i]=a}return s}function j7(n,e){return v0(V7,n,e||{})}function W7(n,e){return v0(U7,n,e||{})}class G7{constructor(e){this.client=e,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(e){return this.client.mfa.enroll(Object.assign(Object.assign({},e),{factorType:"webauthn"}))}async _challenge({factorId:e,webauthn:t,friendlyName:s,signal:r},i){try{const{data:a,error:o}=await this.client.mfa.challenge({factorId:e,webauthn:t});if(!a)return{data:null,error:o};const u=r??O7.createNewAbortSignal();if(a.webauthn.type==="create"){const{user:h}=a.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(a.webauthn.type){case"create":{const h=j7(a.webauthn.credential_options.publicKey,i?.create),{data:d,error:p}=await P7({publicKey:h,signal:u});return d?{data:{factorId:e,challengeId:a.id,webauthn:{type:a.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}case"request":{const h=W7(a.webauthn.credential_options.publicKey,i?.request),{data:d,error:p}=await B7(Object.assign(Object.assign({},a.webauthn.credential_options),{publicKey:h,signal:u}));return d?{data:{factorId:e,challengeId:a.id,webauthn:{type:a.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}}}catch(a){return Pe(a)?{data:null,error:a}:{data:null,error:new Cl("Unexpected error in challenge",a)}}}async _verify({challengeId:e,factorId:t,webauthn:s}){return this.client.mfa.verify({factorId:t,challengeId:e,webauthn:s})}async _authenticate({factorId:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!t)return{data:null,error:new Gf("rpId is required for WebAuthn authentication")};try{if(!iO())return{data:null,error:new Cl("Browser does not support WebAuthn",null)};const{data:a,error:o}=await this.challenge({factorId:e,webauthn:{rpId:t,rpOrigins:s},signal:r},{request:i});if(!a)return{data:null,error:o};const{webauthn:u}=a;return this._verify({factorId:e,challengeId:a.challengeId,webauthn:{type:u.type,rpId:t,rpOrigins:s,credential_response:u.credential_response}})}catch(a){return Pe(a)?{data:null,error:a}:{data:null,error:new Cl("Unexpected error in authenticate",a)}}}async _register({friendlyName:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!t)return{data:null,error:new Gf("rpId is required for WebAuthn registration")};try{if(!iO())return{data:null,error:new Cl("Browser does not support WebAuthn",null)};const{data:a,error:o}=await this._enroll({friendlyName:e});if(!a)return await this.client.mfa.listFactors().then(d=>{var p;return(p=d.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===e&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:o};const{data:u,error:h}=await this._challenge({factorId:a.id,friendlyName:a.friendly_name,webauthn:{rpId:t,rpOrigins:s},signal:r},{create:i});return u?this._verify({factorId:a.id,challengeId:u.challengeId,webauthn:{rpId:t,rpOrigins:s,type:u.webauthn.type,credential_response:u.webauthn.credential_response}}):{data:null,error:h}}catch(a){return Pe(a)?{data:null,error:a}:{data:null,error:new Cl("Unexpected error in register",a)}}}}E7();const H7={url:VK,storageKey:UK,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:jK,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function aO(n,e,t){return await t()}const gc={};class Hf{get jwks(){var e,t;return(t=(e=gc[this.storageKey])===null||e===void 0?void 0:e.jwks)!==null&&t!==void 0?t:{keys:[]}}set jwks(e){gc[this.storageKey]=Object.assign(Object.assign({},gc[this.storageKey]),{jwks:e})}get jwks_cached_at(){var e,t;return(t=(e=gc[this.storageKey])===null||e===void 0?void 0:e.cachedAt)!==null&&t!==void 0?t:Number.MIN_SAFE_INTEGER}set jwks_cached_at(e){gc[this.storageKey]=Object.assign(Object.assign({},gc[this.storageKey]),{cachedAt:e})}constructor(e){var t,s,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const i=Object.assign(Object.assign({},H7),e);if(this.storageKey=i.storageKey,this.instanceID=(t=Hf.nextInstanceID[this.storageKey])!==null&&t!==void 0?t:0,Hf.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!i.debug,typeof i.debug=="function"&&(this.logger=i.debug),this.instanceID>0&&ls()){const a=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(a),this.logDebugMessages&&console.trace(a)}if(this.persistSession=i.persistSession,this.autoRefreshToken=i.autoRefreshToken,this.admin=new C7({url:i.url,headers:i.headers,fetch:i.fetch}),this.url=i.url,this.headers=i.headers,this.fetch=WL(i.fetch),this.lock=i.lock||aO,this.detectSessionInUrl=i.detectSessionInUrl,this.flowType=i.flowType,this.hasCustomAuthorizationHeader=i.hasCustomAuthorizationHeader,this.throwOnError=i.throwOnError,i.lock?this.lock=i.lock:this.persistSession&&ls()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=k7:this.lock=aO,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new G7(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(i.storage?this.storage=i.storage:jL()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=rO(this.memoryStorage)),i.userStorage&&(this.userStorage=i.userStorage)):(this.memoryStorage={},this.storage=rO(this.memoryStorage)),ls()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(a){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",a)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async a=>{this._debug("received broadcast notification from other tab or client",a),await this._notifyAllSubscribers(a.data.event,a.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(e){if(this.throwOnError&&e&&e.error)throw e.error;return e}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${BL}) ${new Date().toISOString()}`}_debug(...e){return this.logDebugMessages&&this.logger(this._logPrefix(),...e),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var e;try{let t={},s="none";if(ls()&&(t=r7(window.location.href),this._isImplicitGrantCallback(t)?s="implicit":await this._isPKCECallback(t)&&(s="pkce")),ls()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(t,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),XK(i)){const u=(e=i.details)===null||e===void 0?void 0:e.code;if(u==="identity_already_exists"||u==="identity_not_found"||u==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:a,redirectType:o}=r;return this._debug("#_initialize()","detected session in URL",a,"redirect type",o),await this._saveSession(a),setTimeout(async()=>{o==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",a):await this._notifyAllSubscribers("SIGNED_IN",a)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(t){return Pe(t)?this._returnResult({error:t}):this._returnResult({error:new Cl("Unexpected error during initialization",t)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(e){var t,s,r;try{const i=await We(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(t=e?.options)===null||t===void 0?void 0:t.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=e?.options)===null||r===void 0?void 0:r.captchaToken}},xform:si}),{data:a,error:o}=i;if(o||!a)return this._returnResult({data:{user:null,session:null},error:o});const u=a.session,h=a.user;return a.session&&(await this._saveSession(a.session),await this._notifyAllSubscribers("SIGNED_IN",u)),this._returnResult({data:{user:h,session:u},error:null})}catch(i){if(Pe(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signUp(e){var t,s,r;try{let i;if("email"in e){const{email:d,password:p,options:m}=e;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await fc(this.storage,this.storageKey)),i=await We(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:p,data:(t=m?.data)!==null&&t!==void 0?t:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:si})}else if("phone"in e){const{phone:d,password:p,options:m}=e;i=await We(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:p,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:si})}else throw new _y("You must provide either an email or phone number and a password");const{data:a,error:o}=i;if(o||!a)return await os(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:o});const u=a.session,h=a.user;return a.session&&(await this._saveSession(a.session),await this._notifyAllSubscribers("SIGNED_IN",u)),this._returnResult({data:{user:h,session:u},error:null})}catch(i){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signInWithPassword(e){try{let t;if("email"in e){const{email:i,password:a,options:o}=e;t=await We(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:a,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:nO})}else if("phone"in e){const{phone:i,password:a,options:o}=e;t=await We(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:a,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:nO})}else throw new _y("You must provide either an email or phone number and a password");const{data:s,error:r}=t;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!s||!s.session||!s.user){const i=new dc;return this._returnResult({data:{user:null,session:null},error:i})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(t){if(Pe(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOAuth(e){var t,s,r,i;return await this._handleProviderSignIn(e.provider,{redirectTo:(t=e.options)===null||t===void 0?void 0:t.redirectTo,scopes:(s=e.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=e.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=e.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(e){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(e))}async signInWithWeb3(e){const{chain:t}=e;switch(t){case"ethereum":return await this.signInWithEthereum(e);case"solana":return await this.signInWithSolana(e);default:throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`)}}async signInWithEthereum(e){var t,s,r,i,a,o,u,h,d,p,m;let y,b;if("message"in e)y=e.message,b=e.signature;else{const{chain:x,wallet:w,statement:S,options:C}=e;let N;if(ls())if(typeof w=="object")N=w;else{const F=window;if("ethereum"in F&&typeof F.ethereum=="object"&&"request"in F.ethereum&&typeof F.ethereum.request=="function")N=F.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!C?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");N=w}const k=new URL((t=C?.url)!==null&&t!==void 0?t:window.location.href),E=await N.request({method:"eth_requestAccounts"}).then(F=>F).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const _=HL(E[0]);let R=(s=C?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!R){const F=await N.request({method:"eth_chainId"});R=$7(F)}const O={domain:k.host,address:_,statement:S,uri:k.href,version:"1",chainId:R,nonce:(r=C?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(a=(i=C?.signInWithEthereum)===null||i===void 0?void 0:i.issuedAt)!==null&&a!==void 0?a:new Date,expirationTime:(o=C?.signInWithEthereum)===null||o===void 0?void 0:o.expirationTime,notBefore:(u=C?.signInWithEthereum)===null||u===void 0?void 0:u.notBefore,requestId:(h=C?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=C?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=_7(O),b=await N.request({method:"personal_sign",params:[I7(y),_]})}try{const{data:x,error:w}=await We(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((p=e.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=e.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:si});if(w)throw w;if(!x||!x.session||!x.user){const S=new dc;return this._returnResult({data:{user:null,session:null},error:S})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(Pe(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(e){var t,s,r,i,a,o,u,h,d,p,m,y;let b,x;if("message"in e)b=e.message,x=e.signature;else{const{chain:w,wallet:S,statement:C,options:N}=e;let k;if(ls())if(typeof S=="object")k=S;else{const _=window;if("solana"in _&&typeof _.solana=="object"&&("signIn"in _.solana&&typeof _.solana.signIn=="function"||"signMessage"in _.solana&&typeof _.solana.signMessage=="function"))k=_.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof S!="object"||!N?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=S}const E=new URL((t=N?.url)!==null&&t!==void 0?t:window.location.href);if("signIn"in k&&k.signIn){const _=await k.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},N?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),C?{statement:C}:null));let R;if(Array.isArray(_)&&_[0]&&typeof _[0]=="object")R=_[0];else if(_&&typeof _=="object"&&"signedMessage"in _&&"signature"in _)R=_;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in R&&"signature"in R&&(typeof R.signedMessage=="string"||R.signedMessage instanceof Uint8Array)&&R.signature instanceof Uint8Array)b=typeof R.signedMessage=="string"?R.signedMessage:new TextDecoder().decode(R.signedMessage),x=R.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in k)||typeof k.signMessage!="function"||!("publicKey"in k)||typeof k!="object"||!k.publicKey||!("toBase58"in k.publicKey)||typeof k.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,k.publicKey.toBase58(),...C?["",C,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(r=(s=N?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=N?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${N.signInWithSolana.notBefore}`]:[],...!((a=N?.signInWithSolana)===null||a===void 0)&&a.expirationTime?[`Expiration Time: ${N.signInWithSolana.expirationTime}`]:[],...!((o=N?.signInWithSolana)===null||o===void 0)&&o.chainId?[`Chain ID: ${N.signInWithSolana.chainId}`]:[],...!((u=N?.signInWithSolana)===null||u===void 0)&&u.nonce?[`Nonce: ${N.signInWithSolana.nonce}`]:[],...!((h=N?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${N.signInWithSolana.requestId}`]:[],...!((p=(d=N?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||p===void 0)&&p.length?["Resources",...N.signInWithSolana.resources.map(R=>`- ${R}`)]:[]].join(`
`);const _=await k.signMessage(new TextEncoder().encode(b),"utf8");if(!_||!(_ instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=_}}try{const{data:w,error:S}=await We(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:Rl(x)},!((m=e.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=e.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:si});if(S)throw S;if(!w||!w.session||!w.user){const C=new dc;return this._returnResult({data:{user:null,session:null},error:C})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:S})}catch(w){if(Pe(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(e){const t=await gl(this.storage,`${this.storageKey}-code-verifier`),[s,r]=(t??"").split("/");try{if(!s&&this.flowType==="pkce")throw new YK;const{data:i,error:a}=await We(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:e,code_verifier:s},xform:si});if(await os(this.storage,`${this.storageKey}-code-verifier`),a)throw a;if(!i||!i.session||!i.user){const o=new dc;return this._returnResult({data:{user:null,session:null,redirectType:null},error:o})}return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",i.session)),this._returnResult({data:Object.assign(Object.assign({},i),{redirectType:r??null}),error:a})}catch(i){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(i))return this._returnResult({data:{user:null,session:null,redirectType:null},error:i});throw i}}async signInWithIdToken(e){try{const{options:t,provider:s,token:r,access_token:i,nonce:a}=e,o=await We(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:r,access_token:i,nonce:a,gotrue_meta_security:{captcha_token:t?.captchaToken}},xform:si}),{data:u,error:h}=o;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!u||!u.session||!u.user){const d=new dc;return this._returnResult({data:{user:null,session:null},error:d})}return u.session&&(await this._saveSession(u.session),await this._notifyAllSubscribers("SIGNED_IN",u.session)),this._returnResult({data:u,error:h})}catch(t){if(Pe(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOtp(e){var t,s,r,i,a;try{if("email"in e){const{email:o,options:u}=e;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await fc(this.storage,this.storageKey));const{error:p}=await We(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:o,data:(t=u?.data)!==null&&t!==void 0?t:{},create_user:(s=u?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:u?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:u?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in e){const{phone:o,options:u}=e,{data:h,error:d}=await We(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:o,data:(r=u?.data)!==null&&r!==void 0?r:{},create_user:(i=u?.shouldCreateUser)!==null&&i!==void 0?i:!0,gotrue_meta_security:{captcha_token:u?.captchaToken},channel:(a=u?.channel)!==null&&a!==void 0?a:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new _y("You must provide either an email or phone number.")}catch(o){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(o))return this._returnResult({data:{user:null,session:null},error:o});throw o}}async verifyOtp(e){var t,s;try{let r,i;"options"in e&&(r=(t=e.options)===null||t===void 0?void 0:t.redirectTo,i=(s=e.options)===null||s===void 0?void 0:s.captchaToken);const{data:a,error:o}=await We(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},e),{gotrue_meta_security:{captcha_token:i}}),redirectTo:r,xform:si});if(o)throw o;if(!a)throw new Error("An error occurred on token verification.");const u=a.session,h=a.user;return u?.access_token&&(await this._saveSession(u),await this._notifyAllSubscribers(e.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",u)),this._returnResult({data:{user:h,session:u},error:null})}catch(r){if(Pe(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(e){var t,s,r,i,a;try{let o=null,u=null;this.flowType==="pkce"&&([o,u]=await fc(this.storage,this.storageKey));const h=await We(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in e?{provider_id:e.providerId}:null),"domain"in e?{domain:e.domain}:null),{redirect_to:(s=(t=e.options)===null||t===void 0?void 0:t.redirectTo)!==null&&s!==void 0?s:void 0}),!((r=e?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:e.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:o,code_challenge_method:u}),headers:this.headers,xform:v7});return!((i=h.data)===null||i===void 0)&&i.url&&ls()&&!(!((a=e.options)===null||a===void 0)&&a.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(o){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(o))return this._returnResult({data:null,error:o});throw o}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;if(s)throw s;if(!t)throw new dr;const{error:r}=await We(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:t.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(e){if(Pe(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async resend(e){try{const t=`${this.url}/resend`;if("email"in e){const{email:s,type:r,options:i}=e,{error:a}=await We(this.fetch,"POST",t,{headers:this.headers,body:{email:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}},redirectTo:i?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:a})}else if("phone"in e){const{phone:s,type:r,options:i}=e,{data:a,error:o}=await We(this.fetch,"POST",t,{headers:this.headers,body:{phone:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:a?.message_id},error:o})}throw new _y("You must provide either an email or phone number and a type")}catch(t){if(Pe(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async t=>t))}async _acquireLock(e,t){this._debug("#_acquireLock","begin",e);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await s,await t()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,e,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=t();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(e){this._debug("#_useSession","begin");try{const t=await this.__loadSession();return await e(t)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let e=null;const t=await gl(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",t),t!==null&&(this._isValidSession(t)?e=t:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!e)return{data:{session:null},error:null};const s=e.expires_at?e.expires_at*1e3-Date.now()<bS:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",e.expires_at),!s){if(this.userStorage){const a=await gl(this.userStorage,this.storageKey+"-user");a?.user?e.user=a.user:e.user=vS()}if(this.storage.isServer&&e.user&&!e.user.__isUserNotAvailableProxy){const a={value:this.suppressGetSessionWarning};e.user=y7(e.user,a),a.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:e},error:null}}const{data:r,error:i}=await this._callRefreshToken(e.refresh_token);return i?this._returnResult({data:{session:null},error:i}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(e){if(e)return await this._getUser(e);await this.initializePromise;const t=await this._acquireLock(-1,async()=>await this._getUser());return t.data.user&&(this.suppressGetSessionWarning=!0),t}async _getUser(e){try{return e?await We(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:e,xform:go}):await this._useSession(async t=>{var s,r,i;const{data:a,error:o}=t;if(o)throw o;return!(!((s=a.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new dr}:await We(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(i=(r=a.session)===null||r===void 0?void 0:r.access_token)!==null&&i!==void 0?i:void 0,xform:go})})}catch(t){if(Pe(t))return KK(t)&&(await this._removeSession(),await os(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:t});throw t}}async updateUser(e,t={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(e,t))}async _updateUser(e,t={}){try{return await this._useSession(async s=>{const{data:r,error:i}=s;if(i)throw i;if(!r.session)throw new dr;const a=r.session;let o=null,u=null;this.flowType==="pkce"&&e.email!=null&&([o,u]=await fc(this.storage,this.storageKey));const{data:h,error:d}=await We(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:t?.emailRedirectTo,body:Object.assign(Object.assign({},e),{code_challenge:o,code_challenge_method:u}),jwt:a.access_token,xform:go});if(d)throw d;return a.user=h.user,await this._saveSession(a),await this._notifyAllSubscribers("USER_UPDATED",a),this._returnResult({data:{user:a.user},error:null})})}catch(s){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(e))}async _setSession(e){try{if(!e.access_token||!e.refresh_token)throw new dr;const t=Date.now()/1e3;let s=t,r=!0,i=null;const{payload:a}=wS(e.access_token);if(a.exp&&(s=a.exp,r=s<=t),r){const{data:o,error:u}=await this._callRefreshToken(e.refresh_token);if(u)return this._returnResult({data:{user:null,session:null},error:u});if(!o)return{data:{user:null,session:null},error:null};i=o}else{const{data:o,error:u}=await this._getUser(e.access_token);if(u)throw u;i={access_token:e.access_token,refresh_token:e.refresh_token,user:o.user,token_type:"bearer",expires_in:s-t,expires_at:s},await this._saveSession(i),await this._notifyAllSubscribers("SIGNED_IN",i)}return this._returnResult({data:{user:i.user,session:i},error:null})}catch(t){if(Pe(t))return this._returnResult({data:{session:null,user:null},error:t});throw t}}async refreshSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(e))}async _refreshSession(e){try{return await this._useSession(async t=>{var s;if(!e){const{data:a,error:o}=t;if(o)throw o;e=(s=a.session)!==null&&s!==void 0?s:void 0}if(!e?.refresh_token)throw new dr;const{data:r,error:i}=await this._callRefreshToken(e.refresh_token);return i?this._returnResult({data:{user:null,session:null},error:i}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(t){if(Pe(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async _getSessionFromURL(e,t){try{if(!ls())throw new Ay("No browser detected.");if(e.error||e.error_description||e.error_code)throw new Ay(e.error_description||"Error in URL with unspecified error_description",{error:e.error||"unspecified_error",code:e.error_code||"unspecified_code"});switch(t){case"implicit":if(this.flowType==="pkce")throw new XD("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Ay("Not a valid implicit grant flow url.");break;default:}if(t==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!e.code)throw new XD("No code detected.");const{data:C,error:N}=await this._exchangeCodeForSession(e.code);if(N)throw N;const k=new URL(window.location.href);return k.searchParams.delete("code"),window.history.replaceState(window.history.state,"",k.toString()),{data:{session:C.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:r,access_token:i,refresh_token:a,expires_in:o,expires_at:u,token_type:h}=e;if(!i||!o||!a||!h)throw new Ay("No session defined in URL");const d=Math.round(Date.now()/1e3),p=parseInt(o);let m=d+p;u&&(m=parseInt(u));const y=m-d;y*1e3<=wc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${p}s`);const b=m-p;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(i);if(w)throw w;const S={provider_token:s,provider_refresh_token:r,access_token:i,expires_in:p,expires_at:m,refresh_token:a,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:S,redirectType:e.type},error:null})}catch(s){if(Pe(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(e){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),e):!!(e.access_token||e.error_description)}async _isPKCECallback(e){const t=await gl(this.storage,`${this.storageKey}-code-verifier`);return!!(e.code&&t)}async signOut(e={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(e))}async _signOut({scope:e}={scope:"global"}){return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({error:i});const a=(s=r.session)===null||s===void 0?void 0:s.access_token;if(a){const{error:o}=await this.admin.signOut(a,e);if(o&&!(qK(o)&&(o.status===404||o.status===401||o.status===403)))return this._returnResult({error:o})}return e!=="others"&&(await this._removeSession(),await os(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(e){const t=s7(),s={id:t,callback:e,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",t),this.stateChangeEmitters.delete(t)}};return this._debug("#onAuthStateChange()","registered callback with id",t),this.stateChangeEmitters.set(t,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(t)})))(),{data:{subscription:s}}}async _emitInitialSession(e){return await this._useSession(async t=>{var s,r;try{const{data:{session:i},error:a}=t;if(a)throw a;await((s=this.stateChangeEmitters.get(e))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",i)),this._debug("INITIAL_SESSION","callback id",e,"session",i)}catch(i){await((r=this.stateChangeEmitters.get(e))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",e,"error",i),console.error(i)}})}async resetPasswordForEmail(e,t={}){let s=null,r=null;this.flowType==="pkce"&&([s,r]=await fc(this.storage,this.storageKey,!0));try{return await We(this.fetch,"POST",`${this.url}/recover`,{body:{email:e,code_challenge:s,code_challenge_method:r,gotrue_meta_security:{captcha_token:t.captchaToken}},headers:this.headers,redirectTo:t.redirectTo})}catch(i){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(i))return this._returnResult({data:null,error:i});throw i}}async getUserIdentities(){var e;try{const{data:t,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(e=t.user.identities)!==null&&e!==void 0?e:[]},error:null})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}}async linkIdentity(e){return"token"in e?this.linkIdentityIdToken(e):this.linkIdentityOAuth(e)}async linkIdentityOAuth(e){var t;try{const{data:s,error:r}=await this._useSession(async i=>{var a,o,u,h,d;const{data:p,error:m}=i;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,e.provider,{redirectTo:(a=e.options)===null||a===void 0?void 0:a.redirectTo,scopes:(o=e.options)===null||o===void 0?void 0:o.scopes,queryParams:(u=e.options)===null||u===void 0?void 0:u.queryParams,skipBrowserRedirect:!0});return await We(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=p.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(r)throw r;return ls()&&!(!((t=e.options)===null||t===void 0)&&t.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:e.provider,url:s?.url},error:null})}catch(s){if(Pe(s))return this._returnResult({data:{provider:e.provider,url:null},error:s});throw s}}async linkIdentityIdToken(e){return await this._useSession(async t=>{var s;try{const{error:r,data:{session:i}}=t;if(r)throw r;const{options:a,provider:o,token:u,access_token:h,nonce:d}=e,p=await We(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=i?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:o,id_token:u,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:a?.captchaToken}},xform:si}),{data:m,error:y}=p;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new dc}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(r){if(await os(this.storage,`${this.storageKey}-code-verifier`),Pe(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(e){try{return await this._useSession(async t=>{var s,r;const{data:i,error:a}=t;if(a)throw a;return await We(this.fetch,"DELETE",`${this.url}/user/identities/${e.identity_id}`,{headers:this.headers,jwt:(r=(s=i.session)===null||s===void 0?void 0:s.access_token)!==null&&r!==void 0?r:void 0})})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}}async _refreshAccessToken(e){const t=`#_refreshAccessToken(${e.substring(0,5)}...)`;this._debug(t,"begin");try{const s=Date.now();return await o7(async r=>(r>0&&await a7(200*Math.pow(2,r-1)),this._debug(t,"refreshing attempt",r),await We(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:e},headers:this.headers,xform:si})),(r,i)=>{const a=200*Math.pow(2,r);return i&&xS(i)&&Date.now()+a-s<wc})}catch(s){if(this._debug(t,"error",s),Pe(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(t,"end")}}_isValidSession(e){return typeof e=="object"&&e!==null&&"access_token"in e&&"refresh_token"in e&&"expires_at"in e}async _handleProviderSignIn(e,t){const s=await this._getUrlForProvider(`${this.url}/authorize`,e,{redirectTo:t.redirectTo,scopes:t.scopes,queryParams:t.queryParams});return this._debug("#_handleProviderSignIn()","provider",e,"options",t,"url",s),ls()&&!t.skipBrowserRedirect&&window.location.assign(s),{data:{provider:e,url:s},error:null}}async _recoverAndRefresh(){var e,t;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const r=await gl(this.storage,this.storageKey);if(r&&this.userStorage){let a=await gl(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!a&&(a={user:r.user},await vc(this.userStorage,this.storageKey+"-user",a)),r.user=(e=a?.user)!==null&&e!==void 0?e:vS()}else if(r&&!r.user&&!r.user){const a=await gl(this.storage,this.storageKey+"-user");a&&a?.user?(r.user=a.user,await os(this.storage,this.storageKey+"-user"),await vc(this.storage,this.storageKey,r)):r.user=vS()}if(this._debug(s,"session from storage",r),!this._isValidSession(r)){this._debug(s,"session is not valid"),r!==null&&await this._removeSession();return}const i=((t=r.expires_at)!==null&&t!==void 0?t:1/0)*1e3-Date.now()<bS;if(this._debug(s,`session has${i?"":" not"} expired with margin of ${bS}s`),i){if(this.autoRefreshToken&&r.refresh_token){const{error:a}=await this._callRefreshToken(r.refresh_token);a&&(console.error(a),xS(a)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",a),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:a,error:o}=await this._getUser(r.access_token);!o&&a?.user?(r.user=a.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(a){console.error("Error getting user data:",a),this._debug(s,"error getting user data, skipping SIGNED_IN notification",a)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(s,"error",r),console.error(r);return}finally{this._debug(s,"end")}}async _callRefreshToken(e){var t,s;if(!e)throw new dr;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${e.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new ub;const{data:i,error:a}=await this._refreshAccessToken(e);if(a)throw a;if(!i.session)throw new dr;await this._saveSession(i.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",i.session);const o={data:i.session,error:null};return this.refreshingDeferred.resolve(o),o}catch(i){if(this._debug(r,"error",i),Pe(i)){const a={data:null,error:i};return xS(i)||await this._removeSession(),(t=this.refreshingDeferred)===null||t===void 0||t.resolve(a),a}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(i),i}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(e,t,s=!0){const r=`#_notifyAllSubscribers(${e})`;this._debug(r,"begin",t,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:e,session:t});const i=[],a=Array.from(this.stateChangeEmitters.values()).map(async o=>{try{await o.callback(e,t)}catch(u){i.push(u)}});if(await Promise.all(a),i.length>0){for(let o=0;o<i.length;o+=1)console.error(i[o]);throw i[0]}}finally{this._debug(r,"end")}}async _saveSession(e){this._debug("#_saveSession()",e),this.suppressGetSessionWarning=!0,await os(this.storage,`${this.storageKey}-code-verifier`);const t=Object.assign({},e),s=t.user&&t.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&t.user&&await vc(this.userStorage,this.storageKey+"-user",{user:t.user});const r=Object.assign({},t);delete r.user;const i=eO(r);await vc(this.storage,this.storageKey,i)}else{const r=eO(t);await vc(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await os(this.storage,this.storageKey),await os(this.storage,this.storageKey+"-code-verifier"),await os(this.storage,this.storageKey+"-user"),this.userStorage&&await os(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const e=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{e&&ls()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",e)}catch(t){console.error("removing visibilitychange callback failed",t)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const e=setInterval(()=>this._autoRefreshTokenTick(),wc);this.autoRefreshTicker=e,e&&typeof e=="object"&&typeof e.unref=="function"?e.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(e),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const e=this.autoRefreshTicker;this.autoRefreshTicker=null,e&&clearInterval(e)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const e=Date.now();try{return await this._useSession(async t=>{const{data:{session:s}}=t;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((s.expires_at*1e3-e)/wc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${wc}ms, refresh threshold is ${bT} ticks`),r<=bT&&await this._callRefreshToken(s.refresh_token)})}catch(t){console.error("Auto refresh tick failed with error. This is likely a transient error.",t)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(e){if(e.isAcquireTimeout||e instanceof GL)this._debug("auto refresh token tick lock not available");else throw e}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!ls()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(e){console.error("_handleVisibilityChange",e)}}async _onVisibilityChanged(e){const t=`#_onVisibilityChanged(${e})`;this._debug(t,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),e||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(t,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(e,t,s){const r=[`provider=${encodeURIComponent(t)}`];if(s?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&r.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[i,a]=await fc(this.storage,this.storageKey),o=new URLSearchParams({code_challenge:`${encodeURIComponent(i)}`,code_challenge_method:`${encodeURIComponent(a)}`});r.push(o.toString())}if(s?.queryParams){const i=new URLSearchParams(s.queryParams);r.push(i.toString())}return s?.skipBrowserRedirect&&r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${e}?${r.join("&")}`}async _unenroll(e){try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;return i?this._returnResult({data:null,error:i}):await We(this.fetch,"DELETE",`${this.url}/factors/${e.factorId}`,{headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token})})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}}async _enroll(e){try{return await this._useSession(async t=>{var s,r;const{data:i,error:a}=t;if(a)return this._returnResult({data:null,error:a});const o=Object.assign({friendly_name:e.friendlyName,factor_type:e.factorType},e.factorType==="phone"?{phone:e.phone}:e.factorType==="totp"?{issuer:e.issuer}:{}),{data:u,error:h}=await We(this.fetch,"POST",`${this.url}/factors`,{body:o,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(e.factorType==="totp"&&u.type==="totp"&&(!((r=u?.totp)===null||r===void 0)&&r.qr_code)&&(u.totp.qr_code=`data:image/svg+xml;utf-8,${u.totp.qr_code}`),this._returnResult({data:u,error:null}))})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}}async _verify(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({data:null,error:i});const a=Object.assign({challenge_id:e.challengeId},"webauthn"in e?{webauthn:Object.assign(Object.assign({},e.webauthn),{credential_response:e.webauthn.type==="create"?M7(e.webauthn.credential_response):z7(e.webauthn.credential_response)})}:{code:e.code}),{data:o,error:u}=await We(this.fetch,"POST",`${this.url}/factors/${e.factorId}/verify`,{body:a,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return u?this._returnResult({data:null,error:u}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+o.expires_in},o)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",o),this._returnResult({data:o,error:u}))})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}})}async _challenge(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({data:null,error:i});const a=await We(this.fetch,"POST",`${this.url}/factors/${e.factorId}/challenge`,{body:e,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});if(a.error)return a;const{data:o}=a;if(o.type!=="webauthn")return{data:o,error:null};switch(o.webauthn.type){case"create":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:F7(o.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:L7(o.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}})}async _challengeAndVerify(e){const{data:t,error:s}=await this._challenge({factorId:e.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:e.factorId,challengeId:t.id,code:e.code})}async _listFactors(){var e;const{data:{user:t},error:s}=await this.getUser();if(s)return{data:null,error:s};const r={all:[],phone:[],totp:[],webauthn:[]};for(const i of(e=t?.factors)!==null&&e!==void 0?e:[])r.all.push(i),i.status==="verified"&&r[i.factor_type].push(i);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var e,t;const{data:{session:s},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:i}=wS(s.access_token);let a=null;i.aal&&(a=i.aal);let o=a;((t=(e=s.user.factors)===null||e===void 0?void 0:e.filter(d=>d.status==="verified"))!==null&&t!==void 0?t:[]).length>0&&(o="aal2");const h=i.amr||[];return{data:{currentLevel:a,nextLevel:o,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?await We(this.fetch,"GET",`${this.url}/oauth/authorizations/${e}`,{headers:this.headers,jwt:s.access_token,xform:i=>({data:i,error:null})}):this._returnResult({data:null,error:new dr})})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}}async _approveAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new dr});const a=await We(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:o=>({data:o,error:null})});return a.data&&a.data.redirect_url&&ls()&&!t?.skipBrowserRedirect&&window.location.assign(a.data.redirect_url),a})}catch(s){if(Pe(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new dr});const a=await We(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:o=>({data:o,error:null})});return a.data&&a.data.redirect_url&&ls()&&!t?.skipBrowserRedirect&&window.location.assign(a.data.redirect_url),a})}catch(s){if(Pe(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;return s?this._returnResult({data:null,error:s}):t?await We(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:t.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new dr})})}catch(e){if(Pe(e))return this._returnResult({data:null,error:e});throw e}}async _revokeOAuthGrant(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?(await We(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:e.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new dr})})}catch(t){if(Pe(t))return this._returnResult({data:null,error:t});throw t}}async fetchJwk(e,t={keys:[]}){let s=t.keys.find(o=>o.kid===e);if(s)return s;const r=Date.now();if(s=this.jwks.keys.find(o=>o.kid===e),s&&this.jwks_cached_at+GK>r)return s;const{data:i,error:a}=await We(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(a)throw a;return!i.keys||i.keys.length===0||(this.jwks=i,this.jwks_cached_at=r,s=i.keys.find(o=>o.kid===e),!s)?null:s}async getClaims(e,t={}){try{let s=e;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:r,payload:i,signature:a,raw:{header:o,payload:u}}=wS(s);t?.allowExpired||p7(i.exp);const h=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,t?.keys?{keys:t.keys}:t?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:i,header:r,signature:a},error:null}}const d=m7(r.alg),p=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,p,a,t7(`${o}.${u}`)))throw new vT("Invalid JWT signature");return{data:{claims:i,header:r,signature:a},error:null}}catch(s){if(Pe(s))return this._returnResult({data:null,error:s});throw s}}}Hf.nextInstanceID={};const q7=Hf,K7="2.89.0";let wf="";typeof Deno<"u"?wf="deno":typeof document<"u"?wf="web":typeof navigator<"u"&&navigator.product==="ReactNative"?wf="react-native":wf="node";const X7={"X-Client-Info":`supabase-js-${wf}/${K7}`},Y7={headers:X7},J7={schema:"public"},Z7={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},Q7={};function qf(n){"@babel/helpers - typeof";return qf=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},qf(n)}function eX(n,e){if(qf(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(qf(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function tX(n){var e=eX(n,"string");return qf(e)=="symbol"?e:e+""}function nX(n,e,t){return(e=tX(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function oO(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function an(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?oO(Object(t),!0).forEach(function(s){nX(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):oO(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const sX=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),rX=()=>Headers,iX=(n,e,t)=>{const s=sX(t),r=rX();return async(i,a)=>{var o;const u=(o=await e())!==null&&o!==void 0?o:n;let h=new r(a?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${u}`),s(i,an(an({},a),{},{headers:h}))}};function aX(n){return n.endsWith("/")?n:n+"/"}function oX(n,e){var t,s;const{db:r,auth:i,realtime:a,global:o}=n,{db:u,auth:h,realtime:d,global:p}=e,m={db:an(an({},u),r),auth:an(an({},h),i),realtime:an(an({},d),a),storage:{},global:an(an(an({},p),o),{},{headers:an(an({},(t=p?.headers)!==null&&t!==void 0?t:{}),(s=o?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function lX(n){const e=n?.trim();if(!e)throw new Error("supabaseUrl is required.");if(!e.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(aX(e))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var uX=class extends q7{constructor(n){super(n)}},cX=class{constructor(n,e,t){var s,r;this.supabaseUrl=n,this.supabaseKey=e;const i=lX(n);if(!e)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",i),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",i),this.storageUrl=new URL("storage/v1",i),this.functionsUrl=new URL("functions/v1",i);const a=`sb-${i.hostname.split(".")[0]}-auth-token`,o={db:J7,realtime:Q7,auth:an(an({},Z7),{},{storageKey:a}),global:Y7},u=oX(t??{},o);if(this.storageKey=(s=u.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(r=u.global.headers)!==null&&r!==void 0?r:{},u.accessToken)this.accessToken=u.accessToken,this.auth=new Proxy({},{get:(d,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=u.auth)!==null&&h!==void 0?h:{},this.headers,u.global.fetch)}this.fetch=iX(e,this._getAccessToken.bind(this),u.global.fetch),this.realtime=this._initRealtimeClient(an({headers:this.headers,accessToken:this._getAccessToken.bind(this)},u.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new j8(new URL("rest/v1",i).href,{headers:this.headers,schema:u.db.schema,fetch:this.fetch}),this.storage=new BK(this.storageUrl.href,this.headers,this.fetch,t?.storage),u.accessToken||this._listenForAuthEvents()}get functions(){return new z8(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,e={},t={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,e,t)}channel(n,e={config:{}}){return this.realtime.channel(n,e)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,e,t;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(e=(t=s.session)===null||t===void 0?void 0:t.access_token)!==null&&e!==void 0?e:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,storageKey:i,flowType:a,lock:o,debug:u,throwOnError:h},d,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new uX({url:this.authUrl.href,headers:an(an({},m),d),storageKey:i,autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,flowType:a,lock:o,debug:u,throwOnError:h,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new aK(this.realtimeUrl.href,an(an({},n),{},{params:an(an({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,e)=>{this._handleTokenChanged(n,"CLIENT",e?.access_token)})}_handleTokenChanged(n,e,t){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==t?(this.changedAccessToken=t,this.realtime.setAuth(t)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),e=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const hX=(n,e,t)=>new cX(n,e,t);function dX(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const e=n.match(/^v(\d+)\./);return e?parseInt(e[1],10)<=18:!1}dX()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const TS=KL;(function(n,e){const t=KL,s=n();for(;;)try{if(parseInt(t(339))/1+-parseInt(t(334))/2*(parseInt(t(326))/3)+parseInt(t(328))/4*(-parseInt(t(333))/5)+parseInt(t(337))/6*(-parseInt(t(331))/7)+-parseInt(t(323))/8+-parseInt(t(317))/9+parseInt(t(327))/10===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(S0,138876);function KL(n,e){return n=n-317,S0()[n]}const fX="https://brrjoheinakfhohesogc.supabase.co",pX="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A";function S0(){const n=["profiles","undefined","3NJlgJt","7079510bGbmET","20VpKopt","setItem","single","635369yRhrKo","remove","65180BmZWhx","257326Qchhdo","from","getItem","18OidoeX","subscription_tier, stripe_customer_id, stripe_subscription_id, billing_info","66013zJCDfx","get","1127538cCcjCv","local","error","select","storage","removeItem","349296HllnwD"];return S0=function(){return n},S0()}const mX={getItem:n=>{const e=TS;return typeof chrome<"u"&&chrome[e(321)]&&chrome[e(321)][e(318)]?new Promise(t=>{const s=e;chrome.storage[s(318)][s(340)]([n],r=>t(r[n]||null))}):localStorage[e(336)](n)},setItem:(n,e)=>{const t=TS;typeof chrome!==t(325)&&chrome[t(321)]&&chrome[t(321)][t(318)]?chrome.storage[t(318)].set({[n]:e}):localStorage[t(329)](n,e)},removeItem:n=>{const e=TS;typeof chrome!==e(325)&&chrome.storage&&chrome[e(321)][e(318)]?chrome[e(321)].local[e(332)]([n]):localStorage[e(322)](n)}},qs=hX(fX,pX,{auth:{storage:mX,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0}}),XL=ke.createContext(),gX=({children:n})=>{const[e,t]=ke.useState(null),[s,r]=ke.useState(null),[i,a]=ke.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[o,u]=ke.useState(!0);ke.useEffect(()=>{p(),qs.auth.getSession().then(({data:{session:y}})=>{t(y?.user||null),y?.user?h(y.user.id,y.user.email):u(!1)});const{data:{subscription:m}}=qs.auth.onAuthStateChange((y,b)=>{t(b?.user||null),b?.user?h(b.user.id,b.user.email):(r(null),u(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await qs.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:S}=await qs.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();S||(b=w)}r(b)}catch(b){console.error("Profile fetch error:",b)}finally{u(!1)}},d=()=>{e&&h(e.id,e.email)},p=async()=>{try{const{data:m,error:y}=await qs.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&a(m)}catch(m){console.error("Neural state sync error:",m)}};return xe.jsx(XL.Provider,{value:{user:e,profile:s,neuralState:i,loading:o,refreshProfile:d,fetchNeuralState:p,setUser:t,setProfile:r,setNeuralState:a},children:n})},yX=()=>ke.useContext(XL);(function(n,e){const t=Aa,s=n();for(;;)try{if(-parseInt(t(279))/1+-parseInt(t(272))/2*(parseInt(t(276))/3)+-parseInt(t(300))/4*(parseInt(t(299))/5)+-parseInt(t(301))/6+-parseInt(t(284))/7*(-parseInt(t(293))/8)+-parseInt(t(297))/9+parseInt(t(298))/10*(parseInt(t(281))/11)===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(T0,561379);function Aa(n,e){return n=n-271,T0()[n]}const ST=(n,e)=>{const t=Aa;if(n[t(295)]<e)return[];const s=[];for(let r=e-1;r<n[t(295)];r++){const i=n.slice(r-e+1,r+1)[t(306)]((a,o)=>a+o,0);s[t(290)](i/e)}return s},CS=(n,e)=>{const t=Aa;if(n[t(295)]<e)return[];const s=2/(e+1);let r=[n[0]];for(let i=1;i<n[t(295)];i++)r[t(290)](n[i]*s+r[i-1]*(1-s));return r},YL=(n,e=14)=>{const t=Aa;if(n.length<e+1)return[];let s=0,r=0;for(let h=1;h<=e;h++){const d=n[h]-n[h-1];d>=0?s+=d:r+=Math[t(271)](d)}let i=s/e,a=r/e;const o=[];let u=a===0?100:i/a;o[t(290)](100-100/(1+u));for(let h=e+1;h<n.length;h++){const d=n[h]-n[h-1];d>=0?(i=(i*(e-1)+d)/e,a=(a*(e-1)+0)/e):(i=(i*(e-1)+0)/e,a=(a*(e-1)+Math.abs(d))/e),u=a===0?100:i/a,o.push(100-100/(1+u))}return o},JL=(n,e=20,t=2)=>{const s=Aa;if(n.length<e)return[];const r=[],i=[],a=ST(n,e);for(let o=0;o<a[s(295)];o++){const u=n.slice(o,o+e),h=a[o],d=u[s(288)](y=>Math[s(291)](y-h,2)),p=d.reduce((y,b)=>y+b,0)/e,m=Math.sqrt(p);i[s(290)](h+t*m),r[s(290)](h-t*m)}return{basis:a,upper:i,lower:r}},bX=(n,e=12,t=26,s=9)=>{const r=Aa,i=CS(n,e),a=CS(n,t),o=[],u=Math[r(285)](i[r(295)],a[r(295)]);for(let p=0;p<u;p++)o[r(290)](i[p]-a[p]);const h=CS(o,s),d=[];for(let p=0;p<Math[r(285)](o[r(295)],h[r(295)]);p++)d.push(o[p]-h[p]);return{macdLine:o,signalLine:h,histogram:d}};function T0(){const n=["length","type","4876155aSFcRX","18190JKYbiY","445iydfjg","6676XPaFnF","2284764atvbIT","price","Potential Reversal (Top)","Bearish Continuation","sort","reduce","Bullish","abs","22SnnXHx","max","Neutral","Bullish Continuation","25383apCNCh","Volatility Squeeze","Bearish","62934qoWjka","every","4411ohNcbK","Resistance","Insufficient Data","7763wFbLVS","min","fill","filter","map","Support","push","pow","Potential Reversal (Bottom)","7640hoBqEF","slice"];return T0=function(){return n},T0()}const xX=n=>{const e=Aa;if(n[e(295)]<50)return{name:e(283),sentiment:e(274),confidence:0};n[n[e(295)]-1],n[n[e(295)]-2];const t=ST(n[e(294)](-20),10),s=ST(n[e(294)](-50),40),r=t[t[e(295)]-1]>s[s[e(295)]-1],{upper:i,lower:a}=JL(n,20),o=(i[i[e(295)]-1]-a[a[e(295)]-1])/n[n[e(295)]-1],u=o<.05,h=YL(n,14),d=h[h[e(295)]-1],p=d<30,m=d>70;let y=[];return u&&y[e(290)]({name:e(277),sentiment:e(274)}),r&&!m&&y[e(290)]({name:e(275),sentiment:"Bullish"}),!r&&!p&&y[e(290)]({name:e(304),sentiment:e(278)}),r&&m&&y[e(290)]({name:e(303),sentiment:e(278)}),!r&&p&&y[e(290)]({name:e(292),sentiment:e(307)}),y[e(295)]>0?y[0]:{name:"Consolidation",sentiment:e(274)}},wX=(n,e=14)=>{const t=Aa;if(n[t(295)]<e+1)return[];let s=[];for(let o=1;o<n[t(295)];o++){n[o];const u=n[o],h=n[o-1],d=Math[t(271)](u-h),p=u*.005,m=Math[t(273)](d,p);s.push(m)}const r=[];let i=s[t(294)](0,e).reduce((o,u)=>o+u,0)/e;r.push(i);for(let o=e;o<s[t(295)];o++){const u=(r[r[t(295)]-1]*(e-1)+s[o])/e;r[t(290)](u)}return[...new Array(n.length-r[t(295)])[t(286)](null),...r]},vX=n=>{const e=Aa;if(n[e(295)]<20)return{support:Math[e(285)](...n),resistance:Math.max(...n)};const t=[],s=5;for(let o=s;o<n[e(295)]-s;o++){const u=n[e(294)](o-s,o+s+1),h=n[o],d=u.every(m=>m<=h),p=u[e(280)](m=>m>=h);d&&t[e(290)]({price:h,type:"Resistance"}),p&&t[e(290)]({price:h,type:e(289)})}const r=n[n[e(295)]-1],i=t[e(287)](o=>o[e(296)]==="Support"&&o[e(302)]<r)[e(305)]((o,u)=>u[e(302)]-o[e(302)]),a=t.filter(o=>o.type===e(282)&&o[e(302)]>r)[e(305)]((o,u)=>o.price-u.price);return{support:i.length>0?i[0][e(302)]:Math.min(...n),resistance:a[e(295)]>0?a[0][e(302)]:Math[e(273)](...n)}};const SX=1e-7,TX=1e-4;class a2{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class cb{refCount(e){return js("refCount")}incRef(e){return js("incRef")}timerAvailable(){return!0}time(e){return js("time")}read(e){return js("read")}readSync(e){return js("readSync")}readToGPU(e,t){return js("readToGPU")}numDataIds(){return js("numDataIds")}disposeData(e,t){return js("disposeData")}write(e,t,s){return js("write")}move(e,t,s,r,i){return js("move")}createTensorFromGPUData(e,t,s){return js("createTensorFromGPUData")}memory(){return js("memory")}floatPrecision(){return js("floatPrecision")}epsilon(){return this.floatPrecision()===32?SX:TX}dispose(){return js("dispose")}}function js(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function o2(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,ba(n,e,t)}function CX(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,ba(n,t,s),ba(e,t,s)}function Eo(n,e,t){return Math.max(n,Math.min(e,t))}function hb(n){return n%2===0?n:n+1}function ba(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function ZL(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function NX(n,e){const t=Math.random();return e*t+(1-t)*n}function kX(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function D(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Jn(n,e,t=""){D(it(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function uu(n){D(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function he(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function EX(n){return n.length===0}function QL(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function it(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Gl(n){return n%1===0}function $X(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function C0(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function IX(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return o2(e),e}function Pl(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function TT(n,e=r=>0,t,s){return new Promise((r,i)=>{let a=0;const o=()=>{if(n()){r();return}a++;const u=e(a);if(t!=null&&a>=t){i();return}s!=null?s(o,u):setTimeout(o,u)};o()})}function l2(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function st(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),D(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),D(n.every(s=>Gl(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Ra(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:st(e,n).sort();let a=0;for(let o=0;o<n.length;++o){if(i!=null){if(i[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(i[a]==null||i[a]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),i[a]<=o&&a++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function zn(n,e){return tn(n,e)}function tn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function eM(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function tM(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function u2(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Kf(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function nM(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ri(n){return typeof n=="string"||n instanceof String}function sM(n){return typeof n=="boolean"}function N0(n){return typeof n=="number"}function cu(n){return Array.isArray(n)?cu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":N0(n)?"float32":Ri(n)?"string":sM(n)?"bool":"float32"}function $o(n){return!!(n&&n.constructor&&n.call&&n.apply)}function k0(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function ze(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function rM(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let a=0;a<i;a++)r[a]=t[n+a]}else{const i=e[0],a=e.slice(1),o=a.reduce((u,h)=>u*h)*(s?2:1);for(let u=0;u<i;u++)r[u]=rM(n+u*o,a,t,s)}return r}function vr(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return rM(0,n,e,t)}function iM(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function db(n,e){const t=Yn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Yn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function c2(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return vr(n,new Float32Array(t));if(e==="int32")return vr(n,new Int32Array(t));if(e==="bool")return vr(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function tr(n){n.forEach(e=>{D(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function hi(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function hu(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Ta(n){return n&&n.then&&typeof n.then=="function"}const lO="tfjsflags";class aM{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=_X,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ta(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);lO in e&&e[lO].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=RX(r,i)})}}function _X(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(AX(e,s[0],s[1]),s.join("="))),e}function AX(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function RX(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ie(){return h2}let h2=null;function DX(n){h2=n}let NS;function oM(){if(NS==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");NS=n}return NS}function OX(){const n=oM();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function d2(n,e){const t=OX();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const wp="Abs",eh="Acos",th="Acosh",du="Add",vp="AddN",fb="All",pb="Any",Sp="ArgMax",Tp="ArgMin",nh="Asin",sh="Asinh",rh="Atan",ih="Atanh",ah="Atan2",Cp="AvgPool",mb="AvgPoolGrad",Np="AvgPool3D",gb="AvgPool3DGrad",kp="BatchMatMul",Ep="BatchToSpaceND",yb="Bincount",$p="BitwiseAnd",lM="BroadcastTo",bb="BroadcastArgs",oh="Cast",lh="Ceil",uh="ClipByValue",xb="Complex",Ip="ComplexAbs",_p="Concat",Ap="Conv2D",wb="Conv2DBackpropFilter",Rp="Conv2DBackpropInput",Dp="Conv3D",vb="Conv3DBackpropFilterV2",Sb="Conv3DBackpropInputV2",ch="Cos",hh="Cosh",Tb="Cumprod",Op="Cumsum",Cb="CropAndResize",Nb="DenseBincount",kb="DepthToSpace",Fp="DepthwiseConv2dNative",Eb="DepthwiseConv2dNativeBackpropFilter",$b="DepthwiseConv2dNativeBackpropInput",Ib="Diag",Lp="Dilation2D",E0="Dilation2DBackpropInput",$0="Dilation2DBackpropFilter",_b="Draw",dh="RealDiv",Ab="Einsum",fh="Elu",Rb="EluGrad",ph="Erf",Mp="Equal",mh="Exp",zp="ExpandDims",gh="Expm1",Db="FFT",Ob="Fill",Fb="FlipLeftRight",yh="Floor",bh="FloorDiv",Pp="FusedBatchNorm",Bp="GatherV2",Lb="GatherNd",Vp="Greater",xh="GreaterEqual",wh="Identity",Mb="IFFT",zb="Imag",vh="IsFinite",Sh="IsInf",Th="IsNan",Up="LeakyRelu",jp="Less",Wp="LessEqual",Pb="LinSpace",Ch="Log",Nh="Log1p",Gp="LogicalAnd",Hp="LogicalNot",qp="LogicalOr",FX="LogicalXor",uM="LogSoftmax",LX="LowerBound",Kp="LRN",Bb="LRNGrad",MX="MatrixBandPart",Xp="Max",kh="Maximum",Yp="MaxPool",Vb="MaxPoolGrad",Jp="MaxPool3D",Ub="MaxPool3DGrad",jb="MaxPoolWithArgmax",Zp="Mean",Qp="Min",Eh="Minimum",em="MirrorPad",$h="Mod",Wb="Multinomial",Ih="Multiply",tm="Neg",nm="NotEqual",Gb="NonMaxSuppressionV3",Hb="NonMaxSuppressionV4",qb="NonMaxSuppressionV5",sm="OnesLike",rm="OneHot",im="Pack",am="PadV2",zX="Pool",_h="Pow",om="Prelu",lm="Prod",Kb="RaggedGather",Xb="RaggedRange",Yb="RaggedTensorToTensor",Jb="Range",Zb="Real",Ah="Reciprocal",Rh="Relu",um="Reshape",cm="ResizeNearestNeighbor",Qb="ResizeNearestNeighborGrad",hm="ResizeBilinear",ex="ResizeBilinearGrad",Dh="Relu6",dm="Reverse",Oh="Round",Fh="Rsqrt",tx="ScatterNd",nx="TensorScatterUpdate",sx="SearchSorted",fm="Select",Lh="Selu",pm="Slice",Mh="Sin",zh="Sinh",Ph="Sign",Bh="Sigmoid",Vh="Softplus",Uh="Sqrt",mm="Sum",gm="SpaceToBatchND",ym="SplitV",bm="Softmax",rx="SparseFillEmptyRows",ix="SparseReshape",ax="SparseSegmentMean",ox="SparseSegmentSum",lx="SparseToDense",jh="SquaredDifference",ux="Square",xm="StaticRegexReplace",cx="StridedSlice",hx="StringNGrams",dx="StringSplit",fx="StringToHashBucketFast",Wh="Sub",Gh="Tan",Hh="Tanh",qh="Tile",px="TopK",mx="Transform",Bl="Transpose",gx="Unique",wm="Unpack",vm="UnsortedSegmentSum",PX="UpperBound",Sm="ZerosLike",Kh="Step",I0="FromPixels",yx="RotateWithOffset",Xf="_FusedMatMul",Yf="FusedConv2D",Jf="FusedDepthwiseConv2D";function gr(...n){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(...n)}function BX(...n){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.log(...n)}const Mc=d2("kernelRegistry",()=>new Map),Zf=d2("gradRegistry",()=>new Map);function Qf(n,e){const t=f2(n,e);return Mc.get(t)}function CT(n){return Zf.get(n)}function _0(n){const e=Mc.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===n&&t.push(a)}return t}function bx(n){const{kernelName:e,backendName:t}=n,s=f2(e,t);Mc.has(s)&&gr(`The kernel '${e}' for backend '${t}' is already registered`),Mc.set(s,n)}function cM(n){const{kernelName:e}=n;Zf.has(e)&&ie().getBool("DEBUG")&&gr(`Overriding the gradient for '${e}'`),Zf.set(e,n)}function VX(n,e){const t=f2(n,e);if(!Mc.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Mc.delete(t)}function UX(n){if(!Zf.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Zf.delete(n)}function jX(n,e){_0(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});bx(r)})}function f2(n,e){return`${e}_${n}`}function hM(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var kS,uO;function WX(){if(uO)return kS;uO=1,kS=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(L,A,U){this.low=L|0,this.high=A|0,this.unsigned=!!U}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(L){return(L&&L.__isLong__)===!0}e.isLong=t;var s={},r={};function i(L,A){var U,Y,te;return A?(L>>>=0,(te=0<=L&&L<256)&&(Y=r[L],Y)?Y:(U=o(L,(L|0)<0?-1:0,!0),te&&(r[L]=U),U)):(L|=0,(te=-128<=L&&L<128)&&(Y=s[L],Y)?Y:(U=o(L,L<0?-1:0,!1),te&&(s[L]=U),U))}e.fromInt=i;function a(L,A){if(isNaN(L))return A?C:S;if(A){if(L<0)return C;if(L>=b)return R}else{if(L<=-x)return O;if(L+1>=x)return _}return L<0?a(-L,A).neg():o(L%y|0,L/y|0,A)}e.fromNumber=a;function o(L,A,U){return new e(L,A,U)}e.fromBits=o;var u=Math.pow;function h(L,A,U){if(L.length===0)throw Error("empty string");if(L==="NaN"||L==="Infinity"||L==="+Infinity"||L==="-Infinity")return S;if(typeof A=="number"?(U=A,A=!1):A=!!A,U=U||10,U<2||36<U)throw RangeError("radix");var Y;if((Y=L.indexOf("-"))>0)throw Error("interior hyphen");if(Y===0)return h(L.substring(1),A,U).neg();for(var te=a(u(U,8)),Z=S,B=0;B<L.length;B+=8){var V=Math.min(8,L.length-B),j=parseInt(L.substring(B,B+V),U);if(V<8){var ee=a(u(U,V));Z=Z.mul(ee).add(a(j))}else Z=Z.mul(te),Z=Z.add(a(j))}return Z.unsigned=A,Z}e.fromString=h;function d(L,A){return typeof L=="number"?a(L,A):typeof L=="string"?h(L,A):o(L.low,L.high,typeof A=="boolean"?A:L.unsigned)}e.fromValue=d;var p=65536,m=1<<24,y=p*p,b=y*y,x=b/2,w=i(m),S=i(0);e.ZERO=S;var C=i(0,!0);e.UZERO=C;var N=i(1);e.ONE=N;var k=i(1,!0);e.UONE=k;var E=i(-1);e.NEG_ONE=E;var _=o(-1,2147483647,!1);e.MAX_VALUE=_;var R=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=R;var O=o(0,-2147483648,!1);e.MIN_VALUE=O;var F=e.prototype;return F.toInt=function(){return this.unsigned?this.low>>>0:this.low},F.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},F.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(O)){var U=a(A),Y=this.div(U),te=Y.mul(U).sub(this);return Y.toString(A)+te.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var Z=a(u(A,6),this.unsigned),B=this,V="";;){var j=B.div(Z),ee=B.sub(j.mul(Z)).toInt()>>>0,ae=ee.toString(A);if(B=j,B.isZero())return ae+V;for(;ae.length<6;)ae="0"+ae;V=""+ae+V}},F.getHighBits=function(){return this.high},F.getHighBitsUnsigned=function(){return this.high>>>0},F.getLowBits=function(){return this.low},F.getLowBitsUnsigned=function(){return this.low>>>0},F.getNumBitsAbs=function(){if(this.isNegative())return this.eq(O)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,U=31;U>0&&(A&1<<U)==0;U--);return this.high!=0?U+33:U+1},F.isZero=function(){return this.high===0&&this.low===0},F.eqz=F.isZero,F.isNegative=function(){return!this.unsigned&&this.high<0},F.isPositive=function(){return this.unsigned||this.high>=0},F.isOdd=function(){return(this.low&1)===1},F.isEven=function(){return(this.low&1)===0},F.equals=function(A){return t(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},F.eq=F.equals,F.notEquals=function(A){return!this.eq(A)},F.neq=F.notEquals,F.ne=F.notEquals,F.lessThan=function(A){return this.comp(A)<0},F.lt=F.lessThan,F.lessThanOrEqual=function(A){return this.comp(A)<=0},F.lte=F.lessThanOrEqual,F.le=F.lessThanOrEqual,F.greaterThan=function(A){return this.comp(A)>0},F.gt=F.greaterThan,F.greaterThanOrEqual=function(A){return this.comp(A)>=0},F.gte=F.greaterThanOrEqual,F.ge=F.greaterThanOrEqual,F.compare=function(A){if(t(A)||(A=d(A)),this.eq(A))return 0;var U=this.isNegative(),Y=A.isNegative();return U&&!Y?-1:!U&&Y?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},F.comp=F.compare,F.negate=function(){return!this.unsigned&&this.eq(O)?O:this.not().add(N)},F.neg=F.negate,F.add=function(A){t(A)||(A=d(A));var U=this.high>>>16,Y=this.high&65535,te=this.low>>>16,Z=this.low&65535,B=A.high>>>16,V=A.high&65535,j=A.low>>>16,ee=A.low&65535,ae=0,P=0,H=0,ne=0;return ne+=Z+ee,H+=ne>>>16,ne&=65535,H+=te+j,P+=H>>>16,H&=65535,P+=Y+V,ae+=P>>>16,P&=65535,ae+=U+B,ae&=65535,o(H<<16|ne,ae<<16|P,this.unsigned)},F.subtract=function(A){return t(A)||(A=d(A)),this.add(A.neg())},F.sub=F.subtract,F.multiply=function(A){if(this.isZero())return S;if(t(A)||(A=d(A)),n){var U=n.mul(this.low,this.high,A.low,A.high);return o(U,n.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(O))return A.isOdd()?O:S;if(A.eq(O))return this.isOdd()?O:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return a(this.toNumber()*A.toNumber(),this.unsigned);var Y=this.high>>>16,te=this.high&65535,Z=this.low>>>16,B=this.low&65535,V=A.high>>>16,j=A.high&65535,ee=A.low>>>16,ae=A.low&65535,P=0,H=0,ne=0,ce=0;return ce+=B*ae,ne+=ce>>>16,ce&=65535,ne+=Z*ae,H+=ne>>>16,ne&=65535,ne+=B*ee,H+=ne>>>16,ne&=65535,H+=te*ae,P+=H>>>16,H&=65535,H+=Z*ee,P+=H>>>16,H&=65535,H+=B*j,P+=H>>>16,H&=65535,P+=Y*ae+te*ee+Z*j+B*V,P&=65535,o(ne<<16|ce,P<<16|H,this.unsigned)},F.mul=F.multiply,F.divide=function(A){if(t(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var U=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return o(U,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?C:S;var Y,te,Z;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return C;if(A.gt(this.shru(1)))return k;Z=C}else{if(this.eq(O)){if(A.eq(N)||A.eq(E))return O;if(A.eq(O))return N;var B=this.shr(1);return Y=B.div(A).shl(1),Y.eq(S)?A.isNegative()?N:E:(te=this.sub(A.mul(Y)),Z=Y.add(te.div(A)),Z)}else if(A.eq(O))return this.unsigned?C:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();Z=S}for(te=this;te.gte(A);){Y=Math.max(1,Math.floor(te.toNumber()/A.toNumber()));for(var V=Math.ceil(Math.log(Y)/Math.LN2),j=V<=48?1:u(2,V-48),ee=a(Y),ae=ee.mul(A);ae.isNegative()||ae.gt(te);)Y-=j,ee=a(Y,this.unsigned),ae=ee.mul(A);ee.isZero()&&(ee=N),Z=Z.add(ee),te=te.sub(ae)}return Z},F.div=F.divide,F.modulo=function(A){if(t(A)||(A=d(A)),n){var U=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return o(U,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},F.mod=F.modulo,F.rem=F.modulo,F.not=function(){return o(~this.low,~this.high,this.unsigned)},F.and=function(A){return t(A)||(A=d(A)),o(this.low&A.low,this.high&A.high,this.unsigned)},F.or=function(A){return t(A)||(A=d(A)),o(this.low|A.low,this.high|A.high,this.unsigned)},F.xor=function(A){return t(A)||(A=d(A)),o(this.low^A.low,this.high^A.high,this.unsigned)},F.shiftLeft=function(A){return t(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?o(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):o(0,this.low<<A-32,this.unsigned)},F.shl=F.shiftLeft,F.shiftRight=function(A){return t(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?o(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):o(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},F.shr=F.shiftRight,F.shiftRightUnsigned=function(A){if(t(A)&&(A=A.toInt()),A&=63,A===0)return this;var U=this.high;if(A<32){var Y=this.low;return o(Y>>>A|U<<32-A,U>>>A,this.unsigned)}else return A===32?o(U,0,this.unsigned):o(U>>>A-32,0,this.unsigned)},F.shru=F.shiftRightUnsigned,F.shr_u=F.shiftRightUnsigned,F.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},F.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},F.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},F.toBytesLE=function(){var A=this.high,U=this.low;return[U&255,U>>>8&255,U>>>16&255,U>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},F.toBytesBE=function(){var A=this.high,U=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,U>>>24,U>>>16&255,U>>>8&255,U&255]},e.fromBytes=function(A,U,Y){return Y?e.fromBytesLE(A,U):e.fromBytesBE(A,U)},e.fromBytesLE=function(A,U){return new e(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,U)},e.fromBytesBE=function(A,U){return new e(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],U)},kS}var dM=WX();const fM=wC(dM),GX=vG({__proto__:null,default:fM},[dM]);const Nl=fM||GX;function Tm(n){return Nl.fromString(n,!0,16)}const pM=Tm("c3a5c85c97cb3127"),vl=Tm("b492b66fbe98f273"),ps=Tm("9ae16a3b2f90404f");function NT(n){return n.xor(n.shru(47))}function mM(n,e,t){const s=n.slice(e,e+t);return Nl.fromBytes(Array.from(s),!0,!0)}function Lt(n,e){return mM(n,e,8)}function cO(n,e){return mM(n,e,4)}function Fn(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function vo(n,e,t=Tm("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function HX(n,e,t,s,r,i){r=r.add(n),i=Fn(i.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),i=i.add(Fn(r,44)),[r.add(s),i.add(a)]}function Ry(n,e,t,s){return HX(Lt(n,e),Lt(n,e+8),Lt(n,e+16),Lt(n,e+24),t,s)}function qX(n,e=n.length){if(e>=8){const t=ps.add(e*2),s=Lt(n,0).add(ps),r=Lt(n,e-8),i=Fn(r,37).mul(t).add(s),a=Fn(s,25).add(r).mul(t);return vo(i,a,t)}if(e>=4){const t=ps.add(e*2),s=cO(n,0);return vo(s.shl(3).add(e),cO(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),a=e+(r<<2);return NT(ps.mul(i).xor(pM.mul(a))).mul(ps)}return ps}function KX(n,e=n.length){const t=ps.add(e*2),s=Lt(n,0).mul(vl),r=Lt(n,8),i=Lt(n,e-8).mul(t),a=Lt(n,e-16).mul(ps);return vo(Fn(s.add(r),43).add(Fn(i,30)).add(a),s.add(Fn(r.add(ps),18)).add(i),t)}function XX(n,e=n.length){const t=ps.add(e*2),s=Lt(n,0).mul(ps),r=Lt(n,8),i=Lt(n,e-8).mul(t),a=Lt(n,e-16).mul(ps),o=Fn(s.add(r),43).add(Fn(i,30)).add(a),u=vo(o,s.add(Fn(r.add(ps),18)).add(i),t),h=Lt(n,16).mul(t),d=Lt(n,24),p=o.add(Lt(n,e-32)).mul(t),m=u.add(Lt(n,e-24)).mul(t);return vo(Fn(h.add(d),43).add(Fn(p,30)).add(m),h.add(Fn(d.add(s),18)).add(p),t)}function gM(n,e=n.length){const t=Nl.fromNumber(81,!0);if(e<=32)return e<=16?qX(n,e):KX(n,e);if(e<=64)return XX(n,e);let s=t,r=t.mul(vl).add(113),i=NT(r.mul(ps).add(113)).mul(ps),a=[Nl.UZERO,Nl.UZERO],o=[Nl.UZERO,Nl.UZERO];s=s.mul(ps).add(Lt(n,0));let u=0;const h=(e-1>>6)*64,d=h+(e-1&63)-63;do s=Fn(s.add(r).add(a[0]).add(Lt(n,u+8)),37).mul(vl),r=Fn(r.add(a[1]).add(Lt(n,u+48)),42).mul(vl),s=s.xor(o[1]),r=r.add(a[0]).add(Lt(n,u+40)),i=Fn(i.add(o[0]),33).mul(vl),a=Ry(n,u,a[1].mul(vl),s.add(o[0])),o=Ry(n,u+32,i.add(o[1]),r.add(Lt(n,u+16))),[i,s]=[s,i],u+=64;while(u!==h);const p=vl.add(i.and(255).shl(1));return u=d,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=Fn(s.add(r).add(a[0]).add(Lt(n,u+8)),37).mul(p),r=Fn(r.add(a[1]).add(Lt(n,u+48)),42).mul(p),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add(Lt(n,u+40))),i=Fn(i.add(o[0]),33).mul(p),a=Ry(n,u,a[1].mul(p),s.add(o[0])),o=Ry(n,u+32,i.add(o[1]),r.add(Lt(n,u+16))),[i,s]=[s,i],vo(vo(a[0],o[0],p).add(NT(r).mul(pM)).add(i),vo(a[1],o[1],p).add(s),p)}function Da(n,e){return e==="string"?Li(n):Po([n],e)}function YX(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Po(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Vi(n)),ie().getBool("DEBUG")&&eM(n,e),YX(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Gn(){return ie().platform.now()}function yM(n,e){return ie().platform.fetch(n,e)}function Li(n,e="utf-8"){return e=e||"utf-8",ie().platform.encode(n,e)}function Ca(n,e="utf-8"){return e=e||"utf-8",ie().platform.decode(n,e)}function kn(n){return ie().platform.isTypedArray!=null?ie().platform.isTypedArray(n):hM(n)}function Vi(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Ta(n)||n==null||kn(n)&&t)e.push(n);else if(Array.isArray(n)||kn(n))for(let s=0;s<n.length;++s)Vi(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Vi(n[r],e,t)}return e}const JX=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:it,arraysEqualWithNull:QL,assert:D,assertNonNegativeIntegerDimensions:tr,assertNonNull:uu,assertShapesMatch:Jn,bytesFromStringArray:nM,bytesPerElement:Kf,checkConversionForErrors:eM,clamp:Eo,computeStrides:ze,convertBackendValuesAndArrayBuffer:iM,createScalarValue:Da,createShuffledIndices:IX,decodeString:Ca,distSquared:kX,encodeString:Li,fetch:yM,fingerPrint64:gM,flatten:Vi,getArrayFromDType:tn,getTypedArrayFromDType:zn,hasEncodingLoss:u2,hexToLong:Tm,indexToLoc:hu,inferDtype:cu,inferFromImplicitShape:l2,isBoolean:sM,isFunction:$o,isInt:Gl,isNumber:N0,isPromise:Ta,isScalarShape:EX,isString:Ri,isTypedArray:kn,isValidDtype:tM,locToIndex:hi,makeOnesTypedArray:db,makeZerosNestedTypedArray:c2,makeZerosTypedArray:Yn,nearestDivisor:k0,nearestLargerEven:hb,now:Gn,parseAxisParam:st,randUniform:NX,repeatedTry:TT,rightPad:Pl,shuffle:o2,shuffleCombo:CX,sizeFromShape:he,sizeToSquarishShape:C0,squeezeShape:Ra,sum:ZL,swap:ba,tanh:$X,toNestedArray:vr,toTypedArray:Po},Symbol.toStringTag,{value:"Module"}));class ZX{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new e9)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let a;const o=Gn();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const h of r)h.dataSync();a=Promise.resolve({kernelMs:Gn()-o})}if(ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(p=>{QX(p,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(h=>h.kernelMs),extraInfo:a.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:a}=e;s.forEach(o=>{Promise.all([o.data(),r,a]).then(u=>{this.logger.logKernelProfile(t,o,u[0],u[1],i,u[2])})})}}function QX(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class e9{logKernelProfile(e,t,s,r,i,a){const o=typeof r=="number"?Pl(`${r}ms`,9):r.error,u=Pl(e,25),h=t.rank,d=t.size,p=Pl(t.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const x=b.shape||t.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${u}	%c${o}	%c${h}D ${p}	%c${d}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function t9(n,e,t){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<n.length;u++){const h=n[u],d=h.inputs;for(const p in d){const m=d[p];let y=!1;for(let b=0;b<e.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const i={};i[t.id]=!0;const a={};for(let u=n.length-1;u>=0;u--){const h=n[u],d=h.inputs;for(let p=0;p<h.outputs.length;p++)if(i[h.outputs[p].id]){for(const m in d)i[d[m].id]=!0,a[h.id]=!0;break}}const o=[];for(let u=0;u<n.length;u++){const h=n[u];if(r[h.id]&&a[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const p=Object.assign({},h);p.inputs=d,p.outputs=h.outputs,o.push(p)}}return o}function n9(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(u=>{const h=n[u.id];h!=null?a.push(h):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const u in i.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);const h=t(()=>o[u]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${h.dtype}'`);const d=i.inputs[u];if(!it(h.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${u}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const p=n[d.id];n[d.id]=s(p,h),p.dispose()}}}}const hO=20,pf=3,ES=7;function s9(n,e,t,s){const r=ze(e),i=r9(n,e,t,r),a=e.length,o=Jy(n,e,t,r,i),u=["Tensor"];return s&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(o.map(h=>"    "+h).join(`
`)),u.join(`
`)}function r9(n,e,t,s){const r=he(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,u=t==="complex64"?Sf(n):n;if(o>1)for(let h=0;h<r/i;h++){const d=h*i;for(let p=0;p<i;p++)a[p]=Math.max(a[p],vf(u[d+p],0,t).length)}return a}function vf(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(ES))} + ${parseFloat(n[1].toFixed(ES))}j`:Ri(n)?s=`'${n}'`:t==="bool"?s=bM(n):s=parseFloat(n.toFixed(ES)).toString(),Pl(s,e)}function bM(n){return n===0?"false":"true"}function Jy(n,e,t,s,r,i=!0){const a=t==="complex64"?2:1,o=e[0],u=e.length;if(u===0){if(t==="complex64"){const x=Sf(n);return[vf(x[0],0,t)]}return t==="bool"?[bM(n[0])]:[n[0].toString()]}if(u===1){if(o>hO){const w=pf*a;let S=Array.from(n.slice(0,w)),C=Array.from(n.slice((o-pf)*a,o*a));return t==="complex64"&&(S=Sf(S),C=Sf(C)),["["+S.map((N,k)=>vf(N,r[k],t)).join(", ")+", ..., "+C.map((N,k)=>vf(N,r[o-pf+k],t)).join(", ")+"]"]}return["["+(t==="complex64"?Sf(n):Array.from(n)).map((w,S)=>vf(w,r[S],t)).join(", ")+"]"]}const h=e.slice(1),d=s.slice(1),p=s[0]*a,m=[];if(o>hO){for(let x=0;x<pf;x++){const w=x*p,S=w+p;m.push(...Jy(n.slice(w,S),h,t,d,r,!1))}m.push("...");for(let x=o-pf;x<o;x++){const w=x*p,S=w+p;m.push(...Jy(n.slice(w,S),h,t,d,r,x===o-1))}}else for(let x=0;x<o;x++){const w=x*p,S=w+p;m.push(...Jy(n.slice(w,S),h,t,d,r,x===o-1))}const y=u===2?",":"";m[0]="["+(o>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<u;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function Sf(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class bn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=he(e),s!=null){const r=s.length;D(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||tn(t,this.size),this.strides=ze(e)}set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ui().makeTensor(this.values,this.shape,this.dtype)}}let ui=null,Sc=null;function i9(n){ui=n}function a9(n){Sc=n}class mt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=he(e),this.strides=ze(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Sc.buffer(this.shape,this.dtype,e)}bufferSync(){return Sc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return vr(this.shape,e,this.dtype==="complex64")}arraySync(){return vr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ui().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Ca(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ui().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ui().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ca(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ui().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ui().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Sc.print(this,e)}clone(){return this.throwIfDisposed(),Sc.clone(this)}toString(e=!1){const t=this.dataSync();return s9(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Sc.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),ui().makeVariable(this,e,t,s)}}Object.defineProperty(mt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function pe(){return d2("Tensor",()=>mt)}pe();class ep extends mt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!it(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ui().disposeTensor(this),this.dataId=e.dataId,ui().incRef(this,null)}dispose(){ui().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(ep,Symbol.hasInstance,{value:n=>n instanceof mt&&n.assign!=null&&n.assign instanceof Function});var kT;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(kT||(kT={}));var ET;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(ET||(ET={}));var $T;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})($T||($T={}));var IT;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(IT||(IT={}));var _T;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(_T||(_T={}));const o9={float32:IT,int32:ET,bool:$T,complex64:_T};function _s(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return o9[n][e]}function xx(n){return _s(n,"int32")}function xM(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function wM(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Jt(n,e){if(n.dtype===e.dtype)return[n,e];const t=_s(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function vM(n,e){D(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function wx(n,e){return e.some(t=>t.id===n.id)}function Na(n){const e=[];return SM(n,e,new Set),e}function SM(n,e,t){if(n==null)return;if(n instanceof mt){e.push(n);return}if(!l9(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),SM(i,e,t))}}function l9(n){return Array.isArray(n)||typeof n=="object"}const u9=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:vM,getTensorsInContainer:Na,isTensorInList:wx,makeTypesMatch:Jt},Symbol.toStringTag,{value:"Module"}));function $S(n){return n.kernelName!=null}class dO{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class zc{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new dO}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(gr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ZX(this.backendInstance),!0}setupRegisteredKernels(){_0(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){_0(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof cb)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,gr(`Initialization of backend ${e} failed`),gr(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return gr(`Initialization of backend ${e} failed`),gr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return zc.nextTensorId++}nextVariableId(){return zc.nextVariableId++}clone(e){const t=W.runKernel(wh,{x:e}),s={x:e},r=a=>({x:()=>{const o="float32",u={x:a},h={dtype:o};return W.runKernel(oh,u,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(Qf(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(u=>{i+=u.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-i-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u;const h=$S(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if($S(e)){const{kernelName:b,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const S=Qf(b,this.backendName);D(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),o=()=>{const C=this.backend.numDataIds();u=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const N=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,C,N);const k=N.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(b,x,k);s=this.saveTensorsForBackwardMode(E)}return k}}else{const{forwardFunc:b}=e,x=w=>{r&&(s=w.map(S=>this.keep(this.clone(S))))};o=()=>{const w=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,x));const S=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,S),S}}const{inputs:d,attrs:p}=e,m=$S(e)?null:e.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(y=this.profiler.profileKernel(h,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),t=y.outputs)}),r&&this.addTapeNode(h,d,t,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=CT(e);if(r!=null){const i=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(D(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(h=>t[h])):o=i.map(h=>t[h]);const u=s.filter((h,d)=>a[d]);return o.concat(u)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&Ri(e[0])&&(i=e.map(u=>Li(u)));const a=r.write(i,t,s),o=new mt(t,s,a,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const u=this.state.tensorInfo.get(a),h=nM(i);this.state.numBytes+=h-u.bytes,u.bytes=h}return o}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,a=new mt(r,i,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new ep(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Kf(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof ep||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Kf(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},u=CT(e);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=h=>(h=h.map((d,p)=>{if(d==null){const m=s[p],y=Yn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],i,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Na(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(D(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(i instanceof mt,()=>"The result y returned by f() must be a tensor.");const a=t9(this.state.activeTape,t,i);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[i.id]=s??c9(i.shape),n9(o,a,h=>this.tidy(h),h9);const u=t.map(h=>o[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(e){return D($o(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{D(t.every(o=>o instanceof mt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((o,u)=>{r[u]=o});const i=(o,u)=>(s=e(...t,u),D(s.value instanceof mt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D($o(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,u)=>{const h=s.gradFunc(o,u),d=Array.isArray(h)?h:[h];D(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(d.every(m=>m instanceof mt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,y)=>{p[y]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Gn(),s=await this.backend.time(e);return s.wallMs=Gn()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new dO;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}zc.nextTensorId=0;zc.nextVariableId=0;function c9(n){const e=db(he(n),"float32");return W.makeTensor(e,n,"float32")}function TM(){const n=oM();if(n._tfengine==null){const e=new aM(n);n._tfengine=new zc(e)}return DX(n._tfengine.ENV),i9(()=>n._tfengine),n._tfengine}const W=TM();function h9(n,e){const t={a:n,b:e};return W.runKernel(du,t)}function d9(){return typeof navigator<"u"&&navigator!=null}let AT;function f9(n){AT=n}function p2(n){if(AT!==void 0)return AT;if(n||d9()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function m2(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const p9=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:m2,isMobile:p2,mockIsMobile:f9},Symbol.toStringTag,{value:"Module"}));const As=ie();As.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});As.registerFlag("IS_BROWSER",()=>m2());As.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");As.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));As.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));As.registerFlag("PROD",()=>!1);As.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>As.getBool("DEBUG"));As.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);As.registerFlag("IS_TEST",()=>!1);As.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>As.getBool("DEBUG"));As.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);As.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);As.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ui(n,e){let t=n;if(kn(n))return e==="string"?[]:[n.length];if(xM(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(wM(n))return[n.buffer.size/(e==null?4:Kf(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||kn(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&CM(n,s,[]),s}function CM(n,e,t){if(t=t||[],!Array.isArray(n)&&!kn(n)){D(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}D(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),D(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)CM(n[r],s,t.concat(r))}function fO(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function M(n,e,t,s="numeric"){if(n instanceof pe())return fO(s,n.dtype,e,t),n;let r=cu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),fO(s,r,e,t),n==null||!kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const i=Ui(n,r);!kn(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?Po(n,r):Vi(n,[],!0);return W.makeTensor(o,i,r)}function tp(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,a)=>M(i,`${e}[${a}]`,t,s))}const g2="__op";function G(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+g2;const r=(...i)=>{W.startScope(t);try{const a=s(...i);return Ta(a)&&console.error("Cannot return a Promise inside of tidy."),W.endScope(a),a}catch(a){throw W.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function m9(n,e){const t=M(n,"real","complex"),s=M(e,"imag","complex");Jn(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return W.runKernel(xb,r)}const ka=G({complex_:m9});function Bo(n,e,t,s){if(s==null)s=cu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(wM(n)||xM(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return W.backend.createTensorFromGPUData(n,e||t,s)}if(!kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){tr(e);const r=he(e),i=he(t);D(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let a=0;a<t.length;++a){const o=t[a],u=a===t.length-1?o!==he(e.slice(a)):!0;D(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!kn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Po(n,s):Vi(n,[],!0),W.makeTensor(n,e,s)}function Ys(n,e,t){const s=Ui(n,t);return Bo(n,e,s,t)}const Hl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class xi{static join(e){return new xi(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>kn(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),a=new Uint8Array(i);let o=0;for(let u=s;u<this.shards.length;u++){const h=this.shards[u],p=e+o-h.start,m=o,b=Math.min(t,h.end)-h.start,x=new Uint8Array(h.buffer,p,b-p);if(a.set(x,m),o+=x.length,t<h.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=g9(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function g9(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}function y9(){ie().set("PROD",!0)}function b9(){ie().set("DEBUG",!0)}function x9(){ie().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function w9(n){ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function v9(){W.disposeVariables()}function oi(){return W}function RT(){return W.memory()}function S9(n){return W.profile(n)}function se(n,e){return W.tidy(n,e)}function Ke(n){Na(n).forEach(t=>t.dispose())}function En(n){return W.keep(n)}function T9(n){return W.time(n)}function NM(n){return W.setBackend(n)}function C9(){return W.ready()}function kM(){return W.backendName}function N9(n){W.removeBackend(n)}function k9(n){return W.findBackend(n)}function E9(n){return W.findBackendFactory(n)}function y2(n,e,t=1){return W.registerBackend(n,e,t)}function b2(){return W.backend}function $9(n,e){ie().setPlatform(n,e)}const Io=4;async function DT(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const o=r[a],u=Array.isArray(n)?n[a].tensor:n[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);const h={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const d=new Promise(async p=>{const m=await u.bytes(),y=m.reduce((w,S)=>w+S.length,0)+Io*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const S=m[w],C=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(C,x),x+=Io,b.set(S,x),x+=S.length}p(b)});s.push(d)}else s.push(u.data());e!=null&&(h.group=e),t.push(h)}const i=await Promise.all(s);return{data:A9(i),specs:t}}function x2(n,e){const t=new xi(n),s={};let r=0;for(const i of e){const a=I9(i,(o,u)=>t.slice(r+o,r+u));s[i.name]=EM(i,t.slice(r,r+a)),r+=a}return s}function I9(n,e){const t=he(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Hl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Io+new Uint32Array(e(r,r+Io))[0];return r}else s=Hl[n.dtype];return t*s}async function _9(n,e){const t=he(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Hl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=Io+new Uint32Array(await e(r,r+Io))[0];return r}else s=Hl[n.dtype];return t*s}function EM(n,e){const t=n.name,s=n.dtype,r=n.shape,i=he(r);let a,o=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=Hl[u.dtype],d=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){a=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];a[p]=m*u.scale+u.min}}else if(u.dtype==="float16")a=M9()(d);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);a=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];a[p]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*h}else if(s==="string"){const u=he(n.shape);a=[];for(let h=0;h<u;h++){const d=new Uint32Array(e.slice(o,o+Io))[0];o+=Io;const p=new Uint8Array(e.slice(o,o+d));a.push(p),o+=d}}else{const u=Hl[s];if(s==="float32")a=new Float32Array(e);else if(s==="int32")a=new Int32Array(e);else if(s==="bool")a=new Uint8Array(e);else if(s==="complex64"){a=new Float32Array(e);const h=new Float32Array(a.length/2),d=new Float32Array(a.length/2);for(let b=0;b<h.length;b++)h[b]=a[b*2],d[b]=a[b*2+1];const p=Ys(h,r,"float32"),m=Ys(d,r,"float32"),y=ka(p,m);return p.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*u}return Ys(a,r,s)}async function pO(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:i}=await n.read();if(r&&i==null){const o=t-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(s.length+i.byteLength);a.set(s,0),a.set(new Uint8Array(i),s.length),s=a}return s.buffer}async function $M(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of e){const a=await _9(i,async(h,d)=>(r=await pO(s,r,d),r.slice(h,d)));r=await pO(s,r,a);const o=r.slice(0,a);r=r.slice(a);const u=EM(i,o);if(t[i.name]=u,kM()==="webgpu"){const h=b2();"uploadToGPU"in h&&he(u.shape)>=ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&h.uploadToGPU(u.dataId)}}return t}function A9(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const w2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function mO(n){return w2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function R9(n){if(w2)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function D9(n){if(w2){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function IM(n){return xi.join(n)}function gO(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function _M(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function v2(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function S2(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),v2(n,t,s)}function Cm(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:mO(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:mO(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new xi(n.weightData).byteLength}}function A0(n){const e=[];for(const t of n)e.push(...t.weights);return e}function O9(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function F9(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function L9(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function M9(){const n=O9(),e=F9(),t=L9();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const o=s[a],u=n[t[o>>10]+(o&1023)]+e[o>>10];i[a]=u}return new Float32Array(r)}}class qt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return qt.instance==null&&(qt.instance=new qt),qt.instance}static registerSaveRouter(e){qt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){qt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return qt.getHandlers(e,"save")}static getLoadHandlers(e,t){return qt.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?qt.getInstance().loadRouters:qt.getInstance().saveRouters).forEach(a=>{const o=a(e,s);o!==null&&r.push(o)}),r}}const z9=n=>qt.registerSaveRouter(n),P9=n=>qt.registerLoadRouter(n),AM=n=>qt.getSaveHandlers(n),RM=(n,e)=>qt.getLoadHandlers(n,e);const OT="tensorflowjs",FT=1,Dl="models_store",yo="model_info_store";function DM(){if(!ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function LT(n){const e=n.result;e.createObjectStore(Dl,{keyPath:"modelPath"}),e.createObjectStore(yo,{keyPath:"modelPath"})}class ql{constructor(e){if(this.indexedDB=DM(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(OT,FT);i.onupgradeneeded=()=>LT(i),i.onsuccess=()=>{const a=i.result;if(t==null){const o=a.transaction(Dl,"readonly"),h=o.objectStore(Dl).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(a.close(),r(h.error)),o.oncomplete=()=>a.close()}else{t.weightData=xi.join(t.weightData);const o=Cm(t),u=a.transaction(yo,"readwrite");let h=u.objectStore(yo),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(m){return r(m)}let p;d.onsuccess=()=>{p=a.transaction(Dl,"readwrite");const m=p.objectStore(Dl);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:o}),y.onerror=b=>{h=u.objectStore(yo);const x=h.delete(this.modelPath);x.onsuccess=()=>(a.close(),r(y.error)),x.onerror=w=>(a.close(),r(y.error))}},d.onerror=m=>(a.close(),r(d.error)),u.oncomplete=()=>{p==null?a.close():p.oncomplete=()=>a.close()}}},i.onerror=a=>r(i.error)})}}ql.URL_SCHEME="indexeddb://";const OM=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ql.URL_SCHEME)?B9(n.slice(ql.URL_SCHEME.length)):null;qt.registerSaveRouter(OM);qt.registerLoadRouter(OM);function B9(n){return new ql(n)}function V9(n){return n.startsWith(ql.URL_SCHEME)?n.slice(ql.URL_SCHEME.length):n}class U9{constructor(){this.indexedDB=DM()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(OT,FT);s.onupgradeneeded=()=>LT(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(yo,"readonly"),o=i.objectStore(yo).getAll();o.onsuccess=()=>{const u={};for(const h of o.result)u[h.modelPath]=h.modelArtifactsInfo;e(u)},o.onerror=u=>(r.close(),t(o.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=V9(e),new Promise((t,s)=>{const r=this.indexedDB.open(OT,FT);r.onupgradeneeded=()=>LT(r),r.onsuccess=()=>{const i=r.result,a=i.transaction(yo,"readwrite"),o=a.objectStore(yo),u=o.get(e);let h;u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=o.delete(e),p=()=>{h=i.transaction(Dl,"readwrite");const y=h.objectStore(Dl).delete(e);y.onsuccess=()=>t(u.result.modelArtifactsInfo),y.onerror=b=>s(u.error)};d.onsuccess=p,d.onerror=m=>(p(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const xa="/",Tc="tensorflowjs_models",FM="info",j9="model_topology",W9="weight_specs",G9="weight_data",H9="model_metadata";function LM(n){return{info:[Tc,n,FM].join(xa),topology:[Tc,n,j9].join(xa),weightSpecs:[Tc,n,W9].join(xa),weightData:[Tc,n,G9].join(xa),modelMetadata:[Tc,n,H9].join(xa)}}function MM(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function q9(n){const e=n.split(xa);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(xa)}function K9(n){return n.startsWith(Kl.URL_SCHEME)?n.slice(Kl.URL_SCHEME.length):n}class Kl{constructor(e){if(!ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=LM(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Cm(e),i=xi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,R9(i));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw MM(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const o=JSON.parse(i);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=D9(a),t}}Kl.URL_SCHEME="localstorage://";const zM=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Kl.URL_SCHEME)?X9(n.slice(Kl.URL_SCHEME.length)):null;qt.registerSaveRouter(zM);qt.registerLoadRouter(zM);function X9(n){return new Kl(n)}class Y9{constructor(){D(ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Tc+xa,s=xa+FM;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const a=q9(i);e[a]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=K9(e);const t=LM(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return MM(t),s}}const Rc="://";class fs{constructor(){this.managers={}}static getInstance(){return fs.instance==null&&(fs.instance=new fs),fs.instance}static registerManager(e,t){D(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Rc)&&(e=e.slice(0,e.indexOf(Rc))),D(e.length>0,()=>"scheme must not be an empty string.");const s=fs.getInstance();D(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=fs.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(fs.getInstance().managers)}}function Zy(n){if(n.indexOf(Rc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fs.getSchemes().join(",")}`);return{scheme:n.split(Rc)[0],path:n.split(Rc)[1]}}async function PM(n,e,t=!1){D(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=qt.getLoadHandlers(n);D(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),D(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=qt.getSaveHandlers(e);D(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),D(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=i[0],o=Zy(n).scheme,u=Zy(n).path,h=o===Zy(n).scheme,d=await r.load();t&&h&&await fs.getManager(o).removeModel(u);const p=await a.save(d);return t&&!h&&await fs.getManager(o).removeModel(u),p.modelArtifactsInfo}async function J9(){const n=fs.getSchemes(),e={};for(const t of n){const s=await fs.getManager(t).listModels();for(const r in s){const i=t+Rc+r;e[i]=s[r]}}return e}async function Z9(n){const e=Zy(n);return fs.getManager(e.scheme).removeModel(e.path)}async function Q9(n,e){return PM(n,e,!1)}async function eY(n,e){return PM(n,e,!0)}class tY{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return hM(e)}}if(ie().get("IS_BROWSER")){ie().setPlatform("browser",new tY);try{fs.registerManager(Kl.URL_SCHEME,new Y9)}catch{}try{fs.registerManager(ql.URL_SCHEME,new U9)}catch{}}const nY={importFetch:()=>require("node-fetch")};let IS;class sY{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ie().global.fetch!=null?ie().global.fetch(e,t):(IS==null&&(IS=nY.importFetch()),IS(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ie().get("IS_NODE")&&!ie().get("IS_BROWSER")&&ie().setPlatform("node",new sY);function Qe(n,e="float32",t){return e=e||"float32",tr(n),new bn(n,e,t)}function rY(n,e){const t=M(n,"x","cast");if(!tM(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return W.runKernel(oh,s,r)}const Ne=G({cast_:rY});function iY(n){const t={x:M(n,"x","clone","string_or_numeric")};return W.runKernel(wh,t)}const Mi=G({clone_:iY});function T2(n,e=!1){console.log(n.toString(e))}TM();const aY={buffer:Qe,cast:Ne,clone:Mi,print:T2};a9(aY);function oY(n,e){let t=M(n,"a","add"),s=M(e,"b","add");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(du,r)}const we=G({add_:oY});function lY(n,e){let t=M(n,"a","floorDiv"),s=M(e,"b","floorDiv");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(bh,r)}const vx=G({floorDiv_:lY});function uY(n,e){let t=M(n,"a","div"),s=M(e,"b","div");if([t,s]=Jt(t,s),t.dtype==="int32"&&s.dtype==="int32")return vx(t,s);const r={a:t,b:s},i={};return W.runKernel(dh,r,i)}const Oe=G({div_:uY});function cY(n,e){let t=M(n,"a","mul"),s=M(e,"b","mul");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(Ih,r)}const K=G({mul_:cY});function hY(n){const e=M(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return W.runKernel(Ip,t)}else{const t={x:e};return W.runKernel(wp,t)}}const mn=G({abs_:hY});function dY(n){const t={x:M(n,"x","acos")};return W.runKernel(eh,t)}const C2=G({acos_:dY});function fY(n){const t={x:M(n,"x","acosh")};return W.runKernel(th,t)}const N2=G({acosh_:fY});function pY(n){D(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),D(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>M(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!it(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return W.runKernel(vp,s)}const BM=G({addN_:pY});function mY(n,e=null,t=!1){const r={x:M(n,"x","all","bool")},i={axis:e,keepDims:t};return W.runKernel(fb,r,i)}const Sx=G({all_:mY});function gY(n,e=null,t=!1){const r={x:M(n,"x","any","bool")},i={axis:e,keepDims:t};return W.runKernel(pb,r,i)}const np=G({any_:gY});function yY(n,e=0){const s={x:M(n,"x","argMax")},r={axis:e};return W.runKernel(Sp,s,r)}const Xl=G({argMax_:yY});function bY(n,e=0){const s={x:M(n,"x","argMin")},r={axis:e};return W.runKernel(Tp,s,r)}const k2=G({argMin_:bY});function xY(n){const t={x:M(n,"x","asin")};return W.runKernel(nh,t)}const E2=G({asin_:xY});function wY(n){const t={x:M(n,"x","asinh")};return W.runKernel(sh,t)}const $2=G({asinh_:wY});function vY(n){const t={x:M(n,"x","atan")};return W.runKernel(rh,t)}const I2=G({atan_:vY});function SY(n,e){let t=M(n,"a","atan2"),s=M(e,"b","atan2");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(ah,r)}const _2=G({atan2_:SY});function TY(n){const t={x:M(n,"x","atanh")};return W.runKernel(ih,t)}const A2=G({atanh_:TY});function Nm(n,e,t,s,r="NHWC",i){const a=n[3],o=[...e,a],u=Fa(r);return Vn(n,o,t,i,s,null,null,u)}function Hr(n,e,t,s,r,i,a="channelsLast"){const[o,u]=sp(e);let h;if(a==="channelsLast")h=[o,u,n[3],n[3]];else if(a==="channelsFirst")h=[o,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Vn(n,h,t,s,r,i,!1,a)}function Oa(n,e,t,s,r,i,a="NDHWC"){const[o,u,h]=MT(e);let d,p;if(a==="NDHWC")p="channelsLast",d=[o,u,h,n[4],n[4]];else if(a==="NCDHW")p="channelsFirst",d=[o,u,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Vo(n,d,t,s,r,!1,p,i)}function Vn(n,e,t,s,r,i,a=!1,o="channelsLast"){let[u,h,d,p]=[-1,-1,-1,-1];if(o==="channelsLast")[u,h,d,p]=n;else if(o==="channelsFirst")[u,p,h,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,y,,b]=e,[x,w]=sp(t),[S,C]=sp(s),N=Dc(m,S),k=Dc(y,C),{padInfo:E,outHeight:_,outWidth:R}=kY(r,h,d,x,w,N,k,i,o),O=a?b*p:b;let F;return o==="channelsFirst"?F=[u,O,_,R]:o==="channelsLast"&&(F=[u,_,R,O]),{batchSize:u,dataFormat:o,inHeight:h,inWidth:d,inChannels:p,outHeight:_,outWidth:R,outChannels:O,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:N,effectiveFilterWidth:k,dilationHeight:S,dilationWidth:C,inShape:n,outShape:F,filterShape:e}}function Vo(n,e,t,s,r,i=!1,a="channelsLast",o){let[u,h,d,p,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,h,d,p,m]=n;else if(a==="channelsFirst")[u,m,h,d,p]=n;else throw new Error(`Unknown dataFormat ${a}`);const[y,b,x,,w]=e,[S,C,N]=MT(t),[k,E,_]=MT(s),R=Dc(y,k),O=Dc(b,E),F=Dc(x,_),{padInfo:L,outDepth:A,outHeight:U,outWidth:Y}=EY(r,h,d,p,S,C,N,R,O,F,o),te=i?w*m:w;let Z;return a==="channelsFirst"?Z=[u,te,A,U,Y]:a==="channelsLast"&&(Z=[u,A,U,Y,te]),{batchSize:u,dataFormat:a,inDepth:h,inHeight:d,inWidth:p,inChannels:m,outDepth:A,outHeight:U,outWidth:Y,outChannels:te,padInfo:L,strideDepth:S,strideHeight:C,strideWidth:N,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:R,effectiveFilterHeight:O,effectiveFilterWidth:F,dilationDepth:k,dilationHeight:E,dilationWidth:_,inShape:n,outShape:Z,filterShape:e}}function CY(n,e,t,s,r){s==null&&(s=R2(n,e,t));const i=n[0],a=n[1],o=rp((i-e+2*s)/t+1,r),u=rp((a-e+2*s)/t+1,r);return[o,u]}function NY(n,e,t,s,r,i){r==null&&(r=R2(n,e[0],s[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*r>=e[o]&&(a[o]=rp((n[o]-e[o]+2*r)/s[o]+1,i));return a}function R2(n,e,t,s=1){const r=Dc(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function sp(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function MT(n){return typeof n=="number"?[n,n,n]:n}function Dc(n,e){return e<=1?n:n+(n-1)*(e-1)}function kY(n,e,t,s,r,i,a,o,u){let h,d,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=CY([e,t],i,s,n,o);d=y[0],p=y[1]}else if(n==="same"){d=Math.ceil(e/s),p=Math.ceil(t/r);const m=Math.max(0,(d-1)*s+i-e),y=Math.max(0,(p-1)*r+a-t),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),S=y-w;h={top:b,bottom:x,left:w,right:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-i+1)/s),p=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],y=u==="channelsLast"?n[1][1]:n[2][1],b=u==="channelsLast"?n[2][0]:n[3][0],x=u==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=rp((e-i+m+y)/s+1,o),p=rp((t-a+b+x)/r+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:p}}function EY(n,e,t,s,r,i,a,o,u,h,d){let p,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=NY([e,t,s,1],[o,u,h],1,[r,i,a],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(e/r),y=Math.ceil(t/i),b=Math.ceil(s/a);const x=(m-1)*r+o-e,w=(y-1)*i+u-t,S=(b-1)*a+h-s,C=Math.floor(x/2),N=x-C,k=Math.floor(w/2),E=w-k,_=Math.floor(S/2),R=S-_;p={top:k,bottom:E,left:_,right:R,front:C,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:y,outWidth:b}}function rp(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function _o(n){const[e,t,s]=sp(n);return e===1&&t===1&&s===1}function Zn(n,e){return _o(n)||_o(e)}function Yl(n){return sp(n).every(e=>e>0)}function Fa(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ws(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")D(Gl(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{D(Gl(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function $Y(n,e){const s={x:M(n,"x","reshape","string_or_numeric")},r={shape:e};return W.runKernel(um,s,r)}const X=G({reshape_:$Y});function IY(n,e,t,s,r){const i=M(n,"x","avgPool","float32"),a=1;D(Zn(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=i,u=!1;i.rank===3&&(u=!0,o=X(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ws("avgPool",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let p=W.runKernel(Cp,h,d);return p=Ne(p,i.dtype),u?X(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const km=G({avgPool_:IY});function _Y(n,e,t,s,r,i="NDHWC"){const a=M(n,"x","avgPool3d","float32");let o=a,u=!1;a.rank===4&&(u=!0,o=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),D(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),D(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ws("avgPool3d",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let p=W.runKernel(Np,h,d);return p=Ne(p,o.dtype),u?X(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const D2=G({avgPool3d_:_Y});function AY(n,e=0){D(n.length>=1,()=>"Pass at least one tensor to concat");const t=tp(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return Mi(t[0]);const s=t,r={axis:e};return W.runKernel(_p,s,r)}const ln=G({concat_:AY});function RY(n,e,t=!1,s=!1){let r=M(n,"a","matMul"),i=M(e,"b","matMul");[r,i]=Jt(r,i);const a={a:r,b:i},o={transposeA:t,transposeB:s};return W.runKernel(kp,a,o)}const nt=G({matMul_:RY});function DY(n){const t={x:M(n,"x","sigmoid","float32")};return W.runKernel(Bh,t)}const di=G({sigmoid_:DY});function OY(n,e,t){const s=M(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return W.runKernel(pm,r,i)}const ut=G({slice_:OY});function FY(n){const t={x:M(n,"x","tanh","float32")};return W.runKernel(Hh,t)}const Ao=G({tanh_:FY});function LY(n,e,t,s,r,i){const a=M(n,"forgetBias","basicLSTMCell"),o=M(e,"lstmKernel","basicLSTMCell"),u=M(t,"lstmBias","basicLSTMCell"),h=M(s,"data","basicLSTMCell"),d=M(r,"c","basicLSTMCell"),p=M(i,"h","basicLSTMCell"),m=ln([h,p],1),y=nt(m,o),b=we(y,u),x=b.shape[0],w=b.shape[1]/4,S=[x,w],C=ut(b,[0,0],S),N=ut(b,[0,w],S),k=ut(b,[0,w*2],S),E=ut(b,[0,w*3],S),_=we(K(di(C),Ao(N)),K(d,di(we(a,k)))),R=K(Ao(_),di(E));return[_,R]}const VM=G({basicLSTMCell_:LY});function MY(n,e,t){const s=M(n,"x","batchToSpaceND"),r=e.reduce((o,u)=>o*u);D(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),D(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),D(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},a={blockShape:e,crops:t};return W.runKernel(Ep,i,a)}const Em=G({batchToSpaceND_:MY});function zY(n){let e;return n.rank===0||n.rank===1?e=X(n,[1,1,1,n.size]):n.rank===2?e=X(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=X(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function PY(n,e,t,s,r,i){i==null&&(i=.001);const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),u=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;s!=null&&(d=M(s,"offset","batchNorm")),D(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:zY(a),scale:h,offset:d,mean:o,variance:u},y={varianceEpsilon:i},b=W.runKernel(Pp,m,y);return X(b,a.shape)}const Xh=G({batchNorm_:PY});function BY(n,e,t,s,r,i){const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),u=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),D(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),D(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),h!=null&&D(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&D(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),Xh(a,o,u,d,h,i)}const O2=G({batchNorm2d_:BY});function VY(n,e,t,s,r,i){const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),u=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),D(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),D(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),h!=null&&D(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&D(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),Xh(a,o,u,d,h,i)}const F2=G({batchNorm3d_:VY});function UY(n,e,t,s,r,i){const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),u=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),D(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),D(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),h!=null&&D(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&D(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),Xh(a,o,u,d,h,i)}const L2=G({batchNorm4d_:UY});function jY(n,e,t){const s=M(n,"x","bincount"),r=M(e,"weights","bincount");D(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},a={size:t};return W.runKernel(yb,i,a)}const M2=G({bincount_:jY});function WY(n,e){const t=M(n,"x","bitwiseAnd"),s=M(e,"y","bitwiseAnd");if(!it(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return W.runKernel($p,r)}const UM=G({bitwiseAnd_:WY});function GY(n,e){const t=M(n,"s0","broadcastArgs","int32"),s=M(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return W.runKernel(bb,r)}const jM=G({broadcastArgs_:GY});function HY(n,e){let t=M(n,"broadcastTo","x");const s=t.shape;if(tr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=X(t,h)}const r=t.shape,i=Array.from(e);for(let h=e.length-1;h>=0;h--)if(r[h]===e[h])i[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Mi(t);const o={x:t},u={reps:i};return W.runKernel(qh,o,u)}const Vl=G({broadcastTo_:HY});function qY(n){const t={x:M(n,"x","ceil","float32")};return W.runKernel(lh,t)}const z2=G({ceil_:qY});function fu(n,e,t){tr(n),t=t||cu(e);const s={shape:n,value:e,dtype:t};return W.runKernel(Ob,{},s)}function KY(n,e,t){const s=M(n,"x","clipByValue");if(D(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return fu(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return W.runKernel(uh,r,i)}const Rs=G({clipByValue_:KY});function XY(n){return ln(n,0)}const P2=G({concat1d_:XY});function YY(n,e){return ln(n,e)}const B2=G({concat2d_:YY});function JY(n,e){return ln(n,e)}const V2=G({concat3d_:JY});function ZY(n,e){return ln(n,e)}const U2=G({concat4d_:ZY});function QY(n,e,t,s,r="NHWC",i=[1,1],a){const o=M(n,"x","conv2d","float32"),u=M(e,"filter","conv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),D(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ws("conv2d",s,a);const p=r==="NHWC"?h.shape[3]:h.shape[1];D(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),D(Zn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),D(Yl(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),D(Yl(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:u},y={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},b=W.runKernel(Ap,m,y);return d?X(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Ea=G({conv2d_:QY});function eJ(n,e,t,s,r="NWC",i=1,a){const o=M(n,"x","conv1d"),u=M(e,"filter","conv1d");let h=o,d=!1;o.rank===2&&(d=!0,h=X(o,[1,o.shape[0],o.shape[1]])),D(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),D(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ws("conv1d",s,a),D(h.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${u.shape[1]}.`),D(Zn(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),D(Yl(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),D(Yl(t),()=>"Error in conv1D: Stride should be larger than 0."),D(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=X(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=X(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=Ea(m,p,[1,t],s,"NHWC",[1,i],a);return d?X(w,[w.shape[2],w.shape[3]]):X(w,[w.shape[0],w.shape[2],w.shape[3]])}const Tx=G({conv1d_:eJ});function tJ(n,e,t,s,r,i="NHWC",a){D(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,u=e,h=!1;e.rank===3&&(h=!0,u=X(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),D(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),D(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),D(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=i==="NHWC"?o[3]:o[1],p=i==="NHWC"?u.shape[3]:u.shape[1];D(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),D(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),ws("conv2dDerInput",r,a);const m={dy:u,filter:t},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o},b=W.runKernel(Rp,m,y);return h?X(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const j2=G({conv2DBackpropInput_:tJ});function nJ(n,e,t,s,r,i){const a=M(n,"x","conv2dTranspose"),o=M(e,"filter","conv2dTranspose");return j2(t,a,o,s,r,"NHWC",i)}const Cx=G({conv2dTranspose_:nJ});function sJ(n,e,t,s,r="NDHWC",i=[1,1,1]){const a=M(n,"x","conv3d"),o=M(e,"filter","conv3d");let u=a,h=!1;a.rank===4&&(h=!0,u=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),D(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),D(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),D(Zn(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),D(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),D(Yl(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),D(Yl(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:u,filter:o},p={strides:t,pad:s,dataFormat:r,dilations:i},m=W.runKernel(Dp,d,p);return h?X(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const W2=G({conv3d_:sJ});function rJ(n,e,t,s,r){D(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,a=e,o=!1;e.rank===4&&(o=!0,a=X(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const u=i[4],h=a.shape[4];D(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),D(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),D(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),D(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),D(h===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[4]}.`);const d={dy:a,filter:t},p={pad:r,strides:s,inputShape:i},m=W.runKernel(Sb,d,p);return o?X(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const WM=G({conv3DBackpropInput_:rJ});function iJ(n,e,t,s,r){const i=M(n,"x","conv3dTranspose"),a=M(e,"filter","conv3dTranspose");return WM(t,i,a,s,r)}const G2=G({conv3dTranspose_:iJ});function aJ(n){const t={x:M(n,"x","cos","float32")};return W.runKernel(ch,t)}const $m=G({cos_:aJ});function oJ(n){const t={x:M(n,"x","cosh","float32")};return W.runKernel(hh,t)}const Nx=G({cosh_:oJ});function lJ(n,e=0,t=!1,s=!1){const i={x:M(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return W.runKernel(Tb,i,a)}const ip=G({cumprod_:lJ});function uJ(n,e=0,t=!1,s=!1){const i={x:M(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return W.runKernel(Op,i,a)}const kx=G({cumsum_:uJ});function cJ(n,e,t,s=!1){const r=M(n,"x","denseBincount"),i=M(e,"weights","denseBincount");D(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),D(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const a={x:r,weights:i},o={size:t,binaryOutput:s};return W.runKernel(Nb,a,o)}const R0=G({denseBincount_:cJ});function hJ(n,e,t="NHWC"){const s=M(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];D(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),D(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),D(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),D(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},u={blockSize:e,dataFormat:t};return W.runKernel(kb,o,u)}const H2=G({depthToSpace_:hJ});function dJ(n,e,t,s,r="NHWC",i=[1,1],a){const o=M(n,"x","depthwiseConv2d","float32"),u=M(e,"filter","depthwiseConv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),D(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const p=r==="NHWC"?h.shape[3]:h.shape[1];D(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),ws("depthwiseConv2d",s,a);const m={x:h,filter:u},y={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},b=W.runKernel(Fp,m,y);return d?X(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Yh=G({depthwiseConv2d_:dJ});function fJ(n){const t={x:M(n,"x","diag")};return W.runKernel(Ib,t)}const GM=G({diag_:fJ});function pJ(n,e,t,s,r=[1,1],i="NHWC"){const a=M(n,"x","dilation2d"),o=M(e,"filter","dilation2d");D(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),D(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),D(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let u=a,h=!1;a.rank===3&&(u=X(a,[1,a.shape[0],a.shape[1],a.shape[2]]),h=!0),D(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const d={x:u,filter:o},p={strides:t,pad:s,dilations:r},m=W.runKernel(Lp,d,p);return h?X(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const q2=G({dilation2d_:pJ});function Jl(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,a=n[i]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(i)}return s}function xn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,a=e[i];(r==null||r===1&&a>1)&&t.unshift(i)}return t}function Xe(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let a=e[e.length-r-1];if(a==null&&(a=1),i===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=i;else if(i!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else s[t-r-1]=i}return s}const mJ=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Xe,getBroadcastDims:Jl,getReductionAxes:xn},Symbol.toStringTag,{value:"Module"}));function gJ(n,e){let t=M(n,"a","equal","string_or_numeric"),s=M(e,"b","equal","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Mp,r)}const Js=G({equal_:gJ});function yJ(n,e,t){const s=M(e,"a","where"),r=M(t,"b","where"),i=M(n,"condition","where","bool"),a=Xe(Xe(i.shape,s.shape),r.shape),o=Vl(i,a),u=Vl(s,a),h=Vl(r,a),d={condition:o,t:u,e:h};return W.runKernel(fm,d)}const Mn=G({where_:yJ});function bJ(n){const t={x:M(n,"x","zerosLike")};return W.runKernel(Sm,t)}const ct=G({zerosLike_:bJ});function xJ(n,e){let t=M(n,"a","div"),s=M(e,"b","div");[t,s]=Jt(t,s);const r=Oe(t,s),i=ct(r),a=Js(s,i);return Mn(a,i,r)}const K2=G({divNoNan_:xJ});function wJ(n,e){const t=M(n,"t1","dot"),s=M(e,"t2","dot");D((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(D(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const a=X(t,[1,-1]),o=X(s,[-1,1]),u=nt(a,o);return X(u,[])}else if(t.rank===1&&s.rank===2){const a=X(t,[1,-1]),o=X(s,[s.shape[0],s.shape[1]]),u=nt(a,o);return X(u,[u.size])}else if(t.rank===2&&s.rank===1){const a=X(s,[-1,1]),o=nt(t,a);return X(o,[o.size])}else{const a=X(s,[s.shape[0],s.shape[1]]);return nt(t,a)}}const X2=G({dot_:wJ});function vJ(n,...e){const t=e.map((r,i)=>M(r,`tensors${i}`,"einsum")),s={equation:n};return W.runKernel(Ab,t,s)}const kl=G({einsum_:vJ});function SJ(n){const t={x:M(n,"x","elu","float32")};return W.runKernel(fh,t)}const Jh=G({elu_:SJ});function TJ(n,e){const t=M(n,"x","ensureShape","string_or_numeric");if(!QL(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const HM=G({ensureShape_:TJ});function CJ(n){let e=M(n,"x","erf");D(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ne(e,"float32"));const t={x:e};return W.runKernel(ph,t)}const Ex=G({erf_:CJ});function Y2(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function qM(n,e,t){const s=n.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?r.push(n[i++]):r.push(e[a++]);return r}function Un(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function un(n,e){const t=e.map(s=>1);return qM(n,t,e)}function Qn(n,e,t){D(Y2(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Zt(n,e){if(Y2(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Uo(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function cn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function NJ(n,e=null,t=!1){const r={x:M(n,"x","max")},i={reductionIndices:e,keepDims:t};return W.runKernel(Xp,r,i)}const Sr=G({max_:NJ});function kJ(n,e=null,t=!1){const r={x:M(n,"x","min")},i={axis:e,keepDims:t};return W.runKernel(Qp,r,i)}const Pc=G({min_:kJ});function EJ(n,e){let t=M(n,"base","pow"),s=M(e,"exp","pow");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(_h,r)}const ji=G({pow_:EJ});function Me(n,e){if((kn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&kn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Bo(n,[],[],e)}function $J(n){const t={x:M(n,"x","sqrt","float32")};return W.runKernel(Uh,t)}const Pn=G({sqrt_:$J});function IJ(n){const e=M(n,"x","square"),t={};return W.runKernel("Square",{x:e},t)}const $t=G({square_:IJ});function _J(n,e=null,t=!1){let s=M(n,"x","sum");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return W.runKernel(mm,r,i)}const Ae=G({sum_:_J});function AJ(n,e="euclidean",t=null,s=!1){n=M(n,"x","norm");const r=KM(n,e,t);let i=r.shape;if(s){const a=st(t,n.shape);i=un(r.shape,a)}return X(r,i)}function KM(n,e,t=null){if(n.rank===0)return mn(n);if(n.rank!==1&&t===null)return KM(X(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ae(mn(n),t);if(e===1/0)return Sr(mn(n),t);if(e===-1/0)return Pc(mn(n),t);if(e==="euclidean"||e===2)return Pn(Ae(ji(mn(n),Me(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Sr(Ae(mn(n),t[0]),t[1]-1);if(e===1/0)return Sr(Ae(mn(n),t[1]),t[0]);if(e===-1/0)return Pc(Ae(mn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Pn(Ae($t(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Zh=G({norm_:AJ});function RJ(n,e=null,t=!1){return Zh(n,"euclidean",e,t)}const J2=G({euclideanNorm_:RJ});function DJ(n){const t={x:M(n,"x","exp")};return W.runKernel(mh,t)}const Ds=G({exp_:DJ});function OJ(n,e=0){const t=M(n,"x","expandDims","string_or_numeric");D(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return W.runKernel(zp,s,r)}const Hn=G({expandDims_:OJ});function FJ(n){const t={x:M(n,"x","expm1")};return W.runKernel(gh,t)}const Z2=G({expm1_:FJ});function LJ(n,e){const t=M(n,"x","tile","string_or_numeric");D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return W.runKernel(qh,s,r)}const br=G({tile_:LJ});function MJ(n,e,t,s="float32"){e==null&&(e=n);const r=Qe([n,e],s),i=n<=e?n:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=X(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return br(Hn(a,0),[t[0],1,1]);if(t.length===2)return br(Hn(Hn(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return br(Hn(Hn(Hn(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const $x=G({eye_:MJ});function zJ(n){const t={x:M(n,"x","floor","float32")};return W.runKernel(yh,t)}const Qh=G({floor_:zJ});function PJ(n,e,t=0,s=0){const r=M(n,"x","gather"),i=M(e,"indices","gather","int32"),a={x:r,indices:i},o={axis:t,batchDims:s};return W.runKernel(Bp,a,o)}const ed=G({gather_:PJ});function BJ(n,e){let t=M(n,"a","greater","string_or_numeric"),s=M(e,"b","greater","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Vp,r)}const vs=G({greater_:BJ});function VJ(n,e){let t=M(n,"a","greaterEqual","string_or_numeric"),s=M(e,"b","greaterEqual","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(xh,r)}const La=G({greaterEqual_:VJ});function UJ(n){const t={input:M(n,"input","imag")};return W.runKernel(zb,t)}const Im=G({imag_:UJ});function jJ(n){const t={x:M(n,"x","isFinite")};return W.runKernel(vh,t)}const Q2=G({isFinite_:jJ});function WJ(n){const t={x:M(n,"x","isInf")};return W.runKernel(Sh,t)}const eN=G({isInf_:WJ});function GJ(n){const t={x:M(n,"x","isNaN")};return W.runKernel(Th,t)}const tN=G({isNaN_:GJ});function HJ(n,e=.2){const s={x:M(n,"x","leakyRelu")},r={alpha:e};return W.runKernel(Up,s,r)}const _m=G({leakyRelu_:HJ});function qJ(n,e){let t=M(n,"a","less","string_or_numeric"),s=M(e,"b","less","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(jp,r)}const Bc=G({less_:qJ});function KJ(n,e){let t=M(n,"a","lessEqual","string_or_numeric"),s=M(e,"b","lessEqual","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Wp,r)}const jo=G({lessEqual_:KJ});function XM(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return W.runKernel(Pb,{},s)}function XJ(n,e=5,t=1,s=1,r=.5){const i=M(n,"x","localResponseNormalization");D(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),D(Gl(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;i.rank===3&&(o=!0,a=X(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={x:a},h={depthRadius:e,bias:t,alpha:s,beta:r},d=W.runKernel(Kp,u,h);return o?X(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const nN=G({localResponseNormalization_:XJ});function YJ(n){const t={x:M(n,"x","log","float32")};return W.runKernel(Ch,t)}const Zs=G({log_:YJ});function JJ(n){const t={x:M(n,"x","log1p")};return W.runKernel(Nh,t)}const Am=G({log1p_:JJ});function ZJ(n){return D($o(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=M(e,"x","tf.grad","string_or_numeric"),r=t!=null?M(t,"dy","tf.grad"):null;return W.tidy(()=>{const{value:i,grads:a}=W.gradients(()=>n(s),[s],r);return r!=null&&Jn(i.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Ix(a),a[0]})}}function QJ(n){return D($o(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{D(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=tp(e,"args","tf.grads","string_or_numeric"),r=t!=null?M(t,"dy","tf.grads"):null;return W.tidy(()=>{const{value:i,grads:a}=W.gradients(()=>n(...s),s,r);return r!=null&&Jn(i.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ix(a),a})}}function eZ(n){return D($o(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{D(e instanceof mt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(t==null||t instanceof mt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=W.gradients(()=>n(e),[e],t);return Ix(s),{grad:s[0],value:r}}}function tZ(n){return D($o(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{D(Array.isArray(e)&&e.every(r=>r instanceof mt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(t==null||t instanceof mt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=W.gradients(()=>n(...e),e,t);return t!=null&&Jn(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ix(s.grads),s}}function YM(n,e){D($o(n),()=>"The f passed in variableGrads(f) must be a function"),D(e==null||Array.isArray(e)&&e.every(h=>h instanceof ep),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const h in W.registeredVariables)e.push(W.registeredVariables[h])}const s=t?e.filter(h=>!h.trainable):null,r=e.length;e=e.filter(h=>h.trainable),D(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:a,grads:o}=W.gradients(n,e,null,i);D(o.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const u={};return e.forEach((h,d)=>{o[d]!=null&&(u[h.name]=o[d])}),s?.forEach(h=>u[h.name]=null),{value:a,grads:u}}function Wi(n){return W.customGrad(n)}function Ix(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function nZ(n){const t={x:M(n,"x","neg")};return W.runKernel(tm,t)}const Mt=G({neg_:nZ});function sZ(n){const t={x:M(n,"x","softplus")};return W.runKernel(Vh,t)}const pu=G({softplus_:sZ});function rZ(n){const e=M(n,"x","logSigmoid");return Wi(s=>({value:Mt(pu(Mt(s))),gradFunc:a=>K(a,di(Mt(s)))}))(e)}const sN=G({logSigmoid_:rZ});function iZ(n,e){let t=M(n,"a","sub"),s=M(e,"b","sub");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(Wh,r)}const _e=G({sub_:iZ});function aZ(n,e=-1){const t=M(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Wi((r,i)=>{const o=Sr(r,e,!0),u=_e(r,o),h=_e(Ne(u,"float32"),Zs(Ae(Ds(u),e,!0)));return i([h]),{value:h,gradFunc:(p,m)=>{const[y]=m,b=!0,x=Ds(y);return _e(p,K(Ae(p,e,b),x))}}})(t)}const _x=G({logSoftmax_:aZ});function oZ(n,e=null,t=!1){const s=M(n,"x","logSumExp"),r=st(e,s.shape),i=Sr(s,r,!0),a=_e(s,i),o=Ds(a),u=Ae(o,r),h=Zs(u),d=we(X(i,h.shape),h);if(t){const p=un(d.shape,r);return X(d,p)}return d}const Rm=G({logSumExp_:oZ});function lZ(n,e){const t=M(n,"a","logicalAnd","bool"),s=M(e,"b","logicalAnd","bool");Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Gp,r)}const Gr=G({logicalAnd_:lZ});function uZ(n){const t={x:M(n,"x","logicalNot","bool")};return W.runKernel(Hp,t)}const Dm=G({logicalNot_:uZ});function cZ(n,e){const t=M(n,"a","logicalOr","bool"),s=M(e,"b","logicalOr","bool");Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(qp,r)}const Ax=G({logicalOr_:cZ});function hZ(n,e){const t=M(n,"a","logicalXor","bool"),s=M(e,"b","logicalXor","bool");return Xe(t.shape,s.shape),Gr(Ax(n,e),Dm(Gr(n,e)))}const rN=G({logicalXor_:hZ});const Dy=2147483648;function dZ(n,e,t="left"){const s=M(n,"sortedSequence","searchSorted"),r=M(e,"values","searchSorted"),i=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],o=X(s,[-1,i]),u=X(r,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(he(u.shape)>=Dy)throw new Error(`values tensor size must less than ${Dy}`);if(o.shape[1]>=Dy)throw new Error(`trailing dim_size must less than ${Dy} for int32 output type, was ${o.shape[1]}`);const h={sortedSequence:o,values:u},d={side:t};return W.runKernel(sx,h,d)}const Rx=G({searchSorted_:dZ});function JM(n,e){return Rx(n,e,"left")}function fZ(n,e,t,s,r){const i=M(n,"x","maxPool"),a=1;let o=i,u=!1;i.rank===3&&(u=!0,o=X(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),D(Zn(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ws("maxPool",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r},p=W.runKernel(Yp,h,d);return u?X(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Om=G({maxPool_:fZ});function pZ(n,e=[1,1,1],t,s,r,i="NDHWC"){const a=M(n,"x","maxPool3d");let o=a,u=!1;a.rank===4&&(u=!0,o=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),D(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ws("maxPool3d",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},p=W.runKernel(Jp,h,d);return u?X(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const iN=G({maxPool3d_:pZ});function mZ(n,e,t,s,r=!1){const a={x:M(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},u=W.runKernel(jb,a,o);return{result:u[0],indexes:u[1]}}const ZM=G({maxPoolWithArgmax_:mZ});function gZ(n,e){let t=M(n,"a","maximum"),s=M(e,"b","maximum");[t,s]=Jt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(kh,r)}const qi=G({maximum_:gZ});function yZ(n,e=null,t=!1){const r={x:M(n,"x","mean")},i={axis:e,keepDims:t};return W.runKernel(Zp,r,i)}const Kt=G({mean_:yZ});function gn(n,e="float32"){if(tr(n),e==="complex64"){const s=gn(n,"float32"),r=gn(n,"float32");return ka(s,r)}const t=Yn(he(n),e);return W.makeTensor(t,n,e)}function $s(n,e="float32"){if(tr(n),e==="complex64"){const s=$s(n,"float32"),r=gn(n,"float32");return ka(s,r)}const t=db(he(n),e);return W.makeTensor(t,n,e)}function QM(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=M(n,"x","meshgrid",n instanceof mt?n.dtype:"float32");if(e===void 0)return[s];let r=M(e,"y","meshgrid",e instanceof mt?e.dtype:"float32");const i=he(s.shape),a=he(r.shape);return t==="xy"?(s=X(s,[1,-1]),r=X(r,[-1,1]),[nt($s([a,1],s.dtype),s),nt(r,$s([1,i],r.dtype))]):(s=X(s,[-1,1]),r=X(r,[1,-1]),[nt(s,$s([1,a],s.dtype)),nt($s([i,1],r.dtype),r)])}function bZ(n,e){let t=M(n,"a","minimum"),s=M(e,"b","minimum");[t,s]=Jt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Eh,r)}const Ro=G({minimum_:bZ});function xZ(n,e,t){D(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=M(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)D(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},a={x:s};return W.runKernel(em,a,i)}const aN=G({mirrorPad_:xZ});function wZ(n,e){let t=M(n,"a","mod"),s=M(e,"b","mod");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel($h,r)}const oN=G({mod_:wZ});function vZ(n,e=null,t=!1){n=M(n,"x","moments");const s=st(e,n.shape),r=Kt(n,s,t);let i=r.shape;t||(i=un(r.shape,s));const a=$t(_e(Ne(n,"float32"),X(r,i))),o=Kt(a,s,t);return{mean:r,variance:o}}const Fm=G({moments_:vZ});function SZ(n,e,t,s){const r=M(e,"data","multiRNNCell"),i=tp(t,"c","multiRNNCell"),a=tp(s,"h","multiRNNCell");let o=r;const u=[];for(let p=0;p<n.length;p++){const m=n[p](o,i[p],a[p]);u.push(m[0]),u.push(m[1]),o=m[1]}const h=[],d=[];for(let p=0;p<u.length;p+=2)h.push(u[p]),d.push(u[p+1]);return[h,d]}const ez=G({multiRNNCell_:SZ});function TZ(n,e,t,s=!1){const r=M(n,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const u={logits:a===1?X(r,[1,-1]):r},h={numSamples:e,seed:t,normalized:s},d=W.runKernel(Wb,u,h);return a===1?X(d,[d.size]):d}const tz=G({multinomial_:TZ});function CZ(n,e){let t=M(n,"a","notEqual","string_or_numeric"),s=M(e,"b","notEqual","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(nm,r)}const Zl=G({notEqual_:CZ});function NZ(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:M(n,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:t,offValue:s};return W.runKernel(rm,a,o)}const Vc=G({oneHot_:NZ});function kZ(n){const t={x:M(n,"x","onesLike")};return W.runKernel(sm,t)}const Qs=G({onesLike_:kZ});function EZ(n,e){const t=M(n,"v1","outerProduct"),s=M(e,"v2","outerProduct");D(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=X(t,[-1,1]),i=X(s,[1,-1]);return nt(r,i)}const nz=G({outerProduct_:EZ});function $Z(n,e,t=0){const s=M(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return W.runKernel(am,i,r)}const Ma=G({pad_:$Z});function IZ(n,e,t=0){return D(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ma(n,[e],t)}const sz=G({pad1d_:IZ});function _Z(n,e,t=0){return D(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ma(n,e,t)}const rz=G({pad2d_:_Z});function AZ(n,e,t=0){return D(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ma(n,e,t)}const iz=G({pad3d_:AZ});function RZ(n,e,t=0){return D(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ma(n,e,t)}const az=G({pad4d_:RZ});function DZ(n,e,t){const s=M(n,"x","spaceToBatchND");D(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),D(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),D(s.shape.reduce((a,o,u)=>u>0&&u<=e.length?a&&(o+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return W.runKernel(gm,r,i)}const Lm=G({spaceToBatchND_:DZ});function OZ(n,e,t,s,r,i,a){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const o=M(n,"x","maxPool");let u=o,h=!1;o.rank===3&&(h=!0,u=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),D(Zn(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=Hr(u.shape,e,i,r,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=LZ([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const y=p[0]===1&&p[1]===1,[b,x]=FZ([d.inHeight,d.inWidth],p,m),w=y?s:"valid",S=y?u:Lm(u,p,b),N=(t==="avg"?()=>km(S,e,i,w,a):()=>Om(S,e,i,w,a))(),k=y?N:Em(N,p,x);return h?X(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function FZ(n,e,t){const s=t.map(d=>d[0]),r=t.map(d=>d[1]),i=n.concat(s,r),a=e.map((d,p)=>(d-i[p]%d)%d),o=r.map((d,p)=>d+a[p]),u=e.map((d,p)=>[s[p],o[p]]),h=e.map((d,p)=>[0,a[p]]);return[u,h]}function LZ(n,e){const s=n.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),i=s.map((a,o)=>a-r[o]);return s.map((a,o)=>[r[o],i[o]])}const lN=G({pool_:OZ});function MZ(n,e){const t=M(n,"x","prelu"),s=M(e,"alpha","prelu"),r={x:t,alpha:s};return W.runKernel(om,r)}const Mm=G({prelu_:MZ});function zZ(n,e=null,t=!1){let s=M(n,"x","prod");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return W.runKernel(lm,r,i)}const uN=G({prod_:zZ});function PZ(n,e,t,s){const r=n.map((d,p)=>M(d,`tensors${p}`,"raggedGather","int32")),i=M(e,"paramsDenseValues","raggedGather"),a=M(t,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:i,indices:a},u={outputRaggedRank:s},h=W.runKernel(Kb,o,u);return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}const oz=G({raggedGather_:PZ});function BZ(n,e,t){const s=M(n,"starts","raggedRange"),r=M(e,"limits","raggedRange",s.dtype),i=M(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:i},o=W.runKernel(Xb,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const lz=G({raggedRange_:BZ});function VZ(n,e,t,s,r){const i=M(n,"shape","raggedTensorToTensor","int32"),a=M(e,"values","raggedTensorToTensor"),o=M(t,"defaultValue","raggedTensorToTensor",a.dtype),u=s.map((p,m)=>M(p,`tensors${m}`,"raggedTensorToTensor","int32")),h={shape:i,values:a,defaultValue:o,rowPartitionTensors:u},d={rowPartitionTypes:r};return W.runKernel(Yb,h,d)}const uz=G({raggedTensorToTensor_:VZ});function UZ(n,e,t){tr(n);const s=he(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<s;i++)r[i]=e();return W.makeTensor(r,n,t)}const cz=G({rand_:UZ});var Qy={exports:{}},jZ=Qy.exports,yO;function WZ(){return yO||(yO=1,(function(n){(function(e,t,s){function r(u){var h=this,d=o();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(u),h.s0<0&&(h.s0+=1),h.s1-=d(u),h.s1<0&&(h.s1+=1),h.s2-=d(u),h.s2<0&&(h.s2+=1),d=null}function i(u,h){return h.c=u.c,h.s0=u.s0,h.s1=u.s1,h.s2=u.s2,h}function a(u,h){var d=new r(u),p=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,d),m.state=function(){return i(d,{})}),m}function o(){var u=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){u+=d.charCodeAt(p);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return h}t&&t.exports?t.exports=a:this.alea=a})(jZ,n)})(Qy)),Qy.exports}var e0={exports:{}},GZ=e0.exports,bO;function HZ(){return bO||(bO=1,(function(n){(function(e,t,s){function r(o){var u=this,h="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var p=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^p^p>>>8},o===(o|0)?u.x=o:h+=o;for(var d=0;d<h.length+64;d++)u.x^=h.charCodeAt(d)|0,u.next()}function i(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u}function a(o,u){var h=new r(o),d=u&&u.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xor128=a})(GZ,n)})(e0)),e0.exports}var t0={exports:{}},qZ=t0.exports,xO;function KZ(){return xO||(xO=1,(function(n){(function(e,t,s){function r(o){var u=this,h="";u.next=function(){var p=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(p^p<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,o===(o|0)?u.x=o:h+=o;for(var d=0;d<h.length+64;d++)u.x^=h.charCodeAt(d)|0,d==h.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(o,u){return u.x=o.x,u.y=o.y,u.z=o.z,u.w=o.w,u.v=o.v,u.d=o.d,u}function a(o,u){var h=new r(o),d=u&&u.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xorwow=a})(qZ,n)})(t0)),t0.exports}var n0={exports:{}},XZ=n0.exports,wO;function YZ(){return wO||(wO=1,(function(n){(function(e,t,s){function r(o){var u=this;u.next=function(){var d=u.x,p=u.i,m,y;return m=d[p],m^=m>>>7,y=m^m<<24,m=d[p+1&7],y^=m^m>>>10,m=d[p+3&7],y^=m^m>>>3,m=d[p+4&7],y^=m^m<<7,m=d[p+7&7],m=m^m<<13,y^=m^m<<9,d[p]=y,u.i=p+1&7,y};function h(d,p){var m,y=[];if(p===(p|0))y[0]=p;else for(p=""+p,m=0;m<p.length;++m)y[m&7]=y[m&7]<<15^p.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(u,o)}function i(o,u){return u.x=o.x.slice(),u.i=o.i,u}function a(o,u){o==null&&(o=+new Date);var h=new r(o),d=u&&u.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.x&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xorshift7=a})(XZ,n)})(n0)),n0.exports}var s0={exports:{}},JZ=s0.exports,vO;function ZZ(){return vO||(vO=1,(function(n){(function(e,t,s){function r(o){var u=this;u.next=function(){var d=u.w,p=u.X,m=u.i,y,b;return u.w=d=d+1640531527|0,b=p[m+34&127],y=p[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=p[m]=b^y,u.i=m,b+(d^d>>>16)|0};function h(d,p){var m,y,b,x,w,S=[],C=128;for(p===(p|0)?(y=p,p=null):(p=p+"\0",y=0,C=Math.max(C,p.length)),b=0,x=-32;x<C;++x)p&&(y^=p.charCodeAt((x+32)%p.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=S[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(S[(p&&p.length||0)&127]=-1),b=127,x=512;x>0;--x)y=S[b+34&127],m=S[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,S[b]=y^m;d.w=w,d.X=S,d.i=b}h(u,o)}function i(o,u){return u.i=o.i,u.w=o.w,u.X=o.X.slice(),u}function a(o,u){o==null&&(o=+new Date);var h=new r(o),d=u&&u.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.X&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xor4096=a})(JZ,n)})(s0)),s0.exports}var r0={exports:{}},QZ=r0.exports,SO;function eQ(){return SO||(SO=1,(function(n){(function(e,t,s){function r(o){var u=this,h="";u.next=function(){var p=u.b,m=u.c,y=u.d,b=u.a;return p=p<<25^p>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-p|0,u.b=p=p<<20^p>>>12^m,u.c=m=m-y|0,u.d=y<<16^m>>>16^b,u.a=b-p|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,o===Math.floor(o)?(u.a=o/4294967296|0,u.b=o|0):h+=o;for(var d=0;d<h.length+20;d++)u.b^=h.charCodeAt(d)|0,u.next()}function i(o,u){return u.a=o.a,u.b=o.b,u.c=o.c,u.d=o.d,u}function a(o,u){var h=new r(o),d=u&&u.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.tychei=a})(QZ,n)})(r0)),r0.exports}var i0={exports:{}};const tQ={},nQ=Object.freeze(Object.defineProperty({__proto__:null,default:tQ},Symbol.toStringTag,{value:"Module"})),sQ=SG(nQ);var rQ=i0.exports,TO;function iQ(){return TO||(TO=1,(function(n){(function(e,t,s){var r=256,i=6,a=52,o="random",u=s.pow(r,i),h=s.pow(2,a),d=h*2,p=r-1,m;function y(k,E,_){var R=[];E=E==!0?{entropy:!0}:E||{};var O=S(w(E.entropy?[k,N(t)]:k??C(),3),R),F=new b(R),L=function(){for(var A=F.g(i),U=u,Y=0;A<h;)A=(A+Y)*r,U*=r,Y=F.g(1);for(;A>=d;)A/=2,U/=2,Y>>>=1;return(A+Y)/U};return L.int32=function(){return F.g(4)|0},L.quick=function(){return F.g(4)/4294967296},L.double=L,S(N(F.S),t),(E.pass||_||function(A,U,Y,te){return te&&(te.S&&x(te,F),A.state=function(){return x(F,{})}),Y?(s[o]=A,U):A})(L,O,"global"in E?E.global:this==s,E.state)}function b(k){var E,_=k.length,R=this,O=0,F=R.i=R.j=0,L=R.S=[];for(_||(k=[_++]);O<r;)L[O]=O++;for(O=0;O<r;O++)L[O]=L[F=p&F+k[O%_]+(E=L[O])],L[F]=E;(R.g=function(A){for(var U,Y=0,te=R.i,Z=R.j,B=R.S;A--;)U=B[te=p&te+1],Y=Y*r+B[p&(B[te]=B[Z=p&Z+U])+(B[Z]=U)];return R.i=te,R.j=Z,Y})(r)}function x(k,E){return E.i=k.i,E.j=k.j,E.S=k.S.slice(),E}function w(k,E){var _=[],R=typeof k,O;if(E&&R=="object")for(O in k)try{_.push(w(k[O],E-1))}catch{}return _.length?_:R=="string"?k:k+"\0"}function S(k,E){for(var _=k+"",R,O=0;O<_.length;)E[p&O]=p&(R^=E[p&O]*19)+_.charCodeAt(O++);return N(E)}function C(){try{var k;return m&&(k=m.randomBytes)?k=k(r):(k=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(k)),N(k)}catch{var E=e.navigator,_=E&&E.plugins;return[+new Date,e,_,e.screen,N(t)]}}function N(k){return String.fromCharCode.apply(0,k)}if(S(s.random(),t),n.exports){n.exports=y;try{m=sQ}catch{}}else s["seed"+o]=y})(typeof self<"u"?self:rQ,[],Math)})(i0)),i0.exports}var _S,CO;function aQ(){if(CO)return _S;CO=1;var n=WZ(),e=HZ(),t=KZ(),s=YZ(),r=ZZ(),i=eQ(),a=iQ();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=i,_S=a,_S}var td=aQ();const oQ=.001,hz=.1;function lQ(n,e,t){return t==null&&(t=cN()),zT(n,e,(s,r)=>hN(s,r,t))}function cN(){return W.backend.floatPrecision()===32?oQ:hz}function zT(n,e,t){let s=!0;if((kn(n)||kn(e))&&(s=!1),kn(n)&&kn(e)&&(s=!0),s){const a=n.constructor.name,o=e.constructor.name;if(a!==o)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${o}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=Ui(n),o=Ui(e);if(!it(a,o))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${o}]`)}const r=kn(n)?n:Vi(n),i=kn(e)?e:Vi(e);if(r.length!==i.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${i.length}.
Actual:   ${r}.
Expected: ${i}.`);for(let a=0;a<i.length;++a){const o=r[a],u=i[a];if(!t(o,u))throw new Error(`Arrays differ: actual[${a}] = ${o}, expected[${a}] = ${u}.
Actual:   ${r}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function uQ(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function cQ(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Ri(n)||Ri(n[0])||Ri(e)||Ri(e[0])?zT(n,t,(s,r)=>s==r):zT(n,e,(s,r)=>hN(s,r,0))}function hQ(n,e,t){if(t==null&&(t=cN()),!hN(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function hN(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function dQ(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function fQ(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function dz(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?dz(t):n[e]=Li(t)}return n}function pQ(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function mQ(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const gQ=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:hz,createVideoElement:pQ,encodeStrings:dz,expectArrayBuffersEqual:fQ,expectArraysClose:lQ,expectArraysEqual:cQ,expectNumbersClose:hQ,expectPromiseToFail:uQ,expectValuesInRange:dQ,play:mQ,testEpsilon:cN},Symbol.toStringTag,{value:"Module"}));class dN{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=i||Math.random();this.random=td.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,a;do r=2*this.random()-1,i=2*this.random()-1,a=r*r+i*i;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class yQ{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const i=r||Math.random();this.randu=td.alea(i.toString()),this.randn=new dN(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,i,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),i=this.randu(),i<t||Math.log(i)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class bQ{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=td.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function xQ(n,e,t=1,s="float32",r){if(tr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new yQ(e,t,s,r),a=Qe(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const fz=G({randomGamma_:xQ});function wQ(n,e=0,t=1,s,r){if(tr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new dN(e,t,s,!1,r),a=Qe(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Dx=G({randomNormal_:wQ});function vQ(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Dx(n,0,1,e,t)}const pz=G({randomStandardNormal_:vQ});function SQ(n,e=0,t=1,s="float32",r){tr(n);const i=Qe(n,s),a=new bQ(e,t,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Wo=G({randomUniform_:SQ});function TQ(n,e,t,s){return Wo(n,e,t,"int32",s)}const mz=G({randomUniformInt_:TQ});function Ql(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return W.runKernel(Jb,{},r)}function CQ(n){const t={input:M(n,"input","real")};return W.runKernel(Zb,t)}const Uc=G({real_:CQ});function NQ(n){const t={x:M(n,"x","reciprocal")};return W.runKernel(Ah,t)}const fN=G({reciprocal_:NQ});function kQ(n){const t={x:M(n,"x","relu")};return W.runKernel(Rh,t)}const wi=G({relu_:kQ});function EQ(n){const t={x:M(n,"x","relu6")};return W.runKernel(Dh,t)}const Ox=G({relu6_:EQ});function $Q(n,e){const s={x:M(n,"x","reverse")},r={dims:e};return W.runKernel(dm,s,r)}const Tr=G({reverse_:$Q});function IQ(n){const e=M(n,"x","reverse");return D(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Tr(e,0)}const gz=G({reverse1d_:IQ});function _Q(n,e){const t=M(n,"x","reverse");return D(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Tr(t,e)}const yz=G({reverse2d_:_Q});function AQ(n,e){const t=M(n,"x","reverse");return D(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Tr(t,e)}const bz=G({reverse3d_:AQ});function RQ(n,e){const t=M(n,"x","reverse");return D(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Tr(t,e)}const xz=G({reverse4d_:RQ});function DQ(n){const t={x:M(n,"x","round")};return W.runKernel(Oh,t)}const Fx=G({round_:DQ});function OQ(n){const t={x:M(n,"x","rsqrt","float32")};return W.runKernel(Fh,t)}const Lx=G({rsqrt_:OQ});function FQ(n){const t={x:M(n,"x","selu")};return W.runKernel(Lh,t)}const Mx=G({selu_:FQ});function LQ(n,e,t,s,r,i=[1,1],a="NHWC"){const o=M(n,"x","separableConv2d"),u=M(e,"depthwiseFilter","separableConv2d"),h=M(t,"pointwiseFilter","separableConv2d");let d=o,p=!1;if(o.rank===3&&(p=!0,d=X(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),D(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),D(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),D(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=u.shape[2],y=u.shape[3];D(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=Yh(d,u,s,r,a,i),w=Ea(b,h,1,"valid",a);return p?X(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const zx=G({separableConv2d_:LQ});async function MQ(n,e){const t=M(n,"x","setdiff1d"),s=M(e,"y","setdiff1d");D(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),D(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),D(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),a=new Set(i);let o=0;for(let d=0;d<r.length;d++)a.has(r[d])||o++;const u=new bn([o],t.dtype),h=new bn([o],"int32");for(let d=0,p=0;d<r.length;d++)a.has(r[d])||(u.values[p]=r[d],h.values[p]=d,p++);return[u.toTensor(),h.toTensor()]}const wz=MQ;function zQ(n){const t={x:M(n,"x","sign")};return W.runKernel(Ph,t)}const pN=G({sign_:zQ});function PQ(n){const t={x:M(n,"x","sin","float32")};return W.runKernel(Mh,t)}const Px=G({sin_:PQ});function BQ(n){const t={x:M(n,"x","sinh")};return W.runKernel(zh,t)}const Bx=G({sinh_:BQ});function VQ(n,e,t){const s=M(n,"x","slice1d");return D(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),ut(s,[e],[t])}const zm=G({slice1d_:VQ});function UQ(n,e,t){const s=M(n,"x","slice2d");return D(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),ut(s,e,t)}const Vx=G({slice2d_:UQ});function jQ(n,e,t){const s=M(n,"x","slice3d");return D(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),ut(s,e,t)}const Pm=G({slice3d_:jQ});function WQ(n,e,t){const s=M(n,"x","slice4d");return D(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),ut(s,e,t)}const jc=G({slice4d_:WQ});function GQ(n,e=-1){const t=M(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return W.runKernel(bm,s,r)}const Bm=G({softmax_:GQ});function HQ(n){D(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Db,e)}const Vm=G({fft_:HQ});function qQ(n){D(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Mb,e)}const Wc=G({ifft_:qQ});function KQ(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=X(n,[t,e]);s=Wc(r)}else{const r=[t,2*(e-1)],i=X(Uc(n),[t,e]),a=X(Im(n),[t,e]),o=Tr(ut(i,[0,1],[t,e-2]),1),u=K(Tr(ut(a,[0,1],[t,e-2]),1),Me(-1)),h=ln([i,o],1),d=ln([a,u],1),p=X(ka(h,d),[r[0],r[1]]);s=Wc(p)}if(s=Uc(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=X(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const Ux=G({irfft_:KQ});function XQ(n,e,t=0){const r={x:M(n,"x","split")},i={numOrSizeSplits:e,axis:t};return W.runKernel(ym,r,i)}const Is=G({split_:XQ});function YQ(n,e){D(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=e,r=ut(n,b,x),t=e}else if(e!=null&&e>t){const b=n.shape.map(x=>x);b[n.shape.length-1]=e-t,r=ln([n,gn(b)],n.shape.length-1),t=e}else r=n;const i=ct(r),a=X(ka(r,i),[s,t]),o=Vm(a),u=Math.floor(t/2)+1,h=Uc(o),d=Im(o),p=Is(h,[u,t-u],h.shape.length-1),m=Is(d,[u,t-u],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=u,X(ka(p[0],m[0]),y)}const Um=G({rfft_:YQ});function JQ(n,e){let t=M(n,"a","squaredDifference"),s=M(e,"b","squaredDifference");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s},i={};return W.runKernel(jh,r,i)}const jx=G({squaredDifference_:JQ});function ZQ(n,e){const t=M(n,"x","squeeze","string_or_numeric");return X(t,Ra(t.shape,e).newShape)}const Go=G({squeeze_:ZQ});function QQ(n,e=0){const t=tp(n,"tensors","stack","string_or_numeric");D(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&D(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return W.runKernel(im,s,r)}const bs=G({stack_:QQ});function eee(n,e=0){const s={x:M(n,"x","step")},r={alpha:e};return W.runKernel(Kh,s,r)}const mu=G({step_:eee});function tee(n,e,t,s,r=0,i=0,a=0,o=0,u=0){const d={x:M(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};return W.runKernel(cx,d,p)}const mN=G({stridedSlice_:tee});function nee(n){const t={x:M(n,"x","tan","float32")};return W.runKernel(Gh,t)}const gN=G({tan_:nee});function Xn(n,e){uu(n);const t=Ui(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Bo(n,null,t,e)}function So(n,e,t){if(uu(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Ui(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Bo(n,e,s,t)}function yN(n,e,t){if(uu(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Ui(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Bo(n,e,s,t)}function vz(n,e,t){if(uu(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Ui(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Bo(n,e,s,t)}function Sz(n,e,t){if(uu(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Ui(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Bo(n,e,s,t)}function Tz(n,e,t){if(uu(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Ui(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Bo(n,e,s,t)}function bN(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(i+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function Wx(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}bN(t,e,n)}function Ho(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let a=1;for(let p=r;p<i;++p)a*=t[p];const o=r<1?1:r,u=he(e.shape)/o,h=[...ze(t.slice(0,r)),1],d=he(t);return{sliceRank:r,numUpdates:u,sliceSize:a,strides:h,outputSize:d}}const see=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Ho,validateInput:Wx,validateUpdateShape:bN},Symbol.toStringTag,{value:"Module"}));function ree(n,e,t){const s=M(n,"tensor","tensorScatterupdate"),r=M(e,"indices","tensorScatterupdate","int32"),i=M(t,"updates","tensorScatterupdate");if(Wx(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const a={tensor:s,indices:r,updates:i},o={};return W.runKernel(nx,a,o)}const Cz=G({tensorScatterUpdate_:ree});function iee(n,e=1,t=!0){const s=M(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:t},[o,u]=W.runKernel(px,i,a);return{values:o,indices:u}}const xN=G({topk_:iee});function aee(n,e=0,t=1,s,r){if(tr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new dN(e,t,s,!0,r),a=Qe(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Gx=G({truncatedNormal_:aee});function oee(n,e=0){const t=M(n,"x","unique","string_or_numeric");D(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,a]=W.runKernel(gx,s,r);return{values:i,indices:a}}const wN=G({unique_:oee});function lee(n,e,t){const s=M(n,"x","unsortedSegmentSum"),r=M(e,"segmentIds","unsortedSegmentSum","int32");D(Gl(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},a={numSegments:t};return W.runKernel(vm,i,a)}const Hx=G({unsortedSegmentSum_:lee});function uee(n,e=0){const t=M(n,"x","unstack","string_or_numeric");D(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return W.runKernel(wm,s,r)}const Cr=G({unstack_:uee});function Nz(n,e){return Rx(n,e,"right")}function vN(n,e=!0,t,s){return W.makeVariable(n,e,t,s)}function qx(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=Qe(n,"int32"),r=Qe([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const a=s.indexToLoc(t[i]),o=i*n.length;r.values.set(a,o)}return r.toTensor()}async function cee(n){const e=M(n,"condition","whereAsync","bool"),t=await e.data(),s=qx(e.shape,t);return n!==e&&e.dispose(),s}const SN=cee;async function hee(n,e,t){const s=M(n,"tensor","boolMask"),r=M(e,"mask","boolMask","bool"),i=t??0,a=r.rank,o=s.shape;D(a>0,()=>"mask cannot be scalar"),Jn(o.slice(i,i+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let x=i;x<i+a;x++)u*=o[x];const h=o.slice(0,i).concat([u],o.slice(i+a)),d=X(s,h),p=X(r,[-1]),m=await SN(p),y=Go(m,[1]),b=ed(d,y,i);return n!==s&&s.dispose(),e!==r&&r.dispose(),y.dispose(),d.dispose(),p.dispose(),m.dispose(),b}const kz=hee;function dee(n,e,t){const s=M(n,"x","transpose");if(e==null&&(e=s.shape.map((a,o)=>o).reverse()),D(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{D(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?se(()=>{let a=Uc(s),o=Im(s);return a=W.runKernel(Bl,{x:a},i),o=W.runKernel(Bl,{x:o},i),t&&(o=Mt(o)),ka(a,o)}):W.runKernel(Bl,r,i)}const at=G({transpose_:dee});function fee(n,e,t,s,r=!0){const i=M(n,"v","movingAverage"),a=M(e,"x","movingAverage"),o=M(t,"decay","movingAverage");vM(i,a),D(it(i.shape,a.shape),()=>"Shape mismatch in v and x");const u=Me(1),h=_e(u,o);let d=K(_e(a,i),h);if(r){D(s!=null,()=>"When using zeroDebias: true, step is required.");const p=M(s,"step","movingAverage");d=Oe(d,_e(u,ji(o,p)))}return we(i,d)}const Ez=G({movingAverage_:fee});function pee(n,e,t){tr(t);const s=M(n,"indices","scatterND","int32"),r=M(e,"updates","scatterND");Wx(r,s,t);const i={indices:s,updates:r},a={shape:t};return W.runKernel(tx,i,a)}const $z=G({scatterND_:pee});function mee(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function gee(n,e,t,s=0){tr(t);const r=M(n,"sparseIndices","sparseToDense","int32"),i=M(e,"sparseValues","sparseToDense","string_or_numeric"),a=M(s,"defaultValue","sparseToDense",i.dtype);mee(r,i,t,a);const o={sparseIndices:r,sparseValues:i,defaultValue:a},u={outputShape:t};return W.runKernel(lx,o,u)}const Iz=G({sparseToDense_:gee});function yee(n,e){const t=M(e,"indices","gatherND","int32"),r={params:M(n,"x","gatherND","string_or_numeric"),indices:t};return W.runKernel(Lb,r)}const _z=G({gatherND_:yee});function bee(n,e){if(e==null)return n.shape.slice();if(it(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function xee(n,e,t,s){const r=M(n,"x","dropout");if(D(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),D(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof mt?r.clone():r;const i=bee(r,t),a=1-e,o=Oe(Qh(we(Wo(i,0,1,"float32",s),a)),a);return K(r,o)}const TN=G({dropout_:xee});function CN(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Kx(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const a=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(a)}return Xn(r,"float32")}async function wee(n,e,t=1){const s=M(n,"predictions","inTopK"),r=M(e,"targets","inTopK");D(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),D(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Jn(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];D(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const a=await s.data(),o=await r.data(),[u,h]=[a.length/i,i],d=zn("bool",u);for(let p=0;p<u;p++){const m=p*h,y=a.subarray(m,m+h),b=[];for(let x=0;x<y.length;x++)b.push({value:y[x],index:x});b.sort((x,w)=>w.value-x.value),d[p]=0;for(let x=0;x<t;x++)if(b[x].index===o[p]){d[p]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Ys(d,r.shape,"bool")}const Az=wee;function vee(n,e,t,s,r,i="NHWC",a){let o=n;n.rank===3&&(o=X(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=X(e,[1,e.shape[0],e.shape[1],e.shape[2]])),D(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),D(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),D(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const h=i==="NHWC"?o.shape[3]:o.shape[1],d=i==="NHWC"?u.shape[3]:u.shape[1];D(h===t[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${t[2]}.`),D(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),ws("conv2dDerFilter",r,a);const p={x:o,dy:u},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:t};return W.runKernel(wb,p,m)}const NN=G({conv2DBackpropFilter_:vee});function Xx(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return K(n,mu(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Yx(n,e){let t=e;const s=xn(n.shape,e.shape);return s.length>0&&(t=Ae(t,s)),X(t,n.shape)}function Jx(n,e,t,s){if(e==="linear")return n;if(e==="relu")return wi(n);if(e==="elu")return Jh(n);if(e==="relu6")return Ox(n);if(e==="prelu")return Mm(n,t);if(e==="leakyrelu")return _m(n,s);if(e==="sigmoid")return di(n);throw new Error(`Unknown fused activation ${e}.`)}const Zx=(n,e)=>!(n>0)||e==="linear";function See({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(u=u||"linear",Zx(W.state.gradientDepth,u)===!1){D(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=Ea(n,e,t,s,r,i,a);return o!=null&&(_=we(_,o)),Jx(_,u,h,d)}const p=M(n,"x","conv2d","float32"),m=M(e,"filter","conv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=X(p,[1,p.shape[0],p.shape[1],p.shape[2]])),D(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),D(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),ws("fused conv2d",s,a);const x=r==="NHWC"?y.shape[3]:y.shape[1];D(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),D(Zn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const w=Vn(y.shape,m.shape,t,i,s,a);let S;o!=null&&(S=M(o,"bias","fused conv2d"),[S]=Jt(S,p),r==="NHWC"?Xe(w.outShape,S.shape):(D(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),D(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let C;if(h!=null){const _=h.shape;if(D(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)D(_[0]===1||_[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${w.outChannels}).`);else if(_.length===3)try{Xe(_,w.outShape)}catch{const O=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(O)}C=M(h,"prelu weights","fused conv2d")}const N=(_,R)=>{D(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[O,F,L,A]=R,U=Xx(_,L,u);D(_o(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Y=j2(F.shape,U,O,t,s),te=NN(F,U,O.shape,t,s),Z=[Y,te];if(A!=null){const B=Yx(A,U);Z.push(B)}return Z},k={x:y,filter:m,bias:S,preluActivationWeights:C},E={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:d};return o==null?Wi((R,O,F)=>{let L=W.runKernel(Yf,k,E);return F([O,R,L]),b&&(L=X(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:N}})(y,m):Wi((R,O,F,L)=>{let A=W.runKernel(Yf,k,E);return L([O,R,A,F]),b&&(A=X(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:N}})(y,m,S)}const Rz=G({fusedConv2d_:See});function Tee(n,e,t,s,r,i=[1,1],a){let o=n;n.rank===3&&(o=X(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=X(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={x:o,dy:u},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:t};return W.runKernel(Eb,h,d)}const Dz=G({depthwiseConv2dNativeBackpropFilter_:Tee});function Cee(n,e,t,s,r,i=[1,1],a){let o=e,u=!1;e.rank===3&&(u=!0,o=X(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:o,filter:t},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:n},p=W.runKernel($b,h,d);return u?X(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Oz=G({depthwiseConv2dNativeBackpropInput_:Cee});function Nee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:u="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(Zx(W.state.gradientDepth,u)===!1){let E=Yh(n,e,t,s,r,i,a);return o!=null&&(E=we(E,o)),Jx(E,u,h,d)}const p=M(n,"x","depthwiseConv2d","float32"),m=M(e,"filter","depthwiseConv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=X(p,[1,p.shape[0],p.shape[1],p.shape[2]])),D(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),D(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),D(y.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),i==null&&(i=[1,1]),D(Zn(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ws("fused depthwiseConv2d",s,a);const x=Vn(y.shape,m.shape,t,i,s,a,!0);let w;o!=null&&(w=M(o,"bias","fused conv2d"),[w]=Jt(w,p),Xe(x.outShape,w.shape));let S;h!=null&&(S=M(h,"prelu weights","fused depthwiseConv2d"));const C=(E,_)=>{D(_o(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[R,O,F,L]=_,A=Xx(E,F,u),U=Oz(O.shape,A,R,t,s,i,a),Y=Dz(O,A,R.shape,t,s,i,a);if(L!=null){const te=Yx(w,A);return[U,Y,te]}return[U,Y]},N={x:y,filter:m,bias:w,preluActivationWeights:S},k={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:u,leakyreluAlpha:d};return o==null?Wi((_,R,O)=>{let F=W.runKernel(Jf,N,k);return O([R,_,F]),b&&(F=X(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:C}})(y,m):Wi((_,R,O,F)=>{let L=W.runKernel(Jf,N,k);return F([R,_,L,O]),b&&(L=X(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(y,m,w)}const kee=G({fusedDepthwiseConv2d_:Nee});function Eee({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(Zx(W.state.gradientDepth,i)===!1){let A=nt(n,e,t,s);return r!=null&&(A=we(A,r)),Jx(A,i,a,o)}let u=M(n,"a","fused matMul"),h=M(e,"b","fused matMul");[u,h]=Jt(u,h);const d=t?u.shape[u.rank-2]:u.shape[u.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=u.shape.slice(0,-2),x=h.shape.slice(0,-2),w=he(b),S=he(x);D(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${u.shape} and ${h.shape} and transposeA=${t} and transposeB=${s} must match.`);const N=Xe(u.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),k=t?X(u,[w,d,m]):X(u,[w,m,d]),E=s?X(h,[S,y,p]):X(h,[S,p,y]);let _;r!=null&&(_=M(r,"bias","fused matMul"),[_]=Jt(_,u),Xe(N,_.shape));let R;a!=null&&(R=M(a,"prelu weights","fused matMul"));const O=(A,U)=>{const[Y,te,Z,B]=U,V=Xx(X(A,Z.shape),Z,i);let j,ee;if(!t&&!s?(j=nt(V,te,!1,!0),ee=nt(Y,V,!0,!1)):!t&&s?(j=nt(V,te,!1,!1),ee=nt(V,Y,!0,!1)):t&&!s?(j=nt(te,V,!1,!0),ee=nt(Y,V,!1,!1)):(j=nt(te,V,!0,!0),ee=nt(V,Y,!0,!0)),r!=null){const ae=Yx(B,V);return[j,ee,ae]}else return[j,ee]},F={a:k,b:E,bias:_,preluActivationWeights:R},L={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:o};return r==null?Wi((U,Y,te)=>{const Z=W.runKernel(Xf,F,L);return te([U,Y,Z]),{value:X(Z,N),gradFunc:O}})(k,E):Wi((U,Y,te,Z)=>{const B=W.runKernel(Xf,F,L);return Z([U,Y,B,te]),{value:X(B,N),gradFunc:O}})(k,E,_)}const PT=G({fusedMatMul_:Eee});const Fz=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Rz,depthwiseConv2d:kee,matMul:PT},Symbol.toStringTag,{value:"Module"}));function $ee(n){return Kx(n,.54,.46)}const Iee=G({hammingWindow_:$ee});function _ee(n){return Kx(n,.5,.5)}const Lz=G({hannWindow_:_ee});function Aee(n,e,t,s=!1,r=0){let i=0;const a=[];for(;i+e<=n.size;)a.push(ut(n,i,e)),i+=t;if(s)for(;i<n.size;){const o=i+e-n.size,u=ln([ut(n,i,e-o),fu([o],r)]);a.push(u),i+=t}return a.length===0?So([],[0,e]):X(ln(a),[a.length,e])}const Mz=G({frame_:Aee});function Ree(n,e,t,s,r=Lz){s==null&&(s=CN(e));const i=Mz(n,e,t),a=K(i,r(e));return Um(a,s)}const Dee=G({stft_:Ree});function Oee(n,e,t,s,r="bilinear",i=0){const a=M(n,"image","cropAndResize"),o=M(e,"boxes","cropAndResize","float32"),u=M(t,"boxInd","cropAndResize","int32"),h=o.shape[0];D(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),D(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${o.shape}.`),D(u.rank===1&&u.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${o.shape}.`),D(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),D(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),D(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:a,boxes:o,boxInd:u},p={method:r,extrapolationValue:i,cropSize:s};return W.runKernel(Cb,d,p)}const Fee=G({cropAndResize_:Oee});function Lee(n){const e=M(n,"image","flipLeftRight","float32");D(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return W.runKernel(Fb,t,{})}const Mee=G({flipLeftRight_:Lee});function zee(n){const e=M(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];D(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),D(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,br(e,r)}const Pee=G({grayscaleToRGB_:zee});function Bee(n){const e=M(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];D(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),D(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=Ne(e,"float32"),a=Xn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=kl("ij,j->i",i,a);break;case 3:o=kl("ijk,k->ij",i,a);break;case 4:o=kl("ijkl,l->ijk",i,a);break;case 5:o=kl("ijklm,m->ijkl",i,a);break;case 6:o=kl("ijklmn,n->ijklm",i,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Hn(o,-1),Ne(o,r)}const Vee=G({rgbToGrayscale_:Bee});function Uee(n,e,t=0,s=.5){const r=M(n,"image","rotateWithOffset","float32");D(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},a={radians:e,fillValue:t,center:s};return W.runKernel(yx,i,a)}const jee=G({rotateWithOffset_:Uee});function nd(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const a=n.shape[0];return t=Math.min(t,a),D(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),D(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),D(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),D(e.rank===1,()=>"scores must be a 1D tensor"),D(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),D(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function Wee(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=M(n,"boxes","nonMaxSuppression","float32"),a=M(e,"scores","nonMaxSuppression","float32"),o=nd(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return W.runKernel(Gb,{boxes:i,scores:a},u)}const Gee=G({nonMaxSuppression_:Wee});function Hee(n,e,t){const s=qee(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function qee(n,e,t){return Xee(n,e,t||Kee)}function Kee(n,e){return n>e?1:n<e?-1:0}function Xee(n,e,t){let s=0,r=n.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=t(e,n[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}function Qx(n,e,t,s,r){return kN(n,e,t,s,r,0)}function ew(n,e,t,s,r,i){return kN(n,e,t,s,r,0,!1,i,!0)}function tw(n,e,t,s,r,i){return kN(n,e,t,s,r,i,!0)}function kN(n,e,t,s,r,i,a=!1,o=!1,u=!1){const h=[];for(let w=0;w<e.length;w++)e[w]>r&&h.push({score:e[w],boxIndex:w,suppressBeginIndex:0});h.sort(NO);const d=i>0?-.5/i:0,p=[],m=[];for(;p.length<t&&h.length>0;){const w=h.pop(),{score:S,boxIndex:C,suppressBeginIndex:N}=w;if(S<r)break;let k=!1;for(let E=p.length-1;E>=N;--E){const _=Yee(n,C,p[E]);if(_>=s){k=!0;break}if(w.score=w.score*Jee(s,d,_),w.score<=r)break}w.suppressBeginIndex=p.length,k||(w.score===S?(p.push(C),m.push(w.score)):w.score>r&&Hee(h,w,NO))}const y=p.length,b=t-y;o&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:p};return a&&(x.selectedScores=m),u&&(x.validOutputs=y),x}function Yee(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(o-i)*(u-a),b=(p-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(i,h),w=Math.max(a,d),S=Math.min(o,p),C=Math.min(u,m),N=Math.max(S-x,0)*Math.max(C-w,0);return N/(y+b-N)}function Jee(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function NO(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function Zee(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=M(n,"boxes","nonMaxSuppressionAsync"),a=M(e,"scores","nonMaxSuppressionAsync"),o=nd(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const u=await Promise.all([i.data(),a.data()]),h=u[0],d=u[1],{selectedIndices:p}=Qx(h,d,t,s,r);return i!==n&&i.dispose(),a!==e&&a.dispose(),Xn(p,"int32")}const Qee=Zee;function ete(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=M(n,"boxes","nonMaxSuppression"),o=M(e,"scores","nonMaxSuppression"),u=nd(a,o,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const h={boxes:a,scores:o},d={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},p=W.runKernel(qb,h,d);return{selectedIndices:p[0],selectedScores:p[1]}}const tte=G({nonMaxSuppressionWithScore_:ete});async function nte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=M(n,"boxes","nonMaxSuppressionAsync"),o=M(e,"scores","nonMaxSuppressionAsync"),u=nd(a,o,t,s,r,i);t=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,i=u.softNmsSigma;const h=await Promise.all([a.data(),o.data()]),d=h[0],p=h[1],{selectedIndices:m,selectedScores:y}=tw(d,p,t,s,r,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Xn(m,"int32"),selectedScores:Xn(y)}}const ste=nte;function rte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=M(n,"boxes","nonMaxSuppression"),o=M(e,"scores","nonMaxSuppression"),u=nd(a,o,t,s,r,null),h=u.maxOutputSize,d=u.iouThreshold,p=u.scoreThreshold,m={boxes:a,scores:o},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:i},b=W.runKernel(Hb,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const ite=G({nonMaxSuppressionPadded_:rte});async function ate(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=M(n,"boxes","nonMaxSuppressionAsync"),o=M(e,"scores","nonMaxSuppressionAsync"),u=nd(a,o,t,s,r,null),h=u.maxOutputSize,d=u.iouThreshold,p=u.scoreThreshold,[m,y]=await Promise.all([a.data(),o.data()]),{selectedIndices:b,validOutputs:x}=ew(m,y,h,d,p,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Xn(b,"int32"),validOutputs:Me(x,"int32")}}const ote=ate;function lte(n,e,t=!1,s=!1){const r=M(n,"images","resizeBilinear");D(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),D(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),D(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=X(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},h=W.runKernel(hm,o,u);return a?X(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const zz=G({resizeBilinear_:lte});function ute(n,e,t=!1,s=!1){const r=M(n,"images","resizeNearestNeighbor");D(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),D(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),D(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=X(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},u={alignCorners:t,halfPixelCenters:s,size:e},h=W.runKernel(cm,o,u);return a?X(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Pz=G({resizeNearestNeighbor_:ute});function cte(n,e="binary",t=!1,s=.5){const r=M(n,"image","threshold"),i=.2989,a=.587,o=.114,u=r.shape[0]*r.shape[1];let h=K(Xn([s]),255),d,p,m,y;if(D(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),D(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),D(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),D(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,p,m]=Is(r,[1,1,1],-1);const w=K(d,i),S=K(p,a),C=K(m,o);y=we(we(w,S),C)}else y=n;if(e==="otsu"){const w=M2(Ne(Fx(y),"int32"),Ys([]),256);h=hte(w,u)}const b=t?jo(y,h):vs(y,h);return Ne(K(b,255),"int32")}function hte(n,e){let t=Xn([-1]),s=Xn([0]),r=Xn([0]),i,a,o,u,h,d;for(let p=0;p<n.size-1;p++){i=ut(n,0,p+1),a=ut(n,p+1),h=Oe(Ae(i),e),d=Oe(Ae(a),e);const m=Ae(K(i,Ql(0,i.size)));o=Oe(m,Ae(i));const y=fu(a.shape,i.size),b=we(Ql(0,a.size),y),x=K(a,b);u=Oe(Ae(x),Ae(a));const w=_e(o,u),S=_e(o,u),C=K(h,d);r=K(K(C,w),S);const N=vs(r,s);s=Mn(N,r,s),t=Mn(N,Xn([p]),t)}return t}const dte=G({threshold_:cte});function fte(n,e,t="nearest",s="constant",r=0,i){const a=M(n,"image","transform","float32"),o=M(e,"transforms","transform","float32");D(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),D(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const u={image:a,transforms:o},h={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return W.runKernel(mx,u,h)}const pte=G({transform_:fte});function mte(n,e,t){const s=M(n,"a","bandPart");D(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);let o,u;typeof e=="number"?(D(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),D(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),o=M(e<0?i:e,"numLower","bandPart")):(D(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Mn(Bc(e,0),i,Ro(e,i))),typeof t=="number"?(D(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),D(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),u=M(t<0?a:t,"numUpper","bandPart")):(D(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Mn(Bc(t,0),a,Ro(t,a)));const h=X(Ql(0,i,1,"int32"),[-1,1]),d=Ql(0,a,1,"int32"),p=_e(h,d),m=Gr(jo(p,o),La(p,Mt(u))),y=gn([i,a],s.dtype);return X(bs(Cr(X(s,[-1,i,a])).map(b=>Mn(m,b,y))),r)}const gte=G({bandPart_:mte});function yte(n){let e;if(Array.isArray(n)){e=!1,D(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)D(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=Is(n,n.shape[0],0).map(r=>Go(r,[0]));D(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(W.tidy(()=>{let i=s[r];if(r>0)for(let a=0;a<r;++a){const o=K(Ae(K(t[a],i)),t[a]);i=_e(i,o)}return Oe(i,Zh(i,"euclidean"))}));return e?bs(t,0):t}const bte=G({gramSchmidt_:yte});function xte(n,e=!1){if(D(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return kO(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,h)=>u*h),s=Cr(X(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(u=>{const[h,d]=kO(u,e);r.push(h),i.push(d)});const a=X(bs(r,0),n.shape),o=X(bs(i,0),n.shape);return[a,o]}}function kO(n,e=!1){return W.tidy(()=>{D(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=$x(t),i=Mi(n);const a=So([[1]],[1,1]);let o=Mi(a);const u=t>=s?s:t;for(let h=0;h<u;++h){const d=i,p=o,m=r;[o,i,r]=W.tidy(()=>{const y=ut(i,[h,h],[t-h,1]),b=Zh(y),x=ut(i,[h,h],[1,1]),w=Mn(vs(x,0),So([[-1]]),So([[1]])),S=_e(x,K(w,b)),C=Oe(y,S);C.shape[0]===1?o=Mi(a):o=ln([a,ut(C,[1,0],[C.shape[0]-1,C.shape[1]])],0);const N=Mt(Oe(nt(w,S),b)),k=ut(i,[h,0],[t-h,s]),E=K(N,o),_=at(o);if(h===0)i=_e(k,nt(E,nt(_,k)));else{const F=_e(k,nt(E,nt(_,k)));i=ln([ut(i,[0,0],[h,s]),F],0)}const R=at(E),O=ut(r,[0,h],[t,r.shape[1]-h]);if(h===0)r=_e(O,nt(nt(O,o),R));else{const F=_e(O,nt(nt(O,o),R));r=ln([ut(r,[0,0],[t,h]),F],1)}return[o,i,r]}),Ke([d,p,m])}return!e&&t>s&&(r=ut(r,[0,0],[t,s]),i=ut(i,[0,0],[s,s])),[r,i]})}const wte=G({qr_:xte});var ms;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ms||(ms={}));function vte(n,e,t=ms.SUM_BY_NONZERO_WEIGHTS){const s=M(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=M(e,"weights","computeWeightedLoss"));const i=r==null?s:K(s,r);if(t===ms.NONE)return i;if(t===ms.SUM)return Ae(i);if(t===ms.MEAN){if(r==null)return Kt(i);{const a=s.size/r.size,o=Oe(Ae(i),Ae(r));return a>1?Oe(o,Me(a)):o}}if(t===ms.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Oe(Ae(i),Me(s.size));{const a=K(r,$s(s.shape)),o=Ne(Ae(Zl(a,Me(0))),"float32");return Oe(Ae(i),o)}}throw Error(`Unknown reduction: ${t}`)}const za=G({computeWeightedLoss_:vte});function Ste(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){const r=M(n,"labels","absoluteDifference"),i=M(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=M(t,"weights","absoluteDifference")),Jn(r.shape,i.shape,"Error in absoluteDifference: ");const o=mn(_e(r,i));return za(o,a,s)}const Tte=G({absoluteDifference_:Ste});function Cte(n,e,t,s,r=ms.SUM_BY_NONZERO_WEIGHTS){const i=M(n,"labels","cosineDistance"),a=M(e,"predictions","cosineDistance");let o=null;s!=null&&(o=M(s,"weights","cosineDistance")),Jn(i.shape,a.shape,"Error in cosineDistance: ");const u=Me(1),h=_e(u,Ae(K(i,a),t,!0));return za(h,o,r)}const Nte=G({cosineDistance_:Cte});function kte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){let r=M(n,"labels","hingeLoss");const i=M(e,"predictions","hingeLoss");let a=null;t!=null&&(a=M(t,"weights","hingeLoss")),Jn(r.shape,i.shape,"Error in hingeLoss: ");const o=Me(1);r=_e(K(Me(2),r),o);const u=wi(_e(o,K(r,i)));return za(u,a,s)}const Ete=G({hingeLoss_:kte});function $te(n,e,t,s=1,r=ms.SUM_BY_NONZERO_WEIGHTS){const i=M(n,"labels","huberLoss"),a=M(e,"predictions","huberLoss");let o=null;t!=null&&(o=M(t,"weights","huberLoss")),Jn(i.shape,a.shape,"Error in huberLoss: ");const u=Me(s),h=mn(_e(a,i)),d=Ro(h,u),p=_e(h,d),m=we(K(Me(.5),$t(d)),K(u,p));return za(m,o,r)}const Ite=G({huberLoss_:$te});function _te(n,e,t,s=1e-7,r=ms.SUM_BY_NONZERO_WEIGHTS){const i=M(n,"labels","logLoss"),a=M(e,"predictions","logLoss");let o=null;t!=null&&(o=M(t,"weights","logLoss")),Jn(i.shape,a.shape,"Error in logLoss: ");const u=Me(1),h=Me(s),d=Mt(K(i,Zs(we(a,h)))),p=K(_e(u,i),Zs(we(_e(u,a),h))),m=_e(d,p);return za(m,o,r)}const Ate=G({logLoss_:_te});function Rte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){const r=M(n,"labels","meanSquaredError"),i=M(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=M(t,"weights","meanSquaredError")),Jn(r.shape,i.shape,"Error in meanSquaredError: ");const o=jx(r,i);return za(o,a,s)}const Dte=G({meanSquaredError_:Rte});function Ote(n,e){const t=M(n,"labels","sigmoidCrossEntropyWithLogits"),s=M(e,"logits","sigmoidCrossEntropyWithLogits");Jn(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=wi(s),i=K(s,t),a=Am(Ds(Mt(mn(s))));return we(_e(r,i),a)}function Fte(n,e,t,s=0,r=ms.SUM_BY_NONZERO_WEIGHTS){let i=M(n,"multiClassLabels","sigmoidCrossEntropy");const a=M(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=M(t,"weights","sigmoidCrossEntropy")),Jn(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const h=Me(s),d=Me(1),p=Me(.5);i=we(K(i,_e(d,h)),K(p,h))}const u=Ote(i,a);return za(u,o,r)}const Lte=G({sigmoidCrossEntropy_:Fte});function Mte(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Wi((r,i,a)=>{const u=Rm(i,[t],!0),h=_e(Ne(i,"float32"),u);a([r,h]);const d=Mt(K(h,r));return{value:Ae(d,[t]),gradFunc:(y,b)=>{const[x,w]=b,S=un(y.shape,[t]);return[K(X(y,S),_e(Ne(x,"float32"),Ds(w))),K(X(y,S),_e(Ds(w),Ne(x,"float32")))]}}})(n,e)}function zte(n,e,t,s=0,r=ms.SUM_BY_NONZERO_WEIGHTS){let i=M(n,"onehotLabels","softmaxCrossEntropy");const a=M(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=M(t,"weights","softmaxCrossEntropy")),Jn(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const h=Me(s),d=Me(1),p=Me(i.shape[1]);i=we(K(i,_e(d,h)),Oe(h,p))}const u=Mte(i,a);return za(u,o,r)}const Pte=G({softmaxCrossEntropy_:zte});function Bte(n,e,t,s){const r=M(n,"indices","sparseFillEmptyRows","int32"),i=M(e,"values","sparseFillEmptyRows"),a=M(t,"denseShape","sparseFillEmptyRows","int32"),o=M(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:r,values:i,denseShape:a,defaultValue:o},h=W.runKernel(rx,u);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}const Vte=G({sparseFillEmptyRows_:Bte});function Ute(n,e,t){const s=M(n,"inputIndices","sparseReshape","int32"),r=M(e,"inputShape","sparseReshape","int32"),i=M(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:s,inputShape:r,newShape:i},o=W.runKernel(ix,a);return{outputIndices:o[0],outputShape:o[1]}}const jte=G({sparseReshape_:Ute});function Wte(n,e,t){const s=M(n,"data","sparseSegmentMean"),r=M(e,"indices","sparseSegmentMean","int32"),i=M(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return W.runKernel(ax,a)}const Gte=G({sparseSegmentMean_:Wte});function Hte(n,e,t){const s=M(n,"data","sparseSegmentSum"),r=M(e,"indices","sparseSegmentSum","int32"),i=M(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return W.runKernel(ox,a)}const qte=G({sparseSegmentSum_:Hte});function Kte(n,e,t,s,r,i,a,o){const u=M(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const h=M(e,"dataSplits","stringNGrams");if(h.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:a,preserveShortSequences:o},p={data:u,dataSplits:h},m=W.runKernel(hx,p,d);return{nGrams:m[0],nGramsSplits:m[1]}}const Xte=G({stringNGrams_:Kte});function Yte(n,e,t=!0){const s=M(n,"input","stringSplit","string"),r=M(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},a={input:s,delimiter:r},o=W.runKernel(dx,a,i);return{indices:o[0],values:o[1],shape:o[2]}}const Jte=G({stringSplit_:Yte});function Zte(n,e){const t=M(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return W.runKernel(fx,r,s)}const Qte=G({stringToHashBucketFast_:Zte});function ene(n,e,t,s=!0){const r=M(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:s};return W.runKernel(xm,{x:r},i)}const tne=G({staticRegexReplace_:ene});const Bz={fft:Vm,ifft:Wc,rfft:Um,irfft:Ux},Vz={hammingWindow:Iee,hannWindow:Lz,frame:Mz,stft:Dee},Ur={flipLeftRight:Mee,grayscaleToRGB:Pee,resizeNearestNeighbor:Pz,resizeBilinear:zz,rgbToGrayscale:Vee,rotateWithOffset:jee,cropAndResize:Fee,nonMaxSuppression:Gee,nonMaxSuppressionAsync:Qee,nonMaxSuppressionWithScore:tte,nonMaxSuppressionWithScoreAsync:ste,nonMaxSuppressionPadded:ite,nonMaxSuppressionPaddedAsync:ote,threshold:dte,transform:pte},EN={bandPart:gte,gramSchmidt:bte,qr:wte},Uz={absoluteDifference:Tte,computeWeightedLoss:za,cosineDistance:Nte,hingeLoss:Ete,huberLoss:Ite,logLoss:Ate,meanSquaredError:Dte,sigmoidCrossEntropy:Lte,softmaxCrossEntropy:Pte},jz={sparseFillEmptyRows:Vte,sparseReshape:jte,sparseSegmentMean:Gte,sparseSegmentSum:qte},Wz={stringNGrams:Xte,stringSplit:Jte,stringToHashBucketFast:Qte,staticRegexReplace:tne};const nne=new Map,BT=new Map;class gu{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yr{constructor(){this.classNameMap={}}static getMap(){return yr.instance==null&&(yr.instance=new yr),yr.instance}static register(e){yr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ve(n,e,t){D(n.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),D(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return yr.register(n),nne.set(r,n),BT.set(n,r),n}function sne(n){return BT.has(n)?BT.get(n):n.className}const rne=Object.freeze(Object.defineProperty({__proto__:null,Serializable:gu,SerializationMap:yr,getRegisteredName:sne,registerClass:ve},Symbol.toStringTag,{value:"Module"}));class Pa extends gu{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:i[o.name]}));this.applyGradients(a)}else this.applyGradients(i);return Ke(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return YM(e,t)}dispose(){this.iterations_!=null&&Ke(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Pa,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class $N extends Pa{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:se(()=>ct(i).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:se(()=>ct(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const u=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;se(()=>{const d=we(K(u,this.rho),K($t(o),1-this.rho)),p=K(Oe(Pn(we(h,this.epsilon)),Pn(we(u,this.epsilon))),o),m=we(K(h,this.rho),K($t(p),1-this.rho));u.assign(d),h.assign(m);const y=we(K(p,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ke(this.accumulatedGrads.map(e=>e.variable)),Ke(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class IN extends Pa{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:se(()=>fu(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const o=this.accumulatedGrads[r].variable;se(()=>{const u=we(o,$t(a));o.assign(u);const h=we(K(Oe(a,Pn(we(u,W.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ke(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class _N extends Pa{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],se(()=>{this.accBeta1=Me(t).variable(),this.accBeta2=Me(s).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);se(()=>{const s=_e(1,this.accBeta1),r=_e(1,this.accBeta2);t.forEach((i,a)=>{const o=W.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:se(()=>ct(o).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:se(()=>ct(o).variable(u))});const h=Array.isArray(e)?e[a].tensor:e[i];if(h==null)return;const d=this.accumulatedFirstMoment[a].variable,p=this.accumulatedSecondMoment[a].variable,m=we(K(d,this.beta1),K(h,1-this.beta1)),y=we(K(p,this.beta2),K($t(h),1-this.beta2)),b=Oe(m,s),x=Oe(y,r);d.assign(m),p.assign(y);const w=we(K(Oe(b,we(Pn(x),this.epsilon)),-this.learningRate),o);o.assign(w)}),this.accBeta1.assign(K(this.accBeta1,this.beta1)),this.accBeta2.assign(K(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ke(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ke(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),se(()=>{this.accBeta1.assign(ji(this.beta1,this.iterations_+1)),this.accBeta2.assign(ji(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class AN extends Pa{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],se(()=>{this.iteration=Me(0).variable(),this.accBeta1=Me(t).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);se(()=>{const s=_e(1,this.accBeta1),r=Oe(-this.learningRate,we(K(this.iteration,this.decay),1));t.forEach((i,a)=>{const o=W.registeredVariables[i],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:ct(o).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:ct(o).variable(u)});const h=Array.isArray(e)?e[a].tensor:e[i];if(h==null)return;const d=this.accumulatedFirstMoment[a].variable,p=this.accumulatedWeightedInfNorm[a].variable,m=we(K(d,this.beta1),K(h,1-this.beta1)),y=K(p,this.beta2),b=mn(h),x=qi(y,b);d.assign(m),p.assign(x);const w=we(K(Oe(r,s),Oe(m,we(x,this.epsilon))),o);o.assign(w)}),this.iteration.assign(we(this.iteration,1)),this.accBeta1.assign(K(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ke(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ke(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class nw extends Pa{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=W.registeredVariables[s];se(()=>{const o=we(K(this.c,i),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=En(Me(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class RN extends nw{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Me(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:se(()=>ct(i).variable(!1))});const a=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&se(()=>{let u;const h=we(K(this.m,a),o);this.useNesterov?u=we(K(this.c,we(o,K(h,this.m))),i):u=we(K(this.c,h),i),a.assign(h),i.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ke(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class DN extends Pa{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=W.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:se(()=>ct(i).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:se(()=>ct(i).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:se(()=>ct(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const u=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;se(()=>{const d=we(K(u,this.decay),K($t(o),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,m=we(K(p,this.decay),K(o,1-this.decay)),y=Oe(K(o,this.learningRate),Pn(_e(d,we($t(m),this.epsilon)))),b=we(K(h,this.momentum),y);u.assign(d),p.assign(m),h.assign(b);const x=_e(i,b);i.assign(x)}else{const p=we(K(u,this.decay),K($t(o),1-this.decay)),m=we(K(h,this.momentum),Oe(K(o,this.learningRate),Pn(we(p,this.epsilon))));u.assign(p),h.assign(m);const y=_e(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ke(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ke(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ke(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const ine=[$N,IN,_N,AN,RN,DN,nw];function ane(){for(const n of ine)ve(n)}const one="model",lne=".json",une=".weights.bin";function EO(n){return new Promise(e=>setTimeout(e)).then(n)}class eu{constructor(e){if(!ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(eu.URL_SCHEME)&&(e=e.slice(eu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=one),this.modelJsonFileName=e+lne,this.weightDataFileName=e+une}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=xi.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=_M(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await EO(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await EO(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Cm(e)}}}}eu.URL_SCHEME="downloads://";class cne{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const u=S2(i,h=>this.loadWeights(h));e(u)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),i=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(i).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const i=new FileReader;i.onload=a=>{const o=a.target.result;s(o)},i.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(i=>gO(i.name)),r={};for(const i of e)i.paths.forEach(a=>{const o=gO(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const hne=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(eu.URL_SCHEME)?dne(n.slice(eu.URL_SCHEME.length)):null;qt.registerSaveRouter(hne);function dne(n="model"){return new eu(n)}function fne(n){return new cne(n)}function $O(n,e,t,s){a(n),t=t??0,s=s??1,o(t,s);let r=0;const i=u=>(u.then(h=>{const d=t+ ++r/n.length*(s-t);return e(d),h}),u);function a(u){D(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,h){D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),D(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),D(h>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${h}`)}return Promise.all(n.map(i))}async function Gz(n,e){e==null&&(e={});const t=e.fetchFunc==null?ie().platform.fetch:e.fetchFunc,s=n.map(p=>t(p,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await $O(s,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(o):await $O(o,e.onProgress,.5,1)}function pne(n,e){var t;const s=e.fetchFunc==null?ie().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var o;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:h}=await i.read();if(u){r++,i=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/n.length);continue}a.enqueue(h);return}a.close()}})}async function Hz(n,e="",t,s){return qz(a=>Gz(a,{requestInit:s}))(n,e,t)}function qz(n){return async(e,t="",s)=>{const r=e.map(()=>!1),i={},a=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((y,b)=>{let x=0;y.weights.forEach(w=>{const S="quantization"in w?w.quantization.dtype:w.dtype,C=Hl[S]*he(w.shape),N=()=>{r[b]=!0,i[b]==null&&(i[b]=[]),i[b].push({manifestEntry:w,groupOffset:x,sizeBytes:C})};s!=null?s.forEach((k,E)=>{k===w.name&&(N(),a[E]=!0)}):N(),o.push(w.name),x+=C})}),!a.every(y=>y)){const y=s.filter((b,x)=>!a[x]);throw new Error(`Could not find weights in manifest with names: ${y.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const u=r.reduce((y,b,x)=>(b&&y.push(x),y),[]),h=[];u.forEach(y=>{e[y].paths.forEach(b=>{const x=t+(t.endsWith("/")?"":"/")+b;h.push(x)})});const d=await n(h),p={};let m=0;return u.forEach(y=>{const b=e[y].paths.length,x=new xi(d.slice(m,m+b));i[y].forEach(S=>{const C=x.slice(S.groupOffset,S.groupOffset+S.sizeBytes),N=x2(C,[S.manifestEntry]);for(const k in N)p[k]=N[k]}),m+=b}),p}}const mne="application/octet-stream",gne="application/json";class ON{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ie().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=_M(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:gne}),"model.json"),e.weightData!=null){const a=xi.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:mne}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:Cm(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return S2(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=A0(e.weightsManifest),r=()=>pne(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=yne(t),i=this.weightPathPrefix||s,a=[],o=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(h)):a.push(i+h+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){const t=await this.getWeightUrls(e),s=A0(e),r=await Gz(t,this.loadOptions);return[s,r]}}ON.URL_SCHEME_REGEX=/^https?:\/\//;function yne(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function VT(n){return n.match(ON.URL_SCHEME_REGEX)!=null}const Kz=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>VT(s)):t=VT(n),t)return FN(n,e)}return null};qt.registerSaveRouter(Kz);qt.registerLoadRouter(Kz);function FN(n,e){return new ON(n,e)}function Xz(n,e){return FN(n,e)}class AS{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Yz{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class bne{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Jz(n,e,t,s){const r=arguments;return new bne(D0(...r))}function D0(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new AS(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new AS({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new AS({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function xne(n){return new Yz(n)}function wne(n){return new Yz(n)}const LN=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:xi,browserFiles:fne,browserHTTPRequest:Xz,concatenateArrayBuffers:IM,copyModel:Q9,decodeWeights:x2,decodeWeightsStream:$M,encodeWeights:DT,fromMemory:Jz,fromMemorySync:D0,getLoadHandlers:RM,getModelArtifactsForJSON:S2,getModelArtifactsForJSONSync:v2,getModelArtifactsInfoForJSON:Cm,getSaveHandlers:AM,getWeightSpecs:A0,http:FN,isHTTPScheme:VT,listModels:J9,loadWeights:Hz,moveModel:eY,registerLoadRouter:P9,registerSaveRouter:z9,removeModel:Z9,weightsLoaderFactory:qz,withSaveHandler:xne,withSaveHandlerSync:wne},Symbol.toStringTag,{value:"Module"}));function vne(n,e,t){const s=M(n,"labels","confusionMatrix"),r=M(e,"predictions","confusionMatrix");D(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),D(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),D(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),D(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),D(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const i=Vc(Ne(s,"int32"),t),a=Vc(Ne(r,"int32"),t),o=at(i),u=nt(o,a);return Ne(u,"int32")}const Sne=G({confusionMatrix_:vne});const Tne=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Sne},Symbol.toStringTag,{value:"Module"}));let yl,IO=!1;function Zz(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Qf(I0,W.backendName)!=null){const b={pixels:n},x={numChannels:e};return W.runKernel(I0,b,x)}const[h,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let p;if(a)p=n.getContext("2d").getImageData(0,0,h,d).data;else if(s||t)p=n.data;else if(i||r||o){if(yl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")yl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else yl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});yl.canvas.width=h,yl.canvas.height=d,yl.drawImage(n,0,0,h,d),p=yl.getImageData(0,0,h,d).data}let m;if(e===4)m=new Int32Array(p);else{const b=h*d;m=new Int32Array(b*e);for(let x=0;x<b;x++)for(let w=0;w<e;++w)m[x*e+w]=p[x*4+w]}return yN(m,[d,h,e],"int32")}function Cne(n){return n!=null&&n.data instanceof Uint8Array}function Nne(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function kne(n){return n!=null&&n.width!==0&&n.height!==0}function Ene(n){return Nne()&&!(n instanceof ImageBitmap)&&kne(n)&&!Cne(n)}async function $ne(n,e=3){let t=null;if(ie().getBool("WRAP_TO_IMAGEBITMAP")&&Ene(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return Zz(t,e)}function Qz(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function Ine(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function _ne(n,e){let t=M(n,"img","toPixels");if(!(n instanceof mt)){const h=t;t=Ne(h,"int32"),h.dispose()}Qz(t);const[s,r]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],a=await t.data(),o=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let h=0;h<s*r;++h){const d=[0,0,0,255];for(let m=0;m<i;m++){const y=a[h*i+m];if(t.dtype==="float32"){if(y<0||y>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${y}.`)}else if(t.dtype==="int32"&&(y<0||y>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${y}.`);i===1?(d[0]=y*o,d[1]=y*o,d[2]=y*o):d[m]=y*o}const p=h*4;u[p+0]=Math.round(d[0]),u[p+1]=Math.round(d[1]),u[p+2]=Math.round(d[2]),u[p+3]=Math.round(d[3])}if(e!=null){IO||Qf(_b,W.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),IO=!0),e.width=r,e.height=s;const h=e.getContext("2d"),d=new ImageData(u,r,s);h.putImageData(d,0,0)}return t!==n&&t.dispose(),u}function Ane(n,e,t){let s=M(n,"img","draw");if(!(n instanceof mt)){const a=s;s=Ne(a,"int32"),a.dispose()}Qz(s),Ine(t?.imageOptions);const r={image:s},i={canvas:e,options:t};W.runKernel(_b,r,i)}const eP=G({fromPixels_:Zz}),Rne=Object.freeze(Object.defineProperty({__proto__:null,draw:Ane,fromPixels:eP,fromPixelsAsync:$ne,toPixels:_ne},Symbol.toStringTag,{value:"Module"}));function sw(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(he(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let p=0;p<r.length-1;++p)a*=r[p];const o=n.shape,u=r.slice();u.pop();let h=1;for(let p=i;p<t;++p)h*=o[p],u.push(o[p]);const d=[...ze(n.shape).map(p=>p/h),1].slice(0,i);return[u,a,h,d]}const Dne=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:sw},Symbol.toStringTag,{value:"Module"}));const UT=-2,One=-1;function MN(n,e,t){const s=n.shape.length;D(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),D(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)D(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Fne(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function zN(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function tP(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function nP(n,e,t){return t<=n?t:t-(e-1)}function sP(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function Lne(n,e,t,s,r,i,a,o,u){const h=n.length;let d=new Array(h),p=new Array(h),m=new Array(h);if(e.length&&t>0){const y=e[0],b=t+1;d=rP(a,y,b,s,n),p=iP(o,y,b,r,n),m=tP(i,y,b,n)}else for(let y=0;y<h;y++)d[y]=oP(a,s,i,n,y,u),p[y]=lP(o,r,i,n,y,u),m[y]=aP(i,y,u);return{begin:d,end:p,strides:m}}function rP(n,e,t,s,r){const i=[...r],a=sP(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const u=nP(e,t,o);let h=s[u];n&1<<u&&(h=0),i[o]=h}return i}function iP(n,e,t,s,r){const i=[...r],a=sP(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const u=nP(e,t,o);let h=s[u];n&1<<u&&(h=Number.MAX_SAFE_INTEGER),i[o]=h}for(let o=0;o<i.length;o++){const u=r[o];i[o]<0&&(i[o]+=u),i[o]=Eo(0,i[o],r[o])}return i}function aP(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function oP(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),a=Eo(0,a,u-1),a}function lP(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const u=s[r];return a<0&&(a+=u),o>0?a=Eo(0,a,u):a=Eo(-1,a,u-1),a}function PN(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function BN(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function rw(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{D(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((a,o)=>a>=0?a:(D(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,i]}function VN(n,e,t,s,r,i,a,o,u){let h;if(s==null?(h=new Array(e.length),h.fill(1)):h=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:h.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:u};for(let N=0;N<p.dims;N++)d&&(1<<N&o)!==0&&p.numAddAxisAfterEllipsis++,1<<N&a&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Mne(p,m);let y=!0,b=!0,x=!0;const w=[],S=[];for(let N=0;N<n.length;++N){if(m.strides[N]===0)throw Error(`strides[${N}] must be non-zero`);const k=!!(m.shrinkAxisMask&1<<N),E=n[N];if(E===-1){w.push(k?1:-1);continue}const _=[m.beginMask&1<<N,m.endMask&1<<N],R=[m.strides[N]>0?0:-1,m.strides[N]>0?E:E-1];if(k&&m.strides[N]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[N]===1;const O=!!(m.beginMask&1<<N&&m.endMask&1<<N);if(m.beginValid&&m.endValid){if(k){const U=m.begin[N]<0?E+m.begin[N]:m.begin[N];if(m.begin[N]=U,m.end[N]=m.begin[N]+1,U<0||U>=E)throw Error(`slice index ${m.begin[N]} of dimension ${N} out of bounds.`)}else m.begin[N]=_O(m.begin[N],0,m.strides[N],E,_,R),m.end[N]=_O(m.end[N],1,m.strides[N],E,_,R);const A=m.strides[N]===1&&m.begin[N]===0&&m.end[N]===E;y=y&&A,b=b&&(N===0&&m.strides[N]===1||A)}else y=y&&m.strides[N]===1&&O,b=b&&(N===0&&m.strides[N]===1||O);let F,L=!1;if(m.beginValid&&m.endValid?(F=m.end[N]-m.begin[N],L=!0):k?(F=1,L=!0):O&&E>=0&&(m.strides[N]<0?F=-E:F=E,L=!0),L){let A;F===0||F<0!=m.strides[N]<0?A=0:A=Math.trunc(F/m.strides[N])+(F%m.strides[N]!==0?1:0),w.push(A)}else w.push(-1)}for(let N=0;N<m.finalShapeGatherIndices.length;++N){const k=m.finalShapeGatherIndices[N];k>=0?S.push(w[k]):k===UT&&S.push(1)}return{finalShapeSparse:S.filter((N,k)=>m.finalShapeGatherIndices[k]!==UT),finalShape:S,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function Mne(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(UT),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(One),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function _O(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const a=n<0?s+n:n;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const uP=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:MN,computeFlatOffset:BN,computeOutShape:zN,getNormalizedAxes:Lne,isSliceContinous:PN,maskToAxes:Fne,parseSliceParams:rw,sliceInfo:VN,startForAxis:oP,startIndicesWithElidedDims:rP,stopForAxis:lP,stopIndicesWithElidedDims:iP,stridesForAxis:aP,stridesWithElidedDims:tP},Symbol.toStringTag,{value:"Module"}));const cP="4.22.0";class hP{static sgd(e){return new nw(e)}static momentum(e,t,s=!1){return new RN(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new DN(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new _N(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new $N(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new AN(e,t,s,r,i)}static adagrad(e,t=.1){return new IN(e,t)}}const Sl=hP;const zne=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function UN(){return new Promise(n=>zne(()=>n()))}function jN(n,e){const t=n[0].length;n.forEach((r,i)=>{D(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),D(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let a=0;a<t;a++)D(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function zi(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var ci;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(ci||(ci={}));function dP(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],a=s[s.length-t.length+r],o=s[a];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${o}`)}else s[a]=i}return s}function fP(n){const e={FIRST_DIM_SIZE:ci.FIRST_DIM_SIZE,VALUE_ROWIDS:ci.VALUE_ROWIDS,ROW_LENGTHS:ci.ROW_LENGTHS,ROW_SPLITS:ci.ROW_SPLITS,ROW_LIMITS:ci.ROW_LIMITS,ROW_STARTS:ci.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function pP(n){return n.length===0?0:n[0]===ci.FIRST_DIM_SIZE?n.length-1:n.length}function mP(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],a=e[r+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}const WN=30;function iw(n){return n<=WN?n:k0(n,Math.floor(Math.sqrt(n)))}function GN(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function jm(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let a=0;a<i;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(i+1))}return r}function Wm(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?i.push(a):r.push(a);s.push(...r),s.push(0),s.push(...i)}return s}function Gm(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function HN(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function qN(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const aw=1.7580993408473768,ow=1.0507009873554805;const KN=.3275911,XN=.254829592,YN=-.284496736,JN=1.421413741,ZN=-1.453152027,QN=1.061405429;function $a(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function gP(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function yP(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function bP(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function ek(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function xP(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function wP(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function vP(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const RS="->",Pne=/->/g,AO=",",RO="...";function tk(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(Pne,"").length)/RS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${RS}").`);const[s,r]=n.split(RS);D(s.indexOf(RO)===-1,()=>`The ellipsis notation ("${RO}") is not supported yet.`);const i=s.split(AO),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);o.indexOf(y)===-1&&o.push(y)}for(let m=0;m<s.length;++m){const y=s[m];o.indexOf(y)===-1&&y!==AO&&o.push(y)}const u=new Array(i.length);for(let m=0;m<a;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let y=0;y<i[m].length;++y)u[m].push(o.indexOf(i[m][y]))}const h=o.length,d=r.length,p=[];for(let m=d;m<h;++m)p.push(m);return{allDims:o,summedDims:p,idDims:u}}function nk(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function sk(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=i[a]:D(s[e[r][a]]===i[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function rk(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<t.length;++a){const o=t[a],u=Bne(e,o);for(const h of u)i.indexOf(h)===-1&&(s[a].push(h),i.push(h))}return{path:t,steps:s}}function ik(n){return n.every((e,t)=>e===t)}function Bne(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function ak(n,e,t=0){let s=[];if(typeof e=="number")D(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);D(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((o,u)=>u>0?o+u:o);e[i]=n.shape[t]-a}D(n.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function SP(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function TP(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function CP(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function NP(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function kP(n,e){return`size ${n} must be non-negative, not ${e}`}function EP(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function $P(n,e){const t=he(n),s=he(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function IP(n,e){const t=he(n),s=he(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function jT(){return"segment ids must be >= 0"}function _P(){return"segment ids are not increasing"}function AP(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function RP(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function DP(n,e){let t=!1,s;for(n<=WN?(s=n,t=!0):s=k0(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=k0(n,s+1);return s}function OP(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function ok(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let p=0;p<s;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const a=n.shape[t],o=[];let u=1,h=1,d=1;for(let p=0;p<s;++p)o.push(n.shape[p]),u*=n.shape[p];for(let p=s;p<t;p++)o.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<r;p++)o.push(e.shape[p]);for(let p=t+1;p<i;p++)o.push(n.shape[p]),d*=n.shape[p];return{batchSize:u,sliceSize:d,outerSize:h,dimSize:a,outputShape:o}}const Vne=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:ok,computeOutShape:OP,segOpComputeOptimalWindowSize:DP},Symbol.toStringTag,{value:"Module"}));function Ia(n){try{return n.map(e=>Ca(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function FP(n){return n.map(e=>Li(e))}const LP=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:XN,ERF_A2:YN,ERF_A3:JN,ERF_A4:ZN,ERF_A5:QN,ERF_P:KN,PARALLELIZE_THRESHOLD:WN,get RowPartitionType(){return ci},SELU_SCALE:ow,SELU_SCALEALPHA:aw,applyActivation:Jx,assertAndGetBroadcastShape:Xe,assertAxesAreInnerMostDims:Qn,assertParamsConsistent:jN,assignToTypedArray:xP,axesAreInnerMostDims:Y2,calculateShapes:Ho,checkEinsumDimSizes:sk,checkPadOnDimRoundingMode:ws,combineLocations:qM,combineRaggedTensorToTensorShapes:dP,complexWithEvenIndex:yP,complexWithOddIndex:bP,computeConv2DInfo:Vn,computeConv3DInfo:Vo,computeDefaultPad:R2,computeDilation2DInfo:Nm,computeOptimalWindowSize:iw,computeOutAndReduceShapes:Un,computeOutShape:zi,computePool2DInfo:Hr,computePool3DInfo:Oa,convertConv2DDataFormat:Fa,decodeEinsumEquation:tk,eitherStridesOrDilationsAreOne:Zn,expandShapeToKeepDim:un,exponent:vP,exponents:wP,fromStringArrayToUint8:FP,fromUint8ToStringArray:Ia,getAxesPermutation:Zt,getBroadcastDims:Jl,getComplexWithIndex:ek,getEinsumComputePath:rk,getEinsumPermutation:nk,getFusedBiasGradient:Yx,getFusedDyActivation:Xx,getImageCenter:GN,getInnerMostAxes:cn,getPermuted:Wm,getRaggedRank:pP,getReductionAxes:xn,getReshaped:jm,getReshapedPermuted:Gm,getRowPartitionTypesHelper:fP,getSliceBeginCoords:HN,getSliceSize:qN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:SP,getSparseFillEmptyRowsNegativeIndexErrorMessage:TP,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:CP,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:EP,getSparseReshapeInputOutputMismatchErrorMessage:IP,getSparseReshapeInputOutputMultipleErrorMessage:$P,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:NP,getSparseReshapeNegativeOutputDimErrorMessage:kP,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:RP,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:jT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:_P,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:AP,getUndoAxesPermutation:Uo,isIdentityPermutation:ik,log:BX,mergeRealAndImagArrays:$a,prepareAndValidate:sw,prepareSplitSize:ak,segment_util:Vne,shouldFuse:Zx,slice_util:uP,splitRealAndImagArrays:gP,stridesOrDilationsArePositive:Yl,tupleValuesAreOne:_o,upcastType:_s,validateDefaultValueShape:mP,validateInput:Wx,validateUpdateShape:bN,warn:gr},Symbol.toStringTag,{value:"Module"}));const Une=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Qx,nonMaxSuppressionV4Impl:ew,nonMaxSuppressionV5Impl:tw,whereImpl:qx},Symbol.toStringTag,{value:"Module"}));ane();const MP={kernelName:wp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,mu(Ne(t,"float32"),-1))}}};const jne={kernelName:eh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=$t(Ne(t,"float32")),r=Pn(_e(Me(1),s));return Mt(Oe(n,r))}}}};const Wne={kernelName:th,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pn(_e($t(Ne(t,"float32")),1));return Oe(n,s)}}}};const Gne={kernelName:du,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{let o=n;const u=xn(t.shape,r);return u.length>0&&(o=Ae(o,u)),X(o,t.shape)},b:()=>{let o=n;const u=xn(s.shape,r);return u.length>0&&(o=Ae(o,u)),X(o,s.shape)}}}};const Hne={kernelName:vp,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const qne={kernelName:Sp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ct(t)}}};const Kne={kernelName:Tp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ct(t)}}};const Xne={kernelName:nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,Pn(_e(Me(1),$t(Ne(t,"float32")))))}}};const Yne={kernelName:sh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pn(we(Me(1),$t(Ne(t,"float32"))));return Oe(n,s)}}}};const Jne={kernelName:ah,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=we($t(t),$t(s));let u=K(n,Oe(s,o));const h=xn(t.shape,r);return h.length>0&&(u=Ae(u,h)),X(u,t.shape)},b:()=>{const o=we($t(t),$t(s));let u=Mt(K(n,Oe(t,o)));const h=xn(s.shape,r);return h.length>0&&(u=Ae(u,h)),X(u,s.shape)}}}};const Zne={kernelName:rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,we($t(Ne(t,"float32")),1))}}};const Qne={kernelName:ih,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,_e(Me(1),$t(Ne(t,"float32"))))}}};function ese(n,e,t,s,r,i){const a=M(n,"dy","avgPool3dGrad"),o=M(e,"input","avgPool3dGrad");let u=a,h=o,d=!1;o.rank===4&&(d=!0,u=X(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=X(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),ws("avgPool3dGrad",r,i);const p={dy:u,input:h},m={filterSize:t,strides:s,pad:r,dimRoundingMode:i},y=W.runKernel(gb,p,m);return d?X(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const tse=G({avgPool3dGrad_:ese});const nse={kernelName:Np,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=t;return{x:()=>tse(n,s,r,i,a,o)}}};function sse(n,e,t,s,r){const i=M(n,"dy","avgPoolGrad"),a=M(e,"input","avgPoolGrad");D(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,u=i,h=!1;a.rank===3&&(h=!0,o=X(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=X(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),D(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const d={dy:u,input:o},p={filterSize:t,strides:s,pad:r},m=W.runKernel(mb,d,p);return h?X(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const rse=G({avgPoolGrad_:sse});const ise={kernelName:Cp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=t;return{x:()=>rse(n,s,r,i,a)}}};const ase={kernelName:kp,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:a}=t;return!i&&!a?{a:()=>nt(n,r,!1,!0),b:()=>nt(s,n,!0,!1)}:!i&&a?{a:()=>nt(n,r,!1,!1),b:()=>nt(n,s,!0,!1)}:i&&!a?{a:()=>nt(r,n,!1,!0),b:()=>nt(s,n,!1,!1)}:{a:()=>nt(r,n,!0,!0),b:()=>nt(n,s,!0,!0)}}};const ose={kernelName:Ep,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>Lm(n,s,r)}}};const lse={kernelName:lM,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,a=Array.from(i);for(let u=r.length-1;u>=0;u--)if(r[u]===i[u])a[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const o=[];for(let u=0;u<a.length;u++)a[u]>1&&o.push(u);return{x:()=>Ae(n,o,!0)}}};const use={kernelName:oh,gradFunc:n=>({x:()=>n.clone()})};const cse={kernelName:lh,gradFunc:n=>({x:()=>ct(n)})};const hse={kernelName:uh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>Mn(Gr(La(s,r),jo(s,i)),n,ct(n))}}};const dse={kernelName:Ip,inputsToSave:["x"],gradFunc:MP.gradFunc};const fse={kernelName:_p,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(u=>u.shape),{axis:r}=t,i=st(r,e[0].shape)[0],a=s.map(u=>u[i]);return Is(n,a,i).map(u=>()=>u)}};const pse={kernelName:Ap,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:u}=t;return D(_o(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>j2(s.shape,n,r,a,o,u),filter:()=>NN(s,n,r.shape,a,o,u)}}};const mse={kernelName:Rp,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:u}=t;return{dy:()=>Ea(n,r,i,a,o,1,u),filter:()=>NN(n,s,r.shape,i,a,o,u)}}};function gse(n,e,t,s,r){let i=n;n.rank===4&&(i=X(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=X(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),D(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),D(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),D(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),D(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),D(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:i,dy:a},u={strides:s,pad:r,filterShape:t};return W.runKernel(vb,o,u)}const yse=G({conv3DBackpropFilter_:gse});const bse={kernelName:Dp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;D(_o(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>WM(a.shape,n,o,r,i),filter:()=>yse(a,n,o.shape,r,i)}}};const xse={kernelName:ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(Mt(Px(Ne(t,"float32"))),n)}}};const wse={kernelName:hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(Bx(Ne(t,"float32")),n)}}};const vse={kernelName:Op,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=t;return{x:()=>{const o=Zt([r],s.rank);let u=kx(n,r,i,!a);return o!=null&&(u=at(u,o)),u}}}};const Sse={kernelName:Fp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=t,o=s??[1,1];D(_o(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,h]=e;return D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),D(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),D(u.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),D(Zn(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),ws("depthwiseConv2d",i,a),{x:()=>Oz(u.shape,n,h,r,i,o,a),filter:()=>Dz(u,n,h.shape,r,i,o,a)}}};const Tse={kernelName:Lp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>W.runKernel(E0,i,t),filter:()=>W.runKernel($0,a,t)}}};const Cse={kernelName:fh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>W.runKernel(Rb,s)}}};const Nse={kernelName:ph,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=K(Ds(Mt($t(t))),2/Math.sqrt(Math.PI));return{x:()=>K(n,s)}}};const kse={kernelName:mh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,t)}}};const Ese={kernelName:zp,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>X(n,t.shape)}}};const $se={kernelName:gh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,Ds(t))}}};const Ise={kernelName:yh,gradFunc:n=>({x:()=>ct(n)})};const _se={kernelName:bh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=Oe(n,Ne(s,"float32")),u=xn(t.shape,r);return u.length>0?X(Ae(o,u),t.shape):o},b:()=>{let o=K(n,Ne(t,"float32"));const u=xn(s.shape,r);u.length>0&&(o=X(Ae(o,u),s.shape));const h=$t(s);return Mt(Oe(o,Ne(h,"float32")))}}}};const Ase={kernelName:Pp,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,a,o]=e,u=o??Me(1),h=xn(i.shape,r.shape),d=[];if(i.rank===1){for(let k=0;k<r.shape.length-1;++k)d.push(r.shape[k]);d.push(1)}const p=_e(r,i),m=K(n,u),y=Lx(we(a,Me(s))),b=K(K(K(y,y),y),Me(-.5));return{x:()=>i.rank===1?X(K(K(n,br(X(y,[1,1,1,i.shape[0]]),d)),u),r.shape):X(K(K(n,y),u),r.shape),mean:()=>{let k=K(K(y,Me(-1)),m);return i.rank===1&&(k=Ae(k,h)),X(k,i.shape)},variance:()=>{let k=K(K(b,p),m);return i.rank===1&&(k=Ae(k,h)),X(k,i.shape)},scale:()=>{const k=K(p,y);let E=K(n,k);return i.rank===1&&(E=Ae(E,h)),X(E,i.shape)},offset:()=>{let k=n;return i.rank===1&&(k=Ae(k,h)),X(k,i.shape)}}}};const Rse={kernelName:Bp,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:a}=t,o=st(i,s.shape)[0],u=(h,d,p)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,o),x=b.length,w=m.slice(i,m.length).slice(1),S=w.length,C=DO(0,x),N=DO(x+1,x+1+S),k=OO([b,[y],w]),E=X(p,k),_=X(d,[y]),R=OO([[x],C,N]),O=at(E,R);let F=Hx(O,_,h.shape[o]);const L=Uo(R);return F=at(F,L),F};if(a===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>bs(d.map((y,b)=>u(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:u(s,r,n),indices:()=>r}}};function DO(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function OO(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const Dse={kernelName:xh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ct(t),b:()=>ct(s)}}};const Ose={kernelName:wh,gradFunc:n=>({x:()=>Ne(n,"float32")})};const Fse={kernelName:vh,gradFunc:n=>({x:()=>ct(n)})};const Lse={kernelName:Sh,gradFunc:n=>({x:()=>ct(n)})};const Mse={kernelName:Th,gradFunc:n=>({x:()=>ct(n)})};const zse={kernelName:Up,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=vs(s,0);return{x:()=>Mn(i,n,K(n,r))}}};const Pse={kernelName:Nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,we(t,1))}}};const Bse={kernelName:Ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,Ne(t,"float32"))}}};const Vse={kernelName:uM,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const a=Ds(s);return _e(n,K(Ae(n,r,!0),a))}}}};function Use(n,e,t,s=5,r=1,i=1,a=.5){const o={x:n,y:e,dy:t},u={depthRadius:s,bias:r,alpha:i,beta:a};return W.runKernel(Bb,o,u)}const jse=G({localResponseNormalizationBackprop_:Use});const Wse={kernelName:Kp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:u}=t;return{x:()=>jse(s,r,n,i,a,o,u)}}};function zP(n,e,t,s){return e.rank<t.rank&&(e=X(e,un(e.shape,s))),n.rank<t.rank&&(n=X(n,un(n.shape,s))),{x:()=>K(n,Ne(Js(t,e),n.dtype))}}const FO={kernelName:Xp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],a=e[1],o=st(r,i.shape),u=zP(n,a,i,o);return{x:()=>u.x()}}};const Gse={kernelName:kh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>K(n,Ne(La(t,s),"float32")),b:()=>K(n,Ne(Bc(t,s),"float32"))}}};function Hse(n,e,t,s,r,i,a){const o=M(n,"dy","maxPool3dGrad"),u=M(e,"input","maxPool3dGrad"),h=M(t,"output","maxPool3dGrad");let d=o,p=u,m=h,y=!1;u.rank===4&&(y=!0,d=X(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=X(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=X(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),D(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),D(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),D(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),ws("maxPool3dGrad",i,a);const b={dy:d,input:p,output:m},x={filterSize:s,strides:r,pad:i,dimRoundingMode:a},w=W.runKernel(Ub,b,x);return y?X(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const qse=G({maxPool3dGrad_:Hse});const Kse={kernelName:Jp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=t;return{x:()=>qse(n,s,r,i,a,o,u)}}};function Xse(n,e,t,s,r,i,a){const o=M(n,"dy","maxPoolGrad"),u=M(e,"input","maxPoolGrad"),h=M(t,"output","maxPoolGrad");D(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),D(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),D(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),ws("maxPoolGrad",i,a);const d={dy:o,input:u,output:h},p={filterSize:s,strides:r,pad:i,dimRoundingMode:a};return W.runKernel(Vb,d,p)}const Yse=G({maxPoolGrad_:Xse});const Jse={kernelName:Yp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=t;return{x:()=>Yse(n,s,r,i,a,o)}}};const Zse={kernelName:Zp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=st(r,s.shape),o=Un(s.shape,i)[1],u=he(o);return{x:()=>{const d=s.shape.slice();i.forEach(y=>{d[y]=1});const p=X(n,d);return Oe(K(p,$s(s.shape,"float32")),u)}}}};const Qse={kernelName:Qp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,a]=e,o=st(r,i.shape),u=zP(n,a,i,o);return{x:()=>u.x()}}};const ere={kernelName:Eh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>K(n,Ne(jo(t,s),"float32")),b:()=>K(n,Ne(vs(t,s),"float32"))}}};const tre={kernelName:em,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>ut(n,i,s.shape)}}};const nre={kernelName:$h,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=xn(t.shape,r);return o.length>0?X(Ae(n,o),t.shape):n},b:()=>{const o=K(n,Mt(Qh(Oe(t,s)))),u=xn(s.shape,r);return u.length>0?X(Ae(o,u),s.shape):o}}}};const sre={kernelName:Ih,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=K(n,Ne(s,"float32")),u=xn(t.shape,r);return u.length>0?X(Ae(o,u),t.shape):o},b:()=>{const o=K(n,Ne(t,"float32")),u=xn(s.shape,r);return u.length>0?X(Ae(o,u),s.shape):o}}}};const rre={kernelName:tm,gradFunc:n=>({x:()=>Mt(n)})};const ire={kernelName:rm,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>gn(t.shape,"float32")}}};const are={kernelName:sm,gradFunc:n=>({x:()=>ct(n)})};const ore={kernelName:im,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Cr(n,s).map(i=>()=>i)}};const LO={kernelName:am,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>ut(n,i,s.shape)}}};const lre={kernelName:_h,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,a=s,o=Xe(i.shape,a.shape);return{a:()=>{const d=Ne(a,"float32");let p=K(n,K(d,ji(i,_e(d,Me(1)))));const m=xn(i.shape,o);return m.length>0&&(p=Ae(p,m)),X(p,i.shape)},b:()=>{const d=vs(i,0),p=Mn(d,Zs(i),ct(i));let m=K(n,K(r,p));const y=xn(a.shape,o);return y.length>0&&(m=Ae(m,y)),X(m,a.shape)}}}};const ure={kernelName:om,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=vs(t,0);return{x:()=>Mn(r,n,K(n,s)),alpha:()=>{let i=Mn(r,ct(n),K(n,t));const a=xn(s.shape,n.shape);return a.length>0&&(i=Ae(i,a)),X(i,s.shape)}}}};function cre(n,e,t){const s=n.shape.slice();s[t]=1;const r=X(e,s),i=ip(n,t,!0,!1),a=ip(n,t,!0,!0),o=K(i,a);return K(r,o)}function hre(n,e,t){const s=n.shape.length,r=s-t.length,i=Zt(t,s);let a=n;i!=null&&(a=at(n,i));const o=a.shape.slice(),h=o.splice(s-t.length,t.length).reduce((m,y)=>m*y,1);o.push(h);const d=a.reshape(o);let p=cre(d,e,r);if(p=p.reshape(a.shape),i!=null){const m=Uo(i);p=at(p,m)}return p}const dre={kernelName:lm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((a,o)=>o):typeof r=="number"?i=[r]:i=r,{x:()=>hre(s,n,i)}}};const fre={kernelName:dh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=Oe(n,Ne(s,"float32")),u=xn(t.shape,r);return u.length>0?X(Ae(o,u),t.shape):o},b:()=>{let o=K(n,Ne(t,"float32"));const u=xn(s.shape,r);u.length>0&&(o=X(Ae(o,u),s.shape));const h=$t(s);return Mt(Oe(o,Ne(h,"float32")))}}}};const pre={kernelName:Ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,Mt($t(t)))}}};const mre={kernelName:Dh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=K(jo(t,6),mu(t));return{x:()=>K(n,Ne(s,"float32"))}}};const gre={kernelName:Rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,Ne(mu(t),"float32"))}}};const yre={kernelName:um,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,t.shape)}}};const bre={kernelName:hm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(ex,r,t)}}};const xre={kernelName:cm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(Qb,r,t)}}};const wre={kernelName:dm,gradFunc:(n,e,t)=>{const{dims:s}=t,r=st(s,n.shape);return{x:()=>Tr(n,r)}}};const vre={kernelName:Oh,gradFunc:n=>({x:()=>ct(n)})};const Sre={kernelName:Fh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Mt(Oe(n,K(ji(t,1.5),2)))}}};const Tre={kernelName:fm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ne(ct(t),"float32"),t:()=>K(n,Ne(t,n.dtype)),e:()=>K(n,Ne(Dm(t),n.dtype))}}};const Cre={kernelName:Lh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=vs(t,Me(0)),r=Me(aw),i=Me(ow),a=K(n,i),o=K(K(n,r),Ds(Ne(t,"float32")));return Mn(s,a,o)}}}};const Nre={kernelName:Bh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,K(t,_e(Me(1),t)))}}};const kre={kernelName:Ph,gradFunc:n=>({x:()=>ct(n)})};const Ere={kernelName:Mh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K($m(Ne(t,"float32")),n)}}};const $re={kernelName:zh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(Nx(Ne(t,"float32")),n)}}};const Ire={kernelName:pm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,a=s.shape,[o,u]=rw(s,r,i),h=[];for(let d=0;d<n.rank;d++)h.push([o[d],a[d]-o[d]-u[d]]);return{x:()=>Ma(n,h)}}};const _re={kernelName:bm,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,a=K(n,s);return{logits:()=>_e(a,K(Ae(a,[r],i),s))}}};const Are={kernelName:Vh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,di(t))}}};const MO={kernelName:gm,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>Em(n,s,r)}}};const zO={kernelName:ym,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>ln(n,s)}}};const Rre={kernelName:Uh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,K(Pn(Ne(t,"float32")),2))}}};const Dre={kernelName:ux,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,K(Ne(t,"float32"),2))}}};const Ore={kernelName:jh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Me(2);return{a:()=>K(n,K(r,_e(t,s))),b:()=>K(n,K(r,_e(s,t)))}}};const Fre={kernelName:Kh,gradFunc:n=>({x:()=>ct(n)})};const Lre={kernelName:Wh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{let o=n;const u=xn(t.shape,r);return u.length>0&&(o=Ae(o,u)),X(o,t.shape)},b:()=>{let o=n;const u=xn(s.shape,r);return u.length>0&&(o=Ae(o,u)),X(Mt(o),s.shape)}}}};const Mre={kernelName:mm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;st(i,s.shape).forEach(h=>{r[h]=1});const o=X(n,r),u=K(o,$s(s.shape,"float32"));return{x:()=>u}}};const zre={kernelName:Gh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Oe(n,$t($m(t)))}}};const Pre={kernelName:Hh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(_e(Me(1),$t(t)),n)}}};const Bre={kernelName:qh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let a=ct(s);if(s.rank===1)for(let o=0;o<r[0];++o)a=we(a,ut(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)a=we(a,ut(n,[o*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let h=0;h<r[2];++h)a=we(a,ut(n,[o*s.shape[0],u*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let h=0;h<r[2];++h)for(let d=0;d<r[3];++d)a=we(a,ut(n,[o*s.shape[0],u*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};const Vre={kernelName:Bl,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=Uo(r);return{x:()=>at(n,i)}}};const Ure={kernelName:wm,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>bs(n,r)}}};const jre={kernelName:vm,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Wre(n,t)}}};function Wre(n,e){const t=qi(e,ct(e)),s=ed(n,t);let r=La(e,Me(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=Hn(r,o+1);r=Gr(r,$s(s.shape,"bool"));const a=ct(s);return Mn(r,s,a)}const Gre={kernelName:Sm,gradFunc:n=>({x:()=>ct(n)})};const Hre=[MP,jne,Wne,Gne,Hne,qne,Kne,Xne,Yne,Jne,Zne,Qne,nse,ise,ase,ose,lse,use,cse,hse,dse,fse,mse,pse,bse,xse,wse,vse,Sse,Tse,fre,Cse,Nse,kse,Ese,$se,_se,Ise,Ase,Rse,Dse,Ose,Fse,Lse,Mse,zse,Pse,Bse,Vse,Wse,FO,FO,Gse,Kse,Jse,Zse,Qse,ere,tre,nre,sre,rre,ire,are,ore,LO,LO,lre,ure,dre,pre,mre,gre,yre,bre,xre,wre,vre,Sre,Tre,Cre,Nre,kre,Ere,$re,Ire,_re,Are,MO,MO,zO,zO,Rre,Ore,Dre,Fre,Lre,Mre,zre,Pre,Bre,Vre,Ure,jre,Gre];for(const n of Hre)cM(n);pe().prototype.abs=function(){return this.throwIfDisposed(),mn(this)};pe().prototype.acos=function(){return this.throwIfDisposed(),C2(this)};pe().prototype.acosh=function(){return this.throwIfDisposed(),N2(this)};pe().prototype.add=function(n){return this.throwIfDisposed(),we(this,n)};pe().prototype.all=function(n,e){return this.throwIfDisposed(),Sx(this,n,e)};pe().prototype.any=function(n,e){return this.throwIfDisposed(),np(this,n,e)};pe().prototype.argMax=function(n){return this.throwIfDisposed(),Xl(this,n)};pe().prototype.argMin=function(n){return this.throwIfDisposed(),k2(this,n)};pe().prototype.asScalar=function(){return this.throwIfDisposed(),D(this.size===1,()=>"The array must have only 1 element."),X(this,[])};pe().prototype.asType=function(n){return this.throwIfDisposed(),Ne(this,n)};pe().prototype.as1D=function(){return this.throwIfDisposed(),X(this,[this.size])};pe().prototype.as2D=function(n,e){return this.throwIfDisposed(),X(this,[n,e])};pe().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),X(this,[n,e,t])};pe().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),X(this,[n,e,t,s])};pe().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),X(this,[n,e,t,s,r])};pe().prototype.asin=function(){return this.throwIfDisposed(),E2(this)};pe().prototype.asinh=function(){return this.throwIfDisposed(),$2(this)};pe().prototype.atan=function(){return this.throwIfDisposed(),I2(this)};pe().prototype.atan2=function(n){return this.throwIfDisposed(),_2(this,n)};pe().prototype.atanh=function(){return this.throwIfDisposed(),A2(this)};pe().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),km(this,n,e,t,s)};pe().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),Em(this,n,e)};pe().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Xh(this,n,e,t,s,r)};pe().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Vl(this,n)};pe().prototype.cast=function(n){return this.throwIfDisposed(),Ne(this,n)};pe().prototype.ceil=function(){return this.throwIfDisposed(),z2(this)};pe().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Rs(this,n,e)};pe().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof mt&&(n=[n]),ln([this,...n],e)};pe().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Tx(this,n,e,t,s,r,i)};pe().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),Cx(this,n,e,t,s,r)};pe().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Ea(this,n,e,t,s,r,i)};pe().prototype.cos=function(){return this.throwIfDisposed(),$m(this)};pe().prototype.cosh=function(){return this.throwIfDisposed(),Nx(this)};pe().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),ip(this,n,e,t)};pe().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),kx(this,n,e,t)};pe().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),H2(this,n,e)};pe().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Yh(this,n,e,t,s,r,i)};pe().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),q2(this,n,e,t,s,r)};pe().prototype.divNoNan=function(n){return this.throwIfDisposed(),K2(this,n)};pe().prototype.div=function(n){return this.throwIfDisposed(),Oe(this,n)};pe().prototype.dot=function(n){return this.throwIfDisposed(),X2(this,n)};pe().prototype.elu=function(){return this.throwIfDisposed(),Jh(this)};pe().prototype.equal=function(n){return this.throwIfDisposed(),Js(this,n)};pe().prototype.erf=function(){return this.throwIfDisposed(),Ex(this)};pe().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),J2(this,n,e)};pe().prototype.exp=function(){return this.throwIfDisposed(),Ds(this)};pe().prototype.expandDims=function(n){return this.throwIfDisposed(),Hn(this,n)};pe().prototype.expm1=function(){return this.throwIfDisposed(),Z2(this)};pe().prototype.fft=function(){return this.throwIfDisposed(),Vm(this)};pe().prototype.flatten=function(){return this.throwIfDisposed(),X(this,[this.size])};pe().prototype.floor=function(){return this.throwIfDisposed(),Qh(this)};pe().prototype.floorDiv=function(n){return this.throwIfDisposed(),vx(this,n)};pe().prototype.gather=function(n,e,t){return this.throwIfDisposed(),ed(this,n,e,t)};pe().prototype.greaterEqual=function(n){return this.throwIfDisposed(),La(this,n)};pe().prototype.greater=function(n){return this.throwIfDisposed(),vs(this,n)};pe().prototype.ifft=function(){return this.throwIfDisposed(),Wc(this)};pe().prototype.irfft=function(){return this.throwIfDisposed(),Ux(this)};pe().prototype.isFinite=function(){return this.throwIfDisposed(),Q2(this)};pe().prototype.isInf=function(){return this.throwIfDisposed(),eN(this)};pe().prototype.isNaN=function(){return this.throwIfDisposed(),tN(this)};pe().prototype.leakyRelu=function(n){return this.throwIfDisposed(),_m(this,n)};pe().prototype.lessEqual=function(n){return this.throwIfDisposed(),jo(this,n)};pe().prototype.less=function(n){return this.throwIfDisposed(),Bc(this,n)};pe().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),nN(this,n,e,t,s)};pe().prototype.logSigmoid=function(){return this.throwIfDisposed(),sN(this)};pe().prototype.logSoftmax=function(n){return this.throwIfDisposed(),_x(this,n)};pe().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Rm(this,n,e)};pe().prototype.log=function(){return this.throwIfDisposed(),Zs(this)};pe().prototype.log1p=function(){return this.throwIfDisposed(),Am(this)};pe().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Gr(this,n)};pe().prototype.logicalNot=function(){return this.throwIfDisposed(),Dm(this)};pe().prototype.logicalOr=function(n){return this.throwIfDisposed(),Ax(this,n)};pe().prototype.logicalXor=function(n){return this.throwIfDisposed(),rN(this,n)};pe().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),nt(this,n,e,t)};pe().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),Om(this,n,e,t,s)};pe().prototype.max=function(n,e){return this.throwIfDisposed(),Sr(this,n,e)};pe().prototype.maximum=function(n){return this.throwIfDisposed(),qi(this,n)};pe().prototype.mean=function(n,e){return this.throwIfDisposed(),Kt(this,n,e)};pe().prototype.min=function(n,e){return this.throwIfDisposed(),Pc(this,n,e)};pe().prototype.minimum=function(n){return this.throwIfDisposed(),Ro(this,n)};pe().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),aN(this,n,e)};pe().prototype.mod=function(n){return this.throwIfDisposed(),oN(this,n)};pe().prototype.mul=function(n){return this.throwIfDisposed(),K(this,n)};pe().prototype.neg=function(){return this.throwIfDisposed(),Mt(this)};pe().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Zh(this,n,e,t)};pe().prototype.notEqual=function(n){return this.throwIfDisposed(),Zl(this,n)};pe().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Vc(this,n,e,t)};pe().prototype.onesLike=function(){return this.throwIfDisposed(),Qs(this)};pe().prototype.pad=function(n,e){return this.throwIfDisposed(),Ma(this,n,e)};pe().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),lN(this,n,e,t,s,r,i)};pe().prototype.pow=function(n){return this.throwIfDisposed(),ji(this,n)};pe().prototype.prelu=function(n){return this.throwIfDisposed(),Mm(this,n)};pe().prototype.prod=function(n,e){return this.throwIfDisposed(),uN(this,n,e)};pe().prototype.reciprocal=function(){return this.throwIfDisposed(),fN(this)};pe().prototype.relu=function(){return this.throwIfDisposed(),wi(this)};pe().prototype.relu6=function(){return this.throwIfDisposed(),Ox(this)};pe().prototype.reshapeAs=function(n){return this.throwIfDisposed(),X(this,n.shape)};pe().prototype.reshape=function(n){return this.throwIfDisposed(),X(this,n)};pe().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),zz(this,n,e,t)};pe().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Pz(this,n,e,t)};pe().prototype.reverse=function(n){return this.throwIfDisposed(),Tr(this,n)};pe().prototype.rfft=function(){return this.throwIfDisposed(),Um(this)};pe().prototype.round=function(){return this.throwIfDisposed(),Fx(this)};pe().prototype.rsqrt=function(){return this.throwIfDisposed(),Lx(this)};pe().prototype.selu=function(){return this.throwIfDisposed(),Mx(this)};pe().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),zx(this,n,e,t,s,r,i)};pe().prototype.sigmoid=function(){return this.throwIfDisposed(),di(this)};pe().prototype.sign=function(){return this.throwIfDisposed(),pN(this)};pe().prototype.sin=function(){return this.throwIfDisposed(),Px(this)};pe().prototype.sinh=function(){return this.throwIfDisposed(),Bx(this)};pe().prototype.slice=function(n,e){return this.throwIfDisposed(),ut(this,n,e)};pe().prototype.softmax=function(n){return this.throwIfDisposed(),Bm(this,n)};pe().prototype.softplus=function(){return this.throwIfDisposed(),pu(this)};pe().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),Lm(this,n,e)};pe().prototype.split=function(n,e){return this.throwIfDisposed(),Is(this,n,e)};pe().prototype.sqrt=function(){return this.throwIfDisposed(),Pn(this)};pe().prototype.square=function(){return this.throwIfDisposed(),$t(this)};pe().prototype.squaredDifference=function(n){return this.throwIfDisposed(),jx(this,n)};pe().prototype.squeeze=function(n){return this.throwIfDisposed(),Go(this,n)};pe().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof mt?[this,n]:[this,...n];return bs(t,e)};pe().prototype.step=function(n){return this.throwIfDisposed(),mu(this,n)};pe().prototype.stridedSlice=function(n,e,t,s,r,i,a,o){return this.throwIfDisposed(),mN(this,n,e,t,s,r,i,a,o)};pe().prototype.sub=function(n){return this.throwIfDisposed(),_e(this,n)};pe().prototype.sum=function(n,e){return this.throwIfDisposed(),Ae(this,n,e)};pe().prototype.tan=function(){return this.throwIfDisposed(),gN(this)};pe().prototype.tanh=function(){return this.throwIfDisposed(),Ao(this)};pe().prototype.tile=function(n){return this.throwIfDisposed(),br(this,n)};pe().prototype.toBool=function(){return this.throwIfDisposed(),Ne(this,"bool")};pe().prototype.toFloat=function(){return this.throwIfDisposed(),Ne(this,"float32")};pe().prototype.toInt=function(){return this.throwIfDisposed(),Ne(this,"int32")};pe().prototype.topk=function(n,e){return this.throwIfDisposed(),xN(this,n,e)};pe().prototype.transpose=function(n){return this.throwIfDisposed(),at(this,n)};pe().prototype.unique=function(n){return this.throwIfDisposed(),wN(this,n)};pe().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Hx(this,n,e)};pe().prototype.unstack=function(n){return this.throwIfDisposed(),Cr(this,n)};pe().prototype.where=function(n,e){return this.throwIfDisposed(),Mn(n,this,e)};pe().prototype.zerosLike=function(){return this.throwIfDisposed(),ct(this)};class Ii extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ii.prototype)}}class jr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jr.prototype)}}class J extends Error{constructor(e){super(e),Object.setPrototypeOf(this,J.prototype)}}class Ze extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ze.prototype)}}class lk extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lk.prototype)}}class PP{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function tu(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function _i(n,e){if(!n)throw new lk(e)}function PO(n,e){let t=0;for(const s of n)s===e&&t++;return t}function ks(n){return n.length===1?n[0]:n}function Ct(n){return Array.isArray(n)?n:[n]}function ma(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function El(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Mr={};function uk(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function WT(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>WT(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:WT(s))}}}function Hm(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let a;if(i in t)a=t[i];else if(i in Mr)a=Mr[i];else if(a=e[i],a==null)throw new J(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const i=n;if(i.className==null||i.config==null)throw new J(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const a=i.className;let o,u;if(a in t?[o,u]=t[a]:a in Mr?[o,u]=Mr.className:a in e&&([o,u]=e[a]),o==null)throw new J(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const h={};for(const y of Object.keys(Mr))h[y]=Mr[y];for(const y of Object.keys(t))h[y]=t[y];const d=i.config;d.customObjects=h;const p=Object.assign({},Mr);for(const y of Object.keys(t))Mr[y]=t[y];WT(i.config);const m=u(o,i.config,t,r);return Mr=Object.assign({},p),m}else{const h=Object.assign({},Mr);for(const p of Object.keys(t))Mr[p]=t[p];const d=new o(i.config);return Mr=Object.assign({},h),d}}}function qre(n,e){return n<e?-1:n>e?1:0}function Oy(n,e){return-1*qre(n,e)}function To(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function Kre(n){if(n==null)throw new J(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function yu(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new J(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function ck(n,e,t=0,s=1/0){return _i(t>=0),_i(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Ln(n,e){Array.isArray(n)?(D(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Ln(t,`element ${s+1} of ${e}`))):D(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${BP(n)}.`)}function BP(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>BP(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function Xre(n,e,t){let s=t!=null?t():Gn(),r;return(...a)=>{const o=t!=null?t():Gn();return o-s<e||(s=o,r=n(...a)),r}}function VP(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let Yre=0;function UP(){return Yre++}const Fy={};function lw(n=""){return n in Fy||(Fy[n]=0),Fy[n]+=1,n+Fy[n].toString()}const Jre=["channelsFirst","channelsLast"],Zre=["nearest","bilinear"],Qre=["valid","same","causal"],eie=["max","avg"],tie=["sum","mul","concat","ave"];const yc=new Map;function hn(n){yu(Jre,"DataFormat",n)}function nie(n){yu(Zre,"InterpolationFormat",n)}function Nr(n){yu(Qre,"PaddingMode",n)}function jP(n){yu(eie,"PoolMode",n)}const Lf=[],BO="/";function Ul(n,e){Lf.push(n);try{const t=e();return Lf.pop(),t}catch(t){throw Lf.pop(),t}}function sie(){return Lf.length===0?"":Lf.join(BO)+BO}function WP(n){if(!HP(n))throw new Error("Not a valid tensor name: '"+n+"'");return sie()+n}function GP(n){if(!HP(n))throw new Error("Not a valid tensor name: '"+n+"'");yc.has(n)||yc.set(n,0);const e=yc.get(n);if(yc.set(n,yc.get(n)+1),e>0){const t=`${n}_${e}`;return yc.set(t,1),t}else return n}const rie=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function HP(n){return!!n.match(rie)}function iie(n){return n===parseInt(n.toString(),10)}function Co(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Gc(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Do(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function mi(n,e){if(e<n)throw new J(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let DS;function $n(){return DS==null&&(DS=b2().epsilon()),DS}function gi(){return"channelsLast"}function Pi(n,e){return Ne(n,e)}function qm(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),X(n,t)}function aie(n,e){return se(()=>{if(n.shape.length!==2)throw new J(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=qm(n,1);return GT(t,[1,e,1])})}function oie(n){const e=[Co(n.shape)];return X(n,e)}function lie(n){if(n.rank<=1)throw new J(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Co(n.shape,1)];return X(n,e)}function jl(n,e,t){return se(()=>{switch(n.rank){case 1:return zm(n,e,t);case 2:return Vx(n,[e,0],[t,n.shape[1]]);case 3:return Pm(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return jc(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ut(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ut(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new J(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function OS(n,e,t){return se(()=>{switch(n.rank){case 1:return zm(n,e,t);case 2:return Vx(n,[0,e],[n.shape[0],t]);case 3:return Pm(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return jc(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new J(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ly(n,e,t,s){return se(()=>{switch(n.rank){case 1:return zm(n,e,t);case 2:switch(s){case 1:return jl(n,e,t);case 2:return OS(n,e,t);default:throw new J(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return jl(n,e,t);case 2:return Pm(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return OS(n,e,t);default:throw new J(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return jl(n,e,t);case 2:return jc(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return jc(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return OS(n,e,t);default:throw new J(`The axis is not within the rank of the tensor ${s}`)}default:throw new J(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function hk(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),ln(n,e)}function VO(n,e){switch(n.rank){case 1:return P2([n,e]);case 2:return B2([n,e],0);case 3:return V2([n,e],0);case 4:return U2([n,e],0);default:throw new J(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function GT(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new J(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return br(n,e)}function uw(n,e=0,t=1,s,r){return Dx(n,e,t,s,r)}function Bi(n,e,t,s){if(n.rank<2||e.rank<2)throw new Ze(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new Ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return PT({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?HT(n.rank,s,gi()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=X(n,[-1,i]);const a=e.shape.slice(),o=a.pop(),u=a.pop(),h=[...a,o],d=Array.from({length:e.rank},(b,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=X(at(e,d),[u,-1]);const p=[...r,...h];return X(PT({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?HT(n.rank,s,gi()):null,activation:t}),p)}}function qP(n,e,t){return se(()=>(Array.isArray(e)?e=Xn(e,"int32"):e=Ne(e,"int32"),ed(n,e,t)))}function Km(n){return K(n,n)}function HT(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new J(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?X(e,[1,s[0],1,1,1]):X(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?X(e,[1,1,1,1,s[0]]):X(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?X(e,[1,s[0],1,1]):X(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?X(e,[1,1,1,s[0]]):X(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?X(e,[1,s[0],1]):X(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?X(e,[1,1,s[0]]):X(e,[1].concat(s))}else if(n<3)return e;throw new J(`Unsupported input rank by biasAdd: ${e.rank}`)}function vi(n,e,t){return se(()=>(t==null&&(t=gi()),hn(t),we(n,HT(n.rank,e,t))))}function uie(n,e=1){if(e!==1)throw new Ze(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Jh(n)}function cie(n){return se(()=>Oe(n,we(mn(n),1)))}function KP(n,e,t,s){return se(()=>TN(n,e,t,s))}function hie(n){return se(()=>{const e=we(.5,K(.2,n));return Rs(e,0,1)})}function Xm(n,e,t=!1){return t?n():e()}const die=["fanIn","fanOut","fanAvg"],fie=["normal","uniform","truncatedNormal"];function pie(n){yu(die,"FanMode",n)}function mie(n){yu(fie,"Distribution",n)}class qr extends gu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class dk extends qr{apply(e,t){return gn(e,t)}}dk.className="Zeros";ve(dk);class cw extends qr{apply(e,t){return $s(e,t)}}cw.className="Ones";ve(cw);class fk extends qr{constructor(e){if(super(),typeof e!="object")throw new J(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new J(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return se(()=>K(Me(this.value),$s(e,t)))}getConfig(){return{value:this.value}}}fk.className="Constant";ve(fk);class pk extends qr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Wo(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}pk.className="RandomUniform";ve(pk);class mk extends qr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`randomNormal does not support dType ${t}.`);return uw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}mk.className="RandomNormal";ve(mk);class gk extends qr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`truncatedNormal does not support dType ${t}.`);return Gx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}gk.className="TruncatedNormal";ve(gk);class yk extends qr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return se(()=>{if(e.length!==2||e[0]!==e[1])throw new J("Identity matrix initializer can only be used for 2D square matrices.");return K(this.gain,$x(e[0]))})}getConfig(){return{gain:this.gain}}}yk.className="Identity";ve(yk);function gie(n,e="channelsLast"){let t,s;if(hn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=Co(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=Co(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Co(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Os extends qr{constructor(e){if(super(),e.scale<0)throw new J(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,pie(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,mie(this.distribution),this.seed=e.seed}apply(e,t){const s=gie(e),r=s[0],i=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`${this.getClassName()} does not support dType ${t}.`);return Gx(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Wo(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Os.className="VarianceScaling";ve(Os);class hw extends Os{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}hw.className="GlorotUniform";ve(hw);class dw extends Os{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}dw.className="GlorotNormal";ve(dw);class fw extends Os{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}fw.className="HeNormal";ve(fw);class pw extends Os{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}pw.className="HeUniform";ve(pw);class mw extends Os{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}mw.className="LeCunNormal";ve(mw);class gw extends Os{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}gw.className="LeCunUniform";ve(gw);class bk extends qr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return se(()=>{if(e.length<2)throw new Ze("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=he(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const a=[Math.max(r,s),Math.min(r,s)],o=uw(a,0,1,t,this.seed),u=EN.qr(o,!1);let h=u[0];const p=u[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return h=K(h,p.sign()),s<r&&(h=h.transpose()),K(Me(this.gain),h.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}bk.className="Orthogonal";ve(bk);const UO={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function jO(n,e={}){return Hm(n,yr.getMap().classNameMap,e,"initializer")}function Yt(n){return uk(n)}function Wt(n){if(typeof n=="string"){const e=n in UO?UO[n]:n;if(e==="GlorotNormal")return new dw;if(e==="GlorotUniform")return new hw;if(e==="HeNormal")return new fw;if(e==="HeUniform")return new pw;if(e==="LeCunNormal")return new mw;if(e==="LeCunUniform")return new gw;{const t={};return t.className=e,t.config={},jO(t)}}else return n instanceof qr?n:jO(n)}function qT(n){return Array.isArray(n)&&Array.isArray(n[0])}function O0(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function He(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new J(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function yt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new J(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function F0(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const WO="Variable";class XP{constructor(e,t="float32",s=WO,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=UP(),s=s??WO,this.originalName=WP(s),this.name=GP(this.originalName),this.trainable_=r,this.constraint=i,this.val=vN(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),yie(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function yie(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function KT(n){return n.map(e=>e.read())}function xk(n){n.forEach(e=>{e[0].write(e[1])})}class yn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class yi{constructor(e,t,s,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=UP(),a!=null&&(this.originalName=WP(a),this.name=GP(this.originalName)),this.rank=t.length}}let bie=0;class yw{constructor(e,t){this.callArgs=t,this.id=bie++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xie=0;class rt extends gu{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=ma(s)+"_"+lw(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new jr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new J(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ks(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ks(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ii(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ii(`Layer ${this.name} is not connected, no input to return.`);return ks(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ii(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ii(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ks(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ct(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Ct(this.inputSpec);if(t.length!==s.length)throw new J(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],a=s[r];if(a==null)continue;const o=i.rank;if(a.ndim!=null&&o!==a.ndim)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&i.dtype!==a.dtype)throw new J(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${i.dtype}.`);if(a.axes){const u=i.shape;for(const h in a.axes){const d=Number(h),p=a.axes[h],m=d>=0?u[d]:u[u.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${u}.`)}}if(a.shape!=null)for(let u=0;u<a.shape.length;++u){const h=a.shape[u],d=i.shape[u];if(h!=null&&d!=null&&h!==d)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Ct(e),r=Sie(e),i=Tie(e);if(r===i)throw new J("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ul(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of Ct(e))a.push(o.shape);this.build(ks(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const o=Ct(a),u=[];for(let h of o)s.indexOf(h)!==-1&&(h=h.clone()),u.push(h);if(a=ks(u),this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=wie(e),o=this.computeOutputShape(a);let u;const h=vie(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?u=o.map((d,p)=>new yi(h,d,this,Ct(e),t,this.name,p)):u=new yi(h,o,this,Ct(e),t,this.name),this.addInboundNode(e,u,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ii(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ii(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new jr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return F0(this.weights)}build(e){this.built=!0}getWeights(e=!1){return KT(e?this.trainableWeights:this.weights)}setWeights(e){se(()=>{const t=this.weights;if(t.length!==e.length)throw new J(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=KT(t);for(let i=0;i<r.length;++i){const a=r[i],o=t[i],u=e[i];if(!it(a.shape,u.shape))throw new J(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);s.push([o,u])}xk(s)})}addWeight(e,t,s,r,i,a,o,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new J(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():Wt("zeros"));const h=r.apply(t,s),d=new XP(h,s,e,a,o);return h.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),a==null&&(a=!0),a?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ct(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=Ct(t),a=Ct(r);if(i.length!==a.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let o=0;o<i.length;o++)i[o].kerasMask=a[o]}addInboundNode(e,t,s,r,i,a,o=null){const u=Ct(e);t=Ct(t),s=Ct(s),r=Ct(r),i=O0(i),a=O0(a);const h=[],d=[],p=[];for(const m of u)h.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new yw({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:p,inputTensors:u,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:a},o);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function wie(n){n=Ct(n);const e=[];for(const t of n)e.push(t.shape);return ks(e)}function vie(n){return"float32"}function YP(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const a=s.inputTensors[i],o=s.inboundLayers[i],u=s.nodeIndices[i],h=YP(a,o,u);for(const d of h)r.indexOf(d)===-1&&r.push(d)}return r}}}function Sie(n){let e=!0;for(const t of Ct(n))if(!(t instanceof yi)){e=!1;break}return e}function Tie(n){let e=!0;for(const t of Ct(n))if(t instanceof yi){e=!1;break}return e}class sd extends rt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:lw("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new J("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new J("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new J("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new yi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new yw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new J(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}sd.className="InputLayer";ve(sd);function JP(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new J("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new sd({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function Cie(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ne(e,n.dtype)}catch{throw new J(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class bo{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof bo)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Cie(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new J(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof yi){if(this.id2Value[e.id]==null)throw new J(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new J(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof yi){if(this.id2Value[e.id]==null)throw new J(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new J(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Ke(this.id2Mask)}}const L0=new PP,M0=new PP;function Nie(n){L0?.setMaxEntries(n),M0?.setMaxEntries(n)}function Tf(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),a=i?n:[n],o=a.map(b=>b.name),u=[],h=e.names();for(const b of o)h.indexOf(b)!==-1?u.push(e.getValue(b)):u.push(null);const d=o.join(",")+"|"+e.names().sort().join(",");let p=L0.get(d),m;if(p==null){const b=kie(a,e);p=b.sorted,m=b.recipientCounts,L0.put(d,p),M0.put(d,m)}m={},r||Object.assign(m,M0.get(d));const y=new bo(e);for(let b=0;b<p.length;++b){const x=p[b],w=x.sourceLayer;if(w instanceof sd)continue;const S=[],C=[],N=[];let k=!1;for(const F of x.inputs){const L=y.getValue(F),A=y.getMask(F);S.push(L),C.push(A),A!=null&&(k=!0),r||(m[F.name]--,m[F.name]===0&&!e.hasKey(F)&&o.indexOf(F.name)===-1&&!L.isDisposed&&F.sourceLayer.stateful!==!0&&N.push(L))}k&&(t=t||{},t.mask=C[0]);const E=Ct(w.apply(S,t));let _=null;w.supportsMasking&&(_=w.computeMask(S,C));const R=$ie(x),O=Array.isArray(R)?R:[R];for(let F=0;F<O.length;++F){y.hasKey(O[F])||y.add(O[F],E[F],Array.isArray(_)?_[0]:_);const L=o.indexOf(O[F].name);L!==-1&&(u[L]=E[F])}r||Ke(N)}return y.disposeMasks(),i?u:u[0]}function kie(n,e){D(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=GO(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:a,recipientMap:o}=GO(i,e);for(const u of a)r.has(u.name)||(t.push(u),r.add(u.name));for(const u in o)s[u]==null&&(s[u]=new Set),o[u].forEach(h=>s[u].add(h))}}return{sorted:t,recipientCounts:Eie(s)}}function Eie(n){const e={};for(const t in n)e[t]=n[t].size;return e}function GO(n,e){const t=new Set,s=[],r={};for(const o of e.names())t.add(o);const i=[],a=[];for(i.push(n);i.length>0;){const o=i[i.length-1];if(t.has(o.name)){i.pop();continue}const u=a[a.length-1]===i.length-1;if(o.inputs.length===0||u)i.pop(),s.push(o),t.add(o.name),u&&a.pop();else{a.push(i.length-1);for(const h of o.inputs)r[h.name]==null&&(r[h.name]=new Set),r[h.name].add(o.name),!t.has(h.name)&&i.push(h)}}return{sorted:s,recipientMap:r}}function $ie(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const Iie=ie();Iie.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Nie);function wk(n,e){return se(()=>Pn(Ae(K(n,n),e,!0)))}class Ym extends gu{getConfig(){return{}}}class vk extends Ym{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return se(()=>{const t=wk(e,this.axis),s=Rs(t,0,this.maxValue);return K(e,Oe(s,we($n(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}vk.className="MaxNorm";ve(vk);class Sk extends Ym{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return se(()=>Oe(e,we($n(),wk(e,this.axis))))}getConfig(){return{axis:this.axis}}}Sk.className="UnitNorm";ve(Sk);class Tk extends Ym{apply(e){return wi(e)}}Tk.className="NonNeg";ve(Tk);class Ck extends Ym{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return se(()=>{const t=wk(e,this.axis),s=we(K(this.rate,Rs(t,this.minValue,this.maxValue)),K(1-this.rate,t));return K(e,Oe(s,we($n(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Ck.className="MinMaxNorm";ve(Ck);const HO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function In(n){return uk(n)}function qO(n,e={}){return Hm(n,yr.getMap().classNameMap,e,"constraint")}function _n(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in HO?HO[n]:n,config:{}};return qO(t)}else return n instanceof Ym?n:qO(n)}function _ie(n){return new vk(n)}function Aie(n){return new Sk(n)}function Rie(){return new Tk}function Die(n){return new Ck(n)}const Oie=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:_ie,minMaxNorm:Die,nonNeg:Rie,unitNorm:Aie},Symbol.toStringTag,{value:"Module"}));function Fie(){return new dk}function Lie(){return new cw}function Mie(n){return new fk(n)}function zie(n){return new pk(n)}function Pie(n){return new mk(n)}function Bie(n){return new gk(n)}function Vie(n){return new yk(n)}function Uie(n){return new Os(n)}function jie(n){return new hw(n)}function Wie(n){return new dw(n)}function Gie(n){return new fw(n)}function Hie(n){return new pw(n)}function qie(n){return new mw(n)}function Kie(n){return new gw(n)}function Xie(n){return new bk(n)}const Yie=Object.freeze(Object.defineProperty({__proto__:null,constant:Mie,glorotNormal:Wie,glorotUniform:jie,heNormal:Gie,heUniform:Hie,identity:Vie,leCunNormal:qie,leCunUniform:Kie,ones:Lie,orthogonal:Xie,randomNormal:Pie,randomUniform:zie,truncatedNormal:Bie,varianceScaling:Uie,zeros:Fie},Symbol.toStringTag,{value:"Module"}));async function fo(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const a=i;e.push(a.data()),t.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];Ke(s)}}function ZP(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var KO;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(KO||(KO={}));const Jie=125;class Hc{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class QP{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Zie extends Hc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const o=se(()=>we(this.totals[r],K(i,s)));this.totals[r]=o,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:se(()=>{const r=K(Oe(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),En(t[s])}))}}class eB extends Hc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const a=this.history[i];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const u=a[o];e.push(u.data()),t.push(i),s.push(o)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class tB extends Hc{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||UN,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Jie),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");N0(this.yieldEvery)&&(this.maybeWait=Xre(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await fo(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await fo(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await fo(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await fo(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await fo(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):N0(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await fo(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await fo(e),await this.trainEnd(e))}}function nB(n,e){return n==null&&(n={}),n instanceof Hc?[n]:Array.isArray(n)&&n[0]instanceof Hc?n:Ct(n).map(s=>new tB(s,e))}class fr{constructor(){}static registerCallbackConstructor(e,t){D(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),fr.checkForDuplicate(t),fr.constructors[e]==null&&(fr.constructors[e]=[]),fr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in fr.constructors)fr.constructors[+t].forEach(r=>{if(r===e)throw new J("Duplicate callback constructor.")})}static clear(){fr.constructors={}}static createCallbacks(e){const t=[];for(const s in fr.constructors){const r=+s;e>=r&&t.push(...fr.constructors[r])}return t.map(s=>new s)}}fr.constructors={};function sB(n,e,t,s,r,i,a,o,u){const h=new eB,d=[new Zie,...fr.createCallbacks(e)];n!=null&&d.push(...n),d.push(h);const p=new QP(d);return p.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:u}),{callbackList:p,history:h}}function fi(n,e={},t=!1){return Hm(n,yr.getMap().classNameMap,e,"layer",t)}function z0(n,e){return se(()=>{n.dtype!=="float32"&&(n=Ne(n,"float32"));const t=Ae(Km(n),e,!0),s=fu(t.shape,$n()),r=Pn(qi(t,s));return Oe(n,r)})}function bu(n,e){return se(()=>Kt(Km(_e(e,n)),-1))}function bw(n,e){return se(()=>Kt(mn(_e(e,n)),-1))}function rd(n,e){return se(()=>{const t=_e(n,e),s=Rs(mn(n),$n(),Number.MAX_VALUE),r=mn(Oe(t,s));return K(100,Kt(r,-1))})}function Qie(n,e){return se(()=>{const t=Rs(e,$n(),Number.MAX_VALUE),s=Zs(we(1,t)),r=Rs(n,$n(),Number.MAX_VALUE),i=Zs(we(1,r));return Kt(Km(_e(s,i)),-1)})}function eae(n,e){return se(()=>{const t=qi(0,_e(1,K(n,e)));return Kt(Km(t),-1)})}function tae(n,e){return se(()=>{const t=qi(0,_e(1,K(n,e)));return Kt(t,-1)})}function nae(n,e){return se(()=>{const t=Ae(K(n,e),-1),s=Sr(K(_e(1,n),e),-1);return qi(0,we(1,_e(s,t)))})}function sae(n,e){return se(()=>{const t=Math.log(2),s=_e(e,n),r=_e(we(s,pu(K(-2,s))),t);return Kt(r,-1)})}function ap(n,e,t=!1){return se(()=>{if(t)e=Bm(e);else{const s=Ae(e,e.shape.length-1,!0);e=Oe(e,s)}return e=Rs(e,$n(),1-$n()),Mt(Ae(K(Ne(n,"float32"),Zs(e)),e.shape.length-1))})}function P0(n,e,t=!1){return se(()=>{const s=Ne(Qh(oie(n)),"int32");e=Rs(e,$n(),1-$n());const r=e.shape,i=X(Vc(s,r[r.length-1]),r);return ap(i,e,t)})}function rae(n,e){if(!it(n.shape,e.shape))throw new J(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return se(()=>{const t=wi(e),s=Mt(mn(e));return we(_e(t,K(e,n)),Am(Ds(s)))})}function xw(n,e){return se(()=>{let t;return t=Rs(e,$n(),1-$n()),t=Zs(Oe(t,_e(1,t))),Kt(rae(n,t),-1)})}function iae(n,e){return se(()=>{const t=Rs(n,$n(),1),s=Rs(e,$n(),1);return Ae(K(n,Zs(Oe(t,s))),-1)})}function aae(n,e){return se(()=>{const t=Zs(we($n(),e));return Kt(_e(e,K(n,t)),-1)})}function Nk(n,e){return se(()=>{const t=z0(n,-1),s=z0(e,-1),r=K(t,s);return Mt(Ae(r,-1))})}const B0={meanSquaredError:bu,meanAbsoluteError:bw,meanAbsolutePercentageError:rd,meanSquaredLogarithmicError:Qie,squaredHinge:eae,hinge:tae,categoricalHinge:nae,logcosh:sae,categoricalCrossentropy:ap,sparseCategoricalCrossentropy:P0,binaryCrossentropy:xw,kullbackLeiblerDivergence:iae,poisson:aae,cosineProximity:Nk};function FS(n){if(typeof n=="string"){if(n in B0)return B0[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new J(e)}else return n}function kk(n,e){return se(()=>{const t=K(.5,Qs(e)),s=Pi(vs(e,t),n.dtype);return Kt(Js(n,s),-1)})}function Ek(n,e){return se(()=>Pi(Js(Xl(n,-1),Xl(e,-1)),"float32"))}function rB(n,e){return se(()=>Ne(Ae(Gr(Js(n,1),Js(e,1))),"float32"))}function oae(n,e){return se(()=>Ne(Ae(Gr(Js(n,1),Js(e,0))),"float32"))}function lae(n,e){return se(()=>Ne(Ae(Gr(Js(n,0),Js(e,1))),"float32"))}function iB(n,e){return se(()=>{const t=rB(n,e),s=lae(n,e),r=we(t,s);return Ne(Mn(vs(r,0),Oe(t,r),0),"float32")})}function uae(n,e){return se(()=>{const t=rB(n,e),s=oae(n,e),r=we(t,s);return Ne(Mn(vs(r,0),Oe(t,r),0),"float32")})}function aB(n,e){return xw(n,e)}function oB(n,e){return n.rank===e.rank&&(n=Go(n,[n.rank-1])),e=Xl(e,-1),e.dtype!==n.dtype&&(e=Ne(e,n.dtype)),Ne(Js(n,e),"float32")}function cae(n,e){return se(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return Me(1).sub(t.div(s))})}const hae=bu,dae=bu,fae=bw,pae=bw,mae=rd,gae=rd,$k=ap,yae=Nk,lB=P0,V0={binaryAccuracy:kk,categoricalAccuracy:Ek,precision:iB,categoricalCrossentropy:$k,sparseCategoricalCrossentropy:lB,mse:hae,MSE:dae,mae:fae,MAE:pae,mape:mae,MAPE:gae,cosine:yae};function bae(n){if(typeof n=="string"&&n in V0)return V0[n];if(typeof n!="string"&&n!=null)return n;throw new J(`Unknown metric ${n}`)}function My(n){if(_i(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(B0))if(B0[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(V0))if(V0[t]===n){e=t;break}return e!==void 0?e:n.name}}function xae(n){const e={Adagrad:()=>Sl.adagrad(.01),Adadelta:()=>Sl.adadelta(1,.95,$n()),Adam:()=>Sl.adam(.001,.9,.999,$n()),Adamax:()=>Sl.adamax(.002,.9,.999,$n(),0),RMSProp:()=>Sl.rmsprop(.001,.9,0,$n()),SGD:()=>Sl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new J(`Unknown Optimizer ${n}`)}const XO=1*1024*1024;function YO(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!XT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>XO&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${XO}.`)}}function XT(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!XT(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!XT(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function wae(n,e,t,s=console.log){const r=Sae(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let a;if(!r){i.push("Receives inputs"),a=[];for(const d in n.nodesByDepth)a.push(...n.nodesByDepth[d])}s("_".repeat(e)),U0(i,t,s),s("=".repeat(e));const o=n.layers;for(let d=0;d<o.length;++d)r?Tae(o[d],t,s):Cae(o[d],t,a,s),s((d===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const u=vae(n),h=F0(n.nonTrainableWeights);s(`Total params: ${u+h}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${h}`),s("_".repeat(e))}function vae(n){let e;return n.collectedTrainableWeights!=null?e=F0(n.collectedTrainableWeights):e=F0(n.trainableWeights),e}function Sae(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function U0(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function Tae(n,e,t){let s,r;try{r=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,a=n.getClassName(),o=[`${i} (${a})`,r,s,n.countParams().toString()];U0(o,e,t)}function Cae(n,e,t,s){let r,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=[];for(const p of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const y=p.inboundLayers[m].name,b=p.nodeIndices[m],x=p.tensorIndices[m];a.push(`${y}[${b}][${x}]`)}const o=n.name,u=n.getClassName(),h=a.length===0?"":a[0],d=[`${o} (${u})`,i,r,n.countParams().toString(),h];U0(d,e,s);for(let p=1;p<a.length;++p)U0(["","","","",a[p]],e,s)}function uB(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function op(n,e){if(n===null)return null;if(typeof n=="string")return El(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];uB(e,r,i)?t.push(i):t.push(op(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=El(s);t[i]=op(r,i)}}return t}}function YT(n,e){if(n==null)return null;if(typeof n=="string")return ma(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];uB(e,r,i)?t.push(i):t.push(YT(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=ma(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=YT(r,s)}return t}}const ww="4.22.0";const Nae=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class ii extends rt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const C=this.getClassName().toLowerCase();this.name=lw(C)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],To(this.inputs).length!==this.inputs.length)throw new J(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(C=>C.name)}`);To(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(C=>C.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const C of this.outputs){const N=C.sourceLayer,k=C.nodeIndex,E=C.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(E)}for(const C of this.inputs){const N=C.sourceLayer,k=C.nodeIndex,E=C.tensorIndex;_i(k===0,"input layer has >1 nodes"),_i(E===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let C=0;C<this.inputLayers.length;C++){const N=this.inputLayers[C];if(!(N instanceof sd))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${C} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(const C of this.outputLayers)this.outputNames.push(C.name);this.internalInputShapes=this.inputs.map(C=>C.shape),this.internalOutputShapes=this.outputs.map(C=>C.shape);const t={},s={},r={},i={},a={},o=[],u=(C,N,k,E,_,R)=>{(E==null||_==null||R==null)&&(E=C.sourceLayer,_=C.nodeIndex,R=C.tensorIndex);const O=E.inboundNodes[_];if(k.indexOf(O)!==-1)throw new jr(`The tensor ${C.name} at layer "${E.name}" is part of a cycle.`);if(N.indexOf(O)!==-1)return;this.containerNodes.add(ii.nodeKey(E,_)),E.id in a||(a[E.id]=Object.keys(a).length),k.indexOf(O)===-1&&k.push(O);const F=O.inboundLayers.length;for(let L=0;L<F;L++){const A=O.inputTensors[L],U=O.inboundLayers[L],Y=O.nodeIndices[L],te=O.tensorIndices[L];u(A,N,k,U,Y,te)}for(N.push(O);k.indexOf(O)>=0;)k.splice(k.indexOf(O),1);o.push(O)},h=[],d=[];for(const C of this.outputs)u(C,h,d);const p=o.slice().reverse();for(const C of p){s[C.id]=C,C.id in t||(t[C.id]=0);let N=t[C.id];const k=r[C.outboundLayer.id]==null?0:r[C.outboundLayer.id];N=Math.max(N,k),r[C.outboundLayer.id]=N,i[C.outboundLayer.id]=C.outboundLayer,t[C.id]=N;for(let E=0;E<C.inboundLayers.length;E++){const _=C.inboundLayers[E],R=C.nodeIndices[E],O=_.inboundNodes[R],F=t[O.id]==null?0:t[O.id];t[O.id]=Math.max(N+1,F),s[O.id]=O}}const m={};for(const C in t){const N=t[C];N in m||(m[N]=[]),m[N].push(s[C])}const y={};for(const C in r){const N=r[C];N in y||(y[N]=[]),y[N].push(i[C])}let b=Object.keys(y).map(C=>parseInt(C,10)).sort(Oy);this.layers=[];for(const C of b){const N=y[C];N.sort((k,E)=>{const _=a[k.id],R=a[E.id];return _<R?-1:_>R?1:0});for(const k of N)k instanceof ii&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=y,b=Object.keys(m).map(C=>parseInt(C,10)).sort(Oy);const x=this.inputs.slice(),w=[];for(const C of b)for(const N of m[C]){const k=N.outboundLayer;if(k!=null){for(const E of N.inputTensors)if(x.indexOf(E)===-1)throw new jr(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${k.name}". The following previous layers were accessed without issue: ${w}`);for(const E of N.outputTensors)x.push(E);w.push(k.name)}}this.nodesByDepth=m;const S=this.layers.map(C=>C.name);for(const C of S){const N=S.filter(k=>k===C).length;if(N!==1)throw new jr(`The name "${C}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new yw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(C=>null),outputMasks:this.outputs.map(C=>null),inputShapes:this.inputs.map(C=>C.shape),outputShapes:this.outputs.map(C=>C.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new J("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=Nae(e);i&&this.parseWeights(e);for(const o of this.layers)for(const[u,h]of o.weights.entries()){const d=i?`${h.name.split("/").slice(0,-1).join("/")+"/"}${u}`:h.originalName;if(s[d]!=null)throw new J(`Duplicate weight name: ${d}`);s[d]=h,r++}const a=[];for(const o in e){let u=o;if(s[o]==null){const h=o.split("/");u=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[u]!=null)a.push([s[u],e[o]]);else if(t)throw new J(`Provided weight data has no target variable: ${o}`);delete s[u]}if(t){const o=[];for(const u in s)o.push(u);if(o.length>0)throw new J(`${o.length} of ${r} weights are not set: ${o}`)}xk(a)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!r.includes(a)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${ww}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=YT(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return se(()=>{e=Ct(e);const s=new bo;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Tf(this.outputs,s,t)})}computeMask(e,t){return se(()=>{e=Ct(e);let s;return t==null?s=tu(null,e.length):s=Ct(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=O0(e);if(t.length!==this.inputLayers.length)throw new J(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const u=this.inputLayers[o],h=t[o],d=u.name+"_0_0";s[d]=h}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Oy);if(r.length>1)for(const o of r){const u=this.nodesByDepth[o];for(const h of u){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const p=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],S=h.nodeIndices[x],C=h.tensorIndices[x],N=`${w.name}_${S}_${C}`,k=s[N];p.push(k)}const m=d.computeOutputShape(ks(p)),y=O0(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const i=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const u=this.outputLayers[o],h=this.outputLayersNodeIndices[o],d=this.outputLayersTensorIndices[o],p=`${u.name}_${h}_${d}`;a.push(p)}for(let o=0;o<a.length;o++){const u=a[o];_i(u in s),i.push(s[u])}return ks(i)}runInternalGraph(e,t){t==null&&(t=tu(null,e.length));const s={};for(let u=0;u<this.inputs.length;++u){const h=this.inputs[u],d=e[u],p=t[u];s[h.id]=[d,p]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Oy);for(const u of r){const h=this.nodesByDepth[u];for(const d of h){const p=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,S,C,N;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[k,E]=b[0];x.mask==null&&(x.mask=E),C=Ct(p.call(k,x)),N=Ct(p.computeMask(k,E)),w=[k],S=[E]}else w=b.map(k=>k[0]),S=b.map(k=>k[1]),x.mask==null&&(x.mask=S),C=Ct(p.call(w,x)),N=Ct(p.computeMask(w,S));if(p.activityRegularizer)throw new Ze("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<y.length;++k){const E=y[k],_=C[k],R=N[k];s[E.id]=[_,R]}}}}const i=[],a=[],o=[];for(const u of this.outputs){_i(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[h,d]=s[u.id];o.push(h.shape),i.push(h),a.push(d)}return[i,a,o]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof ii?1:0;for(let i=0;i<r.inboundNodes.length;i++){const a=ii.nodeKey(r,i);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new J("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new J(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new J(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return se(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=ii.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const o=a.getClassName(),u=a.getConfig(),h=[];for(let p=0;p<a.inboundNodes.length;p++){const m=a.inboundNodes[p],y=ii.nodeKey(a,p);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const S=m.inboundLayers[w],C=m.nodeIndices[w],N=m.tensorIndices[w],k=ii.nodeKey(S,C);let E=t[k];E==null&&(E=0),x.push([S.name,E,N,b])}h.push(x)}}}const d={};d.name=a.name,d.className=o,d.config=u,d.inboundNodes=h,s.push(d)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],u=this.inputLayersNodeIndices[a],h=ii.nodeKey(o,u);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const p=this.inputLayersTensorIndices[a];r.push([o.name,d,p])}e.inputLayers=r;const i=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],u=this.outputLayersNodeIndices[a],h=ii.nodeKey(o,u);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const p=this.outputLayersTensorIndices[a];i.push([o.name,d,p])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},a={};function o(w,S){w.name in a?a[w.name].push(S):a[w.name]=[S]}function u(w,S){const C=[];let N;for(const k of S){const E=k[0],_=k[1],R=k[2];if(N=k[3]==null?{}:k[3],!(E in i)){o(w,S);return}const O=i[E];if(O.inboundNodes.length<=_){o(w,S);return}const F=O.inboundNodes[_];C.push(F.outputTensors[R])}C.length>0&&w.apply(ks(C),N)}function h(w){const S=w.name,C=fi(w,t.customObjects!=null?t.customObjects:{});C.setFastWeightInitDuringBuild(r),i[S]=C,w.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new J(`Corrupted configuration, expected array for nodeData: ${k}`);o(C,k)})}const d=t.name,p=t.layers;for(const w of p)h(w);for(;!Kre(a);)for(const w of p){const S=i[w.name];if(S.name in a){const C=a[S.name];delete a[S.name];for(const N of C)u(S,N)}}const m=[],y=[],b=t.inputLayers;for(const w of b){const S=w[0],C=w[1],N=w[2];_i(S in i);const E=i[S].inboundNodes[C].outputTensors;m.push(E[N])}const x=t.outputLayers;for(const w of x){const S=w[0],C=w[1],N=w[2];_i(S in i);const E=i[S].inboundNodes[C].outputTensors;y.push(E[N])}return new e({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new J("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){se(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function kae(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function cB(n,e){return kae(n,e,"classWeight")}async function hB(n,e,t,s){if(t!=null){const r=se(()=>{if(n.shape.length===1)return Mi(n);if(n.shape.length===2){if(n.shape[1]>1)return Xl(n,1);if(n.shape[1]===1)return X(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Ke(r);const a=[];return i.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),Xn(a,"float32")}else return null}function Eae(n,e){return K(n,e)}const $ae=32;function dB(n,e){let t,s;const r=e;t=r.xs,s=r.ys,D(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=JO("input",n.inputNames,t),a=JO("output",n.outputNames,s),o=i[0].shape[0];D(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),D(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<i.length;u++)D(i[u].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let u=0;u<a.length;u++)D(a[u].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:i,ys:a}}function JO(n,e,t){if(t instanceof mt)return[t];if(Array.isArray(t))return D(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new J(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function Iae(n){if(n.length===3)throw new Ze("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function _ae(n,e,t){const s=t.batchesPerEpoch!=null;if(D(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),D(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),D(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),D(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),D(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,a;if(r)if(ZO(t.validationData))D(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const w=Iae(t.validationData);i=w.xs,a=w.ys}const o=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let h;r?h=u.slice().concat(u.map(w=>"val_"+w)):h=u.slice();const d=nB(t.callbacks,t.yieldEvery),p=t.verbose==null?1:t.verbose,{callbackList:m,history:y}=sB(d,p,t.epochs,null,null,Aae(e,t),null,r,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=t.initialEpoch==null?0:t.initialEpoch,x=await e.iterator();for(;b<t.epochs;){const w={};await m.onEpochBegin(b);let S=0,C=0;for(s||(x=await e.iterator());!s||S<t.batchesPerEpoch;){const N=await x.next();if(s&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){const{xs:k,ys:E}=dB(n,N.value),_={};_.batch=C,_.size=k[0].shape[0],await m.onBatchBegin(C,_);const R=[];if(t.classWeight!=null){const L=cB(t.classWeight,n.outputNames);for(let A=0;A<L.length;++A)R.push(await hB(E[A],null,L[A]))}const O=k.concat(E).concat(R),F=o(O);Ke(O);for(let L=0;L<u.length;++L){const A=u[L],U=F[L];_[A]=U,En(U)}await m.onBatchEnd(C,_),ZP(_),C++,S++}if(s?S>=t.batchesPerEpoch:N.done){if(r){let k;ZO(t.validationData)?k=Ct(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):k=Ct(n.evaluate(i,a,{batchSize:t.validationBatchSize==null?$ae:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=k[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Aae(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function ZO(n){return typeof n.iterator=="function"}function Rae(n){return typeof n.next=="function"}async function Dae(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new Ze("Verbose mode is not implemented yet.");D(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=Rae(e)?e:await e.iterator();let o=0,u=0;for(;!s||u<t.batches;){const h=await a.next();if(i=se(()=>{if(h.value){const{xs:d,ys:p}=dB(n,h.value),m=d.concat(p),y=se(()=>r(m));if(Ke(m),u===0)for(let x=0;x<y.length;++x)i.push(Me(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],S=i[x];i[x]=se(()=>we(i[x],K(b,w))),u>0&&Ke(S)}Ke(y),o+=b,++u}return i}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<i.length;++h){const d=i[h];i[h]=Oe(i[h],o),Ke(d)}return ks(i)}function LS(n){D(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function mf(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>jl(s,e,t-e)):jl(n,e,t-e)}function JT(n,e){return se(()=>n==null?null:Array.isArray(n)?n.map(t=>JT(t,e)):qP(n,e.dtype==="int32"?e:Ne(e,"int32")))}function MS(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function fB(n){const e=[];n instanceof mt&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(qm(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function ni(n,e){if(n==null)return;const t=[];if(e instanceof mt)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof mt)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function Oae(n){return n instanceof mt}function ZT(n){return Array.isArray(n)}function QO(n){return!Oae(n)&&!ZT(n)}function e3(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(ZT(n)&&n.length>0)a=!0;else if(QO(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new J(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let i;if(QO(n)){n=n,i=[];for(const a of e){if(n[a]==null)throw new J(`No data provided for "${a}". Need data for each key in: ${e}`);i.push(n[a])}}else if(ZT(n)){if(n=n,n.length!==e.length)throw new J(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new J(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=fB(i),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new J(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<t[a].length;++u){if(u===0&&!s)continue;const h=o.shape[u],d=t[a][u];if(d!=null&&d>=0&&h!==d)throw new J(`${r} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return i}function Fae(n,e,t){const s=To(n.map(i=>i.shape[0]));s.sort();const r=To(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new J(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new J(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!it(s,r))throw new J(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function Lae(n,e,t){const s=[bu,xw,ap];for(let r=0;r<n.length;++r){const i=n[r],a=e[r],o=t[r];if(a!=null){if(a===ap&&i.shape[i.shape.length-1]===1)throw new J(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const u=i.shape.slice(1),h=o.slice(1);for(let d=0;d<u.length;++d){const p=u[d],m=h[d];if(m!=null&&p!==m)throw new J(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function t3(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new J(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new J(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new J(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<t[a].length;++u){if(u===0&&!s)continue;const h=o.shape[u],d=t[a][u];if(d!=null&&d!==h)throw new J(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function Mae(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const zae="layers-model";class wa extends ii{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new J("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");wae(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=xae(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Pa))throw new J("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new J(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(FS(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new J(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>FS(o))}else{const a=FS(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ul("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=Mae(e.metrics,this.outputNames),i=(a,o,u)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([u,a])};Ul("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=r[a];(h=>{let p,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[a];w[w.length-1]===1||this.lossFunctions[a]===xw?["accuracy","acc"].indexOf(b)!==-1?m=kk:["crossentropy","ce"].indexOf(b)!==-1&&(m=aB):this.lossFunctions[a]===P0?["accuracy","acc"].indexOf(b)!==-1?m=oB:["crossentropy","ce"].indexOf(b)!==-1&&(m=lB):["accuracy","acc"].indexOf(b)!==-1?m=Ek:["crossentropy","ce"].indexOf(b)!==-1&&(m=$k);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,p=""+S}else y=bae(b),p=""+My(b);let x;Ul(p,()=>{x=y}),i(a,p,x)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;LS(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const o=a[0].concat(a[1]);this.makeTestFunction();const u=this.testFunction,h=this.testLoop(u,o,r,s.verbose,s.steps);return ks(h)}finally{ni(a[0],e),ni(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Dae(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new J(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new J(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new J("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),a=new bo;if(e instanceof mt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new J(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(const u of this.inputs){const h=e[u.name];if(h==null)throw new J(`No value is provided for the model's input ${u.name}`);a.add(u,h)}const o=Tf(i,a);return s?o:o[0]}retrieveSymbolicTensors(e){const t=tu(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],a=i.map(o=>o.name);for(let o=0;o<e.length;++o){const u=a.indexOf(e[o]);if(u!==-1&&(t[o]=i[u],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,a)=>{i==null&&r.push(e[a])}),new J(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return se(()=>{const r=this.checkNumSamples(e);if(s)throw new Ze("Verbose predictLoop() is not implemented yet.");const i=MS(r,t),a=this.outputs.map(o=>[]);for(let o=0;o<i.length;++o)se(()=>{const h=i[o][0],d=i[o][1],p=mf(e,h,d),m=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)m.push({key:this.inputs[b],value:p[b]});else m.push({key:this.inputs[0],value:p});const y=new bo(m);return Tf(this.outputs,y)}).forEach((h,d)=>a[d].push(h));return ks(a.map(o=>ln(o,0)))})}predict(e,t={}){const s=fB(e);t3(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return LS(r),this.predictLoop(s,r)}finally{ni(s,e)}}predictOnBatch(e){t3(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new jr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===P0?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(e=e3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=e3(t,this.feedOutputNames,i,!1,"target"),Fae(e,t),Lae(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new J(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,a){const[o,u]=this.standardizeUserDataXY(e,t,i,a);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(r!=null){const d=cB(r,this.outputNames);h=[];for(let p=0;p<d.length;++p)h.push(await hB(u[p],null,d[p]))}return[o,u,h]}testLoop(e,t,s,r=0,i){return se(()=>{const a=this.checkNumSamples(t,s,i,"steps"),o=[];if(r>0)throw new Ze("Verbose mode is not implemented yet.");if(i!=null)throw new Ze("steps mode in testLoop() is not implemented yet");{const u=MS(a,s),h=Xn(mi(0,a));for(let d=0;d<u.length;++d){const p=u[d][0],m=u[d][1],y=jl(h,p,m-p),b=JT(t,y),x=e(b);if(d===0)for(let w=0;w<x.length;++w)o.push(Me(0));for(let w=0;w<x.length;++w){const S=x[w];o[w]=we(o[w],K(m-p,S))}}for(let d=0;d<o.length;++d)o[d]=Oe(o[d],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(PO(e,r)>1){const a=PO(e.slice(0,s),r);i+=`_${a}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const m=new bo(p),y=Tf(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let S=w(r[x],y[x]);i[x]!=null&&(S=Eae(S,i[x]));const C=Kt(S);t.push(C),x===0?b=S:b=we(b,S)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=t[x];else{const S=this.metricsTensors[x][0],C=this.metricsTensors[x][1];w=Kt(S(r[C],y[C]))}En(w),a.push(w)}return b=Kt(b),this.calculateLosses().forEach(x=>{b=we(b,x)}),b},u=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(o,!0,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>se(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let h=0;h<this.inputs.length;++h)a.push({key:this.inputs[h],value:r[h]});const o=new bo(a),u=Tf(this.outputs,o);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],p=Kt(d(i[h],u[h]));h===0?s=p:s=we(s,p),t.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],p=this.metricsTensors[h][1],m=Kt(d(i[p],u[p]));t.push(m)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,a,o,u,h,d,p,m;try{const y=s.batchSize==null?32:s.batchSize;LS(y);const x=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,y);r=x[0],i=x[1],m=x[2];let w=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)u=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Ze("validationData including sample weights is not supported yet."):new J(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const L=await this.standardizeUserData(u,h,null,null,!0,y);d=L[0],p=L[1],S=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const F=Math.floor(r[0].shape[0]*(1-s.validationSplit)),L=r[0].shape[0];d=mf(r,F,L),a=r,r=mf(r,0,F),p=mf(i,F,L),o=i,i=mf(i,0,F),S=d.concat(p)}else s.validationSteps!=null&&(w=!0);const C=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const N=this.makeTrainFunction(),k=this.getDedupedMetricsNames();let E,_;w?(this.makeTestFunction(),E=this.testFunction,_=k.slice().concat(k.map(F=>"val_"+F))):(E=null,S=[],_=k.slice());const R=nB(s.callbacks,s.yieldEvery);return await this.fitLoop(N,C,k,y,s.epochs,s.verbose,R,E,S,s.shuffle,_,s.initialEpoch,null,null)}finally{this.isTraining=!1,ni(r,e),ni(i,t),ni(a,e),ni(o,t),ni(d,u),ni(p,h),m!=null&&Ke(m)}}async fitLoop(e,t,s,r,i,a,o,u,h,d,p,m,y,b){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(u!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new J("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(t,r,y,"steps_per_epoch");let S;w!=null&&(S=mi(0,w)),a==null&&(a=1);const{callbackList:C,history:N}=sB(o,a,i,m,w,y,r,x,p);C.setModel(this),this.history=N,await C.onTrainBegin(),this.stopTraining_=!1;for(let k=m;k<i;++k){await C.onEpochBegin(k);const E={};if(y!=null)throw new Ze("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Ze("batch shuffling is not implemneted yet");d&&o2(S);const _=Xn(S),R=MS(w,r);for(let O=0;O<R.length;++O){const F={};if(await C.onBatchBegin(O,F),se(()=>{const L=R[O][0],A=R[O][1],U=jl(_,L,A-L);F.batch=O,F.size=A-L;const Y=JT(t,U),te=e(Y);for(let Z=0;Z<s.length;++Z){const B=s[Z],V=te[Z];F[B]=V,En(V)}if(O===R.length-1&&x){const Z=this.testLoop(u,h,r);for(let B=0;B<s.length;++B){const V=s[B],j=Z[B];En(j),E["val_"+V]=j}}}),await C.onBatchEnd(O,F),ZP(F),this.stopTraining_)break}_.dispose()}if(await C.onEpochEnd(k,E),this.stopTraining_)break}return await C.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return _ae(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],o=this.makeTrainFunction()(r.concat(i)),u=[];for(const h of o){const d=await h.data();u.push(d[0])}return Ke(o),ni(s[0],e),ni(s[1],t),ks(u)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||t.push({name:r[a].originalName,tensor:i[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=RT().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-RT().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ma(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ma(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=ma(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ma(My(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ma(My(e)));{const e={};for(const t in this.metrics)e[t]=ma(My(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=op(e.optimizer_config),s=fi(t);let r;if(typeof e.loss=="string")r=El(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>El(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=El(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>El(a));else if(e.metrics!=null){i={};for(const a in e.metrics)i[a]=El(e.metrics[a])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const h=AM(e);if(h.length===0)throw new J(`Cannot find any save handlers for URL '${e}'`);if(h.length>1)throw new J(`Found more than one (${h.length}) save handlers for URL '${e}'`);e=h[0]}if(e.save==null)throw new J("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await DT(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:zae,generatedBy:`TensorFlow.js tfjs-layers v${ww}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:p}=await DT(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=IM([s.data,d])}return this.userDefinedMetadata!=null&&(YO(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){YO(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}wa.className="Model";ve(wa);class pB extends wa{}pB.className="Functional";ve(pB);async function Pae(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=op(t),r=fi(s,e);if(n.weightsManifest!=null){const i=await Hz(n.weightsManifest,n.pathPrefix,r.weights.map(o=>o.originalName)),a={};for(const o of r.weights)a[o.originalName]=i[o.originalName];r.loadWeights(a),Ke(i)}return r}async function mB(n,e){if(e==null&&(e={}),typeof n=="string"){const t=RM(n,e);if(t.length===0)t.push(Xz(n,e));else if(t.length>1)throw new J(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return Bae(n,void 0,e)}async function Bae(n,e,t){if(t==null&&(t={}),n.load==null)throw new J("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=t.strict==null?!0:t.strict,a=s.weightData!=null&&s.weightSpecs!=null&&i,o=fi(op(r),e,a),u=s.trainingConfig;if(u!=null&&o.loadTrainingConfig(u),s.userDefinedMetadata!=null&&o.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new J("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=Vae(s.weightData,s.weightSpecs);o.loadWeights(h,i),o.optimizer!=null&&d.length>0&&await o.optimizer.setWeights(d),Ke(h),Ke(d.map(p=>p.tensor))}return o}function Vae(n,e){const t=x2(n,e),s={},r=[];return e.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:t[i.name]}):s[i.name]=t[i.name]}),{modelWeights:s,optimizerWeights:r}}class nu extends wa{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:lw("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new J(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof nu||e instanceof wa;let s;if(t){if(s=e,s.outputs.length!==1)throw new J("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new J("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new J("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=JP({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new J(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new J("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=YP(this.outputs[0])}this.inboundNodes=[],new yw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:tu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(yt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new wa({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new jr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new jr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new jr("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new jr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new J("Legacy serialization format not supported yet.");i=t}else D(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof nu))throw new Ze(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const u of i){const d=fi(u,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(e){if(this.model==null)throw new J("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new J("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}nu.className="Sequential";ve(nu);function Uae(n){return new wa(n)}function jae(n){return new nu(n)}function gB(n){return JP(n)}function Wae(n,e){fr.registerCallbackConstructor(n,e)}let cs=class extends gu{getConfig(){return{}}};class yB extends cs{apply(e,t=1){return uie(e,t)}}yB.className="elu";ve(yB);class bB extends cs{apply(e){return Mx(e)}}bB.className="selu";ve(bB);class xB extends cs{apply(e){return wi(e)}}xB.className="relu";ve(xB);class wB extends cs{apply(e){return se(()=>Ro(6,wi(e)))}}wB.className="relu6";ve(wB);class vB extends cs{apply(e){return e}}vB.className="linear";ve(vB);class SB extends cs{apply(e){return di(e)}}SB.className="sigmoid";ve(SB);class TB extends cs{apply(e){return hie(e)}}TB.className="hardSigmoid";ve(TB);class CB extends cs{apply(e){return pu(e)}}CB.className="softplus";ve(CB);class NB extends cs{apply(e){return cie(e)}}NB.className="softsign";ve(NB);class kB extends cs{apply(e){return Ao(e)}}kB.className="tanh";ve(kB);let Ik=class extends cs{apply(e,t=-1){return Bm(e,t)}};Ik.className="softmax";ve(Ik);class EB extends cs{apply(e,t=-1){return _x(e,t)}}EB.className="logSoftmax";ve(EB);class $B extends cs{apply(e){return se(()=>se(()=>{const t=Math.sqrt(2),s=K(.5,we(1,Ex(Oe(e,t))));return K(e,s)}))}}$B.className="gelu";ve($B);class IB extends cs{apply(e){return se(()=>K(.5,K(e,we(1,Ao(K(Pn(Oe(2,Math.PI)),we(e,K(.044715,ji(e,3)))))))))}}IB.className="gelu_new";ve(IB);class _B extends cs{apply(e){return se(()=>K(e,Ao(pu(e))))}}_B.className="mish";ve(_B);class AB extends cs{apply(e,t=1){return se(()=>K(di(K(e,t)),e))}}AB.className="swish";ve(AB);function Oo(n){return n.getClassName()}function zS(n,e={}){return Hm(n,yr.getMap().classNameMap,e,"activation")}function Fo(n){if(n==null){const e={};return e.className="linear",e.config={},zS(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},zS(e)}else return n instanceof cs?n:zS(n)}function _k(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class RB extends gu{}class Jm extends RB{constructor(e){super(),_k(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return se(()=>{let t=gn([1]);return this.hasL1&&(t=we(t,Ae(K(this.l1,mn(e))))),this.hasL2&&(t=we(t,Ae(K(this.l2,Km(e))))),X(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Jm.className="L1L2";ve(Jm);function Gae(n){return _k(n),new Jm({l1:n!=null?n.l1:null,l2:0})}function Hae(n){return _k(n),new Jm({l2:n!=null?n.l2:null,l1:0})}const n3={l1l2:"L1L2"};function Ot(n){return uk(n)}function s3(n,e={}){return Hm(n,yr.getMap().classNameMap,e,"regularizer")}function Gt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in n3?n3[n]:n,config:{}};return s3(t)}else return n instanceof RB?n:s3(n)}class Ak extends rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=He(e);let s=wi(e);return this.maxValue!=null&&(s=Rs(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Ak.className="ReLU";ve(Ak);class Rk extends rt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=He(e);return _m(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Rk.className="LeakyReLU";ve(Rk);class Dk extends rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Wt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Gt(e.alphaRegularizer),this.alphaConstraint=_n(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new J(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=yt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new yn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=He(e),Mm(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Yt(this.alphaInitializer),alphaRegularizer:Ot(this.alphaRegularizer),alphaConstraint:In(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Dk.className="PReLU";ve(Dk);let Ok=class extends rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=He(e);return Jh(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Ok.className="ELU";ve(Ok);class Fk extends rt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=He(e);return K(s,Ne(vs(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Fk.className="ThresholdedReLU";ve(Fk);class Lk extends rt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Ik().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return se(()=>{let s=He(e);const r=t.mask;if(r!=null){const i=K(_e($s(s.shape),Ne(r,s.dtype)),Me(-1e9));s=we(s,i)}return this.axis instanceof Array?this.axis.length>1?Ds(_e(s,Rm(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Lk.className="Softmax";ve(Lk);function Oc(n,e,t){if(typeof n=="number")return tu(n,e);if(n.length!==e)throw new J(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!iie(r))throw new J(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function pi(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let a;return t==="same"?a=n:a=n-i+1,Math.floor((a+s-1)/s)}function Ai(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Do([t-e,0]);else if(s==="same")n=n*e;else throw new J(`Unsupport padding mode: ${s}.`);return n}function Mk(n,e){return se(()=>(hn(e),e==="channelsFirst"?at(n,[0,2,3,1]):n))}function DB(n,e){return se(()=>(hn(e),e==="channelsFirst"?at(n,[0,2,3,4,1]):n))}function qae(n,e,t,s=1,r="valid",i,a=1){return se(()=>{if(i==null&&(i=gi()),hn(i),n.shape.length!==3)throw new J(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new J(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new J(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=at(n,[0,2,1])),r==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Tx(n,e,s,r==="same"?"same":"valid","NWC",a);return t!=null&&(o=vi(o,t)),o})}function r3(n,e,t,s=[1,1],r="valid",i,a,o=null){return se(()=>{if(i==null&&(i=gi()),hn(i),n.rank!==3&&n.rank!==4)throw new J(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new J(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=Mk(n,i);if(r==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Rz({x:u,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),i==="channelsFirst"&&(u=at(u,[0,3,1,2])),u})}function Kae(n,e,t,s=[1,1,1],r="valid",i,a){return se(()=>{if(i==null&&(i=gi()),hn(i),n.rank!==4&&n.rank!==5)throw new J(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new J(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=DB(n,i);if(r==="causal")throw new Ze("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=W2(o,e,s,r==="same"?"same":"valid","NDHWC",a),t!=null&&(o=vi(o,t)),i==="channelsFirst"&&(o=at(o,[0,4,1,2,3])),o})}class vw extends rt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",vw.verifyArgs(t),this.rank=e,Ln(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Oc(t.kernelSize,e,"kernelSize"),this.strides=Oc(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Nr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,hn(this.dataFormat),this.activation=Fo(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=_n(t.biasConstraint),this.biasRegularizer=Gt(t.biasRegularizer),this.activityRegularizer=Gt(t.activityRegularizer),this.dilationRate=Oc(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new J(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new J(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new J(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(_i("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!ck(e.kernelSize,"number",1,3))throw new J(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Oo(this.activation),useBias:this.useBias,biasInitializer:Yt(this.biasInitializer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),biasConstraint:In(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class id extends vw{constructor(e,t){super(e,t),this.kernel=null,id.verifyArgs(t),this.filters=t.filters,Ln(this.filters,"filters"),this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=_n(t.kernelConstraint),this.kernelRegularizer=Gt(t.kernelRegularizer)}build(e){e=yt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new J(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return se(()=>{e=He(e);let s;const r=this.bias==null?null:this.bias.read(),i=VP(this.activation.getClassName());if(i!=null&&this.rank===2)s=r3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=qae(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=r3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=Kae(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ze("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=yt(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const a=pi(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Yt(this.kernelInitializer),kernelRegularizer:Ot(this.kernelRegularizer),kernelConstraint:In(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new J(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ad extends id{constructor(e){super(2,e),ad.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!ck(e.kernelSize,"number",1,2))throw new J(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ad.className="Conv2D";ve(ad);class od extends id{constructor(e){super(3,e),od.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new J(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}od.className="Conv3D";ve(od);class zk extends ad{constructor(e){if(super(e),this.inputSpec=[new yn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new J(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=yt(e),e.length!==4)throw new J("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new J("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return se(()=>{let s=He(e);if(s.shape.length!==4)throw new J(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const u=r[a],h=r[o],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=Ai(u,m,d,this.padding),x=Ai(h,y,p,this.padding),w=[i,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=at(s,[0,2,3,1]));let S=Cx(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=at(S,[0,3,1,2])),this.bias!=null&&(S=vi(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(e){e=yt(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const a=this.kernelSize[0],o=this.kernelSize[1],u=this.strides[0],h=this.strides[1];return t[s]=this.filters,t[r]=Ai(t[r],u,a,this.padding),t[i]=Ai(t[i],h,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}zk.className="Conv2DTranspose";ve(zk);class Pk extends od{constructor(e){if(super(e),this.inputSpec=[new yn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new J(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=yt(e),e.length!==5)throw new J("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new J("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return se(()=>{let s=He(e);if(s.shape.length!==5)throw new J(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o,u;this.dataFormat==="channelsFirst"?(u=2,a=3,o=4):(u=1,a=2,o=3);const h=r[u],d=r[a],p=r[o],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],S=this.strides[2],C=Ai(h,x,m,this.padding),N=Ai(d,w,y,this.padding),k=Ai(p,S,b,this.padding),E=[i,C,N,k,this.filters];this.dataFormat!=="channelsLast"&&(s=at(s,[0,2,3,4,1]));let _=G2(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(_=at(_,[0,4,1,2,3])),this.bias!==null&&(_=vi(_,this.bias.read(),this.dataFormat)),this.activation!==null&&(_=this.activation.apply(_)),_})}computeOutputShape(e){e=yt(e);const t=e.slice();let s,r,i,a;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,a=4):(s=4,r=1,i=2,a=3);const o=this.kernelSize[0],u=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return t[s]=this.filters,t[r]=Ai(t[r],d,o,this.padding),t[i]=Ai(t[i],p,u,this.padding),t[a]=Ai(t[a],m,h,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Pk.className="Conv3DTranspose";ve(Pk);class OB extends id{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new J("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new J("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new J(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Gt(t.depthwiseRegularizer),this.depthwiseConstraint=_n(t.depthwiseConstraint),this.pointwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Gt(t.pointwiseRegularizer),this.pointwiseConstraint=_n(t.pointwiseConstraint)}build(e){if(e=yt(e),e.length<this.rank+2)throw new J(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new J(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new yn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return se(()=>{e=He(e);let s;if(this.rank===1)throw new Ze("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=at(e,[0,2,3,1])),s=zx(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=vi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=at(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Yt(this.depthwiseInitializer),e.pointwiseInitializer=Yt(this.pointwiseInitializer),e.depthwiseRegularizer=Ot(this.depthwiseRegularizer),e.pointwiseRegularizer=Ot(this.pointwiseRegularizer),e.depthwiseConstraint=In(this.depthwiseConstraint),e.pointwiseConstraint=In(this.pointwiseConstraint),e}}OB.className="SeparableConv";class Bk extends OB{constructor(e){super(2,e)}}Bk.className="SeparableConv2D";ve(Bk);class Zm extends id{constructor(e){super(1,e),Zm.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!ck(e.kernelSize,"number",1,1))throw new J(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Zm.className="Conv1D";ve(Zm);class Vk extends rt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return se(()=>{if(e=He(e),this.dataFormat==="channelsLast"){const s=Ly(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ly(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Ly(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ly(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Vk.className="Cropping2D";ve(Vk);class Uk extends rt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,nie(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return se(()=>{let s=He(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=at(s,[0,2,3,1]);const i=this.size[0]*r[2],a=this.size[1]*r[3],o=this.interpolation==="nearest"?Ur.resizeNearestNeighbor(s,[i,a]):Ur.resizeBilinear(s,[i,a]);return at(o,[0,3,1,2])}else{const i=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?Ur.resizeNearestNeighbor(s,[i,a]):Ur.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Uk.className="UpSampling2D";ve(Uk);function Xae(n,e,t=[1,1],s="valid",r,i){return se(()=>{r==null&&(r=gi()),hn(r);let a=Mk(n,r);if(n.rank!==4)throw new J(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new J(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Yh(a,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(a=at(a,[0,3,1,2])),a})}class jk extends vw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Wt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=_n(e.depthwiseConstraint),this.depthwiseRegularizer=Gt(e.depthwiseRegularizer)}build(e){if(e=yt(e),e.length<4)throw new J(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new J(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return se(()=>{e=He(e);let s=Xae(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=vi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=yt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=pi(t,this.kernelSize[0],this.padding,this.strides[0]),a=pi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,a]:[e[0],i,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Yt(this.depthwiseInitializer),e.depthwiseRegularizer=Ot(this.depthwiseRegularizer),e.depthwiseConstraint=In(this.depthwiseRegularizer),e}}jk.className="DepthwiseConv2D";ve(jk);function FB(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new J("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function LB(n,e,t,s=!1,r,i,a=!1,o=!1){return se(()=>{const u=e.shape.length;if(u<3)throw new J(`Input should be at least 3D, but is ${u}D.`);const h=[1,0].concat(mi(2,u));e=at(e,h),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ne(Ne(r,"bool"),"float32"),r.rank===u-1&&(r=Hn(r,-1)),r=at(r,h)),s&&(e=Tr(e,0),r!=null&&(r=Tr(r,0)));const d=[];let p,m=t;const y=e.shape[0],b=Cr(e);let x;r!=null&&(x=Cr(r));for(let S=0;S<y;++S){const C=b[S],N=se(()=>n(C,m));if(r==null)p=N[0],m=N[1];else{const k=se(()=>{const E=x[S],_=_e(Qs(E),E),R=we(K(N[0],E),K(m[0],_)),O=m.map((F,L)=>we(K(N[1][L],E),K(F,_)));return{output:R,newStates:O}});p=k.output,m=k.newStates}o&&d.push(p)}let w;return o&&(w=bs(d,1)),[p,w,m]})}class Si extends rt{constructor(e){super(e);let t;if(e.cell==null)throw new J("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Cw({cells:e.cell}):t=e.cell,t.stateSize==null)throw new J("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new yn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return mi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){qT(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const a of t)i.push([e[0],a]);return[r].concat(i)}else return r}computeMask(e,t){return se(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ze("Constants support is not implemented in RNN yet.");qT(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new yn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!it(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new J(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new yn({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){se(()=>{if(!this.stateful)throw new Ii("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new J("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gn([s,r])):this.states_=[gn([s,this.cell.stateSize])];else if(e==null)Ke(this.states_),this.keptStates!=null&&(Ke(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gn([s,r])):this.states_[0]=gn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new J(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Ke(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,a];if(!it(i.shape,o))throw new J(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>En(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=FB(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let a=[],o=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new yn({shape:h.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof yi){const h=[e].concat(a),d=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return se(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=He(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new J(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},h=LB((b,x)=>{const w=this.cell.call([b].concat(x),o);return[w[0],w.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],p=h[1],m=h[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?p:d;return this.returnState?[y].concat(m):y})}getInitialState(e){return se(()=>{let t=gn(e.shape);return t=Ae(t,[1,2]),t=qm(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?GT(t,[1,s]):t):this.cell.stateSize>1?[GT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Si.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=fi(r,s);return new e(Object.assign(t,{cell:i}))}}Si.className="RNN";ve(Si);class Qm extends rt{}class Sw extends Qm{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ln(this.units,"units"),this.activation=Fo(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Do([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Do([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=yt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return se(()=>{if(e=e,e.length!==2)throw new J(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lo({ones:()=>Qs(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lo({ones:()=>Qs(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?i=Bi(K(e,a),this.kernel.read()):i=Bi(e,this.kernel.read()),this.bias!=null&&(i=vi(i,this.bias.read())),o!=null&&(s=K(s,o));let u=we(i,Bi(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Oo(this.activation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),recurrentConstraint:In(this.recurrentConstraint),biasConstraint:In(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Sw.className="SimpleRNNCell";ve(Sw);class Wk extends Si{constructor(e){e.cell=new Sw(e),super(e)}call(e,t){return se(()=>{this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}Wk.className="SimpleRNN";ve(Wk);class Tw extends Qm{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new J("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ln(this.units,"units"),this.activation=Fo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Do([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Do([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=yt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return se(()=>{if(e=e,e.length!==2)throw new J(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lo({ones:()=>Qs(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lo({ones:()=>Qs(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let o,u,h;0<this.dropout&&this.dropout<1&&(e=K(e,i[0]));let d=Bi(e,this.kernel.read());this.useBias&&(d=vi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=K(r,a[0]));const p=this.recurrentKernel.read(),[m,y]=Is(p,[2*this.units,this.units],p.rank-1),b=Bi(r,m),[x,w,S]=Is(d,3,d.rank-1),[C,N]=Is(b,2,b.rank-1);o=this.recurrentActivation.apply(we(x,C)),u=this.recurrentActivation.apply(we(w,N));const k=Bi(K(u,r),y);h=this.activation.apply(we(S,k));const E=we(K(o,r),K(we(1,Mt(o)),h));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Oo(this.activation),recurrentActivation:Oo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),recurrentConstraint:In(this.recurrentConstraint),biasConstraint:In(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Tw.className="GRUCell";ve(Tw);class Gk extends Si{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Tw(e),super(e)}call(e,t){return se(()=>{this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Gk.className="GRU";ve(Gk);class eg extends Qm{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ln(this.units,"units"),this.activation=Fo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Do([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Do([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=yt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;r=new(t=class extends qr{apply(u,h){const d=i.apply([a]),p=new cw().apply([a]),m=i.apply([a*2]);return VO(VO(d,p),m)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return se(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new J(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lo({ones:()=>Qs(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lo({ones:()=>Qs(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let u,h,d,p;0<this.dropout&&this.dropout<1&&(e=K(e,a[0]));let m=Bi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=K(r,o[0])),m=we(m,Bi(r,this.recurrentKernel.read())),this.useBias&&(m=vi(m,this.bias.read()));const[y,b,x,w]=Is(m,4,m.rank-1);u=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=we(K(h,i),K(u,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const S=K(p,this.activation.apply(d));return[S,S,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Oo(this.activation),recurrentActivation:Oo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),recurrentConstraint:In(this.recurrentConstraint),biasConstraint:In(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}eg.className="LSTMCell";ve(eg);class Hk extends Si{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new eg(e),super(e)}call(e,t){return se(()=>{this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Hk.className="LSTM";ve(Hk);class Cw extends Qm{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return se(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let a;for(let o=0;o<this.cells.length;++o){const u=this.cells[o];s=r[o],o===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=u.call(a,t),i.push(a.slice(1))}s=[];for(const o of i.slice().reverse())s.push(...o);return[a[0]].concat(s)})}build(e){qT(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Ul(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(fi(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return KT(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],i[a]])}xk(t)}}Cw.className="StackedRNNCells";ve(Cw);function Lo(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,a=()=>i!=null?i(e(),t):KP(e(),t),o=()=>Xm(a,e,s);return!r||r<=1?En(o().clone()):Array(r).fill(void 0).map(o).map(h=>En(h.clone()))}var Yae=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class MB extends Si{constructor(e){if(e.unroll)throw new Ze("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ze("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new yn({ndim:5})]}call(e,t){return se(()=>{if(this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new J("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return se(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],a=gn(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){se(()=>{if(!this.stateful)throw new Ii("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new J("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gn(i)):this.states_=[gn(i)];else if(e==null)Ke(this.states_),this.keptStates!=null&&(Ke(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gn(i)):this.states_[0]=gn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new J(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ke(this.states_);for(let o=0;o<this.states_.length;++o){const u=e[o],h=i;if(!it(u.shape,h))throw new J(`State ${o} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${u.shape}`);this.states_[o]=u}}this.states_=this.states_.map(o=>En(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:a,dilationRate:o}=this.cell,u=t==="channelsFirst",h=e[u?3:2],d=e[u?4:3],p=pi(h,r[0],i,a[0],o[0]),m=pi(d,r[1],i,a[1],o[1]);return[...e.slice(0,2),...u?[s,p,m]:[p,m,s]]}}MB.className="ConvRNN2D";class Nw extends eg{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ln(this.filters,"filters"),this.kernelSize=Oc(s,2,"kernelSize"),this.kernelSize.forEach(u=>Ln(u,"kernelSize")),this.strides=Oc(r||1,2,"strides"),this.strides.forEach(u=>Ln(u,"strides")),this.padding=i||"valid",Nr(this.padding),this.dataFormat=a||"channelsLast",hn(this.dataFormat),this.dilationRate=Oc(o||1,2,"dilationRate"),this.dilationRate.forEach(u=>Ln(u,"dilationRate"))}build(e){var t;e=yt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new J(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,a=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;u=new(t=class extends qr{apply(m,y){const b=h.apply([d]),x=$s([d]),w=h.apply([d*2]);return hk([b,x,w])}},t.className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return se(()=>{if(e.length!==3)throw new J(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Lo({ones:()=>Qs(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,h=(ae,P,H)=>!P||!P[H]?ae:K(P[H],ae);let d=h(r,u,0),p=h(r,u,1),m=h(r,u,2),y=h(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Lo({ones:()=>Qs(i),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(i,b,0),w=h(i,b,1),S=h(i,b,2),C=h(i,b,3);const N=3,[k,E,_,R]=Is(this.kernel.read(),o,N),[O,F,L,A]=this.useBias?Is(this.bias.read(),o):[null,null,null,null];d=this.inputConv(d,k,O,this.padding),p=this.inputConv(p,E,F,this.padding),m=this.inputConv(m,_,L,this.padding),y=this.inputConv(y,R,A,this.padding);const[U,Y,te,Z]=Is(this.recurrentKernel.read(),o,N);x=this.recurrentConv(x,U),w=this.recurrentConv(w,Y),S=this.recurrentConv(S,te),C=this.recurrentConv(C,Z);const B=this.recurrentActivation.apply(we(d,x)),V=this.recurrentActivation.apply(we(p,w)),j=we(K(V,a),K(B,this.activation.apply(we(m,S)))),ee=K(this.recurrentActivation.apply(we(y,C)),this.activation.apply(j));return[ee,ee,j]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=Yae(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=Ea(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?vi(i,s,this.dataFormat):i}recurrentConv(e,t){return Ea(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Nw.className="ConvLSTM2DCell";ve(Nw);class qk extends MB{constructor(e){const t=new Nw(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}qk.className="ConvLSTM2D";ve(qk);class kw extends rt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return Xm(()=>KP(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}kw.className="Dropout";ve(kw);class Kk extends kw{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Kk.className="SpatialDropout1D";ve(Kk);class Xk extends rt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ln(this.units,"units"),this.activation=Fo(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=_n(e.kernelConstraint),this.biasConstraint=_n(e.biasConstraint),this.kernelRegularizer=Gt(e.kernelRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.activityRegularizer=Gt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=yt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=yt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e),r=VP(this.activation.getClassName());let i;return r!=null?i=Bi(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Bi(s,this.kernel.read()),this.bias!=null&&(i=vi(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Oo(this.activation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),biasConstraint:In(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Xk.className="Dense";ve(Xk);class Yk extends rt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=yt(e);for(const t of e.slice(1))if(t==null)throw new J(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Co(e,1)]}call(e,t){return se(()=>{this.invokeCallHook(e,t);let s=He(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=at(s,r)}return lie(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Yk.className="Flatten";ve(Yk);class Jk extends rt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Fo(e.activation)}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e);return this.activation.apply(s)})}getConfig(){const e={activation:Oo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Jk.className="Activation";ve(Jk);class Zk extends rt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return se(()=>(e=He(e),aie(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Zk.className="RepeatVector";ve(Zk);class Qk extends rt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,a=null;for(let u=0;u<r.length;++u){const h=r[u];if(this.isUnknown(h))if(a===null)a=u;else throw new J("Can only specifiy one unknown dimension.");else i*=h}const o=Co(e);if(a!==null){if(i===0||o%i!==0)throw new J(s);r[a]=o/i}else if(o!==i)throw new J(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return X(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}Qk.className="Reshape";ve(Qk);class eE extends rt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=mi(1,e.dims.length+1);if(!it(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new yn({ndim:this.dims.length+1})]}computeOutputShape(e){e=yt(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return at(He(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}eE.className="Permute";ve(eE);class tE extends rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=He(e);return np(Zl(s,this.maskValue),-1)}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e),a=np(Zl(s,this.maskValue),-1,!0);return K(s,Ne(a,s.dtype))})}}tE.className="Masking";ve(tE);class nE extends rt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ct(e.inputLength))}this.inputDim=e.inputDim,Ln(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ln(this.outputDim,"outputDim"),this.embeddingsInitializer=Wt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Gt(e.embeddingsRegularizer),this.activityRegularizer=Gt(e.activityRegularizer),this.embeddingsConstraint=_n(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return se(()=>this.maskZero?(e=He(e),Zl(e,ct(e))):null)}computeOutputShape(e){if(e=yt(e),this.inputLength==null)return[...e,this.outputDim];const t=Ct(this.inputLength);if(t.length!==e.length-1)throw new J(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],a=e[r+1];if(i!=null&&a!=null&&i!==a)throw new J(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return se(()=>{this.invokeCallHook(e,t);let s=He(e);s.dtype!=="int32"&&(s=Pi(s,"int32"));const r=qP(this.embeddings.read(),X(s,[s.size]));return X(r,yt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Yt(this.embeddingsInitializer),embeddingsRegularizer:Ot(this.embeddingsRegularizer),activityRegularizer:Ot(this.activityRegularizer),embeddingsConstraint:In(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}nE.className="Embedding";ve(nE);class xu extends rt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ze}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],a=t[r];if(i==null||a==null||i<0||a<0)s.push(null);else if(i===1)s.push(a);else if(a===1)s.push(i);else{if(i!==a)throw new J("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[yt(e)]),e=e,e.length<2)throw new J(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=To(t),t.length>1)throw new J(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const a=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&To(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return se(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Do(r);for(let a of e){const o=a.rank;for(let u=0;u<i-o;++u)a=qm(a,1);s.push(a)}return this.mergeFunction(s)}else{let i=!1;for(const u of e){const h=u.rank;if(h==null){const d=u.shape,p=d[0],m=d.slice(1).concat([p]);let y=X(u,[p].concat(Co(d.slice(1))));y=at(y,[1,0]),y=X(y,m),s.push(y),i=!0}else if(h>1){const d=mi(1,h).concat([0]);s.push(at(u,d)),i=!0}else s.push(u)}let a=this.mergeFunction(s);const o=a.rank;if(i){if(o==null){const u=a.shape,h=u.length,d=u[h-1],p=[d].concat(u.slice(0,u.length-1));a=X(at(X(a,[-1,d]),[1,0]),p)}else if(o>1){const u=[o-1].concat(mi(0,o-1));a=at(a,u)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=To(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return se(()=>{if(t==null)return null;if(!Array.isArray(t))throw new J("`mask` should be an Array");if(!Array.isArray(e))throw new J("`inputs` should be an Array");if(t.length!==e.length)throw new J(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Hn(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Gr(s,t[r]);return s})}}class sE extends xu{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return t})}}sE.className="Add";ve(sE);class rE extends xu{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=K(t,e[s]);return t})}}rE.className="Multiply";ve(rE);class iE extends xu{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return K(1/e.length,t)})}}iE.className="Average";ve(iE);class aE extends xu{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=qi(t,e[s]);return t})}}aE.className="Maximum";ve(aE);class oE extends xu{constructor(e){super(e)}mergeFunction(e){return se(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Ro(t,e[s]);return t})}}oE.className="Minimum";ve(oE);class lE extends xu{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new J("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let a=!1;for(const o of s)if(it(o,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new J("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return se(()=>hk(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new J("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new J("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new J("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new J(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return se(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(Ne(Qs(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Hn(t[a],-1)):r.push(t[a]);const i=ln(r,this.axis);return Sx(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}lE.className="Concatenate";ve(lE);function gf(n,e){for(;n<0;)n+=e;return n}function Jae(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Ze("batchDot is not implemented for tensors of 4D or higher rank yet");if(D(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),D(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Ze("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return se(()=>{let a;if(s>r){a=s-r;const u=[];for(let h=0;h<a;++h)u.push(1);e=X(e,e.shape.concat(u))}else if(r>s){a=r-s;const u=[];for(let h=0;h<a;++h)u.push(1);n=X(n,n.shape.concat(u))}else a=0;let o;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?o=Ae(K(n,e),i[0]):o=Ae(K(at(n,[1,0]),e),i[1]);else{const u=i[0]!==n.shape.length-1,h=i[1]===e.shape.length-1;o=nt(n,e,u,h)}if(a>0){let u;s>r?u=s+r-3:u=s-1;const h=[];for(let d=u;d<u+a;++d)h.push(d);o=Go(o,h)}return o.shape.length===1&&(o=Hn(o,1)),o})}class uE extends xu{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){D(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new J(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new J(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,a)=>gf(i,e[a].shape.length)):r=[gf(this.axes,t.shape.length),gf(this.axes,s.shape.length)],this.normalize&&(t=z0(t,r[0]),s=z0(s,r[1])),Jae(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[gf(this.axes,e.length),gf(this.axes,t.length)],s}computeOutputShape(e){D(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}uE.className="Dot";ve(uE);class cE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e);return Xm(()=>we(uw(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}cE.className="GaussianNoise";ve(cE);class hE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return se(()=>{this.invokeCallHook(e,t);const s=He(e);return this.rate>0&&this.rate<1?Xm(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return K(s,uw(s.shape,1,i))},()=>s,t.training||!1):s})}}hE.className="GaussianDropout";ve(hE);class dE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||He(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return se(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Xm(()=>{const i=He(e),o=-1.6732632423543772*1.0507009873554805;let u=La(Wo(s),this.rate);u=Pi(u,"float32");const h=((1-this.rate)*(1+this.rate*o**2))**-.5,d=-h*o*this.rate,p=we(K(i,u),K(we(u,-1),o));return we(K(p,h),d)},()=>He(e),t.training||!1)}return e})}}dE.className="AlphaDropout";ve(dE);function lp(n,e,t,s,r,i=.001){let a;if(n.rank===2)a=O2(n,e,t,s,r,i);else if(n.rank===3)a=F2(n,e,t,s,r,i);else if(n.rank===4)a=L2(n,e,t,s,r,i);else throw new Ze(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function Zae(n,e,t,s,r=.001){return se(()=>{const i=Fm(n,s),a=i.mean,o=i.variance;return[lp(n,a,o,t,e,r),a,o]})}function Qae(n,e,t,s,r=.001){return se(()=>{const i=Fm(n,s),a=i.mean,o=i.variance,u=[];for(const b of mi(0,n.rank))s.indexOf(b)!==-1?u.push(1):u.push(n.shape[b]);const h=X(a,u),d=X(o,u),p=e==null?null:X(e,u),m=t==null?null:X(t,u);return[lp(n,h,d,m,p,r),a,o]})}function eoe(n,e,t,s,r=.001){return it(s.slice().sort(),mi(0,n.rank-1))?Zae(n,e,t,s,r):Qae(n,e,t,s,r)}class fE extends rt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Wt(e.betaInitializer||"zeros"),this.gammaInitializer=Wt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Wt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Wt(e.movingVarianceInitializer||"ones"),this.betaConstraint=_n(e.betaConstraint),this.gammaConstraint=_n(e.gammaConstraint),this.betaRegularizer=Gt(e.betaRegularizer),this.gammaRegularizer=Gt(e.gammaRegularizer)}build(e){e=yt(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new J(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new yn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return se(()=>{const s=t.training==null?!1:t.training,r=He(e),i=r.shape,a=i.length,o=mi(0,a),u=this.axis>=0?this.axis:this.axis+a;o.splice(u,1);const h=tu(1,a);h[u]=i[u];const d=o.slice();d.sort();const p=!it(d,mi(0,a).slice(0,a-1)),m=()=>{if(p){const C=X(this.movingMean.read(),h),N=X(this.movingVariance.read(),h),k=this.center?X(this.beta.read(),h):null,E=this.scale?X(this.gamma.read(),h):null;return lp(r,C,N,k,E,this.epsilon)}else return lp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=eoe(r,this.gamma.read(),this.beta.read(),o,this.epsilon),w=(C,N,k)=>{se(()=>{const E=1-k,_=C.read(),R=K(_e(_,N),E);C.write(_e(_,R))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yt(this.betaInitializer),gammaInitializer:Yt(this.gammaInitializer),movingMeanInitializer:Yt(this.movingMeanInitializer),movingVarianceInitializer:Yt(this.movingVarianceInitializer),betaRegularizer:Ot(this.betaRegularizer),gammaRegularizer:Ot(this.gammaRegularizer),betaConstraint:In(this.betaConstraint),gammaConstraint:In(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}fE.className="BatchNormalization";ve(fE);class pE extends rt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Wt(e.betaInitializer||"zeros"),this.gammaInitializer=Wt(e.gammaInitializer||"ones"),this.betaRegularizer=Gt(e.betaRegularizer),this.gammaRegularizer=Gt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=yt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==To(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=He(e),r=s.shape,i=r.length;return se(()=>{let{mean:o,variance:u}=Fm(s,this.axis,!0);const h=tu(1,i);for(const x of this.axis)h[x]=r[x];const d=x=>x!=null&&x.shape.length!==i?X(x,h):x;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<i;++x)this.axis.indexOf(x)!==-1?(y.push(r[x]),b.push(1)):(y.push(1),b.push(r[x]));return o=br(o,y),u=br(u,y),p!=null&&(p=br(p,b)),m!=null&&(m=br(m,b)),lp(s,o,u,m,p,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yt(this.betaInitializer),gammaInitializer:Yt(this.gammaInitializer),betaRegularizer:Ot(this.betaRegularizer),gammaRegularizer:Ot(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}pE.className="LayerNormalization";ve(pE);function toe(n,e,t){return se(()=>{if(n.rank!==4)throw new J(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new J("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=gi()),t!=="channelsLast"&&t!=="channelsFirst")throw new J(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Ma(n,s)})}class mE extends rt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?gi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new J(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new J(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new J(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){e=yt(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return se(()=>toe(He(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}mE.className="ZeroPadding2D";ve(mE);function Ew(n,e,t,s,r,i){return se(()=>{hn(r),jP(i),Nr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=gi()),i==null&&(i="max"),n=Mk(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=Om(n,e,t,o):a=km(n,e,t,o),r==="channelsFirst"&&(a=at(a,[0,3,1,2])),a})}function zB(n,e,t,s,r,i){return se(()=>{hn(r),jP(i),Nr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=gi()),i==null&&(i="max"),n=DB(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=iN(n,e,t,o):a=D2(n,e,t,o),r==="channelsFirst"&&(a=at(a,[0,4,1,2,3])),a})}class PB extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new J(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ln(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new J(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ln(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Nr(this.padding),this.inputSpec=[new yn({ndim:3})]}computeOutputShape(e){e=yt(e);const t=pi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return se(()=>{this.invokeCallHook(e,t),e=qm(He(e),2);const s=this.poolingFunction(He(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Go(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class gE extends PB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Ew(e,t,s,r,i,"max")}}gE.className="MaxPooling1D";ve(gE);class yE extends PB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Ew(e,t,s,r,i,"avg")}}yE.className="AveragePooling1D";ve(yE);class BB extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new J(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ln(this.poolSize,"poolSize"),Ln(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),Nr(this.padding),this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){e=yt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=pi(t,this.poolSize[0],this.padding,this.strides[0]),s=pi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return se(()=>(this.invokeCallHook(e,t),this.poolingFunction(He(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class bE extends BB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Ew(e,t,s,r,i,"max")}}bE.className="MaxPooling2D";ve(bE);class xE extends BB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Ew(e,t,s,r,i,"avg")}}xE.className="AveragePooling2D";ve(xE);class VB extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new J(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ln(this.poolSize,"poolSize"),Ln(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),Nr(this.padding),this.inputSpec=[new yn({ndim:5})]}computeOutputShape(e){e=yt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=pi(t,this.poolSize[0],this.padding,this.strides[0]),s=pi(s,this.poolSize[1],this.padding,this.strides[1]),r=pi(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return se(()=>(this.invokeCallHook(e,t),this.poolingFunction(He(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class wE extends VB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),zB(e,t,s,r,i,"max")}}wE.className="MaxPooling3D";ve(wE);class vE extends VB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),zB(e,t,s,r,i,"avg")}}vE.className="AveragePooling3D";ve(vE);class UB extends rt{constructor(e){super(e),this.inputSpec=[new yn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ze}}class SE extends UB{constructor(e){super(e||{})}call(e,t){return se(()=>{const s=He(e);return Kt(s,1)})}}SE.className="GlobalAveragePooling1D";ve(SE);class TE extends UB{constructor(e){super(e||{})}call(e,t){return se(()=>{const s=He(e);return Sr(s,1)})}}TE.className="GlobalMaxPooling1D";ve(TE);class jB extends rt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ze}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class CE extends jB{call(e,t){return se(()=>{const s=He(e);return this.dataFormat==="channelsLast"?Kt(s,[1,2]):Kt(s,[2,3])})}}CE.className="GlobalAveragePooling2D";ve(CE);class NE extends jB{call(e,t){return se(()=>{const s=He(e);return this.dataFormat==="channelsLast"?Sr(s,[1,2]):Sr(s,[2,3])})}}NE.className="GlobalMaxPooling2D";ve(NE);class WB extends rt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=fi(r,s);delete t.layer;const a={layer:i};return Object.assign(a,t),new e(a)}}class kE extends WB{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=yt(e),e.length<3)throw new J(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=yt(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return se(()=>(e=He(e),LB((a,o)=>[He(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}kE.className="TimeDistributed";ve(kE);function noe(n){yu(tie,"BidirectionalMergeMode",n)}const soe="concat";class EE extends WB{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=fi(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=fi(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?soe:e.mergeMode,noe(this.mergeMode),e.weights)throw new Ze("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):ks(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=FB(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const a=[],o=[];if(s!=null){const h=s.length;if(h%2>0)throw new J("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const d=s.map(p=>new yn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),o.push(...d)}if(r!=null)throw new Ze("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof yi;for(const h of a)if(h instanceof yi!==u)throw new J("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const h=[e].concat(a),d=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return se(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const u=s.slice(0,s.length/2),h=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:h}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Tr(i,1));let o;return this.mergeMode==="concat"?o=hk([r,i]):this.mergeMode==="sum"?o=we(r,i):this.mergeMode==="ave"?o=K(.5,we(r,i)):this.mergeMode==="mul"?o=K(r,i):this.mergeMode==null&&(o=[r,i]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ul(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ul(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=fi(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ze("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}EE.className="Bidirectional";ve(EE);class $E extends rt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return se(()=>(e=He(e),e.dtype!=="float32"&&(e=Pi(e,"float32")),we(K(e,this.scale),this.offset)))}}$E.className="Rescaling";ve($E);const{resizeBilinear:roe,cropAndResize:ioe}=Ur;class IE extends rt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,a,o,u){return se(()=>{let h,d=!1;const p=t/a,m=s/o,y=(r+t)/a,b=(i+s)/o,x=[p,m,y,b],w=[];e.rank===3?(d=!0,h=bs([e])):h=e;for(let E=0;E<h.shape[0];E++)w.push(x);const S=Ys(w,[w.length,4]),C=Ql(0,w.length,1,"int32"),k=ioe(h,S,C,[r,i],"nearest");return Pi(d?He(Cr(k)):k,u)})}upsize(e,t,s,r){return se(()=>{const i=roe(e,[t,s]);return Pi(i,r)})}call(e,t){return se(()=>{const s=He(e),r=s.dtype,i=s.shape,a=i[i.length-3],o=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let h=0;return o!==this.width&&(h=Math.floor((o-this.width)/2),h===0&&(h=1)),u>=0&&h>=0?this.centerCrop(s,u,h,this.height,this.width,a,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=yt(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}IE.className="CenterCrop";ve(IE);function aoe(n,e,t,s){let r=He(n);if(r.dtype!=="int32"&&(r=Pi(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=Hn(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Hn(r,-1)),r.rank>2)throw new J(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),o=r;let u;if(typeof s<"u"&&e==="count"?u=R0(o,s,t,a):u=R0(o,[],t,a),e!=="tfIdf")return u;if(s)return K(u,s);throw new J("When outputMode is 'tfIdf', weights must be provided.")}class _E extends rt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=yt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return se(()=>{e=He(e),e.dtype!=="int32"&&(e=Pi(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new J(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=He(t.countWeights)}const r=Sr(e),i=Pc(e),a=vs(this.numTokens,r).bufferSync().get(0),o=La(i,0).bufferSync().get(0);if(!(a&&o))throw new J(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return aoe(e,this.outputMode,this.numTokens,s)})}}_E.className="CategoryEncoding";ve(_E);const ooe=["bilinear","nearest"],i3=new Set(ooe);class AE extends rt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(i3.has(e.interpolation))this.interpolation=e.interpolation;else throw new J(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=yt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return se(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Ur.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ur.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...i3]} are supported`)})}}AE.className="Resizing";ve(AE);class GB{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}GB.className="RandomSeed";class HB extends rt{constructor(e){super(e),this.randomGenerator=new GB(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}HB.className="BaseRandomLayer";const loe=["bilinear","nearest"],a3=new Set(loe);class RE extends HB{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new J(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new J(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new J(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(a3.has(s))this.interpolation=s;else throw new J(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=yt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return se(()=>{const s=He(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Wo([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Ur.resizeBilinear(e,a);case"nearest":return Ur.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...a3]} are supported`)}})}}RE.className="RandomWidth";ve(RE);function uoe(n){return new sd(n)}function coe(n){return new Ok(n)}function hoe(n){return new Ak(n)}function doe(n){return new Rk(n)}function foe(n){return new Dk(n)}function poe(n){return new Lk(n)}function moe(n){return new Fk(n)}function goe(n){return new Zm(n)}function yoe(n){return new ad(n)}function boe(n){return new zk(n)}function xoe(n){return new od(n)}function woe(n){return new Pk(n)}function voe(n){return new Bk(n)}function Soe(n){return new Vk(n)}function Toe(n){return new Uk(n)}function Coe(n){return new jk(n)}function Noe(n){return new Jk(n)}function koe(n){return new Xk(n)}function Eoe(n){return new kw(n)}function $oe(n){return new Kk(n)}function Ioe(n){return new Yk(n)}function _oe(n){return new Zk(n)}function Aoe(n){return new Qk(n)}function Roe(n){return new eE(n)}function Doe(n){return new nE(n)}function Ooe(n){return new sE(n)}function Foe(n){return new iE(n)}function Loe(n){return new lE(n)}function Moe(n){return new aE(n)}function zoe(n){return new oE(n)}function Poe(n){return new rE(n)}function Boe(n){return new uE(n)}function Voe(n){return new fE(n)}function Uoe(n){return new pE(n)}function joe(n){return new mE(n)}function DE(n){return new yE(n)}function Woe(n){return DE(n)}function Goe(n){return DE(n)}function OE(n){return new xE(n)}function Hoe(n){return OE(n)}function qoe(n){return OE(n)}function FE(n){return new vE(n)}function Koe(n){return FE(n)}function Xoe(n){return FE(n)}function Yoe(n){return new SE(n)}function Joe(n){return new CE(n)}function qB(n){return new TE(n)}function KB(n){return new NE(n)}function XB(n){return new gE(n)}function YB(n){return new bE(n)}function Zoe(n){return new wE(n)}function Qoe(n){return new Gk(n)}function ele(n){return new Tw(n)}function tle(n){return new Hk(n)}function nle(n){return new eg(n)}function sle(n){return new Wk(n)}function rle(n){return new Sw(n)}function ile(n){return new qk(n)}function ale(n){return new Nw(n)}function ole(n){return new Si(n)}function lle(n){return new Cw(n)}function ule(n){return new EE(n)}function cle(n){return new kE(n)}const hle=qB,dle=KB,fle=XB,ple=YB;function mle(n){return new cE(n)}function gle(n){return new hE(n)}function yle(n){return new dE(n)}function ble(n){return new tE(n)}function xle(n){return new $E(n)}function wle(n){return new IE(n)}function vle(n){return new AE(n)}function Sle(n){return new _E(n)}function Tle(n){return new RE(n)}const Cle=Object.freeze(Object.defineProperty({__proto__:null,Layer:rt,RNN:Si,RNNCell:Qm,activation:Noe,add:Ooe,alphaDropout:yle,average:Foe,averagePooling1d:DE,averagePooling2d:OE,averagePooling3d:FE,avgPool1d:Woe,avgPool2d:Hoe,avgPool3d:Koe,avgPooling1d:Goe,avgPooling2d:qoe,avgPooling3d:Xoe,batchNormalization:Voe,bidirectional:ule,categoryEncoding:Sle,centerCrop:wle,concatenate:Loe,conv1d:goe,conv2d:yoe,conv2dTranspose:boe,conv3d:xoe,conv3dTranspose:woe,convLstm2d:ile,convLstm2dCell:ale,cropping2D:Soe,dense:koe,depthwiseConv2d:Coe,dot:Boe,dropout:Eoe,elu:coe,embedding:Doe,flatten:Ioe,gaussianDropout:gle,gaussianNoise:mle,globalAveragePooling1d:Yoe,globalAveragePooling2d:Joe,globalMaxPool1d:hle,globalMaxPool2d:dle,globalMaxPooling1d:qB,globalMaxPooling2d:KB,gru:Qoe,gruCell:ele,input:gB,inputLayer:uoe,layerNormalization:Uoe,leakyReLU:doe,lstm:tle,lstmCell:nle,masking:ble,maxPool1d:fle,maxPool2d:ple,maxPooling1d:XB,maxPooling2d:YB,maxPooling3d:Zoe,maximum:Moe,minimum:zoe,multiply:Poe,permute:Roe,prelu:foe,randomWidth:Tle,reLU:hoe,repeatVector:_oe,rescaling:xle,reshape:Aoe,resizing:vle,rnn:ole,separableConv2d:voe,simpleRNN:sle,simpleRNNCell:rle,softmax:poe,spatialDropout1d:$oe,stackedRNNCells:lle,thresholdedReLU:moe,timeDistributed:cle,upSampling2d:Toe,zeroPadding2d:joe},Symbol.toStringTag,{value:"Module"}));function Nle(n,e){return kk(n,e)}function kle(n,e){return aB(n,e)}function Ele(n,e){return oB(n,e)}function $le(n,e){return Ek(n,e)}function Ile(n,e){return $k(n,e)}function _le(n,e){return iB(n,e)}function Ale(n,e){return uae(n,e)}function Rle(n,e){return Nk(n,e)}function Dle(n,e){return bw(n,e)}function Ole(n,e){return rd(n,e)}function Fle(n,e){return rd(n,e)}function Lle(n,e){return rd(n,e)}function Mle(n,e){return bu(n,e)}function zle(n,e){return bu(n,e)}function Ple(n,e){return bu(n,e)}function Ble(n,e){return cae(n,e)}const Vle=Object.freeze(Object.defineProperty({__proto__:null,MAPE:Fle,MSE:zle,binaryAccuracy:Nle,binaryCrossentropy:kle,categoricalAccuracy:$le,categoricalCrossentropy:Ile,cosineProximity:Rle,mape:Lle,meanAbsoluteError:Dle,meanAbsolutePercentageError:Ole,meanSquaredError:Mle,mse:Ple,precision:_le,r2Score:Ble,recall:Ale,sparseCategoricalAccuracy:Ele},Symbol.toStringTag,{value:"Module"}));const Ule=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:Pae},Symbol.toStringTag,{value:"Module"}));function jle(n){return new Jm(n)}function Wle(n){return Gae(n)}function Gle(n){return Hae(n)}const Hle=Object.freeze(Object.defineProperty({__proto__:null,l1:Wle,l1l2:jle,l2:Gle},Symbol.toStringTag,{value:"Module"}));class JB extends Hc{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof wa))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function zy(n,e){return n<e}function o3(n,e){return n>e}class ZB extends JB{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Ze("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=zy:this.mode==="max"?this.monitorFunc=o3:this.monitor.indexOf("acc")!==-1?this.monitorFunc=o3:this.monitorFunc=zy,this.monitorFunc===zy&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===zy?1/0:-1/0}async onEpochEnd(e,t){await fo(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function qle(n){return new ZB(n)}const Kle={earlyStopping:qle};const Xle=ie();Xle.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ws;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ws||(Ws={}));var l3;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(l3||(l3={}));const LE={};function Yle(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};LE[n]=t}function QB(n){return LE[n]}function Jle(n){delete LE[n]}function $(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,u=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,h=o<0?e.inputNames.length+o:o;if(i.type==="tensor")return qn(e.inputNames[h],t,s,r);if(i.type==="tensors"){const m=e.inputs.slice(o,u);return e.inputNames.slice(o,u).filter((b,x)=>{var w;return((w=m[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(b=>qn(b,t,s,r))}const d=qn(e.inputNames[h],t,s,r),p=d.dataSync();return i.type==="number"?p[0]:vr(d.shape,p)}const a=e.attrParams[n];return a&&a.value}function qn(n,e,t,s){const[r,i]=Hs(n,t);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[j0(r,o)]);return a!==void 0?e[j0(r,a)][i]:void 0}function u3(n,e,t){return e[j0(n,t.currentContextId)]}function ga(n,e){const[t,s,r]=Hs(n,e);return[j0(t,e&&e.currentContextId),s,r]}function j0(n,e){return e?`${n}-${e}`:n}function Hs(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],a=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[i,o,a]}return t&&e.parseNodeNameCache.set(n,r),r}function a0(n,e,t){let s=$("pad",n,e,t);if(s==="explicit"){s=$("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function ya(n){return n.kept?n:Mi(n)}const Zle=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qle=Object.freeze(Object.defineProperty({__proto__:null,json:Zle},Symbol.toStringTag,{value:"Module"}));const eue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tue=Object.freeze(Object.defineProperty({__proto__:null,json:eue},Symbol.toStringTag,{value:"Module"}));const nue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],sue=Object.freeze(Object.defineProperty({__proto__:null,json:nue},Symbol.toStringTag,{value:"Module"}));const rue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],iue=Object.freeze(Object.defineProperty({__proto__:null,json:rue},Symbol.toStringTag,{value:"Module"}));const aue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],oue=Object.freeze(Object.defineProperty({__proto__:null,json:aue},Symbol.toStringTag,{value:"Module"}));const lue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uue=Object.freeze(Object.defineProperty({__proto__:null,json:lue},Symbol.toStringTag,{value:"Module"}));const cue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],hue=Object.freeze(Object.defineProperty({__proto__:null,json:cue},Symbol.toStringTag,{value:"Module"}));const due=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],fue=Object.freeze(Object.defineProperty({__proto__:null,json:due},Symbol.toStringTag,{value:"Module"}));const pue=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],mue=Object.freeze(Object.defineProperty({__proto__:null,json:pue},Symbol.toStringTag,{value:"Module"}));const gue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],yue=Object.freeze(Object.defineProperty({__proto__:null,json:gue},Symbol.toStringTag,{value:"Module"}));const bue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],xue=Object.freeze(Object.defineProperty({__proto__:null,json:bue},Symbol.toStringTag,{value:"Module"}));const wue=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],vue=Object.freeze(Object.defineProperty({__proto__:null,json:wue},Symbol.toStringTag,{value:"Module"}));const Sue=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Tue=Object.freeze(Object.defineProperty({__proto__:null,json:Sue},Symbol.toStringTag,{value:"Module"}));const Cue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Nue=Object.freeze(Object.defineProperty({__proto__:null,json:Cue},Symbol.toStringTag,{value:"Module"}));const kue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Eue=Object.freeze(Object.defineProperty({__proto__:null,json:kue},Symbol.toStringTag,{value:"Module"}));const $ue=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Iue=Object.freeze(Object.defineProperty({__proto__:null,json:$ue},Symbol.toStringTag,{value:"Module"}));const _ue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Aue=Object.freeze(Object.defineProperty({__proto__:null,json:_ue},Symbol.toStringTag,{value:"Module"}));const Rue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Due=Object.freeze(Object.defineProperty({__proto__:null,json:Rue},Symbol.toStringTag,{value:"Module"}));const Oue=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Fue=Object.freeze(Object.defineProperty({__proto__:null,json:Oue},Symbol.toStringTag,{value:"Module"}));class c3{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Qle,tue,sue,iue,oue,uue,hue,fue,mue,yue,xue,vue,Tue,Nue,Eue,Iue,Aue,Due,Fue],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],a=[],o=s.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?r.push(x[w.name]):w.op==="Const"?i.push(x[w.name]):(w.input==null||w.input.length===0)&&a.push(x[w.name]),x),{});let u=[];const h=[];let d={},p={};t!=null&&(d=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));const m=Object.keys(o);m.forEach(x=>{const w=o[x];w.inputNames.forEach((S,C)=>{const[N,,k]=ga(S),E=o[N];if(E.outputs!=null){const _=E.outputs.indexOf(k);if(_!==-1){const R=`${N}:${_}`;w.inputNames[C]=R}}w.inputs.push(E),E.children.push(w)})}),Object.keys(p).length===0?m.forEach(x=>{const w=o[x];w.children.length===0&&h.push(w)}):Object.keys(p).forEach(x=>{const[w]=ga(x),S=o[w];S!=null&&(S.signatureKey=p[x],h.push(S))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{const[w]=ga(x),S=o[w];S&&(S.signatureKey=d[x],u.push(S))}):u=r;let y={};e.library!=null&&e.library.function!=null&&(y=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const b={nodes:o,inputs:u,outputs:h,weights:i,placeholders:r,signature:t,functions:y};return a.length>0&&(b.initNodes=a),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=QB(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const a=i.type;let o;switch(i.type){case"string":o=QT(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=QT(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=aC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=aC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=tC(e.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=tC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=iC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=iC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=eC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=eC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=lC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=lC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=rC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=rC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=oC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=oC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=nC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=nC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=sC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=sC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=h3(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=h3(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:o,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&r.push(p[m.name]),p),{}));const a=[],o=[];e.signature.inputArg.forEach(p=>{const[m]=ga(p.name),y={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ME(p.type),type:"dtype"}},children:[]};y.signatureKey=p.name,a.push(y),i[m]=y}),Object.keys(i).forEach(p=>{const m=i[p];m.inputNames.forEach((y,b)=>{const[x,,w]=ga(y),S=i[x];if(S.outputs!=null){const C=S.outputs.indexOf(w);if(C!==-1){const N=`${x}:${C}`;m.inputNames[b]=N}}m.inputs.push(S),S.children.push(m)})});const h=e.ret;e.signature.outputArg.forEach(p=>{const[m,y]=ga(h[p.name]),b=i[m];b!=null&&(b.defaultOutput=y,o.push(b))});const d=this.mapArgsToSignature(e);return{nodes:i,inputs:a,outputs:o,weights:r,placeholders:s,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Lue(n){const e=ie().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function eV(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):Lue(n);return e?t:t.toLowerCase()}function QT(n,e,t,s=!1){const r=n[e];return r!=null?eV(r.s,s):t}function eC(n,e,t){const s=n[e];return s?s.b:t}function tC(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function ME(n){switch(typeof n=="string"&&(n=Ws[n]),n){case Ws.DT_FLOAT:case Ws.DT_HALF:return"float32";case Ws.DT_INT32:case Ws.DT_INT64:case Ws.DT_INT8:case Ws.DT_UINT8:return"int32";case Ws.DT_BOOL:return"bool";case Ws.DT_DOUBLE:return"float32";case Ws.DT_STRING:return"string";case Ws.DT_COMPLEX64:case Ws.DT_COMPLEX128:return"complex64";default:return null}}function h3(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function nC(n,e,t){const s=n[e];return s&&s.type?ME(s.type):t}function sC(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>ME(r)):t}function tV(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function rC(n,e,t){const s=n[e];return s&&s.shape?tV(s.shape):t}function iC(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function aC(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>eV(i,s)):t}function oC(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>tV(r)):t}function lC(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class Mue{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return qn(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return qn(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return tC(this.node.rawAttrs,e,t);if(s.s!=null)return QT(this.node.rawAttrs,e,t);if(s.b!=null)return eC(this.node.rawAttrs,e,t);if(s.shape!=null)return rC(this.node.rawAttrs,e,t);if(s.type!=null)return nC(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return iC(this.node.rawAttrs,e,t);if(s.list.s!=null)return aC(this.node.rawAttrs,e,t);if(s.list.shape!=null)return oC(this.node.rawAttrs,e,t);if(s.list.b!=null)return lC(this.node.rawAttrs,e,t);if(s.list.type!=null)return sC(this.node.rawAttrs,e,t)}return t}}const es=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:g2,abs:mn,acos:C2,acosh:N2,add:we,addN:BM,all:Sx,any:np,argMax:Xl,argMin:k2,asin:E2,asinh:$2,atan:I2,atan2:_2,atanh:A2,avgPool:km,avgPool3d:D2,basicLSTMCell:VM,batchNorm:Xh,batchNorm2d:O2,batchNorm3d:F2,batchNorm4d:L2,batchToSpaceND:Em,bincount:M2,bitwiseAnd:UM,booleanMaskAsync:kz,broadcastArgs:jM,broadcastTo:Vl,buffer:Qe,cast:Ne,ceil:z2,clipByValue:Rs,clone:Mi,complex:ka,concat:ln,concat1d:P2,concat2d:B2,concat3d:V2,concat4d:U2,conv1d:Tx,conv2d:Ea,conv2dTranspose:Cx,conv3d:W2,conv3dTranspose:G2,cos:$m,cosh:Nx,cosineWindow:Kx,cumprod:ip,cumsum:kx,denseBincount:R0,depthToSpace:H2,depthwiseConv2d:Yh,diag:GM,dilation2d:q2,div:Oe,divNoNan:K2,dot:X2,dropout:TN,einsum:kl,elu:Jh,enclosingPowerOfTwo:CN,ensureShape:HM,equal:Js,erf:Ex,euclideanNorm:J2,exp:Ds,expandDims:Hn,expm1:Z2,eye:$x,fft:Vm,fill:fu,floor:Qh,floorDiv:vx,fused:Fz,gather:ed,gatherND:_z,greater:vs,greaterEqual:La,ifft:Wc,imag:Im,image:Ur,inTopKAsync:Az,irfft:Ux,isFinite:Q2,isInf:eN,isNaN:tN,leakyRelu:_m,less:Bc,lessEqual:jo,linalg:EN,linspace:XM,localResponseNormalization:nN,log:Zs,log1p:Am,logSigmoid:sN,logSoftmax:_x,logSumExp:Rm,logicalAnd:Gr,logicalNot:Dm,logicalOr:Ax,logicalXor:rN,losses:Uz,lowerBound:JM,matMul:nt,max:Sr,maxPool:Om,maxPool3d:iN,maxPoolWithArgmax:ZM,maximum:qi,mean:Kt,meshgrid:QM,min:Pc,minimum:Ro,mirrorPad:aN,mod:oN,moments:Fm,movingAverage:Ez,mul:K,multiRNNCell:ez,multinomial:tz,neg:Mt,norm:Zh,notEqual:Zl,oneHot:Vc,ones:$s,onesLike:Qs,op:G,outerProduct:nz,pad:Ma,pad1d:sz,pad2d:rz,pad3d:iz,pad4d:az,pool:lN,pow:ji,prelu:Mm,print:T2,prod:uN,raggedGather:oz,raggedRange:lz,raggedTensorToTensor:uz,rand:cz,randomGamma:fz,randomNormal:Dx,randomStandardNormal:pz,randomUniform:Wo,randomUniformInt:mz,range:Ql,real:Uc,reciprocal:fN,relu:wi,relu6:Ox,reshape:X,reverse:Tr,reverse1d:gz,reverse2d:yz,reverse3d:bz,reverse4d:xz,rfft:Um,round:Fx,rsqrt:Lx,scalar:Me,scatterND:$z,searchSorted:Rx,selu:Mx,separableConv2d:zx,setdiff1dAsync:wz,sigmoid:di,sign:pN,signal:Vz,sin:Px,sinh:Bx,slice:ut,slice1d:zm,slice2d:Vx,slice3d:Pm,slice4d:jc,softmax:Bm,softplus:pu,spaceToBatchND:Lm,sparse:jz,sparseToDense:Iz,spectral:Bz,split:Is,sqrt:Pn,square:$t,squaredDifference:jx,squeeze:Go,stack:bs,step:mu,stridedSlice:mN,string:Wz,sub:_e,sum:Ae,tan:gN,tanh:Ao,tensor:Ys,tensor1d:Xn,tensor2d:So,tensor3d:yN,tensor4d:vz,tensor5d:Sz,tensor6d:Tz,tensorScatterUpdate:Cz,tile:br,topk:xN,transpose:at,truncatedNormal:Gx,unique:wN,unsortedSegmentSum:Hx,unstack:Cr,upperBound:Nz,variable:vN,where:Mn,whereAsync:SN,zeros:gn,zerosLike:ct},Symbol.toStringTag,{value:"Module"}));const zue=(n,e,t,s=es)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add($("a",n,e,t),$("b",n,e,t))];case"AddN":return[s.addN($("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod($("a",n,e,t),$("b",n,e,t))];case"Mul":return[s.mul($("a",n,e,t),$("b",n,e,t))];case"RealDiv":case"Div":return[s.div($("a",n,e,t),$("b",n,e,t))];case"DivNoNan":return[s.divNoNan($("a",n,e,t),$("b",n,e,t))];case"FloorDiv":return[s.floorDiv($("a",n,e,t),$("b",n,e,t))];case"Sub":return[s.sub($("a",n,e,t),$("b",n,e,t))];case"Minimum":return[s.minimum($("a",n,e,t),$("b",n,e,t))];case"Maximum":return[s.maximum($("a",n,e,t),$("b",n,e,t))];case"Pow":return[s.pow($("a",n,e,t),$("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference($("a",n,e,t),$("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Pue=(n,e,t,s=es)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs($("x",n,e,t))];case"Acos":return[s.acos($("x",n,e,t))];case"Acosh":return[s.acosh($("x",n,e,t))];case"Asin":return[s.asin($("x",n,e,t))];case"Asinh":return[s.asinh($("x",n,e,t))];case"Atan":return[s.atan($("x",n,e,t))];case"Atan2":return[s.atan2($("x",n,e,t),$("y",n,e,t))];case"Atanh":return[s.atanh($("x",n,e,t))];case"Ceil":return[s.ceil($("x",n,e,t))];case"Complex":return[s.complex($("real",n,e,t),$("imag",n,e,t))];case"Cos":return[s.cos($("x",n,e,t))];case"Cosh":return[s.cosh($("x",n,e,t))];case"Elu":return[s.elu($("x",n,e,t))];case"Erf":return[s.erf($("x",n,e,t))];case"Exp":return[s.exp($("x",n,e,t))];case"Expm1":return[s.expm1($("x",n,e,t))];case"Floor":return[s.floor($("x",n,e,t))];case"Log":return[s.log($("x",n,e,t))];case"Log1p":return[s.log1p($("x",n,e,t))];case"Imag":return[s.imag($("x",n,e,t))];case"Neg":return[s.neg($("x",n,e,t))];case"Reciprocal":return[s.reciprocal($("x",n,e,t))];case"Real":return[s.real($("x",n,e,t))];case"Relu":return[s.relu($("x",n,e,t))];case"Round":return[s.round($("x",n,e,t))];case"Selu":return[s.selu($("x",n,e,t))];case"Sigmoid":return[s.sigmoid($("x",n,e,t))];case"Sin":return[s.sin($("x",n,e,t))];case"Sign":return[s.sign($("x",n,e,t))];case"Sinh":return[s.sinh($("x",n,e,t))];case"Softplus":return[s.softplus($("x",n,e,t))];case"Sqrt":return[s.sqrt($("x",n,e,t))];case"Square":return[s.square($("x",n,e,t))];case"Tanh":return[s.tanh($("x",n,e,t))];case"Tan":return[s.tan($("x",n,e,t))];case"ClipByValue":return[s.clipByValue($("x",n,e,t),$("clipValueMin",n,e,t),$("clipValueMax",n,e,t))];case"Relu6":return[s.relu6($("x",n,e,t))];case"Rsqrt":return[s.rsqrt(qn(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu($("x",n,e,t),$("alpha",n,e,t))];case"Prelu":return[s.prelu($("x",n,e,t),$("alpha",n,e,t))];case"IsNan":return[s.isNaN(qn(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(qn(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(qn(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Br(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){D(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];D(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function d3(n){return!(typeof n=="number"||n.some(e=>e<0))}function yf(n,e,t){let s=uC(n,t);const r=!d3(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=uC(i.shape,s)}),!d3(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function uC(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}class Bue{constructor(e,t,s,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Me(0),En(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Br(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,En(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Ys([],[0].concat(this.elementShape));const s=this.readMany(e);return Br(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),bs(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ys([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Br(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ln(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Cr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,a=[];se(()=>{t=X(t,[1,s,i]);for(let u=0;u<e.length;++u){const d=[0,u===0?0:r[u-1],0],p=[1,e[u],i];a[u]=X(ut(t,d,p),this.elementShape)}return a});const o=[];for(let u=0;u<e.length;u++)o[u]=u;this.writeMany(o,a)}}class su{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);Br(t,i.shape,"TensorList shape mismatch: "),En(i)}),this.idTensor=Me(0),this.maxNumElements=r,En(this.idTensor)}copy(){return new su([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Br(e,this.elementShape,"TensorList shape mismatch: ");const r=yf(this.elementShape,this.tensors,e);return se(()=>{const i=this.tensors.map(a=>X(a,r));return bs(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=yf(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Br(r.shape,e,"TensorList shape mismatch: "),X(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Br(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");En(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new su([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Br(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=yf(this.elementShape,this.tensors,t);return X(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Br(this.elementShape,t.shape,"TensorList shape mismatch: "),En(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Br(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=yf(this.elementShape,this.tensors,s);return e.length===0?Ys([],[0].concat(r)):se(()=>{const i=e.map(a=>X(this.tensors[a],r));return bs(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Br(this.elementShape,t,"TensorList shape mismatch: ");const s=yf(this.elementShape,this.tensors,t);return this.size()===0?Ys([],[0].concat(s)):se(()=>{const r=this.tensors.map(i=>X(i,s));return ln(r,0)})}}function Vue(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Br(r,e,"TensorList shape mismatch: ");const i=Cr(n);return new su(i,e,s)}function Uue(n,e,t,s){return new su([],n,e,s)}function jue(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new su([],t,n.dtype,s),a=Cr(n,0);return e.forEach((o,u)=>{i.setItem(o,a[u])}),i}function Wue(n,e,t){let s=0;const r=e.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),a=uC(i,t),o=s===0?0:n.size/s,u=se(()=>{const d=[];n=X(n,[1,s,o]);for(let p=0;p<e.length;++p){const y=[0,p===0?0:r[p-1],0],b=[1,e[p],o];d[p]=X(ut(n,y,b),a)}return n.dispose(),d}),h=new su([],t,n.dtype,e.length);for(let d=0;d<u.length;d++)h.setItem(d,u[d]);return h}const Gue=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=$("thenBranch",n,e,t),r=$("elseBranch",n,e,t),i=$("cond",n,e,t),a=$("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=$("body",n,e,t),r=$("cond",n,e,t),i=$("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),o=i.map(d=>d.id);let u=await a[0].data();a.forEach(d=>{!d.kept&&o.indexOf(d.id)===-1&&d.dispose()});let h=i;for(;u[0];){const d=h;h=await t.functionMap[s].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);const p=h.map(y=>y.id);d.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&p.indexOf(y.id)===-1&&y.dispose()});const m=await t.functionMap[r].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&p.indexOf(y.id)===-1&&y.dispose()})}return h}case"LoopCond":{const s=$("pred",n,e,t);return[ya(s)]}case"Switch":{const s=$("pred",n,e,t);let r=$("data",n,e,t);return r.kept||(r=ya(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>qn(r,e,t)!==void 0);if(s){const r=qn(s,e,t);return[ya(r)]}return}case"Enter":{const s=$("frameName",n,e,t),r=$("tensor",n,e,t);return t.enterFrame(s),[ya(r)]}case"Exit":{const s=$("tensor",n,e,t);return t.exitFrame(),[ya(s)]}case"NextIteration":{const s=$("tensor",n,e,t);return t.nextIteration(),[ya(s)]}case"TensorArrayV3":{const s=$("size",n,e,t),r=$("dtype",n,e,t),i=$("elementShape",n,e,t),a=$("dynamicSize",n,e,t),o=$("clearAfterRead",n,e,t),u=$("identicalElementShapes",n,e,t),h=$("name",n,e,t),d=new Bue(h,r,s,i,u,a,o);return t.addTensorArray(d),[d.idTensor,Me(1)]}case"TensorArrayWriteV3":{const s=$("tensorArrayId",n,e,t),r=$("index",n,e,t),i=$("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,i),[a.idTensor]}case"TensorArrayReadV3":{const s=$("tensorArrayId",n,e,t),r=$("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=$("tensorArrayId",n,e,t),r=$("indices",n,e,t),i=$("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=$("tensorArrayId",n,e,t),r=$("indices",n,e,t),i=$("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=$("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=$("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=$("tensorArrayId",n,e,t),r=$("tensor",n,e,t),i=$("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(i,r),[a.idTensor]}case"TensorArraySizeV3":{const s=$("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Me(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=$("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=$("tensorListId",n,e,t),r=$("index",n,e,t),i=$("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,i),[a.idTensor]}case"TensorListGetItem":{const s=$("tensorListId",n,e,t),r=$("index",n,e,t),i=$("elementShape",n,e,t),a=$("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=$("indices",n,e,t),r=$("tensor",n,e,t),i=$("elementShape",n,e,t),a=$("numElements",n,e,t),o=jue(r,s,i,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=$("elementShape",n,e,t),r=$("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const a=$(i,n,e,t),o=n.op==="TensorListReserve"?-1:a,u=Uue(s,r,a,o);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=$("tensorListId",n,e,t),r=$("indices",n,e,t),i=$("elementShape",n,e,t),a=$("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,i)]}case"TensorListStack":{const s=$("tensorListId",n,e,t),r=$("elementShape",n,e,t),i=$("elementDType",n,e,t),a=$("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,a)]}case"TensorListFromTensor":{const s=$("tensor",n,e,t),r=$("elementShape",n,e,t),i=$("elementDType",n,e,t),a=Vue(s,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=$("tensorListId",n,e,t),r=t.getTensorList(s.id),i=$("dtype",n,e,t),a=$("elementShape",n,e,t);return[r.concat(i,a)]}case"TensorListPushBack":{const s=$("tensorListId",n,e,t),r=$("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=$("tensorListId",n,e,t),r=$("elementShape",n,e,t),i=$("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=$("tensor",n,e,t),r=$("elementShape",n,e,t),i=$("lengths",n,e,t),a=Wue(s,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=$("tensorListId",n,e,t),r=t.getTensorList(s.id);return[Me(r.size(),"int32")]}case"TensorListResize":{const s=$("tensorListId",n,e,t),r=$("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function f3(n,e,t){const[s,r]=$("fusedOps",n,e,t),i=s==="biasadd",a=!i,o=r==="prelu",u=s==="fusedbatchnorm",h=$("numArgs",n,e,t);if(i){if(o&&h!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&h!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=$("strides",n,e,t),p=a0(n,e,t),m=$("dataFormat",n,e,t).toUpperCase(),y=$("dilations",n,e,t);let[b,x]=$("args",n,e,t);a&&(x=b,b=void 0);const w=$("leakyreluAlpha",n,e,t);return{stride:d,pad:p,dataFormat:m,dilations:y,biasArg:b,preluArg:x,activationFunc:r,leakyreluAlpha:w}}const Hue=(n,e,t,s=es)=>{switch(n.op){case"Conv1D":{const r=$("stride",n,e,t),i=$("pad",n,e,t),a=$("dataFormat",n,e,t).toUpperCase(),o=$("dilation",n,e,t);return[s.conv1d($("x",n,e,t),$("filter",n,e,t),r,i,a,o)]}case"Conv2D":{const r=$("strides",n,e,t),i=a0(n,e,t),a=$("dataFormat",n,e,t).toUpperCase(),o=$("dilations",n,e,t);return[s.conv2d($("x",n,e,t),$("filter",n,e,t),[r[1],r[2]],i,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:u,preluArg:h,activationFunc:d,leakyreluAlpha:p}=f3(n,e,t);return[s.fused.conv2d({x:$("x",n,e,t),filter:$("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:h,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:u,preluArg:h,activationFunc:d,leakyreluAlpha:p}=f3(n,e,t);return[s.fused.depthwiseConv2d({x:$("x",n,e,t),filter:$("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:h,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=$("outputShape",n,e,t),i=$("strides",n,e,t),a=a0(n,e,t);return[s.conv2dTranspose($("x",n,e,t),$("filter",n,e,t),r,[i[1],i[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=$("strides",n,e,t),i=a0(n,e,t),a=$("dilations",n,e,t),o=$("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d($("input",n,e,t),$("filter",n,e,t),[r[1],r[2]],i,o,[a[1],a[2]])]}case"Conv3D":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("dataFormat",n,e,t).toUpperCase(),o=$("dilations",n,e,t);return[s.conv3d($("x",n,e,t),$("filter",n,e,t),[r[1],r[2],r[3]],i,a,[o[1],o[2],o[3]])]}case"AvgPool":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("kernelSize",n,e,t);return[s.avgPool($("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("kernelSize",n,e,t);return[s.maxPool($("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("kernelSize",n,e,t),o=$("includeBatchInIndex",n,e,t),{result:u,indexes:h}=s.maxPoolWithArgmax($("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i,o);return[u,h]}case"AvgPool3D":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("kernelSize",n,e,t);return[s.avgPool3d($("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("kernelSize",n,e,t);return[s.maxPool3d($("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=$("strides",n,e,t),i=$("pad",n,e,t),a=$("dilations",n,e,t),o=r[1],u=r[2],h=a[1],d=a[2];return[s.dilation2d($("x",n,e,t),$("filter",n,e,t),[o,u],i,[h,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const que=(n,e,t,s=es)=>{switch(n.op){case"Fill":{const r=$("shape",n,e,t),i=$("dtype",n,e,t),a=$("value",n,e,t);return[s.fill(r,a,i)]}case"LinSpace":{const r=$("start",n,e,t),i=$("stop",n,e,t),a=$("num",n,e,t);return[s.linspace(r,i,a)]}case"Multinomial":{const r=$("logits",n,e,t),i=$("numSamples",n,e,t),a=$("seed",n,e,t);return[s.multinomial(r,i,a)]}case"OneHot":{const r=$("indices",n,e,t),i=$("depth",n,e,t),a=$("onValue",n,e,t),o=$("offValue",n,e,t),u=$("dtype",n,e,t);return[s.oneHot(r,i,a,o,u)]}case"Ones":return[s.ones($("shape",n,e,t),$("dtype",n,e,t))];case"OnesLike":return[s.onesLike($("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal($("shape",n,e,t),$("dtype",n,e,t),$("seed",n,e,t))];case"RandomUniform":return[s.randomUniform($("shape",n,e,t),$("minval",n,e,t),$("maxval",n,e,t),$("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt($("shape",n,e,t),$("minval",n,e,t),$("maxval",n,e,t),$("seed",n,e,t))];case"Range":{const r=$("start",n,e,t),i=$("stop",n,e,t),a=$("step",n,e,t);return[s.range(r,i,a,$("dtype",n,e,t))]}case"TruncatedNormal":{const r=$("shape",n,e,t),i=$("mean",n,e,t),a=$("stdDev",n,e,t),o=$("seed",n,e,t);return[s.truncatedNormal(r,i,a,$("dtype",n,e,t),o)]}case"Zeros":return[s.zeros($("shape",n,e,t),$("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function PS(n,e,t){const s=$("boxes",n,e,t),r=$("scores",n,e,t),i=$("maxOutputSize",n,e,t),a=$("iouThreshold",n,e,t),o=$("scoreThreshold",n,e,t),u=$("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:u}}const Kue=async(n,e,t,s,r=es)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h,softNmsSigma:d}=PS(n,e,t),p=await r.image.nonMaxSuppressionWithScoreAsync(i,a,o,u,h,d);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h}=PS(n,e,t),d=$("padToMaxOutputSize",n,e,t),p=await r.image.nonMaxSuppressionPaddedAsync(i,a,o,u,h,d);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:u,scoreThreshold:h}=PS(n,e,t);return[await r.image.nonMaxSuppressionAsync(i,a,o,u,h)]}case"Where":{const i=r.cast($("condition",n,e,t),"bool"),a=[await r.whereAsync(i)];return i.dispose(),a}case"ListDiff":return r.setdiff1dAsync($("x",n,e,t),$("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Xue=(n,e,t,s=es)=>{switch(n.op){case"LowerBound":{const r=$("sortedSequence",n,e,t),i=$("values",n,e,t);return[s.lowerBound(r,i)]}case"TopKV2":{const r=$("x",n,e,t),i=$("k",n,e,t),a=$("sorted",n,e,t),o=s.topk(r,i,a);return[o.values,o.indices]}case"UpperBound":{const r=$("sortedSequence",n,e,t),i=$("values",n,e,t);return[s.upperBound(r,i)]}case"Unique":{const r=$("x",n,e,t),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=$("x",n,e,t),i=$("axis",n,e,t),a=s.unique(r,i);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Yue=(n,e,t,s=es)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=$("default",n,e,t);return[qn(n.name,e,t)||r];case"Placeholder":return[qn(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=$("x",n,e,t);return[ya(d)]}case"IdentityN":return $("x",n,e,t).map(d=>ya(d));case"Snapshot":const i=$("x",n,e,t);return[ya(i)];case"Shape":return[s.tensor1d($("x",n,e,t).shape,"int32")];case"ShapeN":return $("x",n,e,t).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar($("x",n,e,t).size,"int32")];case"Rank":return[s.scalar($("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=$("x",n,e,t),o=$("data",n,e,t),u=$("message",n,e,t),h=$("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,h));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class Jue{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Me(0),this.tensorMap=new Map,En(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Me(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),se(()=>{const r=Cr(t),i=s.length,a=r.length;D(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){const u=s[o],h=r[o];En(h),this.tensorMap.set(u,h)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return se(()=>{const r=[];for(let i=0;i<s.length;i++){const a=s[i],o=this.findWithDefault(a,t);r.push(o)}return bs(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const Zue=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=$("keyDType",n,e,t),a=$("valueDType",n,e,t),o=new Jue(i,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=$("tableHandle",n,e,t,s),i=$("keys",n,e,t),a=$("values",n,e,t);return[await s.getHashTableById(r.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=$("tableHandle",n,e,t,s),i=$("keys",n,e,t),a=$("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=$("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Que=(n,e,t,s=es)=>{switch(n.op){case"ResizeBilinear":{const r=$("images",n,e,t),i=$("size",n,e,t),a=$("alignCorners",n,e,t),o=$("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[i[0],i[1]],a,o)]}case"ResizeNearestNeighbor":{const r=$("images",n,e,t),i=$("size",n,e,t),a=$("alignCorners",n,e,t),o=$("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],a,o)]}case"CropAndResize":{const r=$("image",n,e,t),i=$("boxes",n,e,t),a=$("boxInd",n,e,t),o=$("cropSize",n,e,t),u=$("method",n,e,t),h=$("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,i,a,o,u,h)]}case"ImageProjectiveTransformV3":{const r=$("images",n,e,t),i=$("transforms",n,e,t),a=$("outputShape",n,e,t),o=$("fillValue",n,e,t),u=$("interpolation",n,e,t),h=$("fillMode",n,e,t);return[s.image.transform(r,i,u.toLowerCase(),h.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const ece=(n,e,t,s=es)=>{switch(n.op){case"Equal":return[s.equal($("a",n,e,t),$("b",n,e,t))];case"NotEqual":return[s.notEqual($("a",n,e,t),$("b",n,e,t))];case"Greater":return[s.greater($("a",n,e,t),$("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual($("a",n,e,t),$("b",n,e,t))];case"Less":return[s.less($("a",n,e,t),$("b",n,e,t))];case"LessEqual":return[s.lessEqual($("a",n,e,t),$("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd($("a",n,e,t),$("b",n,e,t))];case"LogicalNot":return[s.logicalNot($("a",n,e,t))];case"LogicalOr":return[s.logicalOr($("a",n,e,t),$("b",n,e,t))];case"Select":case"SelectV2":return[s.where($("condition",n,e,t),$("a",n,e,t),$("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd($("a",n,e,t),$("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const tce=(n,e,t,s=es)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul($("a",n,e,t),$("b",n,e,t),$("transposeA",n,e,t),$("transposeB",n,e,t))];case"Einsum":return[s.einsum($("equation",n,e,t),...$("tensors",n,e,t))];case"Transpose":return[s.transpose($("x",n,e,t),$("perm",n,e,t))];case"_FusedMatMul":const[r,i]=$("fusedOps",n,e,t),a=r==="biasadd",o=i==="prelu",u=$("numArgs",n,e,t),h=$("leakyreluAlpha",n,e,t);if(a){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,p]=$("args",n,e,t);return[s.fused.matMul({a:$("a",n,e,t),b:$("b",n,e,t),transposeA:$("transposeA",n,e,t),transposeB:$("transposeB",n,e,t),bias:d,activation:i,preluActivationWeights:p,leakyreluAlpha:h})];case"MatrixBandPart":return[s.linalg.bandPart($("a",n,e,t),$("numLower",n,e,t),$("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const nce=(n,e,t,s=es)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm($("x",n,e,t),$("axis",n,e,t),$("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm($("x",n,e,t),$("mean",n,e,t),$("variance",n,e,t),$("offset",n,e,t),$("scale",n,e,t),$("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm($("x",n,e,t),$("mean",n,e,t),$("variance",n,e,t),$("offset",n,e,t),$("scale",n,e,t),$("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization($("x",n,e,t),$("radius",n,e,t),$("bias",n,e,t),$("alpha",n,e,t),$("beta",n,e,t))];case"Softmax":return[s.softmax($("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const sce=(n,e,t,s=es)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather($("paramsNestedSplits",n,e,t),$("paramsDenseValues",n,e,t),$("indices",n,e,t),$("outputRaggedRank",n,e,t));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange($("starts",n,e,t),$("limits",n,e,t),$("splits",n,e,t));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor($("shape",n,e,t),$("values",n,e,t),$("defaultValue",n,e,t),$("rowPartitionTensors",n,e,t),$("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const rce=(n,e,t,s=es)=>{switch(n.op){case"Max":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.max($("x",n,e,t),o,u)]}case"Mean":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.mean($("x",n,e,t),o,u)]}case"Min":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.min($("x",n,e,t),o,u)]}case"Sum":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.sum($("x",n,e,t),o,u)]}case"All":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.all($("x",n,e,t),o,u)]}case"Any":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.any($("x",n,e,t),o,u)]}case"ArgMax":{const o=$("axis",n,e,t);return[s.argMax($("x",n,e,t),o)]}case"ArgMin":{const o=$("axis",n,e,t);return[s.argMin($("x",n,e,t),o)]}case"Prod":{const o=$("axis",n,e,t),u=$("keepDims",n,e,t);return[s.prod($("x",n,e,t),o,u)]}case"Cumprod":{const o=$("axis",n,e,t),u=$("exclusive",n,e,t),h=$("reverse",n,e,t);return[s.cumprod($("x",n,e,t),o,u,h)]}case"Cumsum":{const o=$("axis",n,e,t),u=$("exclusive",n,e,t),h=$("reverse",n,e,t);return[s.cumsum($("x",n,e,t),o,u,h)]}case"Bincount":const r=$("x",n,e,t),i=$("weights",n,e,t),a=$("size",n,e,t);return[s.bincount(r,i,a)];case"DenseBincount":{const o=$("x",n,e,t),u=$("weights",n,e,t),h=$("size",n,e,t),d=$("binaryOutput",n,e,t);return[s.denseBincount(o,u,h,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const ice=(n,e,t,s=es)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=$("n",n,e,t),i=$("axis",n,e,t);let a=$("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,i)]}case"Gather":{const r=$("x",n,e,t),i=$("indices",n,e,t);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=$("axis",n,e,t),i=$("batchDims",n,e,t),a=$("x",n,e,t),o=$("indices",n,e,t);return[s.gather(a,s.cast(o,"int32"),r,i)]}case"Reverse":{const r=$("dims",n,e,t),i=[];for(let o=0;o<r.length;o++)r[o]&&i.push(o);const a=$("x",n,e,t);return[s.reverse(a,i)]}case"ReverseV2":{const r=$("axis",n,e,t),i=$("x",n,e,t);return[s.reverse(i,r)]}case"Slice":{const r=$("begin",n,e,t),i=$("size",n,e,t);return[s.slice($("x",n,e,t),r,i)]}case"StridedSlice":{const r=$("begin",n,e,t),i=$("end",n,e,t),a=$("strides",n,e,t),o=$("beginMask",n,e,t),u=$("endMask",n,e,t),h=$("ellipsisMask",n,e,t),d=$("newAxisMask",n,e,t),p=$("shrinkAxisMask",n,e,t),m=$("x",n,e,t);return[s.stridedSlice(m,r,i,a,o,u,h,d,p)]}case"Pack":return se(()=>{const r=$("axis",n,e,t),i=$("tensors",n,e,t),a=i[0].shape,o=s.squeeze(i[0]).shape,u=i.map(h=>{const d=it(h.shape,a);if(!d&&!it(s.squeeze(h).shape,o))throw new Error("the input tensors shape does not match");return d?h:s.reshape(h,a)});return[s.stack(u,r)]});case"Unpack":{const r=$("axis",n,e,t),i=$("tensor",n,e,t);return s.unstack(i,r)}case"Tile":{const r=$("reps",n,e,t);return[s.tile($("x",n,e,t),r)]}case"Split":case"SplitV":{const r=$("axis",n,e,t),i=$("numOrSizeSplits",n,e,t),a=$("x",n,e,t);return s.split(a,i,r)}case"ScatterNd":{const r=$("indices",n,e,t),i=$("values",n,e,t),a=$("shape",n,e,t);return[s.scatterND(r,i,a)]}case"GatherNd":{const r=$("x",n,e,t),i=$("indices",n,e,t);return[s.gatherND(r,i)]}case"SparseToDense":{const r=$("sparseIndices",n,e,t),i=$("outputShape",n,e,t),a=$("sparseValues",n,e,t),o=$("defaultValue",n,e,t);return[s.sparseToDense(r,a,i,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}case"TensorScatterUpdate":{const r=$("indices",n,e,t),i=$("values",n,e,t),a=$("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const ace=(n,e,t,s=es)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows($("indices",n,e,t),$("values",n,e,t),$("denseShape",n,e,t),$("defaultValue",n,e,t));return[r,i,a,o]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape($("inputIndices",n,e,t),$("inputShape",n,e,t),$("newShape",n,e,t));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean($("data",n,e,t),$("indices",n,e,t),$("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum($("data",n,e,t),$("indices",n,e,t),$("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const oce=(n,e,t,s=es)=>{switch(n.op){case"FFT":return[s.fft($("x",n,e,t))];case"IFFT":return[s.ifft($("x",n,e,t))];case"RFFT":return[s.rfft($("x",n,e,t))];case"IRFFT":return[s.irfft($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const lce=(n,e,t,s=es)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace($("input",n,e,t),$("pattern",n,e,t),$("rewrite",n,e,t),$("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams($("data",n,e,t),$("dataSplits",n,e,t),$("separator",n,e,t),$("nGramWidths",n,e,t),$("leftPad",n,e,t),$("rightPad",n,e,t),$("padWidth",n,e,t),$("preserveShortSequences",n,e,t));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:a}=s.string.stringSplit($("input",n,e,t),$("delimiter",n,e,t),$("skipEmpty",n,e,t));return[r,i,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast($("input",n,e,t),$("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const uce=(n,e,t,s=es)=>{switch(n.op){case"Cast":return[s.cast($("x",n,e,t),$("dtype",n,e,t))];case"ExpandDims":{const r=$("axis",n,e,t);return[s.expandDims($("x",n,e,t),r)]}case"Squeeze":{const r=$("axis",n,e,t);return[s.squeeze($("x",n,e,t),r)]}case"Reshape":return[s.reshape($("x",n,e,t),$("shape",n,e,t))];case"EnsureShape":return[s.ensureShape($("x",n,e,t),$("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad($("x",n,e,t),$("padding",n,e,t),$("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad($("x",n,e,t),$("padding",n,e,t),$("constantValue",n,e,t))];case"SpaceToBatchND":{const r=$("blockShape",n,e,t),i=$("paddings",n,e,t);return[s.spaceToBatchND($("x",n,e,t),r,i)]}case"BatchToSpaceND":{const r=$("blockShape",n,e,t),i=$("crops",n,e,t);return[s.batchToSpaceND($("x",n,e,t),r,i)]}case"DepthToSpace":{const r=$("blockSize",n,e,t),i=$("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace($("x",n,e,t),r,i)]}case"BroadcastTo":return[s.broadcastTo($("x",n,e,t),$("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs($("s0",n,e,t),$("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function p3(n,e,t,s,r=se){const i=((a,o,u)=>{switch(a.category){case"arithmetic":return r(()=>zue(a,o,u));case"basic_math":return r(()=>Pue(a,o,u));case"control":return Gue(a,o,u);case"convolution":return r(()=>Hue(a,o,u));case"creation":return r(()=>que(a,o,u));case"dynamic":return Kue(a,o,u);case"evaluation":return r(()=>Xue(a,o,u));case"image":return r(()=>Que(a,o,u));case"graph":return r(()=>Yue(a,o,u));case"logical":return r(()=>ece(a,o,u));case"matrices":return r(()=>tce(a,o,u));case"normalization":return r(()=>nce(a,o,u));case"ragged":return r(()=>sce(a,o,u));case"reduction":return r(()=>rce(a,o,u));case"slice_join":return r(()=>ice(a,o,u));case"sparse":return r(()=>ace(a,o,u));case"spectral":return r(()=>oce(a,o,u));case"string":return r(()=>lce(a,o,u));case"transformation":return r(()=>uce(a,o,u));case"hash_table":return Zue(a,o,u,s);case"custom":const h=QB(a.op);if(h&&h.customExecutor)return h.customExecutor(new Mue(a,o,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Ta(i)?i.then(a=>[].concat(a)):[].concat(i)}class m3{constructor(e={},t={},s={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function g3(n,e,t,s){const r=new Set,i=[];let a=null,o=null;const u=new Set,h=new Set(Object.keys(n).map(m=>Hs(m)[0]));s=s||[];const d=new Set(s.map(m=>Hs(m.name)[0])),p=[...e];for(;p.length>0;){const m=p.pop();if(($l(m)||yce(m)||bce(m))&&a==null&&(a=m,o=a.children.map(y=>y.name).filter(y=>r.has(y))),r.add(m.name),t[m.name]==null&&!h.has(m.name)&&!d.has(m.name)){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(y=>{u.has(y.name)||(u.add(y.name),p.push(y))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:a,syncInputs:o}}function cce(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(w=>Hs(w)[0]).map(w=>n.nodes[w]),i=n.initNodes||[],a=w=>t.has(typeof w=="string"?w:w.name);function o(w){return[...new Map(w.map(S=>[S.name,S])).values()]}const u=o([...r,...n.weights,...i]).filter(a),h=o([...u,...Object.values(n.nodes)]).filter(a),d=new Map(h.map(w=>[w.name,w])),p={};for(const w of h){p[w.name]=p[w.name]||0;for(const S of w.children)a(S)||(p[S.name]=Number.POSITIVE_INFINITY),p[S.name]=(p[S.name]||0)+1}const m=Object.entries(p).filter(([,w])=>w===0).map(([w])=>w),y=[...m];for(;m.length>0;){const w=m.pop(),S=d.get(w);for(const C of S.children.filter(a))--p[C.name]===0&&(y.push(C.name),m.push(C.name))}const b=y.map(w=>d.get(w)),x=hce(b,u);return dce(x,u),x}function hce(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),o=t.get(a);for(const u of o.children)!t.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(a=>r.has(a.name))}class Py extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function dce(n,e){const t=new Map(n.map((o,u)=>[o.name,u])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),i=new Set(n.map(o=>o.name)),a=o=>i.has(typeof o=="string"?o:o.name);for(const o of n){for(const u of o.children.filter(a)){if(!t.has(u.name))throw new Py(`Child ${u.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(u.name))throw new Py(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(const u of o.inputs){if(!t.has(u.name))throw new Py(`Input ${u.name} of node ${o.name} is unreachable.`);if(t.get(u.name)>t.get(o.name))throw new Py(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function fce(n){const e=new Map(n.map((o,u)=>[o.name,u])),t=Number.MAX_SAFE_INTEGER,s=n.map((o,u)=>$l(o)?t:u),r=o=>{const u=s[e.get(o.name)];return u??-1},i=n.map((o,u)=>o.children.map(r).reduce((h,d)=>Math.max(h,d),s[u])),a=new Map;for(let o=0;o<n.length;++o){const u=i[o];if(u===t)continue;const h=n[o],d=n[u];a.has(d.name)||a.set(d.name,[]),a.get(d.name).push(h)}return a}const pce=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),mce=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),gce=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function $l(n){return pce.has(n.op)}function yce(n){return mce.has(n.op)}function bce(n){return gce.has(n.op)}class W0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new W0(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=g3(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:a}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const h=t.map(p=>p.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=cce(this.graph,s),u=fce(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return En(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(m=>this.graph.nodes[Hs(m)[0]]),i=t.map(m=>Hs(m)[0]),a=new Set(i);let o=i.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);const u=this.getCompilationKey(r,o);let h=this.compiledMap.get(u);h==null&&(h=this.compile(e,o),this.compiledMap.set(u,h));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const d={},p={};return se(()=>{const m=new m3(this.weightMap,d,p,this.functionExecutorMap,this.parseNodeNameCache),y=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(S=>{const[C,N]=Hs(S,m),k=[];k[N]=e[S],y[C]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[C]=this.cloneTensorList(k))});const b=this.getFrozenTensorIds(y),{orderedNodes:x,nodeLiveUntilMap:w}=h;for(const S of x){if(y[S.name])continue;const C=p3(S,y,m,this._resourceManager);if(Ta(C))throw new Error(`The execution of the op '${S.op}' returned a promise. Please use model.executeAsync() instead.`);y[S.name]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[S.name]=this.cloneTensorList(C)),this.checkTensorForDisposalWithNodeLiveUntilInfo(S,y,m,b,a,w.get(S.name))}return this.parent==null&&m.dispose(b),t.map(S=>qn(S,y,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,a,o){if(!($l(t)||a.has(e))){for(const u of s[e])u!=null&&(o[u.id]=(o[u.id]||0)+t.children.length);for(const u of t.inputs){if($l(u))continue;const h=u3(u.name,s,r);if(h!=null)for(const d of h){if(!d||d.kept||i.has(d.id))continue;const p=o[d.id];p===1?(d.dispose(),delete o[d.id]):p!=null&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,i,a){function o(u){return $l(u)||i.has(u.name)}if(!($l(e)||a==null))for(const u of a){if(o(u))continue;const h=u3(u.name,t,s);for(const d of h)!d||d.kept||r.has(d.id)||d.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const a=new m3(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,s),u=t.map(m=>qn(m,o,a)),h=u.map(m=>m.id),d=Object.keys(e).map(m=>e[m].id),p=new Set([...h,...d,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(y=>{y&&!y.isDisposed&&!p.has(y.id)&&y.dispose()})}),this.parent==null&&a.dispose(p),u}async executeFunctionAsync(e,t,s){const r=e.reduce((i,a,o)=>(i[this.inputs[o].name]=a,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),a=i.map(k=>this.graph.nodes[Hs(k)[0]]),o=s.map(k=>Hs(k)[0]),u=new Set(o);let h=o.map(k=>this.graph.nodes[k]);h.length===0&&(h=this._outputs);const{usedNodes:d,missingInputs:p,dynamicNode:m,syncInputs:y}=g3(e,h,this.weightMap,this._initNodes),b=[...a,...this.graph.weights,...this._initNodes||[]].map(k=>({node:k,contexts:t.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(k=>{const[E,_]=Hs(k),R=[];R[_]=e[k],x[E]=R});const w={},S=this.getFrozenTensorIds(x),C={};for(;b.length>0;){const k=this.processStack(a,b,t,x,C,S,u,w,d);await Promise.all(k)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=h.filter(k=>!$l(k)&&!qn(k.name,x,t)).map(k=>k.name);if(N.length>0){let k="";throw m!=null&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${y}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${i}]. Consider providing the following inputs: [${p}]. ${k}`)}return x}processStack(e,t,s,r,i,a,o,u,h){const d=[];for(;t.length>0;){const p=t.pop();s.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&$("isConstant",p.node,r,s)&&([m]=ga(p.node.name,s)),r[p.node.name]==null){const y=p3(p.node,r,s,this._resourceManager);m||([m]=ga(p.node.name,s));const b=s.currentContext;Ta(y)?d.push(y.then(x=>(r[m]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(x)),s.currentContext=b,this.checkTensorForDisposal(m,p.node,r,s,a,o,u),this.processChildNodes(p.node,t,s,r,i,h),x))):(r[m]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(y)),this.checkTensorForDisposal(m,p.node,r,s,a,o,u),this.processChildNodes(p.node,t,s,r,i,h))}else this.processChildNodes(p.node,t,s,r,i,h)}return d}processChildNodes(e,t,s,r,i,a){e.children.forEach(o=>{const[u]=ga(o.name,s);i[u]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(h=>!!qn(h,r,s))&&(i[u]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(h=>!!qn(h,r,s))&&(i[u]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Hs(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const a=i.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((u,h)=>a[h]===-1||a[h]===u);D(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&D(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const i in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];a!=null?r[a.name]=e[i]:r[i]=e[i]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Hs(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Hs(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class xce{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const wce="?tfjs-format=file",vce="model.json";class zE{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=LN){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new xce}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ta(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await $M(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new W0(c3.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=c3.Instance.transformGraph(e.modelInitializer);this.initializer=new W0(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof mt?[e]:e,s={};return t.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof mt)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const a in i){const o=i[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,a)=>{var o,u,h;const d=(h=(u=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||u===void 0?void 0:u[a])===null||h===void 0?void 0:h.resourceId;return d!=null?i[a]=this.resourceIdToCapturedInput[d]:i[a]=e[r++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const i=s[r],a=t[i];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ke(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Sce(n,e={},t=LN){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=Cce(n));const s=new zE(n,e,t);return await s.load(),s}function Tce(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,r]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const i=A0(s.weightsManifest),a=v2(s,i,r);e=D0(a)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=D0(n);else throw new Error("Unknown model format");const t=new zE(e);return t.load(),t}function Cce(n){return n.endsWith("/")||(n=n+"/"),`${n}${vce}${wce}`}const nV="4.22.0";function Nce(n,e){return G0(n,e)}function G0(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(qc(n)){const i=Array.isArray(n)?[]:{};s.add(n);for(const a in n){const o=n[a],u=G0(o,e,t,s);i[a]=u}return s.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function kce(n,e=rV){return sV(n,e)}function sV(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(qc(s)){const i=Array.isArray(s)?[]:{};t.add(s);for(const a in s){const o=n.map(h=>h[a]),u=sV(o,e,t);i[a]=u}return t.delete(s),i}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function rV(n){return n===null?null:qc(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function iV(n,e){const t=new Map;G0(n,e,t);for(const r of Array.from(t.keys())){const i=t.get(r);if(Ta(i)){const a=await i;t.set(r,a)}}return G0(n,e,t)}function qc(n){let e=!1;if(ie().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof mt)&&!(n instanceof Promise)&&!e)}function Ece(n){return n==null||$ce(n)||Array.isArray(n)||typeof n=="object"&&n instanceof mt||kn(n)}function $ce(n){return n===null||typeof n!="object"&&typeof n!="function"}function Ice(n){return Nce(n,_ce)}function _ce(n){return n instanceof mt?{value:n.clone(),recurse:!1}:qc(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class aV{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}class $w extends aV{constructor(){super($w.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let r=0;r<s;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}$w.INITIAL_CAPACITY=32;function oV(n){return new Dce(n)}function PE(n){return new Oce(n)}function Ace(n,e){return new lV(n,e)}function Rce(n,e=xo.FAIL){return new jce(n,e)}class Bn{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new Vce(this,e)}filter(e){return new Pce(this,e)}map(e){return new Bce(this,e)}mapAsync(e){return new y3(this,e)}serialMapAsync(e){return new y3(this,e).serial()}flatmap(e){return new Uce(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new zce(this,e,t)}columnMajorBatch(e,t=!0,s=rV){return this.rowMajorBatch(e,t).map(i=>kce(i,s))}concatenate(e,t){return new lV(oV([this,e]),t)}take(e){return e<0||e==null?this:new Mce(this,e)}skip(e){return e<0||e==null?this:new Lce(this,e)}prefetch(e){return new uV(this,e)}shuffle(e,t){return new Wce(this,e,t)}serial(){return new Fce(this)}}class Dce extends Bn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Ice(e),done:!1}}}class Oce extends Bn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class Fce extends Bn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class Lce extends Bn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Ke(e.value)}return this.upstream.next()}}class Mce extends Bn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class zce extends Bn{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class Pce extends Bn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ke(e.value)}}}class Bce extends Bn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Na(e.value),s=this.transform(e.value),r=Na(s);for(const i of t)wx(i,r)||i.dispose();return{value:s,done:!1}}}class Vce extends Bn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class y3 extends Bn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Na(e.value),s=await this.transform(e.value),r=Na(s);for(const i of t)wx(i,r)||i.dispose();return{value:s,done:!1}}}class BE extends Bn{constructor(){super(),this.outputQueue=new $w,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Uce extends BE{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Na(e.value),s=this.transform(e.value),r=Na(s);this.outputQueue.pushAll(s);for(const i of t)wx(i,r)||i.dispose();return!0}}class lV extends Bn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var xo;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(xo||(xo={}));class jce extends Bn{constructor(e,t=xo.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function r(a){return a instanceof Bn?{value:a.next().then(u=>(t++,u.done&&s++,u.value)),recurse:!1}:{value:null,recurse:!0}}const i=await iV(this.iterators,r);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case xo.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case xo.SHORTEST:return{value:null,done:!0};case xo.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class uV extends Bn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new aV(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Wce extends uV{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=td.alea(s||Gn().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}class ld{constructor(){this.size=null}batch(e,t=!0){const s=this;D(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Gs(async()=>(await s.iterator()).columnMajorBatch(e,t,qce),r)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,Gs(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,Gs(async()=>(await t.iterator()).filter(r=>se(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Gs(async()=>(await t.iterator()).map(s=>se(()=>e(s))),this.size)}mapAsync(e){const t=this;return Gs(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Gs(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,Gs(async()=>{const r=PE(async()=>({value:await t.iterator(),done:!1}));return Ace(r.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,Gs(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=td.alea(t||Gn().toString());return Gs(async()=>{let a=i.int32();return s&&(a+=i.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,Gs(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}ld.MAX_BUFFER_SIZE=1e4;function Gs(n,e=null){return new class extends ld{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function Gce(n){return Gs(async()=>oV(n),n.length)}function Hce(n){if(!qc(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return Gs(async()=>{const t=await iV(n,s=>{if(s instanceof ld)return{value:s.iterator(),recurse:!1};if(qc(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Rce(t,xo.SHORTEST)},e)}function qce(n){if(n===null)return null;const e=n[0];return Ece(e)?{value:Kce(n),recurse:!1}:{value:null,recurse:!0}}function Kce(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof mt?bs(n):Ys(n)}class cV extends ld{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}const By='"',bf=Symbol("out"),b3=Symbol("field"),Vy=Symbol("quote"),BS=Symbol("quoteafterquote"),x3=Symbol("quoteinquote");class hV extends ld{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&D(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,i)=>(r[i]=r[i]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(D(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new cV(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(D(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let i=0;i<this.fullColumnNames.length;i++){const a=this.fullColumnNames[i],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){const u=t[i];let h=null;if(u==="")if(o&&o.default!==void 0)h=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);h=void 0}else{const d=Number(u);if(isNaN(d))o&&o.dtype==="bool"?h=this.getBoolean(u):h=u;else if(!o||!o.dtype)h=d;else switch(o.dtype){case"float32":h=d;break;case"int32":h=Math.floor(d);break;case"bool":h=this.getBoolean(u);break;default:h=d}}o&&o.isLabel?r[a]=h:s[a]=h}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const i=e.length;let a=bf;for(let o=0;o<i;o++)switch(a){case bf:switch(e.charAt(o)){case By:r=o+1,a=Vy;break;case this.delimiter:if(r=o+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=bf;break;default:a=b3,r=o;break}break;case b3:e.charAt(o)===this.delimiter&&(s.push(e.substring(r,o)),a=bf,r=o+1);break;case Vy:e.charAt(o)===By&&(a=BS);break;case BS:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(r,o-1)),a=bf,r=o+1;break;case By:a=Vy;break;default:a=x3;break}break;case x3:e.charAt(o)===By&&(a=Vy);break}if(a===BS?s.push(e.substring(r,i-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class VE extends Bn{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ie().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new VE(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(i),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,i)=>s.set(r,i*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(he(t));return s.set(e,s.length-e.length),Ys(s,t)}}class UE extends Bn{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Xn([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,i=(1-s)/2,a=(1-r)/2,o=i+s,u=r+a;this.cropBox=So([a,i,u,o],[1,4])}else this.cropBox=So([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ie().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new UE(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&D(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=eP(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return se(()=>{const t=Hn(Ne(e,"float32"),0);let s;s=Ur.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return X(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class dV{}class fV extends Bn{split(e){return new Xce(this,e)}}class Xce extends fV{constructor(e,t){super(),this.upstream=e,this.impl=new Yce(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Yce extends BE{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}class Jce extends Bn{decodeUTF8(){return new Zce(this)}}class Zce extends fV{constructor(e){super(),this.upstream=e,this.impl=new Qce(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Qce extends BE{constructor(e){if(super(),this.upstream=e,ie().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return ie().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}class pV extends Jce{constructor(e,t={}){super(),this.file=e,this.options=t,D(e instanceof Uint8Array||(ie().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const i=new FileReader;i.onload=o=>{let u=i.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(u)},i.onabort=o=>s(new Error("Aborted")),i.onerror=o=>s(new Error(o.type));const a=this.file.slice(this.offset,r);i.readAsArrayBuffer(a)}this.offset=r}),done:!1}}}async function ehe(n,e={},t){let s,r;typeof n=="string"?s=n:(s=n.url,r=the(n));const i=await yM(s,r);if(i.ok){const a=new Uint8Array(await i.arrayBuffer());return new pV(a,e)}else throw new Error(i.statusText)}const the=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function mV(n){return typeof n=="string"&&n.slice(0,7)==="file://"}class gV extends dV{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(mV(this.input)&&ie().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new pV(this.input,this.options)}}class yV extends dV{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return mV(this.url)?new gV(this.url,this.fileOptions).iterator():ehe(this.url,this.fileOptions)}}function nhe(n,e={}){return new hV(new yV(n),e)}function she(n){const e=PE(n);return Gs(async()=>e)}function rhe(n){return Gs(async()=>{const e=await n();return PE(()=>e.next())})}async function ihe(n,e){return UE.create(n,e)}async function ahe(n){return VE.create(n)}const bV="4.22.0";const ohe=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:hV,Dataset:ld,FileDataSource:gV,TextLineDataset:cV,URLDataSource:yV,array:Gce,csv:nhe,func:she,generator:rhe,microphone:ahe,version_data:bV,webcam:ihe,zip:Hce},Symbol.toStringTag,{value:"Module"}));function De(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&D(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const lhe=qx;class tg extends cb{nextDataId(){return tg.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new a2(this,oi())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ie().get("IS_NODE")&&gr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ri(s[0])){const i=s.map(a=>Li(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return $a(r,i)}return iM(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ca(r));return Qe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,t)}makeOutput(e,t,s){return oi().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Gn();return e(),{kernelMs:Gn()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){De([e],"where");const t=this.readSync(e.dataId);return lhe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}tg.nextDataId=0;function xV(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const uhe=n=>{const{x:e}=n.inputs,t=n.backend;De(e,"abs");let s=new Float32Array(he(e.shape));const r=t.data.get(e.dataId).values;return s=xV(r),t.makeOutput(s,e.shape,e.dtype)},che={kernelName:wp,backendName:"cpu",kernelFunc:uhe};function dn(n){return(e,t,s,r,i)=>{const a=Xe(e,t),o=a.length,u=ze(a),h=he(a),d=zn(i,h),p=e.length,m=t.length,y=ze(e),b=ze(t),x=Jl(e,a),w=Jl(t,a);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=n(s[S%s.length],r[S%r.length]);else for(let S=0;S<d.length;++S){const C=hu(S,o,u),N=C.slice(-p);x.forEach(R=>N[R]=0);const k=hi(N,p,y),E=C.slice(-m);w.forEach(R=>E[R]=0);const _=hi(E,m,b);d[S]=n(s[k],r[_])}return[d,a]}}function Ks(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),u=t.data.get(o.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",a)},o}const hhe={kernelName:xb,backendName:"cpu",kernelFunc:Ks};function H0(n,e,t="float32"){if(t==="complex64"){const r=H0(n,e,"float32"),i=H0(n,e,"float32");return Ks({inputs:{real:r,imag:i},backend:n})}const s=Yn(he(e),t);return n.makeTensorInfo(e,t,s)}function Gi(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const dhe={kernelName:wh,backendName:"cpu",kernelFunc:Gi};function ru(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const fhe={kernelName:Zb,backendName:"cpu",kernelFunc:ru};function wV(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Po([0],t),[i,a]=dn((o,u)=>o!==u?1:0)(e,[],n,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function Mo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Gi({inputs:{x:r},backend:t});const d=H0(t,r.shape,r.dtype),p=Mo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=Ks({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){const d=ru({inputs:{input:r},backend:t}),p=Mo({inputs:{x:d},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(d),p}if(!u2(r.dtype,i)){const d=Gi({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:i}}const a=t.data.get(r.dataId).values,[o,u,h]=wV(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,u,h)}const phe={kernelName:oh,backendName:"cpu",kernelFunc:Mo};function An(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a,b:o}=r,u=i;De([a,o],n);const h=u.data.get(a.dataId).values,d=u.data.get(o.dataId).values,p=a.dtype==="string"?Ia(h):h,m=a.dtype==="string"?Ia(d):d,y=s||a.dtype,[b,x]=e(a.shape,o.shape,p,m,y);return u.makeTensorInfo(x,y,b)}:({inputs:r,backend:i})=>{const{a,b:o}=r,u=i;if(a.dtype==="complex64"||o.dtype==="complex64"){const h=Mo({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(h.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=u.data.get(p.dataId).values,b=u.data.get(m.dataId).values,x=Mo({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),w=u.data.get(x.dataId),S=w.complexTensorInfos.real,C=w.complexTensorInfos.imag,N=u.data.get(S.dataId).values,k=u.data.get(C.dataId).values,[E,_,R]=t(a.shape,o.shape,y,b,N,k),O=u.makeTensorInfo(R,"float32",E),F=u.makeTensorInfo(R,"float32",_),L=Ks({inputs:{real:O,imag:F},backend:u});return u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(x),u.disposeIntermediateTensorInfo(O),u.disposeIntermediateTensorInfo(F),L}else{const h=u.data.get(a.dataId).values,d=u.data.get(o.dataId).values,p=s||a.dtype,[m,y]=e(a.shape,o.shape,h,d,p);return u.makeTensorInfo(y,p,m)}}}function jE(n){return(e,t,s,r,i,a)=>{const o=Xe(e,t),u=he(o),h=o.length,d=ze(o),p=zn("float32",u),m=zn("float32",u),y=Jl(e,o),b=Jl(t,o),x=$a(s,r),w=$a(i,a),S=e.length,C=ze(e),N=t.length,k=ze(t);if(y.length+b.length===0)for(let E=0;E<p.length;E++){const _=E%x.length,R=E%w.length,O=n(x[_*2],x[_*2+1],w[R*2],w[R*2+1]);p[E]=O.real,m[E]=O.imag}else for(let E=0;E<p.length;E++){const _=hu(E,h,d),R=_.slice(-S);y.forEach(U=>R[U]=0);const O=hi(R,S,C),F=_.slice(-N);b.forEach(U=>F[U]=0);const L=hi(F,N,k),A=n(x[O*2],x[O*2+1],w[L*2],w[L*2+1]);p[E]=A.real,m[E]=A.imag}return[p,m,o]}}const vV=dn(((n,e)=>n+e)),mhe=jE(((n,e,t,s)=>({real:n+t,imag:e+s}))),Kc=An(du,vV,mhe),ghe={kernelName:du,backendName:"cpu",kernelFunc:Kc};function WE(n,e,t,s,r){const i=he(s),a=Yn(r,t);for(let o=0;o<n.length;o++){const u=n[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i>0?a[u]+=e[o]:a[u]+=1)}return a}function SV(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],a=Qe([r,t],e.dtype);for(let o=0;o<r;o++)for(let u=0;u<i;u++){const h=n.get(o,u);if(h<0)throw new Error("Input x must be non-negative!");h>=t||(s?a.set(1,o,h):e.size>0?a.set(a.get(o,h)+e.get(o,u),o,h):a.set(a.get(o,h)+1,o,h))}return a}const TV=dn(((n,e)=>n&e)),yhe=An($p,TV),bhe={kernelName:$p,backendName:"cpu",kernelFunc:yhe};function Ki(n){return(e,t,s)=>{const r=tn(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}function Nt(n,e,t){const s=Ki(e);return qo(n,s,t)}function qo(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;De(a,n);const o=i,u=o.data.get(a.dataId).values;let h;if(a.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");h=Ia(u)}else h=u;const d=t||a.dtype,p=e(h,d,r);return o.makeTensorInfo(a.shape,d,p)}}const CV=Ki(n=>Math.ceil(n)),xhe=qo(lh,CV),whe={kernelName:lh,backendName:"cpu",kernelFunc:xhe};function NV(n,e,t,s){const r=tn(t,he(e));if(s&&t!=="string"){let i=0;n.forEach(a=>{const o=he(a.shape);r.set(a.vals,i),i+=o})}else{let i=0;n.forEach(a=>{const o=t==="string"?Ia(a.vals):a.vals;let u=0;for(let h=0;h<a.shape[0];++h){const d=h*e[1]+i;for(let p=0;p<a.shape[1];++p)r[d+p]=o[u++]}i+=a.shape[1]})}return r}const kV=dn((n,e)=>n===e?1:0),EV=An(Mp,kV,null,"bool"),vhe={kernelName:Mp,backendName:"cpu",kernelFunc:EV};const $V=Ki(n=>Math.exp(n)),IV=qo(mh,$V,"float32"),She={kernelName:mh,backendName:"cpu",kernelFunc:IV};const _V=Ki(n=>Math.expm1(n)),The=qo(gh,_V),Che={kernelName:gh,backendName:"cpu",kernelFunc:The};const AV=Ki(n=>Math.floor(n)),Nhe=qo(yh,AV),khe={kernelName:yh,backendName:"cpu",kernelFunc:Nhe};const RV=dn((n,e)=>Math.floor(n/e)),Ehe=An(bh,RV,null,"int32"),$he={kernelName:bh,backendName:"cpu",kernelFunc:Ehe};function DV(n,e,t,s,r,i,a,o,u){const h=Qe([s,i],t);for(let d=0;d<s;d++){const p=[];let m=0;for(let y=0;y<r;y++){const b=n[d*r+y];m+=b*a[y],p.push(b)}if(m<0||m>=u/i)throw new Error(`Invalid indices: ${p} does not index into ${o}`);for(let y=0;y<i;y++)h.values[d*i+y]=e.get(...e.indexToLoc(m*i+y))}return h}function OV(n,e,t){const s=Qe(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),o=a[0],u=a[2],h=e.locToIndex([o,u]);a[2]=e.values[h];const d=n.locToIndex(a);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const FV=dn((n,e)=>n>e?1:0),Ihe=An(Vp,FV,null,"bool"),_he={kernelName:Vp,backendName:"cpu",kernelFunc:Ihe};const LV=dn((n,e)=>n>=e?1:0),Ahe=An(xh,LV,null,"bool"),Rhe={kernelName:xh,backendName:"cpu",kernelFunc:Ahe};const MV=dn((n,e)=>n<e?1:0),Dhe=An(jp,MV,null,"bool"),Ohe={kernelName:jp,backendName:"cpu",kernelFunc:Dhe};const zV=dn((n,e)=>n<=e?1:0),Fhe=An(Wp,zV,null,"bool"),Lhe={kernelName:Wp,backendName:"cpu",kernelFunc:Fhe};function PV(n,e,t){const s=(e-n)/(t-1),r=Yn(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const BV=Ki(n=>Math.log(n)),Mhe=qo(Ch,BV),zhe={kernelName:Ch,backendName:"cpu",kernelFunc:Mhe};function VV(n,e,t,s){const r=zn(s,he(t));for(let i=0;i<r.length;++i){const a=i*e;let o=n[a];for(let u=0;u<e;++u){const h=n[a+u];(Number.isNaN(h)||h>o)&&(o=h)}r[i]=o}return r}const UV=dn(((n,e)=>Math.max(n,e))),Phe=An(kh,UV),Bhe={kernelName:kh,backendName:"cpu",kernelFunc:Phe};const jV=dn(((n,e)=>Math.min(n,e))),Vhe=An(Eh,jV),Uhe={kernelName:Eh,backendName:"cpu",kernelFunc:Vhe};const GE=dn(((n,e)=>n*e)),jhe=jE(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),Iw=An(Ih,GE,jhe),Whe={kernelName:Ih,backendName:"cpu",kernelFunc:Iw};function WV(n,e,t){const s=Da(-1,t);return GE([],e,s,n,t)}function Ghe(n){const{inputs:e,backend:t}=n,{x:s}=e;De(s,"neg");const r=t.data.get(s.dataId).values,[i,a]=WV(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}const Hhe={kernelName:tm,backendName:"cpu",kernelFunc:Ghe};const GV=dn(((n,e)=>n!==e?1:0)),qhe=An(nm,GV,null,"bool"),Khe={kernelName:nm,backendName:"cpu",kernelFunc:qhe};function HE(n,e,t,s,r){const i=e.length,a=he(e),o=ze(e),u=ze(r),h=zn(t,he(r));for(let d=0;d<a;++d){const p=hu(d,i,o),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[s[b]];const y=hi(m,i,u);h[y]=n[d]}return h}function Fs(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;De(r,"transpose");const a=r.shape.length,o=new Array(a);for(let p=0;p<o.length;p++)o[p]=r.shape[i[p]];const u=s.data.get(r.dataId).values,h=HE(u,r.shape,r.dtype,i,o);return{dataId:s.write(h,o,r.dtype),shape:o,dtype:r.dtype}}const Xhe={kernelName:Bl,backendName:"cpu",kernelFunc:Fs};function HV(n,e,t,s){const[r,i]=Un(n,s),a=_s(e,"int32"),o=Yn(he(r),a),u=he(i);for(let h=0;h<o.length;++h){const d=h*u;let p=1;for(let m=0;m<u;++m)p*=t[d+m];o[h]=p}return{outVals:o,outShape:r,outDtype:a}}function Yhe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;De(r,"prod");const o=r.shape.length,u=st(i,r.shape),h=Zt(u,o);let d=u,p=r;const m=[];h!=null&&(p=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),m.push(p),d=cn(d.length,o));const y=t.data.get(p.dataId).values,{outVals:b,outShape:x,outDtype:w}=HV(p.shape,p.dtype,y,d);let S=x;return a&&(S=un(x,u)),m.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(S,w,b)}const Jhe={kernelName:lm,backendName:"cpu",kernelFunc:Yhe};function Zhe(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=hu(r,e.length,ze(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function Qhe(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function ede(n,e,t,s){const r=[];let i=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);Qhe(t,s);let u=1;for(let h=0;h<e.length-1;++h){u*=e[h];const d=e[h+1];for(let p=1;p<u+1;++p)o[h].push(p*d)}for(let h=0;h<n.length;++h){let d=n[h],p=n[h]+1;for(let m=0;m<t.length;++m){const y=t[m],b=m+e.length-1;if(b>=0){const x=o[b],w=x[x.length-1]-y[d];for(let S=d;S<p;++S)o[b].push(y[S+1]+w)}d=y[d],p=y[p]}p!==d&&(r.push([d,p]),i+=p-d)}return{outSplits:o,valueSlices:r,numValues:i}}function tde(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=tn("int32",s);e.push(r),n[t].forEach((i,a)=>r[a]=i)}return e}function w3(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function nde(n,e,t,s,r,i){const a=w3(e,2)[1],o=w3(i,2)[1];let u=0;for(const h of t)for(let d=h[0];d<h[1];++d){for(let p=0;p<s;++p)r[u*o+p]=n[d*a+p];++u}}function sde(n,e,t,s,r){const i=e.slice();i[0]=r;const a=tn(t,he(i)),o=n.length,u=o===0?0:o/e[0];return nde(n,e,s,u,a,i),[a,i]}function qV(n,e,t,s,r,i,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(Zhe(i,a,u),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:p,numValues:m}=ede(i,a,n,h),y=tde(d),b=sde(t,s,r,p,m);return[y,b[0],b[1]]}const v3=2147483647;function KV(n,e,t,s,r,i,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,u=r.length===0,h=a.length===0,d=[];o||d.push(e[0]),u||d.push(r[0]),h||d.push(a[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=tn("int32",p+1);m[0]=0;for(let w=0;w<p;++w){const S=o?n[0]:n[w],C=u?s[0]:s[w],N=h?i[0]:i[w];if(N===0)throw new Error("Requires delta != 0");let k;if(N>0&&C<S||N<0&&C>S)k=0;else if(k=Math.ceil(Math.abs((C-S)/N)),k>v3)throw new Error(`Requires ((limit - start) / delta) <= ${v3}`);m[w+1]=m[w]+k}const y=m[p],b=tn(t,y);let x=0;for(let w=0;w<p;++w){const S=m[w+1]-m[w];let C=o?n[0]:n[w];const N=h?i[0]:i[w];for(let k=0;k<S;++k)b[x++]=C,C+=N}return[m,b]}var zr=ci;class q0{constructor(e,t,s,r,i,a,o,u,h,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=fP(d),this.raggedRank=pP(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===zr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===zr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case zr.VALUE_ROWIDS:return q0.getMaxWidthValueRowID(t);case zr.ROW_SPLITS:return q0.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${zr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let a=1;a<t;++a){const o=e[a];o!==r&&(r=o,i=Math.max(a-s,i),s=a)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return T3(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;mP(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=dP(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let a=0;for(let o=0;o<r;++o,a+=t)i.push(a);for(let o=r;o<e;++o)i.push(-1);return D(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,a=[];for(let o=0;o<i-1;++o){const u=e[o+1]-e[o];let h=Math.min(r,u),d=t[o];d===-1&&(h=0);for(let p=0;p<h;++p)a.push(d),d+=s;for(let p=0;p<u-h;++p)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,a=[];if(i===0)return[];let o=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let h=t[u];a.push(h);for(let d=1;d<i;++d){const p=e[d];if(p===u)h>=0&&(++o,o<r?h+=s:h=-1);else{if(o=0,u=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);h=t[p]}a.push(h)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case zr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case zr.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${zr[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case zr.FIRST_DIM_SIZE:return e[0];case zr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${zr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const i=T3(s,!1),a=tn(this.valuesDType,he(i));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)u=this.calculateOutputIndex(h-1,u,r[h],s[h]);this.setOutput(this.raggedRank,u,a,i)}return[i,a]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,a=s;let o=r.slice();o=o.slice(e+1);const u=he(o),h=t.length;let d=this.defaultValue;if(d.length!==u&&d.length!==1){const b=this.defaultValueShape;se(()=>{const x=X(d,b);d=Vl(x,o).dataSync()})}let p=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?t[b]:-1;if(x===y){++y;continue}if(m<y){const w=i.subarray(p*u),S=a.subarray(m*u),C=(y-m)*u;S3(S,w,C)}if(b>=h){const w=s.length;x=Math.floor(w/u)}if(x>y)if(this.defaultValue.length===1)a.subarray(y*u,x*u).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=a.slice(y*u);S3(w,d,u),++y}x<0?(p=b+1,m=y):(p=b,m=y,y=m+1)}}}function S3(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function T3(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function XV(n,e,t,s,r,i,a,o,u,h){return new q0(n,e,t,s,r,i,a,o,u,h).compute()}function YV(n,e,t,s){const r=n===e,i=n<e&&t<0,a=e<n&&t>1;if(r||i||a)return Yn(0,s);const o=Math.abs(Math.ceil((e-n)/t)),u=Yn(o,s);e<n&&t===1&&(t=-1),u[0]=n;for(let h=1;h<u.length;h++)u[h]=u[h-1]+t;return u}const JV=Ki(n=>1/Math.sqrt(n)),rde=qo(Fh,JV),ide={kernelName:Fh,backendName:"cpu",kernelFunc:rde};function Ol(n,e,t,s,r,i,a,o,u,h){const d=[s/r,r],p=n.values,m=e.values;if(s===0)return Qe(t,e.dtype);const y=u instanceof bn?u:Qe(d,e.dtype);typeof u=="string"||typeof u=="number"?y.values.fill(u):typeof u=="boolean"&&y.values.fill(+u);for(let b=0;b<i;b++){const x=[];let w=0;for(let S=0;S<a;S++){const C=p[b*a+S];x.push(C),w+=C*o[S]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let S=0;S<r;S++)h?y.values[w*r+S]+=m[b*r+S]:y.values[w*r+S]=e.rank===0?m[0]:m[b*r+S]}return y}const ade=Ki(n=>1/(1+Math.exp(-n))),ZV=Nt(Bh,n=>1/(1+Math.exp(-n))),ode={kernelName:Bh,backendName:"cpu",kernelFunc:ZV};function QV(n,e,t,s,r){const i=PN(s,e,t),a=he(t),o=ze(s);if(i){const p=BN(e,o);return r==="string"?n.slice(p,p+a):n.subarray(p,p+a)}const u=r==="string"?Ia(n):n,h=Qe(s,r,u),d=Qe(t,r);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),y=m.map((b,x)=>b+e[x]);d.set(h.get(...y),...m)}return r==="string"?FP(d.values):d.values}function iu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s;De(r,"slice");const[o,u]=rw(r,i,a);MN(r,o,u);const h=t.data.get(r.dataId).values,d=QV(h,o,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,d)}const lde={kernelName:pm,backendName:"cpu",kernelFunc:iu};function e4(n,e,t,s,r,i,a){const o=e[0],u=i[0],h=new Array(u),d=new Array(o),p=e[1];if(u===0){if(o!==0)throw new Error(SP(o));const w=tn(t,0),S=tn(r,0);return[w,[0,p],S,h,d]}let m=!0,y=0;const b=new Array(u).fill(0);for(let w=0;w<o;++w){const S=n[w*p];if(S<0)throw new Error(TP(w,S));if(S>=u)throw new Error(CP(w,S,u));++b[S],m=m&&S>=y,y=S}let x=!0;for(let w=0;w<u;++w){const S=b[w]===0;h[w]=S,x=x&&!S,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,S=s;for(let C=0;C<o;++C)d[C]=C;return[w,[o,p],S,h,d]}else{const w=b[u-1],S=tn(t,w*p),C=tn(r,w),N=new Array(u).fill(0);for(let k=0;k<o;++k){const E=n[k*p],_=N[E],R=(E===0?0:b[E-1])+_;N[E]++;for(let O=0;O<p;++O)S[R*p+O]=n[k*p+O];C[R]=s[k],d[k]=R}for(let k=0;k<u;++k)if(N[k]===0){const _=k===0?0:b[k-1];S[_*p+0]=k;for(let R=1;R<p;++R)S[_*p+R]=0;C[_]=a}return[S,[w,p],C,h,d]}}function t4(n,e,t,s,r){const i=he(s),a=e[0],o=r.length,u=[];let h=1,d=-1;for(let w=0;w<o;++w){const S=r[w];if(S===-1){if(d!==-1)throw new Error(NP(d,w));d=w,u.push(1)}else{if(S<0)throw new Error(kP(w,S));h*=S,u.push(S)}}if(d!==-1){if(h<=0)throw new Error(EP());const w=Math.trunc(i/h);if(h*w!==i)throw new Error($P(s,u));u[d]=w}if(he(u)!==i)throw new Error(IP(s,u));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(o>0){b[o-1]=1;for(let w=o-2;w>=0;--w)b[w]=b[w+1]*u[w+1]}const x=tn(t,a*o);for(let w=0;w<a;++w){let S=0;for(let C=0;C<m;++C)S+=n[w*m+C]*y[C];for(let C=0;C<o;++C)x[w*o+C]=Math.trunc(S/b[C]),S%=b[C]}return[x,[a,o],u]}function qE(n,e,t,s,r,i=!1,a=0){const o=s.length,u=[e[0],n.length/e[0]],h=u[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(jT());const m=e.slice();m[0]=p;const y=m.reduce((N,k)=>N*k,1),b=tn(t,y);if(o===0)return p>0&&b.fill(a),[b,m];if(p<=0)throw new Error(jT());let x=0,w=1,S=0,C=r[x];for(;;){let N=0;if(w<o){if(N=r[w],C===N){++w;continue}if(C>=N)throw new Error(_P())}if(C<0||C>=p)throw new Error(AP(C,p));C>S&&b.fill(a,S*h,C*h);for(let k=x;k<w;++k){const E=s[k];if(E<0||E>=u[0])throw new Error(RP(k,s[k],u[0]));for(let _=0;_<h;_++)b[C*h+_]+=n[E*h+_]}if(i)for(let k=0;k<h;k++)b[C*h+k]/=w-x;if(x=w,++w,S=C+1,C=N,w>o)break}return S<p&&b.fill(a,S*h,p*h),[b,m]}const ude=Ki(n=>Math.sqrt(n)),cde=Nt(Uh,n=>Math.sqrt(n)),hde={kernelName:Uh,backendName:"cpu",kernelFunc:cde};const n4=dn(((n,e)=>{const t=n-e;return t*t})),dde=An(jh,n4),fde={kernelName:jh,backendName:"cpu",kernelFunc:dde};const s4=Ki((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),pde=qo(xm,s4),mde={kernelName:xm,backendName:"cpu",kernelFunc:pde};function r4(n,e,t,s){const r=Qe(n,e.dtype);for(let i=0;i<r.size;i++){const a=r.indexToLoc(i),o=new Array(a.length);for(let u=0;u<o.length;u++)o[u]=a[u]*t[u]+s[u];r.set(e.get(...o),...a)}return r}class gde{constructor(e,t,s,r,i,a){this.separator=Li(e),this.nGramWidths=t,this.leftPad=Li(s),this.rightPad=Li(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,a){for(let o=0;o<i;++o){const u=this.getPadWidth(a),h=Math.max(0,u-o),d=Math.max(0,u-(i-(o+1))),p=a-(h+d),m=t+(h>0?0:o-u);let y=0;y+=h*this.leftPad.length;for(let C=0;C<p;++C)y+=e[m+C].length;y+=d*this.rightPad.length;const b=h+d+p-1;y+=b*this.separator.length,s[r+o]=new Uint8Array(y);const x=s[r+o];let w=0;const S=C=>C.forEach(N=>x[w++]=N);for(let C=0;C<h;++C)S(this.leftPad),S(this.separator);for(let C=0;C<p-1;++C)S(e[m+C]),S(this.separator);if(p>0){S(e[m+p-1]);for(let C=0;C<d;++C)S(this.separator),S(this.rightPad)}else{for(let C=0;C<d-1;++C)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let h=1;h<r;++h){let d=t[h]>=u;if(d=d&&t[h]<=s,!d)throw new Error(`Invalid split value ${t[h]}, must be in [${u}, ${s}]`);u=t[h]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const i=r-1,a=tn("int32",r);if(s===0||r===0){const u=new Array(s);for(let h=0;h<=i;++h)a[h]=0;return[u,a]}a[0]=0;for(let u=1;u<=i;++u){const h=t[u]-t[u-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&d===0&&(d=1),a[u]=a[u-1]+d}const o=new Array(a[i]);for(let u=0;u<i;++u){const h=t[u];let d=a[u];if(this.nGramWidths.forEach(p=>{const m=t[u+1]-t[u],y=this.getNumNGrams(m,p);this.createNGrams(e,h,o,d,y,p),d+=y}),this.preserveShort&&d===a[u]){const p=t[u+1]-t[u];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(e,h,o,d,1,m)}}return[o,a]}}function i4(n,e,t,s,r,i,a,o){return new gde(t,s,r,i,a,o).compute(n,e)}function yde(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let a=n.indexOf(i);for(;a!==-1;){const o=n.subarray(0,a);(!t||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const a=n.subarray(r,i);(!t||a.length!==0)&&s.push(a),r=i+1}}function a4(n,e,t){const s=n.length,r=[];let i=0,a=0;const o=new Array(s);for(let m=0;m<s;++m){const y=r.length;yde(n[m],e,t,r);const b=r.length-y;o[m]=b,i+=b,a=Math.max(a,b)}const u=tn("int32",i*2),h=new Array(i),d=[s,a];let p=0;for(let m=0;m<s;++m)for(let y=0;y<o[m];++y)u[p*2]=m,u[p*2+1]=y,h[p]=r[p],++p;return[u,h,d]}function o4(n,e){const t=tn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=gM(n[s]).modulo(e).getLowBitsUnsigned();return t}const l4=dn(((n,e)=>n-e)),bde=jE(((n,e,t,s)=>({real:n-t,imag:e-s}))),KE=An(Wh,l4,bde),xde={kernelName:Wh,backendName:"cpu",kernelFunc:KE};function u4(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=Qe(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),a=new Array(n.rank);for(let u=0;u<a.length;u++)a[u]=i[u]%n.shape[u];const o=n.locToIndex(a);s.values[r]=n.values[o]}return s}const Cf=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function c4(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,u=e-t+1,h=Math.log(o),d=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*d*(o-d)/o)*Math.sign(u-o/2),m=Math.max(t,Math.floor(e-u*d/o+p)),y=Math.min(s,Math.floor(e+(o-u)*d/o+p));c4(n,e,m,y)}const r=n[e];let i=t,a=s;for(ba(n,t,e),Cf(n[s],r)>0&&ba(n,t,s);i<a;){for(ba(n,i,a),i++,a--;Cf(n[i],r)<0;)i=i+1;for(;Cf(n[a],r)>0;)a=a-1}Cf(n[t],r)===0?ba(n,t,a):(a=a+1,ba(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function h4(n,e,t,s,r){const i=e[e.length-1],[a,o]=[n.length/i,i],u=zn(t,a*s),h=zn("int32",a*s);for(let p=0;p<a;p++){const m=p*o,y=n.subarray(m,m+o);let b=new Array(y.length);y.forEach((C,N)=>b[N]={value:C,index:N}),s<b.length&&(c4(b,s),b=b.slice(0,s)),r&&b.sort(Cf);const x=p*s,w=u.subarray(x,x+s),S=h.subarray(x,x+s);for(let C=0;C<s;C++)w[C]=b[C].value,S[C]=b[C].index}const d=e.slice();return d[d.length-1]=s,[Qe(d,t,u),Qe(d,"int32",h)]}function d4(n,e,t,s){const r=st(e,t)[0],i=[1,t[0],1];for(let b=0;b<r;b++)i[0]*=t[b];i[1]=t[r];for(let b=r+1;b<t.length;b++)i[2]*=t[b];const a=new Map,o=new Int32Array(t[r]),u=new bn(i,s,n),h=[],d=i[0]===1&&i[2]===1;for(let b=0;b<t[r];b++){let x;if(d)x=n[b].toString();else{const S=[];for(let C=0;C<i[0];C++)for(let N=0;N<i[2];N++)S.push(u.get(C,b,N));x=S.join(",")}const w=a.get(x);if(w!=null)o[b]=w;else{const S=a.size;a.set(x,S),o[b]=S,h.push(b)}}const p=i.slice();p[1]=a.size;const m=new bn(p,s);h.forEach((b,x)=>{for(let w=0;w<i[0];w++)for(let S=0;S<i[2];S++)m.set(u.get(w,b,S),w,x,S)});const y=t.slice();return y[r]=p[1],{outputValues:m.values,outputShape:y,indices:o}}const f4=Object.freeze(Object.defineProperty({__proto__:null,addImpl:vV,bincountImpl:WE,bincountReduceImpl:SV,bitwiseAndImpl:TV,castImpl:wV,ceilImpl:CV,concatImpl:NV,equalImpl:kV,expImpl:$V,expm1Impl:_V,floorDivImpl:RV,floorImpl:AV,gatherNdImpl:DV,gatherV2Impl:OV,greaterEqualImpl:LV,greaterImpl:FV,lessEqualImpl:zV,lessImpl:MV,linSpaceImpl:PV,logImpl:BV,maxImpl:VV,maximumImpl:UV,minimumImpl:jV,multiplyImpl:GE,negImpl:WV,notEqualImpl:GV,prodImpl:HV,raggedGatherImpl:qV,raggedRangeImpl:KV,raggedTensorToTensorImpl:XV,rangeImpl:YV,rsqrtImpl:JV,scatterImpl:Ol,sigmoidImpl:ade,simpleAbsImpl:xV,sliceImpl:QV,sparseFillEmptyRowsImpl:e4,sparseReshapeImpl:t4,sparseSegmentReductionImpl:qE,sqrtImpl:ude,squaredDifferenceImpl:n4,staticRegexReplaceImpl:s4,stridedSliceImpl:r4,stringNGramsImpl:i4,stringSplitImpl:a4,stringToHashBucketFastImpl:o4,subImpl:l4,tileImpl:u4,topKImpl:h4,transposeImpl:HE,uniqueImpl:d4},Symbol.toStringTag,{value:"Module"}));const p4="4.22.0";y2("cpu",()=>new tg,1);const m4=Nt(fh,n=>n>=0?n:Math.exp(n)-1),wde={kernelName:fh,backendName:"cpu",kernelFunc:m4};function g4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;De([r],"leakyRelu");const a=he(r.shape),o=t.data.get(r.dataId).values,u=zn("float32",a);for(let h=0;h<o.length;h++)u[h]=o[h]<0?i*o[h]:o[h];return t.makeTensorInfo(r.shape,"float32",u)}const vde={kernelName:Up,backendName:"cpu",kernelFunc:g4};const Sde=dn((n,e)=>n<0?e*n:n);function y4(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;De([s,r],"prelu");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[o,u]=Sde(s.shape,r.shape,i,a,"float32");return t.makeTensorInfo(u,"float32",o)}const Tde={kernelName:om,backendName:"cpu",kernelFunc:y4};const b4=Nt(Rh,n=>Math.max(0,n)),Cde={kernelName:Rh,backendName:"cpu",kernelFunc:b4};const x4=Nt(Dh,n=>Math.min(Math.max(0,n),6)),Nde={kernelName:Dh,backendName:"cpu",kernelFunc:x4};function K0(n,e,t,s,r){if(t==="linear")return Gi({inputs:{x:e},backend:n});if(t==="relu")return b4({inputs:{x:e},backend:n});if(t==="elu")return m4({inputs:{x:e},backend:n});if(t==="relu6")return x4({inputs:{x:e},backend:n});if(t==="prelu")return y4({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return g4({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return ZV({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function zt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=he(r.shape),o=l2(i,a),u=he(o);D(a===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const h=t.data.get(r.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;d.shape=o,p.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const kde={kernelName:um,backendName:"cpu",kernelFunc:zt};function w4(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;De([r,i],"matMul");const u=r.shape.length,h=i.shape.length,d=a?r.shape[u-2]:r.shape[u-1],p=o?i.shape[h-1]:i.shape[h-2],m=a?r.shape[u-1]:r.shape[u-2],y=o?i.shape[h-2]:i.shape[h-1],b=r.shape.slice(0,-2),x=i.shape.slice(0,-2),w=he(b),S=he(x),N=Xe(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,y]);D(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const k=a?[w,d,m]:[w,m,d],E=o?[S,y,p]:[S,p,y],_=zt({inputs:{x:r},backend:t,attrs:{shape:k}}),R=zt({inputs:{x:i},backend:t,attrs:{shape:E}}),O=a?_.shape[1]:_.shape[2],F=a?_.shape[2]:_.shape[1],L=o?R.shape[1]:R.shape[2],A=Math.max(w,S),U=t.data.get(_.dataId).values,Y=t.data.get(R.dataId).values,te=ze(_.shape),Z=ze(R.shape),[B,V,j]=a?[te[0],1,te[1]]:[te[0],te[1],1],[ee,ae,P]=o?[1,Z[1],Z[0]]:[Z[1],1,Z[0]],H=F*L,ne=Qe([A,F,L],_.dtype),ce=ne.values,me=t.blockSize;for(let de=0;de<A;de++){const Se=de%w,Te=de%S;for(let Ee=0;Ee<F;Ee+=me){const Ve=Math.min(Ee+me,F);for(let je=0;je<L;je+=me){const Ye=Math.min(je+me,L);for(let ft=0;ft<O;ft+=me){const bt=Math.min(ft+me,O);for(let St=Ee;St<Ve;St++)for(let xt=je;xt<Ye;xt++){let Pt=0;for(let _t=ft;_t<bt;_t++){const nr=U[Se*B+St*V+_t*j],nn=Y[_t*ee+xt*ae+Te*P];Pt+=nr*nn}ce[de*H+(St*L+xt)]+=Pt}}}}}return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(N,ne.dtype,ne.values)}const Ede={kernelName:kp,backendName:"cpu",kernelFunc:w4};function $de(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:u,transposeB:h,activation:d,leakyreluAlpha:p}=s;let m,y,b;const x=[];m=w4({inputs:{a:r,b:i},attrs:{transposeA:u,transposeB:h},backend:t}),a&&(y=Kc({inputs:{a:m,b:a},backend:t}),x.push(m),m=y),d&&(b=K0(t,m,d,o,p),x.push(m),m=b);for(const S of x)t.disposeIntermediateTensorInfo(S);return m}const Ide={kernelName:Xf,backendName:"cpu",kernelFunc:$de};const _de=Nt(eh,n=>Math.acos(n)),Ade={kernelName:eh,backendName:"cpu",kernelFunc:_de};const Rde=Nt(th,n=>Math.acosh(n)),Dde={kernelName:th,backendName:"cpu",kernelFunc:Rde};function Ode(n){const{inputs:e,backend:t}=n,s=e;De(e,"addN");const r=s.map(o=>t.data.get(o.dataId).values),i=Qe(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const u=r[o];for(let h=0;h<a.length;h++)a[h]+=u[h]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const Fde={kernelName:vp,backendName:"cpu",kernelFunc:Ode};function Lde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;De(r,"all");const o=st(i,r.shape);let u=o;const h=Zt(u,r.shape.length);let d=r;h!=null&&(d=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),u=cn(u.length,r.shape.length)),Qn("all",u,d.shape.length);const[p,m]=Un(d.shape,u),y=he(m),b=Yn(he(p),d.dtype),x=t.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const C=S*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];N=N&&E}b[S]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(a){const S=un(p,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(w),C}return w}const Mde={kernelName:fb,backendName:"cpu",kernelFunc:Lde};function zde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;De(r,"any");const o=st(i,r.shape);let u=o;const h=Zt(u,r.shape.length);let d=r;h!=null&&(d=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),u=cn(u.length,r.shape.length)),Qn("any",u,d.shape.length);const[p,m]=Un(d.shape,u),y=he(m),b=Yn(he(p),d.dtype),x=t.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const C=S*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];N=N||E}b[S]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(a){const S=un(p,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(w),C}return w}const Pde={kernelName:pb,backendName:"cpu",kernelFunc:zde};function Bde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;De(r,"argMax");let a=st(i,r.shape);const o=Zt(a,r.shape.length);let u=r;const h=[];o!=null&&(u=Fs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(u),a=cn(a.length,u.shape.length)),a=[a[0]],Qn("argMax",a,u.shape.length);const[d,p]=Un(u.shape,a),m=he(d),y=Yn(m,"int32"),b=he(p),x=t.data.get(u.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let C=x[S],N=0;for(let k=0;k<b;++k){const E=x[S+k];E>C&&(C=E,N=k)}y[w]=N}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const Vde={kernelName:Sp,backendName:"cpu",kernelFunc:Bde};function Ude(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;De(r,"argMin");let a=st(i,r.shape);const o=Zt(a,r.shape.length);let u=r;const h=[];o!=null&&(u=Fs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(u),a=cn(a.length,u.shape.length)),a=[a[0]],Qn("argMin",a,u.shape.length);const[d,p]=Un(u.shape,a),m=he(d),y=Yn(m,"int32"),b=he(p),x=t.data.get(u.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let C=x[S],N=0;for(let k=0;k<b;++k){const E=x[S+k];E<C&&(C=E,N=k)}y[w]=N}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const jde={kernelName:Tp,backendName:"cpu",kernelFunc:Ude};const Wde=Nt(nh,n=>Math.asin(n)),Gde={kernelName:nh,backendName:"cpu",kernelFunc:Wde};const Hde=Nt(sh,n=>Math.asinh(n)),qde={kernelName:sh,backendName:"cpu",kernelFunc:Hde};const Kde=Nt(rh,n=>Math.atan(n)),Xde={kernelName:rh,backendName:"cpu",kernelFunc:Kde};const Yde=dn((n,e)=>Math.atan2(n,e)),Jde=An(ah,Yde),Zde={kernelName:ah,backendName:"cpu",kernelFunc:Jde};const Qde=Nt(ih,n=>Math.atanh(n)),efe={kernelName:ih,backendName:"cpu",kernelFunc:Qde};function XE(n,e,t,s,r,i){const a=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Qe(r.outShape,t),w=x.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3],C=r.outShape[2]*r.outShape[3],N=r.outShape[3];for(let k=0;k<r.batchSize;++k){const E=k*S,_=k*s[0];for(let R=0;R<r.inChannels;++R)for(let O=0;O<r.outHeight;++O){const F=O*a-m,L=Math.max(0,F),A=Math.min(r.inHeight,d+F),U=E+O*C;for(let Y=0;Y<r.outWidth;++Y){const te=Y*o-y,Z=Math.max(0,te),B=Math.min(r.inWidth,p+te);let V=b,j=0,ee=0;for(let P=L;P<A;P+=u){const H=_+P*s[1];for(let ne=Z;ne<B;ne+=h){const ce=H+ne*s[2],me=n[ce+R];i==="max"&&me>V?V=me:i==="avg"&&(j+=me,ee++)}if(isNaN(V))break}const ae=U+Y*N+R;w[ae]=i==="avg"?j/ee:V}}}return x}function v4(n,e,t,s,r=!1,i=!1){const a=Qe(s.outShape,"int32"),o=s.strideHeight,u=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=Qe(e,t,n);for(let w=0;w<s.batchSize;++w)for(let S=0;S<s.inChannels;++S)for(let C=0;C<s.outHeight;++C){const N=C*o-y;let k=N;for(;k<0;)k+=h;const E=Math.min(s.inHeight,p+N);for(let _=0;_<s.outWidth;++_){const R=_*u-b;let O=R;for(;O<0;)O+=d;const F=Math.min(s.inWidth,m+R);let L=Number.NEGATIVE_INFINITY,A=-1;for(let U=k;U<E;U+=h){const Y=U-N;for(let te=O;te<F;te+=d){const Z=te-R,B=x.get(w,U,te,S);B>L&&(L=B,r?A=i?((w*s.inHeight+U)*s.inWidth+te)*s.inChannels+S:(U*s.inWidth+te)*s.inChannels+S:A=Y*m+Z)}}a.set(A,w,C,_,S)}}return a}function S4(n,e,t,s,r,i){const a=r.strideDepth,o=r.strideHeight,u=r.strideWidth,h=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,S=r.padInfo.left,C=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=Qe(r.outShape,t),k=N.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[3]*r.outShape[4],O=r.outShape[4];for(let F=0;F<r.batchSize;++F){const L=F*E,A=F*s[0];for(let U=0;U<r.inChannels;++U)for(let Y=0;Y<r.outDepth;++Y){const te=Y*a-x;let Z=te;for(;Z<0;)Z+=h;const B=Math.min(r.inDepth,m+te),V=L+Y*_;for(let j=0;j<r.outHeight;++j){const ee=j*o-w;let ae=ee;for(;ae<0;)ae+=d;const P=Math.min(r.inHeight,y+ee),H=V+j*R;for(let ne=0;ne<r.outWidth;++ne){const ce=ne*u-S;let me=ce;for(;me<0;)me+=p;const de=Math.min(r.inWidth,b+ce),Se=H+ne*O;let Te=C,Ee=0,Ve=0;for(let Ye=Z;Ye<B;Ye+=h){const ft=A+Ye*s[1];for(let bt=ae;bt<P;bt+=d){const St=ft+bt*s[2];for(let xt=me;xt<de;xt+=p){const Pt=St+xt*s[3],_t=n[Pt+U];if(i==="max"&&_t>Te?Te=_t:i==="avg"&&(Ee+=_t,Ve++),isNaN(Te))break}if(isNaN(Te))break}if(isNaN(Te))break}const je=Se+U;k[je]=i==="avg"?Ee/Math.max(Ve,1):Te}}}}return N}function tfe(n,e){const t=Qe(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let w=0;w<e.inChannels;++w)for(let S=0;S<e.outDepth;++S){const C=S*s-m;let N=C;for(;N<0;)N+=a;const k=Math.min(e.inDepth,h+C);for(let E=0;E<e.outHeight;++E){const _=E*r-y;let R=_;for(;R<0;)R+=o;const O=Math.min(e.inHeight,d+_);for(let F=0;F<e.outWidth;++F){const L=F*i-b;let A=L;for(;A<0;)A+=u;const U=Math.min(e.inWidth,p+L);let Y=Number.NEGATIVE_INFINITY,te=-1;for(let Z=N;Z<k;Z+=a){const B=Z-C;for(let V=R;V<O;V+=o){const j=V-_;for(let ee=A;ee<U;ee+=u){const ae=ee-L,P=n.get(x,Z,V,ee,w);P>=Y&&(Y=P,te=B*d*p+j*d+ae)}}}t.set(te,x,S,E,F,w)}}}return t}function nfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;De(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,h=1;D(Zn(a,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Hr(r.shape,i,a,h,o,u);let p;if(d.filterWidth===1&&d.filterHeight===1&&it(d.inShape,d.outShape))p=Gi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=ze(r.shape),b=XE(m,r.shape,r.dtype,y,d,"avg");p=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const sfe={kernelName:Cp,backendName:"cpu",kernelFunc:nfe};function rfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:h}=s;De(r,"avgPool3d");const d=Oa(r.shape,i,a,1,o,u,h),p=t.data.get(r.dataId).values,m=S4(p,r.shape,r.dtype,ze(r.shape),d,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const ife={kernelName:Np,backendName:"cpu",kernelFunc:rfe};function afe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:u,dimRoundingMode:h}=s;De([r,i],"avgPool3DGrad");const d=Oa(i.shape,a,o,1,u,h),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,S=d.dilationDepth,C=d.dilationHeight,N=d.dilationWidth,k=d.effectiveFilterDepth,E=d.effectiveFilterHeight,_=d.effectiveFilterWidth,R=k-1-d.padInfo.front,O=_-1-d.padInfo.left,F=E-1-d.padInfo.top,L=Qe(i.shape,"float32"),A=1/(b*x*w),U=t.bufferSync(r);for(let Y=0;Y<d.batchSize;++Y)for(let te=0;te<d.inChannels;++te)for(let Z=0;Z<d.inDepth;++Z)for(let B=0;B<d.inHeight;++B)for(let V=0;V<d.inWidth;++V){const j=Z-R,ee=B-F,ae=V-O;let P=0;for(let H=0;H<k;H+=S){const ne=(j+H)/p;if(!(ne<0||ne>=d.outDepth||Math.floor(ne)!==ne))for(let ce=0;ce<E;ce+=C){const me=(ee+ce)/m;if(!(me<0||me>=d.outHeight||Math.floor(me)!==me))for(let de=0;de<_;de+=N){const Se=(ae+de)/y;if(Se<0||Se>=d.outWidth||Math.floor(Se)!==Se)continue;const Te=U.get(Y,ne,me,Se,te);P+=Te}}}L.set(P*A,Y,Z,B,V,te)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}const ofe={kernelName:gb,backendName:"cpu",kernelFunc:afe};function lfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;De([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:h}=s,d=Hr(a.shape,o,u,1,h),p=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,S=d.effectiveFilterHeight,C=d.effectiveFilterWidth,N=C-1-d.padInfo.left,k=S-1-d.padInfo.top,E=Qe(a.shape,"float32"),_=1/(y*b),R=t.data.get(r.dataId).values,O=Qe(r.shape,"float32",R);for(let F=0;F<d.batchSize;++F)for(let L=0;L<d.inChannels;++L)for(let A=0;A<d.inHeight;++A)for(let U=0;U<d.inWidth;++U){const Y=A-k,te=U-N;let Z=0;for(let B=0;B<S;B+=x){const V=(Y+B)/p;if(!(V<0||V>=d.outHeight||Math.floor(V)!==V))for(let j=0;j<C;j+=w){const ee=(te+j)/m;if(ee<0||ee>=d.outWidth||Math.floor(ee)!==ee)continue;const ae=O.get(F,V,ee,L);Z+=ae}}E.set(Z*_,F,A,U,L)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const ufe={kernelName:mb,backendName:"cpu",kernelFunc:lfe};function cfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:a,mean:o,variance:u}=e;D(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),De([r,o,u,i,a],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=t.data.get(r.dataId).values,p=t.data.get(o.dataId).values,m=t.data.get(u.dataId).values,y=i?t.data.get(i.dataId).values:new Float32Array([1]),b=a?t.data.get(a.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,S=y.length,C=m.length,N=p.length;let k=0,E=0,_=0,R=0;for(let O=0;O<d.length;++O)x[O]=b[k++]+(d[O]-p[E++])*y[_++]/Math.sqrt(m[R++]+h),k>=w&&(k=0),E>=N&&(E=0),_>=S&&(_=0),R>=C&&(R=0);return t.makeTensorInfo(r.shape,r.dtype,x)}const hfe={kernelName:Pp,backendName:"cpu",kernelFunc:cfe};function dfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;De([r],"batchToSpaceND");const o=i.reduce((S,C)=>S*C),u=jm(r.shape,i,o),h=Wm(u.length,i.length),d=Gm(r.shape,i,o),p=HN(a,i.length),m=qN(d,a,i.length),y=zt({inputs:{x:r},backend:t,attrs:{shape:u}}),b=Fs({inputs:{x:y},backend:t,attrs:{perm:h}}),x=zt({inputs:{x:b},backend:t,attrs:{shape:d}}),w=iu({inputs:{x},backend:t,attrs:{begin:p,size:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const ffe={kernelName:Ep,backendName:"cpu",kernelFunc:dfe};function pfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,h=WE(o,u,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,h)}const mfe={kernelName:yb,backendName:"cpu",kernelFunc:pfe};function gfe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=Xe(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const yfe={kernelName:bb,backendName:"cpu",kernelFunc:gfe};const bfe=Nt(uh,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),xfe={kernelName:uh,backendName:"cpu",kernelFunc:bfe};const wfe=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(he(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,o=t.data.get(i.dataId).values,u=t.data.get(a.dataId).values;for(let h=0;h<o.length;h++){const d=o[h],p=u[h];s[h]=Math.hypot(d,p)}return t.makeOutput(s,e.shape,"float32")},vfe={kernelName:Ip,backendName:"cpu",kernelFunc:wfe};function Xc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Sfe={kernelName:zb,backendName:"cpu",kernelFunc:Xc};function Yc(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=st(r,e[0].shape)[0],a=e.map(x=>x.shape);jN(a,i);let o=zi(e.map(x=>x.shape),i);if(he(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(x=>he(x.shape)>0);if(u.length===1)return Gi({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){const x=u.map(k=>ru({inputs:{input:k},backend:t})),w=u.map(k=>Xc({inputs:{input:k},backend:t})),S=Yc({inputs:x,backend:t,attrs:{axis:i}}),C=Yc({inputs:w,backend:t,attrs:{axis:i}}),N=Ks({inputs:{real:S,imag:C},backend:t});return x.forEach(k=>t.disposeIntermediateTensorInfo(k)),w.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(C),N}const h=u.map(x=>{const S=[-1,he(x.shape.slice(i))];return zt({inputs:{x},backend:t,attrs:{shape:S}})}),d=h.map(x=>({vals:t.data.get(x.dataId).values,shape:x.shape}));o=zi(h.map(x=>x.shape),1);const p=h[0].shape[0]===1,m=NV(d,o,e[0].dtype,p),y=zi(u.map(x=>x.shape),i),b=t.makeTensorInfo(y,e[0].dtype,m);return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const Tfe={kernelName:_p,backendName:"cpu",kernelFunc:Yc};function T4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:u,dilations:h,dimRoundingMode:d}=s;De([r,i],"conv2d");const p=Fa(u),m=Vn(r.shape,i.shape,a,h,o,d,!1,p),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,S=m.padInfo.left,C=m.padInfo.top,N=m.dataFormat==="channelsLast",k=new bn(m.outShape,r.dtype),E=ze(r.shape),_=ze(i.shape),R=E[0],O=N?E[1]:E[2],F=N?E[2]:1,L=N?1:E[1],A=k.strides[0],U=N?k.strides[1]:k.strides[2],Y=N?k.strides[2]:1,te=N?1:k.strides[1],Z=t.data.get(r.dataId).values,B=t.data.get(i.dataId).values,V=k.values;for(let j=0;j<m.batchSize;++j){const ee=j*R,ae=j*A;for(let P=0;P<m.outHeight;++P){const H=ae+P*U,ne=P*m.strideHeight-C;for(let ce=0;ce<y;++ce){const me=ne+ce*x;if(me<0||me>=m.inHeight)continue;const de=ce*_[0],Se=ee+me*O;for(let Te=0;Te<m.outWidth;++Te){const Ee=H+Te*Y,Ve=Te*m.strideWidth-S;for(let je=0;je<b;++je){const Ye=Ve+je*w;if(Ye<0||Ye>=m.inWidth)continue;const ft=de+je*_[1],bt=Se+Ye*F;let St=ft;for(let xt=0;xt<m.inChannels;++xt){const Pt=Z[bt+xt*L];for(let _t=0;_t<m.outChannels;++_t)V[Ee+_t*te]+=Pt*B[St+_t];St+=m.outChannels}}}}}}return t.makeTensorInfo(k.shape,k.dtype,V)}const Cfe={kernelName:Ap,backendName:"cpu",kernelFunc:T4};function Nfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:u,dimRoundingMode:h,filterShape:d}=s;De([r,i],"conv2dBackpropFilter");const p=Fa(u),m=Vn(r.shape,d,a,1,o,h,!1,p),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,S=m.dataFormat==="channelsLast",C=new bn(m.filterShape,"float32"),N=m.padInfo.left,k=m.padInfo.top,E=t.data.get(r.dataId).values,_=t.data.get(i.dataId).values,R=new bn(r.shape,r.dtype,E),O=new bn(i.shape,i.dtype,_);for(let F=0;F<x;++F){const L=Math.max(0,Math.ceil((k-F)/y)),A=Math.min(m.outHeight,(m.inHeight+k-F)/y);for(let U=0;U<w;++U){const Y=Math.max(0,Math.ceil((N-U)/b)),te=Math.min(m.outWidth,(m.inWidth+N-U)/b);for(let Z=0;Z<m.inChannels;++Z)for(let B=0;B<m.outChannels;++B){let V=0;for(let j=0;j<m.batchSize;++j)for(let ee=L;ee<A;++ee){const ae=F+ee*y-k;for(let P=Y;P<te;++P){const H=U+P*b-N;S?V+=R.get(j,ae,H,Z)*O.get(j,ee,P,B):V+=R.get(j,Z,ae,H)*O.get(j,B,ee,P)}}C.set(V,F,U,Z,B)}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const kfe={kernelName:wb,backendName:"cpu",kernelFunc:Nfe};function Efe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:u,dataFormat:h,dimRoundingMode:d}=s;De([r,i],"conv2dBackpropInput");const p=ze(i.shape),m=ze(r.shape);let y=Fa(h);const b=Vn(a,i.shape,o,1,u,d,!1,y),x=new bn(b.inShape,"float32"),w=x.values,S=t.data.get(r.dataId).values,C=t.data.get(i.dataId).values,[N,k,E]=p,{batchSize:_,filterHeight:R,filterWidth:O,inChannels:F,inHeight:L,inWidth:A,outChannels:U,outHeight:Y,outWidth:te,strideHeight:Z,strideWidth:B}=b;y=b.dataFormat;const V=R-1-b.padInfo.top,j=O-1-b.padInfo.left,ee=y==="channelsLast",ae=x.strides[0],P=ee?x.strides[1]:x.strides[2],H=ee?x.strides[2]:1,ne=ee?1:x.strides[1],ce=m[0],me=ee?m[1]:m[2],de=ee?m[2]:1,Se=ee?1:m[1];for(let Te=0;Te<_;++Te)for(let Ee=0;Ee<F;++Ee)for(let Ve=0;Ve<L;++Ve){const je=Ve-V,Ye=Math.max(0,Math.ceil(je/Z)),ft=Math.min(Y,(R+je)/Z);for(let bt=0;bt<A;++bt){const St=bt-j,xt=Math.max(0,Math.ceil(St/B)),Pt=Math.min(te,(O+St)/B);let _t=0;for(let nn=Ye;nn<ft;++nn){const kr=nn*Z-je;for(let Ts=xt;Ts<Pt;++Ts){const Xi=Ts*B-St,Vt=ce*Te+me*nn+de*Ts,Xr=N*(R-1-kr)+k*(O-1-Xi)+E*Ee;for(let Yr=0;Yr<U;++Yr){const Jr=S[Vt+Se*Yr],sr=C[Xr+Yr];_t+=Jr*sr}}}const nr=ae*Te+P*Ve+H*bt+ne*Ee;w[nr]=_t}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const $fe={kernelName:Rp,backendName:"cpu",kernelFunc:Efe};function Ife(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s;De([r,i],"conv3d");const h=Vo(r.shape,i.shape,a,u,o),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,S=w.front,C=w.left,N=w.top,k=new bn(h.outShape,r.dtype),E=t.data.get(r.dataId).values,_=t.data.get(i.dataId).values,R=k.values,O=ze(r.shape),F=ze(i.shape);for(let L=0;L<h.batchSize;++L){const A=L*O[0],U=L*k.strides[0];for(let Y=0;Y<h.outDepth;++Y){const te=U+Y*k.strides[1],Z=Y*h.strideDepth-S;for(let B=0;B<d;++B){const V=Z+B*y;if(V<0||V>=h.inDepth)continue;const j=B*F[0],ee=A+V*O[1];for(let ae=0;ae<h.outHeight;++ae){const P=te+ae*k.strides[2],H=ae*h.strideHeight-N;for(let ne=0;ne<p;++ne){const ce=H+ne*b;if(ce<0||ce>=h.inHeight)continue;const me=j+ne*F[1],de=ee+ce*O[2];for(let Se=0;Se<h.outWidth;++Se){const Te=P+Se*h.outChannels,Ee=Se*h.strideWidth-C;for(let Ve=0;Ve<m;++Ve){const je=Ee+Ve*x;if(je<0||je>=h.inWidth)continue;const Ye=me+Ve*F[2],ft=de+je*h.inChannels;let bt=Ye;for(let St=0;St<h.inChannels;++St){const xt=E[ft+St];for(let Pt=0;Pt<h.outChannels;++Pt)R[Te+Pt]+=xt*_[bt+Pt];bt+=h.outChannels}}}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const _fe={kernelName:Dp,backendName:"cpu",kernelFunc:Ife};function Afe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:u}=s;De([r,i],"conv3dBackpropFilterV2");const h=ze(r.shape),d=ze(i.shape),p=Vo(r.shape,u,a,1,o),m=p.strideDepth,y=p.strideHeight,b=p.strideWidth,x=p.filterDepth,w=p.filterHeight,S=p.filterWidth,C=new bn(p.filterShape,"float32"),N=C.values,[k,E,_,R]=C.strides,O=t.data.get(i.dataId).values,[F,L,A,U]=d,Y=t.data.get(r.dataId).values,[te,Z,B,V]=h,j=p.padInfo.front,ee=p.padInfo.left,ae=p.padInfo.top;for(let P=0;P<x;++P){const H=Math.max(0,Math.ceil((j-P)/m)),ne=Math.min(p.outDepth,(p.inDepth+j-P)/m),ce=P*k;for(let me=0;me<w;++me){const de=Math.max(0,Math.ceil((ae-me)/y)),Se=Math.min(p.outHeight,(p.inHeight+ae-me)/y),Te=me*E+ce;for(let Ee=0;Ee<S;++Ee){const Ve=Math.max(0,Math.ceil((ee-Ee)/b)),je=Math.min(p.outWidth,(p.inWidth+ee-Ee)/b),Ye=Ee*_+Te;for(let ft=0;ft<p.inChannels;++ft){const bt=ft*R+Ye;for(let St=0;St<p.outChannels;++St){let xt=0;for(let Pt=0;Pt<p.batchSize;++Pt){const _t=Pt*te,nr=Pt*F;for(let nn=H;nn<ne;++nn){const Ts=(P+nn*m-j)*Z+_t,Xi=nn*L+nr;for(let Vt=de;Vt<Se;++Vt){const Yr=(me+Vt*y-ae)*B+Ts,Jr=Vt*A+Xi;for(let sr=Ve;sr<je;++sr){const Nu=(Ee+sr*b-ee)*V+Yr,bd=sr*U+Jr;xt+=Y[Nu+ft]*O[bd+St]}}}}N[bt+St]=xt}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Rfe={kernelName:vb,backendName:"cpu",kernelFunc:Afe};function Dfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:u}=s;De([r],"conv3dBackpropInputV2");const h=ze(r.shape),d=ze(i.shape),p=Vo(u,i.shape,o,1,a),m=new bn(p.inShape,"float32"),y=m.values,[b,x,w,S]=m.strides,C=t.data.get(r.dataId).values,[N,k,E,_]=h,R=t.data.get(i.dataId).values,[O,F,L,A]=d,{batchSize:U,filterDepth:Y,filterHeight:te,filterWidth:Z,inChannels:B,inDepth:V,inHeight:j,inWidth:ee,outChannels:ae,outDepth:P,outHeight:H,outWidth:ne,strideDepth:ce,strideHeight:me,strideWidth:de}=p,Se=Y-1-p.padInfo.front,Te=te-1-p.padInfo.top,Ee=Z-1-p.padInfo.left;for(let Ve=0;Ve<U;++Ve)for(let je=0;je<B;++je)for(let Ye=0;Ye<V;++Ye){const ft=Ye-Se,bt=Math.max(0,Math.ceil(ft/ce)),St=Math.min(P,(Y+ft)/ce);for(let xt=0;xt<j;++xt){const Pt=xt-Te,_t=Math.max(0,Math.ceil(Pt/me)),nr=Math.min(H,(te+Pt)/me);for(let nn=0;nn<ee;++nn){const kr=nn-Ee,Ts=Math.max(0,Math.ceil(kr/de)),Xi=Math.min(ne,(Z+kr)/de);let Vt=0;for(let Xr=bt;Xr<St;++Xr){const Yr=Xr*ce-ft;for(let Jr=_t;Jr<nr;++Jr){const sr=Jr*me-Pt;for(let Xo=Ts;Xo<Xi;++Xo){const Nu=Xo*de-kr,bd=N*Ve+k*Xr+E*Jr+_*Xo,Ow=O*(Y-1-Yr)+F*(te-1-sr)+L*(Z-1-Nu)+A*je;for(let Ti=0;Ti<ae;++Ti){const Cs=C[bd+Ti],Ci=R[Ow+Ti];Vt+=Cs*Ci}}}}y[b*Ve+x*Ye+w*xt+S*nn+je]=Vt}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const Ofe={kernelName:Sb,backendName:"cpu",kernelFunc:Dfe};const Ffe=Nt(ch,n=>Math.cos(n)),Lfe={kernelName:ch,backendName:"cpu",kernelFunc:Ffe};const Mfe=Nt(hh,n=>Math.cosh(n)),zfe={kernelName:hh,backendName:"cpu",kernelFunc:Mfe};function Pfe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:u,extrapolationValue:h}=s,[d,p,m,y]=r.shape,b=i.shape[0],[x,w]=o,S=Qe([b,x,w,y],"float32"),C=t.data.get(i.dataId).values,N=t.data.get(a.dataId).values,k=t.data.get(r.dataId).values,E=ze(r.shape),_=ze(S.shape);for(let R=0;R<b;R++){const O=R*4,F=C[O],L=C[O+1],A=C[O+2],U=C[O+3],Y=N[R];if(Y>=d)continue;const te=x>1?(A-F)*(p-1)/(x-1):0,Z=w>1?(U-L)*(m-1)/(w-1):0;for(let B=0;B<x;B++){const V=x>1?F*(p-1)+B*te:.5*(F+A)*(p-1);if(V<0||V>p-1){for(let j=0;j<w;j++)for(let ee=0;ee<y;ee++){const ae=ee+j*_[2]+B*_[1]+R*_[0];S.values[ae]=h}continue}if(u==="bilinear"){const j=Math.floor(V),ee=Math.ceil(V),ae=V-j;for(let P=0;P<w;P++){const H=w>1?L*(m-1)+P*Z:.5*(L+U)*(m-1);if(H<0||H>m-1){for(let de=0;de<y;de++){const Se=de+P*_[2]+B*_[1]+R*_[0];S.values[Se]=h}continue}const ne=Math.floor(H),ce=Math.ceil(H),me=H-ne;for(let de=0;de<y;de++){let Se=de+ne*E[2]+j*E[1]+Y*E[0];const Te=k[Se];Se=de+ce*E[2]+j*E[1]+Y*E[0];const Ee=k[Se];Se=de+ne*E[2]+ee*E[1]+Y*E[0];const Ve=k[Se];Se=de+ce*E[2]+ee*E[1]+Y*E[0];const je=k[Se],Ye=Te+(Ee-Te)*me,ft=Ve+(je-Ve)*me;Se=de+P*_[2]+B*_[1]+R*_[0],S.values[Se]=Ye+(ft-Ye)*ae}}}else for(let j=0;j<w;++j){const ee=w>1?L*(m-1)+j*Z:.5*(L+U)*(m-1);if(ee<0||ee>m-1){for(let H=0;H<y;H++){const ne=H+j*_[2]+B*_[1]+R*_[0];S.values[ne]=h}continue}const ae=Math.round(ee),P=Math.round(V);for(let H=0;H<y;H++){const ne=H+ae*E[2]+P*E[1]+Y*E[0],ce=H+j*_[2]+B*_[1]+R*_[0];S.values[ce]=k[ne]}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const Bfe={kernelName:Cb,backendName:"cpu",kernelFunc:Pfe};function Vfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;De(r,"cumprod");const u=Zt([i],r.shape.length);let h=r;u!=null&&(h=Fs({inputs:{x:r},backend:t,attrs:{perm:u}}));const d=cn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=_s(h.dtype,"int32"),m=db(he(h.shape),p),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=o?(S,C)=>S+b-C-1:(S,C)=>S+C;for(let S=0;S<y.length;S+=b)for(let C=0;C<b;C++){const N=x(S,C);if(C===0)m[N]=a?1:y[N];else{const k=x(S,C-1);m[N]=a?y[k]*m[k]:y[N]*m[k]}}const w=t.makeTensorInfo(h.shape,p,m);if(u!=null){const S=Uo(u),C=Fs({inputs:{x:w},backend:t,attrs:{perm:S}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),C}return w}const Ufe={kernelName:Tb,backendName:"cpu",kernelFunc:Vfe};function jfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;De(r,"cumsum");const u=Zt([i],r.shape.length);let h=r;u!=null&&(h=Fs({inputs:{x:r},backend:t,attrs:{perm:u}}));const d=cn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=_s(h.dtype,"int32"),m=Yn(he(h.shape),p),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=o?(S,C)=>S+b-C-1:(S,C)=>S+C;for(let S=0;S<y.length;S+=b)for(let C=0;C<b;C++){const N=x(S,C);if(C===0)m[N]=a?0:y[N];else{const k=x(S,C-1);m[N]=a?y[k]+m[k]:y[N]+m[k]}}const w=t.makeTensorInfo(h.shape,p,m);if(u!=null){const S=Uo(u),C=Fs({inputs:{x:w},backend:t,attrs:{perm:S}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),C}return w}const Wfe={kernelName:Op,backendName:"cpu",kernelFunc:jfe};function Gfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const u=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=WE(u,h,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const u=t.bufferSync(r),h=t.bufferSync(i),d=SV(u,h,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Hfe={kernelName:Nb,backendName:"cpu",kernelFunc:Gfe};function qfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s;D(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=r.shape[0],u=r.shape[1],h=r.shape[2],d=r.shape[3],p=u*i,m=h*i,y=d/(i*i),b=t.data.get(r.dataId).values,x=new Float32Array(o*p*m*y);let w=0;for(let S=0;S<o;++S)for(let C=0;C<p;++C){const N=Math.floor(C/i),k=C%i;for(let E=0;E<m;++E){const _=Math.floor(E/i),R=E%i,O=(k*i+R)*y;for(let F=0;F<y;++F){const A=F+O+d*(_+h*(N+u*S));x[w++]=b[A]}}}return t.makeTensorInfo([o,p,m,y],r.dtype,x)}const Kfe={kernelName:kb,backendName:"cpu",kernelFunc:qfe};function C4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u,dimRoundingMode:h}=s;De([r,i],"depthwiseConv2DNative");const d=ze(r.shape),p=ze(i.shape);let m=u;m==null&&(m=[1,1]),D(Zn(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);const y=Vn(r.shape,i.shape,a,m,o,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:S,padInfo:C}=y,N=C.left,k=C.top,E=y.outChannels/y.inChannels,_=new bn(y.outShape,r.dtype),R=t.data.get(r.dataId).values,O=t.data.get(i.dataId).values,F=_.values;for(let L=0;L<y.batchSize;++L){const A=L*d[0],U=L*_.strides[0];for(let Y=0;Y<y.outHeight;++Y){const te=U+Y*_.strides[1],Z=Y*y.strideHeight-k;for(let B=0;B<b;++B){const V=Z+B*w;if(V<0||V>=y.inHeight)continue;const j=B*p[0],ee=A+V*d[1];for(let ae=0;ae<y.outWidth;++ae){const P=te+ae*_.strides[2],H=ae*y.strideWidth-N;for(let ne=0;ne<x;++ne){const ce=H+ne*S;if(ce<0||ce>=y.inWidth)continue;const me=j+ne*p[1],de=ee+ce*y.inChannels;let Se=P,Te=me;for(let Ee=0;Ee<y.inChannels;++Ee){const Ve=R[de+Ee];for(let je=0;je<E;++je)F[Se+je]+=Ve*O[Te+je];Se+=E,Te+=E}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const Xfe={kernelName:Fp,backendName:"cpu",kernelFunc:C4};function Yfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:h,filterShape:d}=s;De([r,i],"depthwiseConv2dNativeBackpropFilter");const p=Vn(r.shape,d,a,o,u,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=p,w=new bn(p.filterShape,"float32"),S=p.padInfo.left,C=p.padInfo.top,N=p.outChannels/p.inChannels,k=t.data.get(r.dataId).values,E=new bn(r.shape,r.dtype,k),_=t.data.get(i.dataId).values,R=new bn(i.shape,i.dtype,_);for(let O=0;O<b;++O){const F=Math.max(0,Math.ceil((C-O)/m)),L=Math.min(p.outHeight,(p.inHeight+C-O)/m);for(let A=0;A<x;++A){const U=Math.max(0,Math.ceil((S-A)/y)),Y=Math.min(p.outWidth,(p.inWidth+S-A)/y);for(let te=0;te<p.outChannels;++te){const Z=Math.trunc(te/N),B=te%N;let V=0;for(let j=0;j<p.batchSize;++j)for(let ee=F;ee<L;++ee){const ae=O+ee*m-C;for(let P=U;P<Y;++P){const H=A+P*y-S;V+=E.get(j,ae,H,Z)*R.get(j,ee,P,te)}}w.set(V,O,A,Z,B)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const Jfe={kernelName:Eb,backendName:"cpu",kernelFunc:Yfe};function Zfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:h,inputShape:d}=s;De([r,i],"depthwiseConv2DNativeBackpropInput");const p=ze(r.shape),m=ze(i.shape),y=Vn(d,i.shape,a,o,u,h,!0),b=new bn(y.inShape,"float32"),x=b.values,[w,S,C]=b.strides,N=t.data.get(r.dataId).values,[k,E,_]=p,R=t.data.get(i.dataId).values,[O,F,L]=m,{batchSize:A,filterHeight:U,filterWidth:Y,inChannels:te,inHeight:Z,inWidth:B,outChannels:V,outHeight:j,outWidth:ee,strideHeight:ae,strideWidth:P}=y,H=U-1-y.padInfo.top,ne=Y-1-y.padInfo.left,ce=V/te;for(let me=0;me<A;++me)for(let de=0;de<te;++de)for(let Se=0;Se<Z;++Se){const Te=Se-H,Ee=Math.max(0,Math.ceil(Te/ae)),Ve=Math.min(j,(U+Te)/ae);for(let je=0;je<B;++je){const Ye=je-ne,ft=Math.max(0,Math.ceil(Ye/P)),bt=Math.min(ee,(Y+Ye)/P);let St=0;for(let xt=Ee;xt<Ve;++xt){const Pt=xt*ae-Te;for(let _t=ft;_t<bt;++_t){const nr=_t*P-Ye,nn=k*me+E*xt+_*_t,kr=O*(U-1-Pt)+F*(Y-1-nr)+L*de;for(let Ts=0;Ts<ce;++Ts){const Xi=de*ce+Ts,Vt=N[nn+Xi],Xr=R[kr+Ts];St+=Vt*Xr}}}x[w*me+S*Se+C*je+de]=St}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const Qfe={kernelName:$b,backendName:"cpu",kernelFunc:Zfe};function epe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=he(s.shape),i=t.data.get(s.dataId).values,a=Qe([r,r],s.dtype),o=a.values;for(let h=0;h<i.length;h++)o[h*r+h]=i[h];const u=[...s.shape,...s.shape];return t.makeTensorInfo(u,a.dtype,a.values)}const tpe={kernelName:Ib,backendName:"cpu",kernelFunc:epe};const npe={kernelName:Lp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:a,dilations:o}=t,u=e,h=u.data.get(s.dataId).values,d=s.shape.length,p=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:S,outWidth:C,padInfo:N,strideHeight:k,strideWidth:E,filterHeight:_,filterWidth:R,dilationHeight:O,dilationWidth:F,outShape:L}=Nm(s.shape,r.shape,i,a,"NHWC",o),A=he(L),U=L.length,Y=tn(s.dtype,A);for(let Z=0;Z<y;++Z)for(let B=0;B<S;++B){const V=B*k-N.top;for(let j=0;j<C;++j){const ee=j*E-N.left;for(let ae=0;ae<w;++ae){let P=Number.MIN_SAFE_INTEGER;for(let ne=0;ne<_;++ne){const ce=V+ne*O;if(ce>=0&&ce<b)for(let me=0;me<R;++me){const de=ee+me*F;if(de>=0&&de<x){const Se=hi([Z,ce,de,ae],d,ze(s.shape)),Te=hi([ne,me,ae],m,ze(r.shape)),Ee=h[Se]+p[Te];Ee>P&&(P=Ee)}}}const H=hi([Z,B,j,ae],U,ze(L));Y[H]=P}}}return{dataId:u.write(Po(Y,s.dtype),L,s.dtype),shape:L,dtype:s.dtype}}};const spe={kernelName:$0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:u}=t,h=e,d=vr(s.shape,h.data.get(s.dataId).values),p=vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:C,strideHeight:N,strideWidth:k,filterHeight:E,filterWidth:_,dilationHeight:R,dilationWidth:O,outShape:F}=Nm(s.shape,r.shape,a,o,"NHWC",u);D(i.rank===F.length,()=>`Error in ${$0}, dy must have the same rank as output ${F.length}, but got ${i.rank}`);const L=vr(F,h.data.get(i.dataId).values),A=c2(r.shape,r.dtype);for(let Y=0;Y<m;++Y)for(let te=0;te<w;++te){const Z=te*N-C.top;for(let B=0;B<S;++B){const V=B*k-C.left;for(let j=0;j<x;++j){let ee=Number.MIN_SAFE_INTEGER,ae=0,P=0;for(let H=0;H<E;++H){const ne=Z+H*R;if(ne>=0&&ne<y)for(let ce=0;ce<_;++ce){const me=V+ce*O;if(me>=0&&me<b){const de=d[Y][ne][me][j]+p[H][ce][j];de>ee&&(ee=de,ae=H,P=ce)}}}A[ae][P][j]+=L[Y][te][B][j]}}}return{dataId:h.write(Po(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const rpe={kernelName:E0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:u}=t,h=e,d=vr(s.shape,h.data.get(s.dataId).values),p=vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:C,strideHeight:N,strideWidth:k,filterHeight:E,filterWidth:_,dilationHeight:R,dilationWidth:O,outShape:F}=Nm(s.shape,r.shape,a,o,"NHWC",u);D(i.rank===F.length,()=>`Error in ${E0}, dy must have the same rank as output ${F.length}, but got ${i.rank}`);const L=vr(F,h.data.get(i.dataId).values),A=c2(s.shape,s.dtype);for(let Y=0;Y<m;++Y)for(let te=0;te<w;++te){const Z=te*N-C.top;for(let B=0;B<S;++B){const V=B*k-C.left;for(let j=0;j<x;++j){let ee=Number.MIN_SAFE_INTEGER,ae=Z<0?0:Z,P=V<0?0:V;for(let H=0;H<E;++H){const ne=Z+H*R;if(ne>=0&&ne<y)for(let ce=0;ce<_;++ce){const me=V+ce*O;if(me>=0&&me<b){const de=d[Y][ne][me][j]+p[H][ce][j];de>ee&&(ee=de,ae=ne,P=me)}}}A[Y][ae][P][j]+=L[Y][te][B][j]}}}return{dataId:h.write(Po(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function ipe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,{contextOptions:o,imageOptions:u}=a||{},h=u?.alpha||1,d=o?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const p=i.getContext(d,o?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],x=t.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,S=new Uint8ClampedArray(y*m*4);for(let N=0;N<m*y;++N){const k=[0,0,0,255*h];for(let _=0;_<b;_++){const R=x[N*b+_];if(r.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(r.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);b===1?(k[0]=R*w,k[1]=R*w,k[2]=R*w):k[_]=R*w}const E=N*4;S[E+0]=Math.round(k[0]),S[E+1]=Math.round(k[1]),S[E+2]=Math.round(k[2]),S[E+3]=Math.round(k[3])}i.width=y,i.height=m;const C=new ImageData(S,y,m);return p.putImageData(C,0,0),r}const ape={kernelName:_b,backendName:"cpu",kernelFunc:ipe};function ng(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;De(r,"sum");let o;r.dtype==="bool"?o=Mo({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):o=Gi({inputs:{x:r},backend:t});const u=o.shape.length,h=st(i,o.shape),d=Zt(h,u);let p=h,m=o;d!=null&&(m=Fs({inputs:{x:o},backend:t,attrs:{perm:d}}),p=cn(p.length,u)),Qn("sum",p,m.shape.length);const[y,b]=Un(m.shape,p),x=_s(m.dtype,"int32");let w=H0(t,y,x);const S=he(b),C=t.data.get(w.dataId).values,N=t.data.get(m.dataId).values;for(let k=0;k<C.length;++k){const E=k*S;let _=0;for(let R=0;R<S;++R)_+=N[E+R];C[k]=_}if(a){const k=un(w.shape,h),E=w;w=zt({inputs:{x:w},backend:t,attrs:{shape:k}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(o),d!=null&&t.disposeIntermediateTensorInfo(m),w}const ope={kernelName:mm,backendName:"cpu",kernelFunc:ng};function lpe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:u}=tk(r,i.length);sk(a.length,u,i);const{path:h,steps:d}=rk(o,u),p=d.length;let m=null,y=a.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:C}=nk(y,u[w]);let N;ik(S)?N=i[w]:(N=Fs({inputs:{x:i[w]},backend:t,attrs:{perm:S}}),b.push(N));const k=N.shape.slice();for(let E=0;E<C.length;++E)k.splice(C[E],0,1);it(N.shape,k)||(N=zt({inputs:{x:N},backend:t,attrs:{shape:k}}),b.push(N)),m===null?m=N:(m=Iw({inputs:{a:N,b:m},backend:t}),b.push(m))}x<p-1&&(h[x]>=0&&(m=ng({inputs:{x:m},backend:t,attrs:{axis:h[x]-(a.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const upe={kernelName:Ab,backendName:"cpu",kernelFunc:lpe};function cpe(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;De([s,r],"eluGrad");const i=new Float32Array(he(r.shape)),a=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values;for(let u=0;u<a.length;++u){const h=a[u];h>=0?i[u]=o[u]:i[u]=o[u]*(h+1)}return t.makeTensorInfo(r.shape,"float32",i)}const hpe={kernelName:Rb,backendName:"cpu",kernelFunc:cpe};const dpe=KN,fpe=XN,ppe=YN,mpe=JN,gpe=ZN,ype=QN,bpe=Nt(ph,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+dpe*t);return e*(1-((((ype*s+gpe)*s+mpe)*s+ppe)*s+fpe)*s*Math.exp(-t*t))}),xpe={kernelName:ph,backendName:"cpu",kernelFunc:bpe};function X0(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,a=r.shape.length,o=r.shape.slice();let u=i;return i<0&&(D(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+i+1),o.splice(u,0,1),zt({inputs:{x:r},backend:t,attrs:{shape:o}})}const wpe={kernelName:zp,backendName:"cpu",kernelFunc:X0};const vpe=dn((n,e)=>n/e),YE=An(dh,vpe),cC={kernelName:dh,backendName:"cpu",kernelFunc:YE};function N4(n,e,t){const s=n.shape,r=s[0],i=s[1],a=t.data.get(n.dataId),o=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,h=[r,i],d=he(h),p=zn("float32",d),m=zn("float32",d);for(let w=0;w<r;w++){const S=iu({inputs:{x:o},backend:t,attrs:{begin:[w,0],size:[1,i]}}),C=iu({inputs:{x:u},backend:t,attrs:{begin:[w,0],size:[1,i]}}),N=Ks({inputs:{real:S,imag:C},backend:t}),{real:k,imag:E}=Spe(N,e,t),_=$a(k,E);for(let R=0;R<i;R++){const O=ek(_,R);p[w*i+R]=O.real,m[w*i+R]=O.imag}t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(N)}const y=t.makeTensorInfo(h,"float32",p),b=t.makeTensorInfo(h,"float32",m),x=Ks({inputs:{real:y,imag:b},backend:t});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}function Spe(n,e,t){const s=he(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(Tpe(s)){const o=hC(i,a,s,e,t),u=[n.shape[0],n.shape[1]];if(e){const h=t.makeTensorInfo(u,"float32",o.real),d=t.makeTensorInfo(u,"float32",o.imag),p=t.makeTensorInfo([],"float32",Da(s,"float32")),m=Gi({inputs:{x:p},backend:t}),y=cC.kernelFunc({inputs:{a:h,b:p},backend:t}),b=cC.kernelFunc({inputs:{a:d,b:m},backend:t}),x=t.data.get(y.dataId).values,w=t.data.get(b.dataId).values;return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return o}else{const o=$a(i,a),u=Cpe(o,s,e);return gP(u)}}function Tpe(n){return(n&n-1)===0}function hC(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=$a(n,e),a=t/2,o=yP(i),u=o.real,h=o.imag,d=[u.length],p=r.makeTensorInfo(d,"float32",u),m=r.makeTensorInfo(d,"float32",h),y=Ks({inputs:{real:p,imag:m},backend:r}),b=bP(i),x=b.real,w=b.imag,S=[x.length],C=r.makeTensorInfo(S,"float32",x),N=r.makeTensorInfo(S,"float32",w),k=Ks({inputs:{real:C,imag:N},backend:r}),E=hC(u,h,a,s,r),_=E.real,R=E.imag,O=[_.length],F=r.makeTensorInfo(O,"float32",_),L=r.makeTensorInfo(O,"float32",R),A=Ks({inputs:{real:F,imag:L},backend:r}),U=hC(x,w,a,s,r),Y=U.real,te=U.imag,Z=[Y.length],B=r.makeTensorInfo(Z,"float32",Y),V=r.makeTensorInfo(Z,"float32",te),j=Ks({inputs:{real:B,imag:V},backend:r}),ee=wP(t,s),ae=[ee.real.length],P=r.makeTensorInfo(ae,"float32",ee.real),H=r.makeTensorInfo(ae,"float32",ee.imag),ne=Ks({inputs:{real:P,imag:H},backend:r}),ce=Iw({inputs:{a:ne,b:j},backend:r}),me=Kc({inputs:{a:A,b:ce},backend:r}),de=KE({inputs:{a:A,b:ce},backend:r}),Se=ru({inputs:{input:me},backend:r}),Te=ru({inputs:{input:de},backend:r}),Ee=Xc({inputs:{input:me},backend:r}),Ve=Xc({inputs:{input:de},backend:r}),je=Yc({inputs:[Se,Te],backend:r,attrs:{axis:0}}),Ye=Yc({inputs:[Ee,Ve],backend:r,attrs:{axis:0}}),ft=r.data.get(je.dataId).values,bt=r.data.get(Ye.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(ce),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(de),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(Ve),r.disposeIntermediateTensorInfo(je),r.disposeIntermediateTensorInfo(Ye),{real:ft,imag:bt}}function Cpe(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,a=0;for(let o=0;o<e;o++){const u=vP(r*o,e,t),h=ek(n,o);i+=h.real*u.real-h.imag*u.imag,a+=h.real*u.imag+h.imag*u.real}t&&(i/=e,a/=e),xP(s,i,a,r)}return s}function Npe(n){const{inputs:e,backend:t}=n,{input:s}=e,r=he(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=zt({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),u=N4(o,!1,t),h=zt({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),h}const kpe={kernelName:Db,backendName:"cpu",kernelFunc:Npe};function JE(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,a=i||cu(r),o=tn(a,he(s));return $pe(o,r,a),e.makeTensorInfo(s,a,o)}const Epe={kernelName:Ob,backendName:"cpu",kernelFunc:JE};function $pe(n,e,t){n.fill(e)}const Ipe={kernelName:Fb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=zn(s.dtype,he(s.shape)),[a,o,u,h]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<a;m++){const y=m*u*o*h;for(let b=0;b<o;b++){const x=b*(u*h);for(let w=0;w<u;w++){const S=w*h;for(let C=0;C<h;C++){const N=Math.round(u-w-1),k=y+x+S+C;let E=d[k];if(N>=0&&N<u){const _=N*h,R=y+x+_+C;E=d[R]}i[k]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function _pe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=T4({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(a){const w=x;if(d==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const S=zt({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});x=Kc({inputs:{a:x,b:S},backend:t}),t.disposeIntermediateTensorInfo(S)}else x=Kc({inputs:{a:x,b:a},backend:t});t.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const S=zt({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});x=K0(t,x,y,S,b),t.disposeIntermediateTensorInfo(S)}else x=K0(t,x,y,o,b);t.disposeIntermediateTensorInfo(w)}return x}const Ape={kernelName:Yf,backendName:"cpu",kernelFunc:_pe};function Rpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=C4({inputs:{x:r,filter:i},backend:t,attrs:{strides:u,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(a){const w=x;x=Kc({inputs:{a:x,b:a},backend:t}),t.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=K0(t,x,y,o,b),t.disposeIntermediateTensorInfo(w)}return x}const Dpe={kernelName:Jf,backendName:"cpu",kernelFunc:Rpe};function Ope(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=he(s.shape),a=r.shape,o=a[a.length-1],[u,h,d,p]=sw(s,r);if(h===0)return t.makeTensorInfo(u,s.dtype,[]);const m=t.data.get(r.dataId).values,y=t.bufferSync(s),b=DV(m,y,s.dtype,h,o,d,p,s.shape,i);return t.makeTensorInfo(u,s.dtype,b.values)}const Fpe={kernelName:Lb,backendName:"cpu",kernelFunc:Ope};function Lpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s;De([r,i],"gatherV2");const u=st(a,r.shape)[0],h=t.data.get(i.dataId).values,d=r.shape[u];for(let k=0;k<h.length;++k){const E=h[k];D(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=o;o==null&&(p=0);const m=he(i.shape),y=ok(r,i,u,p),b=zt({inputs:{x:r},backend:t,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=zt({inputs:{x:i},backend:t,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],S=t.bufferSync(x),C=t.bufferSync(b),N=OV(C,S,w);return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.makeTensorInfo(y.outputShape,N.dtype,N.values)}const Mpe={kernelName:Bp,backendName:"cpu",kernelFunc:Lpe};function zpe(n){const{inputs:e,backend:t}=n,{input:s}=e,r=he(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=zt({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),u=N4(o,!0,t),h=zt({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),h}const Ppe={kernelName:Mb,backendName:"cpu",kernelFunc:zpe};const Bpe=Nt(vh,n=>Number.isFinite(n)?1:0,"bool"),Vpe={kernelName:vh,backendName:"cpu",kernelFunc:Bpe};const Upe=Nt(Sh,n=>Math.abs(n)===1/0?1:0,"bool"),jpe={kernelName:Sh,backendName:"cpu",kernelFunc:Upe};const Wpe=Nt(Th,n=>Number.isNaN(n)?1:0,"bool"),Gpe={kernelName:Th,backendName:"cpu",kernelFunc:Wpe};function Hpe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=PV(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const qpe={kernelName:Pb,backendName:"cpu",kernelFunc:Hpe};const Kpe=Nt(Nh,n=>Math.log1p(n)),Xpe={kernelName:Nh,backendName:"cpu",kernelFunc:Kpe};const Ype=dn((n,e)=>n&&e),Jpe=An(Gp,Ype,null,"bool"),Zpe={kernelName:Gp,backendName:"cpu",kernelFunc:Jpe};const Qpe=Nt(Hp,n=>n?0:1,"bool"),eme={kernelName:Hp,backendName:"cpu",kernelFunc:Qpe};const tme=dn((n,e)=>n||e),nme=An(qp,tme,null,"bool"),sme={kernelName:qp,backendName:"cpu",kernelFunc:nme};function rme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:u}=s;De(r,"LRN");const h=r.shape[3],d=h-1,p=t.data.get(r.dataId).values,m=he(r.shape),y=new Float32Array(m);function b(x){const w=x%h;let S=x-w+Math.max(0,w-i);const C=x-w+Math.min(w+i,d);let N=0;for(;S<=C;S++){const k=p[S];N+=k*k}return N}for(let x=0;x<m;x++){const w=b(x),S=p[x]*Math.pow(a+o*w,-u);y[x]=S}return t.makeTensorInfo(r.shape,r.dtype,y)}const ime={kernelName:Kp,backendName:"cpu",kernelFunc:rme};function ame(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:u,alpha:h,beta:d}=s;De(a,"LRNGrad");const p=he(a.shape),m=a.shape[3],y=t.data.get(a.dataId).values,b=t.data.get(r.dataId).values,x=t.data.get(i.dataId).values,w=new Float32Array(p),S=p;for(let C=0;C<S;C++){const N=C%m,k=C-N+Math.max(0,N-o),E=C-N+Math.min(m,N+o+1);let _=0;for(let R=k;R<E;R++)_+=Math.pow(b[R],2);_=h*_+u;for(let R=k;R<E;R++){let O=-2*h*d*b[R]*x[C]/_;C===R&&(O+=Math.pow(_,-d)),O*=y[C],w[R]+=O}}return t.makeTensorInfo(a.shape,r.dtype,w)}const ome={kernelName:Bb,backendName:"cpu",kernelFunc:ame};function k4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=t;let u=r.shape;const h=u.length,d=st(i,u);let p=d;const m=Zt(p,h);let y=o.data.get(r.dataId).values;if(m!=null){const k=new Array(h);for(let E=0;E<k.length;E++)k[E]=u[m[E]];y=HE(y,u,r.dtype,m,k),p=cn(p.length,h),u=k}De(r,"max"),Qn("max",p,h);const[b,x]=Un(u,p),w=he(x),S=VV(y,w,b,r.dtype),C=o.write(S,b,r.dtype);let N=b;return a&&(N=un(b,d)),{dataId:C,shape:N,dtype:r.dtype}}const lme={kernelName:Xp,backendName:"cpu",kernelFunc:k4};function ume(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;De(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,h=1;D(Zn(a,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Hr(r.shape,i,a,h,o,u);let p;if(d.filterWidth===1&&d.filterHeight===1&&it(d.inShape,d.outShape))p=Gi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=ze(r.shape),b=XE(m,r.shape,r.dtype,y,d,"max");p=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const cme={kernelName:Yp,backendName:"cpu",kernelFunc:ume};function hme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:h}=s;De(r,"maxPool3d");const d=Oa(r.shape,i,a,1,o,u,h),p=t.data.get(r.dataId).values,m=S4(p,r.shape,r.dtype,ze(r.shape),d,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const dme={kernelName:Jp,backendName:"cpu",kernelFunc:hme};function fme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:u,dimRoundingMode:h}=s;De([r,i],"maxPool3DGrad");const d=Oa(i.shape,a,o,1,u,h),p=t.bufferSync(i),m=tfe(p,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,S=d.dilationHeight,C=d.dilationWidth,N=d.effectiveFilterDepth,k=d.effectiveFilterHeight,E=d.effectiveFilterWidth,_=N-1-d.padInfo.front,R=E-1-d.padInfo.left,O=k-1-d.padInfo.top,F=Qe(i.shape,"float32"),L=t.bufferSync(r);for(let A=0;A<d.batchSize;++A)for(let U=0;U<d.inChannels;++U)for(let Y=0;Y<d.inDepth;++Y)for(let te=0;te<d.inHeight;++te)for(let Z=0;Z<d.inWidth;++Z){const B=Y-_,V=te-O,j=Z-R;let ee=0;for(let ae=0;ae<N;ae+=w){const P=(B+ae)/y;if(!(P<0||P>=d.outDepth||Math.floor(P)!==P))for(let H=0;H<k;H+=S){const ne=(V+H)/b;if(!(ne<0||ne>=d.outHeight||Math.floor(ne)!==ne))for(let ce=0;ce<E;ce+=C){const me=(j+ce)/x;if(me<0||me>=d.outWidth||Math.floor(me)!==me)continue;const de=N*k*E-1-m.get(A,P,ne,me,U),Se=ae*k*E+H*E+ce,Te=de===Se?1:0;if(Te===0)continue;const Ee=L.get(A,P,ne,me,U);ee+=Ee*Te}}}F.set(ee,A,Y,te,Z,U)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const pme={kernelName:Ub,backendName:"cpu",kernelFunc:fme};function mme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;De([i,a],"maxPoolGrad");const{filterSize:u,strides:h,pad:d,dimRoundingMode:p}=s,m=Hr(o.shape,u,h,1,d,p),y=t.data.get(o.dataId).values,b=Qe(m.outShape,o.dtype,v4(y,o.shape,o.dtype,m).values),x=m.strideHeight,w=m.strideWidth,S=m.dilationHeight,C=m.dilationWidth,N=m.effectiveFilterHeight,k=m.effectiveFilterWidth,E=k-1-m.padInfo.left,_=N-1-m.padInfo.top,R=Qe(o.shape,"float32"),O=t.data.get(r.dataId).values,F=Qe(r.shape,"float32",O);for(let L=0;L<m.batchSize;++L)for(let A=0;A<m.inChannels;++A)for(let U=0;U<m.inHeight;++U)for(let Y=0;Y<m.inWidth;++Y){const te=U-_,Z=Y-E;let B=0;for(let V=0;V<N;V+=S){const j=(te+V)/x;if(!(j<0||j>=m.outHeight||Math.floor(j)!==j))for(let ee=0;ee<k;ee+=C){const ae=(Z+ee)/w;if(ae<0||ae>=m.outWidth||Math.floor(ae)!==ae)continue;const P=N*k-1-b.get(L,j,ae,A),H=V*k+ee,ne=P===H?1:0;if(ne===0)continue;const ce=F.get(L,j,ae,A);B+=ce*ne}}R.set(B,L,U,Y,A)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const gme={kernelName:Vb,backendName:"cpu",kernelFunc:mme};function yme(n,e,t,s,r){const i=ze(e),a=XE(n,e,t,i,r,"max"),o=v4(n,e,t,r,!0,s);return[a.values,o.values]}const bme={kernelName:jb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,u=t;De(s,"MaxPoolWithArgmax");const h=u.data.get(s.dataId).values,d=Hr(s.shape,r,i,[1,1],a),[p,m]=yme(h,s.shape,s.dtype,o,d),y=u.write(p,d.outShape,s.dtype),b=u.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function xme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=st(i,r.shape),h=Un(r.shape,o)[1],d=he(h),p=[],m=t.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const y=Mo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});p.push(y);const b=YE({inputs:{a:y,b:m},backend:t});p.push(b);const x=ng({inputs:{x:b},backend:t,attrs:{axis:i,keepDims:a}});return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const wme={kernelName:Zp,backendName:"cpu",kernelFunc:xme};function vme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;De(r,"min");const o=st(i,r.shape);let u=o;const h=Zt(u,r.shape.length);let d=r;h!=null&&(d=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),u=cn(u.length,r.shape.length)),Qn("min",u,d.shape.length);const[p,m]=Un(d.shape,u),y=he(m),b=Yn(he(p),d.dtype),x=t.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const C=S*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];(Number.isNaN(E)||E<N)&&(N=E)}b[S]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(a){const S=un(p,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(w),C}return w}const Sme={kernelName:Qp,backendName:"cpu",kernelFunc:vme};function Tme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:a}=s;De(r,"mirrorPad");const o=i.map((N,k)=>N[0]+r.shape[k]+N[1]),u=i.map(N=>N[0]),h=i.map((N,k)=>N[0]+r.shape[k]),d=a==="reflect"?0:1,p=t.data.get(r.dataId).values,m=r.shape.length,y=ze(r.shape),b=he(o),x=o.length,w=ze(o),S=zn(r.dtype,b);for(let N=0;N<b;N++){let k=hu(N,x,w);for(let _=0;_<x;_++)k[_]<u[_]?k[_]=u[_]*2-k[_]-d:k[_]>=h[_]&&(k[_]=(h[_]-1)*2-k[_]+d);k=k.map((_,R)=>_-u[R]);const E=hi(k,m,y);S[N]=p[E]}return{dataId:t.write(S,o,r.dtype),shape:o,dtype:r.dtype}}const Cme={kernelName:em,backendName:"cpu",kernelFunc:Tme};const Nme=dn(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),kme=An($h,Nme),Eme={kernelName:$h,backendName:"cpu",kernelFunc:kme};function E4(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=r.shape.length;let o=i;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const u=st([o],r.shape),h=k4({inputs:{x:r},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),d=un(h.shape,u),p=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),m=KE({inputs:{a:r,b:p},backend:t}),y=IV({inputs:{x:m},backend:t}),b=ng({inputs:{x:y},backend:t,attrs:{axis:u,keepDims:!1}}),x=zt({inputs:{x:b},backend:t,attrs:{shape:d}}),w=YE({inputs:{a:y,b:x},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const $me={kernelName:bm,backendName:"cpu",kernelFunc:E4};function Ime(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s;De(r,"multinomial");const u=o?r:E4({inputs:{logits:r},backend:t,attrs:{dim:-1}}),h=u.shape[0],d=u.shape[1],p=t.data.get(u.dataId).values,m=[h,i],y=Yn(he(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=p[x];for(let N=1;N<w.length;++N)w[N]=w[N-1]+p[x+N];const S=td.alea(a.toString()),C=b*i;for(let N=0;N<i;++N){const k=S();y[C+N]=w.length;for(let E=0;E<w.length;E++)if(k<w[E]){y[C+N]=E;break}}}return o||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(m,"int32",y)}const _me={kernelName:Wb,backendName:"cpu",kernelFunc:Ime};const Ame=Qx;function Rme(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s;De(r,"NonMaxSuppression");const h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:p}=Ame(h,d,a,o,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Dme={kernelName:Gb,backendName:"cpu",kernelFunc:Rme};const Ome=ew;function Fme(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:h}=s;De(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,{selectedIndices:m,validOutputs:y}=Ome(d,p,a,o,u,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const Lme={kernelName:Hb,backendName:"cpu",kernelFunc:Fme};const Mme=tw;function zme(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:h}=s;De(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,m=a,y=o,b=u,x=h,{selectedIndices:w,selectedScores:S}=Mme(d,p,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const Pme={kernelName:qb,backendName:"cpu",kernelFunc:zme};function Bme(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:u}=s;De(r,"oneHot");const h=he(r.shape),d=new Float32Array(h*a);d.fill(u);const p=t.data.get(r.dataId).values;for(let m=0;m<h;++m)p[m]>=0&&p[m]<a&&(d[m*a+p[m]]=o);return t.makeTensorInfo([...r.shape,a],i,d)}const Vme={kernelName:rm,backendName:"cpu",kernelFunc:Bme};function Y0(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=ru({inputs:{input:s},backend:t}),i=Y0({inputs:{x:r},backend:t}),a=Xc({inputs:{input:s},backend:t}),o=Y0({inputs:{x:a},backend:t}),u=Ks({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return JE({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Ume={kernelName:Sm,backendName:"cpu",kernelFunc:Y0};function $4(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=ru({inputs:{input:s},backend:t}),i=$4({inputs:{x:r},backend:t}),a=Xc({inputs:{input:s},backend:t}),o=Y0({inputs:{x:a},backend:t}),u=Ks({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return JE({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const jme={kernelName:sm,backendName:"cpu",kernelFunc:$4};function I4(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return X0({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{Jn(i,d.shape,"All tensors passed to stack must have matching shapes"),D(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(d=>{const p=X0({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),h=Yc({inputs:u,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const Wme={kernelName:im,backendName:"cpu",kernelFunc:I4};function Gme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;De(r,"pad");const o=i.map((C,N)=>C[0]+r.shape[N]+C[1]),u=i.map(C=>C[0]),h=t.data.get(r.dataId).values,d=he(r.shape),p=r.shape.length,m=ze(r.shape),y=he(o),b=o.length,x=ze(o),w=zn(r.dtype,y);a!==0&&w.fill(a);for(let C=0;C<d;C++){const k=hu(C,p,m).map((_,R)=>_+u[R]),E=hi(k,b,x);w[E]=h[C]}return{dataId:t.write(w,o,r.dtype),shape:o,dtype:r.dtype}}const _4={kernelName:am,backendName:"cpu",kernelFunc:Gme};const Hme=dn((n,e)=>Math.pow(n,e)),qme=An(_h,Hme),Kme={kernelName:_h,backendName:"cpu",kernelFunc:qme};function Xme(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,u=r.map(S=>t.data.get(S.dataId).values),h=r.map(S=>S.shape),d=t.data.get(i.dataId).values,p=t.data.get(a.dataId).values,[m,y,b]=qV(u,h,d,i.shape,i.dtype,p,a.shape),x=m.map(S=>t.makeTensorInfo([S.length],"int32",S)),w=t.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const Yme={kernelName:Kb,backendName:"cpu",kernelFunc:Xme};function Jme(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[h,d]=KV(a,s.shape,s.dtype,o,r.shape,u,i.shape),p=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Zme={kernelName:Xb,backendName:"cpu",kernelFunc:Jme};function Qme(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:u}=s,h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,p=t.data.get(a.dataId).values,m=o.map(w=>t.data.get(w.dataId).values),y=o.map(w=>w.shape),[b,x]=XV(h,r.shape,d,i.shape,i.dtype,p,a.shape,m,y,u);return t.makeTensorInfo(b,i.dtype,x)}const ege={kernelName:Yb,backendName:"cpu",kernelFunc:Qme};function tge(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:a}=t,o=YV(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}const nge={kernelName:Jb,backendName:"cpu",kernelFunc:tge};const sge=Nt(Ah,n=>1/n),rge={kernelName:Ah,backendName:"cpu",kernelFunc:sge};function ige(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;De(r,"resizeBilinear");const u=ze(r.shape),[h,d]=o,[p,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(he([p,h,d,b])),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],C=[i&&h>1?h-1:h,i&&d>1?d-1:d];let N=0;const k=S[0]/C[0],E=S[1]/C[1];for(let _=0;_<p;_++)for(let R=0;R<h;R++){let O;a?O=k*(R+.5)-.5:O=k*R;const F=Math.max(0,Math.floor(O)),L=O-F,A=Math.min(m-1,Math.ceil(O)),U=_*u[0]+F*u[1],Y=_*u[0]+A*u[1];for(let te=0;te<d;te++){let Z;a?Z=E*(te+.5)-.5:Z=E*te;const B=Math.max(0,Math.floor(Z)),V=Z-B,j=Math.min(y-1,Math.ceil(Z)),ee=U+B*u[2],ae=Y+B*u[2],P=U+j*u[2],H=Y+j*u[2];for(let ne=0;ne<b;ne++){const ce=x[ee+ne],me=x[ae+ne],de=x[P+ne],Se=x[H+ne],Te=ce+(de-ce)*V,Ee=me+(Se-me)*V,Ve=Te+(Ee-Te)*L;w[N++]=Ve}}}return t.makeTensorInfo([p,h,d,b],"float32",w)}const age={kernelName:hm,backendName:"cpu",kernelFunc:ige};function oge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;De([i,r],"resizeBilinearGrad");const o=ze(r.shape),[u,h,d,p]=r.shape,[,m,y]=i.shape,b=new Float32Array(u*h*d*p),x=[a&&m>1?h-1:h,a&&y>1?d-1:d],w=[a&&m>1?m-1:m,a&&y>1?y-1:y],S=x[0]/w[0],C=x[1]/w[1],N=t.data.get(i.dataId).values;let k=0;for(let E=0;E<u;E++){const _=E*o[0];for(let R=0;R<m;R++){const O=R*S,F=Math.floor(O),L=Math.min(Math.ceil(O),h-1),A=_+F*o[1],U=_+L*o[1],Y=O-F,te=1-Y;for(let Z=0;Z<y;Z++){const B=Z*C,V=Math.floor(B),j=Math.min(Math.ceil(B),d-1),ee=B-V,ae=1-ee,P=A+V*o[2],H=A+j*o[2],ne=U+V*o[2],ce=U+j*o[2],me=te*ae,de=te*ee,Se=Y*ae,Te=Y*ee;for(let Ee=0;Ee<p;Ee++){const Ve=N[k++];b[P+Ee]+=Ve*me,b[H+Ee]+=Ve*de,b[ne+Ee]+=Ve*Se,b[ce+Ee]+=Ve*Te}}}}return t.makeTensorInfo([u,d,h,p],"float32",b)}const lge={kernelName:ex,backendName:"cpu",kernelFunc:oge};function uge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;De(r,"resizeNearestNeighbor");const u=ze(r.shape),[h,d]=o,[p,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(p*h*d*b),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],C=[i&&h>1?h-1:h,i&&d>1?d-1:d],N=S[0]/C[0],k=S[1]/C[1];let E=0;for(let _=0;_<p;_++){const R=_*u[0];for(let O=0;O<h;O++){const F=a?N*(O+.5):N*O;let L=Math.min(m-1,i?Math.round(F):Math.floor(F));a&&(L=Math.max(0,L));const A=R+L*u[1];for(let U=0;U<d;U++){const Y=a?k*(U+.5):k*U;let te=Math.min(y-1,i?Math.round(Y):Math.floor(Y));a&&(te=Math.max(0,te));const Z=A+te*u[2];for(let B=0;B<b;B++){const V=x[Z+B];w[E++]=V}}}}return t.makeTensorInfo([p,h,d,b],r.dtype,w)}const cge={kernelName:cm,backendName:"cpu",kernelFunc:uge};function hge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;De([i,r],"resizeNearestNeighborGrad");const o=ze(r.shape),u=ze(i.shape),[h,d,p,m]=r.shape,[,y,b]=i.shape,x=new Float32Array(h*d*p*m),w=t.data.get(i.dataId).values,S=[a&&y>1?d-1:d,a&&b>1?p-1:p],C=[a&&y>1?y-1:y,a&&b>1?b-1:b],N=S[0]/C[0],k=S[1]/C[1],E=1/N,_=1/k,R=Math.ceil(E)*2+2,O=Math.ceil(_)*2+2;for(let F=0;F<h;F++){const L=F*o[0];for(let A=0;A<d;A++){const U=L+A*o[1],Y=Math.floor(A*E),te=Math.floor(Y-R/2);for(let Z=0;Z<p;Z++){const B=U+Z*o[2],V=Math.floor(Z*_),j=Math.floor(V-O/2);for(let ee=0;ee<m;ee++){let ae=0;for(let P=0;P<R;P++){const H=P+te;if(H<0||H>=y)continue;const ne=L+H*u[1],ce=H*N,me=Math.min(d-1,a?Math.round(ce):Math.floor(ce));if(A===me)for(let de=0;de<O;de++){const Se=de+j;if(Se<0||Se>=b)continue;const Te=ne+Se*u[2],Ee=Se*k,Ve=Math.min(p-1,a?Math.round(Ee):Math.floor(Ee));Z===Ve&&(ae+=w[Te+ee])}}x[B+ee]=ae}}}}return t.makeTensorInfo(r.shape,r.dtype,x)}const dge={kernelName:Qb,backendName:"cpu",kernelFunc:hge};function fge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;De(r,"reverse");const a=r.shape.length,o=st(i,r.shape);if(a===0)return Gi({inputs:{x:r},backend:t});const u=new bn(r.shape,r.dtype),h=t.bufferSync(r);for(let d=0;d<u.size;d++){const p=u.indexToLoc(d),m=p.slice();o.forEach(y=>m[y]=r.shape[y]-1-m[y]),u.set(h.get(...m),...p)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}const pge={kernelName:dm,backendName:"cpu",kernelFunc:fge};const mge={kernelName:yx,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,u=zn(s.dtype,he(s.shape)),[h,d,p,m]=s.shape,[y,b]=GN(a,d,p),x=255,w=Math.sin(r),S=Math.cos(r),C=o.data.get(s.dataId).values;for(let k=0;k<h;k++){const E=k*p*d*m;for(let _=0;_<d;_++){const R=_*(p*m);for(let O=0;O<p;O++){const F=O*m;for(let L=0;L<m;L++){const A=[h,_,O,L],U=A[2],Y=A[1];let te=(U-y)*S-(Y-b)*w,Z=(U-y)*w+(Y-b)*S;te=Math.round(te+y),Z=Math.round(Z+b);let B=i;if(typeof i!="number"&&(L===3?B=x:B=i[L]),te>=0&&te<p&&Z>=0&&Z<d){const j=Z*(p*m),ee=te*m,ae=E+j+ee+L;B=C[ae]}const V=E+R+F+L;u[V]=B}}}}return{dataId:o.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const gge=Nt(Oh,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),yge={kernelName:Oh,backendName:"cpu",kernelFunc:gge};function bge(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:p}=Ho(i,r,a),m=!0,y=t.bufferSync(r),b=t.bufferSync(i),x=Ol(y,b,a,p,h,u,o,d,0,m);return t.makeTensorInfo(a,x.dtype,x.values)}const xge={kernelName:tx,backendName:"cpu",kernelFunc:bge};function wge(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function vge(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function Sge(n,e,t,s,r,i){const a=tn("int32",t*r);for(let o=0;o<t;++o){const u=n.slice(o*s,(o+1)*s),h=o*r;for(let d=0;d<r;++d)a[h+d]=i==="left"?wge(u,e[d+h]):vge(u,e[d+h])}return a}function Tge(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,h=Sge(o,u,r.shape[0],r.shape[1],i.shape[1],a);return t.makeTensorInfo(i.shape,"int32",h)}const Cge={kernelName:sx,backendName:"cpu",kernelFunc:Tge};function Nge(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;De([s,r,i],"select");const a=s.shape.length,o=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=_s(r.dtype,i.dtype),p=Yn(he(r.shape),d);let m=0;const y=a===0||a>1||r.shape.length===1?1:he(r.shape.slice(1));for(let b=0;b<o.length;b++)for(let x=0;x<y;x++)o[b]===1?p[m++]=u[b]:p[m++]=h[b];return t.makeTensorInfo(r.shape,d,p)}const kge={kernelName:fm,backendName:"cpu",kernelFunc:Nge};const Ege=aw,$ge=ow,Ige=Nt(Lh,n=>n>=0?$ge*n:Ege*(Math.exp(n)-1)),_ge={kernelName:Lh,backendName:"cpu",kernelFunc:Ige};const Age=Nt(Ph,n=>n<0?-1:n>0?1:0),Rge={kernelName:Ph,backendName:"cpu",kernelFunc:Age};const Dge=Nt(Mh,n=>Math.sin(n)),Oge={kernelName:Mh,backendName:"cpu",kernelFunc:Dge};const Fge=Nt(zh,n=>Math.sinh(n)),Lge={kernelName:zh,backendName:"cpu",kernelFunc:Fge};const Mge=11920928955078125e-23,C3=Math.log(Mge)+2,zge=Nt(Vh,n=>{const e=n>-C3,t=n<C3,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),Pge={kernelName:Vh,backendName:"cpu",kernelFunc:zge};function Bge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;De([r],"spaceToBatchND");const o=he(i),u=[[0,0]];u.push(...a);for(let _=1+i.length;_<r.shape.length;++_)u.push([0,0]);const h=_4.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),d=jm(h.shape,i,o,!1),p=Wm(d.length,i.length,!1),m=Gm(h.shape,i,o,!1),x=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),C=Fs({inputs:{x},backend:t,attrs:{perm:p}}),E=zt({inputs:{x:C},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(C),E}const Vge={kernelName:gm,backendName:"cpu",kernelFunc:Bge};function Uge(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values[0],[p,m,y,b,x]=e4(o,s.shape,s.dtype,u,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const jge={kernelName:rx,backendName:"cpu",kernelFunc:Uge};function Wge(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.data.get(r.dataId).values),o=t.data.get(s.dataId).values,u=Array.from(t.data.get(i.dataId).values),[h,d,p]=t4(o,s.shape,s.dtype,a,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const Gge={kernelName:ix,backendName:"cpu",kernelFunc:Wge};function Hge(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[h,d]=qE(a,s.shape,s.dtype,o,u,!0);return t.makeTensorInfo(d,s.dtype,h)}const qge={kernelName:ax,backendName:"cpu",kernelFunc:Hge};function Kge(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,u=t.data.get(i.dataId).values,[h,d]=qE(a,s.shape,s.dtype,o,u);return t.makeTensorInfo(d,s.dtype,h)}const Xge={kernelName:ox,backendName:"cpu",kernelFunc:Kge};function Yge(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=Ho(i,r,o),y=!1,b=t.bufferSync(r);let x;switch(i.dtype){case"bool":{const w=t.bufferSync(i),S=!!t.data.get(a.dataId).values[0];x=Ol(b,w,o,m,d,h,u,p,S,y);break}case"float32":{const w=t.bufferSync(i),S=t.data.get(a.dataId).values[0];x=Ol(b,w,o,m,d,h,u,p,S,y);break}case"int32":{const w=t.bufferSync(i),S=t.data.get(a.dataId).values[0];x=Ol(b,w,o,m,d,h,u,p,S,y);break}case"string":{const w=t.bufferSync(i),S=Ca(t.data.get(a.dataId).values[0]);x=Ol(b,w,o,m,d,h,u,p,S,y);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(o,x.dtype,x.values)}const Jge={kernelName:lx,backendName:"cpu",kernelFunc:Yge};function Zge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=st(a,r.shape)[0],u=ak(r,i,o),h=new Array(r.shape.length).fill(0),d=r.shape.slice();return u.map(p=>{const m=[...d];m[o]=p;const y=iu({inputs:{x:r},backend:t,attrs:{begin:h,size:m}});return h[o]+=p,y})}const Qge={kernelName:ym,backendName:"cpu",kernelFunc:Zge};const eye={kernelName:ux,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;De(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const u=r[o];i[o]=u*u}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const tye=Nt(Kh,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),nye={kernelName:Kh,backendName:"cpu",kernelFunc:tye};function sye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;De(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:C,end:N,strides:k}=VN(r.shape,i,a,o,u,h,d,p,m);let E;if(x)E=zt({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||S){D(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const _=zN(C,N,k),R=iu({inputs:{x:r},backend:t,attrs:{begin:C,size:_}});E=zt({inputs:{x:R},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(R)}else{const _=t.bufferSync(r),R=r4(y,_,k,C);E=t.makeTensorInfo(b,R.dtype,R.values)}return E}const rye={kernelName:cx,backendName:"cpu",kernelFunc:sye};function iye(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:h}=s,{data:d,dataSplits:p}=e,m=t.data.get(d.dataId).values,y=t.data.get(p.dataId).values,[b,x]=i4(m,y,r,i,a,o,u,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(p.shape,"int32",x)]}const aye={kernelName:hx,backendName:"cpu",kernelFunc:iye};function oye(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(i.dataId).values,u=t.data.get(a.dataId).values[0],[h,d,p]=a4(o,u,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const lye={kernelName:dx,backendName:"cpu",kernelFunc:oye};function uye(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(i.dataId).values,o=o4(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const cye={kernelName:fx,backendName:"cpu",kernelFunc:uye};const hye=Nt(Gh,n=>Math.tan(n)),dye={kernelName:Gh,backendName:"cpu",kernelFunc:hye};const fye=Nt(Hh,n=>Math.tanh(n)),pye={kernelName:Hh,backendName:"cpu",kernelFunc:fye};function mye(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:a,numUpdates:o,sliceSize:u,strides:h,outputSize:d}=Ho(i,r,s.shape),p=!1,m=t.bufferSync(r),y=t.bufferSync(i),b=t.bufferSync(s),x=Ol(m,y,s.shape,d,u,o,a,h,b,p);return t.makeTensorInfo(s.shape,x.dtype,x.values)}const gye={kernelName:nx,backendName:"cpu",kernelFunc:mye};function yye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;De(r,"tile");const a=u4(t.bufferSync(r),i);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const bye={kernelName:qh,backendName:"cpu",kernelFunc:yye};function xye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s;De(r,"topk");const o=t.data.get(r.dataId).values,[u,h]=h4(o,r.shape,r.dtype,i,a);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(h.shape,h.dtype,h.values)]}const wye={kernelName:px,backendName:"cpu",kernelFunc:xye};function vye(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:u,outputShape:h}=t,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=ze(r.shape),C=S[0],N=S[1],k=S[2],E=ze(w),_=E[0],R=E[1],O=E[2],F=zn(r.dtype,he(w));F.fill(u);const L=s.data.get(r.dataId).values,A=s.data.get(i.dataId).values;for(let Y=0;Y<d;++Y){const te=i.shape[0]===1?A:A.subarray(Y*8,Y*8+8);for(let Z=0;Z<b;++Z)for(let B=0;B<x;++B)for(let V=0;V<y;++V){let j;const ee=te[6]*B+te[7]*Z+1;if(ee===0)continue;const ae=(te[0]*B+te[1]*Z+te[2])/ee,P=(te[3]*B+te[4]*Z+te[5])/ee,H=N3(ae,m,o),ne=N3(P,p,o);switch(a){case"nearest":j=Eye(L,p,m,C,N,k,Y,ne,H,V,u);break;case"bilinear":j=$ye(L,p,m,C,N,k,Y,ne,H,V,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const ce=Y*_+Z*R+B*O+V;F[ce]=j}return s.makeTensorInfo(w,r.dtype,F)}return{dataId:s.write(F,w,r.dtype),shape:r.shape,dtype:r.dtype}}const Sye={kernelName:mx,backendName:"cpu",kernelFunc:vye};function N3(n,e,t){switch(t){case"reflect":return Tye(n,e);case"wrap":return Cye(n,e);case"nearest":return kye(n,e);default:return Nye(n)}}function Tye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Eo(0,t,e-1)}function Cye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Eo(0,t,e-1)}function Nye(n,e){return n}function kye(n,e){return Eo(0,n,e-1)}function Nf(n,e,t,s,r,i,a,o,u,h,d){const p=a*s+o*r+u*i+h;return 0<=o&&o<e&&0<=u&&u<t?n[p]:d}function Eye(n,e,t,s,r,i,a,o,u,h,d){const p=Math.round(o),m=Math.round(u);return Nf(n,e,t,s,r,i,a,p,m,h,d)}function $ye(n,e,t,s,r,i,a,o,u,h,d){const p=Math.floor(o),m=Math.floor(u),y=p+1,b=m+1,x=(b-u)*Nf(n,e,t,s,r,i,a,p,m,h,d)+(u-m)*Nf(n,e,t,s,r,i,a,p,b,h,d),w=(b-u)*Nf(n,e,t,s,r,i,a,y,m,h,d)+(u-m)*Nf(n,e,t,s,r,i,a,y,b,h,d);return(y-o)*x+(o-p)*w}function Iye(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;De(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:u,indices:h}=d4(a,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const _ye={kernelName:gx,backendName:"cpu",kernelFunc:Iye};function Aye(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],u=new Array(a-1);let h=0;for(let y=0;y<a;y++)y!==i&&(u[h++]=r.shape[y]);const d=new Array(a).fill(0),p=r.shape.slice();p[i]=1;const m=new Array(o);for(let y=0;y<m.length;y++){d[i]=y;const b=iu({inputs:{x:r},backend:t,attrs:{begin:d,size:p}});m[y]=zt({inputs:{x:b},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(b)}return m}const Rye={kernelName:wm,backendName:"cpu",kernelFunc:Aye};function Dye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s;De(r,"unsortedSegmentSum");const o=r.shape.length,u=i.shape.length,h=[],d=[],p=o-u;let m=i;for(let b=0;b<p;++b){const x=X0({inputs:{input:m},backend:t,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<a;++b){const x=Da(b,"int32"),w=t.makeTensorInfo([],"int32",x),S=EV({inputs:{a:w,b:m},backend:t}),C=Mo({inputs:{x:S},backend:t,attrs:{dtype:"float32"}}),N=Iw({inputs:{a:C,b:r},backend:t}),k=ng({inputs:{x:N},backend:t,attrs:{axis:0,keepDims:!1}});h.push(k),d.push(w),d.push(S),d.push(C),d.push(N),d.push(k)}const y=I4({inputs:h,backend:t,attrs:{axis:0}});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const Oye={kernelName:vm,backendName:"cpu",kernelFunc:Dye};const Fye=[Ide,che,Ade,Dde,ghe,Fde,Mde,Pde,Vde,jde,Gde,qde,Xde,Zde,efe,sfe,ife,ofe,ufe,Ede,hfe,ffe,mfe,bhe,yfe,phe,whe,xfe,hhe,vfe,Tfe,Cfe,kfe,$fe,_fe,Rfe,Ofe,Lfe,zfe,Bfe,Ufe,Wfe,Hfe,Kfe,Xfe,Jfe,Qfe,tpe,npe,spe,rpe,ape,upe,wde,hpe,vhe,xpe,She,wpe,Che,kpe,Epe,Ipe,khe,$he,Ape,Dpe,Fpe,Mpe,_he,Rhe,dhe,Ppe,Sfe,Vpe,jpe,Gpe,vde,Ohe,Lhe,qpe,zhe,Xpe,Zpe,eme,sme,ime,ome,lme,Bhe,cme,dme,pme,gme,bme,wme,Sme,Uhe,Cme,Eme,_me,Whe,Hhe,Dme,Lme,Pme,Khe,Vme,jme,Wme,_4,Kme,Tde,Jhe,Yme,Zme,ege,nge,fhe,cC,rge,Cde,Nde,kde,age,lge,cge,dge,pge,mge,yge,ide,xge,Cge,kge,_ge,ode,Rge,Oge,Lge,lde,$me,Pge,Vge,jge,Gge,qge,Xge,Jge,Qge,hde,eye,fde,mde,nye,rye,aye,lye,cye,xde,ope,dye,pye,gye,bye,wye,Sye,Xhe,_ye,Rye,Oye,Ume];for(const n of Fye)bx(n);const Il={},Uy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function A4(n,e){Il[n]=e}function bi(n,e){if(!(n in Il)||e!=null){const s=Mye(n,e);if(s!==null)Il[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Il[n];return t==null||t.isContextLost()?(delete Il[n],bi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Il[n])}function Lye(n){if(!ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Mye(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Lye(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Il[n]},!1),ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(Uy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Uy)||t.getContext("experimental-webgl",Uy):t.getContext("webgl2",Uy)}var up;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(up||(up={}));var xr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(xr||(xr={}));var Kn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Kn||(Kn={}));function sg(n,e){return[e,n]}function zye(n,e){return n*e}function jy(n){const e=he(n),t=Math.ceil(e/4);return C0(t)}function ud(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Pye(n,e){const[t,s]=ud(n,e);return t*s*4}function ZE(n,e){const t=n;let s,r,i,a,o,u,h,d,p,m;return ie().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,a=t.RGBA32F,o=t.RED,h=4,d=1,p=t.HALF_FLOAT,m=t.FLOAT,u=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,a=t.RGBA,o=n.RGBA,h=4,d=4,p=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function Ie(n,e){const t=e();return ie().getBool("DEBUG")&&Bye(n),t}function Bye(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+D4(n,e))}const Vye=596e-10,Uye=65504;function R4(n){return!!(ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Vye<Math.abs(n)&&Math.abs(n)<Uye)}function D4(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function kf(n,e){return Ba(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function O4(n,e){const t=Ba(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ie(n,()=>n.shaderSource(t,e)),Ie(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function F4(n,e){const t=Ba(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ie(n,()=>n.shaderSource(t,e)),Ie(n,()=>n.compileShader(t)),ie().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw QE(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const jye=/ERROR: [0-9]+:([0-9]+):/g;function QE(n,e){const t=jye.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,a=r.map((p,m)=>Pl((m+1).toString(),i)+p);let o=0;for(let p=0;p<a.length;p++)o=Math.max(a[p].length,o);const u=a.slice(0,s-1),h=a.slice(s-1,s),d=a.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Pl(h[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function L4(n){return Ba(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function M4(n,e){if(Ie(n,()=>n.linkProgram(e)),!ie().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function o0(n,e){if(Ie(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function z4(n,e){const t=Ba(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Ie(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function P4(n,e){const t=Ba(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ie(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Ie(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Wye(){return ie().getNumber("WEBGL_VERSION")===2?1:4}function B4(n){return Ba(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function V4(n,e){const t=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function U4(n){return Ba(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function dC(n,e,t,s,r,i,a){const o=n.getAttribLocation(e,t);return o===-1?!1:(Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Ie(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,i,a)),Ie(n,()=>n.enableVertexAttribArray(o)),!0)}function j4(n,e,t){K4(n,t),Ie(n,()=>n.activeTexture(n.TEXTURE0+t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Gye(n,e){K4(n,e),Ie(n,()=>n.activeTexture(n.TEXTURE0+e)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function W4(n,e,t){return Ba(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function G4(n,e,t){return n.getUniformLocation(e,t)}function H4(n,e,t,s){Ie(n,()=>j4(n,e,s)),Ie(n,()=>n.uniform1i(t,s))}function Hye(n){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Ie(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),Ie(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function l0(n,e,t){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Ie(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function fC(n,e){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Ie(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ef(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+q4(n,e))}function q4(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Ba(n,e,t){const s=Ie(n,()=>e());if(s==null)throw new Error(t);return s}function K4(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function au(n,e=2){return he(n.slice(0,n.length-e))}function ou(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function $f(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[au(n),...ou(n)]),e}function X4(n,e=!1){let t=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,u)=>u>=n.length-2?hb(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Ra(n).newShape);let r=he(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const a=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||a)if(e){const o=au(n);let u=2,h=2;n.length&&([u,h]=ou(n)),r=o*(u/2)*(h/2),i=C0(r).map(d=>d*2)}else i=C0(r);return i}function Wy(n){return n%2===0}function cp(n,e){if(n=n.slice(-2),e=e.slice(-2),it(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Wy(t)&&Wy(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Wy(n[0])&&Wy(e[0])}let u0,c0;function Y4(n){if(u0==null){const e=bi(n);u0=e.getParameter(e.MAX_TEXTURE_SIZE)}return u0}function qye(){u0=null}function Kye(){c0=null}function J4(n){if(c0==null){const e=bi(n);c0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,c0)}function Z4(n){if(n===0)return 0;let e;const t=bi(n);return wr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:wr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function wr(n,e){return n.getExtension(e)!=null}function pC(n){try{if(bi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Q4(n){if(n===0)return!1;const e=bi(n);if(n===1){if(!wr(e,"OES_texture_float"))return!1}else if(!wr(e,"EXT_color_buffer_float"))return!1;return mC(e)}function eU(n){if(n===0)return!1;const e=bi(n);if(n===1){if(!wr(e,"OES_texture_float")||!wr(e,"WEBGL_color_buffer_float"))return!1}else{if(wr(e,"EXT_color_buffer_float"))return mC(e);const s="EXT_color_buffer_half_float";if(wr(e,s)){const r=e.getExtension(s);return Xye(e,r)}return!1}return mC(e)}function mC(n){const e=ZE(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),a}function Xye(n,e){const t=ZE(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function tU(n){return n!==2?!1:bi(n).fenceSync!=null}function cd(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&D(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const Yye=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:cd,bindCanvasToFramebuffer:Hye,bindColorTextureToFramebuffer:l0,bindTextureToProgramUniformSampler:H4,bindTextureUnit:j4,bindVertexBufferToProgramAttribute:dC,callAndCheck:Ie,canBeRepresented:R4,createFragmentShader:F4,createFramebuffer:U4,createProgram:L4,createStaticIndexBuffer:P4,createStaticVertexBuffer:z4,createTexture:B4,createVertexShader:O4,getBatchDim:au,getExtensionOrThrow:kf,getFramebufferErrorMessage:q4,getMaxTexturesInShader:J4,getNumChannels:Wye,getProgramUniformLocation:G4,getProgramUniformLocationOrThrow:W4,getRowsCols:ou,getShapeAs3D:$f,getTextureShapeFromLogicalShape:X4,getWebGLDisjointQueryTimerVersion:Z4,getWebGLErrorMessage:D4,getWebGLMaxTextureSize:Y4,hasExtension:wr,isCapableOfRenderingToFloatTexture:Q4,isDownloadFloatTextureEnabled:eU,isReshapeFree:cp,isWebGLFenceEnabled:tU,isWebGLVersionEnabled:pC,linkProgram:M4,logShaderSourceAndInfoLog:QE,resetMaxTextureSize:qye,resetMaxTexturesInShader:Kye,unbindColorTextureFromFramebuffer:fC,unbindTextureUnit:Gye,validateFramebuffer:Ef,validateProgram:o0,validateTextureSize:V4},Symbol.toStringTag,{value:"Module"}));const Fe=ie();Fe.registerFlag("HAS_WEBGL",()=>Fe.getNumber("WEBGL_VERSION")>0);Fe.registerFlag("WEBGL_VERSION",()=>pC(2)?2:pC(1)?1:0);Fe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Fe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Fe.get("WEBGL_VERSION")===2);Fe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Fe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Fe.registerFlag("WEBGL_PACK",()=>Fe.getBool("HAS_WEBGL"));Fe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_CLIP",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_REDUCE",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_CONV_IM2COL",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Y4(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>J4(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Fe.getNumber("WEBGL_VERSION");return n===0?0:Z4(n)});Fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!p2());Fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Q4(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Fe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>eU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>tU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Fe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Fe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>p2()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Fe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Fe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Fe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Fe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Fe.registerFlag("WEBGL_EXP_CONV",()=>!1);Fe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Fe.getBool("IS_TEST"));Fe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Fe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Fe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Fe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ss(){let n,e,t,s,r,i,a,o,u,h;return ie().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o=ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:u,defineRound:h}}function wu(n,e,t="index"){const s=ze(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / ${r}`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${a}; ${o};`}).join("")}function _w(n,e,t="index"){const s=ze(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${a}; ${o};`}).join("")}function Jye(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function Zye(n,e,t="index"){const s=n.map((i,a)=>a),r=Jye(s,e);return r.map((i,a)=>{const o=`int ${n[a]} = ${t} / ${r[a]}`,u=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${o}; ${u};`}).join("")}function e$(n){const e=ze(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function t$(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const nU=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:sU}=LP;function Qye(n,e,t){const s=[];if(n.forEach(y=>{const b=he(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),t.enableShapeUniforms){const{uniformShape:x}=n$(t.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>e0e(y,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=Ss(),u=s0e(o);let h,d,p=a0e(o);return e.isPacked?(h=t0e(e.logicalShape,a,t.enableShapeUniforms),d=i0e(o)):(h=n0e(e.logicalShape,a,t.enableShapeUniforms),d=r0e(o)),t.packedInputs&&(p+=c0e),[p,u,d,r,h,i,t.userCode].join(`
`)}function hd(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return S0e(n,e);case 1:return C0e(n,e);case 2:return k0e(n,e);case 3:return $0e(n,e);case 4:return _0e(n,e);case 5:return A0e(n);case 6:return R0e(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function rU(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return v0e(n);case 1:return T0e(n,e);case 2:return N0e(n,e);case 3:return E0e(n,e);default:return I0e(n,e)}}function e0e(n,e,t=!1,s){let r="";t?r+=rU(n,s):r+=hd(n,s);const i=n.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(t?r+=D0e(n,e):r+=O0e(n,e)),r}function t0e(n,e,t){switch(n.length){case 0:return iU();case 1:return h0e(n,e,t);case 2:return x0e(n,e,t);case 3:return f0e(n,e,t);default:return m0e(n,e,t)}}function n0e(n,e,t){switch(n.length){case 0:return iU();case 1:return d0e(n,e,t);case 2:return w0e(n,e,t);case 3:return p0e(n,e,t);case 4:return g0e(n,e,t);case 5:return y0e(n,e);case 6:return b0e(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function s0e(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function r0e(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function i0e(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function a0e(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${o0e}
    ${l0e}
    ${u0e}
  `}const o0e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,l0e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,u0e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,c0e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function iU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function h0e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function d0e(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function f0e(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function p0e(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${_w(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=wu(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function m0e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let a=i,o="",u="b, r, c";for(let h=2;h<n.length-1;h++)a*=n[n.length-h-1],o=`
      int b${h} = index / ${a};
      index -= b${h} * ${a};
    `+o,u=`b${h}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${u});
    }
  `}function g0e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${_w(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=wu(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function y0e(n,e){const t=wu(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function b0e(n,e){const t=wu(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function x0e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(it(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function w0e(n,e,t){return it(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function vu(n){return`offset${n}`}function v0e(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ss();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function S0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=vu(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,u]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function T0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Ss();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function C0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${dd(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],a=r[1];if(a===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=vu(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function N0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=i[0],o=i[1],u=Ss();if(i!=null&&it(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function k0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&it(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=Ra(t),u=a;if(u.length<t.length){const m=fd(n,u),y=["row","col"];return`
      ${hd(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${pd(y,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${dd(n)}
      }
    `;const h=i[0],d=i[1],p=vu(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function E0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const m=t.slice(1),y=[1,2],b=fd(n,m),x=["b","row","col"];return`
        ${rU(b,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${pd(x,y)});
        }
      `}const o=Ss();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const u=a[0],h=a[1],d=Math.ceil(t[2]/2),p=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${h}, ${p}, ${d}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function $0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],a=t[2],{newShape:o,keptDims:u}=Ra(t),h=o;if(h.length<t.length){const x=fd(n,h),w=["row","col","depth"];return`
        ${hd(x,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${pd(w,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${dd(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===a&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=vu(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function I0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ss();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,a=i.length,o=n.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],h=u[0],d=u[1],p=Math.ceil(i[a-1]/2);let m=p*Math.ceil(i[a-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<a-1;x++)y=`int b${x}, `+y,m*=i[a-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${t}, uv);
    }
  `}function _0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],a=t[2]*i,o=t[1]*a,{newShape:u,keptDims:h}=Ra(t);if(u.length<t.length){const C=fd(n,u),N=["row","col","depth","depth2"];return`
      ${hd(C,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${pd(N,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${i}, 1)));
        ${dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===o&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const S=vu(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${S});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${S});
      return sampleTexture(${s}, uv);
    }
  `}function A0e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,a=e[2]*i,o=e[1]*a,{newShape:u,keptDims:h}=Ra(e);if(u.length<e.length){const x=fd(n,u),w=["row","col","depth","depth2","depth3"];return`
      ${hd(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${pd(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${i}, ${r})) +
          depth3;
        ${dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===o&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=vu(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${i} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${t}, uv);
    }
  `}function R0e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Ra(e);if(r.length<e.length){const w=fd(n,r),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${hd(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${pd(S,i)});
      }
    `}const a=e[5],o=e[4]*a,u=e[3]*o,h=e[2]*u,d=e[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${dd(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${u}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(b===a&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=vu(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${u} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${t}, uv);
    }
  `}function dd(n){const e=n.name,t=he(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function D0e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=sU(n.shapeInfo.logicalShape,e.logicalShape),u=It(a),h=a-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":a<2&&o.length>=1?d="coords = 0;":d=o.map(C=>`coords.${p[C+h]} = 0;`).join(`
`);let m="";a<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((C,N)=>`coords.${p[N+h]}`).join(", ");let y="return outputValue;";const x=he(n.shapeInfo.logicalShape)===1,S=he(e.logicalShape)===1;if(i===1&&!x&&!S)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)a===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(o.length){const C=i-2,N=i-1;o.indexOf(C)>-1&&o.indexOf(N)>-1?y="return vec4(outputValue.x);":o.indexOf(C)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(N)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function O0e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===u&&n.shapeInfo.flatOffset==null&&it(a,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const h=It(u),d=sU(n.shapeInfo.logicalShape,e.logicalShape),p=u-o;let m;const y=["x","y","z","w","u","v"];o===0?m="":u<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+p]} = 0;`).join(`
`);let b="";return u<2&&o>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+p]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function It(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function n$(n,e,t){const{newShape:s,keptDims:r}=Ra(e),i=e.length,a=n&&i===3&&e[0]===1,o=a?e.slice(1):s,u=!n&&i>1&&!it(e,t)&&s.length<i||a;return{useSqueezeShape:u,uniformShape:u?o:e,keptDims:r}}function fd(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function pd(n,e){return e.map(t=>n[t]).join(", ")}function F0e(n,e,t,s){const r=t.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=Qye(r,a,e),u=F4(n.gl,o),h=n.createProgram(u);return ie().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:o,webGLProgram:h,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:e,fragmentShader:u,source:o,webGLProgram:h,inShapeInfos:i,outShapeInfo:a},aU(n,e,h)))}function aU(n,e,t){const s=[],r=[];let i,a,o,u=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ie().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const p of e.variableNames){const m={name:p,uniform:n.getUniformLocation(t,p,d),offset:n.getUniformLocation(t,`offset${p}`,d)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${p}Shape`,d),m.texShape=n.getUniformLocation(t,`${p}TexShape`,d)),s.push(m)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),o=n.getUniformLocation(t,"outShapeStrides",d),a=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const p of e.customUniforms)r.push(n.getUniformLocation(t,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:a}}function k3(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],a=i.shape;if(!it(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const o=t.texShape,u=i.isUniform?null:i.texData.texShape;if(!it(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function L0e(n,e,t,s,r){e.program.enableShapeUniforms||(k3(e.inShapeInfos,t),k3([e.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):n.setOutputMatrixTexture(i.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ie().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const h=t[u],{uniform:d,offset:p,shape:m,texShape:y}=e.variablesLocations[u];if(m){const{uniformShape:b}=n$(e.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(he(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,u)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=ze(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const h=e.program.customUniforms[u],d=e.customUniformLocations[u],p=r[u];if(h.type==="float")n.gl.uniform1fv(d,p);else if(h.type==="vec2")n.gl.uniform2fv(d,p);else if(h.type==="vec3")n.gl.uniform3fv(d,p);else if(h.type==="vec4")n.gl.uniform4fv(d,p);else if(h.type==="int")n.gl.uniform1iv(d,p);else if(h.type==="ivec2")n.gl.uniform2iv(d,p);else if(h.type==="ivec3")n.gl.uniform3iv(d,p);else if(h.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function M0e(n,e,t){let s="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const u=a.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:p}=n$(n.packedInputs,a.shape,u);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=ze(d);b=`${E[0]===u[1]}_${E[E.length-1]===u[1]}`}const x=a.shape.length,w=d.length===2&&it(a.shape,u),S=he(a.shape)===1,C=Jl(a.shape,t.shape),N=!n.packedInputs&&x===t.shape.length&&it(u,t.texData.texShape),k=n.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${x}_${N}_${h?p:""}_${d.length}_${S}_${C}_${w}_${m}_${y}_${b}_${k}_${o}`}else{const u=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${u}_${o}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${ie().getNumber("WEBGL_VERSION")}`,i}function hs(n){return ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class z0e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=up.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_w(["r","c","d"],e):wu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class P0e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=up.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_w(["r","c","d"],e):wu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class B0e{constructor(e){this.variableNames=["A"],this.outTexUsage=xr.DOWNLOAD;const t=Ss();this.outputShape=e,this.userCode=`
      ${nU}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class V0e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=xr.DOWNLOAD;const t=Ss();this.outputShape=e,this.userCode=`
      ${nU}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const U0e={R:0,G:1,B:2,A:3};class E3{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const u=s[o];a+=`
          if(offset == ${o}) {
            result = values[${U0e[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?t$():e$(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class j0e{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const u=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?t$():e$(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function oU(n){const e=Ss(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return O4(n,t)}function lU(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return z4(n,e)}function uU(n){const e=new Uint16Array([0,1,2,2,1,3]);return P4(n,e)}function rg(n,e,t,s,r,i){V4(e,t);const a=B4(n),o=n.TEXTURE_2D;return Ie(n,()=>n.bindTexture(o,a)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),ie().getNumber("WEBGL_VERSION")===1?Ie(n,()=>n.texImage2D(o,0,s,e,t,0,r,i,null)):Ie(n,()=>n.texStorage2D(o,1,s,e,t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function s$(n){return n.internalFormatFloat}function cU(n,e,t,s){const[r,i]=sg(e,t);return rg(n,r,i,s$(s),s.textureFormatFloat,n.FLOAT)}function r$(n){return n.internalFormatHalfFloat}function hU(n,e,t,s){const[r,i]=sg(e,t);return rg(n,r,i,r$(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function i$(n){return n.downloadTextureFormat}function dU(n,e,t,s){const[r,i]=sg(e,t);return rg(n,r,i,i$(s),n.RGBA,n.UNSIGNED_BYTE)}function a$(n){return n.internalFormatPackedFloat}function fU(n,e,t,s){const[r,i]=ud(e,t);return rg(n,r,i,a$(s),n.RGBA,n.FLOAT)}function o$(n){return n.internalFormatPackedHalfFloat}function pU(n,e,t,s){const[r,i]=ud(e,t);return rg(n,r,i,o$(s),n.RGBA,s.textureTypeHalfFloat)}function mU(n,e,t){return Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),dC(n,e,"clipSpacePos",t,3,20,0)&&dC(n,e,"uv",t,2,20,12)}function gU(n,e,t,s,r,i){Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,o,u;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,u=n.RGBA):(a=new Float32Array(t*s*4),o=n.FLOAT,u=i.internalFormatPackedFloat),a.set(r),ie().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,a)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,s,0,n.RGBA,o,a)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function yU(n,e,t){Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ie().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ie().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function bU(n,e,t,s){const r=n.createBuffer();Ie(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=4*4*e*t;return Ie(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Ie(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Ie(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function xU(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function wU(n,e,t,s){const[r,i]=sg(e,t),a=4,o=new Uint8Array(zye(e*t,a));return Ie(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function vU(n,e,t,s,r,i,a,o){const u=n,h=new Float32Array(Pye(i,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,h),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),h}function SU(n,e,t){const s=new Float32Array(e*t*4);return Ie(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const W0e=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:mU,createBufferFromOutputTexture:bU,createFloat16MatrixTexture:hU,createFloat16PackedMatrixTexture:pU,createFloat32MatrixTexture:cU,createIndexBuffer:uU,createPackedMatrixTexture:fU,createUnsignedBytesMatrixTexture:dU,createVertexBuffer:lU,createVertexShader:oU,downloadByteEncodedFloatMatrixFromOutputTexture:wU,downloadFloat32MatrixFromBuffer:xU,downloadMatrixFromPackedOutputTexture:SU,downloadPackedMatrixFromBuffer:vU,getInternalFormatForFloat16MatrixTexture:r$,getInternalFormatForFloat16PackedMatrixTexture:o$,getInternalFormatForFloat32MatrixTexture:s$,getInternalFormatForPackedMatrixTexture:a$,getInternalFormatForUnsignedBytesMatrixTexture:i$,uploadDenseMatrixToTexture:gU,uploadPixelDataToTexture:yU},Symbol.toStringTag,{value:"Module"}));class h0{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ie().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,A4(t,e)):this.gl=bi(t),e=this.gl,ie().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Ie(i,()=>i.createVertexArray()),this.bindVertexArray=a=>Ie(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>Ie(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>Ie(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ie(e,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>Ie(e,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Ie(e,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>Ie(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ie().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=kf(this.gl,i),wr(this.gl,a))this.textureHalfFloatExtension=kf(this.gl,a);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),wr(this.gl,r))this.colorBufferHalfFloatExtension=kf(this.gl,r);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",wr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(wr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=lU(this.gl),this.indexBuffer=uU(this.gl),this.framebuffer=U4(this.gl),this.textureConfig=ZE(this.gl,this.textureHalfFloatExtension)}get debug(){return ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ie(e,()=>e.finish()),Ie(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ie(e,()=>e.deleteFramebuffer(this.framebuffer)),Ie(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ie(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ie(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),cU(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),hU(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),dU(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),yU(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),gU(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),pU(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),fU(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(fC(this.gl,this.framebuffer),this.outputTexture=null),Ie(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>wU(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,a){return vU(this.gl,e,t,s,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return xU(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=bU(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ie().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(i,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=i}else ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>SU(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=oU(t));const s=L4(t);Ie(t,()=>t.attachShader(s,this.vertexShader)),Ie(t,()=>t.attachShader(s,e)),M4(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&o0(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Ie(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),mU(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ie(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&o0(this.gl,this.program),Ie(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?W4(this.gl,e,t):G4(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ie(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),H4(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=ud(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&o0(this.gl,this.program),Ef(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ie(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ie(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=kf(this.gl,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await TT(()=>this.disposed||this.isQueryAvailable(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=G0e(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ie().platform&&(s=ie().platform.setTimeoutCustom.bind(ie().platform)),TT(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),l0(this.gl,e,this.framebuffer),this.debug&&Ef(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(l0(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ef(this.gl)):fC(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;l0(r,e,this.framebuffer),this.debug&&Ef(r),this.outputTexture=e,Ie(r,()=>r.viewport(0,0,t,s)),Ie(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),Ie(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function G0e(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:H0e,bincountImpl:TU,bincountReduceImpl:q0e,bitwiseAndImpl:K0e,castImpl:X0e,ceilImpl:Y0e,concatImpl:J0e,equalImpl:Z0e,expImpl:Q0e,expm1Impl:ebe,floorImpl:tbe,gatherNdImpl:nbe,gatherV2Impl:sbe,greaterImpl:rbe,greaterEqualImpl:ibe,lessImpl:abe,lessEqualImpl:obe,linSpaceImpl:lbe,logImpl:ube,maxImpl:cbe,maximumImpl:hbe,minimumImpl:dbe,multiplyImpl:fbe,negImpl:pbe,notEqualImpl:mbe,prodImpl:gbe,raggedGatherImpl:ybe,raggedRangeImpl:bbe,raggedTensorToTensorImpl:xbe,rangeImpl:wbe,rsqrtImpl:vbe,scatterImpl:Sbe,sigmoidImpl:Tbe,simpleAbsImpl:CU,sliceImpl:Cbe,sparseFillEmptyRowsImpl:Nbe,sparseReshapeImpl:kbe,sparseSegmentReductionImpl:NU,sqrtImpl:Ebe,staticRegexReplaceImpl:$be,stridedSliceImpl:Ibe,stringNGramsImpl:_be,stringSplitImpl:Abe,stringToHashBucketFastImpl:Rbe,subImpl:Dbe,tileImpl:Obe,topKImpl:Fbe,transposeImpl:l$,uniqueImpl:Lbe}=f4;function kU(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function gs(n,e){return e===1?[n]:kU(n,e)}function Mbe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class zbe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=hs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=gs("rc",this.rank),s=It(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${e[e.length-1-a]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class EU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${Pbe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?t$():e$(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Pbe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Zye(["r","c","d"],"inputShape"):wu(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class Bbe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=I3(t,s),i=_3(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=$3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const u=this.freeTextures[i].pop();return this.usedTextures[i].push(u),u}let o;return r===Kn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Kn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Kn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Kn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Kn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=I3(s,r),a=_3(t,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const o=$3(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const h=this.usedTextures[a],d=h&&h.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Vbe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function $3(n,e,t,s,r){const i=Ube(e,s);let a;if(r){const[u,h]=ud(n[0],n[1]);a=u*h}else{const[u,h]=sg(n[0],n[1]);a=u*h}const o=Vbe(t,i);return a*o}function Ube(n,e){switch(n){case Kn.PACKED_2X2_FLOAT32:return a$(e);case Kn.PACKED_2X2_FLOAT16:return o$(e);case Kn.UNPACKED_FLOAT32:return s$(e);case Kn.UNPACKED_FLOAT16:return r$(e);case Kn.PACKED_4X1_UNSIGNED_BYTE:return i$(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function jbe(n){return ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Kn.PACKED_2X2_FLOAT32:Kn.UNPACKED_FLOAT32:n?Kn.PACKED_2X2_FLOAT16:Kn.UNPACKED_FLOAT16}function I3(n,e){if(n===xr.UPLOAD)return Kn.PACKED_2X2_FLOAT32;if(n===xr.RENDER||n==null)return jbe(e);if(n===xr.DOWNLOAD||n===xr.PIXELS)return Kn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function _3(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class Di{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Kr="if (isnan(x)) return x;",Wbe="return x;",A3="return abs(x);",Gbe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Hbe=Kr+`
  return (x < 0.0) ? 0.0 : x;
`,qbe=Kr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,mo="return x;",Kbe="return 1.0 / (1.0 + exp(-1.0 * x));";const Xbe="return x;",Ybe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Jbe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Zbe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qbe="return 1.0 / (1.0 + exp(-1.0 * x));";class wo{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class exe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);const t=e.length,s=gs("rc",t),r=It(t),i=Mbe(t,s),a=s.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}const txe=qx,nxe=1e-7,sxe=1e-4,Gy={};function rxe(n){return n in Gy||(Gy[n]={}),Gy[n]}const ixe=ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),axe=600;function oxe(){return ie().global.screen==null?1024:ie().global.screen.height*ie().global.screen.width*window.devicePixelRatio*axe/1024/1024}class ig extends cb{nextDataId(){return ig.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof h0)t=e;else{const s=bi(ie().getNumber("WEBGL_VERSION"),e);t=new h0(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=bi(ie().getNumber("WEBGL_VERSION"));t=new h0(s),this.binaryCache=rxe(ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Bbe(this.gpgpu),this.numMBBeforeWarning=oxe(),this.texData=new a2(this,oi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,a){const o=this.makeTensorInfo(t,s),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,i]},u.texShape=[r,i];const h=$f(t),d=new E3(h,!1,a),p=this.runWebGLProgram(d,[o],s,[[r,i]]);return p.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(o),p.dataId}write(e,t,s){if((ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:xr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(ie().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:xr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:u}=t;if(a!=null){let m;u?m=new wo(o,mo):m=new Di(o,mo);const y=this.runWebGLProgram(m,[{dataId:e,shape:o,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=Gn());let p;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);p=$a(m,y)}else p=this.getValuesFromTexture(e);return h&&(this.downloadWaitMs+=Gn()-d),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const b=this.pendingRead.get(e);return new Promise(x=>b.push(x))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:u}=t;if(i!=null){let b;u?b=new wo(r,mo):b=new Di(r,mo);const x=this.runWebGLProgram(b,[{dataId:e,shape:r,dtype:a}],a),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(e);if(ie().getBool("DEBUG")&&!ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(a!=="complex64"&&ie().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...jy(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(a==="complex64"){const b=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),x=b[0],w=b[1];p=$a(x,w)}else if(h==null)p=this.getValuesFromTexture(e);else{const b=he(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;Ie(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(e,p),y=this.pendingRead.get(e);return this.pendingRead.delete(e),y.forEach(b=>b(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&oi().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:a,dtype:o,isPacked:u,texture:h}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let y;u?y=new wo(i,mo):y=new Di(i,mo);const b=this.runWebGLProgram(y,[{dataId:e,shape:i,dtype:o}],o),x=this.readToGPU(b,t);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),p=oi().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Ca(r));return Qe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!R4(s))throw ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=he(t);if(ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...jy(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),b}const a=ie().getBool("WEBGL_PACK")&&r===!0,o=a?$f(t):t,u=a?new V0e(o):new B0e(o),h=this.runWebGLProgram(u,[{shape:o,dtype:s,dataId:e}],"float32"),d=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Vi(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=Vi(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(i);o.kernelMs=ZL(u),o.getExtraProfileInfo=()=>u.map((h,d)=>({name:a[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gn(),endMs:null}}endTimer(e){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Gn(),e)}async getQueryTime(e){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:a,slice:o}=this.texData.get(e),u=o&&o.origDataId||e,h=this.dataRefCount.get(u);h>1?this.dataRefCount.set(u,h-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=ixe){return ie().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&he(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return txe(e.shape,t)}packedUnaryOp(e,t,s){const r=new wo(e.shape,t),i=this.compileAndRun(r,[e],s);return oi().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=CU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,A3,e.dtype);const t=new Di(e.shape,A3),s=this.compileAndRun(t,[e]);return oi().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ri(s[0])){const i=s.map(a=>Li(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return oi().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new exe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new zbe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[au(e.shape),...ou(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[au(t),...ou(t)],a=new EU(i,s),o=!0,u=[s],h=this.runWebGLProgram(a,[r],e.dtype,u,o);return{dataId:h.dataId,shape:t,dtype:h.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:a}=s;if(t!=null){const m=he(i),y=t[0]*t[1]*4;D(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=$f(i);let u;r?u=new P0e(o):u=new z0e(o);const h=!0,d=[t??jy(o)],p=this.runWebGLProgram(u,[{shape:o,dtype:a,dataId:e}],a,d,h,t);return{dtype:a,shape:i,dataId:p.dataId}}runWebGLProgram(e,t,s,r,i=!1,a){const o=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(o.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===up.DENSE){const S=a??jy(e.outputShape);u.texShape=S.map(C=>C*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),he(o.shape)===0)return u.values=zn(o.dtype,0),o;const h=[],d=t.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(S.dataId);if(C.texture==null){if(!e.packedInputs&&he(S.shape)<=ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:C.values};e.packedInputs&&(C.isPacked=!0,C.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!C.isPacked!=!!e.packedInputs)S=C.isPacked?this.unpackTensor(S):this.packTensor(S),h.push(S),C=this.texData.get(S.dataId);else if(C.isPacked&&!cp(C.shape,S.shape)){const N=S,k=S.shape;S.shape=C.shape,S=this.packedReshape(S,k),h.push(S),C=this.texData.get(S.dataId),N.shape=k}return{shape:S.shape,texData:C,isUniform:!1}});this.uploadToGPU(o.dataId);const p={shape:o.shape,texData:u,isUniform:!1},m=M0e(e,d,p),y=this.getAndSaveBinary(m,()=>F0e(this.gpgpu,e,d,p)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),ie().get("ENGINE_COMPILE_ONLY")||L0e(this.gpgpu,y,d,p,r),h.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=Gn();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!ie().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&i===!1){const S=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),S}return o}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=se(()=>{if(!ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ie().getBool("DEBUG");ie().set("DEBUG",!1);const t=this.abs(Me(1e-8)).dataSync()[0];if(ie().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?nxe:sxe}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:a,usage:o,isPacked:u}=t;if(a!=null)return;const h=this.activeTimers!=null;let d;h&&(d=Gn());let p=t.texShape;if(p==null&&(p=X4(s,u),t.texShape=p),i!=null){const m=$f(s);let y,b=p[1],x=p[0];const w=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!w)&&([b,x]=ud(p[0],p[1])),u?y=new j0e(m,w):y=new E3(m,w);const S=w?[x,b]:p,C=this.makeTensorInfo(S,r),N=this.texData.get(C.dataId);w?N.usage=xr.PIXELS:N.usage=xr.UPLOAD,N.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),b,x,i);const k=[[x,b]],_=this.runWebGLProgram(y,[C],r,k,!0),R=this.texData.get(_.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(C),h&&(this.uploadWaitMs+=Gn()-d)}else{const m=this.acquireTexture(p,o,r,u);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=lxe(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Kf(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await UN(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(QE(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:u}=aU(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:a,channels:o}=e,u=oi().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=u.writeTexture(r,t,s,i,a,o);return oi().makeTensorFromDataId(h,t,s,u)}}ig.nextDataId=0;function lxe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}const $U="4.22.0";function IU(){ie().set("WEBGL_FORCE_F16_TEXTURES",!0)}m2()&&y2("webgl",()=>new ig,2);const uxe={forceHalfFloat:IU};const u$=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class lu{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Xe(t,s),this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Su=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class md{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Xe(t,s);const i=this.outputShape.length;this.enableShapeUniforms=hs(i);let a="";if(r)if(i===0||he(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${It(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=gs("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${u[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}function er(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const cxe={kernelName:wh,backendName:"webgl",kernelFunc:er};function Ko(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(i.dataId),o=er({inputs:{x:s},backend:t}),u=er({inputs:{x:r},backend:t});return a.complexTensorInfos={real:o,imag:u},i}const hxe={kernelName:xb,backendName:"webgl",kernelFunc:Ko};const _U="return (a < 0.) ? b * a : a;",AU=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function dxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=t.makeTensorInfo([],"float32",Da(i,"float32")),o=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(AU,r.shape,a.shape):new lu(_U,r.shape,a.shape),u=t.runWebGLProgram(o,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),u}const fxe={kernelName:Up,backendName:"webgl",kernelFunc:dxe};const RU="return (a < 0.) ? b * a : a;",DU=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function pxe(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(DU,s.shape,r.shape):new lu(RU,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const mxe={kernelName:om,backendName:"webgl",kernelFunc:pxe};const gd="if (isnan(x)) return x;";function gt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,u=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const p=o.texData.get(a.dataId),m=t(p.values,u);return o.makeTensorInfo(a.shape,u,m)}const h=ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return h?d=new wo(a.shape,e):d=new Di(a.shape,n),o.runWebGLProgram(d,[a],u)}}function ts({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:u,b:h}=a,d=o;if(s&&u.dtype==="complex64"){const b=d.texData.get(u.dataId),x=d.texData.get(h.dataId),[w,S]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(N=>{const[k,E]=N,_={dataId:k.dataId,dtype:k.dtype,shape:u.shape},R={dataId:E.dataId,dtype:E.dtype,shape:h.shape},O=new lu(n,u.shape,h.shape);return d.runWebGLProgram(O,[_,R],_s(k.dtype,E.dtype))}),C=Ko({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),C}const p=i||_s(u.dtype,h.dtype);if((u.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([u,h]))&&r!=null){const b=d.texData.get(u.dataId).values,x=d.texData.get(h.dataId).values,w=u.dtype==="string"?Ia(b):b,S=u.dtype==="string"?Ia(x):x,[C,N]=r(u.shape,h.shape,w,S,p),k=d.makeTensorInfo(N,p),E=d.texData.get(k.dataId);return E.values=C,k}const m=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let y;return m?y=new md(e,u.shape,h.shape,t):y=new lu(n,u.shape,h.shape),d.runWebGLProgram(y,[u,h],p)}}function hp(n,e=!1){if(n==="linear")return e?Xbe:Wbe;if(n==="relu")return e?Jbe:Hbe;if(n==="elu")return e?Ybe:Gbe;if(n==="relu6")return e?Zbe:qbe;if(n==="prelu")return e?DU:RU;if(n==="leakyrelu")return e?AU:_U;if(n==="sigmoid")return e?Qbe:Kbe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class OU{constructor(e,t,s,r=!1,i=!1,a=!1,o=null,u=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=hs(this.outputShape.length);const d=r?e[1]:e[2],p=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";o&&(u?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:w=`vec4 activation(vec4 x) {
          ${o}
        }`,S="result = activation(result);");const C=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let N="rc.x",k="rc.x";e[0]<t[0]?N=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(k=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${N};
        int batchB = ${k};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${C}

        ${S}

        setOutput(result);
      }
    `}}const R3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class D3{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Xe(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const O3="return a * b;";function c$(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=_s(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),u=t.texData.get(r.dataId),h=new D3(R3.REAL,s.shape,r.shape),d=new D3(R3.IMAG,s.shape,r.shape),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(h,p,"float32"),y=t.runWebGLProgram(d,p,"float32"),b=Ko({inputs:{real:m,imag:y},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}if(t.shouldExecuteOnCPU([s,r])){const o=t.texData.get(s.dataId),u=t.texData.get(r.dataId),[h,d]=fbe(s.shape,r.shape,o.values,u.values,i),p=t.makeTensorInfo(d,i),m=t.texData.get(p.dataId);return m.values=h,p}let a;return ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new md(O3,s.shape,r.shape):a=new lu(O3,s.shape,r.shape),t.runWebGLProgram(a,[s,r],i)}const gxe={kernelName:Ih,backendName:"webgl",kernelFunc:c$};function yxe(n,e,t){const s=[au(n.shape),...ou(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[au(e),...ou(e)],a=new EU(i,s),o=!0,u=[s],h=t.runWebGLProgram(a,[r],n.dtype,u,o);return{dataId:h.dataId,shape:e,dtype:h.dtype}}function $e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=t,o=he(r.shape),u=l2(i,o),h=he(u);D(o===h,()=>`The new shape (${u}) has ${h} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=a.texData.get(r.dataId);return d.isPacked&&!cp(r.shape,u)&&!(d.texture!==null&&cp(d.shape,u))?yxe(r,u,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const bxe={kernelName:um,backendName:"webgl",kernelFunc:$e};class F3{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];const o=Math.floor(s/4)*4,u=s%4;let h="sumValue += dot(values, ones);";if(t!=null){const p=1/t;h=`sumValue += dot(values * ${Gl(p)?p.toPrecision(2):p}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${o};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class xxe{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let o="0.0",u="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",u="min"):t==="max"&&(o="-1.0 / 1e-20",u="max");let h=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?h="sumValue":t==="prod"?h="prodValue":t==="all"?h="allValue":t==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";t==="all"?(o="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):t==="any"&&(o="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function wxe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=iw(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Tu(n,e,t,s){const r=wxe(n.shape);let i=n;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:u,outSize:h}=r[a];let d,p;t==="mean"?d=a===0?new F3({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:h},o):new F3({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:h}):d=new xxe({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:h},t),p=i,i=s.runWebGLProgram(d,[i],e),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}class vxe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=It(this.rank),i=Sxe(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Sxe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class Txe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=It(this.rank),i=kU("rc",this.rank),a=new Array(this.rank);for(let d=0;d<t.length;d++)a[t[d]]=i[d];const o=`vec2(${a.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${u}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${u}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function Aw(n,e,t){const s=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Txe(n.shape,e):new vxe(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function Cxe(n,e,t,s){const r=e,i=n.shape.length,a=st(r,n.shape);let o=a;const u=Zt(o,i),h=u!=null;let d=n;h&&(d=Aw(n,u,s),o=cn(o.length,i)),Qn("sum",o,i);const[p,m]=Un(d.shape,o);let y=p;t&&(y=un(p,a));const b=he(m),w=he(n.shape)/b,S=$e({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),C=xx(n.dtype),N=Tu(S,C,"sum",s),k=$e({inputs:{x:N},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(N),h&&s.disposeIntermediateTensorInfo(d),k}function Rw(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return Cxe(r,i,a,t)}const Nxe={kernelName:mm,backendName:"webgl",kernelFunc:Rw};function xs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,o=r.shape.length,u=new Array(o);for(let d=0;d<u.length;d++)u[d]=r.shape[i[d]];let h;if(a.shouldExecuteOnCPU([r])){const p=a.texData.get(r.dataId).values,m=l$(p,r.shape,r.dtype,i,u);h=a.makeTensorInfo(u,r.dtype);const y=a.texData.get(h.dataId);y.values=m}else h=Aw(r,i,a);return h}const kxe={kernelName:Bl,backendName:"webgl",kernelFunc:xs};const FU=1e3;function J0({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const h=n.shape.length,d=e.shape.length,p=t?n.shape[h-2]:n.shape[h-1],m=s?e.shape[d-1]:e.shape[d-2],y=t?n.shape[h-1]:n.shape[h-2],b=s?e.shape[d-2]:e.shape[d-1],x=n.shape.slice(0,-2),w=e.shape.slice(0,-2),S=he(x),C=he(w),k=Xe(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([y,b]);D(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[S,p,y]:[S,y,p],_=s?[C,b,m]:[C,m,b],R=$e({inputs:{x:n},backend:r,attrs:{shape:E}}),O=$e({inputs:{x:e},backend:r,attrs:{shape:_}}),F=[R,O],L=Math.max(S,C),A=t?R.shape[1]:R.shape[2],U=i!=null,Y=a!=null,te=u==="leakyrelu",Z=u!=null?hp(u,!0):null,B=U||Y||te||Z!=null;let V;if((y===1||b===1)&&A>FU&&B===!1){let ee=R,ae=O;t&&(ee=xs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),F.push(ee)),s&&(ae=xs({inputs:{x:O},backend:r,attrs:{perm:[0,2,1]}}),F.push(ae));const P=b!==1,H=b===1;let ne=ee;P&&(ne=$e({inputs:{x:ee},backend:r,attrs:{shape:[L,A,1]}}),F.push(ne));const ce=b===1?2:1;let me=ae;H&&(me=$e({inputs:{x:ae},backend:r,attrs:{shape:[L,1,A]}}),F.push(me));const de=c$({inputs:{a:ne,b:me},backend:r});V=Rw({inputs:{x:de},backend:r,attrs:{axis:ce,keepDims:!0}}),F.push(de)}else{const ee=_s(n.dtype,e.dtype),ae=new OU(E,_,[L,y,b],t,s,U,Z,Y,te),P=[R,O];if(i!=null&&P.push(i),Y&&P.push(a),te){const H=r.makeTensorInfo([],"float32",Da(o,"float32"));P.push(H),F.push(H)}V=r.runWebGLProgram(ae,P,ee)}const j=$e({inputs:{x:V},backend:r,attrs:{shape:k}});F.push(V);for(const ee of F)r.disposeIntermediateTensorInfo(ee);return j}function Exe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:u,transposeB:h,activation:d,leakyreluAlpha:p}=s;return J0({a:r,b:i,transposeA:u,transposeB:h,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:p,activation:d})}const $xe={kernelName:Xf,backendName:"webgl",kernelFunc:Exe};const L3="return abs(x);";function Ixe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),a=CU(i.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new wo(s.shape,L3):r=new Di(s.shape,L3),t.runWebGLProgram(r,[s],s.dtype)}const _xe={kernelName:wp,backendName:"webgl",kernelFunc:Ixe};const Axe=Kr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Rxe=gt({opSnippet:Axe}),Dxe={kernelName:eh,backendName:"webgl",kernelFunc:Rxe};const Oxe=Kr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Fxe=gt({opSnippet:Oxe}),Lxe={kernelName:th,backendName:"webgl",kernelFunc:Fxe};const M3="return a + b;",Mxe=ts({opSnippet:M3,packedOpSnippet:M3,supportsComplex:!0,cpuKernelImpl:H0e}),zxe={kernelName:du,backendName:"webgl",kernelFunc:Mxe};class Pxe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class Bxe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function d0(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return er({inputs:{x:s[0]},backend:t});if(s.length>ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),h=d0({inputs:s.slice(0,u),backend:t}),d=d0({inputs:s.slice(u),backend:t});return d0({inputs:[h,d],backend:t})}const r=s.map(u=>u.dtype).reduce((u,h)=>_s(u,h)),i=s.map(u=>u.shape),o=ie().getBool("WEBGL_PACK")?new Bxe(s[0].shape,i):new Pxe(s[0].shape,i);return t.runWebGLProgram(o,s,r)}const Vxe={kernelName:vp,backendName:"webgl",kernelFunc:d0};function Uxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=st(i,r.shape);let h=u;const d=Zt(h,o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,o)),Qn("all",h,o);const[m,y]=Un(p.shape,h),b=he(y),x=$e({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=Tu(x,x.dtype,"all",t);let S;if(a){const C=un(m,u);S=$e({inputs:{x:w},backend:t,attrs:{shape:C}})}else S=$e({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),S}const jxe={kernelName:fb,backendName:"webgl",kernelFunc:Uxe};function Wxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=st(i,r.shape);let h=u;const d=Zt(h,o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,o)),Qn("any",h,o);const[m,y]=Un(p.shape,h),b=he(y),x=$e({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=Tu(x,x.dtype,"any",t);let S;if(a){const C=un(m,u);S=$e({inputs:{x:w},backend:t,attrs:{shape:C}})}else S=$e({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),S}const Gxe={kernelName:pb,backendName:"webgl",kernelFunc:Wxe};class Hxe{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const o=t==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class qxe{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,D(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],a=Math.ceil(i/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,h=It(u),d=gs("coords",u);let p,m;if(a===1){m=u+1;const O=It(m);p=`
        ${O} sourceLocR = ${O}(${d.join()}, 0);
        ++${d[u-1]};
        ${O} sourceLocG = ${O}(${d.join()}, 0);
        ++${d[u-2]};
        ${O} sourceLocA = ${O}(${d.join()}, 0);
        --${d[u-1]};
        ${O} sourceLocB = ${O}(${d.join()}, 0);
        --${d[u-2]};`}else m=u,p=`
        ${h} sourceLocR = coords;
        ++${d[u-1]};
        ${h} sourceLocG = coords;
        ++${d[u-2]};
        ${h} sourceLocA = coords;
        --${d[u-1]};
        ${h} sourceLocB = coords;
        --${d[u-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(O=>"int "+O),w=gs("sourceLocR",m-1).concat("inIdx.r"),S=gs("sourceLocG",m-1).concat("inIdx.g"),C=gs("sourceLocB",m-1).concat("inIdx.b"),N=gs("sourceLocA",m-1).concat("inIdx.a"),k=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${N.join()})));`,_=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${C.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${N.join()}) : 0.)`,R=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[u-1]} < ${o[u-1]-1};
        bool hasNextRow = ${d[u-2]} < ${o[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function LU(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const a=iw(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},u=new Hxe(o,t,s==null),h=[e];s!=null&&h.push(s);const d=n.runWebGLProgram(u,h,"int32");if(d.shape[1]===1)return d;const p=LU(n,e,t,d);return n.disposeIntermediateTensorInfo(d),p}function MU(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],a=iw(i),o=new qxe(r,a,t,s==null),u=s==null?[e]:[e,s],h=n.runWebGLProgram(o,u,"int32");if(h.shape.length===e.shape.length){const d=MU(n,e,t,h);return n.disposeIntermediateTensorInfo(h),d}return h}function zU(n,e,t,s){const r=[t];if(Qn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ie().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],a=n.texData.get(e.dataId),o=a!==null&&a.isPacked;let u=e;o&&(u=n.unpackTensor(e),i.push(u));const[h,d]=Un(u.shape,r),p=he(d),m=$e({inputs:{x:u},backend:n,attrs:{shape:[-1,p]}});i.push(m);const y=LU(n,m,s);i.push(y);const b=$e({inputs:{x:y},backend:n,attrs:{shape:h}});return i.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return MU(n,e,s)}function Kxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=st(i,r.shape);const o=Zt(a,r.shape.length);let u=r;const h=[];o!=null&&(u=xs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(u),a=cn(a.length,u.shape.length)),Qn("argMax",[a[0]],u.shape.length);const d=zU(t,u,a[0],"max");return h.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const Xxe={kernelName:Sp,backendName:"webgl",kernelFunc:Kxe};function Yxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=st(i,r.shape);const o=Zt(a,r.shape.length);let u=r;const h=[];o!=null&&(u=xs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(u),a=cn(a.length,u.shape.length)),Qn("argMin",[a[0]],u.shape.length);const d=zU(t,u,a[0],"min");return h.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const Jxe={kernelName:Tp,backendName:"webgl",kernelFunc:Yxe};const Zxe=Kr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Qxe=gt({opSnippet:Zxe}),ewe={kernelName:nh,backendName:"webgl",kernelFunc:Qxe};const twe=Kr+"return log(x + sqrt(x * x + 1.0));",nwe=gt({opSnippet:twe}),swe={kernelName:sh,backendName:"webgl",kernelFunc:nwe};const rwe=Kr+`
  return atan(x);
`,iwe=gt({opSnippet:rwe}),awe={kernelName:rh,backendName:"webgl",kernelFunc:iwe};const owe=u$+`
  return atan(a, b);
`,lwe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Su+`
  return result;
`,uwe=ts({opSnippet:owe,packedOpSnippet:lwe}),cwe={kernelName:ah,backendName:"webgl",kernelFunc:uwe};const hwe=Kr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,dwe=gt({opSnippet:hwe}),fwe={kernelName:ih,backendName:"webgl",kernelFunc:dwe};class dp{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,u=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,S=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let C="0.0";if(x||(C="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${u});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?w:S:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const E=Math.floor(a/4)*4,_=a%4,R=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${E};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${k});
      }
    `}}class h${constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,u=e.strideHeight,h=e.strideWidth,d=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,S=e.padInfo.top,C=e.padInfo.left;this.outputShape=e.outShape;const N=t==="avg";let k="0.0";if(N||(k="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${u}, ${h});
        const ivec3 pads = ivec3(${w}, ${S}, ${C});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const R=Math.floor(a/4)*4,O=a%4,F=`
      if (${N}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${u}, ${h});
      const ivec3 pads = ivec3(${w}, ${S}, ${C});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${R};
            if (${O===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${O===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${O===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${F}
            }
          }
        }
        setOutput(${_});
      }
    `}}function pwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;cd(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,h=1;D(Zn(a,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Hr(r.shape,i,a,h,o,u);if(d.filterWidth===1&&d.filterHeight===1&&it(d.inShape,d.outShape))return er({inputs:{x:r},backend:t});const p=new dp(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const mwe={kernelName:Cp,backendName:"webgl",kernelFunc:pwe};function gwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:u,dataFormat:h}=s,d=[1,1,1],p=Oa(r.shape,i,a,d,o,u,h),m=new h$(p,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const ywe={kernelName:Np,backendName:"webgl",kernelFunc:gwe};class bwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=u-1-e.padInfo.top,p=h-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class xwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,b=p-1-e.padInfo.front,x=m-1-e.padInfo.top,w=y-1-e.padInfo.left,S=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function wwe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:u,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Oa(a.shape,o,u,p,h,d),y=new xwe(m);return t.runWebGLProgram(y,[r],a.dtype)}const vwe={kernelName:gb,backendName:"webgl",kernelFunc:wwe};function Swe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;cd([r,i],"avgPoolGrad");const{filterSize:o,strides:u,pad:h}=s,d=Hr(a.shape,o,u,1,h),p=new bwe(d);return t.runWebGLProgram(p,[r],a.dtype)}const Twe={kernelName:mb,backendName:"webgl",kernelFunc:Swe};function Cwe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return J0({a:r,b:i,transposeA:a,transposeB:o,backend:t})}const Nwe={kernelName:kp,backendName:"webgl",kernelFunc:Cwe};class kwe{constructor(e,t,s,r,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Xe(e,t),Xe(e,s);let o="0.0";r!=null&&(Xe(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";i!=null&&(Xe(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Ewe{constructor(e,t,s,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Xe(e,t),Xe(e,s);let o="vec4(0.0)";r!=null&&(Xe(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";i!=null&&(Xe(e,i),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const $we=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:a,scale:o}=n;D(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const h=[s,r,i];let d=null;a!=null&&(d=a.shape,h.push(a));let p=null;o!=null&&(p=o.shape,h.push(o));const m=ie().getBool("WEBGL_PACK_NORMALIZATION")?new Ewe(s.shape,r.shape,i.shape,d,p,u):new kwe(s.shape,r.shape,i.shape,d,p,u);return e.runWebGLProgram(m,h,h[0].dtype)},Iwe={kernelName:Pp,backendName:"webgl",kernelFunc:$we};class _we{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=It(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Awe(this.rank);let r;const i=e.map((a,o)=>`sourceLoc.${gC[o]} = start[${o}] + coords.${gC[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const gC=["x","y","z","w","u","v"];function Awe(n){if(n===1)return"sourceLoc";if(n<=6)return gC.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Rwe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=It(this.rank),s=gs("coords",this.rank),r=gs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,p)=>`start[${p}]`).join()});`:e.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${o}
        ${u}
        setOutput(result);
      }
    `}}function Dwe(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let o=BN(e,ze(n.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,u+1),i}function yd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[o,u]=rw(r,i,a);if(MN(r,o,u),he(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=t.texData.get(r.dataId),m=Cbe(p.values,o,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,m)}const{isPacked:h}=t.texData.get(r.dataId),d=PN(r.shape,o,u);if(h||!d){const p=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rwe(u):new _we(u),m=[o];return t.runWebGLProgram(p,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),Dwe(r,o,u,t)}const Owe={kernelName:pm,backendName:"webgl",kernelFunc:yd};const Fwe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;D(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((C,N)=>C*N),u=jm(r.shape,i,o),h=Wm(u.length,i.length),d=Gm(r.shape,i,o),p=HN(a,i.length),m=qN(d,a,i.length),y=[],b=$e({inputs:{x:r},backend:t,attrs:{shape:u}}),x=xs({inputs:{x:b},backend:t,attrs:{perm:h}}),w=$e({inputs:{x},backend:t,attrs:{shape:d}}),S=yd({inputs:{x:w},backend:t,attrs:{begin:p,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(C=>t.disposeIntermediateTensorInfo(C)),S},Lwe={kernelName:Ep,backendName:"webgl",kernelFunc:Fwe};function Mwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.readSync(r.dataId),u=t.readSync(i.dataId),h=TU(o,u,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,h)}const zwe={kernelName:yb,backendName:"webgl",kernelFunc:Mwe};const Pwe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Bwe=`
  return float(int(a.r) & int(b.r));
`;function Vwe(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=ie().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const u=t.texData.get(s.dataId).values,h=t.texData.get(r.dataId).values,[d,p]=K0e(s.shape,r.shape,u,h,s.dtype),m=t.makeTensorInfo(p,s.dtype),y=t.texData.get(m.dataId);return y.values=d,m}let o;return i?o=new md(Pwe,s.shape,r.shape,!1):o=new lu(Bwe,s.shape,r.shape),t.runWebGLProgram(o,[s,r],s.dtype)}const Uwe={kernelName:$p,backendName:"webgl",kernelFunc:Vwe};function jwe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),o=Xe(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Wwe={kernelName:bb,backendName:"webgl",kernelFunc:jwe};const Gwe="return float(a != b);",PU=ts({opSnippet:Gwe,cpuKernelImpl:mbe,dtype:"bool"}),Hwe={kernelName:nm,backendName:"webgl",kernelFunc:PU};function ag(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return er({inputs:{x:r.complexTensorInfos.real},backend:t})}const qwe={kernelName:Zb,backendName:"webgl",kernelFunc:ag};const Kwe="return float(int(x));";function Xwe(n,e){const t=new Di(n.shape,Kwe),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function yC(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return er({inputs:{x:r},backend:t});const a=gn(r.shape),o=yC({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Ko({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){const a=ag({inputs:{input:r},backend:t}),o=yC({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(a),o}if(!u2(r.dtype,i)){const a=er({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[o,u,h]=X0e(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,u,h)}if(i==="int32")return Xwe(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",zn("bool",1)),u=PU({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const Ywe={kernelName:oh,backendName:"webgl",kernelFunc:yC};const z3="return ceil(x);",Jwe=gt({opSnippet:z3,packedOpSnippet:z3,cpuKernelImpl:Y0e}),Zwe={kernelName:lh,backendName:"webgl",kernelFunc:Jwe};class Qwe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class eve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function tve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;ie().getBool("WEBGL_PACK_CLIP")?o=new eve(r.shape):o=new Qwe(r.shape);const u=[[i],[a]];return t.runWebGLProgram(o,[r],r.dtype,u)}const nve={kernelName:uh,backendName:"webgl",kernelFunc:tve};class sve{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function P3(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function rve(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new sve(s.shape),a=[P3(s,r.complexTensorInfos.real),P3(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,a,a[0].dtype)}const ive={kernelName:Ip,backendName:"webgl",kernelFunc:rve};class ave{constructor(e){this.outputShape=[],this.outputShape=zi(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class ove{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=zi(e,t);const s=this.outputShape,r=s.length,i=It(r),a=gs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((x,w)=>`T${w}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let x=1;x<u.length;x++)u[x]=u[x-1]+e[x][t];const h=o[t],d=o.slice(-2),p=o.join();let m=`if (${h} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let x=1;x<u.length;x++){const w=u[x-1];m+=`
        if (${h} < ${u[x]}  && ${h} >= ${u[x-1]}) {
          return getChannel(
            getT${x}(${Hy(o,h,w)}),
            vec2(${Hy(d,h,w)}));
        }`}const y=u.length,b=u[u.length-1];m+=`
        return getChannel(
          getT${y}(${Hy(o,h,b)}),
          vec2(${Hy(d,h,b)}));`,this.userCode=`
      float getValue(${o.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Hy(n,e,t){const s=n.indexOf(e);return n.map((i,a)=>a===s?`${i} - ${t}`:i).join()}function Dw(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return er({inputs:{x:r.complexTensorInfos.imag},backend:t})}const lve={kernelName:zb,backendName:"webgl",kernelFunc:Dw};function If(n,e,t){const s=n[0].dtype;if(s==="complex64"){const y=n.map(C=>ag({inputs:{input:C},backend:t})),b=n.map(C=>Dw({inputs:{input:C},backend:t})),x=If(y,e,t),w=If(b,e,t),S=Ko({inputs:{real:x,imag:w},backend:t});return y.forEach(C=>t.disposeIntermediateTensorInfo(C)),b.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),S}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map(k=>{const _=[-1,he(k.shape.slice(e))];return $e({inputs:{x:k},backend:t,attrs:{shape:_}})}),b=y.map(k=>({vals:t.readSync(k.dataId),shape:k.shape})),x=zi(y.map(k=>k.shape),1),w=y[0].shape[0]===1,S=J0e(b,x,s,w),C=zi(n.map(k=>k.shape),e),N=t.makeTensorInfo(C,s,S);return y.forEach(k=>t.disposeIntermediateTensorInfo(k)),N}const i=n.filter(y=>he(y.shape)>0),a=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=a?new Di(n[0].shape,mo):new wo(n[0].shape,mo);return t.runWebGLProgram(y,n,s)}const o=ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){const y=[];for(let x=0;x<i.length;x+=o){const w=i.slice(x,x+o);y.push(If(w,e,t))}const b=If(y,e,t);for(const x of y)t.disposeIntermediateTensorInfo(x);return b}if(a){const y=new ove(i.map(b=>b.shape),e);return t.runWebGLProgram(y,i,s)}const{tensors2D:u,outShape:h}=uve(i,e,t),d=new ave(u.map(y=>y.shape)),p=t.runWebGLProgram(d,u,s);u.forEach(y=>t.disposeIntermediateTensorInfo(y));const m=$e({inputs:{x:p},attrs:{shape:h},backend:t});return t.disposeIntermediateTensorInfo(p),m}function uve(n,e,t){const s=zi(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>$e({inputs:{x:i},attrs:{shape:[-1,he(i.shape.slice(e))]},backend:t})),outShape:s}}function BU(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=st(r,e[0].shape)[0],a=e.map(h=>h.shape);jN(a,i);const o=zi(e.map(h=>h.shape),i);if(he(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const u=e.filter(h=>he(h.shape)>0);return u.length===1?er({inputs:{x:u[0]},backend:t}):If(u,i,t)}const cve={kernelName:_p,backendName:"webgl",kernelFunc:BU};class VU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,u=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",S=w?1:2,C=w?2:3,N=w?3:1;let k="",E="";s&&(r?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:k=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${u}, ${h});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${N}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${C}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${E}
        setOutput(result);
      }
    `}}class hve{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterDepth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class UU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const S=w*2;if(m+=`
           xC = xCCorner + ${S*u};
           `,o===1){if(S<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,u===1&&S>0?m+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const C=a%2===0?hb(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${C};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,u>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:m+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):C===1?m+=`
                     xC${S+1} = xTexelC${S};
                     `:m+=`
                     xCOffset = xC + ${C};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(m+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(m+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(m+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class dve{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);const{dataFormat:s}=t,r=Ss(),i=s==="channelsLast",a=i?1:2,o=i?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}function Z0(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function jU({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u=n.shape,h=s.texData.get(n.dataId),d=t.inChannels,p=u[0]*u[1]*u[2],m=t.outChannels,y=t.dataFormat==="channelsLast",b=!1,x=!1;let w;const S=[];if(i!=null){const k=Z0(i.shape,y);k!=null&&(i=$e({inputs:{x:i},backend:s,attrs:{shape:k}}),S.push(i))}if(r!=null){const k=Z0(r.shape,y);k!=null&&(r=$e({inputs:{x:r},backend:s,attrs:{shape:k}}),S.push(r))}if(!((p===1||m===1)&&d>FU)&&h.isPacked&&y&&h.texture!=null&&u[2]%2!==0&&it(h.shape.slice(-3),u.slice(-3))){const k=u[0]*u[1]*(u[2]+1),E={dataId:n.dataId,shape:[1,k,t.inChannels],dtype:n.dtype},_=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,D(cp(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const R=$e({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});S.push(R);const O=J0({a:E,b:R,backend:s,transposeA:b,transposeB:x,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),F=s.texData.get(O.dataId);D(F.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=_,F.shape=t.outShape,w=er({inputs:{x:O},backend:s}),w.shape=t.outShape,S.push(O)}else{const k=t.outHeight*t.outWidth,E=$e({inputs:{x:n},backend:s,attrs:{shape:y?[t.batchSize,k,t.inChannels]:[t.batchSize,t.inChannels,k]}}),_=$e({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=J0({a:y?E:_,b:y?_:E,transposeA:!y,transposeB:x,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});w=$e({inputs:{x:R},backend:s,attrs:{shape:t.outShape}}),S.push(E),S.push(_),S.push(R)}for(const k of S)s.disposeIntermediateTensorInfo(k);return w}function WU({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:u,filterHeight:h,inChannels:d,outWidth:p,outHeight:m,dataFormat:y}=t,b=y==="channelsLast",x=u*h*d,w=m*p,S=[t.batchSize,x,w],C=!0,N=!1,k=[];if(i!=null){const j=Z0(i.shape,b);j!=null&&(i=$e({inputs:{x:i},backend:s,attrs:{shape:j}}),k.push(i))}if(r!=null){const j=Z0(r.shape,b);j!=null&&(r=$e({inputs:{x:r},backend:s,attrs:{shape:j}}),k.push(r))}const E=$e({inputs:{x:e},backend:s,attrs:{shape:[1,x,he(e.shape)/x]}});k.push(E);const _=new dve(S,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],O=s.runWebGLProgram(_,[n],"float32",R),F=$e({inputs:{x:O},backend:s,attrs:{shape:S}});k.push(O),k.push(F);const L=r!=null,A=i!=null,U=o==="leakyrelu",Y=o?hp(o,!0):null,te=new OU(b?F.shape:E.shape,b?E.shape:F.shape,b?[t.batchSize,w,t.outChannels]:[t.batchSize,t.outChannels,w],C,N,L,Y,A,U),Z=b?[F,E]:[E,F];if(r&&Z.push(r),A&&Z.push(i),U){const j=s.makeTensorInfo([],"float32",Da(a,"float32"));Z.push(j),k.push(j)}const B=s.runWebGLProgram(te,Z,"float32"),V=$e({inputs:{x:B},backend:s,attrs:{shape:t.outShape}});k.push(B);for(const j of k)s.disposeIntermediateTensorInfo(j);return V}function fve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:u,dilations:h,dimRoundingMode:d}=s,p=Fa(u),m=Vn(r.shape,i.shape,a,h,o,d,!1,p);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=jU({x:r,filter:i,convInfo:m,backend:t});else if(m.strideWidth<=2&&p==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){const x=new UU(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=t.runWebGLProgram(x,[r,i],"float32",w)}else if(ie().getBool("WEBGL_CONV_IM2COL"))y=WU({x:r,filter:i,convInfo:m,backend:t});else{const x=new VU(m);y=t.runWebGLProgram(x,[r,i],"float32")}const b=$e({inputs:{x:y},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(y),b}const pve={kernelName:Ap,backendName:"webgl",kernelFunc:fve};class mve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class gve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,u=s-1-e.padInfo.left,h=a?1:2,d=a?2:3,p=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class yve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class bve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,u=t-1-e.padInfo.front,h=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function xve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:u,dimRoundingMode:h,filterShape:d}=s,p=Fa(u),m=Vn(r.shape,d,a,1,o,h,!1,p),y=new mve(m);return t.runWebGLProgram(y,[r,i],"float32")}const wve={kernelName:wb,backendName:"webgl",kernelFunc:xve};class vve{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=hs(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Sve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:u,dataFormat:h,dimRoundingMode:d}=s,p=Fa(h),m=Vn(a,i.shape,o,1,u,d,!1,p);if(ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new vve(m);return t.runWebGLProgram(b,[r,i],"float32",y)}else{const y=new gve(m);return t.runWebGLProgram(y,[r,i],"float32")}}const Tve={kernelName:Rp,backendName:"webgl",kernelFunc:Sve};function Cve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s,h=Vo(r.shape,i.shape,a,u,o),d=new hve(h);return t.runWebGLProgram(d,[r,i],"float32")}const Nve={kernelName:Dp,backendName:"webgl",kernelFunc:Cve};function kve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:u}=s,h=Vo(r.shape,u,a,1,o),d=new yve(h);return t.runWebGLProgram(d,[r,i],"float32")}const Eve={kernelName:vb,backendName:"webgl",kernelFunc:kve};function $ve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:u}=s,h=Vo(u,i.shape,o,1,a),d=new bve(h);return t.runWebGLProgram(d,[r,i],"float32")}const Ive={kernelName:Sb,backendName:"webgl",kernelFunc:$ve};const _ve=gd+`
  return cos(x);
`,Ave=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Su}
  return result;
`,Rve=gt({opSnippet:_ve,packedOpSnippet:Ave}),Dve={kernelName:ch,backendName:"webgl",kernelFunc:Rve};const Ove=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Fve=gt({opSnippet:Ove}),Lve={kernelName:hh,backendName:"webgl",kernelFunc:Fve};class Mve{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,u,h]=e,[d]=t,[p,m]=s;this.outputShape=[d,p,m,h];const y=r==="bilinear"?1:0,[b,x]=[`${o-1}.0`,`${u-1}.0`],[w,S,C]=p>1?[`${(o-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[N,k,E]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${N});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${k};

        float in_y = ${C};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const zve=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:u,extrapolationValue:h}=s,d=new Mve(r.shape,i.shape,o,u,h);return t.runWebGLProgram(d,[r,i,a],"float32")},Pve={kernelName:Cb,backendName:"webgl",kernelFunc:zve};var fp;(function(n){n.Prod="*",n.Sum="+"})(fp||(fp={}));class B3{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===fp.Prod?"1.0":"0.0",o=s?a:`getX(${V3(i,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${u-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${u}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${It(i)} coords = getOutputCoords();
        int end = ${U3(i,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${U3(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${V3(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function V3(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function U3(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function GU(n,e,t,s,r,i){const a=e.shape.length,o=Zt([s],a);let u=e;o!=null&&(u=xs({inputs:{x:e},backend:t,attrs:{perm:o}}));const h=cn(1,a)[0];if(h!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=u.shape[h];let p=er({inputs:{x:u},backend:t});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new B3(n,u.shape,!1,i),b=[[m]],x=p;p=t.runWebGLProgram(y,[p],p.dtype,b),t.disposeIntermediateTensorInfo(x)}if(r){const m=new B3(n,u.shape,r,i),y=p;p=t.runWebGLProgram(m,[p],p.dtype),t.disposeIntermediateTensorInfo(y)}if(o!=null){const m=Uo(o),y=xs({inputs:{x:p},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(u),y}return p}function Bve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return GU(fp.Prod,r,t,i,a,o)}const Vve={kernelName:Tb,backendName:"webgl",kernelFunc:Bve};function Uve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return GU(fp.Sum,r,t,i,a,o)}const jve={kernelName:Op,backendName:"webgl",kernelFunc:Uve};function Wve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const u=t.readSync(r.dataId),h=t.readSync(i.dataId),d=TU(u,h,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const u=t.bufferSync(r),h=t.bufferSync(i),d=q0e(u,h,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Gve={kernelName:Nb,backendName:"webgl",kernelFunc:Wve};class Hve{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function qve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,o=r.shape[0],u=a==="NHWC"?r.shape[1]:r.shape[2],h=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],p=u*i,m=h*i,y=d/(i*i),b=a==="NHWC"?[o,p,m,y]:[o,y,p,m],x=new Hve(b,i,a);return t.runWebGLProgram(x,[r],r.dtype)}const Kve={kernelName:kb,backendName:"webgl",kernelFunc:qve};class HU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,u=e.outChannels/e.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}}class qU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,u=e.strideWidth,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,m=p;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<p;S++)y+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<p;S++)y+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const C=S*2;if(y+=`
          xC = xCCorner + ${C*h};
          `,u===1){if(C<p&&(o%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }
              `,h===1&&C>0?y+=`
                xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                  } else {
                    xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xC${C} = xTexelC${C};
                `,C+1<p)){const N=o%2===0?hb(h):h;h%2===0&&o%2===1||h%2!==0&&o%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${N};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                    xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${C+1}.zw = vec2(0.0);
                    }
                    xTexelC${C+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                    } else {
                     xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                    }
                    `:y+=`
                    xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                    `):N===1?y+=`
                    xC${C+1} = xTexelC${C};
                    `:y+=`
                    xCOffset = xC + ${N};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                      xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${C+1}.zw = vec2(0.0);
                      }
                      xTexelC${C+1}Ready = 1;
                    }

                    xC${C+1} = xTexelC${C+1};
                    `}}else C<p&&(o%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.0);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
              `,C+1<p&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(
                  xTexelC${C}.xy, xTexelC${C+1}.xy);
              `,C+1<p&&(y+=`
                  xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                `)));C<p&&(y+=`
            wTexel = getW(r, ${C}, d1, q);
            dotProd += xC${C} * vec4(wTexel.xz, wTexel.xz);
          `,C+1<p&&(y+=`
              wTexel = getW(r, ${C+1}, d1, q);
              dotProd += xC${C+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function Xve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u,dimRoundingMode:h}=s;let d=u;d==null&&(d=[1,1]),D(Zn(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=Vn(r.shape,i.shape,a,d,o,h,!0);let m;ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new qU(p):m=new HU(p);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(m,[r,i],"float32",y)}const Yve={kernelName:Fp,backendName:"webgl",kernelFunc:Xve};class Jve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Zve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,o=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Qve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:h,filterShape:d}=s,p=Vn(r.shape,d,a,o,u,h,!0),m=new Jve(p);return t.runWebGLProgram(m,[r,i],"float32")}const e1e={kernelName:Eb,backendName:"webgl",kernelFunc:Qve};function t1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:u,dimRoundingMode:h,inputShape:d}=s,p=Vn(d,i.shape,a,o,u,h,!0),m=new Zve(p);return t.runWebGLProgram(m,[r,i],"float32")}const n1e={kernelName:$b,backendName:"webgl",kernelFunc:t1e};class s1e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function r1e(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=he(s.shape),a=$e({inputs:{x:s},backend:t,attrs:{shape:[i]}}),o=new s1e(i),u=t.runWebGLProgram(o,[a],a.dtype),h=$e({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),h}const i1e={kernelName:Ib,backendName:"webgl",kernelFunc:r1e};class a1e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:u,dilationHeight:h,dilationWidth:d}=e,{top:p,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function o1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:u}=s,h=Nm(r.shape,i.shape,a,o,"NHWC",u);let d;const p=new a1e(h);d=t.runWebGLProgram(p,[r,i],"float32");const m=$e({inputs:{x:d},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(d),m}const l1e={kernelName:Lp,backendName:"webgl",kernelFunc:o1e};function u1e(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:u}=tk(r,i.length);sk(a.length,u,i);const{path:h,steps:d}=rk(o,u),p=d.length;let m=null,y=a.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:C}=nk(y,u[w]);let N;ik(S)?N=i[w]:(N=xs({inputs:{x:i[w]},backend:t,attrs:{perm:S}}),b.push(N));const k=N.shape.slice();for(let E=0;E<C.length;++E)k.splice(C[E],0,1);it(N.shape,k)||(N=$e({inputs:{x:N},backend:t,attrs:{shape:k}}),b.push(N)),m===null?m=N:(m=c$({inputs:{a:N,b:m},backend:t}),b.push(m))}x<p-1&&(h[x]>=0&&(m=Rw({inputs:{x:m},backend:t,attrs:{axis:h[x]-(a.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const c1e={kernelName:Ab,backendName:"webgl",kernelFunc:u1e};const h1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",d1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,f1e=gt({opSnippet:h1e,packedOpSnippet:d1e}),p1e={kernelName:fh,backendName:"webgl",kernelFunc:f1e};const m1e="return (b >= 0.0) ? a : a * (b + 1.0);",g1e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,y1e=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(g1e,s.shape,r.shape):new lu(m1e,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},b1e={kernelName:Rb,backendName:"webgl",kernelFunc:y1e};const x1e=`
  return vec4(equal(a, b));
`,w1e="return float(a == b);",v1e=ts({opSnippet:w1e,packedOpSnippet:x1e,dtype:"bool",cpuKernelImpl:Z0e}),S1e={kernelName:Mp,backendName:"webgl",kernelFunc:v1e};const T1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${KN};
  float a1 = ${XN};
  float a2 = ${YN};
  float a3 = ${JN};
  float a4 = ${ZN};
  float a5 = ${QN};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,C1e=gt({opSnippet:T1e}),N1e={kernelName:ph,backendName:"webgl",kernelFunc:C1e};const k1e=gd+`
  return exp(x);
`,E1e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,KU=gt({opSnippet:k1e,packedOpSnippet:E1e,cpuKernelImpl:Q0e,dtype:"float32"}),$1e={kernelName:mh,backendName:"webgl",kernelFunc:KU};function bC(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,o=i.shape.slice();let u=r;return r<0&&(D(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+r+1),o.splice(u,0,1),$e({inputs:{x:i},backend:s,attrs:{shape:o}})}const I1e={kernelName:zp,backendName:"webgl",kernelFunc:bC};const j3="return exp(x) - 1.0;",_1e=gt({opSnippet:j3,packedOpSnippet:j3,cpuKernelImpl:ebe}),A1e={kernelName:gh,backendName:"webgl",kernelFunc:_1e};class W3{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function XU(n,e,t){const s=t.texData.get(n.dataId),r=he(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=$e({inputs:{x:n},backend:t,attrs:{shape:[a,i]}}),u=o.shape,h=new W3("real",u,e),d=new W3("imag",u,e),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(h,p,"float32"),y=t.runWebGLProgram(d,p,"float32"),b=Ko({inputs:{real:m,imag:y},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y);const x=$e({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(b),x}function R1e(n){const{inputs:e,backend:t}=n,{input:s}=e;return XU(s,!1,t)}const D1e={kernelName:Db,backendName:"webgl",kernelFunc:R1e};class O1e{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function og(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||cu(r),i==="string"){const a=tn(i,he(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new O1e(s,r),o=[[r]];return e.runWebGLProgram(a,[],i,o)}}const F1e={kernelName:Ob,backendName:"webgl",kernelFunc:og};class L1e{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const M1e={kernelName:Fb,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new L1e(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const G3="return floor(x);",z1e=gt({opSnippet:G3,packedOpSnippet:G3,cpuKernelImpl:tbe}),P1e={kernelName:yh,backendName:"webgl",kernelFunc:z1e};const B1e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,V1e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,U1e=ts({opSnippet:B1e,packedOpSnippet:V1e,dtype:"int32"}),j1e={kernelName:bh,backendName:"webgl",kernelFunc:U1e};class W1e{constructor(e){this.variableNames=["A"];const t=Ss(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class G1e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ss(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const H1e={kernelName:I0,backendName:"webgl",kernelFunc:q1e};let bc,VS=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function q1e(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,h]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,u],p=[h,u,i];if(o||a){const x=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(bc==null||x!==VS)&&(VS=x,bc=document.createElement("canvas").getContext("2d",{willReadFrequently:VS})),bc.canvas.width=u,bc.canvas.height=h,bc.drawImage(r,0,0,u,h),r=bc.canvas}const m=t.makeTensorInfo(d,"int32");t.texData.get(m.dataId).usage=xr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const y=ie().getBool("WEBGL_PACK")?new G1e(p):new W1e(p),b=t.runWebGLProgram(y,[m],"int32");return t.disposeData(m.dataId),b}function K1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=Fa(d),w=Vn(r.shape,i.shape,u,p,h,m,!1,x);let S;const C=[],N=a!=null,k=o!=null,E=y==="leakyrelu",_=()=>{const O=[r,i],F=(L,A)=>{if(A==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){const U=$e({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return C.push(U),U}return L};if(N&&O.push(F(a,d)),k&&O.push(F(o,d)),E){const L=t.makeTensorInfo([],"float32",Da(b,"float32"));O.push(L),C.push(L)}return O};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=jU({x:r,filter:i,convInfo:w,backend:t,bias:a,activation:y,preluActivationWeights:o,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){const O=y?hp(y,!0):null,F=new UU(w,N,O,k,E),L=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=_();S=t.runWebGLProgram(F,A,"float32",L)}else if(ie().getBool("WEBGL_CONV_IM2COL"))S=WU({x:r,filter:i,convInfo:w,backend:t,bias:a,activation:y,preluActivationWeights:o,leakyreluAlpha:b});else{const O=y?hp(y,!1):null,F=new VU(w,N,O,k,E),L=_();S=t.runWebGLProgram(F,L,"float32")}const R=$e({inputs:{x:S},backend:t,attrs:{shape:w.outShape}});return C.push(S),C.forEach(O=>t.disposeIntermediateTensorInfo(O)),R}const X1e={kernelName:Yf,backendName:"webgl",kernelFunc:K1e};function Y1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:u,pad:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),D(Zn(u,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${x}'`);const w=Vn(r.shape,i.shape,u,x,h,p,!0),S=ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,C=m?hp(m,S):null,N=[r,i],k=a!=null,E=o!=null,_=m==="leakyrelu";if(k&&N.push(a),E&&N.push(o),_){const L=t.makeTensorInfo([],"float32",Da(y,"float32"));N.push(L),b.push(L)}let R;S?R=new qU(w,k,C,E,_):R=new HU(w,k,C,E,_);const O=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],F=t.runWebGLProgram(R,N,"float32",O);return b.forEach(L=>t.disposeIntermediateTensorInfo(L)),F}const J1e={kernelName:Jf,backendName:"webgl",kernelFunc:Y1e};class Z1e{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=It(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function Q1e(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=he(s.shape),[u,h,d,p]=sw(s,r),m=$e({inputs:{x:r},backend:t,attrs:{shape:[h,a]}}),y=$e({inputs:{x:s},backend:t,attrs:{shape:[he(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const S=t.readSync(r.dataId),C=t.bufferSync(s),N=nbe(S,C,s.dtype,h,a,d,p,s.shape,o);return t.makeTensorInfo(u,s.dtype,N.values)}const b=new Z1e(a,p,[h,d],s.shape),x=t.runWebGLProgram(b,[y,m],y.dtype),w=$e({inputs:{x},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),w}const eSe={kernelName:Lb,backendName:"webgl",kernelFunc:Q1e};class tSe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=It(this.rank),r=nSe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function nSe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function YU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,u=st(a,r.shape)[0];if(ie().get("DEBUG")){const C=t.readSync(i.dataId),N=r.shape[u];for(let k=0;k<C.length;++k){const E=C[k];D(E<=N-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${N-1}]`)}}const h=ok(r,i,u,o),d=he(i.shape),p=[],m=$e({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=$e({inputs:{x:i},backend:t,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(m),p.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const C=t.bufferSync(y),N=t.bufferSync(m),k=sbe(N,C,b);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(h.outputShape,k.dtype,k.values)}const x=new tSe(m.shape,b),w=t.runWebGLProgram(x,[m,y],m.dtype);p.push(w);const S=$e({inputs:{x:w},backend:t,attrs:{shape:h.outputShape}});return p.forEach(C=>t.disposeIntermediateTensorInfo(C)),S}const sSe={kernelName:Bp,backendName:"webgl",kernelFunc:YU};const rSe="return float(a > b);",iSe=`
  return vec4(greaterThan(a, b));
`,aSe=ts({opSnippet:rSe,packedOpSnippet:iSe,cpuKernelImpl:rbe,dtype:"bool"}),oSe={kernelName:Vp,backendName:"webgl",kernelFunc:aSe};const lSe="return float(a >= b);",uSe=`
  return vec4(greaterThanEqual(a, b));
`,cSe=ts({opSnippet:lSe,packedOpSnippet:uSe,dtype:"bool",cpuKernelImpl:ibe}),hSe={kernelName:xh,backendName:"webgl",kernelFunc:cSe};function dSe(n){const{inputs:e,backend:t}=n,{input:s}=e;return XU(s,!0,t)}const fSe={kernelName:Mb,backendName:"webgl",kernelFunc:dSe};const pSe="return float(!isnan(x) && !isinf(x));",mSe=gt({opSnippet:pSe,dtype:"bool"}),gSe={kernelName:vh,backendName:"webgl",kernelFunc:mSe};const ySe="return float(isinf(x));",bSe=gt({opSnippet:ySe,dtype:"bool"}),xSe={kernelName:Sh,backendName:"webgl",kernelFunc:bSe};const wSe="return float(isnan(x));",vSe=gt({opSnippet:wSe,dtype:"bool"}),SSe={kernelName:Th,backendName:"webgl",kernelFunc:vSe};const TSe="return float(a < b);",CSe=`
  return vec4(lessThan(a, b));
`,NSe=ts({opSnippet:TSe,packedOpSnippet:CSe,cpuKernelImpl:abe,dtype:"bool"}),kSe={kernelName:jp,backendName:"webgl",kernelFunc:NSe};const ESe="return float(a <= b);",$Se=`
  return vec4(lessThanEqual(a, b));
`,ISe=ts({opSnippet:ESe,packedOpSnippet:$Se,cpuKernelImpl:obe,dtype:"bool"}),_Se={kernelName:Wp,backendName:"webgl",kernelFunc:ISe};function ASe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=lbe(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const RSe={kernelName:Pb,backendName:"webgl",kernelFunc:ASe};const DSe=gd+`
  return x < 0.0 ? 0./0. : log(x);
`,OSe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,FSe=gt({opSnippet:DSe,packedOpSnippet:OSe,cpuKernelImpl:ube}),LSe={kernelName:Ch,backendName:"webgl",kernelFunc:FSe};const MSe=gd+`
  return log(1.0 + x);
`,zSe=gt({opSnippet:MSe}),PSe={kernelName:Nh,backendName:"webgl",kernelFunc:zSe};const BSe="return float(a >= 1.0 && b >= 1.0);",VSe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,USe=ts({opSnippet:BSe,packedOpSnippet:VSe,dtype:"bool"}),jSe={kernelName:Gp,backendName:"webgl",kernelFunc:USe};const WSe="return float(!(x >= 1.0));",GSe=gt({opSnippet:WSe}),HSe={kernelName:Hp,backendName:"webgl",kernelFunc:GSe};const qSe="return float(a >= 1.0 || b >= 1.0);",KSe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,XSe=ts({opSnippet:qSe,packedOpSnippet:KSe,dtype:"bool"}),YSe={kernelName:qp,backendName:"webgl",kernelFunc:XSe};class JSe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let u;const h=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${h})`:i===1?u=`1.0/(${h})`:u=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}class ZSe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let u;const h=`float(${s}) + float(${r}) * sum`;i===.5?u=`inversesqrt(${h})`:i===1?u=`1.0/(${h})`:u=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}const QSe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:u}=s,h=ie().getBool("WEBGL_PACK_NORMALIZATION")?new ZSe(r.shape,i,a,o,u):new JSe(r.shape,i,a,o,u);return t.runWebGLProgram(h,[r],r.dtype)},eTe={kernelName:Kp,backendName:"webgl",kernelFunc:QSe};class tTe{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const nTe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:u,alpha:h,beta:d}=s,p=new tTe(r.shape,o,u,h,d);return t.runWebGLProgram(p,[r,i,a],r.dtype)},sTe={kernelName:Bb,backendName:"webgl",kernelFunc:nTe};function rTe(n,e,t,s){const r=he(e),a=he(n.shape)/r,o=$e({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Tu(o,n.dtype,"max",s),h=$e({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),h}function JU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,u=st(i,r.shape);let h=u;const d=Zt(h,o),p=d!=null,m=t.shouldExecuteOnCPU([r]);let y=r;if(p){if(m){const N=t.texData.get(y.dataId).values,k=new Array(o);for(let R=0;R<k.length;R++)k[R]=r.shape[d[R]];const E=l$(N,r.shape,r.dtype,d,k);y=t.makeTensorInfo(k,r.dtype);const _=t.texData.get(y.dataId);_.values=E}else y=Aw(r,d,t);h=cn(h.length,o)}Qn("max",h,o);const[b,x]=Un(y.shape,h);let w=b;a&&(w=un(b,u));let S;if(m){const N=t.texData.get(y.dataId).values,k=cbe(N,he(x),w,r.dtype);S=t.makeTensorInfo(w,r.dtype);const E=t.texData.get(S.dataId);E.values=k}else S=rTe(y,x,w,t);return p&&t.disposeIntermediateTensorInfo(y),S}const iTe={kernelName:Xp,backendName:"webgl",kernelFunc:JU};const aTe=u$+`
  return max(a, b);
`,oTe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Su+`
  return result;
`,lTe=ts({opSnippet:aTe,packedOpSnippet:oTe,cpuKernelImpl:hbe}),uTe={kernelName:kh,backendName:"webgl",kernelFunc:lTe};function cTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;cd(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:u}=s,h=1;D(Zn(a,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Hr(r.shape,i,a,h,o,u);if(d.filterWidth===1&&d.filterHeight===1&&it(d.inShape,d.outShape))return er({inputs:{x:r},backend:t});const p=new dp(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const hTe={kernelName:Yp,backendName:"webgl",kernelFunc:cTe};function dTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:u,dimRoundingMode:h}=s,d=[1,1,1],p=Oa(r.shape,i,a,d,o,h,u),m=new h$(p,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const fTe={kernelName:Jp,backendName:"webgl",kernelFunc:dTe};class pTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=i-1-e.padInfo.top,u=a-1-e.padInfo.left,h=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class mTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,m=h-1-e.padInfo.top,y=d-1-e.padInfo.left,b=u*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function gTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:u,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Oa(a.shape,o,u,p,h,d),y=new h$(m,"max",!0),b=t.runWebGLProgram(y,[a],a.dtype),x=new mTe(m),w=t.runWebGLProgram(x,[r,b],a.dtype);return t.disposeIntermediateTensorInfo(b),w}const yTe={kernelName:Ub,backendName:"webgl",kernelFunc:gTe};function bTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;cd([i,a],"maxPoolGrad");const{filterSize:u,strides:h,pad:d,dimRoundingMode:p}=s,m=Hr(o.shape,u,h,1,d,p),y=!0,b=new dp(m,"max",y),x=t.runWebGLProgram(b,[o],o.dtype),w=new pTe(m),S=t.runWebGLProgram(w,[r,x],o.dtype);return t.disposeIntermediateTensorInfo(x),S}const xTe={kernelName:Vb,backendName:"webgl",kernelFunc:bTe};function wTe(n,e,t,s){let r=new dp(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new dp(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[i,a]}const vTe={kernelName:jb,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,u=t;D(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];D(Zn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Hr(s.shape,r,i,h,a),[p,m]=wTe(s,o,d,u);return[p,m]}};function STe(n,e,t,s){const r=he(e),a=he(n.shape)/r,o=$e({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),u=Tu(o,"float32","mean",s),h=$e({inputs:{x:u},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),h}const TTe={kernelName:Zp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,a=t,o=s.shape.length,u=st(i,s.shape);let h=u;const d=Zt(h,o),p=d!=null,m=a.shouldExecuteOnCPU([s]),y=[];let b=s;if(p){if(m){const k=a.texData.get(b.dataId).values,E=new Array(o);for(let O=0;O<E.length;O++)E[O]=s.shape[d[O]];const _=l$(k,s.shape,s.dtype,d,E);b=a.makeTensorInfo(E,s.dtype);const R=a.texData.get(b.dataId);R.values=_}else b=Aw(s,d,a);y.push(b),h=cn(h.length,o)}Qn("sum",h,o);const[x,w]=Un(b.shape,h);let S=x;r&&(S=un(x,u));const C=STe(b,w,S,a);for(const N of y)a.disposeIntermediateTensorInfo(N);return C}};function CTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=st(i,r.shape);let h=u;const d=Zt(h,o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,r.shape.length)),Qn("min",h,o);const[m,y]=Un(p.shape,h),b=he(y),x=$e({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=Tu(x,x.dtype,"min",t);let S;if(a){const C=un(m,u);S=$e({inputs:{x:w},backend:t,attrs:{shape:C}})}else S=$e({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),S}const NTe={kernelName:Qp,backendName:"webgl",kernelFunc:CTe};const kTe=u$+`
  return min(a, b);
`,ETe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Su+`
  return result;
`,$Te=ts({opSnippet:kTe,packedOpSnippet:ETe,cpuKernelImpl:dbe}),ITe={kernelName:Eh,backendName:"webgl",kernelFunc:$Te};class _Te{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,p)=>d[0]+e[p]+d[1]);const r=e.length,i=It(r),a=t.map(d=>d[0]).join(","),o=t.map((d,p)=>d[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}class ATe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((b,x)=>b[0]+e[x]+b[1]);const r=e.length,i=It(r),a=t.map(b=>b[0]).join(","),o=t.map((b,x)=>b[0]+e[x]).join(","),u=gs("rc",r),h=gs("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${u[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${u[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${u[r-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const RTe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,a=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ATe(s.shape,r,i):new _Te(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)},DTe={kernelName:em,backendName:"webgl",kernelFunc:RTe};const OTe=`if (b == 0.0) return NAN;
  return mod(a, b);`,FTe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Su+`
  return result;
`,LTe=ts({opSnippet:OTe,packedOpSnippet:FTe}),MTe={kernelName:$h,backendName:"webgl",kernelFunc:LTe};class zTe{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const PTe=`
if (a == b) {
  return 1.0;
};
return a / b;`,BTe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,ZU=ts({opSnippet:PTe,packedOpSnippet:BTe,checkOutOfBounds:!0}),VTe={kernelName:dh,backendName:"webgl",kernelFunc:ZU};const H3="return a - b;",QU=ts({opSnippet:H3,packedOpSnippet:H3,supportsComplex:!0,cpuKernelImpl:Dbe}),UTe={kernelName:Wh,backendName:"webgl",kernelFunc:QU};function ej(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=st([i],r.shape),o=JU({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=un(o.shape,a),h=$e({inputs:{x:o},backend:t,attrs:{shape:u}}),d=QU({inputs:{a:r,b:h},backend:t}),p=KU({inputs:{x:d},backend:t}),m=Rw({inputs:{x:p},backend:t,attrs:{axis:a,keepDims:!1}}),y=$e({inputs:{x:m},backend:t,attrs:{shape:u}}),b=ZU({inputs:{a:p,b:y},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const jTe={kernelName:bm,backendName:"webgl",kernelFunc:ej};function WTe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,u=o?r:ej({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),h=u.shape[0],d=u.shape[1],p=new zTe(h,d,i),m=[[a]],y=t.runWebGLProgram(p,[u],"int32",m);return o||t.disposeIntermediateTensorInfo(u),y}const GTe={kernelName:Wb,backendName:"webgl",kernelFunc:WTe};const HTe=Kr+`
  return -x;
`,qTe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function KTe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[a,o]=pbe(i.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}let r;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new wo(s.shape,qTe):r=new Di(s.shape,HTe),t.runWebGLProgram(r,[s],s.dtype)}const XTe={kernelName:tm,backendName:"webgl",kernelFunc:KTe};const YTe=Qx;function JTe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:p}=YTe(h,d,a,o,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const ZTe={kernelName:Gb,backendName:"webgl",kernelFunc:JTe};const QTe=ew;function eCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:h}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=QTe(d,p,a,o,u,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const tCe={kernelName:Hb,backendName:"webgl",kernelFunc:eCe};const nCe=tw;function sCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:h}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),m=a,y=o,b=u,x=h,{selectedIndices:w,selectedScores:S}=nCe(d,p,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const rCe={kernelName:qb,backendName:"webgl",kernelFunc:sCe};class iCe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const aCe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:u}=s,h=he(r.shape),d=new iCe(h,a,o,u),p=$e({inputs:{x:r},backend:t,attrs:{shape:[h]}}),m=t.runWebGLProgram(d,[p],i);t.disposeIntermediateTensorInfo(p);const y=[...r.shape,a],b=$e({inputs:{x:m},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(m),b},oCe={kernelName:rm,backendName:"webgl",kernelFunc:aCe};function Q0(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=ag({inputs:{input:s},backend:t}),i=Q0({inputs:{x:r},backend:t}),a=Dw({inputs:{input:s},backend:t}),o=Q0({inputs:{x:a},backend:t}),u=Ko({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return og({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const lCe={kernelName:Sm,backendName:"webgl",kernelFunc:Q0};function tj(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=ag({inputs:{input:s},backend:t}),i=tj({inputs:{x:r},backend:t}),a=Dw({inputs:{input:s},backend:t}),o=Q0({inputs:{x:a},backend:t}),u=Ko({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),u}else return og({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const uCe={kernelName:sm,backendName:"webgl",kernelFunc:tj};function cCe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return bC({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{Jn(i,d.shape,"All tensors passed to stack must have matching shapes"),D(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=e.map(d=>{const p=bC({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),h=BU({inputs:u,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const hCe={kernelName:im,backendName:"webgl",kernelFunc:cCe};class dCe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,d)=>h[0]+e[d]+h[1]);const r=e.length,i=It(r),a=t.map(h=>h[0]).join(","),o=t.map((h,d)=>h[0]+e[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}class fCe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,w)=>x[0]+e[w]+x[1]);const r=e.length,i=It(r),a=t.map(x=>x[0]).join(","),o=t.map((x,w)=>x[0]+e[w]).join(","),u=gs("rc",r),h=gs("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=r===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const nj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(he(r.shape)===0){const h=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return og({backend:t,attrs:{shape:h,value:a,dtype:r.dtype}})}const o=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fCe(r.shape,i,a):new dCe(r.shape,i,a),u=[[a]];return t.runWebGLProgram(o,[r],r.dtype,u)},pCe={kernelName:am,backendName:"webgl",kernelFunc:nj};const mCe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,gCe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Su+`
  return result;
`,yCe=ts({opSnippet:mCe,packedOpSnippet:gCe}),bCe={kernelName:_h,backendName:"webgl",kernelFunc:yCe};function xCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,u=[],h=st(i,r.shape);let d=h;const p=Zt(d,o);let m=r;p!=null&&(m=xs({inputs:{x:r},backend:t,attrs:{perm:p}}),d=cn(d.length,o),u.push(m)),Qn("prod",d,o);let y;if(t.shouldExecuteOnCPU([m])){const b=t.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:S}=gbe(m.shape,m.dtype,b,d);y=t.makeTensorInfo(w,S,x)}else{const[b,x]=Un(m.shape,d),w=he(x),S=$e({inputs:{x:m},backend:t,attrs:{shape:[-1,w]}}),C=xx(r.dtype),N=Tu(S,C,"prod",t);y=$e({inputs:{x:N},backend:t,attrs:{shape:b}}),u.push(S),u.push(N)}if(a){u.push(y);const b=un(y.shape,h);y=$e({inputs:{x:y},backend:t,attrs:{shape:b}})}return u.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const wCe={kernelName:lm,backendName:"webgl",kernelFunc:xCe};function vCe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,u=r.map(S=>t.readSync(S.dataId)),h=r.map(S=>S.shape),d=t.readSync(i.dataId),p=t.readSync(a.dataId),[m,y,b]=ybe(u,h,d,i.shape,i.dtype,p,a.shape,o),x=m.map(S=>t.makeTensorInfo([S.length],"int32",S)),w=t.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const SCe={kernelName:Kb,backendName:"webgl",kernelFunc:vCe};function TCe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.readSync(s.dataId),o=t.readSync(r.dataId),u=t.readSync(i.dataId),[h,d]=bbe(a,s.shape,s.dtype,o,r.shape,u,i.shape),p=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const CCe={kernelName:Xb,backendName:"webgl",kernelFunc:TCe};function NCe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:u}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),p=t.readSync(a.dataId),m=o.map(w=>t.readSync(w.dataId)),y=o.map(w=>w.shape),[b,x]=xbe(h,r.shape,d,i.shape,i.dtype,p,a.shape,m,y,u);return t.makeTensorInfo(b,i.dtype,x)}const kCe={kernelName:Yb,backendName:"webgl",kernelFunc:NCe};const sj=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,o=wbe(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},ECe={kernelName:Jb,backendName:"webgl",kernelFunc:sj};const $Ce="return 1.0 / x;",ICe=gt({opSnippet:$Ce}),_Ce={kernelName:Ah,backendName:"webgl",kernelFunc:ICe};const ACe=Kr+`
  return (x < 0.0) ? 0.0 : x;
`,RCe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DCe=gt({opSnippet:ACe,packedOpSnippet:RCe}),OCe={kernelName:Rh,backendName:"webgl",kernelFunc:DCe};const FCe=Kr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,LCe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,MCe=gt({opSnippet:FCe,packedOpSnippet:LCe}),zCe={kernelName:Dh,backendName:"webgl",kernelFunc:MCe};class PCe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,u,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class BCe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,u,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function VCe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,h]=o,d=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new BCe(r.shape,u,h,i,a):new PCe(r.shape,u,h,i,a);return t.runWebGLProgram(d,[r],"float32")}const UCe={kernelName:hm,backendName:"webgl",kernelFunc:VCe};class jCe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,u=[s&&a>1?r-1:r,s&&o>1?i-1:i],h=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=u[0]/h[0],p=u[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function WCe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new jCe(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const GCe={kernelName:ex,backendName:"webgl",kernelFunc:WCe};class HCe{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,u,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class qCe{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,u,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?u-1:u],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function KCe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[u,h]=o,d=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qCe(r.shape,u,h,i,a):new HCe(r.shape,u,h,i,a);return t.runWebGLProgram(d,[r],r.dtype)}const XCe={kernelName:cm,backendName:"webgl",kernelFunc:KCe};class YCe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,u=[s&&a>1?r-1:r,s&&o>1?i-1:i],h=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=u[0]/h[0],p=u[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function JCe(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new YCe(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const ZCe={kernelName:Qb,backendName:"webgl",kernelFunc:JCe};class QCe{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,i=e.map((o,u)=>r(u)).join(","),a=It(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class e2e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=gs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=It(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${i}){
            result.g = ${h(r.slice())};
          }
          if(${a}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=e.map((C,N)=>y(N,b)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function y(b,x){return t.indexOf(b)!==-1&&e[b]!==1?`${e[b]} - ${x[b]} - 1`:`${x[b]}`}}}function t2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length,o=st(i,r.shape);if(a===0)return er({inputs:{x:r},backend:t});const u=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new e2e(r.shape,o):new QCe(r.shape,o);return t.runWebGLProgram(u,[r],r.dtype)}const n2e={kernelName:dm,backendName:"webgl",kernelFunc:t2e};class s2e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const r2e={kernelName:yx,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,u=new s2e(s.shape,i),[h,d]=GN(a,s.shape[1],s.shape[2]),p=[[h,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[s],s.dtype,p)}};const i2e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,a2e=gt({opSnippet:i2e}),o2e={kernelName:Oh,backendName:"webgl",kernelFunc:a2e};const l2e="return inversesqrt(x);",u2e=gt({opSnippet:l2e,cpuKernelImpl:vbe}),c2e={kernelName:Fh,backendName:"webgl",kernelFunc:u2e};class d${constructor(e,t,s,r,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const h=It(i.length),d=It(a.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";u&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=t>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class h2e{constructor(e,t,s,r,i,a,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const h=It(i.length),d=It(a.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";u&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=t>1?"strides[j]":"strides",C=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${C};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function d2e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:p}=Ho(i,r,a),m=[p/h,h];if(p===0)return t.makeTensorInfo(a,r.dtype);const y=$e({inputs:{x:r},backend:t,attrs:{shape:[u,o]}}),b=$e({inputs:{x:i},backend:t,attrs:{shape:[u,h]}}),x=t.makeTensorInfo([],"float32",new Float32Array([0]));let w;ie().getBool("WEBGL_PACK")?w=new h2e(u,o,y.shape.length,b.shape.length,d,m):w=new d$(u,o,y.shape.length,b.shape.length,d,m);const S=t.runWebGLProgram(w,[b,y,x],b.dtype),C=$e({inputs:{x:S},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(x),C}const f2e={kernelName:tx,backendName:"webgl",kernelFunc:d2e};class p2e{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=ie().getNumber("WEBGL_VERSION")===2?i:a,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function m2e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=new p2e(r.shape[0],r.shape[1],i.shape[1],a),u=[[r.shape[1]]];return t.runWebGLProgram(o,[r,i],"int32",u)}const g2e={kernelName:sx,backendName:"webgl",kernelFunc:m2e};class y2e{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],h=[];for(let d=0;d<t.length;d++)h.push(`${o[d]}`),d<e&&u.push(`${o[d]}`);r=u.join(),i=h.join()}const a=It(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function b2e(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new y2e(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,i],_s(r.dtype,i.dtype))}const x2e={kernelName:fm,backendName:"webgl",kernelFunc:b2e};const w2e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${aw};
  float scale = ${ow};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,v2e=gt({opSnippet:w2e}),S2e={kernelName:Lh,backendName:"webgl",kernelFunc:v2e};const T2e=gd+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,C2e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,N2e=gt({opSnippet:T2e,packedOpSnippet:C2e,cpuKernelImpl:Tbe}),k2e={kernelName:Bh,backendName:"webgl",kernelFunc:N2e};const E2e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,$2e=gt({opSnippet:E2e}),I2e={kernelName:Ph,backendName:"webgl",kernelFunc:$2e};const _2e=gd+`
  return sin(x);
`,A2e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Su}
  return result;
`,R2e=gt({opSnippet:_2e,packedOpSnippet:A2e}),D2e={kernelName:Mh,backendName:"webgl",kernelFunc:R2e};const O2e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,F2e=gt({opSnippet:O2e}),L2e={kernelName:zh,backendName:"webgl",kernelFunc:F2e};const M2e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,z2e=gt({opSnippet:M2e}),P2e={kernelName:Vh,backendName:"webgl",kernelFunc:z2e};const B2e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;D(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((S,C)=>S*C),u=[[0,0]];u.push(...a);for(let S=1+i.length;S<r.shape.length;++S)u.push([0,0]);const h=[],d=nj({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),p=jm(d.shape,i,o,!1),m=Wm(p.length,i.length,!1),y=Gm(d.shape,i,o,!1),b=$e({inputs:{x:d},backend:t,attrs:{shape:p}}),x=xs({inputs:{x:b},backend:t,attrs:{perm:m}}),w=$e({inputs:{x},backend:t,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(S=>t.disposeIntermediateTensorInfo(S)),w},V2e={kernelName:gm,backendName:"webgl",kernelFunc:B2e};function U2e(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(s.dataId),u=t.readSync(r.dataId),h=t.readSync(i.dataId),d=t.readSync(a.dataId)[0],[p,m,y,b,x]=Nbe(o,s.shape,s.dtype,u,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const j2e={kernelName:rx,backendName:"webgl",kernelFunc:U2e};function W2e(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.readSync(r.dataId)),o=t.readSync(s.dataId),u=Array.from(t.readSync(i.dataId)),[h,d,p]=kbe(o,s.shape,s.dtype,a,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const G2e={kernelName:ix,backendName:"webgl",kernelFunc:W2e};function H2e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),u=t.readSync(i.dataId),[h,d]=NU(a,s.shape,s.dtype,o,u,!0);return t.makeTensorInfo(d,s.dtype,h)}const q2e={kernelName:ax,backendName:"webgl",kernelFunc:H2e};function K2e(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),u=t.readSync(i.dataId),[h,d]=NU(a,s.shape,s.dtype,o,u);return t.makeTensorInfo(d,s.dtype,h)}const X2e={kernelName:ox,backendName:"webgl",kernelFunc:K2e};function Y2e(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:u,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=Ho(i,r,o),y=!1;if(i.dtype==="string"){const S=t.bufferSync(r),C=t.bufferSync(i),N=Ca(t.readSync(a.dataId)[0]),k=Sbe(S,C,o,m,d,h,u,p,N,y);return t.makeTensorInfo(o,k.dtype,k.values)}const b=new d$(h,u,r.shape.length,i.shape.length,p,[m,1],y),x=t.runWebGLProgram(b,[i,r,a],i.dtype),w=$e({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(x),w}const J2e={kernelName:lx,backendName:"webgl",kernelFunc:Y2e};function Z2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=st(a,r.shape)[0],u=ak(r,i,o),h=r.shape.length,d=new Array(h).fill(0),p=r.shape.slice();return u.map(m=>{const y=[...p];y[o]=m;const b=yd({inputs:{x:r},backend:t,attrs:{begin:d,size:y}});return d[o]+=m,b})}const Q2e={kernelName:ym,backendName:"webgl",kernelFunc:Z2e};const q3="return sqrt(x);",eNe=gt({opSnippet:q3,packedOpSnippet:q3,cpuKernelImpl:Ebe}),tNe={kernelName:Uh,backendName:"webgl",kernelFunc:eNe};const nNe="return x * x;",sNe=gt({opSnippet:nNe}),rNe={kernelName:ux,backendName:"webgl",kernelFunc:sNe};const K3="return (a - b) * (a - b);",iNe=ts({opSnippet:K3,packedOpSnippet:K3}),aNe={kernelName:jh,backendName:"webgl",kernelFunc:iNe};function oNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),a=Ia(i),o=$be(a,"string",s);return t.makeTensorInfo(r.shape,"string",o)}const lNe={kernelName:xm,backendName:"webgl",kernelFunc:oNe};function uNe({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Kr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new Di(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const cNe={kernelName:Kh,backendName:"webgl",kernelFunc:uNe};class hNe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=It(s.length),a=It(s.length);let o="";if(r===1)o="coords * strides + begin";else{let u=0;o=s.map((h,d)=>(u++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}function dNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:u,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:C,end:N,strides:k}=VN(r.shape,i,a,o,u,h,d,p,m);let E;if(x)E=$e({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||S){D(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const R=zN(C,N,k),O=yd({inputs:{x:r},backend:t,attrs:{begin:C,size:R}});E=$e({inputs:{x:O},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(O)}else if(t.shouldExecuteOnCPU([r])){const O=t.readSync(r.dataId),F=Qe(r.shape,r.dtype,O),L=Ibe(y,F,k,C);E=t.makeTensorInfo(b,r.dtype,L.values)}else{const O=new hNe(C,k,y);E=t.runWebGLProgram(O,[r],r.dtype)}const _=$e({inputs:{x:E},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(E),_}const fNe={kernelName:cx,backendName:"webgl",kernelFunc:dNe};function pNe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:h}=s,{data:d,dataSplits:p}=e,m=t.readSync(d.dataId),y=t.readSync(p.dataId),[b,x]=_be(m,y,r,i,a,o,u,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(p.shape,"int32",x)]}const mNe={kernelName:hx,backendName:"webgl",kernelFunc:pNe};function gNe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(i.dataId),u=t.readSync(a.dataId)[0],[h,d,p]=Abe(o,u,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const yNe={kernelName:dx,backendName:"webgl",kernelFunc:gNe};function bNe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(i.dataId),o=Rbe(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const xNe={kernelName:fx,backendName:"webgl",kernelFunc:bNe};const wNe="return tan(x);",vNe=gt({opSnippet:wNe}),SNe={kernelName:Gh,backendName:"webgl",kernelFunc:vNe};const TNe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,CNe=gt({opSnippet:TNe}),NNe={kernelName:Hh,backendName:"webgl",kernelFunc:CNe};function kNe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:o,numUpdates:u,sliceSize:h,strides:d,outputSize:p}=Ho(a,i,r.shape),m=[p/h,h];if(p===0)return t.makeTensorInfo(r.shape,i.dtype);const y=$e({inputs:{x:i},backend:t,attrs:{shape:[u,o]}}),b=$e({inputs:{x:a},backend:t,attrs:{shape:[u,h]}}),x=$e({inputs:{x:r},backend:t,attrs:{shape:m}}),w=new d$(u,o,y.shape.length,b.shape.length,d,m,!1,!0),S=t.runWebGLProgram(w,[b,y,x],x.dtype),C=$e({inputs:{x:S},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(S),C}const ENe={kernelName:nx,backendName:"webgl",kernelFunc:kNe};class $Ne{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=It(this.rank),i=INe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function INe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function rj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),h=r.dtype==="string"?u.map(m=>Ca(m)):u,d=Qe(r.shape,r.dtype,h),p=Obe(d,i);return t.makeTensorInfo(p.shape,p.dtype,p.values)}const a=new $Ne(r.shape,i);return t.runWebGLProgram(a,[r],r.dtype)}const _Ne={kernelName:qh,backendName:"webgl",kernelFunc:rj};class ANe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class RNe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function bl(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function X3(n){let e=1;for(;e<n;)e*=2;return e}function DNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,o=ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(t.shouldExecuteOnCPU([r])||d<o||i>u){const L=t.readSync(r.dataId),[A,U]=Fbe(L,h,r.dtype,i,a);return[t.makeTensorInfo(A.shape,A.dtype,A.values),t.makeTensorInfo(U.shape,U.dtype,U.values)]}if(i===0)return h[h.length-1]=0,[t.makeTensorInfo(h,r.dtype,[]),t.makeTensorInfo(h,"int32",[])];if(d===1)return[r,og({attrs:{shape:h,dtype:"int32",value:0},backend:t})];const p=t.texData.get(r.dataId),m=p!==null&&p.isPacked,y=m?t.unpackTensor(r):r,x=he(h)/d,w=$e({inputs:{x:y},attrs:{shape:[x,d]},backend:t});m&&bl(t,y);const S=X3(i),C=X3(d);let N=null;const k=()=>N===null?[w,w]:[w,N],E=(L,A,U)=>{const Y=k(),te=new ANe(U),B=[[d],[N===null?1:0],[Number.NEGATIVE_INFINITY],[L],[A]],V=N;N=t.runWebGLProgram(te,Y,"int32",B),bl(t,V)};for(let L=1;L<S;L*=2){const A=L*2;for(let U=L;U>=1;U/=2)E(A,U,[x,C])}for(let L=C;L>S;L/=2){const A=k(),U=new RNe([x,L/2]),te=[[d],[N===null?1:0],[S]],Z=N;N=t.runWebGLProgram(U,A,"int32",te),bl(t,Z);const B=S/2,V=B*2;for(let j=B;j>=1;j/=2)E(V,j,N.shape)}let _=N;N=yd({inputs:{x:N},backend:t,attrs:{begin:0,size:[x,i]}}),bl(t,_);let R=YU({inputs:{x:w,indices:N},backend:t,attrs:{axis:1,batchDims:1}});bl(t,w);const O=h.slice(0,-1);O.push(i),_=N,N=$e({inputs:{x:N},attrs:{shape:O},backend:t}),bl(t,_);const F=R;return R=$e({inputs:{x:R},attrs:{shape:O},backend:t}),bl(t,F),[R,N]}const ONe={kernelName:px,backendName:"webgl",kernelFunc:DNe};class FNe{constructor(e,t,s,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function LNe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:u,outputShape:h}=s,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=new FNe(p,m,a,o,u,w);return t.runWebGLProgram(S,[r,i],"float32")}const MNe={kernelName:mx,backendName:"webgl",kernelFunc:LNe};function zNe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;cd(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:u,indices:h}=Lbe(a,r,i.shape,i.dtype);return[s.makeTensorInfo(u,i.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const PNe={kernelName:gx,backendName:"webgl",kernelFunc:zNe};function BNe(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,u=r.shape[i],h=new Array(o-1);let d=0;for(let x=0;x<o;x++)x!==i&&(h[d++]=a.shape[x]);const p=[],m=new Array(o).fill(0),y=a.shape.slice();y[i]=1;const b=new Array(u);for(let x=0;x<b.length;x++){m[i]=x;const w=yd({inputs:{x:a},backend:t,attrs:{begin:m,size:y}}),S=$e({inputs:{x:w},backend:t,attrs:{shape:h}});b[x]=S,p.push(w)}return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const VNe={kernelName:wm,backendName:"webgl",kernelFunc:BNe};class UNe{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,o=a*Math.ceil(i/s);this.outputShape=[r,o];const u="0.0",h="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function jNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,u=[];let h=0;const d=Zt([h],o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),u.push(p),h=cn(1,o)[0]);const m=OP(p.shape,h,a),y=he([p.shape[h]]),b=$e({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}});u.push(b);const x=xx(r.dtype),w=(k,E,_,R,O)=>{const F=k.shape[0],L=k.shape[1],A=DP(L,O),U={windowSize:A,inSize:L,batchSize:F,numSegments:O},Y=new UNe(U,E),te=t.compileAndRun(Y,[k,_],R);if(u.push(te),te.shape[1]===O)return te;const Z=sj({backend:t,attrs:{start:0,stop:O,step:1,dtype:"float32"}}),B=rj({inputs:{x:Z},backend:t,attrs:{reps:[L/A]}});return u.push(Z),u.push(B),w(te,E,B,R,O)},S=w(b,"unsortedSegmentSum",i,x,a),C=$e({inputs:{x:S},backend:t,attrs:{shape:m}});let N=C;if(d!=null){u.push(C);const k=Uo(d);N=xs({inputs:{x:N},backend:t,attrs:{perm:k}})}return u.forEach(k=>t.disposeIntermediateTensorInfo(k)),N}const WNe={kernelName:vm,backendName:"webgl",kernelFunc:jNe};const GNe=[$xe,_xe,Dxe,Lxe,zxe,Vxe,jxe,Gxe,Xxe,Jxe,ewe,swe,awe,cwe,fwe,mwe,ywe,vwe,Twe,Nwe,Iwe,Lwe,zwe,Uwe,Wwe,Ywe,Zwe,nve,hxe,ive,cve,pve,wve,Tve,Nve,Eve,Ive,Dve,Lve,Pve,Vve,jve,Gve,Kve,Yve,e1e,n1e,i1e,l1e,c1e,p1e,b1e,S1e,N1e,$1e,I1e,A1e,D1e,F1e,M1e,P1e,j1e,H1e,X1e,J1e,eSe,sSe,oSe,hSe,cxe,fSe,lve,gSe,xSe,SSe,fxe,kSe,_Se,RSe,LSe,PSe,jSe,HSe,YSe,eTe,sTe,iTe,uTe,hTe,fTe,yTe,xTe,vTe,TTe,NTe,ITe,DTe,MTe,GTe,gxe,XTe,ZTe,tCe,rCe,Hwe,oCe,uCe,hCe,pCe,bCe,mxe,wCe,SCe,CCe,kCe,ECe,qwe,VTe,_Ce,OCe,zCe,bxe,UCe,GCe,XCe,ZCe,n2e,r2e,o2e,c2e,f2e,g2e,x2e,S2e,k2e,I2e,D2e,L2e,Owe,jTe,P2e,V2e,j2e,G2e,q2e,X2e,J2e,Q2e,tNe,rNe,aNe,lNe,cNe,fNe,mNe,yNe,xNe,UTe,Nxe,SNe,NNe,ENe,_Ne,ONe,MNe,kxe,PNe,VNe,WNe,lCe];for(const n of GNe)bx(n);const HNe="4.22.0";const qNe={"tfjs-core":cP,"tfjs-backend-cpu":p4,"tfjs-backend-webgl":$U,"tfjs-data":bV,"tfjs-layers":ww,"tfjs-converter":nV,tfjs:HNe},xC=Object.freeze(Object.defineProperty({__proto__:null,Abs:wp,Acos:eh,Acosh:th,AdadeltaOptimizer:$N,AdagradOptimizer:IN,AdamOptimizer:_N,AdamaxOptimizer:AN,Add:du,AddN:vp,All:fb,Any:pb,ArgMax:Sp,ArgMin:Tp,Asin:nh,Asinh:sh,Atan:rh,Atan2:ah,Atanh:ih,AvgPool:Cp,AvgPool3D:Np,AvgPool3DGrad:gb,AvgPoolGrad:mb,BatchMatMul:kp,BatchToSpaceND:Ep,Bincount:yb,BitwiseAnd:$p,BroadcastArgs:bb,BroadcastTo:lM,Callback:JB,CallbackList:QP,Cast:oh,Ceil:lh,ClipByValue:uh,Complex:xb,ComplexAbs:Ip,Concat:_p,Conv2D:Ap,Conv2DBackpropFilter:wb,Conv2DBackpropInput:Rp,Conv3D:Dp,Conv3DBackpropFilterV2:vb,Conv3DBackpropInputV2:Sb,Cos:ch,Cosh:hh,CropAndResize:Cb,Cumprod:Tb,Cumsum:Op,CustomCallback:tB,DataStorage:a2,DenseBincount:Nb,DepthToSpace:kb,DepthwiseConv2dNative:Fp,DepthwiseConv2dNativeBackpropFilter:Eb,DepthwiseConv2dNativeBackpropInput:$b,Diag:Ib,Dilation2D:Lp,Dilation2DBackpropFilter:$0,Dilation2DBackpropInput:E0,Draw:_b,get ENV(){return h2},EarlyStopping:ZB,Einsum:Ab,Elu:fh,EluGrad:Rb,Environment:aM,Equal:Mp,Erf:ph,Exp:mh,ExpandDims:zp,Expm1:gh,FFT:Db,Fill:Ob,FlipLeftRight:Fb,Floor:yh,FloorDiv:bh,FromPixels:I0,FusedBatchNorm:Pp,FusedConv2D:Yf,FusedDepthwiseConv2D:Jf,GPGPUContext:h0,GatherNd:Lb,GatherV2:Bp,GraphModel:zE,Greater:Vp,GreaterEqual:xh,History:eB,IFFT:Mb,Identity:wh,Imag:zb,InputSpec:yn,IsFinite:vh,IsInf:Sh,IsNan:Th,KernelBackend:cb,LRN:Kp,LRNGrad:Bb,LayerVariable:XP,LayersModel:wa,LeakyRelu:Up,Less:jp,LessEqual:Wp,LinSpace:Pb,Log:Ch,Log1p:Nh,LogSoftmax:uM,LogicalAnd:Gp,LogicalNot:Hp,LogicalOr:qp,LogicalXor:FX,LowerBound:LX,MathBackendCPU:tg,MathBackendWebGL:ig,MatrixBandPart:MX,Max:Xp,MaxPool:Yp,MaxPool3D:Jp,MaxPool3DGrad:Ub,MaxPoolGrad:Vb,MaxPoolWithArgmax:jb,Maximum:kh,Mean:Zp,Min:Qp,Minimum:Eh,MirrorPad:em,Mod:$h,MomentumOptimizer:RN,Multinomial:Wb,Multiply:Ih,Neg:tm,NonMaxSuppressionV3:Gb,NonMaxSuppressionV4:Hb,NonMaxSuppressionV5:qb,NotEqual:nm,OP_SCOPE_SUFFIX:g2,OneHot:rm,OnesLike:sm,Optimizer:Pa,OptimizerConstructors:hP,Pack:im,PadV2:am,Pool:zX,Pow:_h,Prelu:om,Prod:lm,RMSPropOptimizer:DN,RNN:Si,RaggedGather:Kb,RaggedRange:Xb,RaggedTensorToTensor:Yb,Range:Jb,get Rank(){return kT},Real:Zb,RealDiv:dh,Reciprocal:Ah,get Reduction(){return ms},Relu:Rh,Relu6:Dh,Reshape:um,ResizeBilinear:hm,ResizeBilinearGrad:ex,ResizeNearestNeighbor:cm,ResizeNearestNeighborGrad:Qb,Reverse:dm,RotateWithOffset:yx,Round:Oh,Rsqrt:Fh,SGDOptimizer:nw,ScatterNd:tx,SearchSorted:sx,Select:fm,Selu:Lh,Sequential:nu,Sigmoid:Bh,Sign:Ph,Sin:Mh,Sinh:zh,Slice:pm,Softmax:bm,Softplus:Vh,SpaceToBatchND:gm,SparseFillEmptyRows:rx,SparseReshape:ix,SparseSegmentMean:ax,SparseSegmentSum:ox,SparseToDense:lx,SplitV:ym,Sqrt:Uh,Square:ux,SquaredDifference:jh,StaticRegexReplace:xm,Step:Kh,StridedSlice:cx,StringNGrams:hx,StringSplit:dx,StringToHashBucketFast:fx,Sub:Wh,Sum:mm,SymbolicTensor:yi,Tan:Gh,Tanh:Hh,Tensor:mt,TensorBuffer:bn,TensorScatterUpdate:nx,Tile:qh,TopK:px,Transform:mx,Transpose:Bl,Unique:gx,Unpack:wm,UnsortedSegmentSum:vm,UpperBound:PX,Variable:ep,ZerosLike:Sm,_FusedMatMul:Xf,abs:mn,acos:C2,acosh:N2,add:we,addN:BM,all:Sx,any:np,argMax:Xl,argMin:k2,asin:E2,asinh:$2,atan:I2,atan2:_2,atanh:A2,avgPool:km,avgPool3d:D2,backend:b2,backend_util:LP,basicLSTMCell:VM,batchNorm:Xh,batchNorm2d:O2,batchNorm3d:F2,batchNorm4d:L2,batchToSpaceND:Em,bincount:M2,bitwiseAnd:UM,booleanMaskAsync:kz,broadcastArgs:jM,broadcastTo:Vl,broadcast_util:mJ,browser:Rne,buffer:Qe,callbacks:Kle,cast:Ne,ceil:z2,clipByValue:Rs,clone:Mi,complex:ka,concat:ln,concat1d:P2,concat2d:B2,concat3d:V2,concat4d:U2,constraints:Oie,conv1d:Tx,conv2d:Ea,conv2dTranspose:Cx,conv3d:W2,conv3dTranspose:G2,copyRegisteredKernels:jX,cos:$m,cosh:Nx,cosineWindow:Kx,cumprod:ip,cumsum:kx,customGrad:Wi,data:ohe,denseBincount:R0,deprecationWarn:w9,depthToSpace:H2,depthwiseConv2d:Yh,deregisterOp:Jle,device_util:p9,diag:GM,dilation2d:q2,disableDeprecationWarnings:x9,dispose:Ke,disposeVariables:v9,div:Oe,divNoNan:K2,dot:X2,dropout:TN,einsum:kl,elu:Jh,enableDebugMode:b9,enableProdMode:y9,enclosingPowerOfTwo:CN,engine:oi,ensureShape:HM,env:ie,equal:Js,erf:Ex,euclideanNorm:J2,exp:Ds,expandDims:Hn,expm1:Z2,eye:$x,fft:Vm,fill:fu,findBackend:k9,findBackendFactory:E9,floor:Qh,floorDiv:vx,forceHalfFloat:IU,fused:Fz,gather:ed,gatherND:_z,gather_util:Dne,getBackend:kM,getGradient:CT,getKernel:Qf,getKernelsForBackend:_0,gpgpu_util:W0e,grad:ZJ,grads:QJ,greater:vs,greaterEqual:La,ifft:Wc,imag:Im,image:Ur,inTopKAsync:Az,initializers:Yie,input:gB,io:LN,irfft:Ux,isFinite:Q2,isInf:eN,isNaN:tN,keep:En,kernel_impls:Une,layers:Cle,leakyRelu:_m,less:Bc,lessEqual:jo,linalg:EN,linspace:XM,loadGraphModel:Sce,loadGraphModelSync:Tce,loadLayersModel:mB,localResponseNormalization:nN,log:Zs,log1p:Am,logSigmoid:sN,logSoftmax:_x,logSumExp:Rm,logicalAnd:Gr,logicalNot:Dm,logicalOr:Ax,logicalXor:rN,losses:Uz,lowerBound:JM,matMul:nt,math:Tne,max:Sr,maxPool:Om,maxPool3d:iN,maxPoolWithArgmax:ZM,maximum:qi,mean:Kt,memory:RT,meshgrid:QM,metrics:Vle,min:Pc,minimum:Ro,mirrorPad:aN,mod:oN,model:Uae,models:Ule,moments:Fm,movingAverage:Ez,mul:K,multiRNNCell:ez,multinomial:tz,neg:Mt,nextFrame:UN,norm:Zh,notEqual:Zl,oneHot:Vc,ones:$s,onesLike:Qs,op:G,outerProduct:nz,pad:Ma,pad1d:sz,pad2d:rz,pad3d:iz,pad4d:az,pool:lN,pow:ji,prelu:Mm,print:T2,prod:uN,profile:S9,raggedGather:oz,raggedRange:lz,raggedTensorToTensor:uz,rand:cz,randomGamma:fz,randomNormal:Dx,randomStandardNormal:pz,randomUniform:Wo,randomUniformInt:mz,range:Ql,ready:C9,real:Uc,reciprocal:fN,registerBackend:y2,registerCallbackConstructor:Wae,registerGradient:cM,registerKernel:bx,registerOp:Yle,regularizers:Hle,relu:wi,relu6:Ox,removeBackend:N9,reshape:X,reverse:Tr,reverse1d:gz,reverse2d:yz,reverse3d:bz,reverse4d:xz,rfft:Um,round:Fx,rsqrt:Lx,scalar:Me,scatterND:$z,scatter_util:see,searchSorted:Rx,selu:Mx,separableConv2d:zx,sequential:jae,serialization:rne,setBackend:NM,setPlatform:$9,setWebGLContext:A4,setdiff1dAsync:wz,shared:f4,sigmoid:di,sign:pN,signal:Vz,sin:Px,sinh:Bx,slice:ut,slice1d:zm,slice2d:Vx,slice3d:Pm,slice4d:jc,slice_util:uP,softmax:Bm,softplus:pu,spaceToBatchND:Lm,sparse:jz,sparseToDense:Iz,spectral:Bz,split:Is,sqrt:Pn,square:$t,squaredDifference:jx,squeeze:Go,stack:bs,step:mu,stridedSlice:mN,string:Wz,sub:_e,sum:Ae,sumOutType:xx,tan:gN,tanh:Ao,tensor:Ys,tensor1d:Xn,tensor2d:So,tensor3d:yN,tensor4d:vz,tensor5d:Sz,tensor6d:Tz,tensorScatterUpdate:Cz,tensor_util:u9,test_util:gQ,tidy:se,tile:br,time:T9,topk:xN,train:Sl,transpose:at,truncatedNormal:Gx,unique:wN,unregisterGradient:UX,unregisterKernel:VX,unsortedSegmentSum:Hx,unstack:Cr,upcastType:_s,upperBound:Nz,util:JX,valueAndGrad:eZ,valueAndGrads:tZ,variable:vN,variableGrads:YM,version:qNe,version_converter:nV,version_core:cP,version_cpu:p4,version_layers:ww,version_webgl:$U,webgl:uxe,webgl_util:Yye,where:Mn,whereAsync:SN,zeros:gn,zerosLike:ct},Symbol.toStringTag,{value:"Module"}));(function(n,e){const t=Cu,s=n();for(;;)try{if(-parseInt(t(371))/1*(-parseInt(t(394))/2)+parseInt(t(376))/3*(parseInt(t(393))/4)+parseInt(t(392))/5+parseInt(t(395))/6+-parseInt(t(437))/7*(-parseInt(t(401))/8)+parseInt(t(427))/9+-parseInt(t(417))/10===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(eb,436903);const KNe=async()=>{const n=Cu;try{await NM(n(364)),await xC[n(404)]()}catch{console[n(448)](n(413)),await xC[n(388)](n(407))}};KNe();const XNe=n=>new Promise((e,t)=>{const s=Cu,r=new Worker(new URL(s(399),import.meta.url),{type:"module"});r.onmessage=i=>{const a=s,{type:o,data:u}=i.data;o===a(434)?(r[a(370)](),e(u)):o===a(372)&&(r[a(370)](),t(new Error(u)))},r[s(422)]=i=>{r.terminate(),t(i)},r[s(445)]({type:s(425),data:n}),setTimeout(()=>{const i=s;r[i(370)](),t(new Error(i(424)))},12e4)});function eb(){const n=["slice","dense","ASSESS_ACCURACY","upsert","meanSquaredError","webgl","sentiment","sequential","shape","user_id","PROGRESS","terminate","3584ceVEyJ","ERROR","toISOString","neural","length","939gsqEgH","model_json","mean","from","technical","select","error","prices","tensor3d","Cloud Artifact Save Error:","reduce","Bearish","setBackend","). Discarding legacy model.","charCodeAt","add","4204960koqMDv","3676fAuelm","326VPtTSh","1520586NpZyFD","tensor2d","glorotUniform","adam","./brain.worker.js","pattern","1032016bFnbLg","neural_models","fit","ready","sqrt","dispose","cpu","isArray","min","Cloud Model Save Error:","name","user_id, name","WebGL failed, falling back to CPU. Performance will be reduced.","random","regularizers","string","26008440WXaIcp","byteLength","Cloud Model Load Error:","trainOnBatch","maybeSingle","onerror","predict","Neural Training Timed Out (120s Limit)","TRAIN_AND_PREDICT","weightData","7321329WnXSVx","dropout","map","onmessage","[Brain] Model shape mismatch detected (","compile","lstm","TRAIN_SUCCESS","layers","module","14zwTkgP","push","pow","std","inputs","toFixed","fromCharCode","ASSESS_SUCCESS","postMessage","save","buffer","warn","data","relu"];return eb=function(){return n},eb()}const Wl=30,YNe=3,Y3=(n,e,t)=>(n-e)/(t||1),JNe=n=>{const e=Cu,{prices:t,rsi:s,macd:r}=n,i=Math[e(409)](t[e(375)],s[e(375)],r[e(375)]),a=t[e(359)](-i),o=s[e(359)](-i),u=r[e(359)](-i);return[a,o,u][e(429)](h=>{const d=e,p=h[d(386)]((y,b)=>y+b,0)/h[d(375)],m=Math[d(405)](h[d(386)]((y,b)=>y+Math[d(439)](b-p,2),0)/h[d(375)])||1;return{mean:p,std:m}})};function Cu(n,e){return n=n-359,eb()[n]}const ZNe=(n,e,t)=>{const s=Cu,r=e[s(383)][0],i=[];for(let h=0;h<Wl;h++)i.push([(e.prices[h]-r)/(r||1),Y3(e.rsi[h],t[1][s(378)],t[1][s(440)]),Y3(e.macd[h],t[2][s(378)],t[2][s(440)])]);const a=xC[s(384)]([i],[1,Wl,YNe]),o=n[s(423)](a),u=o.dataSync()[0];return a[s(406)](),o[s(406)](),u*r+r},QNe=n=>{n&&n.dispose()},eke=async(n,e,t,s)=>{const r=Cu;if(n)try{if(e.weightData instanceof ArrayBuffer){const a=new Uint8Array(e.weightData);let o="";for(let u=0;u<a.byteLength;u++)o+=String[r(443)](a[u]);e[r(426)]=btoa(o)}const{error:i}=await qs[r(379)]("neural_models").upsert([{user_id:n.id,name:t,model_json:e,accuracy:s,created_at:new Date().toISOString()}],{onConflict:r(412)});if(i)throw i;return!0}catch(i){return console[r(382)](r(385),i),!1}},tke=async(n,e)=>{const t=Cu;if(!n)return null;try{const{data:s,error:r}=await qs[t(379)](t(402))[t(381)](t(377)).eq(t(368),n.id).eq(t(411),e)[t(421)]();if(r||!s)return null;const i=s[t(377)];if(typeof i[t(426)]===t(416)){const u=atob(i[t(426)]),h=new Uint8Array(u[t(375)]);for(let d=0;d<u[t(375)];d++)h[d]=u[t(390)](d);i.weightData=h.buffer}else Array[t(408)](i[t(426)])&&(i[t(426)]=new Uint8Array(i[t(426)])[t(447)]);const a=await mB(Jz(i)),o=a[t(441)][0][t(367)];return o[1]!==Wl?(console[t(448)](t(431)+o[1]+" vs "+Wl+t(389)),a[t(406)](),null):a}catch(s){return console[t(382)](t(419),s),null}},nke={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_SUPABASE_ANON_KEY:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",VITE_SUPABASE_URL:"https://brrjoheinakfhohesogc.supabase.co"},Ce=f$;(function(n,e){const t=f$,s=n();for(;;)try{if(-parseInt(t(383))/1*(parseInt(t(360))/2)+-parseInt(t(336))/3+-parseInt(t(278))/4+-parseInt(t(395))/5*(parseInt(t(397))/6)+parseInt(t(351))/7+-parseInt(t(272))/8*(-parseInt(t(409))/9)+parseInt(t(353))/10===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(tb,267747);const Fl={BTC:Ce(371),ETH:"ethereum",SOL:Ce(386),XRP:Ce(377),ADA:Ce(286),DOGE:Ce(269),AVAX:Ce(315),DOT:"polkadot",MATIC:"matic-network",LINK:Ce(388),LTC:"litecoin",SHIB:Ce(245),TRX:Ce(313),UNI:Ce(291),ATOM:Ce(373),XMR:Ce(271),ETC:Ce(385),XLM:Ce(387),BCH:Ce(400),FIL:Ce(405),APT:Ce(312),QNT:Ce(391),NEAR:Ce(357),ARB:Ce(406),VET:Ce(358),MKR:Ce(366),AAVE:Ce(248),GRT:"the-graph",ALGO:Ce(277),AXS:Ce(311),SAND:Ce(359),EOS:Ce(260),MANA:Ce(319),THETA:Ce(369),EGLD:Ce(273),FTM:"fantom",XTZ:Ce(368),FLOW:"flow",IMX:Ce(323),SNX:Ce(393),NEO:Ce(407),CVX:Ce(354),CRV:"curve-dao-token",BAT:Ce(362),CHZ:"chiliz",ENJ:Ce(253),DASH:Ce(332),COMP:Ce(270),ZEC:"zcash",XEM:Ce(345),HOT:Ce(322),IOTX:Ce(287),RUNE:Ce(293),KSM:Ce(370),ZIL:Ce(392),RVN:Ce(243),CELO:Ce(396),ONE:Ce(338),QTUM:Ce(410),BNB:Ce(367)};function f$(n,e){return n=n-240,tb()[n]}const Ll={AAPL:Ce(398),MSFT:Ce(344),GOOGL:Ce(275),AMZN:"Amazon.com Inc.",NVDA:Ce(339),TSLA:"Tesla Inc.",META:Ce(346),"BRK.B":"Berkshire Hathaway",V:Ce(290),JNJ:Ce(261),WMT:Ce(389),JPM:Ce(241),PG:Ce(279),MA:Ce(376),LLY:Ce(295),HD:Ce(411),CVX:Ce(285),MRK:Ce(262),KO:Ce(254),PEP:"PepsiCo Inc.",AVGO:Ce(347),COST:Ce(274),ORCL:Ce(413),AMD:Ce(244),NFLX:Ce(292),INTC:Ce(390),IBM:Ce(308),QCOM:Ce(264),TXN:Ce(298),HON:"Honeywell",UNH:Ce(265),SPY:Ce(309),QQQ:Ce(267),IWM:Ce(331),DIA:Ce(414)},ske=n=>{const e=Ce;if(!n)return null;const t=n.match(/\d{1,3}(?:,\d{3})*\.\d{1,8}/g),s=n.match(/\b\d{3,7}\b/g),r=[...t||[],...s||[]],i=r[e(288)](o=>parseFloat(o[e(355)](/,/g,""))).filter(o=>o>=2020&&o<=2030||o===24||o===1||o===7?!1:o>1e-4&&o<2e7);return i[e(284)]===0?null:i[e(404)]((o,u)=>{const h=o%1!==0,d=u%1!==0;return h&&!d?-1:!h&&d?1:u-o})[0]},rke=n=>{const e=Ce;if(!n)return null;const t=n[e(365)](),s=[e(327),e(324),e(297),e(349),"HIGH",e(361),"PRICE",e(250),e(321),e(382),e(394),e(281),e(294),e(340),e(412)],r=t[e(355)](/[^A-Z0-9]/g," "),i=r[e(305)](/\s+/)[e(326)](d=>d[e(284)]>=2&&!s[e(333)](d));for(const d of i)if(Fl[d]||Ll[d])return d;const a=t.match(/([A-Z]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP|FRAX|DAI)/);if(a){const d=a[1];if(Fl[d]||Ll[d]||d[e(284)]>=2&&!s[e(333)](d))return d}const o=t[e(363)](/\(([A-Z]{2,6})\)[ -]|^([A-Z]{2,6})\s+\d/);if(o){const d=o[1]||o[2];if(Fl[d]||Ll[d]||d[e(284)]>=2&&!s.includes(d))return d}const u=Object.keys(Fl)[e(404)]((d,p)=>p[e(284)]-d[e(284)]);for(const d of u)if(new RegExp("\\b"+d+"\\b")[e(256)](t))return d;const h=Object.keys(Ll)[e(404)]((d,p)=>p[e(284)]-d[e(284)]);for(const d of h)if(new RegExp("\\b"+d+e(352)+d)[e(256)](t))return d;return null},pp=async(n,e)=>{const t=Ce;try{const s="https://brrjoheinakfhohesogc.supabase.co"+t(251),r=await fetch(s,{method:t(329),headers:{"Content-Type":t(379),apikey:nke[t(314)],Authorization:t(257)+"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A"},body:JSON[t(337)]({mode:n,tickers:e})});if(!r.ok){const i=await r[t(380)]()[t(246)](()=>({}));throw new Error(i.error||"Proxy Error ("+r[t(310)]+")")}return await r.json()}catch(s){return console.warn(t(408)+n+"):",s),null}},ike=async n=>{const e=Ce,t=Fl[n];if(!t)return null;const s=await pp("simple_price",[t]);return s&&s[t]?{price:Number(s[t].usd)||0,change24h:Number(s[t][e(403)])||0,volume:Number(s[t][e(356)])||0,source:e(341)}:null},ake=async(n,e=90)=>{const t=Ce,s=Fl[n];if(!s)return null;const r=await pp(t(302),[s]);return r&&r[t(378)]?r.prices[t(288)](i=>i[1]):null},oke=async n=>{const e=Ce,t=n.replace(".","-"),s=async i=>{const a=f$;try{const o=await pp(a(316),[i]);if(o&&o[a(335)]&&o[a(335)][a(255)]&&o[a(335)][a(255)][0]){const u=o[a(335)][a(255)][0],h=u[a(240)],d=u[a(276)].quote[0],p=d[a(375)]||[],m=p[a(326)](w=>w!=null);if(m[a(284)]===0)return null;const y=h[a(268)]||m[m[a(284)]-1],b=h[a(372)]||m[m.length-2]||y,x=(y-b)/b*100;return{marketStats:{price:y,change24h:x,volume:h[a(342)]||0,source:a(384)},historicalPrices:m}}}catch(o){console[a(350)](a(343)+i+":",o)}return null};let r=await s(t);return!r&&!Ll[n]&&!t[e(333)]("-")&&(console.log(e(280)+t+e(399)+t+"-USD)..."),r=await s(t+e(263))),r};function tb(){const n=["Qualcomm Inc.","UnitedHealth Group","price","Invesco QQQ Trust","regularMarketPrice","dogecoin","compound-governance-token","monero","400888JOWCii","elrond-erd-2","Costco Wholesale Corp.","Alphabet Inc.","indicators","algorand","858844YNSVnV","Procter & Gamble Co.","Retrying ","MARKET","setItem","&to=","length","Chevron Corp.","cardano","iotex","map","cache_","Visa Inc.","uniswap","Netflix Inc.","thorchain","TRADE","Eli Lilly and Co.","clear","VOL","Texas Instruments","Yahoo Finance (Institutional)","floor","Bulk Crypto Error:","market_chart","https://finnhub.io/api/v1/quote?symbol=","Macro Data Fetch Error:","split","stock","historicalPrices","IBM Corp.","SPDR S&P 500 ETF","status","axie-infinity","aptos","tron","VITE_SUPABASE_ANON_KEY","avalanche-2","yahoo_finance","Finnhub API","usd","decentraland","getItem","STOCK","holo","immutable-x","USDT","timestamp","filter","USD","change24h","POST","marketStats","iShares Russell 2000","dash","includes","&token=","chart","1330860cmvSnB","stringify","harmony","NVIDIA Corp.","BUY","CoinGecko (Edge)","regularMarketVolume","Yahoo fetch failed for ","Microsoft Corp.","nem","Meta Platforms Inc.","Broadcom Inc.","min","24H","warn","2125508XnDAgq","\\b|\\$","11164630vYoGlQ","convex-finance","replace","usd_24h_vol","near","vechain","the-sandbox","56332hyLnwm","LOW","basic-attention-token","match","Stock Data API Error:","toUpperCase","maker","binancecoin","tezos","theta-token","kusama","bitcoin","chartPreviousClose","cosmos","Cache read compile error","close","Mastercard Inc.","ripple","prices","application/json","json","slice","CRYPTO","7qbLAWl","Yahoo Finance (Edge)","ethereum-classic","solana","stellar","chainlink","Walmart Inc.","Intel Corp.","quant-network","zilliqa","havven","CHART","867445zqtgkd","celo","12whBezV","Apple Inc."," as crypto-pair (","bitcoin-cash","parse","macro_history","usd_24h_change","sort","filecoin","arbitrum","neo","Market Proxy Error (","9YHmBuK","qtum","Home Depot Inc.","SELL","Oracle Corp.","SPDR Dow Jones","max","meta","JPMorgan Chase & Co.","&resolution=D&from=","ravencoin","Advanced Micro Devices","shiba-inu","catch","https://finnhub.io/api/v1/stock/candle?symbol=","aave","all","INDEX","/functions/v1/market-proxy","now","enjincoin","Coca-Cola Co.","result","test","Bearer ","simple_price","reduce","eos","Johnson & Johnson","Merck & Co.","-USD"];return tb=function(){return n},tb()}const lke=async n=>{const e=Ce,t=Ll[n],s=Fl[n];try{let r=null;if(t){const i=n.replace(".","-");r=await pp(e(402),[i,e(306)])}else if(s){const i=n[e(365)]()+e(263);r=await pp(e(402),[i,"stock"])}if(r?.[e(335)]?.result?.[0]){const i=r[e(335)][e(255)][0],a=i[e(325)]||[],o=i[e(276)].quote[0][e(375)]||[],u=a[e(288)]((h,d)=>({date:h,price:o[d]}))[e(326)](h=>h[e(266)]!=null);return{prices:u[e(288)](h=>h[e(266)]),dates:u[e(288)](h=>h.date),source:e(299)}}}catch(r){console.warn(e(304),r)}return null},uke=n=>{const e=Ce;if(!n||n.length<52)return .5;const t=n[n[e(284)]-1],s=Math[e(415)](...n),r=Math[e(348)](...n),i=s-r||1,a=(t-r)/i,o=n[e(381)](-200),u=o[e(259)]((m,y)=>m+y,0)/o[e(284)],h=t>u?1:0,d=t/u;let p=a*.4+h*.4+Math[e(348)](1.5,d)/1.5*.2;return Math.min(.95,Math.max(.05,p))};(function(n,e){const t=p$,s=n();for(;;)try{if(-parseInt(t(359))/1*(parseInt(t(334))/2)+-parseInt(t(384))/3*(-parseInt(t(347))/4)+parseInt(t(341))/5*(-parseInt(t(377))/6)+-parseInt(t(369))/7*(-parseInt(t(356))/8)+parseInt(t(386))/9+-parseInt(t(371))/10+-parseInt(t(348))/11*(-parseInt(t(349))/12)===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(nb,327926);function p$(n,e){return n=n-333,nb()[n]}function nb(){const n=["iterations","4907390ZLHece","modelArtifacts","Macro Intelligence","10-Year Trend Analysis","Ensemble","Technical Confluence","2955774fphvnM","Moderate Bearish","Moderate Bullish","Algorithmic","min","toFixed","Strong Bearish","71406dnLThA","source","2875518xAEwgr","name","omega","slice","HYBRID-CORE-V3 (Iter: ","The active **","toISOString","rsi","%** statistical confidence interval. ","Consolidation","Yahoo Finance","histogram","price","Strong Bullish","Neutral","UNKNOWN","max","4382JWrnfH","lstm_v3_","now","Gathering 10-Year Macro Context...","Indicator","Rapid inference mode","RSI metrics show terminal overbought conditions. ","5yJDHBn","Bullish","Rapid Neural Heuristic Applied...","Neural diagnostics detect high-velocity capital concentration. ","toString","alpha","84yHtwhu","55nOcidS","2013612oXYvvR","Trained on 1M+ pattern variations","Calibrating Cloud Intelligence...","prices","Deep Learning","Running Predictive Inference..."," continuation. ","8UnpIKg","Bearish","gamma","172VeRxJz","sentiment","** pattern provides a geometric anchor for ","upside","Neural inference suggests aggressive institutional distribution levels. ","Syncing Brain to Cloud...","length","Long-term 10-year macro sentiment remains structurally bullish. ","** identified a **","RSI metrics indicate deep oversold territory, suggesting a technical floor. ","208579DTvtCN"];return nb=function(){return n},nb()}const cke=(n,e,t,s,r=.95,i=.5)=>{const a=p$,o=.5,u=.15,h=s[a(388)]+s.alpha+s.gamma+u,d=n,p=s[a(388)]/h,m=r,y=1;let b=.5;e===a(342)?b=.8:e===a(357)&&(b=.2);const x=s[a(346)]/h,w=.9,S=1,C=t[a(393)][t[a(393)][a(365)]-1];let N=.5;C<35?N=.75:C>65&&(N=.25);const k=s[a(358)]/h,E=1,_=C<20||C>80?1.2:1,R=i,O=u/h,F=1,L=1,A=[{w:p,p:d,c:m,f:y},{w:x,p:b,c:w,f:S},{w:k,p:N,c:E,f:_},{w:O,p:R,c:F,f:L}],U=A.reduce((te,Z)=>{const B=a,V=(Z.p-.5)*2,j=Z.w*V*Z.c*Z.f;return te*(1-Math[B(333)](-.99,Math[B(381)](.99,j)))},1-o),Y=1-U;return Math[a(381)](.992,Math[a(333)](.008,Y))},hke=async(n,e,t,s,r,i,a=.95,o=!1)=>{const u=p$,h=YL(t,14),d=bX(t),p=d[u(397)];JL(t);const m=xX(t),y=wX(t,14);vX(t);let b=.5,x=null;if(t[u(365)]>50)if(o){const de=t[t.length-1],Se=t[t[u(365)]-10],Te=(de-Se)/Se;b=.5+Math.min(.4,Math.max(-.4,Te*2)),i(u(343))}else{let de=null;try{const Se={prices:t,rsi:h,macd:p};if(s&&(de=await tke(s,u(335)+n)),de){if(i(u(351)),x=JNe(Se),de&&t[u(365)]>=14&&x){i(u(354));const Te={prices:t.slice(-Wl),rsi:h[u(389)](-Wl),macd:p[u(389)](-Wl)},Ee=ZNe(de,Te,x),Ve=t[t[u(365)]-1];b=.5+(Ee-Ve)/Ve*8,b=Math.max(.05,Math.min(.95,b))}}else{i("Training Deep LSTM (Background Worker)...");const Te=await XNe({ticker:n,historicalPrices:t,rsi:h,macdHist:p});Te&&(b=.5+(Te.predictedPrice-t[t[u(365)]-1])/t[t[u(365)]-1]*8,b=Math[u(333)](.05,Math.min(.95,b)),x=Te.stats,s&&Te.modelArtifacts&&(i(u(364)),await eke(s,Te[u(372)],u(335)+n,.98)))}}finally{de&&QNe(de)}}i(u(337));const w=await lke(n),S=uke(w?.[u(352)]);let C=cke(b,m[u(360)],{rsi:h},r,a,S);const N=h[h[u(365)]-1]<40&&m[u(360)]===u(342),k=h[h.length-1]>60&&m[u(360)]==="Bearish";b>.7&&N?C=Math[u(381)](.98,C+.12):b<.3&&k&&(C=Math[u(333)](.02,C-.12));const E=[{name:"Neural Net (LSTM)",type:o?"Heuristic Core":u(353),w:r[u(388)],p:b,value:u(o?339:350)},{name:"Pattern Recognition",type:u(380),w:r[u(346)],p:m[u(360)]===u(342)?.8:m[u(360)]===u(357)?.2:.5,value:m.name},{name:u(376),type:u(338),w:r[u(358)],p:h<35?.8:h>65?.2:.5,value:"RSI: "+h[h[u(365)]-1]?.toFixed(1)},{name:u(373),type:u(375),w:.15,p:S,value:u(374)},{name:"Visual Verification",type:"Geometric",w:.1,p:a,value:"Sync Confidence: "+(a*100).toFixed(1)+"%"}];let _=u(400);C>.65?_=u(399):C>.55?_=u(379):C<.35?_=u(383):C<.45&&(_=u(378));const R=e?.[u(398)]||t[t[u(365)]-1],O=y[y.length-1]||R*.02,F=_.includes("Bullish"),L=O/R;2+r.iterations*.01;const A=R<1?4:2,U=2+r[u(370)]*.01,Y=Math.max(R*.005,O*1.5);let te,Z,B;F?(te=Math[u(333)](0,R-Y),Z=R+Y*U,B=R+Y*U*1.8):(te=R+Y,Z=Math[u(333)](0,R-Y*U),B=Math.max(0,R-Y*U*1.8));const V={entry:R[u(382)](A),sl:te.toFixed(A),tp1:Z.toFixed(A),tp2:B.toFixed(A),rr:U[u(382)](1)},j=((C>.5?C:1-C)*100).toFixed(1),ee=()=>{const de=u,Se=h[h.length-1];let Te="Analysis of **"+n+de(367)+_+"** structure with a **"+j+de(394);return b>.65?Te+=de(344):b<.35?Te+=de(363):Te+="Neutral neural signals imply a period of market re-accumulation and range-bound volatility. ",m[de(387)]!==de(395)&&(Te+=de(391)+m[de(387)]+de(361)+(m.sentiment==="Bullish"?de(362):"downside")+de(355)),Se<35?Te+=de(368):Se>65&&(Te+=de(340)),S>.6?Te+=de(366):S<.4&&(Te+="Macro-scale compression signals long-term structural weakness. "),Te},ae=L*Math.sqrt(252)*100,P=(R-t[0])/t[0]*100,H=t[u(365)],ne=P*(252/H),ce=(ne-4.5)/(ae||1),me={volatility:(L*100)[u(382)](2),annualizedVol:ae.toFixed(2),sharpeRatio:ce[u(382)](2),maxDrawdown:((Math.min(...t[u(389)](-90))-Math[u(333)](...t[u(389)](-90)))/Math[u(333)](...t[u(389)](-90))*100)[u(382)](2)};return{id:Date[u(336)]()[u(345)](),date:new Date()[u(392)](),p0:r.alpha[u(382)](2),finalProb:Number(C),direction:_,confidence:j,pattern:m,factors:E,targets:V,riskMetrics:me,targets:V,riskMetrics:me,macroTrend:{...w,source:w?.[u(385)]||u(396)},overview:ee(),ticker:n||u(401),version:u(390)+r.iterations+")",raw_prices:t}},US="https://diverai.flisoft.agency",dke=()=>{const{user:n,profile:e,refreshProfile:t,neuralState:s}=yX(),[r,i]=ke.useState("idle"),[a,o]=ke.useState(null),[u,h]=ke.useState(null),[d,p]=ke.useState(""),[m,y]=ke.useState(""),[b,x]=ke.useState(!1),[w,S]=ke.useState(""),[C,N]=ke.useState("guest"),[k,E]=ke.useState(null),[_,R]=ke.useState([]),[O,F]=ke.useState("analyze");ke.useEffect(()=>{L();const V=async j=>{if(j.type==="AUTH_SYNC"&&j.session){const{access_token:ee,refresh_token:ae}=j.session;await qs.auth.setSession({access_token:ee,refresh_token:ae}),t()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(V),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(V)}},[]);const L=async()=>{try{const V=await fetch("https://api.ipify.org?format=json");if(!V.ok)throw new Error("Network response was not ok");const j=await V.json();E(j.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};ke.useEffect(()=>{A()},[n]);const A=async()=>{if(!n){const ee=localStorage.getItem("diver_ai_guest_history");R(ee?JSON.parse(ee):[]);return}const{data:V,error:j}=await qs.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!j&&V&&R(V.map(ee=>({...ee.data,db_id:ee.id,created_at:ee.created_at})))},U=async V=>{if(n){const{data:j}=await qs.from("prediction_history").insert([{user_id:n.id,data:V}]).select();if(j?.[0]){const ee={...V,db_id:j[0].id,created_at:j[0].created_at};R(ae=>[ee,...ae].slice(0,10))}}else{const j=new Date().toISOString(),ee={...V,db_id:"local-"+Date.now(),created_at:j};R(ae=>{const P=[ee,...ae].slice(0,5);return localStorage.setItem("diver_ai_guest_history",JSON.stringify(P)),P})}},Y=()=>{if(n)return;const V=new Date().toISOString().split("T")[0],j=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}"),ee=k||"unknown",ae=j[ee]||{count:0,date:V};ae.date!==V?(ae.count=1,ae.date=V):ae.count+=1,j[ee]=ae,localStorage.setItem("diver_ai_guest_ip_logs",JSON.stringify(j))},te=()=>{const V=new Date().toISOString().split("T")[0];if(!n){const ee=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}")[k||"unknown"]||{count:0,date:V};return ee.date!==V&&(ee.count=0,ee.date=V),ee.count>=3?(S("IP Limit Reached: 3 guest analysis/day. Please log in for expanded access."),N("guest"),x(!0),!1):!0}return n.email_confirmed_at?e&&e.subscription_tier!=="pro"&&(e.upload_count||0)>=3&&e.last_upload_date===V?(S("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),N("free"),x(!0),!1):!0:(S("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),N("verify"),x(!0),!1)},Z=async()=>{if(te()){i("scanning"),p("Capturing Visual Stream..."),o(null);try{const V=await chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"});if(V.error)throw new Error(V.error);const j=V.dataUrl;h(j),i("analyzing"),p("Deep Scan (Cloud OCR)...");const{data:{session:ee}}=await qs.auth.getSession();let ae=ee?.access_token||"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",P=0,H,ne=!1;for(;!ne&&P<3;)try{if(H=await fetch("https://brrjoheinakfhohesogc.supabase.co/functions/v1/detect_ticker",{method:"POST",headers:{"Content-Type":"application/json",apikey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",Authorization:`Bearer ${P===2?"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A":ae}`},body:JSON.stringify({image:j})}),H.ok)ne=!0;else if(H.status===401&&P===0){const{data:{session:ft},error:bt}=await qs.auth.refreshSession();if(bt||!ft)throw new Error("Refresh Failed");ae=ft.access_token,P++}else if(H.status===401&&P===1)P++;else throw new Error(`Service Error (${H.status})`)}catch(Ye){if(P===2)throw Ye;P++}if(!H||!H.ok)throw new Error("Visualization Service Unavailable");const me=(await H.json())?.text||"",de=rke(me),Se=ske(me);if(console.log("[Sidebar] OCR Detected:",{ticker:de,anchorPrice:Se}),!de&&!Se)throw new Error("Neural Core Rejected: No valid asset or price identified.");p(`Target Locked: ${de}. Syncing Data...`);let Te,Ee;if(Ll[de]){const Ye=await oke(de);if(Ye)Te=Ye.marketStats,Ee=Ye.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else Te=await ike(de),Ee=await ake(de,90);p("Synchronizing Global Intelligence...");const je=await hke(de,Te,Ee,n,s,p,.95,!0);if(n&&e){const Ye=new Date().toISOString().split("T")[0],ft=e.last_upload_date!==Ye?1:(e.upload_count||0)+1;await qs.from("profiles").update({upload_count:ft,last_upload_date:Ye}).eq("id",n.id),t()}else Y();await U(je),o(je),i("success")}catch(V){console.error(V),y(V.message),i("error")}}},B=({id:V,label:j,icon:ee})=>xe.jsxs("button",{onClick:()=>F(V),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${O===V?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[xe.jsx(ee,{className:"w-3.5 h-3.5"}),j,O===V&&xe.jsx(cc.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return xe.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&xe.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:xe.jsxs("div",{className:"space-y-6 max-w-xs",children:[xe.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:xe.jsx(N8,{className:"text-rose-500"})}),xe.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),xe.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),xe.jsxs("div",{className:"space-y-3",children:[C==="free"?xe.jsx("button",{onClick:()=>window.open(`${US}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):C==="guest"?xe.jsx("button",{onClick:()=>window.open(`${US}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):xe.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),xe.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),xe.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[xe.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[xe.jsxs("div",{className:"flex items-center gap-2",children:[xe.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:xe.jsx(w8,{className:"w-3.5 h-3.5 text-white"})}),xe.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",xe.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?xe.jsxs("div",{className:"flex items-center gap-3",children:[xe.jsx("div",{className:"text-right",children:xe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:e?.subscription_tier==="pro"?"PRO":"BASIC"})}),xe.jsx("button",{onClick:()=>qs.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:xe.jsx(E8,{className:"w-4 h-4"})})]}):xe.jsx("button",{onClick:()=>window.open(`${US}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),xe.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[xe.jsx(B,{id:"analyze",label:"Analysis",icon:zD}),xe.jsx(B,{id:"history",label:"History",icon:FD})]})]}),xe.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:xe.jsxs(M5,{mode:"wait",children:[O==="history"&&xe.jsx(cc.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:_.length===0?xe.jsxs("div",{className:"text-center py-12 text-slate-600",children:[xe.jsx(FD,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),xe.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):_.map((V,j)=>xe.jsxs("div",{onClick:()=>{o(V),i("success"),F("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[xe.jsxs("div",{className:"flex items-center gap-3",children:[xe.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${V.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:V.direction.includes("Bullish")?xe.jsx(MD,{className:"w-4 h-4"}):xe.jsx(LD,{className:"w-4 h-4"})}),xe.jsxs("div",{children:[xe.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:V.ticker}),xe.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(V.created_at).toLocaleDateString()})]})]}),xe.jsxs("span",{className:`text-xs font-mono font-bold ${V.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(V.finalProb*100).toFixed(0),"%"]})]},V.db_id||j))},"history"),O==="analyze"&&r==="idle"&&xe.jsxs(cc.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:[xe.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:xe.jsx(I8,{className:"w-8 h-8 text-blue-500"})}),xe.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[xe.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),xe.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]},"idle"),(r==="scanning"||r==="analyzing")&&xe.jsxs(cc.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[xe.jsxs("div",{className:"relative w-16 h-16",children:[xe.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),xe.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),xe.jsxs("div",{className:"text-center space-y-2",children:[xe.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),xe.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),r==="success"&&a&&O==="analyze"&&xe.jsxs(cc.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[xe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[xe.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[xe.jsxs("div",{children:[xe.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:a.ticker}),xe.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[xe.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${a.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[a.direction.split(" ")[0]," Signal"]}),xe.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(a.finalProb*100).toFixed(1),"% Conf."]})]})]}),xe.jsx("div",{className:`p-2 rounded-xl ${a.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:a.direction.includes("Bullish")?xe.jsx(MD,{className:"w-5 h-5 text-emerald-500"}):xe.jsx(LD,{className:"w-5 h-5 text-rose-500"})})]}),xe.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${a.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),xe.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[xe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[xe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),xe.jsx("p",{className:"text-lg font-mono font-bold text-white",children:a.targets.entry})]}),xe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[xe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),xe.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",a.targets.rr]})]}),xe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[xe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),xe.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:a.targets.tp1})]}),xe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[xe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),xe.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:a.targets.sl})]})]}),xe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[xe.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[xe.jsx(S8,{className:"w-3 h-3"})," AI Analysis"]}),xe.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:a.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),xe.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:xe.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",a.version.split(" ")[0],"  Data: ",a.macroTrend?.source||"Institutional Feed"]})}),xe.jsx("button",{onClick:()=>i("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),r==="error"&&xe.jsxs(cc.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[xe.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:xe.jsx(D8,{className:"w-6 h-6 text-rose-500"})}),xe.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),xe.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),xe.jsx("button",{onClick:()=>i("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),O==="analyze"&&r==="idle"&&xe.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:xe.jsxs("button",{onClick:Z,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[xe.jsx(zD,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};OG.createRoot(document.getElementById("root")).render(xe.jsx(kG.StrictMode,{children:xe.jsx(gX,{children:xe.jsx(dke,{})})}));
