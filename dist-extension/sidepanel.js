function vB(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();function dw(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function wB(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),e}var Zb={exports:{}},Qu={};var D$;function SB(){if(D$)return Qu;D$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,r,i){var o=null;if(i!==void 0&&(o=""+i),r.key!==void 0&&(o=""+r.key),"key"in r){i={};for(var l in r)l!=="key"&&(i[l]=r[l])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:o,ref:r!==void 0?r:null,props:i}}return Qu.Fragment=t,Qu.jsx=e,Qu.jsxs=e,Qu}var O$;function CB(){return O$||(O$=1,Zb.exports=SB()),Zb.exports}var it=CB(),Jb={exports:{}},Ht={};var M$;function TB(){if(M$)return Ht;M$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),o=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function y(F){return F===null||typeof F!="object"?null:(F=m&&F[m]||F["@@iterator"],typeof F=="function"?F:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function S(F,B,Q){this.props=F,this.context=B,this.refs=w,this.updater=Q||b}S.prototype.isReactComponent={},S.prototype.setState=function(F,B){if(typeof F!="object"&&typeof F!="function"&&F!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,F,B,"setState")},S.prototype.forceUpdate=function(F){this.updater.enqueueForceUpdate(this,F,"forceUpdate")};function T(){}T.prototype=S.prototype;function k(F,B,Q){this.props=F,this.context=B,this.refs=w,this.updater=Q||b}var $=k.prototype=new T;$.constructor=k,x($,S.prototype),$.isPureReactComponent=!0;var E=Array.isArray;function N(){}var _={H:null,A:null,T:null,S:null},R=Object.prototype.hasOwnProperty;function D(F,B,Q){var lt=Q.ref;return{$$typeof:n,type:F,key:B,ref:lt!==void 0?lt:null,props:Q}}function O(F,B){return D(F.type,B,F.props)}function A(F){return typeof F=="object"&&F!==null&&F.$$typeof===n}function z(F){var B={"=":"=0",":":"=2"};return"$"+F.replace(/[=:]/g,function(Q){return B[Q]})}var q=/\/+/g;function W(F,B){return typeof F=="object"&&F!==null&&F.key!=null?z(""+F.key):B.toString(36)}function X(F){switch(F.status){case"fulfilled":return F.value;case"rejected":throw F.reason;default:switch(typeof F.status=="string"?F.then(N,N):(F.status="pending",F.then(function(B){F.status==="pending"&&(F.status="fulfilled",F.value=B)},function(B){F.status==="pending"&&(F.status="rejected",F.reason=B)})),F.status){case"fulfilled":return F.value;case"rejected":throw F.reason}}throw F}function P(F,B,Q,lt,pt){var gt=typeof F;(gt==="undefined"||gt==="boolean")&&(F=null);var vt=!1;if(F===null)vt=!0;else switch(gt){case"bigint":case"string":case"number":vt=!0;break;case"object":switch(F.$$typeof){case n:case t:vt=!0;break;case d:return vt=F._init,P(vt(F._payload),B,Q,lt,pt)}}if(vt)return pt=pt(F),vt=lt===""?"."+W(F,0):lt,E(pt)?(Q="",vt!=null&&(Q=vt.replace(q,"$&/")+"/"),P(pt,B,Q,"",function(Rt){return Rt})):pt!=null&&(A(pt)&&(pt=O(pt,Q+(pt.key==null||F&&F.key===pt.key?"":(""+pt.key).replace(q,"$&/")+"/")+vt)),B.push(pt)),1;vt=0;var kt=lt===""?".":lt+":";if(E(F))for(var Ct=0;Ct<F.length;Ct++)lt=F[Ct],gt=kt+W(lt,Ct),vt+=P(lt,B,Q,gt,pt);else if(Ct=y(F),typeof Ct=="function")for(F=Ct.call(F),Ct=0;!(lt=F.next()).done;)lt=lt.value,gt=kt+W(lt,Ct++),vt+=P(lt,B,Q,gt,pt);else if(gt==="object"){if(typeof F.then=="function")return P(X(F),B,Q,lt,pt);throw B=String(F),Error("Objects are not valid as a React child (found: "+(B==="[object Object]"?"object with keys {"+Object.keys(F).join(", ")+"}":B)+"). If you meant to render a collection of children, use an array instead.")}return vt}function V(F,B,Q){if(F==null)return F;var lt=[],pt=0;return P(F,lt,"","",function(gt){return B.call(Q,gt,pt++)}),lt}function G(F){if(F._status===-1){var B=F._result;B=B(),B.then(function(Q){(F._status===0||F._status===-1)&&(F._status=1,F._result=Q)},function(Q){(F._status===0||F._status===-1)&&(F._status=2,F._result=Q)}),F._status===-1&&(F._status=0,F._result=B)}if(F._status===1)return F._result.default;throw F._result}var tt=typeof reportError=="function"?reportError:function(F){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var B=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof F=="object"&&F!==null&&typeof F.message=="string"?String(F.message):String(F),error:F});if(!window.dispatchEvent(B))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",F);return}console.error(F)},Z={map:V,forEach:function(F,B,Q){V(F,function(){B.apply(this,arguments)},Q)},count:function(F){var B=0;return V(F,function(){B++}),B},toArray:function(F){return V(F,function(B){return B})||[]},only:function(F){if(!A(F))throw Error("React.Children.only expected to receive a single React element child.");return F}};return Ht.Activity=p,Ht.Children=Z,Ht.Component=S,Ht.Fragment=e,Ht.Profiler=r,Ht.PureComponent=k,Ht.StrictMode=s,Ht.Suspense=c,Ht.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=_,Ht.__COMPILER_RUNTIME={__proto__:null,c:function(F){return _.H.useMemoCache(F)}},Ht.cache=function(F){return function(){return F.apply(null,arguments)}},Ht.cacheSignal=function(){return null},Ht.cloneElement=function(F,B,Q){if(F==null)throw Error("The argument must be a React element, but you passed "+F+".");var lt=x({},F.props),pt=F.key;if(B!=null)for(gt in B.key!==void 0&&(pt=""+B.key),B)!R.call(B,gt)||gt==="key"||gt==="__self"||gt==="__source"||gt==="ref"&&B.ref===void 0||(lt[gt]=B[gt]);var gt=arguments.length-2;if(gt===1)lt.children=Q;else if(1<gt){for(var vt=Array(gt),kt=0;kt<gt;kt++)vt[kt]=arguments[kt+2];lt.children=vt}return D(F.type,pt,lt)},Ht.createContext=function(F){return F={$$typeof:o,_currentValue:F,_currentValue2:F,_threadCount:0,Provider:null,Consumer:null},F.Provider=F,F.Consumer={$$typeof:i,_context:F},F},Ht.createElement=function(F,B,Q){var lt,pt={},gt=null;if(B!=null)for(lt in B.key!==void 0&&(gt=""+B.key),B)R.call(B,lt)&&lt!=="key"&&lt!=="__self"&&lt!=="__source"&&(pt[lt]=B[lt]);var vt=arguments.length-2;if(vt===1)pt.children=Q;else if(1<vt){for(var kt=Array(vt),Ct=0;Ct<vt;Ct++)kt[Ct]=arguments[Ct+2];pt.children=kt}if(F&&F.defaultProps)for(lt in vt=F.defaultProps,vt)pt[lt]===void 0&&(pt[lt]=vt[lt]);return D(F,gt,pt)},Ht.createRef=function(){return{current:null}},Ht.forwardRef=function(F){return{$$typeof:l,render:F}},Ht.isValidElement=A,Ht.lazy=function(F){return{$$typeof:d,_payload:{_status:-1,_result:F},_init:G}},Ht.memo=function(F,B){return{$$typeof:h,type:F,compare:B===void 0?null:B}},Ht.startTransition=function(F){var B=_.T,Q={};_.T=Q;try{var lt=F(),pt=_.S;pt!==null&&pt(Q,lt),typeof lt=="object"&&lt!==null&&typeof lt.then=="function"&&lt.then(N,tt)}catch(gt){tt(gt)}finally{B!==null&&Q.types!==null&&(B.types=Q.types),_.T=B}},Ht.unstable_useCacheRefresh=function(){return _.H.useCacheRefresh()},Ht.use=function(F){return _.H.use(F)},Ht.useActionState=function(F,B,Q){return _.H.useActionState(F,B,Q)},Ht.useCallback=function(F,B){return _.H.useCallback(F,B)},Ht.useContext=function(F){return _.H.useContext(F)},Ht.useDebugValue=function(){},Ht.useDeferredValue=function(F,B){return _.H.useDeferredValue(F,B)},Ht.useEffect=function(F,B){return _.H.useEffect(F,B)},Ht.useEffectEvent=function(F){return _.H.useEffectEvent(F)},Ht.useId=function(){return _.H.useId()},Ht.useImperativeHandle=function(F,B,Q){return _.H.useImperativeHandle(F,B,Q)},Ht.useInsertionEffect=function(F,B){return _.H.useInsertionEffect(F,B)},Ht.useLayoutEffect=function(F,B){return _.H.useLayoutEffect(F,B)},Ht.useMemo=function(F,B){return _.H.useMemo(F,B)},Ht.useOptimistic=function(F,B){return _.H.useOptimistic(F,B)},Ht.useReducer=function(F,B,Q){return _.H.useReducer(F,B,Q)},Ht.useRef=function(F){return _.H.useRef(F)},Ht.useState=function(F){return _.H.useState(F)},Ht.useSyncExternalStore=function(F,B,Q){return _.H.useSyncExternalStore(F,B,Q)},Ht.useTransition=function(){return _.H.useTransition()},Ht.version="19.2.3",Ht}var F$;function fw(){return F$||(F$=1,Jb.exports=TB()),Jb.exports}var St=fw();const kB=dw(St);var Qb={exports:{}},th={},tx={exports:{}},ex={};var L$;function $B(){return L$||(L$=1,(function(n){function t(P,V){var G=P.length;P.push(V);t:for(;0<G;){var tt=G-1>>>1,Z=P[tt];if(0<r(Z,V))P[tt]=V,P[G]=Z,G=tt;else break t}}function e(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var V=P[0],G=P.pop();if(G!==V){P[0]=G;t:for(var tt=0,Z=P.length,F=Z>>>1;tt<F;){var B=2*(tt+1)-1,Q=P[B],lt=B+1,pt=P[lt];if(0>r(Q,G))lt<Z&&0>r(pt,Q)?(P[tt]=pt,P[lt]=G,tt=lt):(P[tt]=Q,P[B]=G,tt=B);else if(lt<Z&&0>r(pt,G))P[tt]=pt,P[lt]=G,tt=lt;else break t}}return V}function r(P,V){var G=P.sortIndex-V.sortIndex;return G!==0?G:P.id-V.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();n.unstable_now=function(){return o.now()-l}}var c=[],h=[],d=1,p=null,m=3,y=!1,b=!1,x=!1,w=!1,S=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,k=typeof setImmediate<"u"?setImmediate:null;function $(P){for(var V=e(h);V!==null;){if(V.callback===null)s(h);else if(V.startTime<=P)s(h),V.sortIndex=V.expirationTime,t(c,V);else break;V=e(h)}}function E(P){if(x=!1,$(P),!b)if(e(c)!==null)b=!0,N||(N=!0,z());else{var V=e(h);V!==null&&X(E,V.startTime-P)}}var N=!1,_=-1,R=5,D=-1;function O(){return w?!0:!(n.unstable_now()-D<R)}function A(){if(w=!1,N){var P=n.unstable_now();D=P;var V=!0;try{t:{b=!1,x&&(x=!1,T(_),_=-1),y=!0;var G=m;try{e:{for($(P),p=e(c);p!==null&&!(p.expirationTime>P&&O());){var tt=p.callback;if(typeof tt=="function"){p.callback=null,m=p.priorityLevel;var Z=tt(p.expirationTime<=P);if(P=n.unstable_now(),typeof Z=="function"){p.callback=Z,$(P),V=!0;break e}p===e(c)&&s(c),$(P)}else s(c);p=e(c)}if(p!==null)V=!0;else{var F=e(h);F!==null&&X(E,F.startTime-P),V=!1}}break t}finally{p=null,m=G,y=!1}V=void 0}}finally{V?z():N=!1}}}var z;if(typeof k=="function")z=function(){k(A)};else if(typeof MessageChannel<"u"){var q=new MessageChannel,W=q.port2;q.port1.onmessage=A,z=function(){W.postMessage(null)}}else z=function(){S(A,0)};function X(P,V){_=S(function(){P(n.unstable_now())},V)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(P){switch(m){case 1:case 2:case 3:var V=3;break;default:V=m}var G=m;m=V;try{return P()}finally{m=G}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(P,V){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var G=m;m=P;try{return V()}finally{m=G}},n.unstable_scheduleCallback=function(P,V,G){var tt=n.unstable_now();switch(typeof G=="object"&&G!==null?(G=G.delay,G=typeof G=="number"&&0<G?tt+G:tt):G=tt,P){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=G+Z,P={id:d++,callback:V,priorityLevel:P,startTime:G,expirationTime:Z,sortIndex:-1},G>tt?(P.sortIndex=G,t(h,P),e(c)===null&&P===e(h)&&(x?(T(_),_=-1):x=!0,X(E,G-tt))):(P.sortIndex=Z,t(c,P),b||y||(b=!0,N||(N=!0,z()))),P},n.unstable_shouldYield=O,n.unstable_wrapCallback=function(P){var V=m;return function(){var G=m;m=V;try{return P.apply(this,arguments)}finally{m=G}}}})(ex)),ex}var P$;function EB(){return P$||(P$=1,tx.exports=$B()),tx.exports}var nx={exports:{}},ss={};var z$;function IB(){if(z$)return ss;z$=1;var n=fw();function t(c){var h="https://react.dev/errors/"+c;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+c+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(c,h,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:c,containerInfo:h,implementation:d}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function l(c,h){if(c==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return ss.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,ss.createPortal=function(c,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(t(299));return i(c,h,null,d)},ss.flushSync=function(c){var h=o.T,d=s.p;try{if(o.T=null,s.p=2,c)return c()}finally{o.T=h,s.p=d,s.d.f()}},ss.preconnect=function(c,h){typeof c=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(c,h))},ss.prefetchDNS=function(c){typeof c=="string"&&s.d.D(c)},ss.preinit=function(c,h){if(typeof c=="string"&&h&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(c,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(c,{crossOrigin:p,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},ss.preinitModule=function(c,h){if(typeof c=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=l(h.as,h.crossOrigin);s.d.M(c,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(c)},ss.preload=function(c,h){if(typeof c=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin);s.d.L(c,d,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},ss.preloadModule=function(c,h){if(typeof c=="string")if(h){var d=l(h.as,h.crossOrigin);s.d.m(c,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(c)},ss.requestFormReset=function(c){s.d.r(c)},ss.unstable_batchedUpdates=function(c,h){return c(h)},ss.useFormState=function(c,h,d){return o.H.useFormState(c,h,d)},ss.useFormStatus=function(){return o.H.useHostTransitionStatus()},ss.version="19.2.3",ss}var B$;function NB(){if(B$)return nx.exports;B$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),nx.exports=IB(),nx.exports}var V$;function AB(){if(V$)return th;V$=1;var n=EB(),t=fw(),e=NB();function s(a){var u="https://react.dev/errors/"+a;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)u+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+a+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function i(a){var u=a,f=a;if(a.alternate)for(;u.return;)u=u.return;else{a=u;do u=a,(u.flags&4098)!==0&&(f=u.return),a=u.return;while(a)}return u.tag===3?f:null}function o(a){if(a.tag===13){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function l(a){if(a.tag===31){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function c(a){if(i(a)!==a)throw Error(s(188))}function h(a){var u=a.alternate;if(!u){if(u=i(a),u===null)throw Error(s(188));return u!==a?null:a}for(var f=a,g=u;;){var v=f.return;if(v===null)break;var C=v.alternate;if(C===null){if(g=v.return,g!==null){f=g;continue}break}if(v.child===C.child){for(C=v.child;C;){if(C===f)return c(v),a;if(C===g)return c(v),u;C=C.sibling}throw Error(s(188))}if(f.return!==g.return)f=v,g=C;else{for(var I=!1,M=v.child;M;){if(M===f){I=!0,f=v,g=C;break}if(M===g){I=!0,g=v,f=C;break}M=M.sibling}if(!I){for(M=C.child;M;){if(M===f){I=!0,f=C,g=v;break}if(M===g){I=!0,g=C,f=v;break}M=M.sibling}if(!I)throw Error(s(189))}}if(f.alternate!==g)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?a:u}function d(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a;for(a=a.child;a!==null;){if(u=d(a),u!==null)return u;a=a.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),k=Symbol.for("react.context"),$=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),R=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),O=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function z(a){return a===null||typeof a!="object"?null:(a=A&&a[A]||a["@@iterator"],typeof a=="function"?a:null)}var q=Symbol.for("react.client.reference");function W(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===q?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case x:return"Fragment";case S:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case N:return"SuspenseList";case D:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case b:return"Portal";case k:return a.displayName||"Context";case T:return(a._context.displayName||"Context")+".Consumer";case $:var u=a.render;return a=a.displayName,a||(a=u.displayName||u.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case _:return u=a.displayName||null,u!==null?u:W(a.type)||"Memo";case R:u=a._payload,a=a._init;try{return W(a(u))}catch{}}return null}var X=Array.isArray,P=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,G={pending:!1,data:null,method:null,action:null},tt=[],Z=-1;function F(a){return{current:a}}function B(a){0>Z||(a.current=tt[Z],tt[Z]=null,Z--)}function Q(a,u){Z++,tt[Z]=a.current,a.current=u}var lt=F(null),pt=F(null),gt=F(null),vt=F(null);function kt(a,u){switch(Q(gt,u),Q(pt,a),Q(lt,null),u.nodeType){case 9:case 11:a=(a=u.documentElement)&&(a=a.namespaceURI)?n$(a):0;break;default:if(a=u.tagName,u=u.namespaceURI)u=n$(u),a=s$(u,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}B(lt),Q(lt,a)}function Ct(){B(lt),B(pt),B(gt)}function Rt(a){a.memoizedState!==null&&Q(vt,a);var u=lt.current,f=s$(u,a.type);u!==f&&(Q(pt,a),Q(lt,f))}function Gt(a){pt.current===a&&(B(lt),B(pt)),vt.current===a&&(B(vt),Xu._currentValue=G)}var re,ge;function de(a){if(re===void 0)try{throw Error()}catch(f){var u=f.stack.trim().match(/\n( *(at )?)/);re=u&&u[1]||"",ge=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+re+a+ge}var pe=!1;function ae(a,u){if(!a||pe)return"";pe=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(u){var bt=function(){throw Error()};if(Object.defineProperty(bt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(bt,[])}catch(ht){var ut=ht}Reflect.construct(a,[],bt)}else{try{bt.call()}catch(ht){ut=ht}a.call(bt.prototype)}}else{try{throw Error()}catch(ht){ut=ht}(bt=a())&&typeof bt.catch=="function"&&bt.catch(function(){})}}catch(ht){if(ht&&ut&&typeof ht.stack=="string")return[ht.stack,ut.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var v=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");v&&v.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var C=g.DetermineComponentFrameRoot(),I=C[0],M=C[1];if(I&&M){var j=I.split(`
`),at=M.split(`
`);for(v=g=0;g<j.length&&!j[g].includes("DetermineComponentFrameRoot");)g++;for(;v<at.length&&!at[v].includes("DetermineComponentFrameRoot");)v++;if(g===j.length||v===at.length)for(g=j.length-1,v=at.length-1;1<=g&&0<=v&&j[g]!==at[v];)v--;for(;1<=g&&0<=v;g--,v--)if(j[g]!==at[v]){if(g!==1||v!==1)do if(g--,v--,0>v||j[g]!==at[v]){var mt=`
`+j[g].replace(" at new "," at ");return a.displayName&&mt.includes("<anonymous>")&&(mt=mt.replace("<anonymous>",a.displayName)),mt}while(1<=g&&0<=v);break}}}finally{pe=!1,Error.prepareStackTrace=f}return(f=a?a.displayName||a.name:"")?de(f):""}function Ne(a,u){switch(a.tag){case 26:case 27:case 5:return de(a.type);case 16:return de("Lazy");case 13:return a.child!==u&&u!==null?de("Suspense Fallback"):de("Suspense");case 19:return de("SuspenseList");case 0:case 15:return ae(a.type,!1);case 11:return ae(a.type.render,!1);case 1:return ae(a.type,!0);case 31:return de("Activity");default:return""}}function Ce(a){try{var u="",f=null;do u+=Ne(a,f),f=a,a=a.return;while(a);return u}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var Pt=Object.prototype.hasOwnProperty,Jt=n.unstable_scheduleCallback,$n=n.unstable_cancelCallback,dn=n.unstable_shouldYield,ds=n.unstable_requestPaint,me=n.unstable_now,an=n.unstable_getCurrentPriorityLevel,Un=n.unstable_ImmediatePriority,Er=n.unstable_UserBlockingPriority,Ps=n.unstable_NormalPriority,ea=n.unstable_LowPriority,gl=n.unstable_IdlePriority,au=n.log,P0=n.unstable_setDisableYieldValue,Kr=null,fs=null;function Xr(a){if(typeof au=="function"&&P0(a),fs&&typeof fs.setStrictMode=="function")try{fs.setStrictMode(Kr,a)}catch{}}var zs=Math.clz32?Math.clz32:oP,rP=Math.log,iP=Math.LN2;function oP(a){return a>>>=0,a===0?32:31-(rP(a)/iP|0)|0}var Sf=256,Cf=262144,Tf=4194304;function na(a){var u=a&42;if(u!==0)return u;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function kf(a,u,f){var g=a.pendingLanes;if(g===0)return 0;var v=0,C=a.suspendedLanes,I=a.pingedLanes;a=a.warmLanes;var M=g&134217727;return M!==0?(g=M&~C,g!==0?v=na(g):(I&=M,I!==0?v=na(I):f||(f=M&~a,f!==0&&(v=na(f))))):(M=g&~C,M!==0?v=na(M):I!==0?v=na(I):f||(f=g&~a,f!==0&&(v=na(f)))),v===0?0:u!==0&&u!==v&&(u&C)===0&&(C=v&-v,f=u&-u,C>=f||C===32&&(f&4194048)!==0)?u:v}function lu(a,u){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&u)===0}function aP(a,u){switch(a){case 1:case 2:case 4:case 8:case 64:return u+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function LC(){var a=Tf;return Tf<<=1,(Tf&62914560)===0&&(Tf=4194304),a}function z0(a){for(var u=[],f=0;31>f;f++)u.push(a);return u}function cu(a,u){a.pendingLanes|=u,u!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function lP(a,u,f,g,v,C){var I=a.pendingLanes;a.pendingLanes=f,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=f,a.entangledLanes&=f,a.errorRecoveryDisabledLanes&=f,a.shellSuspendCounter=0;var M=a.entanglements,j=a.expirationTimes,at=a.hiddenUpdates;for(f=I&~f;0<f;){var mt=31-zs(f),bt=1<<mt;M[mt]=0,j[mt]=-1;var ut=at[mt];if(ut!==null)for(at[mt]=null,mt=0;mt<ut.length;mt++){var ht=ut[mt];ht!==null&&(ht.lane&=-536870913)}f&=~bt}g!==0&&PC(a,g,0),C!==0&&v===0&&a.tag!==0&&(a.suspendedLanes|=C&~(I&~u))}function PC(a,u,f){a.pendingLanes|=u,a.suspendedLanes&=~u;var g=31-zs(u);a.entangledLanes|=u,a.entanglements[g]=a.entanglements[g]|1073741824|f&261930}function zC(a,u){var f=a.entangledLanes|=u;for(a=a.entanglements;f;){var g=31-zs(f),v=1<<g;v&u|a[g]&u&&(a[g]|=u),f&=~v}}function BC(a,u){var f=u&-u;return f=(f&42)!==0?1:B0(f),(f&(a.suspendedLanes|u))!==0?0:f}function B0(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function V0(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function VC(){var a=V.p;return a!==0?a:(a=window.event,a===void 0?32:$$(a.type))}function UC(a,u){var f=V.p;try{return V.p=a,u()}finally{V.p=f}}var Qi=Math.random().toString(36).slice(2),jn="__reactFiber$"+Qi,Ts="__reactProps$"+Qi,yl="__reactContainer$"+Qi,U0="__reactEvents$"+Qi,cP="__reactListeners$"+Qi,uP="__reactHandles$"+Qi,jC="__reactResources$"+Qi,uu="__reactMarker$"+Qi;function j0(a){delete a[jn],delete a[Ts],delete a[U0],delete a[cP],delete a[uP]}function bl(a){var u=a[jn];if(u)return u;for(var f=a.parentNode;f;){if(u=f[yl]||f[jn]){if(f=u.alternate,u.child!==null||f!==null&&f.child!==null)for(a=u$(a);a!==null;){if(f=a[jn])return f;a=u$(a)}return u}a=f,f=a.parentNode}return null}function xl(a){if(a=a[jn]||a[yl]){var u=a.tag;if(u===5||u===6||u===13||u===31||u===26||u===27||u===3)return a}return null}function hu(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a.stateNode;throw Error(s(33))}function vl(a){var u=a[jC];return u||(u=a[jC]={hoistableStyles:new Map,hoistableScripts:new Map}),u}function Mn(a){a[uu]=!0}var GC=new Set,WC={};function sa(a,u){wl(a,u),wl(a+"Capture",u)}function wl(a,u){for(WC[a]=u,a=0;a<u.length;a++)GC.add(u[a])}var hP=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),HC={},qC={};function dP(a){return Pt.call(qC,a)?!0:Pt.call(HC,a)?!1:hP.test(a)?qC[a]=!0:(HC[a]=!0,!1)}function $f(a,u,f){if(dP(u))if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":a.removeAttribute(u);return;case"boolean":var g=u.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){a.removeAttribute(u);return}}a.setAttribute(u,""+f)}}function Ef(a,u,f){if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(u);return}a.setAttribute(u,""+f)}}function vi(a,u,f,g){if(g===null)a.removeAttribute(f);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(f);return}a.setAttributeNS(u,f,""+g)}}function nr(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function KC(a){var u=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(u==="checkbox"||u==="radio")}function fP(a,u,f){var g=Object.getOwnPropertyDescriptor(a.constructor.prototype,u);if(!a.hasOwnProperty(u)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var v=g.get,C=g.set;return Object.defineProperty(a,u,{configurable:!0,get:function(){return v.call(this)},set:function(I){f=""+I,C.call(this,I)}}),Object.defineProperty(a,u,{enumerable:g.enumerable}),{getValue:function(){return f},setValue:function(I){f=""+I},stopTracking:function(){a._valueTracker=null,delete a[u]}}}}function G0(a){if(!a._valueTracker){var u=KC(a)?"checked":"value";a._valueTracker=fP(a,u,""+a[u])}}function XC(a){if(!a)return!1;var u=a._valueTracker;if(!u)return!0;var f=u.getValue(),g="";return a&&(g=KC(a)?a.checked?"true":"false":a.value),a=g,a!==f?(u.setValue(a),!0):!1}function If(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var pP=/[\n"\\]/g;function sr(a){return a.replace(pP,function(u){return"\\"+u.charCodeAt(0).toString(16)+" "})}function W0(a,u,f,g,v,C,I,M){a.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?a.type=I:a.removeAttribute("type"),u!=null?I==="number"?(u===0&&a.value===""||a.value!=u)&&(a.value=""+nr(u)):a.value!==""+nr(u)&&(a.value=""+nr(u)):I!=="submit"&&I!=="reset"||a.removeAttribute("value"),u!=null?H0(a,I,nr(u)):f!=null?H0(a,I,nr(f)):g!=null&&a.removeAttribute("value"),v==null&&C!=null&&(a.defaultChecked=!!C),v!=null&&(a.checked=v&&typeof v!="function"&&typeof v!="symbol"),M!=null&&typeof M!="function"&&typeof M!="symbol"&&typeof M!="boolean"?a.name=""+nr(M):a.removeAttribute("name")}function YC(a,u,f,g,v,C,I,M){if(C!=null&&typeof C!="function"&&typeof C!="symbol"&&typeof C!="boolean"&&(a.type=C),u!=null||f!=null){if(!(C!=="submit"&&C!=="reset"||u!=null)){G0(a);return}f=f!=null?""+nr(f):"",u=u!=null?""+nr(u):f,M||u===a.value||(a.value=u),a.defaultValue=u}g=g??v,g=typeof g!="function"&&typeof g!="symbol"&&!!g,a.checked=M?a.checked:!!g,a.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(a.name=I),G0(a)}function H0(a,u,f){u==="number"&&If(a.ownerDocument)===a||a.defaultValue===""+f||(a.defaultValue=""+f)}function Sl(a,u,f,g){if(a=a.options,u){u={};for(var v=0;v<f.length;v++)u["$"+f[v]]=!0;for(f=0;f<a.length;f++)v=u.hasOwnProperty("$"+a[f].value),a[f].selected!==v&&(a[f].selected=v),v&&g&&(a[f].defaultSelected=!0)}else{for(f=""+nr(f),u=null,v=0;v<a.length;v++){if(a[v].value===f){a[v].selected=!0,g&&(a[v].defaultSelected=!0);return}u!==null||a[v].disabled||(u=a[v])}u!==null&&(u.selected=!0)}}function ZC(a,u,f){if(u!=null&&(u=""+nr(u),u!==a.value&&(a.value=u),f==null)){a.defaultValue!==u&&(a.defaultValue=u);return}a.defaultValue=f!=null?""+nr(f):""}function JC(a,u,f,g){if(u==null){if(g!=null){if(f!=null)throw Error(s(92));if(X(g)){if(1<g.length)throw Error(s(93));g=g[0]}f=g}f==null&&(f=""),u=f}f=nr(u),a.defaultValue=f,g=a.textContent,g===f&&g!==""&&g!==null&&(a.value=g),G0(a)}function Cl(a,u){if(u){var f=a.firstChild;if(f&&f===a.lastChild&&f.nodeType===3){f.nodeValue=u;return}}a.textContent=u}var mP=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function QC(a,u,f){var g=u.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?g?a.setProperty(u,""):u==="float"?a.cssFloat="":a[u]="":g?a.setProperty(u,f):typeof f!="number"||f===0||mP.has(u)?u==="float"?a.cssFloat=f:a[u]=(""+f).trim():a[u]=f+"px"}function tT(a,u,f){if(u!=null&&typeof u!="object")throw Error(s(62));if(a=a.style,f!=null){for(var g in f)!f.hasOwnProperty(g)||u!=null&&u.hasOwnProperty(g)||(g.indexOf("--")===0?a.setProperty(g,""):g==="float"?a.cssFloat="":a[g]="");for(var v in u)g=u[v],u.hasOwnProperty(v)&&f[v]!==g&&QC(a,v,g)}else for(var C in u)u.hasOwnProperty(C)&&QC(a,C,u[C])}function q0(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var gP=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),yP=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Nf(a){return yP.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function wi(){}var K0=null;function X0(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var Tl=null,kl=null;function eT(a){var u=xl(a);if(u&&(a=u.stateNode)){var f=a[Ts]||null;t:switch(a=u.stateNode,u.type){case"input":if(W0(a,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),u=f.name,f.type==="radio"&&u!=null){for(f=a;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+sr(""+u)+'"][type="radio"]'),u=0;u<f.length;u++){var g=f[u];if(g!==a&&g.form===a.form){var v=g[Ts]||null;if(!v)throw Error(s(90));W0(g,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name)}}for(u=0;u<f.length;u++)g=f[u],g.form===a.form&&XC(g)}break t;case"textarea":ZC(a,f.value,f.defaultValue);break t;case"select":u=f.value,u!=null&&Sl(a,!!f.multiple,u,!1)}}}var Y0=!1;function nT(a,u,f){if(Y0)return a(u,f);Y0=!0;try{var g=a(u);return g}finally{if(Y0=!1,(Tl!==null||kl!==null)&&(gp(),Tl&&(u=Tl,a=kl,kl=Tl=null,eT(u),a)))for(u=0;u<a.length;u++)eT(a[u])}}function du(a,u){var f=a.stateNode;if(f===null)return null;var g=f[Ts]||null;if(g===null)return null;f=g[u];t:switch(u){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(a=a.type,g=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!g;break t;default:a=!1}if(a)return null;if(f&&typeof f!="function")throw Error(s(231,u,typeof f));return f}var Si=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Z0=!1;if(Si)try{var fu={};Object.defineProperty(fu,"passive",{get:function(){Z0=!0}}),window.addEventListener("test",fu,fu),window.removeEventListener("test",fu,fu)}catch{Z0=!1}var to=null,J0=null,Af=null;function sT(){if(Af)return Af;var a,u=J0,f=u.length,g,v="value"in to?to.value:to.textContent,C=v.length;for(a=0;a<f&&u[a]===v[a];a++);var I=f-a;for(g=1;g<=I&&u[f-g]===v[C-g];g++);return Af=v.slice(a,1<g?1-g:void 0)}function _f(a){var u=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&u===13&&(a=13)):a=u,a===10&&(a=13),32<=a||a===13?a:0}function Rf(){return!0}function rT(){return!1}function ks(a){function u(f,g,v,C,I){this._reactName=f,this._targetInst=v,this.type=g,this.nativeEvent=C,this.target=I,this.currentTarget=null;for(var M in a)a.hasOwnProperty(M)&&(f=a[M],this[M]=f?f(C):C[M]);return this.isDefaultPrevented=(C.defaultPrevented!=null?C.defaultPrevented:C.returnValue===!1)?Rf:rT,this.isPropagationStopped=rT,this}return p(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=Rf)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=Rf)},persist:function(){},isPersistent:Rf}),u}var ra={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Df=ks(ra),pu=p({},ra,{view:0,detail:0}),bP=ks(pu),Q0,ty,mu,Of=p({},pu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:ny,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==mu&&(mu&&a.type==="mousemove"?(Q0=a.screenX-mu.screenX,ty=a.screenY-mu.screenY):ty=Q0=0,mu=a),Q0)},movementY:function(a){return"movementY"in a?a.movementY:ty}}),iT=ks(Of),xP=p({},Of,{dataTransfer:0}),vP=ks(xP),wP=p({},pu,{relatedTarget:0}),ey=ks(wP),SP=p({},ra,{animationName:0,elapsedTime:0,pseudoElement:0}),CP=ks(SP),TP=p({},ra,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),kP=ks(TP),$P=p({},ra,{data:0}),oT=ks($P),EP={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},IP={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},NP={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function AP(a){var u=this.nativeEvent;return u.getModifierState?u.getModifierState(a):(a=NP[a])?!!u[a]:!1}function ny(){return AP}var _P=p({},pu,{key:function(a){if(a.key){var u=EP[a.key]||a.key;if(u!=="Unidentified")return u}return a.type==="keypress"?(a=_f(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?IP[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:ny,charCode:function(a){return a.type==="keypress"?_f(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?_f(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),RP=ks(_P),DP=p({},Of,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),aT=ks(DP),OP=p({},pu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:ny}),MP=ks(OP),FP=p({},ra,{propertyName:0,elapsedTime:0,pseudoElement:0}),LP=ks(FP),PP=p({},Of,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),zP=ks(PP),BP=p({},ra,{newState:0,oldState:0}),VP=ks(BP),UP=[9,13,27,32],sy=Si&&"CompositionEvent"in window,gu=null;Si&&"documentMode"in document&&(gu=document.documentMode);var jP=Si&&"TextEvent"in window&&!gu,lT=Si&&(!sy||gu&&8<gu&&11>=gu),cT=" ",uT=!1;function hT(a,u){switch(a){case"keyup":return UP.indexOf(u.keyCode)!==-1;case"keydown":return u.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function dT(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var $l=!1;function GP(a,u){switch(a){case"compositionend":return dT(u);case"keypress":return u.which!==32?null:(uT=!0,cT);case"textInput":return a=u.data,a===cT&&uT?null:a;default:return null}}function WP(a,u){if($l)return a==="compositionend"||!sy&&hT(a,u)?(a=sT(),Af=J0=to=null,$l=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(u.ctrlKey||u.altKey||u.metaKey)||u.ctrlKey&&u.altKey){if(u.char&&1<u.char.length)return u.char;if(u.which)return String.fromCharCode(u.which)}return null;case"compositionend":return lT&&u.locale!=="ko"?null:u.data;default:return null}}var HP={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function fT(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u==="input"?!!HP[a.type]:u==="textarea"}function pT(a,u,f,g){Tl?kl?kl.push(g):kl=[g]:Tl=g,u=Cp(u,"onChange"),0<u.length&&(f=new Df("onChange","change",null,f,g),a.push({event:f,listeners:u}))}var yu=null,bu=null;function qP(a){Y2(a,0)}function Mf(a){var u=hu(a);if(XC(u))return a}function mT(a,u){if(a==="change")return u}var gT=!1;if(Si){var ry;if(Si){var iy="oninput"in document;if(!iy){var yT=document.createElement("div");yT.setAttribute("oninput","return;"),iy=typeof yT.oninput=="function"}ry=iy}else ry=!1;gT=ry&&(!document.documentMode||9<document.documentMode)}function bT(){yu&&(yu.detachEvent("onpropertychange",xT),bu=yu=null)}function xT(a){if(a.propertyName==="value"&&Mf(bu)){var u=[];pT(u,bu,a,X0(a)),nT(qP,u)}}function KP(a,u,f){a==="focusin"?(bT(),yu=u,bu=f,yu.attachEvent("onpropertychange",xT)):a==="focusout"&&bT()}function XP(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Mf(bu)}function YP(a,u){if(a==="click")return Mf(u)}function ZP(a,u){if(a==="input"||a==="change")return Mf(u)}function JP(a,u){return a===u&&(a!==0||1/a===1/u)||a!==a&&u!==u}var Bs=typeof Object.is=="function"?Object.is:JP;function xu(a,u){if(Bs(a,u))return!0;if(typeof a!="object"||a===null||typeof u!="object"||u===null)return!1;var f=Object.keys(a),g=Object.keys(u);if(f.length!==g.length)return!1;for(g=0;g<f.length;g++){var v=f[g];if(!Pt.call(u,v)||!Bs(a[v],u[v]))return!1}return!0}function vT(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function wT(a,u){var f=vT(a);a=0;for(var g;f;){if(f.nodeType===3){if(g=a+f.textContent.length,a<=u&&g>=u)return{node:f,offset:u-a};a=g}t:{for(;f;){if(f.nextSibling){f=f.nextSibling;break t}f=f.parentNode}f=void 0}f=vT(f)}}function ST(a,u){return a&&u?a===u?!0:a&&a.nodeType===3?!1:u&&u.nodeType===3?ST(a,u.parentNode):"contains"in a?a.contains(u):a.compareDocumentPosition?!!(a.compareDocumentPosition(u)&16):!1:!1}function CT(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var u=If(a.document);u instanceof a.HTMLIFrameElement;){try{var f=typeof u.contentWindow.location.href=="string"}catch{f=!1}if(f)a=u.contentWindow;else break;u=If(a.document)}return u}function oy(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u&&(u==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||u==="textarea"||a.contentEditable==="true")}var QP=Si&&"documentMode"in document&&11>=document.documentMode,El=null,ay=null,vu=null,ly=!1;function TT(a,u,f){var g=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;ly||El==null||El!==If(g)||(g=El,"selectionStart"in g&&oy(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),vu&&xu(vu,g)||(vu=g,g=Cp(ay,"onSelect"),0<g.length&&(u=new Df("onSelect","select",null,u,f),a.push({event:u,listeners:g}),u.target=El)))}function ia(a,u){var f={};return f[a.toLowerCase()]=u.toLowerCase(),f["Webkit"+a]="webkit"+u,f["Moz"+a]="moz"+u,f}var Il={animationend:ia("Animation","AnimationEnd"),animationiteration:ia("Animation","AnimationIteration"),animationstart:ia("Animation","AnimationStart"),transitionrun:ia("Transition","TransitionRun"),transitionstart:ia("Transition","TransitionStart"),transitioncancel:ia("Transition","TransitionCancel"),transitionend:ia("Transition","TransitionEnd")},cy={},kT={};Si&&(kT=document.createElement("div").style,"AnimationEvent"in window||(delete Il.animationend.animation,delete Il.animationiteration.animation,delete Il.animationstart.animation),"TransitionEvent"in window||delete Il.transitionend.transition);function oa(a){if(cy[a])return cy[a];if(!Il[a])return a;var u=Il[a],f;for(f in u)if(u.hasOwnProperty(f)&&f in kT)return cy[a]=u[f];return a}var $T=oa("animationend"),ET=oa("animationiteration"),IT=oa("animationstart"),tz=oa("transitionrun"),ez=oa("transitionstart"),nz=oa("transitioncancel"),NT=oa("transitionend"),AT=new Map,uy="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");uy.push("scrollEnd");function Ir(a,u){AT.set(a,u),sa(u,[a])}var Ff=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var u=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(u))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},rr=[],Nl=0,hy=0;function Lf(){for(var a=Nl,u=hy=Nl=0;u<a;){var f=rr[u];rr[u++]=null;var g=rr[u];rr[u++]=null;var v=rr[u];rr[u++]=null;var C=rr[u];if(rr[u++]=null,g!==null&&v!==null){var I=g.pending;I===null?v.next=v:(v.next=I.next,I.next=v),g.pending=v}C!==0&&_T(f,v,C)}}function Pf(a,u,f,g){rr[Nl++]=a,rr[Nl++]=u,rr[Nl++]=f,rr[Nl++]=g,hy|=g,a.lanes|=g,a=a.alternate,a!==null&&(a.lanes|=g)}function dy(a,u,f,g){return Pf(a,u,f,g),zf(a)}function aa(a,u){return Pf(a,null,null,u),zf(a)}function _T(a,u,f){a.lanes|=f;var g=a.alternate;g!==null&&(g.lanes|=f);for(var v=!1,C=a.return;C!==null;)C.childLanes|=f,g=C.alternate,g!==null&&(g.childLanes|=f),C.tag===22&&(a=C.stateNode,a===null||a._visibility&1||(v=!0)),a=C,C=C.return;return a.tag===3?(C=a.stateNode,v&&u!==null&&(v=31-zs(f),a=C.hiddenUpdates,g=a[v],g===null?a[v]=[u]:g.push(u),u.lane=f|536870912),C):null}function zf(a){if(50<Uu)throw Uu=0,wb=null,Error(s(185));for(var u=a.return;u!==null;)a=u,u=a.return;return a.tag===3?a.stateNode:null}var Al={};function sz(a,u,f,g){this.tag=a,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=u,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Vs(a,u,f,g){return new sz(a,u,f,g)}function fy(a){return a=a.prototype,!(!a||!a.isReactComponent)}function Ci(a,u){var f=a.alternate;return f===null?(f=Vs(a.tag,u,a.key,a.mode),f.elementType=a.elementType,f.type=a.type,f.stateNode=a.stateNode,f.alternate=a,a.alternate=f):(f.pendingProps=u,f.type=a.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=a.flags&65011712,f.childLanes=a.childLanes,f.lanes=a.lanes,f.child=a.child,f.memoizedProps=a.memoizedProps,f.memoizedState=a.memoizedState,f.updateQueue=a.updateQueue,u=a.dependencies,f.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext},f.sibling=a.sibling,f.index=a.index,f.ref=a.ref,f.refCleanup=a.refCleanup,f}function RT(a,u){a.flags&=65011714;var f=a.alternate;return f===null?(a.childLanes=0,a.lanes=u,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=f.childLanes,a.lanes=f.lanes,a.child=f.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=f.memoizedProps,a.memoizedState=f.memoizedState,a.updateQueue=f.updateQueue,a.type=f.type,u=f.dependencies,a.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),a}function Bf(a,u,f,g,v,C){var I=0;if(g=a,typeof a=="function")fy(a)&&(I=1);else if(typeof a=="string")I=lB(a,f,lt.current)?26:a==="html"||a==="head"||a==="body"?27:5;else t:switch(a){case D:return a=Vs(31,f,u,v),a.elementType=D,a.lanes=C,a;case x:return la(f.children,v,C,u);case w:I=8,v|=24;break;case S:return a=Vs(12,f,u,v|2),a.elementType=S,a.lanes=C,a;case E:return a=Vs(13,f,u,v),a.elementType=E,a.lanes=C,a;case N:return a=Vs(19,f,u,v),a.elementType=N,a.lanes=C,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case k:I=10;break t;case T:I=9;break t;case $:I=11;break t;case _:I=14;break t;case R:I=16,g=null;break t}I=29,f=Error(s(130,a===null?"null":typeof a,"")),g=null}return u=Vs(I,f,u,v),u.elementType=a,u.type=g,u.lanes=C,u}function la(a,u,f,g){return a=Vs(7,a,g,u),a.lanes=f,a}function py(a,u,f){return a=Vs(6,a,null,u),a.lanes=f,a}function DT(a){var u=Vs(18,null,null,0);return u.stateNode=a,u}function my(a,u,f){return u=Vs(4,a.children!==null?a.children:[],a.key,u),u.lanes=f,u.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},u}var OT=new WeakMap;function ir(a,u){if(typeof a=="object"&&a!==null){var f=OT.get(a);return f!==void 0?f:(u={value:a,source:u,stack:Ce(u)},OT.set(a,u),u)}return{value:a,source:u,stack:Ce(u)}}var _l=[],Rl=0,Vf=null,wu=0,or=[],ar=0,eo=null,Yr=1,Zr="";function Ti(a,u){_l[Rl++]=wu,_l[Rl++]=Vf,Vf=a,wu=u}function MT(a,u,f){or[ar++]=Yr,or[ar++]=Zr,or[ar++]=eo,eo=a;var g=Yr;a=Zr;var v=32-zs(g)-1;g&=~(1<<v),f+=1;var C=32-zs(u)+v;if(30<C){var I=v-v%5;C=(g&(1<<I)-1).toString(32),g>>=I,v-=I,Yr=1<<32-zs(u)+v|f<<v|g,Zr=C+a}else Yr=1<<C|f<<v|g,Zr=a}function gy(a){a.return!==null&&(Ti(a,1),MT(a,1,0))}function yy(a){for(;a===Vf;)Vf=_l[--Rl],_l[Rl]=null,wu=_l[--Rl],_l[Rl]=null;for(;a===eo;)eo=or[--ar],or[ar]=null,Zr=or[--ar],or[ar]=null,Yr=or[--ar],or[ar]=null}function FT(a,u){or[ar++]=Yr,or[ar++]=Zr,or[ar++]=eo,Yr=u.id,Zr=u.overflow,eo=a}var Gn=null,Be=null,le=!1,no=null,lr=!1,by=Error(s(519));function so(a){var u=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Su(ir(u,a)),by}function LT(a){var u=a.stateNode,f=a.type,g=a.memoizedProps;switch(u[jn]=a,u[Ts]=g,f){case"dialog":se("cancel",u),se("close",u);break;case"iframe":case"object":case"embed":se("load",u);break;case"video":case"audio":for(f=0;f<Gu.length;f++)se(Gu[f],u);break;case"source":se("error",u);break;case"img":case"image":case"link":se("error",u),se("load",u);break;case"details":se("toggle",u);break;case"input":se("invalid",u),YC(u,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":se("invalid",u);break;case"textarea":se("invalid",u),JC(u,g.value,g.defaultValue,g.children)}f=g.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||u.textContent===""+f||g.suppressHydrationWarning===!0||t$(u.textContent,f)?(g.popover!=null&&(se("beforetoggle",u),se("toggle",u)),g.onScroll!=null&&se("scroll",u),g.onScrollEnd!=null&&se("scrollend",u),g.onClick!=null&&(u.onclick=wi),u=!0):u=!1,u||so(a,!0)}function PT(a){for(Gn=a.return;Gn;)switch(Gn.tag){case 5:case 31:case 13:lr=!1;return;case 27:case 3:lr=!0;return;default:Gn=Gn.return}}function Dl(a){if(a!==Gn)return!1;if(!le)return PT(a),le=!0,!1;var u=a.tag,f;if((f=u!==3&&u!==27)&&((f=u===5)&&(f=a.type,f=!(f!=="form"&&f!=="button")||Fb(a.type,a.memoizedProps)),f=!f),f&&Be&&so(a),PT(a),u===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Be=c$(a)}else if(u===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Be=c$(a)}else u===27?(u=Be,bo(a.type)?(a=Vb,Vb=null,Be=a):Be=u):Be=Gn?ur(a.stateNode.nextSibling):null;return!0}function ca(){Be=Gn=null,le=!1}function xy(){var a=no;return a!==null&&(Ns===null?Ns=a:Ns.push.apply(Ns,a),no=null),a}function Su(a){no===null?no=[a]:no.push(a)}var vy=F(null),ua=null,ki=null;function ro(a,u,f){Q(vy,u._currentValue),u._currentValue=f}function $i(a){a._currentValue=vy.current,B(vy)}function wy(a,u,f){for(;a!==null;){var g=a.alternate;if((a.childLanes&u)!==u?(a.childLanes|=u,g!==null&&(g.childLanes|=u)):g!==null&&(g.childLanes&u)!==u&&(g.childLanes|=u),a===f)break;a=a.return}}function Sy(a,u,f,g){var v=a.child;for(v!==null&&(v.return=a);v!==null;){var C=v.dependencies;if(C!==null){var I=v.child;C=C.firstContext;t:for(;C!==null;){var M=C;C=v;for(var j=0;j<u.length;j++)if(M.context===u[j]){C.lanes|=f,M=C.alternate,M!==null&&(M.lanes|=f),wy(C.return,f,a),g||(I=null);break t}C=M.next}}else if(v.tag===18){if(I=v.return,I===null)throw Error(s(341));I.lanes|=f,C=I.alternate,C!==null&&(C.lanes|=f),wy(I,f,a),I=null}else I=v.child;if(I!==null)I.return=v;else for(I=v;I!==null;){if(I===a){I=null;break}if(v=I.sibling,v!==null){v.return=I.return,I=v;break}I=I.return}v=I}}function Ol(a,u,f,g){a=null;for(var v=u,C=!1;v!==null;){if(!C){if((v.flags&524288)!==0)C=!0;else if((v.flags&262144)!==0)break}if(v.tag===10){var I=v.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var M=v.type;Bs(v.pendingProps.value,I.value)||(a!==null?a.push(M):a=[M])}}else if(v===vt.current){if(I=v.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==v.memoizedState.memoizedState&&(a!==null?a.push(Xu):a=[Xu])}v=v.return}a!==null&&Sy(u,a,f,g),u.flags|=262144}function Uf(a){for(a=a.firstContext;a!==null;){if(!Bs(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function ha(a){ua=a,ki=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function Wn(a){return zT(ua,a)}function jf(a,u){return ua===null&&ha(a),zT(a,u)}function zT(a,u){var f=u._currentValue;if(u={context:u,memoizedValue:f,next:null},ki===null){if(a===null)throw Error(s(308));ki=u,a.dependencies={lanes:0,firstContext:u},a.flags|=524288}else ki=ki.next=u;return f}var rz=typeof AbortController<"u"?AbortController:function(){var a=[],u=this.signal={aborted:!1,addEventListener:function(f,g){a.push(g)}};this.abort=function(){u.aborted=!0,a.forEach(function(f){return f()})}},iz=n.unstable_scheduleCallback,oz=n.unstable_NormalPriority,fn={$$typeof:k,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Cy(){return{controller:new rz,data:new Map,refCount:0}}function Cu(a){a.refCount--,a.refCount===0&&iz(oz,function(){a.controller.abort()})}var Tu=null,Ty=0,Ml=0,Fl=null;function az(a,u){if(Tu===null){var f=Tu=[];Ty=0,Ml=Eb(),Fl={status:"pending",value:void 0,then:function(g){f.push(g)}}}return Ty++,u.then(BT,BT),u}function BT(){if(--Ty===0&&Tu!==null){Fl!==null&&(Fl.status="fulfilled");var a=Tu;Tu=null,Ml=0,Fl=null;for(var u=0;u<a.length;u++)(0,a[u])()}}function lz(a,u){var f=[],g={status:"pending",value:null,reason:null,then:function(v){f.push(v)}};return a.then(function(){g.status="fulfilled",g.value=u;for(var v=0;v<f.length;v++)(0,f[v])(u)},function(v){for(g.status="rejected",g.reason=v,v=0;v<f.length;v++)(0,f[v])(void 0)}),g}var VT=P.S;P.S=function(a,u){T2=me(),typeof u=="object"&&u!==null&&typeof u.then=="function"&&az(a,u),VT!==null&&VT(a,u)};var da=F(null);function ky(){var a=da.current;return a!==null?a:Oe.pooledCache}function Gf(a,u){u===null?Q(da,da.current):Q(da,u.pool)}function UT(){var a=ky();return a===null?null:{parent:fn._currentValue,pool:a}}var Ll=Error(s(460)),$y=Error(s(474)),Wf=Error(s(542)),Hf={then:function(){}};function jT(a){return a=a.status,a==="fulfilled"||a==="rejected"}function GT(a,u,f){switch(f=a[f],f===void 0?a.push(u):f!==u&&(u.then(wi,wi),u=f),u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,HT(a),a;default:if(typeof u.status=="string")u.then(wi,wi);else{if(a=Oe,a!==null&&100<a.shellSuspendCounter)throw Error(s(482));a=u,a.status="pending",a.then(function(g){if(u.status==="pending"){var v=u;v.status="fulfilled",v.value=g}},function(g){if(u.status==="pending"){var v=u;v.status="rejected",v.reason=g}})}switch(u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,HT(a),a}throw pa=u,Ll}}function fa(a){try{var u=a._init;return u(a._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(pa=f,Ll):f}}var pa=null;function WT(){if(pa===null)throw Error(s(459));var a=pa;return pa=null,a}function HT(a){if(a===Ll||a===Wf)throw Error(s(483))}var Pl=null,ku=0;function qf(a){var u=ku;return ku+=1,Pl===null&&(Pl=[]),GT(Pl,a,u)}function $u(a,u){u=u.props.ref,a.ref=u!==void 0?u:null}function Kf(a,u){throw u.$$typeof===m?Error(s(525)):(a=Object.prototype.toString.call(u),Error(s(31,a==="[object Object]"?"object with keys {"+Object.keys(u).join(", ")+"}":a)))}function qT(a){function u(st,K){if(a){var ot=st.deletions;ot===null?(st.deletions=[K],st.flags|=16):ot.push(K)}}function f(st,K){if(!a)return null;for(;K!==null;)u(st,K),K=K.sibling;return null}function g(st){for(var K=new Map;st!==null;)st.key!==null?K.set(st.key,st):K.set(st.index,st),st=st.sibling;return K}function v(st,K){return st=Ci(st,K),st.index=0,st.sibling=null,st}function C(st,K,ot){return st.index=ot,a?(ot=st.alternate,ot!==null?(ot=ot.index,ot<K?(st.flags|=67108866,K):ot):(st.flags|=67108866,K)):(st.flags|=1048576,K)}function I(st){return a&&st.alternate===null&&(st.flags|=67108866),st}function M(st,K,ot,yt){return K===null||K.tag!==6?(K=py(ot,st.mode,yt),K.return=st,K):(K=v(K,ot),K.return=st,K)}function j(st,K,ot,yt){var Ft=ot.type;return Ft===x?mt(st,K,ot.props.children,yt,ot.key):K!==null&&(K.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===R&&fa(Ft)===K.type)?(K=v(K,ot.props),$u(K,ot),K.return=st,K):(K=Bf(ot.type,ot.key,ot.props,null,st.mode,yt),$u(K,ot),K.return=st,K)}function at(st,K,ot,yt){return K===null||K.tag!==4||K.stateNode.containerInfo!==ot.containerInfo||K.stateNode.implementation!==ot.implementation?(K=my(ot,st.mode,yt),K.return=st,K):(K=v(K,ot.children||[]),K.return=st,K)}function mt(st,K,ot,yt,Ft){return K===null||K.tag!==7?(K=la(ot,st.mode,yt,Ft),K.return=st,K):(K=v(K,ot),K.return=st,K)}function bt(st,K,ot){if(typeof K=="string"&&K!==""||typeof K=="number"||typeof K=="bigint")return K=py(""+K,st.mode,ot),K.return=st,K;if(typeof K=="object"&&K!==null){switch(K.$$typeof){case y:return ot=Bf(K.type,K.key,K.props,null,st.mode,ot),$u(ot,K),ot.return=st,ot;case b:return K=my(K,st.mode,ot),K.return=st,K;case R:return K=fa(K),bt(st,K,ot)}if(X(K)||z(K))return K=la(K,st.mode,ot,null),K.return=st,K;if(typeof K.then=="function")return bt(st,qf(K),ot);if(K.$$typeof===k)return bt(st,jf(st,K),ot);Kf(st,K)}return null}function ut(st,K,ot,yt){var Ft=K!==null?K.key:null;if(typeof ot=="string"&&ot!==""||typeof ot=="number"||typeof ot=="bigint")return Ft!==null?null:M(st,K,""+ot,yt);if(typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case y:return ot.key===Ft?j(st,K,ot,yt):null;case b:return ot.key===Ft?at(st,K,ot,yt):null;case R:return ot=fa(ot),ut(st,K,ot,yt)}if(X(ot)||z(ot))return Ft!==null?null:mt(st,K,ot,yt,null);if(typeof ot.then=="function")return ut(st,K,qf(ot),yt);if(ot.$$typeof===k)return ut(st,K,jf(st,ot),yt);Kf(st,ot)}return null}function ht(st,K,ot,yt,Ft){if(typeof yt=="string"&&yt!==""||typeof yt=="number"||typeof yt=="bigint")return st=st.get(ot)||null,M(K,st,""+yt,Ft);if(typeof yt=="object"&&yt!==null){switch(yt.$$typeof){case y:return st=st.get(yt.key===null?ot:yt.key)||null,j(K,st,yt,Ft);case b:return st=st.get(yt.key===null?ot:yt.key)||null,at(K,st,yt,Ft);case R:return yt=fa(yt),ht(st,K,ot,yt,Ft)}if(X(yt)||z(yt))return st=st.get(ot)||null,mt(K,st,yt,Ft,null);if(typeof yt.then=="function")return ht(st,K,ot,qf(yt),Ft);if(yt.$$typeof===k)return ht(st,K,ot,jf(K,yt),Ft);Kf(K,yt)}return null}function It(st,K,ot,yt){for(var Ft=null,ye=null,_t=K,Yt=K=0,oe=null;_t!==null&&Yt<ot.length;Yt++){_t.index>Yt?(oe=_t,_t=null):oe=_t.sibling;var be=ut(st,_t,ot[Yt],yt);if(be===null){_t===null&&(_t=oe);break}a&&_t&&be.alternate===null&&u(st,_t),K=C(be,K,Yt),ye===null?Ft=be:ye.sibling=be,ye=be,_t=oe}if(Yt===ot.length)return f(st,_t),le&&Ti(st,Yt),Ft;if(_t===null){for(;Yt<ot.length;Yt++)_t=bt(st,ot[Yt],yt),_t!==null&&(K=C(_t,K,Yt),ye===null?Ft=_t:ye.sibling=_t,ye=_t);return le&&Ti(st,Yt),Ft}for(_t=g(_t);Yt<ot.length;Yt++)oe=ht(_t,st,Yt,ot[Yt],yt),oe!==null&&(a&&oe.alternate!==null&&_t.delete(oe.key===null?Yt:oe.key),K=C(oe,K,Yt),ye===null?Ft=oe:ye.sibling=oe,ye=oe);return a&&_t.forEach(function(Co){return u(st,Co)}),le&&Ti(st,Yt),Ft}function zt(st,K,ot,yt){if(ot==null)throw Error(s(151));for(var Ft=null,ye=null,_t=K,Yt=K=0,oe=null,be=ot.next();_t!==null&&!be.done;Yt++,be=ot.next()){_t.index>Yt?(oe=_t,_t=null):oe=_t.sibling;var Co=ut(st,_t,be.value,yt);if(Co===null){_t===null&&(_t=oe);break}a&&_t&&Co.alternate===null&&u(st,_t),K=C(Co,K,Yt),ye===null?Ft=Co:ye.sibling=Co,ye=Co,_t=oe}if(be.done)return f(st,_t),le&&Ti(st,Yt),Ft;if(_t===null){for(;!be.done;Yt++,be=ot.next())be=bt(st,be.value,yt),be!==null&&(K=C(be,K,Yt),ye===null?Ft=be:ye.sibling=be,ye=be);return le&&Ti(st,Yt),Ft}for(_t=g(_t);!be.done;Yt++,be=ot.next())be=ht(_t,st,Yt,be.value,yt),be!==null&&(a&&be.alternate!==null&&_t.delete(be.key===null?Yt:be.key),K=C(be,K,Yt),ye===null?Ft=be:ye.sibling=be,ye=be);return a&&_t.forEach(function(xB){return u(st,xB)}),le&&Ti(st,Yt),Ft}function Re(st,K,ot,yt){if(typeof ot=="object"&&ot!==null&&ot.type===x&&ot.key===null&&(ot=ot.props.children),typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case y:t:{for(var Ft=ot.key;K!==null;){if(K.key===Ft){if(Ft=ot.type,Ft===x){if(K.tag===7){f(st,K.sibling),yt=v(K,ot.props.children),yt.return=st,st=yt;break t}}else if(K.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===R&&fa(Ft)===K.type){f(st,K.sibling),yt=v(K,ot.props),$u(yt,ot),yt.return=st,st=yt;break t}f(st,K);break}else u(st,K);K=K.sibling}ot.type===x?(yt=la(ot.props.children,st.mode,yt,ot.key),yt.return=st,st=yt):(yt=Bf(ot.type,ot.key,ot.props,null,st.mode,yt),$u(yt,ot),yt.return=st,st=yt)}return I(st);case b:t:{for(Ft=ot.key;K!==null;){if(K.key===Ft)if(K.tag===4&&K.stateNode.containerInfo===ot.containerInfo&&K.stateNode.implementation===ot.implementation){f(st,K.sibling),yt=v(K,ot.children||[]),yt.return=st,st=yt;break t}else{f(st,K);break}else u(st,K);K=K.sibling}yt=my(ot,st.mode,yt),yt.return=st,st=yt}return I(st);case R:return ot=fa(ot),Re(st,K,ot,yt)}if(X(ot))return It(st,K,ot,yt);if(z(ot)){if(Ft=z(ot),typeof Ft!="function")throw Error(s(150));return ot=Ft.call(ot),zt(st,K,ot,yt)}if(typeof ot.then=="function")return Re(st,K,qf(ot),yt);if(ot.$$typeof===k)return Re(st,K,jf(st,ot),yt);Kf(st,ot)}return typeof ot=="string"&&ot!==""||typeof ot=="number"||typeof ot=="bigint"?(ot=""+ot,K!==null&&K.tag===6?(f(st,K.sibling),yt=v(K,ot),yt.return=st,st=yt):(f(st,K),yt=py(ot,st.mode,yt),yt.return=st,st=yt),I(st)):f(st,K)}return function(st,K,ot,yt){try{ku=0;var Ft=Re(st,K,ot,yt);return Pl=null,Ft}catch(_t){if(_t===Ll||_t===Wf)throw _t;var ye=Vs(29,_t,null,st.mode);return ye.lanes=yt,ye.return=st,ye}}}var ma=qT(!0),KT=qT(!1),io=!1;function Ey(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Iy(a,u){a=a.updateQueue,u.updateQueue===a&&(u.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function oo(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function ao(a,u,f){var g=a.updateQueue;if(g===null)return null;if(g=g.shared,(Se&2)!==0){var v=g.pending;return v===null?u.next=u:(u.next=v.next,v.next=u),g.pending=u,u=zf(a),_T(a,null,f),u}return Pf(a,g,u,f),zf(a)}function Eu(a,u,f){if(u=u.updateQueue,u!==null&&(u=u.shared,(f&4194048)!==0)){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,zC(a,f)}}function Ny(a,u){var f=a.updateQueue,g=a.alternate;if(g!==null&&(g=g.updateQueue,f===g)){var v=null,C=null;if(f=f.firstBaseUpdate,f!==null){do{var I={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};C===null?v=C=I:C=C.next=I,f=f.next}while(f!==null);C===null?v=C=u:C=C.next=u}else v=C=u;f={baseState:g.baseState,firstBaseUpdate:v,lastBaseUpdate:C,shared:g.shared,callbacks:g.callbacks},a.updateQueue=f;return}a=f.lastBaseUpdate,a===null?f.firstBaseUpdate=u:a.next=u,f.lastBaseUpdate=u}var Ay=!1;function Iu(){if(Ay){var a=Fl;if(a!==null)throw a}}function Nu(a,u,f,g){Ay=!1;var v=a.updateQueue;io=!1;var C=v.firstBaseUpdate,I=v.lastBaseUpdate,M=v.shared.pending;if(M!==null){v.shared.pending=null;var j=M,at=j.next;j.next=null,I===null?C=at:I.next=at,I=j;var mt=a.alternate;mt!==null&&(mt=mt.updateQueue,M=mt.lastBaseUpdate,M!==I&&(M===null?mt.firstBaseUpdate=at:M.next=at,mt.lastBaseUpdate=j))}if(C!==null){var bt=v.baseState;I=0,mt=at=j=null,M=C;do{var ut=M.lane&-536870913,ht=ut!==M.lane;if(ht?(ie&ut)===ut:(g&ut)===ut){ut!==0&&ut===Ml&&(Ay=!0),mt!==null&&(mt=mt.next={lane:0,tag:M.tag,payload:M.payload,callback:null,next:null});t:{var It=a,zt=M;ut=u;var Re=f;switch(zt.tag){case 1:if(It=zt.payload,typeof It=="function"){bt=It.call(Re,bt,ut);break t}bt=It;break t;case 3:It.flags=It.flags&-65537|128;case 0:if(It=zt.payload,ut=typeof It=="function"?It.call(Re,bt,ut):It,ut==null)break t;bt=p({},bt,ut);break t;case 2:io=!0}}ut=M.callback,ut!==null&&(a.flags|=64,ht&&(a.flags|=8192),ht=v.callbacks,ht===null?v.callbacks=[ut]:ht.push(ut))}else ht={lane:ut,tag:M.tag,payload:M.payload,callback:M.callback,next:null},mt===null?(at=mt=ht,j=bt):mt=mt.next=ht,I|=ut;if(M=M.next,M===null){if(M=v.shared.pending,M===null)break;ht=M,M=ht.next,ht.next=null,v.lastBaseUpdate=ht,v.shared.pending=null}}while(!0);mt===null&&(j=bt),v.baseState=j,v.firstBaseUpdate=at,v.lastBaseUpdate=mt,C===null&&(v.shared.lanes=0),fo|=I,a.lanes=I,a.memoizedState=bt}}function XT(a,u){if(typeof a!="function")throw Error(s(191,a));a.call(u)}function YT(a,u){var f=a.callbacks;if(f!==null)for(a.callbacks=null,a=0;a<f.length;a++)XT(f[a],u)}var zl=F(null),Xf=F(0);function ZT(a,u){a=Mi,Q(Xf,a),Q(zl,u),Mi=a|u.baseLanes}function _y(){Q(Xf,Mi),Q(zl,zl.current)}function Ry(){Mi=Xf.current,B(zl),B(Xf)}var Us=F(null),cr=null;function lo(a){var u=a.alternate;Q(ln,ln.current&1),Q(Us,a),cr===null&&(u===null||zl.current!==null||u.memoizedState!==null)&&(cr=a)}function Dy(a){Q(ln,ln.current),Q(Us,a),cr===null&&(cr=a)}function JT(a){a.tag===22?(Q(ln,ln.current),Q(Us,a),cr===null&&(cr=a)):co()}function co(){Q(ln,ln.current),Q(Us,Us.current)}function js(a){B(Us),cr===a&&(cr=null),B(ln)}var ln=F(0);function Yf(a){for(var u=a;u!==null;){if(u.tag===13){var f=u.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||zb(f)||Bb(f)))return u}else if(u.tag===19&&(u.memoizedProps.revealOrder==="forwards"||u.memoizedProps.revealOrder==="backwards"||u.memoizedProps.revealOrder==="unstable_legacy-backwards"||u.memoizedProps.revealOrder==="together")){if((u.flags&128)!==0)return u}else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return null;u=u.return}u.sibling.return=u.return,u=u.sibling}return null}var Ei=0,Kt=null,Ae=null,pn=null,Zf=!1,Bl=!1,ga=!1,Jf=0,Au=0,Vl=null,cz=0;function Ye(){throw Error(s(321))}function Oy(a,u){if(u===null)return!1;for(var f=0;f<u.length&&f<a.length;f++)if(!Bs(a[f],u[f]))return!1;return!0}function My(a,u,f,g,v,C){return Ei=C,Kt=u,u.memoizedState=null,u.updateQueue=null,u.lanes=0,P.H=a===null||a.memoizedState===null?Mk:Yy,ga=!1,C=f(g,v),ga=!1,Bl&&(C=tk(u,f,g,v)),QT(a),C}function QT(a){P.H=Du;var u=Ae!==null&&Ae.next!==null;if(Ei=0,pn=Ae=Kt=null,Zf=!1,Au=0,Vl=null,u)throw Error(s(300));a===null||mn||(a=a.dependencies,a!==null&&Uf(a)&&(mn=!0))}function tk(a,u,f,g){Kt=a;var v=0;do{if(Bl&&(Vl=null),Au=0,Bl=!1,25<=v)throw Error(s(301));if(v+=1,pn=Ae=null,a.updateQueue!=null){var C=a.updateQueue;C.lastEffect=null,C.events=null,C.stores=null,C.memoCache!=null&&(C.memoCache.index=0)}P.H=Fk,C=u(f,g)}while(Bl);return C}function uz(){var a=P.H,u=a.useState()[0];return u=typeof u.then=="function"?_u(u):u,a=a.useState()[0],(Ae!==null?Ae.memoizedState:null)!==a&&(Kt.flags|=1024),u}function Fy(){var a=Jf!==0;return Jf=0,a}function Ly(a,u,f){u.updateQueue=a.updateQueue,u.flags&=-2053,a.lanes&=~f}function Py(a){if(Zf){for(a=a.memoizedState;a!==null;){var u=a.queue;u!==null&&(u.pending=null),a=a.next}Zf=!1}Ei=0,pn=Ae=Kt=null,Bl=!1,Au=Jf=0,Vl=null}function ps(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return pn===null?Kt.memoizedState=pn=a:pn=pn.next=a,pn}function cn(){if(Ae===null){var a=Kt.alternate;a=a!==null?a.memoizedState:null}else a=Ae.next;var u=pn===null?Kt.memoizedState:pn.next;if(u!==null)pn=u,Ae=a;else{if(a===null)throw Kt.alternate===null?Error(s(467)):Error(s(310));Ae=a,a={memoizedState:Ae.memoizedState,baseState:Ae.baseState,baseQueue:Ae.baseQueue,queue:Ae.queue,next:null},pn===null?Kt.memoizedState=pn=a:pn=pn.next=a}return pn}function Qf(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function _u(a){var u=Au;return Au+=1,Vl===null&&(Vl=[]),a=GT(Vl,a,u),u=Kt,(pn===null?u.memoizedState:pn.next)===null&&(u=u.alternate,P.H=u===null||u.memoizedState===null?Mk:Yy),a}function tp(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return _u(a);if(a.$$typeof===k)return Wn(a)}throw Error(s(438,String(a)))}function zy(a){var u=null,f=Kt.updateQueue;if(f!==null&&(u=f.memoCache),u==null){var g=Kt.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(u={data:g.data.map(function(v){return v.slice()}),index:0})))}if(u==null&&(u={data:[],index:0}),f===null&&(f=Qf(),Kt.updateQueue=f),f.memoCache=u,f=u.data[u.index],f===void 0)for(f=u.data[u.index]=Array(a),g=0;g<a;g++)f[g]=O;return u.index++,f}function Ii(a,u){return typeof u=="function"?u(a):u}function ep(a){var u=cn();return By(u,Ae,a)}function By(a,u,f){var g=a.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=f;var v=a.baseQueue,C=g.pending;if(C!==null){if(v!==null){var I=v.next;v.next=C.next,C.next=I}u.baseQueue=v=C,g.pending=null}if(C=a.baseState,v===null)a.memoizedState=C;else{u=v.next;var M=I=null,j=null,at=u,mt=!1;do{var bt=at.lane&-536870913;if(bt!==at.lane?(ie&bt)===bt:(Ei&bt)===bt){var ut=at.revertLane;if(ut===0)j!==null&&(j=j.next={lane:0,revertLane:0,gesture:null,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null}),bt===Ml&&(mt=!0);else if((Ei&ut)===ut){at=at.next,ut===Ml&&(mt=!0);continue}else bt={lane:0,revertLane:at.revertLane,gesture:null,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null},j===null?(M=j=bt,I=C):j=j.next=bt,Kt.lanes|=ut,fo|=ut;bt=at.action,ga&&f(C,bt),C=at.hasEagerState?at.eagerState:f(C,bt)}else ut={lane:bt,revertLane:at.revertLane,gesture:at.gesture,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null},j===null?(M=j=ut,I=C):j=j.next=ut,Kt.lanes|=bt,fo|=bt;at=at.next}while(at!==null&&at!==u);if(j===null?I=C:j.next=M,!Bs(C,a.memoizedState)&&(mn=!0,mt&&(f=Fl,f!==null)))throw f;a.memoizedState=C,a.baseState=I,a.baseQueue=j,g.lastRenderedState=C}return v===null&&(g.lanes=0),[a.memoizedState,g.dispatch]}function Vy(a){var u=cn(),f=u.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=a;var g=f.dispatch,v=f.pending,C=u.memoizedState;if(v!==null){f.pending=null;var I=v=v.next;do C=a(C,I.action),I=I.next;while(I!==v);Bs(C,u.memoizedState)||(mn=!0),u.memoizedState=C,u.baseQueue===null&&(u.baseState=C),f.lastRenderedState=C}return[C,g]}function ek(a,u,f){var g=Kt,v=cn(),C=le;if(C){if(f===void 0)throw Error(s(407));f=f()}else f=u();var I=!Bs((Ae||v).memoizedState,f);if(I&&(v.memoizedState=f,mn=!0),v=v.queue,Gy(rk.bind(null,g,v,a),[a]),v.getSnapshot!==u||I||pn!==null&&pn.memoizedState.tag&1){if(g.flags|=2048,Ul(9,{destroy:void 0},sk.bind(null,g,v,f,u),null),Oe===null)throw Error(s(349));C||(Ei&127)!==0||nk(g,u,f)}return f}function nk(a,u,f){a.flags|=16384,a={getSnapshot:u,value:f},u=Kt.updateQueue,u===null?(u=Qf(),Kt.updateQueue=u,u.stores=[a]):(f=u.stores,f===null?u.stores=[a]:f.push(a))}function sk(a,u,f,g){u.value=f,u.getSnapshot=g,ik(u)&&ok(a)}function rk(a,u,f){return f(function(){ik(u)&&ok(a)})}function ik(a){var u=a.getSnapshot;a=a.value;try{var f=u();return!Bs(a,f)}catch{return!0}}function ok(a){var u=aa(a,2);u!==null&&As(u,a,2)}function Uy(a){var u=ps();if(typeof a=="function"){var f=a;if(a=f(),ga){Xr(!0);try{f()}finally{Xr(!1)}}}return u.memoizedState=u.baseState=a,u.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ii,lastRenderedState:a},u}function ak(a,u,f,g){return a.baseState=f,By(a,Ae,typeof g=="function"?g:Ii)}function hz(a,u,f,g,v){if(rp(a))throw Error(s(485));if(a=u.action,a!==null){var C={payload:v,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){C.listeners.push(I)}};P.T!==null?f(!0):C.isTransition=!1,g(C),f=u.pending,f===null?(C.next=u.pending=C,lk(u,C)):(C.next=f.next,u.pending=f.next=C)}}function lk(a,u){var f=u.action,g=u.payload,v=a.state;if(u.isTransition){var C=P.T,I={};P.T=I;try{var M=f(v,g),j=P.S;j!==null&&j(I,M),ck(a,u,M)}catch(at){jy(a,u,at)}finally{C!==null&&I.types!==null&&(C.types=I.types),P.T=C}}else try{C=f(v,g),ck(a,u,C)}catch(at){jy(a,u,at)}}function ck(a,u,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(g){uk(a,u,g)},function(g){return jy(a,u,g)}):uk(a,u,f)}function uk(a,u,f){u.status="fulfilled",u.value=f,hk(u),a.state=f,u=a.pending,u!==null&&(f=u.next,f===u?a.pending=null:(f=f.next,u.next=f,lk(a,f)))}function jy(a,u,f){var g=a.pending;if(a.pending=null,g!==null){g=g.next;do u.status="rejected",u.reason=f,hk(u),u=u.next;while(u!==g)}a.action=null}function hk(a){a=a.listeners;for(var u=0;u<a.length;u++)(0,a[u])()}function dk(a,u){return u}function fk(a,u){if(le){var f=Oe.formState;if(f!==null){t:{var g=Kt;if(le){if(Be){e:{for(var v=Be,C=lr;v.nodeType!==8;){if(!C){v=null;break e}if(v=ur(v.nextSibling),v===null){v=null;break e}}C=v.data,v=C==="F!"||C==="F"?v:null}if(v){Be=ur(v.nextSibling),g=v.data==="F!";break t}}so(g)}g=!1}g&&(u=f[0])}}return f=ps(),f.memoizedState=f.baseState=u,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:dk,lastRenderedState:u},f.queue=g,f=Rk.bind(null,Kt,g),g.dispatch=f,g=Uy(!1),C=Xy.bind(null,Kt,!1,g.queue),g=ps(),v={state:u,dispatch:null,action:a,pending:null},g.queue=v,f=hz.bind(null,Kt,v,C,f),v.dispatch=f,g.memoizedState=a,[u,f,!1]}function pk(a){var u=cn();return mk(u,Ae,a)}function mk(a,u,f){if(u=By(a,u,dk)[0],a=ep(Ii)[0],typeof u=="object"&&u!==null&&typeof u.then=="function")try{var g=_u(u)}catch(I){throw I===Ll?Wf:I}else g=u;u=cn();var v=u.queue,C=v.dispatch;return f!==u.memoizedState&&(Kt.flags|=2048,Ul(9,{destroy:void 0},dz.bind(null,v,f),null)),[g,C,a]}function dz(a,u){a.action=u}function gk(a){var u=cn(),f=Ae;if(f!==null)return mk(u,f,a);cn(),u=u.memoizedState,f=cn();var g=f.queue.dispatch;return f.memoizedState=a,[u,g,!1]}function Ul(a,u,f,g){return a={tag:a,create:f,deps:g,inst:u,next:null},u=Kt.updateQueue,u===null&&(u=Qf(),Kt.updateQueue=u),f=u.lastEffect,f===null?u.lastEffect=a.next=a:(g=f.next,f.next=a,a.next=g,u.lastEffect=a),a}function yk(){return cn().memoizedState}function np(a,u,f,g){var v=ps();Kt.flags|=a,v.memoizedState=Ul(1|u,{destroy:void 0},f,g===void 0?null:g)}function sp(a,u,f,g){var v=cn();g=g===void 0?null:g;var C=v.memoizedState.inst;Ae!==null&&g!==null&&Oy(g,Ae.memoizedState.deps)?v.memoizedState=Ul(u,C,f,g):(Kt.flags|=a,v.memoizedState=Ul(1|u,C,f,g))}function bk(a,u){np(8390656,8,a,u)}function Gy(a,u){sp(2048,8,a,u)}function fz(a){Kt.flags|=4;var u=Kt.updateQueue;if(u===null)u=Qf(),Kt.updateQueue=u,u.events=[a];else{var f=u.events;f===null?u.events=[a]:f.push(a)}}function xk(a){var u=cn().memoizedState;return fz({ref:u,nextImpl:a}),function(){if((Se&2)!==0)throw Error(s(440));return u.impl.apply(void 0,arguments)}}function vk(a,u){return sp(4,2,a,u)}function wk(a,u){return sp(4,4,a,u)}function Sk(a,u){if(typeof u=="function"){a=a();var f=u(a);return function(){typeof f=="function"?f():u(null)}}if(u!=null)return a=a(),u.current=a,function(){u.current=null}}function Ck(a,u,f){f=f!=null?f.concat([a]):null,sp(4,4,Sk.bind(null,u,a),f)}function Wy(){}function Tk(a,u){var f=cn();u=u===void 0?null:u;var g=f.memoizedState;return u!==null&&Oy(u,g[1])?g[0]:(f.memoizedState=[a,u],a)}function kk(a,u){var f=cn();u=u===void 0?null:u;var g=f.memoizedState;if(u!==null&&Oy(u,g[1]))return g[0];if(g=a(),ga){Xr(!0);try{a()}finally{Xr(!1)}}return f.memoizedState=[g,u],g}function Hy(a,u,f){return f===void 0||(Ei&1073741824)!==0&&(ie&261930)===0?a.memoizedState=u:(a.memoizedState=f,a=$2(),Kt.lanes|=a,fo|=a,f)}function $k(a,u,f,g){return Bs(f,u)?f:zl.current!==null?(a=Hy(a,f,g),Bs(a,u)||(mn=!0),a):(Ei&42)===0||(Ei&1073741824)!==0&&(ie&261930)===0?(mn=!0,a.memoizedState=f):(a=$2(),Kt.lanes|=a,fo|=a,u)}function Ek(a,u,f,g,v){var C=V.p;V.p=C!==0&&8>C?C:8;var I=P.T,M={};P.T=M,Xy(a,!1,u,f);try{var j=v(),at=P.S;if(at!==null&&at(M,j),j!==null&&typeof j=="object"&&typeof j.then=="function"){var mt=lz(j,g);Ru(a,u,mt,Hs(a))}else Ru(a,u,g,Hs(a))}catch(bt){Ru(a,u,{then:function(){},status:"rejected",reason:bt},Hs())}finally{V.p=C,I!==null&&M.types!==null&&(I.types=M.types),P.T=I}}function pz(){}function qy(a,u,f,g){if(a.tag!==5)throw Error(s(476));var v=Ik(a).queue;Ek(a,v,u,G,f===null?pz:function(){return Nk(a),f(g)})}function Ik(a){var u=a.memoizedState;if(u!==null)return u;u={memoizedState:G,baseState:G,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ii,lastRenderedState:G},next:null};var f={};return u.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ii,lastRenderedState:f},next:null},a.memoizedState=u,a=a.alternate,a!==null&&(a.memoizedState=u),u}function Nk(a){var u=Ik(a);u.next===null&&(u=a.alternate.memoizedState),Ru(a,u.next.queue,{},Hs())}function Ky(){return Wn(Xu)}function Ak(){return cn().memoizedState}function _k(){return cn().memoizedState}function mz(a){for(var u=a.return;u!==null;){switch(u.tag){case 24:case 3:var f=Hs();a=oo(f);var g=ao(u,a,f);g!==null&&(As(g,u,f),Eu(g,u,f)),u={cache:Cy()},a.payload=u;return}u=u.return}}function gz(a,u,f){var g=Hs();f={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},rp(a)?Dk(u,f):(f=dy(a,u,f,g),f!==null&&(As(f,a,g),Ok(f,u,g)))}function Rk(a,u,f){var g=Hs();Ru(a,u,f,g)}function Ru(a,u,f,g){var v={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(rp(a))Dk(u,v);else{var C=a.alternate;if(a.lanes===0&&(C===null||C.lanes===0)&&(C=u.lastRenderedReducer,C!==null))try{var I=u.lastRenderedState,M=C(I,f);if(v.hasEagerState=!0,v.eagerState=M,Bs(M,I))return Pf(a,u,v,0),Oe===null&&Lf(),!1}catch{}if(f=dy(a,u,v,g),f!==null)return As(f,a,g),Ok(f,u,g),!0}return!1}function Xy(a,u,f,g){if(g={lane:2,revertLane:Eb(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},rp(a)){if(u)throw Error(s(479))}else u=dy(a,f,g,2),u!==null&&As(u,a,2)}function rp(a){var u=a.alternate;return a===Kt||u!==null&&u===Kt}function Dk(a,u){Bl=Zf=!0;var f=a.pending;f===null?u.next=u:(u.next=f.next,f.next=u),a.pending=u}function Ok(a,u,f){if((f&4194048)!==0){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,zC(a,f)}}var Du={readContext:Wn,use:tp,useCallback:Ye,useContext:Ye,useEffect:Ye,useImperativeHandle:Ye,useLayoutEffect:Ye,useInsertionEffect:Ye,useMemo:Ye,useReducer:Ye,useRef:Ye,useState:Ye,useDebugValue:Ye,useDeferredValue:Ye,useTransition:Ye,useSyncExternalStore:Ye,useId:Ye,useHostTransitionStatus:Ye,useFormState:Ye,useActionState:Ye,useOptimistic:Ye,useMemoCache:Ye,useCacheRefresh:Ye};Du.useEffectEvent=Ye;var Mk={readContext:Wn,use:tp,useCallback:function(a,u){return ps().memoizedState=[a,u===void 0?null:u],a},useContext:Wn,useEffect:bk,useImperativeHandle:function(a,u,f){f=f!=null?f.concat([a]):null,np(4194308,4,Sk.bind(null,u,a),f)},useLayoutEffect:function(a,u){return np(4194308,4,a,u)},useInsertionEffect:function(a,u){np(4,2,a,u)},useMemo:function(a,u){var f=ps();u=u===void 0?null:u;var g=a();if(ga){Xr(!0);try{a()}finally{Xr(!1)}}return f.memoizedState=[g,u],g},useReducer:function(a,u,f){var g=ps();if(f!==void 0){var v=f(u);if(ga){Xr(!0);try{f(u)}finally{Xr(!1)}}}else v=u;return g.memoizedState=g.baseState=v,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:v},g.queue=a,a=a.dispatch=gz.bind(null,Kt,a),[g.memoizedState,a]},useRef:function(a){var u=ps();return a={current:a},u.memoizedState=a},useState:function(a){a=Uy(a);var u=a.queue,f=Rk.bind(null,Kt,u);return u.dispatch=f,[a.memoizedState,f]},useDebugValue:Wy,useDeferredValue:function(a,u){var f=ps();return Hy(f,a,u)},useTransition:function(){var a=Uy(!1);return a=Ek.bind(null,Kt,a.queue,!0,!1),ps().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,u,f){var g=Kt,v=ps();if(le){if(f===void 0)throw Error(s(407));f=f()}else{if(f=u(),Oe===null)throw Error(s(349));(ie&127)!==0||nk(g,u,f)}v.memoizedState=f;var C={value:f,getSnapshot:u};return v.queue=C,bk(rk.bind(null,g,C,a),[a]),g.flags|=2048,Ul(9,{destroy:void 0},sk.bind(null,g,C,f,u),null),f},useId:function(){var a=ps(),u=Oe.identifierPrefix;if(le){var f=Zr,g=Yr;f=(g&~(1<<32-zs(g)-1)).toString(32)+f,u="_"+u+"R_"+f,f=Jf++,0<f&&(u+="H"+f.toString(32)),u+="_"}else f=cz++,u="_"+u+"r_"+f.toString(32)+"_";return a.memoizedState=u},useHostTransitionStatus:Ky,useFormState:fk,useActionState:fk,useOptimistic:function(a){var u=ps();u.memoizedState=u.baseState=a;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return u.queue=f,u=Xy.bind(null,Kt,!0,f),f.dispatch=u,[a,u]},useMemoCache:zy,useCacheRefresh:function(){return ps().memoizedState=mz.bind(null,Kt)},useEffectEvent:function(a){var u=ps(),f={impl:a};return u.memoizedState=f,function(){if((Se&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},Yy={readContext:Wn,use:tp,useCallback:Tk,useContext:Wn,useEffect:Gy,useImperativeHandle:Ck,useInsertionEffect:vk,useLayoutEffect:wk,useMemo:kk,useReducer:ep,useRef:yk,useState:function(){return ep(Ii)},useDebugValue:Wy,useDeferredValue:function(a,u){var f=cn();return $k(f,Ae.memoizedState,a,u)},useTransition:function(){var a=ep(Ii)[0],u=cn().memoizedState;return[typeof a=="boolean"?a:_u(a),u]},useSyncExternalStore:ek,useId:Ak,useHostTransitionStatus:Ky,useFormState:pk,useActionState:pk,useOptimistic:function(a,u){var f=cn();return ak(f,Ae,a,u)},useMemoCache:zy,useCacheRefresh:_k};Yy.useEffectEvent=xk;var Fk={readContext:Wn,use:tp,useCallback:Tk,useContext:Wn,useEffect:Gy,useImperativeHandle:Ck,useInsertionEffect:vk,useLayoutEffect:wk,useMemo:kk,useReducer:Vy,useRef:yk,useState:function(){return Vy(Ii)},useDebugValue:Wy,useDeferredValue:function(a,u){var f=cn();return Ae===null?Hy(f,a,u):$k(f,Ae.memoizedState,a,u)},useTransition:function(){var a=Vy(Ii)[0],u=cn().memoizedState;return[typeof a=="boolean"?a:_u(a),u]},useSyncExternalStore:ek,useId:Ak,useHostTransitionStatus:Ky,useFormState:gk,useActionState:gk,useOptimistic:function(a,u){var f=cn();return Ae!==null?ak(f,Ae,a,u):(f.baseState=a,[a,f.queue.dispatch])},useMemoCache:zy,useCacheRefresh:_k};Fk.useEffectEvent=xk;function Zy(a,u,f,g){u=a.memoizedState,f=f(g,u),f=f==null?u:p({},u,f),a.memoizedState=f,a.lanes===0&&(a.updateQueue.baseState=f)}var Jy={enqueueSetState:function(a,u,f){a=a._reactInternals;var g=Hs(),v=oo(g);v.payload=u,f!=null&&(v.callback=f),u=ao(a,v,g),u!==null&&(As(u,a,g),Eu(u,a,g))},enqueueReplaceState:function(a,u,f){a=a._reactInternals;var g=Hs(),v=oo(g);v.tag=1,v.payload=u,f!=null&&(v.callback=f),u=ao(a,v,g),u!==null&&(As(u,a,g),Eu(u,a,g))},enqueueForceUpdate:function(a,u){a=a._reactInternals;var f=Hs(),g=oo(f);g.tag=2,u!=null&&(g.callback=u),u=ao(a,g,f),u!==null&&(As(u,a,f),Eu(u,a,f))}};function Lk(a,u,f,g,v,C,I){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(g,C,I):u.prototype&&u.prototype.isPureReactComponent?!xu(f,g)||!xu(v,C):!0}function Pk(a,u,f,g){a=u.state,typeof u.componentWillReceiveProps=="function"&&u.componentWillReceiveProps(f,g),typeof u.UNSAFE_componentWillReceiveProps=="function"&&u.UNSAFE_componentWillReceiveProps(f,g),u.state!==a&&Jy.enqueueReplaceState(u,u.state,null)}function ya(a,u){var f=u;if("ref"in u){f={};for(var g in u)g!=="ref"&&(f[g]=u[g])}if(a=a.defaultProps){f===u&&(f=p({},f));for(var v in a)f[v]===void 0&&(f[v]=a[v])}return f}function zk(a){Ff(a)}function Bk(a){console.error(a)}function Vk(a){Ff(a)}function ip(a,u){try{var f=a.onUncaughtError;f(u.value,{componentStack:u.stack})}catch(g){setTimeout(function(){throw g})}}function Uk(a,u,f){try{var g=a.onCaughtError;g(f.value,{componentStack:f.stack,errorBoundary:u.tag===1?u.stateNode:null})}catch(v){setTimeout(function(){throw v})}}function Qy(a,u,f){return f=oo(f),f.tag=3,f.payload={element:null},f.callback=function(){ip(a,u)},f}function jk(a){return a=oo(a),a.tag=3,a}function Gk(a,u,f,g){var v=f.type.getDerivedStateFromError;if(typeof v=="function"){var C=g.value;a.payload=function(){return v(C)},a.callback=function(){Uk(u,f,g)}}var I=f.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(a.callback=function(){Uk(u,f,g),typeof v!="function"&&(po===null?po=new Set([this]):po.add(this));var M=g.stack;this.componentDidCatch(g.value,{componentStack:M!==null?M:""})})}function yz(a,u,f,g,v){if(f.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(u=f.alternate,u!==null&&Ol(u,f,v,!0),f=Us.current,f!==null){switch(f.tag){case 31:case 13:return cr===null?yp():f.alternate===null&&Ze===0&&(Ze=3),f.flags&=-257,f.flags|=65536,f.lanes=v,g===Hf?f.flags|=16384:(u=f.updateQueue,u===null?f.updateQueue=new Set([g]):u.add(g),Tb(a,g,v)),!1;case 22:return f.flags|=65536,g===Hf?f.flags|=16384:(u=f.updateQueue,u===null?(u={transitions:null,markerInstances:null,retryQueue:new Set([g])},f.updateQueue=u):(f=u.retryQueue,f===null?u.retryQueue=new Set([g]):f.add(g)),Tb(a,g,v)),!1}throw Error(s(435,f.tag))}return Tb(a,g,v),yp(),!1}if(le)return u=Us.current,u!==null?((u.flags&65536)===0&&(u.flags|=256),u.flags|=65536,u.lanes=v,g!==by&&(a=Error(s(422),{cause:g}),Su(ir(a,f)))):(g!==by&&(u=Error(s(423),{cause:g}),Su(ir(u,f))),a=a.current.alternate,a.flags|=65536,v&=-v,a.lanes|=v,g=ir(g,f),v=Qy(a.stateNode,g,v),Ny(a,v),Ze!==4&&(Ze=2)),!1;var C=Error(s(520),{cause:g});if(C=ir(C,f),Vu===null?Vu=[C]:Vu.push(C),Ze!==4&&(Ze=2),u===null)return!0;g=ir(g,f),f=u;do{switch(f.tag){case 3:return f.flags|=65536,a=v&-v,f.lanes|=a,a=Qy(f.stateNode,g,a),Ny(f,a),!1;case 1:if(u=f.type,C=f.stateNode,(f.flags&128)===0&&(typeof u.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(po===null||!po.has(C))))return f.flags|=65536,v&=-v,f.lanes|=v,v=jk(v),Gk(v,a,f,g),Ny(f,v),!1}f=f.return}while(f!==null);return!1}var tb=Error(s(461)),mn=!1;function Hn(a,u,f,g){u.child=a===null?KT(u,null,f,g):ma(u,a.child,f,g)}function Wk(a,u,f,g,v){f=f.render;var C=u.ref;if("ref"in g){var I={};for(var M in g)M!=="ref"&&(I[M]=g[M])}else I=g;return ha(u),g=My(a,u,f,I,C,v),M=Fy(),a!==null&&!mn?(Ly(a,u,v),Ni(a,u,v)):(le&&M&&gy(u),u.flags|=1,Hn(a,u,g,v),u.child)}function Hk(a,u,f,g,v){if(a===null){var C=f.type;return typeof C=="function"&&!fy(C)&&C.defaultProps===void 0&&f.compare===null?(u.tag=15,u.type=C,qk(a,u,C,g,v)):(a=Bf(f.type,null,g,u,u.mode,v),a.ref=u.ref,a.return=u,u.child=a)}if(C=a.child,!lb(a,v)){var I=C.memoizedProps;if(f=f.compare,f=f!==null?f:xu,f(I,g)&&a.ref===u.ref)return Ni(a,u,v)}return u.flags|=1,a=Ci(C,g),a.ref=u.ref,a.return=u,u.child=a}function qk(a,u,f,g,v){if(a!==null){var C=a.memoizedProps;if(xu(C,g)&&a.ref===u.ref)if(mn=!1,u.pendingProps=g=C,lb(a,v))(a.flags&131072)!==0&&(mn=!0);else return u.lanes=a.lanes,Ni(a,u,v)}return eb(a,u,f,g,v)}function Kk(a,u,f,g){var v=g.children,C=a!==null?a.memoizedState:null;if(a===null&&u.stateNode===null&&(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((u.flags&128)!==0){if(C=C!==null?C.baseLanes|f:f,a!==null){for(g=u.child=a.child,v=0;g!==null;)v=v|g.lanes|g.childLanes,g=g.sibling;g=v&~C}else g=0,u.child=null;return Xk(a,u,C,f,g)}if((f&536870912)!==0)u.memoizedState={baseLanes:0,cachePool:null},a!==null&&Gf(u,C!==null?C.cachePool:null),C!==null?ZT(u,C):_y(),JT(u);else return g=u.lanes=536870912,Xk(a,u,C!==null?C.baseLanes|f:f,f,g)}else C!==null?(Gf(u,C.cachePool),ZT(u,C),co(),u.memoizedState=null):(a!==null&&Gf(u,null),_y(),co());return Hn(a,u,v,f),u.child}function Ou(a,u){return a!==null&&a.tag===22||u.stateNode!==null||(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),u.sibling}function Xk(a,u,f,g,v){var C=ky();return C=C===null?null:{parent:fn._currentValue,pool:C},u.memoizedState={baseLanes:f,cachePool:C},a!==null&&Gf(u,null),_y(),JT(u),a!==null&&Ol(a,u,g,!0),u.childLanes=v,null}function op(a,u){return u=lp({mode:u.mode,children:u.children},a.mode),u.ref=a.ref,a.child=u,u.return=a,u}function Yk(a,u,f){return ma(u,a.child,null,f),a=op(u,u.pendingProps),a.flags|=2,js(u),u.memoizedState=null,a}function bz(a,u,f){var g=u.pendingProps,v=(u.flags&128)!==0;if(u.flags&=-129,a===null){if(le){if(g.mode==="hidden")return a=op(u,g),u.lanes=536870912,Ou(null,a);if(Dy(u),(a=Be)?(a=l$(a,lr),a=a!==null&&a.data==="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:eo!==null?{id:Yr,overflow:Zr}:null,retryLane:536870912,hydrationErrors:null},f=DT(a),f.return=u,u.child=f,Gn=u,Be=null)):a=null,a===null)throw so(u);return u.lanes=536870912,null}return op(u,g)}var C=a.memoizedState;if(C!==null){var I=C.dehydrated;if(Dy(u),v)if(u.flags&256)u.flags&=-257,u=Yk(a,u,f);else if(u.memoizedState!==null)u.child=a.child,u.flags|=128,u=null;else throw Error(s(558));else if(mn||Ol(a,u,f,!1),v=(f&a.childLanes)!==0,mn||v){if(g=Oe,g!==null&&(I=BC(g,f),I!==0&&I!==C.retryLane))throw C.retryLane=I,aa(a,I),As(g,a,I),tb;yp(),u=Yk(a,u,f)}else a=C.treeContext,Be=ur(I.nextSibling),Gn=u,le=!0,no=null,lr=!1,a!==null&&FT(u,a),u=op(u,g),u.flags|=4096;return u}return a=Ci(a.child,{mode:g.mode,children:g.children}),a.ref=u.ref,u.child=a,a.return=u,a}function ap(a,u){var f=u.ref;if(f===null)a!==null&&a.ref!==null&&(u.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(a===null||a.ref!==f)&&(u.flags|=4194816)}}function eb(a,u,f,g,v){return ha(u),f=My(a,u,f,g,void 0,v),g=Fy(),a!==null&&!mn?(Ly(a,u,v),Ni(a,u,v)):(le&&g&&gy(u),u.flags|=1,Hn(a,u,f,v),u.child)}function Zk(a,u,f,g,v,C){return ha(u),u.updateQueue=null,f=tk(u,g,f,v),QT(a),g=Fy(),a!==null&&!mn?(Ly(a,u,C),Ni(a,u,C)):(le&&g&&gy(u),u.flags|=1,Hn(a,u,f,C),u.child)}function Jk(a,u,f,g,v){if(ha(u),u.stateNode===null){var C=Al,I=f.contextType;typeof I=="object"&&I!==null&&(C=Wn(I)),C=new f(g,C),u.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,C.updater=Jy,u.stateNode=C,C._reactInternals=u,C=u.stateNode,C.props=g,C.state=u.memoizedState,C.refs={},Ey(u),I=f.contextType,C.context=typeof I=="object"&&I!==null?Wn(I):Al,C.state=u.memoizedState,I=f.getDerivedStateFromProps,typeof I=="function"&&(Zy(u,f,I,g),C.state=u.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(I=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),I!==C.state&&Jy.enqueueReplaceState(C,C.state,null),Nu(u,g,C,v),Iu(),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!0}else if(a===null){C=u.stateNode;var M=u.memoizedProps,j=ya(f,M);C.props=j;var at=C.context,mt=f.contextType;I=Al,typeof mt=="object"&&mt!==null&&(I=Wn(mt));var bt=f.getDerivedStateFromProps;mt=typeof bt=="function"||typeof C.getSnapshotBeforeUpdate=="function",M=u.pendingProps!==M,mt||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(M||at!==I)&&Pk(u,C,g,I),io=!1;var ut=u.memoizedState;C.state=ut,Nu(u,g,C,v),Iu(),at=u.memoizedState,M||ut!==at||io?(typeof bt=="function"&&(Zy(u,f,bt,g),at=u.memoizedState),(j=io||Lk(u,f,j,g,ut,at,I))?(mt||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount()),typeof C.componentDidMount=="function"&&(u.flags|=4194308)):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),u.memoizedProps=g,u.memoizedState=at),C.props=g,C.state=at,C.context=I,g=j):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!1)}else{C=u.stateNode,Iy(a,u),I=u.memoizedProps,mt=ya(f,I),C.props=mt,bt=u.pendingProps,ut=C.context,at=f.contextType,j=Al,typeof at=="object"&&at!==null&&(j=Wn(at)),M=f.getDerivedStateFromProps,(at=typeof M=="function"||typeof C.getSnapshotBeforeUpdate=="function")||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(I!==bt||ut!==j)&&Pk(u,C,g,j),io=!1,ut=u.memoizedState,C.state=ut,Nu(u,g,C,v),Iu();var ht=u.memoizedState;I!==bt||ut!==ht||io||a!==null&&a.dependencies!==null&&Uf(a.dependencies)?(typeof M=="function"&&(Zy(u,f,M,g),ht=u.memoizedState),(mt=io||Lk(u,f,mt,g,ut,ht,j)||a!==null&&a.dependencies!==null&&Uf(a.dependencies))?(at||typeof C.UNSAFE_componentWillUpdate!="function"&&typeof C.componentWillUpdate!="function"||(typeof C.componentWillUpdate=="function"&&C.componentWillUpdate(g,ht,j),typeof C.UNSAFE_componentWillUpdate=="function"&&C.UNSAFE_componentWillUpdate(g,ht,j)),typeof C.componentDidUpdate=="function"&&(u.flags|=4),typeof C.getSnapshotBeforeUpdate=="function"&&(u.flags|=1024)):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=1024),u.memoizedProps=g,u.memoizedState=ht),C.props=g,C.state=ht,C.context=j,g=mt):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=1024),g=!1)}return C=g,ap(a,u),g=(u.flags&128)!==0,C||g?(C=u.stateNode,f=g&&typeof f.getDerivedStateFromError!="function"?null:C.render(),u.flags|=1,a!==null&&g?(u.child=ma(u,a.child,null,v),u.child=ma(u,null,f,v)):Hn(a,u,f,v),u.memoizedState=C.state,a=u.child):a=Ni(a,u,v),a}function Qk(a,u,f,g){return ca(),u.flags|=256,Hn(a,u,f,g),u.child}var nb={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function sb(a){return{baseLanes:a,cachePool:UT()}}function rb(a,u,f){return a=a!==null?a.childLanes&~f:0,u&&(a|=Ws),a}function t2(a,u,f){var g=u.pendingProps,v=!1,C=(u.flags&128)!==0,I;if((I=C)||(I=a!==null&&a.memoizedState===null?!1:(ln.current&2)!==0),I&&(v=!0,u.flags&=-129),I=(u.flags&32)!==0,u.flags&=-33,a===null){if(le){if(v?lo(u):co(),(a=Be)?(a=l$(a,lr),a=a!==null&&a.data!=="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:eo!==null?{id:Yr,overflow:Zr}:null,retryLane:536870912,hydrationErrors:null},f=DT(a),f.return=u,u.child=f,Gn=u,Be=null)):a=null,a===null)throw so(u);return Bb(a)?u.lanes=32:u.lanes=536870912,null}var M=g.children;return g=g.fallback,v?(co(),v=u.mode,M=lp({mode:"hidden",children:M},v),g=la(g,v,f,null),M.return=u,g.return=u,M.sibling=g,u.child=M,g=u.child,g.memoizedState=sb(f),g.childLanes=rb(a,I,f),u.memoizedState=nb,Ou(null,g)):(lo(u),ib(u,M))}var j=a.memoizedState;if(j!==null&&(M=j.dehydrated,M!==null)){if(C)u.flags&256?(lo(u),u.flags&=-257,u=ob(a,u,f)):u.memoizedState!==null?(co(),u.child=a.child,u.flags|=128,u=null):(co(),M=g.fallback,v=u.mode,g=lp({mode:"visible",children:g.children},v),M=la(M,v,f,null),M.flags|=2,g.return=u,M.return=u,g.sibling=M,u.child=g,ma(u,a.child,null,f),g=u.child,g.memoizedState=sb(f),g.childLanes=rb(a,I,f),u.memoizedState=nb,u=Ou(null,g));else if(lo(u),Bb(M)){if(I=M.nextSibling&&M.nextSibling.dataset,I)var at=I.dgst;I=at,g=Error(s(419)),g.stack="",g.digest=I,Su({value:g,source:null,stack:null}),u=ob(a,u,f)}else if(mn||Ol(a,u,f,!1),I=(f&a.childLanes)!==0,mn||I){if(I=Oe,I!==null&&(g=BC(I,f),g!==0&&g!==j.retryLane))throw j.retryLane=g,aa(a,g),As(I,a,g),tb;zb(M)||yp(),u=ob(a,u,f)}else zb(M)?(u.flags|=192,u.child=a.child,u=null):(a=j.treeContext,Be=ur(M.nextSibling),Gn=u,le=!0,no=null,lr=!1,a!==null&&FT(u,a),u=ib(u,g.children),u.flags|=4096);return u}return v?(co(),M=g.fallback,v=u.mode,j=a.child,at=j.sibling,g=Ci(j,{mode:"hidden",children:g.children}),g.subtreeFlags=j.subtreeFlags&65011712,at!==null?M=Ci(at,M):(M=la(M,v,f,null),M.flags|=2),M.return=u,g.return=u,g.sibling=M,u.child=g,Ou(null,g),g=u.child,M=a.child.memoizedState,M===null?M=sb(f):(v=M.cachePool,v!==null?(j=fn._currentValue,v=v.parent!==j?{parent:j,pool:j}:v):v=UT(),M={baseLanes:M.baseLanes|f,cachePool:v}),g.memoizedState=M,g.childLanes=rb(a,I,f),u.memoizedState=nb,Ou(a.child,g)):(lo(u),f=a.child,a=f.sibling,f=Ci(f,{mode:"visible",children:g.children}),f.return=u,f.sibling=null,a!==null&&(I=u.deletions,I===null?(u.deletions=[a],u.flags|=16):I.push(a)),u.child=f,u.memoizedState=null,f)}function ib(a,u){return u=lp({mode:"visible",children:u},a.mode),u.return=a,a.child=u}function lp(a,u){return a=Vs(22,a,null,u),a.lanes=0,a}function ob(a,u,f){return ma(u,a.child,null,f),a=ib(u,u.pendingProps.children),a.flags|=2,u.memoizedState=null,a}function e2(a,u,f){a.lanes|=u;var g=a.alternate;g!==null&&(g.lanes|=u),wy(a.return,u,f)}function ab(a,u,f,g,v,C){var I=a.memoizedState;I===null?a.memoizedState={isBackwards:u,rendering:null,renderingStartTime:0,last:g,tail:f,tailMode:v,treeForkCount:C}:(I.isBackwards=u,I.rendering=null,I.renderingStartTime=0,I.last=g,I.tail=f,I.tailMode=v,I.treeForkCount=C)}function n2(a,u,f){var g=u.pendingProps,v=g.revealOrder,C=g.tail;g=g.children;var I=ln.current,M=(I&2)!==0;if(M?(I=I&1|2,u.flags|=128):I&=1,Q(ln,I),Hn(a,u,g,f),g=le?wu:0,!M&&a!==null&&(a.flags&128)!==0)t:for(a=u.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&e2(a,f,u);else if(a.tag===19)e2(a,f,u);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===u)break t;for(;a.sibling===null;){if(a.return===null||a.return===u)break t;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(v){case"forwards":for(f=u.child,v=null;f!==null;)a=f.alternate,a!==null&&Yf(a)===null&&(v=f),f=f.sibling;f=v,f===null?(v=u.child,u.child=null):(v=f.sibling,f.sibling=null),ab(u,!1,v,f,C,g);break;case"backwards":case"unstable_legacy-backwards":for(f=null,v=u.child,u.child=null;v!==null;){if(a=v.alternate,a!==null&&Yf(a)===null){u.child=v;break}a=v.sibling,v.sibling=f,f=v,v=a}ab(u,!0,f,null,C,g);break;case"together":ab(u,!1,null,null,void 0,g);break;default:u.memoizedState=null}return u.child}function Ni(a,u,f){if(a!==null&&(u.dependencies=a.dependencies),fo|=u.lanes,(f&u.childLanes)===0)if(a!==null){if(Ol(a,u,f,!1),(f&u.childLanes)===0)return null}else return null;if(a!==null&&u.child!==a.child)throw Error(s(153));if(u.child!==null){for(a=u.child,f=Ci(a,a.pendingProps),u.child=f,f.return=u;a.sibling!==null;)a=a.sibling,f=f.sibling=Ci(a,a.pendingProps),f.return=u;f.sibling=null}return u.child}function lb(a,u){return(a.lanes&u)!==0?!0:(a=a.dependencies,!!(a!==null&&Uf(a)))}function xz(a,u,f){switch(u.tag){case 3:kt(u,u.stateNode.containerInfo),ro(u,fn,a.memoizedState.cache),ca();break;case 27:case 5:Rt(u);break;case 4:kt(u,u.stateNode.containerInfo);break;case 10:ro(u,u.type,u.memoizedProps.value);break;case 31:if(u.memoizedState!==null)return u.flags|=128,Dy(u),null;break;case 13:var g=u.memoizedState;if(g!==null)return g.dehydrated!==null?(lo(u),u.flags|=128,null):(f&u.child.childLanes)!==0?t2(a,u,f):(lo(u),a=Ni(a,u,f),a!==null?a.sibling:null);lo(u);break;case 19:var v=(a.flags&128)!==0;if(g=(f&u.childLanes)!==0,g||(Ol(a,u,f,!1),g=(f&u.childLanes)!==0),v){if(g)return n2(a,u,f);u.flags|=128}if(v=u.memoizedState,v!==null&&(v.rendering=null,v.tail=null,v.lastEffect=null),Q(ln,ln.current),g)break;return null;case 22:return u.lanes=0,Kk(a,u,f,u.pendingProps);case 24:ro(u,fn,a.memoizedState.cache)}return Ni(a,u,f)}function s2(a,u,f){if(a!==null)if(a.memoizedProps!==u.pendingProps)mn=!0;else{if(!lb(a,f)&&(u.flags&128)===0)return mn=!1,xz(a,u,f);mn=(a.flags&131072)!==0}else mn=!1,le&&(u.flags&1048576)!==0&&MT(u,wu,u.index);switch(u.lanes=0,u.tag){case 16:t:{var g=u.pendingProps;if(a=fa(u.elementType),u.type=a,typeof a=="function")fy(a)?(g=ya(a,g),u.tag=1,u=Jk(null,u,a,g,f)):(u.tag=0,u=eb(null,u,a,g,f));else{if(a!=null){var v=a.$$typeof;if(v===$){u.tag=11,u=Wk(null,u,a,g,f);break t}else if(v===_){u.tag=14,u=Hk(null,u,a,g,f);break t}}throw u=W(a)||a,Error(s(306,u,""))}}return u;case 0:return eb(a,u,u.type,u.pendingProps,f);case 1:return g=u.type,v=ya(g,u.pendingProps),Jk(a,u,g,v,f);case 3:t:{if(kt(u,u.stateNode.containerInfo),a===null)throw Error(s(387));g=u.pendingProps;var C=u.memoizedState;v=C.element,Iy(a,u),Nu(u,g,null,f);var I=u.memoizedState;if(g=I.cache,ro(u,fn,g),g!==C.cache&&Sy(u,[fn],f,!0),Iu(),g=I.element,C.isDehydrated)if(C={element:g,isDehydrated:!1,cache:I.cache},u.updateQueue.baseState=C,u.memoizedState=C,u.flags&256){u=Qk(a,u,g,f);break t}else if(g!==v){v=ir(Error(s(424)),u),Su(v),u=Qk(a,u,g,f);break t}else for(a=u.stateNode.containerInfo,a.nodeType===9?a=a.body:a=a.nodeName==="HTML"?a.ownerDocument.body:a,Be=ur(a.firstChild),Gn=u,le=!0,no=null,lr=!0,f=KT(u,null,g,f),u.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(ca(),g===v){u=Ni(a,u,f);break t}Hn(a,u,g,f)}u=u.child}return u;case 26:return ap(a,u),a===null?(f=p$(u.type,null,u.pendingProps,null))?u.memoizedState=f:le||(f=u.type,a=u.pendingProps,g=Tp(gt.current).createElement(f),g[jn]=u,g[Ts]=a,qn(g,f,a),Mn(g),u.stateNode=g):u.memoizedState=p$(u.type,a.memoizedProps,u.pendingProps,a.memoizedState),null;case 27:return Rt(u),a===null&&le&&(g=u.stateNode=h$(u.type,u.pendingProps,gt.current),Gn=u,lr=!0,v=Be,bo(u.type)?(Vb=v,Be=ur(g.firstChild)):Be=v),Hn(a,u,u.pendingProps.children,f),ap(a,u),a===null&&(u.flags|=4194304),u.child;case 5:return a===null&&le&&((v=g=Be)&&(g=Xz(g,u.type,u.pendingProps,lr),g!==null?(u.stateNode=g,Gn=u,Be=ur(g.firstChild),lr=!1,v=!0):v=!1),v||so(u)),Rt(u),v=u.type,C=u.pendingProps,I=a!==null?a.memoizedProps:null,g=C.children,Fb(v,C)?g=null:I!==null&&Fb(v,I)&&(u.flags|=32),u.memoizedState!==null&&(v=My(a,u,uz,null,null,f),Xu._currentValue=v),ap(a,u),Hn(a,u,g,f),u.child;case 6:return a===null&&le&&((a=f=Be)&&(f=Yz(f,u.pendingProps,lr),f!==null?(u.stateNode=f,Gn=u,Be=null,a=!0):a=!1),a||so(u)),null;case 13:return t2(a,u,f);case 4:return kt(u,u.stateNode.containerInfo),g=u.pendingProps,a===null?u.child=ma(u,null,g,f):Hn(a,u,g,f),u.child;case 11:return Wk(a,u,u.type,u.pendingProps,f);case 7:return Hn(a,u,u.pendingProps,f),u.child;case 8:return Hn(a,u,u.pendingProps.children,f),u.child;case 12:return Hn(a,u,u.pendingProps.children,f),u.child;case 10:return g=u.pendingProps,ro(u,u.type,g.value),Hn(a,u,g.children,f),u.child;case 9:return v=u.type._context,g=u.pendingProps.children,ha(u),v=Wn(v),g=g(v),u.flags|=1,Hn(a,u,g,f),u.child;case 14:return Hk(a,u,u.type,u.pendingProps,f);case 15:return qk(a,u,u.type,u.pendingProps,f);case 19:return n2(a,u,f);case 31:return bz(a,u,f);case 22:return Kk(a,u,f,u.pendingProps);case 24:return ha(u),g=Wn(fn),a===null?(v=ky(),v===null&&(v=Oe,C=Cy(),v.pooledCache=C,C.refCount++,C!==null&&(v.pooledCacheLanes|=f),v=C),u.memoizedState={parent:g,cache:v},Ey(u),ro(u,fn,v)):((a.lanes&f)!==0&&(Iy(a,u),Nu(u,null,null,f),Iu()),v=a.memoizedState,C=u.memoizedState,v.parent!==g?(v={parent:g,cache:g},u.memoizedState=v,u.lanes===0&&(u.memoizedState=u.updateQueue.baseState=v),ro(u,fn,g)):(g=C.cache,ro(u,fn,g),g!==v.cache&&Sy(u,[fn],f,!0))),Hn(a,u,u.pendingProps.children,f),u.child;case 29:throw u.pendingProps}throw Error(s(156,u.tag))}function Ai(a){a.flags|=4}function cb(a,u,f,g,v){if((u=(a.mode&32)!==0)&&(u=!1),u){if(a.flags|=16777216,(v&335544128)===v)if(a.stateNode.complete)a.flags|=8192;else if(A2())a.flags|=8192;else throw pa=Hf,$y}else a.flags&=-16777217}function r2(a,u){if(u.type!=="stylesheet"||(u.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!x$(u))if(A2())a.flags|=8192;else throw pa=Hf,$y}function cp(a,u){u!==null&&(a.flags|=4),a.flags&16384&&(u=a.tag!==22?LC():536870912,a.lanes|=u,Hl|=u)}function Mu(a,u){if(!le)switch(a.tailMode){case"hidden":u=a.tail;for(var f=null;u!==null;)u.alternate!==null&&(f=u),u=u.sibling;f===null?a.tail=null:f.sibling=null;break;case"collapsed":f=a.tail;for(var g=null;f!==null;)f.alternate!==null&&(g=f),f=f.sibling;g===null?u||a.tail===null?a.tail=null:a.tail.sibling=null:g.sibling=null}}function Ve(a){var u=a.alternate!==null&&a.alternate.child===a.child,f=0,g=0;if(u)for(var v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags&65011712,g|=v.flags&65011712,v.return=a,v=v.sibling;else for(v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags,g|=v.flags,v.return=a,v=v.sibling;return a.subtreeFlags|=g,a.childLanes=f,u}function vz(a,u,f){var g=u.pendingProps;switch(yy(u),u.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ve(u),null;case 1:return Ve(u),null;case 3:return f=u.stateNode,g=null,a!==null&&(g=a.memoizedState.cache),u.memoizedState.cache!==g&&(u.flags|=2048),$i(fn),Ct(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(a===null||a.child===null)&&(Dl(u)?Ai(u):a===null||a.memoizedState.isDehydrated&&(u.flags&256)===0||(u.flags|=1024,xy())),Ve(u),null;case 26:var v=u.type,C=u.memoizedState;return a===null?(Ai(u),C!==null?(Ve(u),r2(u,C)):(Ve(u),cb(u,v,null,g,f))):C?C!==a.memoizedState?(Ai(u),Ve(u),r2(u,C)):(Ve(u),u.flags&=-16777217):(a=a.memoizedProps,a!==g&&Ai(u),Ve(u),cb(u,v,a,g,f)),null;case 27:if(Gt(u),f=gt.current,v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Ai(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return Ve(u),null}a=lt.current,Dl(u)?LT(u):(a=h$(v,g,f),u.stateNode=a,Ai(u))}return Ve(u),null;case 5:if(Gt(u),v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Ai(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return Ve(u),null}if(C=lt.current,Dl(u))LT(u);else{var I=Tp(gt.current);switch(C){case 1:C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":C=I.createElement("div"),C.innerHTML="<script><\/script>",C=C.removeChild(C.firstChild);break;case"select":C=typeof g.is=="string"?I.createElement("select",{is:g.is}):I.createElement("select"),g.multiple?C.multiple=!0:g.size&&(C.size=g.size);break;default:C=typeof g.is=="string"?I.createElement(v,{is:g.is}):I.createElement(v)}}C[jn]=u,C[Ts]=g;t:for(I=u.child;I!==null;){if(I.tag===5||I.tag===6)C.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===u)break t;for(;I.sibling===null;){if(I.return===null||I.return===u)break t;I=I.return}I.sibling.return=I.return,I=I.sibling}u.stateNode=C;t:switch(qn(C,v,g),v){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break t;case"img":g=!0;break t;default:g=!1}g&&Ai(u)}}return Ve(u),cb(u,u.type,a===null?null:a.memoizedProps,u.pendingProps,f),null;case 6:if(a&&u.stateNode!=null)a.memoizedProps!==g&&Ai(u);else{if(typeof g!="string"&&u.stateNode===null)throw Error(s(166));if(a=gt.current,Dl(u)){if(a=u.stateNode,f=u.memoizedProps,g=null,v=Gn,v!==null)switch(v.tag){case 27:case 5:g=v.memoizedProps}a[jn]=u,a=!!(a.nodeValue===f||g!==null&&g.suppressHydrationWarning===!0||t$(a.nodeValue,f)),a||so(u,!0)}else a=Tp(a).createTextNode(g),a[jn]=u,u.stateNode=a}return Ve(u),null;case 31:if(f=u.memoizedState,a===null||a.memoizedState!==null){if(g=Dl(u),f!==null){if(a===null){if(!g)throw Error(s(318));if(a=u.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(557));a[jn]=u}else ca(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Ve(u),a=!1}else f=xy(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=f),a=!0;if(!a)return u.flags&256?(js(u),u):(js(u),null);if((u.flags&128)!==0)throw Error(s(558))}return Ve(u),null;case 13:if(g=u.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(v=Dl(u),g!==null&&g.dehydrated!==null){if(a===null){if(!v)throw Error(s(318));if(v=u.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(s(317));v[jn]=u}else ca(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Ve(u),v=!1}else v=xy(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=v),v=!0;if(!v)return u.flags&256?(js(u),u):(js(u),null)}return js(u),(u.flags&128)!==0?(u.lanes=f,u):(f=g!==null,a=a!==null&&a.memoizedState!==null,f&&(g=u.child,v=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(v=g.alternate.memoizedState.cachePool.pool),C=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(C=g.memoizedState.cachePool.pool),C!==v&&(g.flags|=2048)),f!==a&&f&&(u.child.flags|=8192),cp(u,u.updateQueue),Ve(u),null);case 4:return Ct(),a===null&&_b(u.stateNode.containerInfo),Ve(u),null;case 10:return $i(u.type),Ve(u),null;case 19:if(B(ln),g=u.memoizedState,g===null)return Ve(u),null;if(v=(u.flags&128)!==0,C=g.rendering,C===null)if(v)Mu(g,!1);else{if(Ze!==0||a!==null&&(a.flags&128)!==0)for(a=u.child;a!==null;){if(C=Yf(a),C!==null){for(u.flags|=128,Mu(g,!1),a=C.updateQueue,u.updateQueue=a,cp(u,a),u.subtreeFlags=0,a=f,f=u.child;f!==null;)RT(f,a),f=f.sibling;return Q(ln,ln.current&1|2),le&&Ti(u,g.treeForkCount),u.child}a=a.sibling}g.tail!==null&&me()>pp&&(u.flags|=128,v=!0,Mu(g,!1),u.lanes=4194304)}else{if(!v)if(a=Yf(C),a!==null){if(u.flags|=128,v=!0,a=a.updateQueue,u.updateQueue=a,cp(u,a),Mu(g,!0),g.tail===null&&g.tailMode==="hidden"&&!C.alternate&&!le)return Ve(u),null}else 2*me()-g.renderingStartTime>pp&&f!==536870912&&(u.flags|=128,v=!0,Mu(g,!1),u.lanes=4194304);g.isBackwards?(C.sibling=u.child,u.child=C):(a=g.last,a!==null?a.sibling=C:u.child=C,g.last=C)}return g.tail!==null?(a=g.tail,g.rendering=a,g.tail=a.sibling,g.renderingStartTime=me(),a.sibling=null,f=ln.current,Q(ln,v?f&1|2:f&1),le&&Ti(u,g.treeForkCount),a):(Ve(u),null);case 22:case 23:return js(u),Ry(),g=u.memoizedState!==null,a!==null?a.memoizedState!==null!==g&&(u.flags|=8192):g&&(u.flags|=8192),g?(f&536870912)!==0&&(u.flags&128)===0&&(Ve(u),u.subtreeFlags&6&&(u.flags|=8192)):Ve(u),f=u.updateQueue,f!==null&&cp(u,f.retryQueue),f=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),g=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(g=u.memoizedState.cachePool.pool),g!==f&&(u.flags|=2048),a!==null&&B(da),null;case 24:return f=null,a!==null&&(f=a.memoizedState.cache),u.memoizedState.cache!==f&&(u.flags|=2048),$i(fn),Ve(u),null;case 25:return null;case 30:return null}throw Error(s(156,u.tag))}function wz(a,u){switch(yy(u),u.tag){case 1:return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 3:return $i(fn),Ct(),a=u.flags,(a&65536)!==0&&(a&128)===0?(u.flags=a&-65537|128,u):null;case 26:case 27:case 5:return Gt(u),null;case 31:if(u.memoizedState!==null){if(js(u),u.alternate===null)throw Error(s(340));ca()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 13:if(js(u),a=u.memoizedState,a!==null&&a.dehydrated!==null){if(u.alternate===null)throw Error(s(340));ca()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 19:return B(ln),null;case 4:return Ct(),null;case 10:return $i(u.type),null;case 22:case 23:return js(u),Ry(),a!==null&&B(da),a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 24:return $i(fn),null;case 25:return null;default:return null}}function i2(a,u){switch(yy(u),u.tag){case 3:$i(fn),Ct();break;case 26:case 27:case 5:Gt(u);break;case 4:Ct();break;case 31:u.memoizedState!==null&&js(u);break;case 13:js(u);break;case 19:B(ln);break;case 10:$i(u.type);break;case 22:case 23:js(u),Ry(),a!==null&&B(da);break;case 24:$i(fn)}}function Fu(a,u){try{var f=u.updateQueue,g=f!==null?f.lastEffect:null;if(g!==null){var v=g.next;f=v;do{if((f.tag&a)===a){g=void 0;var C=f.create,I=f.inst;g=C(),I.destroy=g}f=f.next}while(f!==v)}}catch(M){Ee(u,u.return,M)}}function uo(a,u,f){try{var g=u.updateQueue,v=g!==null?g.lastEffect:null;if(v!==null){var C=v.next;g=C;do{if((g.tag&a)===a){var I=g.inst,M=I.destroy;if(M!==void 0){I.destroy=void 0,v=u;var j=f,at=M;try{at()}catch(mt){Ee(v,j,mt)}}}g=g.next}while(g!==C)}}catch(mt){Ee(u,u.return,mt)}}function o2(a){var u=a.updateQueue;if(u!==null){var f=a.stateNode;try{YT(u,f)}catch(g){Ee(a,a.return,g)}}}function a2(a,u,f){f.props=ya(a.type,a.memoizedProps),f.state=a.memoizedState;try{f.componentWillUnmount()}catch(g){Ee(a,u,g)}}function Lu(a,u){try{var f=a.ref;if(f!==null){switch(a.tag){case 26:case 27:case 5:var g=a.stateNode;break;case 30:g=a.stateNode;break;default:g=a.stateNode}typeof f=="function"?a.refCleanup=f(g):f.current=g}}catch(v){Ee(a,u,v)}}function Jr(a,u){var f=a.ref,g=a.refCleanup;if(f!==null)if(typeof g=="function")try{g()}catch(v){Ee(a,u,v)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(v){Ee(a,u,v)}else f.current=null}function l2(a){var u=a.type,f=a.memoizedProps,g=a.stateNode;try{t:switch(u){case"button":case"input":case"select":case"textarea":f.autoFocus&&g.focus();break t;case"img":f.src?g.src=f.src:f.srcSet&&(g.srcset=f.srcSet)}}catch(v){Ee(a,a.return,v)}}function ub(a,u,f){try{var g=a.stateNode;jz(g,a.type,f,u),g[Ts]=u}catch(v){Ee(a,a.return,v)}}function c2(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&bo(a.type)||a.tag===4}function hb(a){t:for(;;){for(;a.sibling===null;){if(a.return===null||c2(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&bo(a.type)||a.flags&2||a.child===null||a.tag===4)continue t;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function db(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(a,u):(u=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,u.appendChild(a),f=f._reactRootContainer,f!=null||u.onclick!==null||(u.onclick=wi));else if(g!==4&&(g===27&&bo(a.type)&&(f=a.stateNode,u=null),a=a.child,a!==null))for(db(a,u,f),a=a.sibling;a!==null;)db(a,u,f),a=a.sibling}function up(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?f.insertBefore(a,u):f.appendChild(a);else if(g!==4&&(g===27&&bo(a.type)&&(f=a.stateNode),a=a.child,a!==null))for(up(a,u,f),a=a.sibling;a!==null;)up(a,u,f),a=a.sibling}function u2(a){var u=a.stateNode,f=a.memoizedProps;try{for(var g=a.type,v=u.attributes;v.length;)u.removeAttributeNode(v[0]);qn(u,g,f),u[jn]=a,u[Ts]=f}catch(C){Ee(a,a.return,C)}}var _i=!1,gn=!1,fb=!1,h2=typeof WeakSet=="function"?WeakSet:Set,Fn=null;function Sz(a,u){if(a=a.containerInfo,Ob=_p,a=CT(a),oy(a)){if("selectionStart"in a)var f={start:a.selectionStart,end:a.selectionEnd};else t:{f=(f=a.ownerDocument)&&f.defaultView||window;var g=f.getSelection&&f.getSelection();if(g&&g.rangeCount!==0){f=g.anchorNode;var v=g.anchorOffset,C=g.focusNode;g=g.focusOffset;try{f.nodeType,C.nodeType}catch{f=null;break t}var I=0,M=-1,j=-1,at=0,mt=0,bt=a,ut=null;e:for(;;){for(var ht;bt!==f||v!==0&&bt.nodeType!==3||(M=I+v),bt!==C||g!==0&&bt.nodeType!==3||(j=I+g),bt.nodeType===3&&(I+=bt.nodeValue.length),(ht=bt.firstChild)!==null;)ut=bt,bt=ht;for(;;){if(bt===a)break e;if(ut===f&&++at===v&&(M=I),ut===C&&++mt===g&&(j=I),(ht=bt.nextSibling)!==null)break;bt=ut,ut=bt.parentNode}bt=ht}f=M===-1||j===-1?null:{start:M,end:j}}else f=null}f=f||{start:0,end:0}}else f=null;for(Mb={focusedElem:a,selectionRange:f},_p=!1,Fn=u;Fn!==null;)if(u=Fn,a=u.child,(u.subtreeFlags&1028)!==0&&a!==null)a.return=u,Fn=a;else for(;Fn!==null;){switch(u=Fn,C=u.alternate,a=u.flags,u.tag){case 0:if((a&4)!==0&&(a=u.updateQueue,a=a!==null?a.events:null,a!==null))for(f=0;f<a.length;f++)v=a[f],v.ref.impl=v.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&C!==null){a=void 0,f=u,v=C.memoizedProps,C=C.memoizedState,g=f.stateNode;try{var It=ya(f.type,v);a=g.getSnapshotBeforeUpdate(It,C),g.__reactInternalSnapshotBeforeUpdate=a}catch(zt){Ee(f,f.return,zt)}}break;case 3:if((a&1024)!==0){if(a=u.stateNode.containerInfo,f=a.nodeType,f===9)Pb(a);else if(f===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":Pb(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(s(163))}if(a=u.sibling,a!==null){a.return=u.return,Fn=a;break}Fn=u.return}}function d2(a,u,f){var g=f.flags;switch(f.tag){case 0:case 11:case 15:Di(a,f),g&4&&Fu(5,f);break;case 1:if(Di(a,f),g&4)if(a=f.stateNode,u===null)try{a.componentDidMount()}catch(I){Ee(f,f.return,I)}else{var v=ya(f.type,u.memoizedProps);u=u.memoizedState;try{a.componentDidUpdate(v,u,a.__reactInternalSnapshotBeforeUpdate)}catch(I){Ee(f,f.return,I)}}g&64&&o2(f),g&512&&Lu(f,f.return);break;case 3:if(Di(a,f),g&64&&(a=f.updateQueue,a!==null)){if(u=null,f.child!==null)switch(f.child.tag){case 27:case 5:u=f.child.stateNode;break;case 1:u=f.child.stateNode}try{YT(a,u)}catch(I){Ee(f,f.return,I)}}break;case 27:u===null&&g&4&&u2(f);case 26:case 5:Di(a,f),u===null&&g&4&&l2(f),g&512&&Lu(f,f.return);break;case 12:Di(a,f);break;case 31:Di(a,f),g&4&&m2(a,f);break;case 13:Di(a,f),g&4&&g2(a,f),g&64&&(a=f.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(f=_z.bind(null,f),Zz(a,f))));break;case 22:if(g=f.memoizedState!==null||_i,!g){u=u!==null&&u.memoizedState!==null||gn,v=_i;var C=gn;_i=g,(gn=u)&&!C?Oi(a,f,(f.subtreeFlags&8772)!==0):Di(a,f),_i=v,gn=C}break;case 30:break;default:Di(a,f)}}function f2(a){var u=a.alternate;u!==null&&(a.alternate=null,f2(u)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(u=a.stateNode,u!==null&&j0(u)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var Ge=null,$s=!1;function Ri(a,u,f){for(f=f.child;f!==null;)p2(a,u,f),f=f.sibling}function p2(a,u,f){if(fs&&typeof fs.onCommitFiberUnmount=="function")try{fs.onCommitFiberUnmount(Kr,f)}catch{}switch(f.tag){case 26:gn||Jr(f,u),Ri(a,u,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:gn||Jr(f,u);var g=Ge,v=$s;bo(f.type)&&(Ge=f.stateNode,$s=!1),Ri(a,u,f),Hu(f.stateNode),Ge=g,$s=v;break;case 5:gn||Jr(f,u);case 6:if(g=Ge,v=$s,Ge=null,Ri(a,u,f),Ge=g,$s=v,Ge!==null)if($s)try{(Ge.nodeType===9?Ge.body:Ge.nodeName==="HTML"?Ge.ownerDocument.body:Ge).removeChild(f.stateNode)}catch(C){Ee(f,u,C)}else try{Ge.removeChild(f.stateNode)}catch(C){Ee(f,u,C)}break;case 18:Ge!==null&&($s?(a=Ge,o$(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,f.stateNode),tc(a)):o$(Ge,f.stateNode));break;case 4:g=Ge,v=$s,Ge=f.stateNode.containerInfo,$s=!0,Ri(a,u,f),Ge=g,$s=v;break;case 0:case 11:case 14:case 15:uo(2,f,u),gn||uo(4,f,u),Ri(a,u,f);break;case 1:gn||(Jr(f,u),g=f.stateNode,typeof g.componentWillUnmount=="function"&&a2(f,u,g)),Ri(a,u,f);break;case 21:Ri(a,u,f);break;case 22:gn=(g=gn)||f.memoizedState!==null,Ri(a,u,f),gn=g;break;default:Ri(a,u,f)}}function m2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{tc(a)}catch(f){Ee(u,u.return,f)}}}function g2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{tc(a)}catch(f){Ee(u,u.return,f)}}function Cz(a){switch(a.tag){case 31:case 13:case 19:var u=a.stateNode;return u===null&&(u=a.stateNode=new h2),u;case 22:return a=a.stateNode,u=a._retryCache,u===null&&(u=a._retryCache=new h2),u;default:throw Error(s(435,a.tag))}}function hp(a,u){var f=Cz(a);u.forEach(function(g){if(!f.has(g)){f.add(g);var v=Rz.bind(null,a,g);g.then(v,v)}})}function Es(a,u){var f=u.deletions;if(f!==null)for(var g=0;g<f.length;g++){var v=f[g],C=a,I=u,M=I;t:for(;M!==null;){switch(M.tag){case 27:if(bo(M.type)){Ge=M.stateNode,$s=!1;break t}break;case 5:Ge=M.stateNode,$s=!1;break t;case 3:case 4:Ge=M.stateNode.containerInfo,$s=!0;break t}M=M.return}if(Ge===null)throw Error(s(160));p2(C,I,v),Ge=null,$s=!1,C=v.alternate,C!==null&&(C.return=null),v.return=null}if(u.subtreeFlags&13886)for(u=u.child;u!==null;)y2(u,a),u=u.sibling}var Nr=null;function y2(a,u){var f=a.alternate,g=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:Es(u,a),Is(a),g&4&&(uo(3,a,a.return),Fu(3,a),uo(5,a,a.return));break;case 1:Es(u,a),Is(a),g&512&&(gn||f===null||Jr(f,f.return)),g&64&&_i&&(a=a.updateQueue,a!==null&&(g=a.callbacks,g!==null&&(f=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=f===null?g:f.concat(g))));break;case 26:var v=Nr;if(Es(u,a),Is(a),g&512&&(gn||f===null||Jr(f,f.return)),g&4){var C=f!==null?f.memoizedState:null;if(g=a.memoizedState,f===null)if(g===null)if(a.stateNode===null){t:{g=a.type,f=a.memoizedProps,v=v.ownerDocument||v;e:switch(g){case"title":C=v.getElementsByTagName("title")[0],(!C||C[uu]||C[jn]||C.namespaceURI==="http://www.w3.org/2000/svg"||C.hasAttribute("itemprop"))&&(C=v.createElement(g),v.head.insertBefore(C,v.querySelector("head > title"))),qn(C,g,f),C[jn]=a,Mn(C),g=C;break t;case"link":var I=y$("link","href",v).get(g+(f.href||""));if(I){for(var M=0;M<I.length;M++)if(C=I[M],C.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&C.getAttribute("rel")===(f.rel==null?null:f.rel)&&C.getAttribute("title")===(f.title==null?null:f.title)&&C.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){I.splice(M,1);break e}}C=v.createElement(g),qn(C,g,f),v.head.appendChild(C);break;case"meta":if(I=y$("meta","content",v).get(g+(f.content||""))){for(M=0;M<I.length;M++)if(C=I[M],C.getAttribute("content")===(f.content==null?null:""+f.content)&&C.getAttribute("name")===(f.name==null?null:f.name)&&C.getAttribute("property")===(f.property==null?null:f.property)&&C.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&C.getAttribute("charset")===(f.charSet==null?null:f.charSet)){I.splice(M,1);break e}}C=v.createElement(g),qn(C,g,f),v.head.appendChild(C);break;default:throw Error(s(468,g))}C[jn]=a,Mn(C),g=C}a.stateNode=g}else b$(v,a.type,a.stateNode);else a.stateNode=g$(v,g,a.memoizedProps);else C!==g?(C===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):C.count--,g===null?b$(v,a.type,a.stateNode):g$(v,g,a.memoizedProps)):g===null&&a.stateNode!==null&&ub(a,a.memoizedProps,f.memoizedProps)}break;case 27:Es(u,a),Is(a),g&512&&(gn||f===null||Jr(f,f.return)),f!==null&&g&4&&ub(a,a.memoizedProps,f.memoizedProps);break;case 5:if(Es(u,a),Is(a),g&512&&(gn||f===null||Jr(f,f.return)),a.flags&32){v=a.stateNode;try{Cl(v,"")}catch(It){Ee(a,a.return,It)}}g&4&&a.stateNode!=null&&(v=a.memoizedProps,ub(a,v,f!==null?f.memoizedProps:v)),g&1024&&(fb=!0);break;case 6:if(Es(u,a),Is(a),g&4){if(a.stateNode===null)throw Error(s(162));g=a.memoizedProps,f=a.stateNode;try{f.nodeValue=g}catch(It){Ee(a,a.return,It)}}break;case 3:if(Ep=null,v=Nr,Nr=kp(u.containerInfo),Es(u,a),Nr=v,Is(a),g&4&&f!==null&&f.memoizedState.isDehydrated)try{tc(u.containerInfo)}catch(It){Ee(a,a.return,It)}fb&&(fb=!1,b2(a));break;case 4:g=Nr,Nr=kp(a.stateNode.containerInfo),Es(u,a),Is(a),Nr=g;break;case 12:Es(u,a),Is(a);break;case 31:Es(u,a),Is(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,hp(a,g)));break;case 13:Es(u,a),Is(a),a.child.flags&8192&&a.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(fp=me()),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,hp(a,g)));break;case 22:v=a.memoizedState!==null;var j=f!==null&&f.memoizedState!==null,at=_i,mt=gn;if(_i=at||v,gn=mt||j,Es(u,a),gn=mt,_i=at,Is(a),g&8192)t:for(u=a.stateNode,u._visibility=v?u._visibility&-2:u._visibility|1,v&&(f===null||j||_i||gn||ba(a)),f=null,u=a;;){if(u.tag===5||u.tag===26){if(f===null){j=f=u;try{if(C=j.stateNode,v)I=C.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{M=j.stateNode;var bt=j.memoizedProps.style,ut=bt!=null&&bt.hasOwnProperty("display")?bt.display:null;M.style.display=ut==null||typeof ut=="boolean"?"":(""+ut).trim()}}catch(It){Ee(j,j.return,It)}}}else if(u.tag===6){if(f===null){j=u;try{j.stateNode.nodeValue=v?"":j.memoizedProps}catch(It){Ee(j,j.return,It)}}}else if(u.tag===18){if(f===null){j=u;try{var ht=j.stateNode;v?a$(ht,!0):a$(j.stateNode,!1)}catch(It){Ee(j,j.return,It)}}}else if((u.tag!==22&&u.tag!==23||u.memoizedState===null||u===a)&&u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break t;for(;u.sibling===null;){if(u.return===null||u.return===a)break t;f===u&&(f=null),u=u.return}f===u&&(f=null),u.sibling.return=u.return,u=u.sibling}g&4&&(g=a.updateQueue,g!==null&&(f=g.retryQueue,f!==null&&(g.retryQueue=null,hp(a,f))));break;case 19:Es(u,a),Is(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,hp(a,g)));break;case 30:break;case 21:break;default:Es(u,a),Is(a)}}function Is(a){var u=a.flags;if(u&2){try{for(var f,g=a.return;g!==null;){if(c2(g)){f=g;break}g=g.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var v=f.stateNode,C=hb(a);up(a,C,v);break;case 5:var I=f.stateNode;f.flags&32&&(Cl(I,""),f.flags&=-33);var M=hb(a);up(a,M,I);break;case 3:case 4:var j=f.stateNode.containerInfo,at=hb(a);db(a,at,j);break;default:throw Error(s(161))}}catch(mt){Ee(a,a.return,mt)}a.flags&=-3}u&4096&&(a.flags&=-4097)}function b2(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var u=a;b2(u),u.tag===5&&u.flags&1024&&u.stateNode.reset(),a=a.sibling}}function Di(a,u){if(u.subtreeFlags&8772)for(u=u.child;u!==null;)d2(a,u.alternate,u),u=u.sibling}function ba(a){for(a=a.child;a!==null;){var u=a;switch(u.tag){case 0:case 11:case 14:case 15:uo(4,u,u.return),ba(u);break;case 1:Jr(u,u.return);var f=u.stateNode;typeof f.componentWillUnmount=="function"&&a2(u,u.return,f),ba(u);break;case 27:Hu(u.stateNode);case 26:case 5:Jr(u,u.return),ba(u);break;case 22:u.memoizedState===null&&ba(u);break;case 30:ba(u);break;default:ba(u)}a=a.sibling}}function Oi(a,u,f){for(f=f&&(u.subtreeFlags&8772)!==0,u=u.child;u!==null;){var g=u.alternate,v=a,C=u,I=C.flags;switch(C.tag){case 0:case 11:case 15:Oi(v,C,f),Fu(4,C);break;case 1:if(Oi(v,C,f),g=C,v=g.stateNode,typeof v.componentDidMount=="function")try{v.componentDidMount()}catch(at){Ee(g,g.return,at)}if(g=C,v=g.updateQueue,v!==null){var M=g.stateNode;try{var j=v.shared.hiddenCallbacks;if(j!==null)for(v.shared.hiddenCallbacks=null,v=0;v<j.length;v++)XT(j[v],M)}catch(at){Ee(g,g.return,at)}}f&&I&64&&o2(C),Lu(C,C.return);break;case 27:u2(C);case 26:case 5:Oi(v,C,f),f&&g===null&&I&4&&l2(C),Lu(C,C.return);break;case 12:Oi(v,C,f);break;case 31:Oi(v,C,f),f&&I&4&&m2(v,C);break;case 13:Oi(v,C,f),f&&I&4&&g2(v,C);break;case 22:C.memoizedState===null&&Oi(v,C,f),Lu(C,C.return);break;case 30:break;default:Oi(v,C,f)}u=u.sibling}}function pb(a,u){var f=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),a=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(a=u.memoizedState.cachePool.pool),a!==f&&(a!=null&&a.refCount++,f!=null&&Cu(f))}function mb(a,u){a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Cu(a))}function Ar(a,u,f,g){if(u.subtreeFlags&10256)for(u=u.child;u!==null;)x2(a,u,f,g),u=u.sibling}function x2(a,u,f,g){var v=u.flags;switch(u.tag){case 0:case 11:case 15:Ar(a,u,f,g),v&2048&&Fu(9,u);break;case 1:Ar(a,u,f,g);break;case 3:Ar(a,u,f,g),v&2048&&(a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Cu(a)));break;case 12:if(v&2048){Ar(a,u,f,g),a=u.stateNode;try{var C=u.memoizedProps,I=C.id,M=C.onPostCommit;typeof M=="function"&&M(I,u.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(j){Ee(u,u.return,j)}}else Ar(a,u,f,g);break;case 31:Ar(a,u,f,g);break;case 13:Ar(a,u,f,g);break;case 23:break;case 22:C=u.stateNode,I=u.alternate,u.memoizedState!==null?C._visibility&2?Ar(a,u,f,g):Pu(a,u):C._visibility&2?Ar(a,u,f,g):(C._visibility|=2,jl(a,u,f,g,(u.subtreeFlags&10256)!==0||!1)),v&2048&&pb(I,u);break;case 24:Ar(a,u,f,g),v&2048&&mb(u.alternate,u);break;default:Ar(a,u,f,g)}}function jl(a,u,f,g,v){for(v=v&&((u.subtreeFlags&10256)!==0||!1),u=u.child;u!==null;){var C=a,I=u,M=f,j=g,at=I.flags;switch(I.tag){case 0:case 11:case 15:jl(C,I,M,j,v),Fu(8,I);break;case 23:break;case 22:var mt=I.stateNode;I.memoizedState!==null?mt._visibility&2?jl(C,I,M,j,v):Pu(C,I):(mt._visibility|=2,jl(C,I,M,j,v)),v&&at&2048&&pb(I.alternate,I);break;case 24:jl(C,I,M,j,v),v&&at&2048&&mb(I.alternate,I);break;default:jl(C,I,M,j,v)}u=u.sibling}}function Pu(a,u){if(u.subtreeFlags&10256)for(u=u.child;u!==null;){var f=a,g=u,v=g.flags;switch(g.tag){case 22:Pu(f,g),v&2048&&pb(g.alternate,g);break;case 24:Pu(f,g),v&2048&&mb(g.alternate,g);break;default:Pu(f,g)}u=u.sibling}}var zu=8192;function Gl(a,u,f){if(a.subtreeFlags&zu)for(a=a.child;a!==null;)v2(a,u,f),a=a.sibling}function v2(a,u,f){switch(a.tag){case 26:Gl(a,u,f),a.flags&zu&&a.memoizedState!==null&&cB(f,Nr,a.memoizedState,a.memoizedProps);break;case 5:Gl(a,u,f);break;case 3:case 4:var g=Nr;Nr=kp(a.stateNode.containerInfo),Gl(a,u,f),Nr=g;break;case 22:a.memoizedState===null&&(g=a.alternate,g!==null&&g.memoizedState!==null?(g=zu,zu=16777216,Gl(a,u,f),zu=g):Gl(a,u,f));break;default:Gl(a,u,f)}}function w2(a){var u=a.alternate;if(u!==null&&(a=u.child,a!==null)){u.child=null;do u=a.sibling,a.sibling=null,a=u;while(a!==null)}}function Bu(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Fn=g,C2(g,a)}w2(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)S2(a),a=a.sibling}function S2(a){switch(a.tag){case 0:case 11:case 15:Bu(a),a.flags&2048&&uo(9,a,a.return);break;case 3:Bu(a);break;case 12:Bu(a);break;case 22:var u=a.stateNode;a.memoizedState!==null&&u._visibility&2&&(a.return===null||a.return.tag!==13)?(u._visibility&=-3,dp(a)):Bu(a);break;default:Bu(a)}}function dp(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Fn=g,C2(g,a)}w2(a)}for(a=a.child;a!==null;){switch(u=a,u.tag){case 0:case 11:case 15:uo(8,u,u.return),dp(u);break;case 22:f=u.stateNode,f._visibility&2&&(f._visibility&=-3,dp(u));break;default:dp(u)}a=a.sibling}}function C2(a,u){for(;Fn!==null;){var f=Fn;switch(f.tag){case 0:case 11:case 15:uo(8,f,u);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var g=f.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Cu(f.memoizedState.cache)}if(g=f.child,g!==null)g.return=f,Fn=g;else t:for(f=a;Fn!==null;){g=Fn;var v=g.sibling,C=g.return;if(f2(g),g===f){Fn=null;break t}if(v!==null){v.return=C,Fn=v;break t}Fn=C}}}var Tz={getCacheForType:function(a){var u=Wn(fn),f=u.data.get(a);return f===void 0&&(f=a(),u.data.set(a,f)),f},cacheSignal:function(){return Wn(fn).controller.signal}},kz=typeof WeakMap=="function"?WeakMap:Map,Se=0,Oe=null,ne=null,ie=0,$e=0,Gs=null,ho=!1,Wl=!1,gb=!1,Mi=0,Ze=0,fo=0,xa=0,yb=0,Ws=0,Hl=0,Vu=null,Ns=null,bb=!1,fp=0,T2=0,pp=1/0,mp=null,po=null,En=0,mo=null,ql=null,Fi=0,xb=0,vb=null,k2=null,Uu=0,wb=null;function Hs(){return(Se&2)!==0&&ie!==0?ie&-ie:P.T!==null?Eb():VC()}function $2(){if(Ws===0)if((ie&536870912)===0||le){var a=Cf;Cf<<=1,(Cf&3932160)===0&&(Cf=262144),Ws=a}else Ws=536870912;return a=Us.current,a!==null&&(a.flags|=32),Ws}function As(a,u,f){(a===Oe&&($e===2||$e===9)||a.cancelPendingCommit!==null)&&(Kl(a,0),go(a,ie,Ws,!1)),cu(a,f),((Se&2)===0||a!==Oe)&&(a===Oe&&((Se&2)===0&&(xa|=f),Ze===4&&go(a,ie,Ws,!1)),Qr(a))}function E2(a,u,f){if((Se&6)!==0)throw Error(s(327));var g=!f&&(u&127)===0&&(u&a.expiredLanes)===0||lu(a,u),v=g?Iz(a,u):Cb(a,u,!0),C=g;do{if(v===0){Wl&&!g&&go(a,u,0,!1);break}else{if(f=a.current.alternate,C&&!$z(f)){v=Cb(a,u,!1),C=!1;continue}if(v===2){if(C=u,a.errorRecoveryDisabledLanes&C)var I=0;else I=a.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){u=I;t:{var M=a;v=Vu;var j=M.current.memoizedState.isDehydrated;if(j&&(Kl(M,I).flags|=256),I=Cb(M,I,!1),I!==2){if(gb&&!j){M.errorRecoveryDisabledLanes|=C,xa|=C,v=4;break t}C=Ns,Ns=v,C!==null&&(Ns===null?Ns=C:Ns.push.apply(Ns,C))}v=I}if(C=!1,v!==2)continue}}if(v===1){Kl(a,0),go(a,u,0,!0);break}t:{switch(g=a,C=v,C){case 0:case 1:throw Error(s(345));case 4:if((u&4194048)!==u)break;case 6:go(g,u,Ws,!ho);break t;case 2:Ns=null;break;case 3:case 5:break;default:throw Error(s(329))}if((u&62914560)===u&&(v=fp+300-me(),10<v)){if(go(g,u,Ws,!ho),kf(g,0,!0)!==0)break t;Fi=u,g.timeoutHandle=r$(I2.bind(null,g,f,Ns,mp,bb,u,Ws,xa,Hl,ho,C,"Throttled",-0,0),v);break t}I2(g,f,Ns,mp,bb,u,Ws,xa,Hl,ho,C,null,-0,0)}}break}while(!0);Qr(a)}function I2(a,u,f,g,v,C,I,M,j,at,mt,bt,ut,ht){if(a.timeoutHandle=-1,bt=u.subtreeFlags,bt&8192||(bt&16785408)===16785408){bt={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:wi},v2(u,C,bt);var It=(C&62914560)===C?fp-me():(C&4194048)===C?T2-me():0;if(It=uB(bt,It),It!==null){Fi=C,a.cancelPendingCommit=It(F2.bind(null,a,u,C,f,g,v,I,M,j,mt,bt,null,ut,ht)),go(a,C,I,!at);return}}F2(a,u,C,f,g,v,I,M,j)}function $z(a){for(var u=a;;){var f=u.tag;if((f===0||f===11||f===15)&&u.flags&16384&&(f=u.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var g=0;g<f.length;g++){var v=f[g],C=v.getSnapshot;v=v.value;try{if(!Bs(C(),v))return!1}catch{return!1}}if(f=u.child,u.subtreeFlags&16384&&f!==null)f.return=u,u=f;else{if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return!0;u=u.return}u.sibling.return=u.return,u=u.sibling}}return!0}function go(a,u,f,g){u&=~yb,u&=~xa,a.suspendedLanes|=u,a.pingedLanes&=~u,g&&(a.warmLanes|=u),g=a.expirationTimes;for(var v=u;0<v;){var C=31-zs(v),I=1<<C;g[C]=-1,v&=~I}f!==0&&PC(a,f,u)}function gp(){return(Se&6)===0?(ju(0),!1):!0}function Sb(){if(ne!==null){if($e===0)var a=ne.return;else a=ne,ki=ua=null,Py(a),Pl=null,ku=0,a=ne;for(;a!==null;)i2(a.alternate,a),a=a.return;ne=null}}function Kl(a,u){var f=a.timeoutHandle;f!==-1&&(a.timeoutHandle=-1,Hz(f)),f=a.cancelPendingCommit,f!==null&&(a.cancelPendingCommit=null,f()),Fi=0,Sb(),Oe=a,ne=f=Ci(a.current,null),ie=u,$e=0,Gs=null,ho=!1,Wl=lu(a,u),gb=!1,Hl=Ws=yb=xa=fo=Ze=0,Ns=Vu=null,bb=!1,(u&8)!==0&&(u|=u&32);var g=a.entangledLanes;if(g!==0)for(a=a.entanglements,g&=u;0<g;){var v=31-zs(g),C=1<<v;u|=a[v],g&=~C}return Mi=u,Lf(),f}function N2(a,u){Kt=null,P.H=Du,u===Ll||u===Wf?(u=WT(),$e=3):u===$y?(u=WT(),$e=4):$e=u===tb?8:u!==null&&typeof u=="object"&&typeof u.then=="function"?6:1,Gs=u,ne===null&&(Ze=1,ip(a,ir(u,a.current)))}function A2(){var a=Us.current;return a===null?!0:(ie&4194048)===ie?cr===null:(ie&62914560)===ie||(ie&536870912)!==0?a===cr:!1}function _2(){var a=P.H;return P.H=Du,a===null?Du:a}function R2(){var a=P.A;return P.A=Tz,a}function yp(){Ze=4,ho||(ie&4194048)!==ie&&Us.current!==null||(Wl=!0),(fo&134217727)===0&&(xa&134217727)===0||Oe===null||go(Oe,ie,Ws,!1)}function Cb(a,u,f){var g=Se;Se|=2;var v=_2(),C=R2();(Oe!==a||ie!==u)&&(mp=null,Kl(a,u)),u=!1;var I=Ze;t:do try{if($e!==0&&ne!==null){var M=ne,j=Gs;switch($e){case 8:Sb(),I=6;break t;case 3:case 2:case 9:case 6:Us.current===null&&(u=!0);var at=$e;if($e=0,Gs=null,Xl(a,M,j,at),f&&Wl){I=0;break t}break;default:at=$e,$e=0,Gs=null,Xl(a,M,j,at)}}Ez(),I=Ze;break}catch(mt){N2(a,mt)}while(!0);return u&&a.shellSuspendCounter++,ki=ua=null,Se=g,P.H=v,P.A=C,ne===null&&(Oe=null,ie=0,Lf()),I}function Ez(){for(;ne!==null;)D2(ne)}function Iz(a,u){var f=Se;Se|=2;var g=_2(),v=R2();Oe!==a||ie!==u?(mp=null,pp=me()+500,Kl(a,u)):Wl=lu(a,u);t:do try{if($e!==0&&ne!==null){u=ne;var C=Gs;e:switch($e){case 1:$e=0,Gs=null,Xl(a,u,C,1);break;case 2:case 9:if(jT(C)){$e=0,Gs=null,O2(u);break}u=function(){$e!==2&&$e!==9||Oe!==a||($e=7),Qr(a)},C.then(u,u);break t;case 3:$e=7;break t;case 4:$e=5;break t;case 7:jT(C)?($e=0,Gs=null,O2(u)):($e=0,Gs=null,Xl(a,u,C,7));break;case 5:var I=null;switch(ne.tag){case 26:I=ne.memoizedState;case 5:case 27:var M=ne;if(I?x$(I):M.stateNode.complete){$e=0,Gs=null;var j=M.sibling;if(j!==null)ne=j;else{var at=M.return;at!==null?(ne=at,bp(at)):ne=null}break e}}$e=0,Gs=null,Xl(a,u,C,5);break;case 6:$e=0,Gs=null,Xl(a,u,C,6);break;case 8:Sb(),Ze=6;break t;default:throw Error(s(462))}}Nz();break}catch(mt){N2(a,mt)}while(!0);return ki=ua=null,P.H=g,P.A=v,Se=f,ne!==null?0:(Oe=null,ie=0,Lf(),Ze)}function Nz(){for(;ne!==null&&!dn();)D2(ne)}function D2(a){var u=s2(a.alternate,a,Mi);a.memoizedProps=a.pendingProps,u===null?bp(a):ne=u}function O2(a){var u=a,f=u.alternate;switch(u.tag){case 15:case 0:u=Zk(f,u,u.pendingProps,u.type,void 0,ie);break;case 11:u=Zk(f,u,u.pendingProps,u.type.render,u.ref,ie);break;case 5:Py(u);default:i2(f,u),u=ne=RT(u,Mi),u=s2(f,u,Mi)}a.memoizedProps=a.pendingProps,u===null?bp(a):ne=u}function Xl(a,u,f,g){ki=ua=null,Py(u),Pl=null,ku=0;var v=u.return;try{if(yz(a,v,u,f,ie)){Ze=1,ip(a,ir(f,a.current)),ne=null;return}}catch(C){if(v!==null)throw ne=v,C;Ze=1,ip(a,ir(f,a.current)),ne=null;return}u.flags&32768?(le||g===1?a=!0:Wl||(ie&536870912)!==0?a=!1:(ho=a=!0,(g===2||g===9||g===3||g===6)&&(g=Us.current,g!==null&&g.tag===13&&(g.flags|=16384))),M2(u,a)):bp(u)}function bp(a){var u=a;do{if((u.flags&32768)!==0){M2(u,ho);return}a=u.return;var f=vz(u.alternate,u,Mi);if(f!==null){ne=f;return}if(u=u.sibling,u!==null){ne=u;return}ne=u=a}while(u!==null);Ze===0&&(Ze=5)}function M2(a,u){do{var f=wz(a.alternate,a);if(f!==null){f.flags&=32767,ne=f;return}if(f=a.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!u&&(a=a.sibling,a!==null)){ne=a;return}ne=a=f}while(a!==null);Ze=6,ne=null}function F2(a,u,f,g,v,C,I,M,j){a.cancelPendingCommit=null;do xp();while(En!==0);if((Se&6)!==0)throw Error(s(327));if(u!==null){if(u===a.current)throw Error(s(177));if(C=u.lanes|u.childLanes,C|=hy,lP(a,f,C,I,M,j),a===Oe&&(ne=Oe=null,ie=0),ql=u,mo=a,Fi=f,xb=C,vb=v,k2=g,(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,Dz(Ps,function(){return V2(),null})):(a.callbackNode=null,a.callbackPriority=0),g=(u.flags&13878)!==0,(u.subtreeFlags&13878)!==0||g){g=P.T,P.T=null,v=V.p,V.p=2,I=Se,Se|=4;try{Sz(a,u,f)}finally{Se=I,V.p=v,P.T=g}}En=1,L2(),P2(),z2()}}function L2(){if(En===1){En=0;var a=mo,u=ql,f=(u.flags&13878)!==0;if((u.subtreeFlags&13878)!==0||f){f=P.T,P.T=null;var g=V.p;V.p=2;var v=Se;Se|=4;try{y2(u,a);var C=Mb,I=CT(a.containerInfo),M=C.focusedElem,j=C.selectionRange;if(I!==M&&M&&M.ownerDocument&&ST(M.ownerDocument.documentElement,M)){if(j!==null&&oy(M)){var at=j.start,mt=j.end;if(mt===void 0&&(mt=at),"selectionStart"in M)M.selectionStart=at,M.selectionEnd=Math.min(mt,M.value.length);else{var bt=M.ownerDocument||document,ut=bt&&bt.defaultView||window;if(ut.getSelection){var ht=ut.getSelection(),It=M.textContent.length,zt=Math.min(j.start,It),Re=j.end===void 0?zt:Math.min(j.end,It);!ht.extend&&zt>Re&&(I=Re,Re=zt,zt=I);var st=wT(M,zt),K=wT(M,Re);if(st&&K&&(ht.rangeCount!==1||ht.anchorNode!==st.node||ht.anchorOffset!==st.offset||ht.focusNode!==K.node||ht.focusOffset!==K.offset)){var ot=bt.createRange();ot.setStart(st.node,st.offset),ht.removeAllRanges(),zt>Re?(ht.addRange(ot),ht.extend(K.node,K.offset)):(ot.setEnd(K.node,K.offset),ht.addRange(ot))}}}}for(bt=[],ht=M;ht=ht.parentNode;)ht.nodeType===1&&bt.push({element:ht,left:ht.scrollLeft,top:ht.scrollTop});for(typeof M.focus=="function"&&M.focus(),M=0;M<bt.length;M++){var yt=bt[M];yt.element.scrollLeft=yt.left,yt.element.scrollTop=yt.top}}_p=!!Ob,Mb=Ob=null}finally{Se=v,V.p=g,P.T=f}}a.current=u,En=2}}function P2(){if(En===2){En=0;var a=mo,u=ql,f=(u.flags&8772)!==0;if((u.subtreeFlags&8772)!==0||f){f=P.T,P.T=null;var g=V.p;V.p=2;var v=Se;Se|=4;try{d2(a,u.alternate,u)}finally{Se=v,V.p=g,P.T=f}}En=3}}function z2(){if(En===4||En===3){En=0,ds();var a=mo,u=ql,f=Fi,g=k2;(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?En=5:(En=0,ql=mo=null,B2(a,a.pendingLanes));var v=a.pendingLanes;if(v===0&&(po=null),V0(f),u=u.stateNode,fs&&typeof fs.onCommitFiberRoot=="function")try{fs.onCommitFiberRoot(Kr,u,void 0,(u.current.flags&128)===128)}catch{}if(g!==null){u=P.T,v=V.p,V.p=2,P.T=null;try{for(var C=a.onRecoverableError,I=0;I<g.length;I++){var M=g[I];C(M.value,{componentStack:M.stack})}}finally{P.T=u,V.p=v}}(Fi&3)!==0&&xp(),Qr(a),v=a.pendingLanes,(f&261930)!==0&&(v&42)!==0?a===wb?Uu++:(Uu=0,wb=a):Uu=0,ju(0)}}function B2(a,u){(a.pooledCacheLanes&=u)===0&&(u=a.pooledCache,u!=null&&(a.pooledCache=null,Cu(u)))}function xp(){return L2(),P2(),z2(),V2()}function V2(){if(En!==5)return!1;var a=mo,u=xb;xb=0;var f=V0(Fi),g=P.T,v=V.p;try{V.p=32>f?32:f,P.T=null,f=vb,vb=null;var C=mo,I=Fi;if(En=0,ql=mo=null,Fi=0,(Se&6)!==0)throw Error(s(331));var M=Se;if(Se|=4,S2(C.current),x2(C,C.current,I,f),Se=M,ju(0,!1),fs&&typeof fs.onPostCommitFiberRoot=="function")try{fs.onPostCommitFiberRoot(Kr,C)}catch{}return!0}finally{V.p=v,P.T=g,B2(a,u)}}function U2(a,u,f){u=ir(f,u),u=Qy(a.stateNode,u,2),a=ao(a,u,2),a!==null&&(cu(a,2),Qr(a))}function Ee(a,u,f){if(a.tag===3)U2(a,a,f);else for(;u!==null;){if(u.tag===3){U2(u,a,f);break}else if(u.tag===1){var g=u.stateNode;if(typeof u.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(po===null||!po.has(g))){a=ir(f,a),f=jk(2),g=ao(u,f,2),g!==null&&(Gk(f,g,u,a),cu(g,2),Qr(g));break}}u=u.return}}function Tb(a,u,f){var g=a.pingCache;if(g===null){g=a.pingCache=new kz;var v=new Set;g.set(u,v)}else v=g.get(u),v===void 0&&(v=new Set,g.set(u,v));v.has(f)||(gb=!0,v.add(f),a=Az.bind(null,a,u,f),u.then(a,a))}function Az(a,u,f){var g=a.pingCache;g!==null&&g.delete(u),a.pingedLanes|=a.suspendedLanes&f,a.warmLanes&=~f,Oe===a&&(ie&f)===f&&(Ze===4||Ze===3&&(ie&62914560)===ie&&300>me()-fp?(Se&2)===0&&Kl(a,0):yb|=f,Hl===ie&&(Hl=0)),Qr(a)}function j2(a,u){u===0&&(u=LC()),a=aa(a,u),a!==null&&(cu(a,u),Qr(a))}function _z(a){var u=a.memoizedState,f=0;u!==null&&(f=u.retryLane),j2(a,f)}function Rz(a,u){var f=0;switch(a.tag){case 31:case 13:var g=a.stateNode,v=a.memoizedState;v!==null&&(f=v.retryLane);break;case 19:g=a.stateNode;break;case 22:g=a.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(u),j2(a,f)}function Dz(a,u){return Jt(a,u)}var vp=null,Yl=null,kb=!1,wp=!1,$b=!1,yo=0;function Qr(a){a!==Yl&&a.next===null&&(Yl===null?vp=Yl=a:Yl=Yl.next=a),wp=!0,kb||(kb=!0,Mz())}function ju(a,u){if(!$b&&wp){$b=!0;do for(var f=!1,g=vp;g!==null;){if(a!==0){var v=g.pendingLanes;if(v===0)var C=0;else{var I=g.suspendedLanes,M=g.pingedLanes;C=(1<<31-zs(42|a)+1)-1,C&=v&~(I&~M),C=C&201326741?C&201326741|1:C?C|2:0}C!==0&&(f=!0,q2(g,C))}else C=ie,C=kf(g,g===Oe?C:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(C&3)===0||lu(g,C)||(f=!0,q2(g,C));g=g.next}while(f);$b=!1}}function Oz(){G2()}function G2(){wp=kb=!1;var a=0;yo!==0&&Wz()&&(a=yo);for(var u=me(),f=null,g=vp;g!==null;){var v=g.next,C=W2(g,u);C===0?(g.next=null,f===null?vp=v:f.next=v,v===null&&(Yl=f)):(f=g,(a!==0||(C&3)!==0)&&(wp=!0)),g=v}En!==0&&En!==5||ju(a),yo!==0&&(yo=0)}function W2(a,u){for(var f=a.suspendedLanes,g=a.pingedLanes,v=a.expirationTimes,C=a.pendingLanes&-62914561;0<C;){var I=31-zs(C),M=1<<I,j=v[I];j===-1?((M&f)===0||(M&g)!==0)&&(v[I]=aP(M,u)):j<=u&&(a.expiredLanes|=M),C&=~M}if(u=Oe,f=ie,f=kf(a,a===u?f:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g=a.callbackNode,f===0||a===u&&($e===2||$e===9)||a.cancelPendingCommit!==null)return g!==null&&g!==null&&$n(g),a.callbackNode=null,a.callbackPriority=0;if((f&3)===0||lu(a,f)){if(u=f&-f,u===a.callbackPriority)return u;switch(g!==null&&$n(g),V0(f)){case 2:case 8:f=Er;break;case 32:f=Ps;break;case 268435456:f=gl;break;default:f=Ps}return g=H2.bind(null,a),f=Jt(f,g),a.callbackPriority=u,a.callbackNode=f,u}return g!==null&&g!==null&&$n(g),a.callbackPriority=2,a.callbackNode=null,2}function H2(a,u){if(En!==0&&En!==5)return a.callbackNode=null,a.callbackPriority=0,null;var f=a.callbackNode;if(xp()&&a.callbackNode!==f)return null;var g=ie;return g=kf(a,a===Oe?g:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g===0?null:(E2(a,g,u),W2(a,me()),a.callbackNode!=null&&a.callbackNode===f?H2.bind(null,a):null)}function q2(a,u){if(xp())return null;E2(a,u,!0)}function Mz(){qz(function(){(Se&6)!==0?Jt(Un,Oz):G2()})}function Eb(){if(yo===0){var a=Ml;a===0&&(a=Sf,Sf<<=1,(Sf&261888)===0&&(Sf=256)),yo=a}return yo}function K2(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:Nf(""+a)}function X2(a,u){var f=u.ownerDocument.createElement("input");return f.name=u.name,f.value=u.value,a.id&&f.setAttribute("form",a.id),u.parentNode.insertBefore(f,u),a=new FormData(a),f.parentNode.removeChild(f),a}function Fz(a,u,f,g,v){if(u==="submit"&&f&&f.stateNode===v){var C=K2((v[Ts]||null).action),I=g.submitter;I&&(u=(u=I[Ts]||null)?K2(u.formAction):I.getAttribute("formAction"),u!==null&&(C=u,I=null));var M=new Df("action","action",null,g,v);a.push({event:M,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(yo!==0){var j=I?X2(v,I):new FormData(v);qy(f,{pending:!0,data:j,method:v.method,action:C},null,j)}}else typeof C=="function"&&(M.preventDefault(),j=I?X2(v,I):new FormData(v),qy(f,{pending:!0,data:j,method:v.method,action:C},C,j))},currentTarget:v}]})}}for(var Ib=0;Ib<uy.length;Ib++){var Nb=uy[Ib],Lz=Nb.toLowerCase(),Pz=Nb[0].toUpperCase()+Nb.slice(1);Ir(Lz,"on"+Pz)}Ir($T,"onAnimationEnd"),Ir(ET,"onAnimationIteration"),Ir(IT,"onAnimationStart"),Ir("dblclick","onDoubleClick"),Ir("focusin","onFocus"),Ir("focusout","onBlur"),Ir(tz,"onTransitionRun"),Ir(ez,"onTransitionStart"),Ir(nz,"onTransitionCancel"),Ir(NT,"onTransitionEnd"),wl("onMouseEnter",["mouseout","mouseover"]),wl("onMouseLeave",["mouseout","mouseover"]),wl("onPointerEnter",["pointerout","pointerover"]),wl("onPointerLeave",["pointerout","pointerover"]),sa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),sa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),sa("onBeforeInput",["compositionend","keypress","textInput","paste"]),sa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),sa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),sa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Gu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),zz=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Gu));function Y2(a,u){u=(u&4)!==0;for(var f=0;f<a.length;f++){var g=a[f],v=g.event;g=g.listeners;t:{var C=void 0;if(u)for(var I=g.length-1;0<=I;I--){var M=g[I],j=M.instance,at=M.currentTarget;if(M=M.listener,j!==C&&v.isPropagationStopped())break t;C=M,v.currentTarget=at;try{C(v)}catch(mt){Ff(mt)}v.currentTarget=null,C=j}else for(I=0;I<g.length;I++){if(M=g[I],j=M.instance,at=M.currentTarget,M=M.listener,j!==C&&v.isPropagationStopped())break t;C=M,v.currentTarget=at;try{C(v)}catch(mt){Ff(mt)}v.currentTarget=null,C=j}}}}function se(a,u){var f=u[U0];f===void 0&&(f=u[U0]=new Set);var g=a+"__bubble";f.has(g)||(Z2(u,a,2,!1),f.add(g))}function Ab(a,u,f){var g=0;u&&(g|=4),Z2(f,a,g,u)}var Sp="_reactListening"+Math.random().toString(36).slice(2);function _b(a){if(!a[Sp]){a[Sp]=!0,GC.forEach(function(f){f!=="selectionchange"&&(zz.has(f)||Ab(f,!1,a),Ab(f,!0,a))});var u=a.nodeType===9?a:a.ownerDocument;u===null||u[Sp]||(u[Sp]=!0,Ab("selectionchange",!1,u))}}function Z2(a,u,f,g){switch($$(u)){case 2:var v=fB;break;case 8:v=pB;break;default:v=Hb}f=v.bind(null,u,f,a),v=void 0,!Z0||u!=="touchstart"&&u!=="touchmove"&&u!=="wheel"||(v=!0),g?v!==void 0?a.addEventListener(u,f,{capture:!0,passive:v}):a.addEventListener(u,f,!0):v!==void 0?a.addEventListener(u,f,{passive:v}):a.addEventListener(u,f,!1)}function Rb(a,u,f,g,v){var C=g;if((u&1)===0&&(u&2)===0&&g!==null)t:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var M=g.stateNode.containerInfo;if(M===v)break;if(I===4)for(I=g.return;I!==null;){var j=I.tag;if((j===3||j===4)&&I.stateNode.containerInfo===v)return;I=I.return}for(;M!==null;){if(I=bl(M),I===null)return;if(j=I.tag,j===5||j===6||j===26||j===27){g=C=I;continue t}M=M.parentNode}}g=g.return}nT(function(){var at=C,mt=X0(f),bt=[];t:{var ut=AT.get(a);if(ut!==void 0){var ht=Df,It=a;switch(a){case"keypress":if(_f(f)===0)break t;case"keydown":case"keyup":ht=RP;break;case"focusin":It="focus",ht=ey;break;case"focusout":It="blur",ht=ey;break;case"beforeblur":case"afterblur":ht=ey;break;case"click":if(f.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ht=iT;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ht=vP;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ht=MP;break;case $T:case ET:case IT:ht=CP;break;case NT:ht=LP;break;case"scroll":case"scrollend":ht=bP;break;case"wheel":ht=zP;break;case"copy":case"cut":case"paste":ht=kP;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ht=aT;break;case"toggle":case"beforetoggle":ht=VP}var zt=(u&4)!==0,Re=!zt&&(a==="scroll"||a==="scrollend"),st=zt?ut!==null?ut+"Capture":null:ut;zt=[];for(var K=at,ot;K!==null;){var yt=K;if(ot=yt.stateNode,yt=yt.tag,yt!==5&&yt!==26&&yt!==27||ot===null||st===null||(yt=du(K,st),yt!=null&&zt.push(Wu(K,yt,ot))),Re)break;K=K.return}0<zt.length&&(ut=new ht(ut,It,null,f,mt),bt.push({event:ut,listeners:zt}))}}if((u&7)===0){t:{if(ut=a==="mouseover"||a==="pointerover",ht=a==="mouseout"||a==="pointerout",ut&&f!==K0&&(It=f.relatedTarget||f.fromElement)&&(bl(It)||It[yl]))break t;if((ht||ut)&&(ut=mt.window===mt?mt:(ut=mt.ownerDocument)?ut.defaultView||ut.parentWindow:window,ht?(It=f.relatedTarget||f.toElement,ht=at,It=It?bl(It):null,It!==null&&(Re=i(It),zt=It.tag,It!==Re||zt!==5&&zt!==27&&zt!==6)&&(It=null)):(ht=null,It=at),ht!==It)){if(zt=iT,yt="onMouseLeave",st="onMouseEnter",K="mouse",(a==="pointerout"||a==="pointerover")&&(zt=aT,yt="onPointerLeave",st="onPointerEnter",K="pointer"),Re=ht==null?ut:hu(ht),ot=It==null?ut:hu(It),ut=new zt(yt,K+"leave",ht,f,mt),ut.target=Re,ut.relatedTarget=ot,yt=null,bl(mt)===at&&(zt=new zt(st,K+"enter",It,f,mt),zt.target=ot,zt.relatedTarget=Re,yt=zt),Re=yt,ht&&It)e:{for(zt=Bz,st=ht,K=It,ot=0,yt=st;yt;yt=zt(yt))ot++;yt=0;for(var Ft=K;Ft;Ft=zt(Ft))yt++;for(;0<ot-yt;)st=zt(st),ot--;for(;0<yt-ot;)K=zt(K),yt--;for(;ot--;){if(st===K||K!==null&&st===K.alternate){zt=st;break e}st=zt(st),K=zt(K)}zt=null}else zt=null;ht!==null&&J2(bt,ut,ht,zt,!1),It!==null&&Re!==null&&J2(bt,Re,It,zt,!0)}}t:{if(ut=at?hu(at):window,ht=ut.nodeName&&ut.nodeName.toLowerCase(),ht==="select"||ht==="input"&&ut.type==="file")var ye=mT;else if(fT(ut))if(gT)ye=ZP;else{ye=XP;var _t=KP}else ht=ut.nodeName,!ht||ht.toLowerCase()!=="input"||ut.type!=="checkbox"&&ut.type!=="radio"?at&&q0(at.elementType)&&(ye=mT):ye=YP;if(ye&&(ye=ye(a,at))){pT(bt,ye,f,mt);break t}_t&&_t(a,ut,at),a==="focusout"&&at&&ut.type==="number"&&at.memoizedProps.value!=null&&H0(ut,"number",ut.value)}switch(_t=at?hu(at):window,a){case"focusin":(fT(_t)||_t.contentEditable==="true")&&(El=_t,ay=at,vu=null);break;case"focusout":vu=ay=El=null;break;case"mousedown":ly=!0;break;case"contextmenu":case"mouseup":case"dragend":ly=!1,TT(bt,f,mt);break;case"selectionchange":if(QP)break;case"keydown":case"keyup":TT(bt,f,mt)}var Yt;if(sy)t:{switch(a){case"compositionstart":var oe="onCompositionStart";break t;case"compositionend":oe="onCompositionEnd";break t;case"compositionupdate":oe="onCompositionUpdate";break t}oe=void 0}else $l?hT(a,f)&&(oe="onCompositionEnd"):a==="keydown"&&f.keyCode===229&&(oe="onCompositionStart");oe&&(lT&&f.locale!=="ko"&&($l||oe!=="onCompositionStart"?oe==="onCompositionEnd"&&$l&&(Yt=sT()):(to=mt,J0="value"in to?to.value:to.textContent,$l=!0)),_t=Cp(at,oe),0<_t.length&&(oe=new oT(oe,a,null,f,mt),bt.push({event:oe,listeners:_t}),Yt?oe.data=Yt:(Yt=dT(f),Yt!==null&&(oe.data=Yt)))),(Yt=jP?GP(a,f):WP(a,f))&&(oe=Cp(at,"onBeforeInput"),0<oe.length&&(_t=new oT("onBeforeInput","beforeinput",null,f,mt),bt.push({event:_t,listeners:oe}),_t.data=Yt)),Fz(bt,a,at,f,mt)}Y2(bt,u)})}function Wu(a,u,f){return{instance:a,listener:u,currentTarget:f}}function Cp(a,u){for(var f=u+"Capture",g=[];a!==null;){var v=a,C=v.stateNode;if(v=v.tag,v!==5&&v!==26&&v!==27||C===null||(v=du(a,f),v!=null&&g.unshift(Wu(a,v,C)),v=du(a,u),v!=null&&g.push(Wu(a,v,C))),a.tag===3)return g;a=a.return}return[]}function Bz(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function J2(a,u,f,g,v){for(var C=u._reactName,I=[];f!==null&&f!==g;){var M=f,j=M.alternate,at=M.stateNode;if(M=M.tag,j!==null&&j===g)break;M!==5&&M!==26&&M!==27||at===null||(j=at,v?(at=du(f,C),at!=null&&I.unshift(Wu(f,at,j))):v||(at=du(f,C),at!=null&&I.push(Wu(f,at,j)))),f=f.return}I.length!==0&&a.push({event:u,listeners:I})}var Vz=/\r\n?/g,Uz=/\u0000|\uFFFD/g;function Q2(a){return(typeof a=="string"?a:""+a).replace(Vz,`
`).replace(Uz,"")}function t$(a,u){return u=Q2(u),Q2(a)===u}function _e(a,u,f,g,v,C){switch(f){case"children":typeof g=="string"?u==="body"||u==="textarea"&&g===""||Cl(a,g):(typeof g=="number"||typeof g=="bigint")&&u!=="body"&&Cl(a,""+g);break;case"className":Ef(a,"class",g);break;case"tabIndex":Ef(a,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":Ef(a,f,g);break;case"style":tT(a,g,C);break;case"data":if(u!=="object"){Ef(a,"data",g);break}case"src":case"href":if(g===""&&(u!=="a"||f!=="href")){a.removeAttribute(f);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=Nf(""+g),a.setAttribute(f,g);break;case"action":case"formAction":if(typeof g=="function"){a.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof C=="function"&&(f==="formAction"?(u!=="input"&&_e(a,u,"name",v.name,v,null),_e(a,u,"formEncType",v.formEncType,v,null),_e(a,u,"formMethod",v.formMethod,v,null),_e(a,u,"formTarget",v.formTarget,v,null)):(_e(a,u,"encType",v.encType,v,null),_e(a,u,"method",v.method,v,null),_e(a,u,"target",v.target,v,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=Nf(""+g),a.setAttribute(f,g);break;case"onClick":g!=null&&(a.onclick=wi);break;case"onScroll":g!=null&&se("scroll",a);break;case"onScrollEnd":g!=null&&se("scrollend",a);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"multiple":a.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":a.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){a.removeAttribute("xlink:href");break}f=Nf(""+g),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""+g):a.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""):a.removeAttribute(f);break;case"capture":case"download":g===!0?a.setAttribute(f,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,g):a.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?a.setAttribute(f,g):a.removeAttribute(f);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?a.removeAttribute(f):a.setAttribute(f,g);break;case"popover":se("beforetoggle",a),se("toggle",a),$f(a,"popover",g);break;case"xlinkActuate":vi(a,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":vi(a,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":vi(a,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":vi(a,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":vi(a,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":vi(a,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":vi(a,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":vi(a,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":vi(a,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":$f(a,"is",g);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=gP.get(f)||f,$f(a,f,g))}}function Db(a,u,f,g,v,C){switch(f){case"style":tT(a,g,C);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"children":typeof g=="string"?Cl(a,g):(typeof g=="number"||typeof g=="bigint")&&Cl(a,""+g);break;case"onScroll":g!=null&&se("scroll",a);break;case"onScrollEnd":g!=null&&se("scrollend",a);break;case"onClick":g!=null&&(a.onclick=wi);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!WC.hasOwnProperty(f))t:{if(f[0]==="o"&&f[1]==="n"&&(v=f.endsWith("Capture"),u=f.slice(2,v?f.length-7:void 0),C=a[Ts]||null,C=C!=null?C[f]:null,typeof C=="function"&&a.removeEventListener(u,C,v),typeof g=="function")){typeof C!="function"&&C!==null&&(f in a?a[f]=null:a.hasAttribute(f)&&a.removeAttribute(f)),a.addEventListener(u,g,v);break t}f in a?a[f]=g:g===!0?a.setAttribute(f,""):$f(a,f,g)}}}function qn(a,u,f){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":se("error",a),se("load",a);var g=!1,v=!1,C;for(C in f)if(f.hasOwnProperty(C)){var I=f[C];if(I!=null)switch(C){case"src":g=!0;break;case"srcSet":v=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:_e(a,u,C,I,f,null)}}v&&_e(a,u,"srcSet",f.srcSet,f,null),g&&_e(a,u,"src",f.src,f,null);return;case"input":se("invalid",a);var M=C=I=v=null,j=null,at=null;for(g in f)if(f.hasOwnProperty(g)){var mt=f[g];if(mt!=null)switch(g){case"name":v=mt;break;case"type":I=mt;break;case"checked":j=mt;break;case"defaultChecked":at=mt;break;case"value":C=mt;break;case"defaultValue":M=mt;break;case"children":case"dangerouslySetInnerHTML":if(mt!=null)throw Error(s(137,u));break;default:_e(a,u,g,mt,f,null)}}YC(a,C,M,j,at,I,v,!1);return;case"select":se("invalid",a),g=I=C=null;for(v in f)if(f.hasOwnProperty(v)&&(M=f[v],M!=null))switch(v){case"value":C=M;break;case"defaultValue":I=M;break;case"multiple":g=M;default:_e(a,u,v,M,f,null)}u=C,f=I,a.multiple=!!g,u!=null?Sl(a,!!g,u,!1):f!=null&&Sl(a,!!g,f,!0);return;case"textarea":se("invalid",a),C=v=g=null;for(I in f)if(f.hasOwnProperty(I)&&(M=f[I],M!=null))switch(I){case"value":g=M;break;case"defaultValue":v=M;break;case"children":C=M;break;case"dangerouslySetInnerHTML":if(M!=null)throw Error(s(91));break;default:_e(a,u,I,M,f,null)}JC(a,g,v,C);return;case"option":for(j in f)f.hasOwnProperty(j)&&(g=f[j],g!=null)&&(j==="selected"?a.selected=g&&typeof g!="function"&&typeof g!="symbol":_e(a,u,j,g,f,null));return;case"dialog":se("beforetoggle",a),se("toggle",a),se("cancel",a),se("close",a);break;case"iframe":case"object":se("load",a);break;case"video":case"audio":for(g=0;g<Gu.length;g++)se(Gu[g],a);break;case"image":se("error",a),se("load",a);break;case"details":se("toggle",a);break;case"embed":case"source":case"link":se("error",a),se("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(at in f)if(f.hasOwnProperty(at)&&(g=f[at],g!=null))switch(at){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:_e(a,u,at,g,f,null)}return;default:if(q0(u)){for(mt in f)f.hasOwnProperty(mt)&&(g=f[mt],g!==void 0&&Db(a,u,mt,g,f,void 0));return}}for(M in f)f.hasOwnProperty(M)&&(g=f[M],g!=null&&_e(a,u,M,g,f,null))}function jz(a,u,f,g){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var v=null,C=null,I=null,M=null,j=null,at=null,mt=null;for(ht in f){var bt=f[ht];if(f.hasOwnProperty(ht)&&bt!=null)switch(ht){case"checked":break;case"value":break;case"defaultValue":j=bt;default:g.hasOwnProperty(ht)||_e(a,u,ht,null,g,bt)}}for(var ut in g){var ht=g[ut];if(bt=f[ut],g.hasOwnProperty(ut)&&(ht!=null||bt!=null))switch(ut){case"type":C=ht;break;case"name":v=ht;break;case"checked":at=ht;break;case"defaultChecked":mt=ht;break;case"value":I=ht;break;case"defaultValue":M=ht;break;case"children":case"dangerouslySetInnerHTML":if(ht!=null)throw Error(s(137,u));break;default:ht!==bt&&_e(a,u,ut,ht,g,bt)}}W0(a,I,M,j,at,mt,C,v);return;case"select":ht=I=M=ut=null;for(C in f)if(j=f[C],f.hasOwnProperty(C)&&j!=null)switch(C){case"value":break;case"multiple":ht=j;default:g.hasOwnProperty(C)||_e(a,u,C,null,g,j)}for(v in g)if(C=g[v],j=f[v],g.hasOwnProperty(v)&&(C!=null||j!=null))switch(v){case"value":ut=C;break;case"defaultValue":M=C;break;case"multiple":I=C;default:C!==j&&_e(a,u,v,C,g,j)}u=M,f=I,g=ht,ut!=null?Sl(a,!!f,ut,!1):!!g!=!!f&&(u!=null?Sl(a,!!f,u,!0):Sl(a,!!f,f?[]:"",!1));return;case"textarea":ht=ut=null;for(M in f)if(v=f[M],f.hasOwnProperty(M)&&v!=null&&!g.hasOwnProperty(M))switch(M){case"value":break;case"children":break;default:_e(a,u,M,null,g,v)}for(I in g)if(v=g[I],C=f[I],g.hasOwnProperty(I)&&(v!=null||C!=null))switch(I){case"value":ut=v;break;case"defaultValue":ht=v;break;case"children":break;case"dangerouslySetInnerHTML":if(v!=null)throw Error(s(91));break;default:v!==C&&_e(a,u,I,v,g,C)}ZC(a,ut,ht);return;case"option":for(var It in f)ut=f[It],f.hasOwnProperty(It)&&ut!=null&&!g.hasOwnProperty(It)&&(It==="selected"?a.selected=!1:_e(a,u,It,null,g,ut));for(j in g)ut=g[j],ht=f[j],g.hasOwnProperty(j)&&ut!==ht&&(ut!=null||ht!=null)&&(j==="selected"?a.selected=ut&&typeof ut!="function"&&typeof ut!="symbol":_e(a,u,j,ut,g,ht));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var zt in f)ut=f[zt],f.hasOwnProperty(zt)&&ut!=null&&!g.hasOwnProperty(zt)&&_e(a,u,zt,null,g,ut);for(at in g)if(ut=g[at],ht=f[at],g.hasOwnProperty(at)&&ut!==ht&&(ut!=null||ht!=null))switch(at){case"children":case"dangerouslySetInnerHTML":if(ut!=null)throw Error(s(137,u));break;default:_e(a,u,at,ut,g,ht)}return;default:if(q0(u)){for(var Re in f)ut=f[Re],f.hasOwnProperty(Re)&&ut!==void 0&&!g.hasOwnProperty(Re)&&Db(a,u,Re,void 0,g,ut);for(mt in g)ut=g[mt],ht=f[mt],!g.hasOwnProperty(mt)||ut===ht||ut===void 0&&ht===void 0||Db(a,u,mt,ut,g,ht);return}}for(var st in f)ut=f[st],f.hasOwnProperty(st)&&ut!=null&&!g.hasOwnProperty(st)&&_e(a,u,st,null,g,ut);for(bt in g)ut=g[bt],ht=f[bt],!g.hasOwnProperty(bt)||ut===ht||ut==null&&ht==null||_e(a,u,bt,ut,g,ht)}function e$(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function Gz(){if(typeof performance.getEntriesByType=="function"){for(var a=0,u=0,f=performance.getEntriesByType("resource"),g=0;g<f.length;g++){var v=f[g],C=v.transferSize,I=v.initiatorType,M=v.duration;if(C&&M&&e$(I)){for(I=0,M=v.responseEnd,g+=1;g<f.length;g++){var j=f[g],at=j.startTime;if(at>M)break;var mt=j.transferSize,bt=j.initiatorType;mt&&e$(bt)&&(j=j.responseEnd,I+=mt*(j<M?1:(M-at)/(j-at)))}if(--g,u+=8*(C+I)/(v.duration/1e3),a++,10<a)break}}if(0<a)return u/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var Ob=null,Mb=null;function Tp(a){return a.nodeType===9?a:a.ownerDocument}function n$(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function s$(a,u){if(a===0)switch(u){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&u==="foreignObject"?0:a}function Fb(a,u){return a==="textarea"||a==="noscript"||typeof u.children=="string"||typeof u.children=="number"||typeof u.children=="bigint"||typeof u.dangerouslySetInnerHTML=="object"&&u.dangerouslySetInnerHTML!==null&&u.dangerouslySetInnerHTML.__html!=null}var Lb=null;function Wz(){var a=window.event;return a&&a.type==="popstate"?a===Lb?!1:(Lb=a,!0):(Lb=null,!1)}var r$=typeof setTimeout=="function"?setTimeout:void 0,Hz=typeof clearTimeout=="function"?clearTimeout:void 0,i$=typeof Promise=="function"?Promise:void 0,qz=typeof queueMicrotask=="function"?queueMicrotask:typeof i$<"u"?function(a){return i$.resolve(null).then(a).catch(Kz)}:r$;function Kz(a){setTimeout(function(){throw a})}function bo(a){return a==="head"}function o$(a,u){var f=u,g=0;do{var v=f.nextSibling;if(a.removeChild(f),v&&v.nodeType===8)if(f=v.data,f==="/$"||f==="/&"){if(g===0){a.removeChild(v),tc(u);return}g--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")g++;else if(f==="html")Hu(a.ownerDocument.documentElement);else if(f==="head"){f=a.ownerDocument.head,Hu(f);for(var C=f.firstChild;C;){var I=C.nextSibling,M=C.nodeName;C[uu]||M==="SCRIPT"||M==="STYLE"||M==="LINK"&&C.rel.toLowerCase()==="stylesheet"||f.removeChild(C),C=I}}else f==="body"&&Hu(a.ownerDocument.body);f=v}while(f);tc(u)}function a$(a,u){var f=a;a=0;do{var g=f.nextSibling;if(f.nodeType===1?u?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(u?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),g&&g.nodeType===8)if(f=g.data,f==="/$"){if(a===0)break;a--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||a++;f=g}while(f)}function Pb(a){var u=a.firstChild;for(u&&u.nodeType===10&&(u=u.nextSibling);u;){var f=u;switch(u=u.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":Pb(f),j0(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}a.removeChild(f)}}function Xz(a,u,f,g){for(;a.nodeType===1;){var v=f;if(a.nodeName.toLowerCase()!==u.toLowerCase()){if(!g&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(g){if(!a[uu])switch(u){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(C=a.getAttribute("rel"),C==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(C!==v.rel||a.getAttribute("href")!==(v.href==null||v.href===""?null:v.href)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin)||a.getAttribute("title")!==(v.title==null?null:v.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(C=a.getAttribute("src"),(C!==(v.src==null?null:v.src)||a.getAttribute("type")!==(v.type==null?null:v.type)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin))&&C&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(u==="input"&&a.type==="hidden"){var C=v.name==null?null:""+v.name;if(v.type==="hidden"&&a.getAttribute("name")===C)return a}else return a;if(a=ur(a.nextSibling),a===null)break}return null}function Yz(a,u,f){if(u==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!f||(a=ur(a.nextSibling),a===null))return null;return a}function l$(a,u){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!u||(a=ur(a.nextSibling),a===null))return null;return a}function zb(a){return a.data==="$?"||a.data==="$~"}function Bb(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function Zz(a,u){var f=a.ownerDocument;if(a.data==="$~")a._reactRetry=u;else if(a.data!=="$?"||f.readyState!=="loading")u();else{var g=function(){u(),f.removeEventListener("DOMContentLoaded",g)};f.addEventListener("DOMContentLoaded",g),a._reactRetry=g}}function ur(a){for(;a!=null;a=a.nextSibling){var u=a.nodeType;if(u===1||u===3)break;if(u===8){if(u=a.data,u==="$"||u==="$!"||u==="$?"||u==="$~"||u==="&"||u==="F!"||u==="F")break;if(u==="/$"||u==="/&")return null}}return a}var Vb=null;function c$(a){a=a.nextSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="/$"||f==="/&"){if(u===0)return ur(a.nextSibling);u--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||u++}a=a.nextSibling}return null}function u$(a){a=a.previousSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(u===0)return a;u--}else f!=="/$"&&f!=="/&"||u++}a=a.previousSibling}return null}function h$(a,u,f){switch(u=Tp(f),a){case"html":if(a=u.documentElement,!a)throw Error(s(452));return a;case"head":if(a=u.head,!a)throw Error(s(453));return a;case"body":if(a=u.body,!a)throw Error(s(454));return a;default:throw Error(s(451))}}function Hu(a){for(var u=a.attributes;u.length;)a.removeAttributeNode(u[0]);j0(a)}var hr=new Map,d$=new Set;function kp(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var Li=V.d;V.d={f:Jz,r:Qz,D:tB,C:eB,L:nB,m:sB,X:iB,S:rB,M:oB};function Jz(){var a=Li.f(),u=gp();return a||u}function Qz(a){var u=xl(a);u!==null&&u.tag===5&&u.type==="form"?Nk(u):Li.r(a)}var Zl=typeof document>"u"?null:document;function f$(a,u,f){var g=Zl;if(g&&typeof u=="string"&&u){var v=sr(u);v='link[rel="'+a+'"][href="'+v+'"]',typeof f=="string"&&(v+='[crossorigin="'+f+'"]'),d$.has(v)||(d$.add(v),a={rel:a,crossOrigin:f,href:u},g.querySelector(v)===null&&(u=g.createElement("link"),qn(u,"link",a),Mn(u),g.head.appendChild(u)))}}function tB(a){Li.D(a),f$("dns-prefetch",a,null)}function eB(a,u){Li.C(a,u),f$("preconnect",a,u)}function nB(a,u,f){Li.L(a,u,f);var g=Zl;if(g&&a&&u){var v='link[rel="preload"][as="'+sr(u)+'"]';u==="image"&&f&&f.imageSrcSet?(v+='[imagesrcset="'+sr(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(v+='[imagesizes="'+sr(f.imageSizes)+'"]')):v+='[href="'+sr(a)+'"]';var C=v;switch(u){case"style":C=Jl(a);break;case"script":C=Ql(a)}hr.has(C)||(a=p({rel:"preload",href:u==="image"&&f&&f.imageSrcSet?void 0:a,as:u},f),hr.set(C,a),g.querySelector(v)!==null||u==="style"&&g.querySelector(qu(C))||u==="script"&&g.querySelector(Ku(C))||(u=g.createElement("link"),qn(u,"link",a),Mn(u),g.head.appendChild(u)))}}function sB(a,u){Li.m(a,u);var f=Zl;if(f&&a){var g=u&&typeof u.as=="string"?u.as:"script",v='link[rel="modulepreload"][as="'+sr(g)+'"][href="'+sr(a)+'"]',C=v;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":C=Ql(a)}if(!hr.has(C)&&(a=p({rel:"modulepreload",href:a},u),hr.set(C,a),f.querySelector(v)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(Ku(C)))return}g=f.createElement("link"),qn(g,"link",a),Mn(g),f.head.appendChild(g)}}}function rB(a,u,f){Li.S(a,u,f);var g=Zl;if(g&&a){var v=vl(g).hoistableStyles,C=Jl(a);u=u||"default";var I=v.get(C);if(!I){var M={loading:0,preload:null};if(I=g.querySelector(qu(C)))M.loading=5;else{a=p({rel:"stylesheet",href:a,"data-precedence":u},f),(f=hr.get(C))&&Ub(a,f);var j=I=g.createElement("link");Mn(j),qn(j,"link",a),j._p=new Promise(function(at,mt){j.onload=at,j.onerror=mt}),j.addEventListener("load",function(){M.loading|=1}),j.addEventListener("error",function(){M.loading|=2}),M.loading|=4,$p(I,u,g)}I={type:"stylesheet",instance:I,count:1,state:M},v.set(C,I)}}}function iB(a,u){Li.X(a,u);var f=Zl;if(f&&a){var g=vl(f).hoistableScripts,v=Ql(a),C=g.get(v);C||(C=f.querySelector(Ku(v)),C||(a=p({src:a,async:!0},u),(u=hr.get(v))&&jb(a,u),C=f.createElement("script"),Mn(C),qn(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function oB(a,u){Li.M(a,u);var f=Zl;if(f&&a){var g=vl(f).hoistableScripts,v=Ql(a),C=g.get(v);C||(C=f.querySelector(Ku(v)),C||(a=p({src:a,async:!0,type:"module"},u),(u=hr.get(v))&&jb(a,u),C=f.createElement("script"),Mn(C),qn(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function p$(a,u,f,g){var v=(v=gt.current)?kp(v):null;if(!v)throw Error(s(446));switch(a){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(u=Jl(f.href),f=vl(v).hoistableStyles,g=f.get(u),g||(g={type:"style",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){a=Jl(f.href);var C=vl(v).hoistableStyles,I=C.get(a);if(I||(v=v.ownerDocument||v,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},C.set(a,I),(C=v.querySelector(qu(a)))&&!C._p&&(I.instance=C,I.state.loading=5),hr.has(a)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},hr.set(a,f),C||aB(v,a,f,I.state))),u&&g===null)throw Error(s(528,""));return I}if(u&&g!==null)throw Error(s(529,""));return null;case"script":return u=f.async,f=f.src,typeof f=="string"&&u&&typeof u!="function"&&typeof u!="symbol"?(u=Ql(f),f=vl(v).hoistableScripts,g=f.get(u),g||(g={type:"script",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,a))}}function Jl(a){return'href="'+sr(a)+'"'}function qu(a){return'link[rel="stylesheet"]['+a+"]"}function m$(a){return p({},a,{"data-precedence":a.precedence,precedence:null})}function aB(a,u,f,g){a.querySelector('link[rel="preload"][as="style"]['+u+"]")?g.loading=1:(u=a.createElement("link"),g.preload=u,u.addEventListener("load",function(){return g.loading|=1}),u.addEventListener("error",function(){return g.loading|=2}),qn(u,"link",f),Mn(u),a.head.appendChild(u))}function Ql(a){return'[src="'+sr(a)+'"]'}function Ku(a){return"script[async]"+a}function g$(a,u,f){if(u.count++,u.instance===null)switch(u.type){case"style":var g=a.querySelector('style[data-href~="'+sr(f.href)+'"]');if(g)return u.instance=g,Mn(g),g;var v=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return g=(a.ownerDocument||a).createElement("style"),Mn(g),qn(g,"style",v),$p(g,f.precedence,a),u.instance=g;case"stylesheet":v=Jl(f.href);var C=a.querySelector(qu(v));if(C)return u.state.loading|=4,u.instance=C,Mn(C),C;g=m$(f),(v=hr.get(v))&&Ub(g,v),C=(a.ownerDocument||a).createElement("link"),Mn(C);var I=C;return I._p=new Promise(function(M,j){I.onload=M,I.onerror=j}),qn(C,"link",g),u.state.loading|=4,$p(C,f.precedence,a),u.instance=C;case"script":return C=Ql(f.src),(v=a.querySelector(Ku(C)))?(u.instance=v,Mn(v),v):(g=f,(v=hr.get(C))&&(g=p({},f),jb(g,v)),a=a.ownerDocument||a,v=a.createElement("script"),Mn(v),qn(v,"link",g),a.head.appendChild(v),u.instance=v);case"void":return null;default:throw Error(s(443,u.type))}else u.type==="stylesheet"&&(u.state.loading&4)===0&&(g=u.instance,u.state.loading|=4,$p(g,f.precedence,a));return u.instance}function $p(a,u,f){for(var g=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),v=g.length?g[g.length-1]:null,C=v,I=0;I<g.length;I++){var M=g[I];if(M.dataset.precedence===u)C=M;else if(C!==v)break}C?C.parentNode.insertBefore(a,C.nextSibling):(u=f.nodeType===9?f.head:f,u.insertBefore(a,u.firstChild))}function Ub(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.title==null&&(a.title=u.title)}function jb(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.integrity==null&&(a.integrity=u.integrity)}var Ep=null;function y$(a,u,f){if(Ep===null){var g=new Map,v=Ep=new Map;v.set(f,g)}else v=Ep,g=v.get(f),g||(g=new Map,v.set(f,g));if(g.has(a))return g;for(g.set(a,null),f=f.getElementsByTagName(a),v=0;v<f.length;v++){var C=f[v];if(!(C[uu]||C[jn]||a==="link"&&C.getAttribute("rel")==="stylesheet")&&C.namespaceURI!=="http://www.w3.org/2000/svg"){var I=C.getAttribute(u)||"";I=a+I;var M=g.get(I);M?M.push(C):g.set(I,[C])}}return g}function b$(a,u,f){a=a.ownerDocument||a,a.head.insertBefore(f,u==="title"?a.querySelector("head > title"):null)}function lB(a,u,f){if(f===1||u.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof u.precedence!="string"||typeof u.href!="string"||u.href==="")break;return!0;case"link":if(typeof u.rel!="string"||typeof u.href!="string"||u.href===""||u.onLoad||u.onError)break;return u.rel==="stylesheet"?(a=u.disabled,typeof u.precedence=="string"&&a==null):!0;case"script":if(u.async&&typeof u.async!="function"&&typeof u.async!="symbol"&&!u.onLoad&&!u.onError&&u.src&&typeof u.src=="string")return!0}return!1}function x$(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function cB(a,u,f,g){if(f.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var v=Jl(g.href),C=u.querySelector(qu(v));if(C){u=C._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(a.count++,a=Ip.bind(a),u.then(a,a)),f.state.loading|=4,f.instance=C,Mn(C);return}C=u.ownerDocument||u,g=m$(g),(v=hr.get(v))&&Ub(g,v),C=C.createElement("link"),Mn(C);var I=C;I._p=new Promise(function(M,j){I.onload=M,I.onerror=j}),qn(C,"link",g),f.instance=C}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(f,u),(u=f.state.preload)&&(f.state.loading&3)===0&&(a.count++,f=Ip.bind(a),u.addEventListener("load",f),u.addEventListener("error",f))}}var Gb=0;function uB(a,u){return a.stylesheets&&a.count===0&&Ap(a,a.stylesheets),0<a.count||0<a.imgCount?function(f){var g=setTimeout(function(){if(a.stylesheets&&Ap(a,a.stylesheets),a.unsuspend){var C=a.unsuspend;a.unsuspend=null,C()}},6e4+u);0<a.imgBytes&&Gb===0&&(Gb=62500*Gz());var v=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&Ap(a,a.stylesheets),a.unsuspend)){var C=a.unsuspend;a.unsuspend=null,C()}},(a.imgBytes>Gb?50:800)+u);return a.unsuspend=f,function(){a.unsuspend=null,clearTimeout(g),clearTimeout(v)}}:null}function Ip(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Ap(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var Np=null;function Ap(a,u){a.stylesheets=null,a.unsuspend!==null&&(a.count++,Np=new Map,u.forEach(hB,a),Np=null,Ip.call(a))}function hB(a,u){if(!(u.state.loading&4)){var f=Np.get(a);if(f)var g=f.get(null);else{f=new Map,Np.set(a,f);for(var v=a.querySelectorAll("link[data-precedence],style[data-precedence]"),C=0;C<v.length;C++){var I=v[C];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(f.set(I.dataset.precedence,I),g=I)}g&&f.set(null,g)}v=u.instance,I=v.getAttribute("data-precedence"),C=f.get(I)||g,C===g&&f.set(null,v),f.set(I,v),this.count++,g=Ip.bind(this),v.addEventListener("load",g),v.addEventListener("error",g),C?C.parentNode.insertBefore(v,C.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(v,a.firstChild)),u.state.loading|=4}}var Xu={$$typeof:k,Provider:null,Consumer:null,_currentValue:G,_currentValue2:G,_threadCount:0};function dB(a,u,f,g,v,C,I,M,j){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=z0(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=z0(0),this.hiddenUpdates=z0(null),this.identifierPrefix=g,this.onUncaughtError=v,this.onCaughtError=C,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=j,this.incompleteTransitions=new Map}function v$(a,u,f,g,v,C,I,M,j,at,mt,bt){return a=new dB(a,u,f,I,j,at,mt,bt,M),u=1,C===!0&&(u|=24),C=Vs(3,null,null,u),a.current=C,C.stateNode=a,u=Cy(),u.refCount++,a.pooledCache=u,u.refCount++,C.memoizedState={element:g,isDehydrated:f,cache:u},Ey(C),a}function w$(a){return a?(a=Al,a):Al}function S$(a,u,f,g,v,C){v=w$(v),g.context===null?g.context=v:g.pendingContext=v,g=oo(u),g.payload={element:f},C=C===void 0?null:C,C!==null&&(g.callback=C),f=ao(a,g,u),f!==null&&(As(f,a,u),Eu(f,a,u))}function C$(a,u){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var f=a.retryLane;a.retryLane=f!==0&&f<u?f:u}}function Wb(a,u){C$(a,u),(a=a.alternate)&&C$(a,u)}function T$(a){if(a.tag===13||a.tag===31){var u=aa(a,67108864);u!==null&&As(u,a,67108864),Wb(a,67108864)}}function k$(a){if(a.tag===13||a.tag===31){var u=Hs();u=B0(u);var f=aa(a,u);f!==null&&As(f,a,u),Wb(a,u)}}var _p=!0;function fB(a,u,f,g){var v=P.T;P.T=null;var C=V.p;try{V.p=2,Hb(a,u,f,g)}finally{V.p=C,P.T=v}}function pB(a,u,f,g){var v=P.T;P.T=null;var C=V.p;try{V.p=8,Hb(a,u,f,g)}finally{V.p=C,P.T=v}}function Hb(a,u,f,g){if(_p){var v=qb(g);if(v===null)Rb(a,u,g,Rp,f),E$(a,g);else if(gB(v,a,u,f,g))g.stopPropagation();else if(E$(a,g),u&4&&-1<mB.indexOf(a)){for(;v!==null;){var C=xl(v);if(C!==null)switch(C.tag){case 3:if(C=C.stateNode,C.current.memoizedState.isDehydrated){var I=na(C.pendingLanes);if(I!==0){var M=C;for(M.pendingLanes|=2,M.entangledLanes|=2;I;){var j=1<<31-zs(I);M.entanglements[1]|=j,I&=~j}Qr(C),(Se&6)===0&&(pp=me()+500,ju(0))}}break;case 31:case 13:M=aa(C,2),M!==null&&As(M,C,2),gp(),Wb(C,2)}if(C=qb(g),C===null&&Rb(a,u,g,Rp,f),C===v)break;v=C}v!==null&&g.stopPropagation()}else Rb(a,u,g,null,f)}}function qb(a){return a=X0(a),Kb(a)}var Rp=null;function Kb(a){if(Rp=null,a=bl(a),a!==null){var u=i(a);if(u===null)a=null;else{var f=u.tag;if(f===13){if(a=o(u),a!==null)return a;a=null}else if(f===31){if(a=l(u),a!==null)return a;a=null}else if(f===3){if(u.stateNode.current.memoizedState.isDehydrated)return u.tag===3?u.stateNode.containerInfo:null;a=null}else u!==a&&(a=null)}}return Rp=a,null}function $$(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(an()){case Un:return 2;case Er:return 8;case Ps:case ea:return 32;case gl:return 268435456;default:return 32}default:return 32}}var Xb=!1,xo=null,vo=null,wo=null,Yu=new Map,Zu=new Map,So=[],mB="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function E$(a,u){switch(a){case"focusin":case"focusout":xo=null;break;case"dragenter":case"dragleave":vo=null;break;case"mouseover":case"mouseout":wo=null;break;case"pointerover":case"pointerout":Yu.delete(u.pointerId);break;case"gotpointercapture":case"lostpointercapture":Zu.delete(u.pointerId)}}function Ju(a,u,f,g,v,C){return a===null||a.nativeEvent!==C?(a={blockedOn:u,domEventName:f,eventSystemFlags:g,nativeEvent:C,targetContainers:[v]},u!==null&&(u=xl(u),u!==null&&T$(u)),a):(a.eventSystemFlags|=g,u=a.targetContainers,v!==null&&u.indexOf(v)===-1&&u.push(v),a)}function gB(a,u,f,g,v){switch(u){case"focusin":return xo=Ju(xo,a,u,f,g,v),!0;case"dragenter":return vo=Ju(vo,a,u,f,g,v),!0;case"mouseover":return wo=Ju(wo,a,u,f,g,v),!0;case"pointerover":var C=v.pointerId;return Yu.set(C,Ju(Yu.get(C)||null,a,u,f,g,v)),!0;case"gotpointercapture":return C=v.pointerId,Zu.set(C,Ju(Zu.get(C)||null,a,u,f,g,v)),!0}return!1}function I$(a){var u=bl(a.target);if(u!==null){var f=i(u);if(f!==null){if(u=f.tag,u===13){if(u=o(f),u!==null){a.blockedOn=u,UC(a.priority,function(){k$(f)});return}}else if(u===31){if(u=l(f),u!==null){a.blockedOn=u,UC(a.priority,function(){k$(f)});return}}else if(u===3&&f.stateNode.current.memoizedState.isDehydrated){a.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Dp(a){if(a.blockedOn!==null)return!1;for(var u=a.targetContainers;0<u.length;){var f=qb(a.nativeEvent);if(f===null){f=a.nativeEvent;var g=new f.constructor(f.type,f);K0=g,f.target.dispatchEvent(g),K0=null}else return u=xl(f),u!==null&&T$(u),a.blockedOn=f,!1;u.shift()}return!0}function N$(a,u,f){Dp(a)&&f.delete(u)}function yB(){Xb=!1,xo!==null&&Dp(xo)&&(xo=null),vo!==null&&Dp(vo)&&(vo=null),wo!==null&&Dp(wo)&&(wo=null),Yu.forEach(N$),Zu.forEach(N$)}function Op(a,u){a.blockedOn===u&&(a.blockedOn=null,Xb||(Xb=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,yB)))}var Mp=null;function A$(a){Mp!==a&&(Mp=a,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Mp===a&&(Mp=null);for(var u=0;u<a.length;u+=3){var f=a[u],g=a[u+1],v=a[u+2];if(typeof g!="function"){if(Kb(g||f)===null)continue;break}var C=xl(f);C!==null&&(a.splice(u,3),u-=3,qy(C,{pending:!0,data:v,method:f.method,action:g},g,v))}}))}function tc(a){function u(j){return Op(j,a)}xo!==null&&Op(xo,a),vo!==null&&Op(vo,a),wo!==null&&Op(wo,a),Yu.forEach(u),Zu.forEach(u);for(var f=0;f<So.length;f++){var g=So[f];g.blockedOn===a&&(g.blockedOn=null)}for(;0<So.length&&(f=So[0],f.blockedOn===null);)I$(f),f.blockedOn===null&&So.shift();if(f=(a.ownerDocument||a).$$reactFormReplay,f!=null)for(g=0;g<f.length;g+=3){var v=f[g],C=f[g+1],I=v[Ts]||null;if(typeof C=="function")I||A$(f);else if(I){var M=null;if(C&&C.hasAttribute("formAction")){if(v=C,I=C[Ts]||null)M=I.formAction;else if(Kb(v)!==null)continue}else M=I.action;typeof M=="function"?f[g+1]=M:(f.splice(g,3),g-=3),A$(f)}}}function _$(){function a(C){C.canIntercept&&C.info==="react-transition"&&C.intercept({handler:function(){return new Promise(function(I){return v=I})},focusReset:"manual",scroll:"manual"})}function u(){v!==null&&(v(),v=null),g||setTimeout(f,20)}function f(){if(!g&&!navigation.transition){var C=navigation.currentEntry;C&&C.url!=null&&navigation.navigate(C.url,{state:C.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,v=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",u),navigation.addEventListener("navigateerror",u),setTimeout(f,100),function(){g=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",u),navigation.removeEventListener("navigateerror",u),v!==null&&(v(),v=null)}}}function Yb(a){this._internalRoot=a}Fp.prototype.render=Yb.prototype.render=function(a){var u=this._internalRoot;if(u===null)throw Error(s(409));var f=u.current,g=Hs();S$(f,g,a,u,null,null)},Fp.prototype.unmount=Yb.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var u=a.containerInfo;S$(a.current,2,null,a,null,null),gp(),u[yl]=null}};function Fp(a){this._internalRoot=a}Fp.prototype.unstable_scheduleHydration=function(a){if(a){var u=VC();a={blockedOn:null,target:a,priority:u};for(var f=0;f<So.length&&u!==0&&u<So[f].priority;f++);So.splice(f,0,a),f===0&&I$(a)}};var R$=t.version;if(R$!=="19.2.3")throw Error(s(527,R$,"19.2.3"));V.findDOMNode=function(a){var u=a._reactInternals;if(u===void 0)throw typeof a.render=="function"?Error(s(188)):(a=Object.keys(a).join(","),Error(s(268,a)));return a=h(u),a=a!==null?d(a):null,a=a===null?null:a.stateNode,a};var bB={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:P,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Lp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Lp.isDisabled&&Lp.supportsFiber)try{Kr=Lp.inject(bB),fs=Lp}catch{}}return th.createRoot=function(a,u){if(!r(a))throw Error(s(299));var f=!1,g="",v=zk,C=Bk,I=Vk;return u!=null&&(u.unstable_strictMode===!0&&(f=!0),u.identifierPrefix!==void 0&&(g=u.identifierPrefix),u.onUncaughtError!==void 0&&(v=u.onUncaughtError),u.onCaughtError!==void 0&&(C=u.onCaughtError),u.onRecoverableError!==void 0&&(I=u.onRecoverableError)),u=v$(a,1,!1,null,null,f,g,null,v,C,I,_$),a[yl]=u.current,_b(a),new Yb(u)},th.hydrateRoot=function(a,u,f){if(!r(a))throw Error(s(299));var g=!1,v="",C=zk,I=Bk,M=Vk,j=null;return f!=null&&(f.unstable_strictMode===!0&&(g=!0),f.identifierPrefix!==void 0&&(v=f.identifierPrefix),f.onUncaughtError!==void 0&&(C=f.onUncaughtError),f.onCaughtError!==void 0&&(I=f.onCaughtError),f.onRecoverableError!==void 0&&(M=f.onRecoverableError),f.formState!==void 0&&(j=f.formState)),u=v$(a,1,!0,u,f??null,g,v,j,C,I,M,_$),u.context=w$(null),f=u.current,g=Hs(),g=B0(g),v=oo(g),v.callback=null,ao(f,v,g),f=g,u.current.lanes=f,cu(u,f),Qr(u),a[yl]=u.current,_b(a),new Fp(u)},th.version="19.2.3",th}var U$;function _B(){if(U$)return Qb.exports;U$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),Qb.exports=AB(),Qb.exports}var RB=_B();const DB=dw(RB),pw=St.createContext({});function mw(n){const t=St.useRef(null);return t.current===null&&(t.current=n()),t.current}const gw=typeof window<"u",TA=gw?St.useLayoutEffect:St.useEffect,sg=St.createContext(null);function yw(n,t){n.indexOf(t)===-1&&n.push(t)}function bw(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const Ui=(n,t,e)=>e>t?t:e<n?n:e;let xw=()=>{};const ji={},kA=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function $A(n){return typeof n=="object"&&n!==null}const EA=n=>/^0[^.\s]+$/u.test(n);function vw(n){let t;return()=>(t===void 0&&(t=n()),t)}const wr=n=>n,OB=(n,t)=>e=>t(n(e)),Yh=(...n)=>n.reduce(OB),$h=(n,t,e)=>{const s=t-n;return s===0?1:(e-n)/s};class ww{constructor(){this.subscriptions=[]}add(t){return yw(this.subscriptions,t),()=>bw(this.subscriptions,t)}notify(t,e,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](t,e,s);else for(let i=0;i<r;i++){const o=this.subscriptions[i];o&&o(t,e,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const oi=n=>n*1e3,br=n=>n/1e3;function IA(n,t){return t?n*(1e3/t):0}const NA=(n,t,e)=>(((1-3*e+3*t)*n+(3*e-6*t))*n+3*t)*n,MB=1e-7,FB=12;function LB(n,t,e,s,r){let i,o,l=0;do o=t+(e-t)/2,i=NA(o,s,r)-n,i>0?e=o:t=o;while(Math.abs(i)>MB&&++l<FB);return o}function Zh(n,t,e,s){if(n===t&&e===s)return wr;const r=i=>LB(i,0,1,n,e);return i=>i===0||i===1?i:NA(r(i),t,s)}const AA=n=>t=>t<=.5?n(2*t)/2:(2-n(2*(1-t)))/2,_A=n=>t=>1-n(1-t),RA=Zh(.33,1.53,.69,.99),Sw=_A(RA),DA=AA(Sw),OA=n=>(n*=2)<1?.5*Sw(n):.5*(2-Math.pow(2,-10*(n-1))),Cw=n=>1-Math.sin(Math.acos(n)),MA=_A(Cw),FA=AA(Cw),PB=Zh(.42,0,1,1),zB=Zh(0,0,.58,1),LA=Zh(.42,0,.58,1),BB=n=>Array.isArray(n)&&typeof n[0]!="number",PA=n=>Array.isArray(n)&&typeof n[0]=="number",VB={linear:wr,easeIn:PB,easeInOut:LA,easeOut:zB,circIn:Cw,circInOut:FA,circOut:MA,backIn:Sw,backInOut:DA,backOut:RA,anticipate:OA},UB=n=>typeof n=="string",j$=n=>{if(PA(n)){xw(n.length===4);const[t,e,s,r]=n;return Zh(t,e,s,r)}else if(UB(n))return VB[n];return n},Pp=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function jB(n,t){let e=new Set,s=new Set,r=!1,i=!1;const o=new WeakSet;let l={delta:0,timestamp:0,isProcessing:!1};function c(d){o.has(d)&&(h.schedule(d),n()),d(l)}const h={schedule:(d,p=!1,m=!1)=>{const b=m&&r?e:s;return p&&o.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),o.delete(d)},process:d=>{if(l=d,r){i=!0;return}r=!0,[e,s]=[s,e],e.forEach(c),e.clear(),r=!1,i&&(i=!1,h.process(d))}};return h}const GB=40;function zA(n,t){let e=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},i=()=>e=!0,o=Pp.reduce((k,$)=>(k[$]=jB(i),k),{}),{setup:l,read:c,resolveKeyframes:h,preUpdate:d,update:p,preRender:m,render:y,postRender:b}=o,x=()=>{const k=ji.useManualTiming?r.timestamp:performance.now();e=!1,ji.useManualTiming||(r.delta=s?1e3/60:Math.max(Math.min(k-r.timestamp,GB),1)),r.timestamp=k,r.isProcessing=!0,l.process(r),c.process(r),h.process(r),d.process(r),p.process(r),m.process(r),y.process(r),b.process(r),r.isProcessing=!1,e&&t&&(s=!1,n(x))},w=()=>{e=!0,s=!0,r.isProcessing||n(x)};return{schedule:Pp.reduce((k,$)=>{const E=o[$];return k[$]=(N,_=!1,R=!1)=>(e||w(),E.schedule(N,_,R)),k},{}),cancel:k=>{for(let $=0;$<Pp.length;$++)o[Pp[$]].cancel(k)},state:r,steps:o}}const{schedule:We,cancel:Mo,state:Yn,steps:sx}=zA(typeof requestAnimationFrame<"u"?requestAnimationFrame:wr,!0);let im;function WB(){im=void 0}const Ds={now:()=>(im===void 0&&Ds.set(Yn.isProcessing||ji.useManualTiming?Yn.timestamp:performance.now()),im),set:n=>{im=n,queueMicrotask(WB)}},BA=n=>t=>typeof t=="string"&&t.startsWith(n),VA=BA("--"),HB=BA("var(--"),Tw=n=>HB(n)?qB.test(n.split("/*")[0].trim()):!1,qB=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Uc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},Eh={...Uc,transform:n=>Ui(0,1,n)},zp={...Uc,default:1},mh=n=>Math.round(n*1e5)/1e5,kw=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function KB(n){return n==null}const XB=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,$w=(n,t)=>e=>!!(typeof e=="string"&&XB.test(e)&&e.startsWith(n)||t&&!KB(e)&&Object.prototype.hasOwnProperty.call(e,t)),UA=(n,t,e)=>s=>{if(typeof s!="string")return s;const[r,i,o,l]=s.match(kw);return{[n]:parseFloat(r),[t]:parseFloat(i),[e]:parseFloat(o),alpha:l!==void 0?parseFloat(l):1}},YB=n=>Ui(0,255,n),rx={...Uc,transform:n=>Math.round(YB(n))},Ma={test:$w("rgb","red"),parse:UA("red","green","blue"),transform:({red:n,green:t,blue:e,alpha:s=1})=>"rgba("+rx.transform(n)+", "+rx.transform(t)+", "+rx.transform(e)+", "+mh(Eh.transform(s))+")"};function ZB(n){let t="",e="",s="",r="";return n.length>5?(t=n.substring(1,3),e=n.substring(3,5),s=n.substring(5,7),r=n.substring(7,9)):(t=n.substring(1,2),e=n.substring(2,3),s=n.substring(3,4),r=n.substring(4,5),t+=t,e+=e,s+=s,r+=r),{red:parseInt(t,16),green:parseInt(e,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const Kx={test:$w("#"),parse:ZB,transform:Ma.transform},Jh=n=>({test:t=>typeof t=="string"&&t.endsWith(n)&&t.split(" ").length===1,parse:parseFloat,transform:t=>`${t}${n}`}),To=Jh("deg"),ai=Jh("%"),Wt=Jh("px"),JB=Jh("vh"),QB=Jh("vw"),G$={...ai,parse:n=>ai.parse(n)/100,transform:n=>ai.transform(n*100)},gc={test:$w("hsl","hue"),parse:UA("hue","saturation","lightness"),transform:({hue:n,saturation:t,lightness:e,alpha:s=1})=>"hsla("+Math.round(n)+", "+ai.transform(mh(t))+", "+ai.transform(mh(e))+", "+mh(Eh.transform(s))+")"},bn={test:n=>Ma.test(n)||Kx.test(n)||gc.test(n),parse:n=>Ma.test(n)?Ma.parse(n):gc.test(n)?gc.parse(n):Kx.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?Ma.transform(n):gc.transform(n),getAnimatableNone:n=>{const t=bn.parse(n);return t.alpha=0,bn.transform(t)}},tV=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function eV(n){return isNaN(n)&&typeof n=="string"&&(n.match(kw)?.length||0)+(n.match(tV)?.length||0)>0}const jA="number",GA="color",nV="var",sV="var(",W$="${}",rV=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Ih(n){const t=n.toString(),e=[],s={color:[],number:[],var:[]},r=[];let i=0;const l=t.replace(rV,c=>(bn.test(c)?(s.color.push(i),r.push(GA),e.push(bn.parse(c))):c.startsWith(sV)?(s.var.push(i),r.push(nV),e.push(c)):(s.number.push(i),r.push(jA),e.push(parseFloat(c))),++i,W$)).split(W$);return{values:e,split:l,indexes:s,types:r}}function WA(n){return Ih(n).values}function HA(n){const{split:t,types:e}=Ih(n),s=t.length;return r=>{let i="";for(let o=0;o<s;o++)if(i+=t[o],r[o]!==void 0){const l=e[o];l===jA?i+=mh(r[o]):l===GA?i+=bn.transform(r[o]):i+=r[o]}return i}}const iV=n=>typeof n=="number"?0:bn.test(n)?bn.getAnimatableNone(n):n;function oV(n){const t=WA(n);return HA(n)(t.map(iV))}const Fo={test:eV,parse:WA,createTransformer:HA,getAnimatableNone:oV};function ix(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+(t-n)*6*e:e<1/2?t:e<2/3?n+(t-n)*(2/3-e)*6:n}function aV({hue:n,saturation:t,lightness:e,alpha:s}){n/=360,t/=100,e/=100;let r=0,i=0,o=0;if(!t)r=i=o=e;else{const l=e<.5?e*(1+t):e+t-e*t,c=2*e-l;r=ix(c,l,n+1/3),i=ix(c,l,n),o=ix(c,l,n-1/3)}return{red:Math.round(r*255),green:Math.round(i*255),blue:Math.round(o*255),alpha:s}}function bm(n,t){return e=>e>0?t:n}const Xe=(n,t,e)=>n+(t-n)*e,ox=(n,t,e)=>{const s=n*n,r=e*(t*t-s)+s;return r<0?0:Math.sqrt(r)},lV=[Kx,Ma,gc],cV=n=>lV.find(t=>t.test(n));function H$(n){const t=cV(n);if(!t)return!1;let e=t.parse(n);return t===gc&&(e=aV(e)),e}const q$=(n,t)=>{const e=H$(n),s=H$(t);if(!e||!s)return bm(n,t);const r={...e};return i=>(r.red=ox(e.red,s.red,i),r.green=ox(e.green,s.green,i),r.blue=ox(e.blue,s.blue,i),r.alpha=Xe(e.alpha,s.alpha,i),Ma.transform(r))},Xx=new Set(["none","hidden"]);function uV(n,t){return Xx.has(n)?e=>e<=0?n:t:e=>e>=1?t:n}function hV(n,t){return e=>Xe(n,t,e)}function Ew(n){return typeof n=="number"?hV:typeof n=="string"?Tw(n)?bm:bn.test(n)?q$:pV:Array.isArray(n)?qA:typeof n=="object"?bn.test(n)?q$:dV:bm}function qA(n,t){const e=[...n],s=e.length,r=n.map((i,o)=>Ew(i)(i,t[o]));return i=>{for(let o=0;o<s;o++)e[o]=r[o](i);return e}}function dV(n,t){const e={...n,...t},s={};for(const r in e)n[r]!==void 0&&t[r]!==void 0&&(s[r]=Ew(n[r])(n[r],t[r]));return r=>{for(const i in s)e[i]=s[i](r);return e}}function fV(n,t){const e=[],s={color:0,var:0,number:0};for(let r=0;r<t.values.length;r++){const i=t.types[r],o=n.indexes[i][s[i]],l=n.values[o]??0;e[r]=l,s[i]++}return e}const pV=(n,t)=>{const e=Fo.createTransformer(t),s=Ih(n),r=Ih(t);return s.indexes.var.length===r.indexes.var.length&&s.indexes.color.length===r.indexes.color.length&&s.indexes.number.length>=r.indexes.number.length?Xx.has(n)&&!r.values.length||Xx.has(t)&&!s.values.length?uV(n,t):Yh(qA(fV(s,r),r.values),e):bm(n,t)};function KA(n,t,e){return typeof n=="number"&&typeof t=="number"&&typeof e=="number"?Xe(n,t,e):Ew(n)(n,t)}const mV=n=>{const t=({timestamp:e})=>n(e);return{start:(e=!0)=>We.update(t,e),stop:()=>Mo(t),now:()=>Yn.isProcessing?Yn.timestamp:Ds.now()}},XA=(n,t,e=10)=>{let s="";const r=Math.max(Math.round(t/e),2);for(let i=0;i<r;i++)s+=Math.round(n(i/(r-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},xm=2e4;function Iw(n){let t=0;const e=50;let s=n.next(t);for(;!s.done&&t<xm;)t+=e,s=n.next(t);return t>=xm?1/0:t}function gV(n,t=100,e){const s=e({...n,keyframes:[0,t]}),r=Math.min(Iw(s),xm);return{type:"keyframes",ease:i=>s.next(r*i).value/t,duration:br(r)}}const yV=5;function YA(n,t,e){const s=Math.max(t-yV,0);return IA(e-n(s),t-s)}const Qe={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},ax=.001;function bV({duration:n=Qe.duration,bounce:t=Qe.bounce,velocity:e=Qe.velocity,mass:s=Qe.mass}){let r,i,o=1-t;o=Ui(Qe.minDamping,Qe.maxDamping,o),n=Ui(Qe.minDuration,Qe.maxDuration,br(n)),o<1?(r=h=>{const d=h*o,p=d*n,m=d-e,y=Yx(h,o),b=Math.exp(-p);return ax-m/y*b},i=h=>{const p=h*o*n,m=p*e+e,y=Math.pow(o,2)*Math.pow(h,2)*n,b=Math.exp(-p),x=Yx(Math.pow(h,2),o);return(-r(h)+ax>0?-1:1)*((m-y)*b)/x}):(r=h=>{const d=Math.exp(-h*n),p=(h-e)*n+1;return-ax+d*p},i=h=>{const d=Math.exp(-h*n),p=(e-h)*(n*n);return d*p});const l=5/n,c=vV(r,i,l);if(n=oi(n),isNaN(c))return{stiffness:Qe.stiffness,damping:Qe.damping,duration:n};{const h=Math.pow(c,2)*s;return{stiffness:h,damping:o*2*Math.sqrt(s*h),duration:n}}}const xV=12;function vV(n,t,e){let s=e;for(let r=1;r<xV;r++)s=s-n(s)/t(s);return s}function Yx(n,t){return n*Math.sqrt(1-t*t)}const wV=["duration","bounce"],SV=["stiffness","damping","mass"];function K$(n,t){return t.some(e=>n[e]!==void 0)}function CV(n){let t={velocity:Qe.velocity,stiffness:Qe.stiffness,damping:Qe.damping,mass:Qe.mass,isResolvedFromDuration:!1,...n};if(!K$(n,SV)&&K$(n,wV))if(n.visualDuration){const e=n.visualDuration,s=2*Math.PI/(e*1.2),r=s*s,i=2*Ui(.05,1,1-(n.bounce||0))*Math.sqrt(r);t={...t,mass:Qe.mass,stiffness:r,damping:i}}else{const e=bV(n);t={...t,...e,mass:Qe.mass},t.isResolvedFromDuration=!0}return t}function vm(n=Qe.visualDuration,t=Qe.bounce){const e=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:t}:n;let{restSpeed:s,restDelta:r}=e;const i=e.keyframes[0],o=e.keyframes[e.keyframes.length-1],l={done:!1,value:i},{stiffness:c,damping:h,mass:d,duration:p,velocity:m,isResolvedFromDuration:y}=CV({...e,velocity:-br(e.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(c*d)),w=o-i,S=br(Math.sqrt(c/d)),T=Math.abs(w)<5;s||(s=T?Qe.restSpeed.granular:Qe.restSpeed.default),r||(r=T?Qe.restDelta.granular:Qe.restDelta.default);let k;if(x<1){const E=Yx(S,x);k=N=>{const _=Math.exp(-x*S*N);return o-_*((b+x*S*w)/E*Math.sin(E*N)+w*Math.cos(E*N))}}else if(x===1)k=E=>o-Math.exp(-S*E)*(w+(b+S*w)*E);else{const E=S*Math.sqrt(x*x-1);k=N=>{const _=Math.exp(-x*S*N),R=Math.min(E*N,300);return o-_*((b+x*S*w)*Math.sinh(R)+E*w*Math.cosh(R))/E}}const $={calculatedDuration:y&&p||null,next:E=>{const N=k(E);if(y)l.done=E>=p;else{let _=E===0?b:0;x<1&&(_=E===0?oi(b):YA(k,E,N));const R=Math.abs(_)<=s,D=Math.abs(o-N)<=r;l.done=R&&D}return l.value=l.done?o:N,l},toString:()=>{const E=Math.min(Iw($),xm),N=XA(_=>$.next(E*_).value,E,30);return E+"ms "+N},toTransition:()=>{}};return $}vm.applyToOptions=n=>{const t=gV(n,100,vm);return n.ease=t.ease,n.duration=oi(t.duration),n.type="keyframes",n};function Zx({keyframes:n,velocity:t=0,power:e=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:i=500,modifyTarget:o,min:l,max:c,restDelta:h=.5,restSpeed:d}){const p=n[0],m={done:!1,value:p},y=R=>l!==void 0&&R<l||c!==void 0&&R>c,b=R=>l===void 0?c:c===void 0||Math.abs(l-R)<Math.abs(c-R)?l:c;let x=e*t;const w=p+x,S=o===void 0?w:o(w);S!==w&&(x=S-p);const T=R=>-x*Math.exp(-R/s),k=R=>S+T(R),$=R=>{const D=T(R),O=k(R);m.done=Math.abs(D)<=h,m.value=m.done?S:O};let E,N;const _=R=>{y(m.value)&&(E=R,N=vm({keyframes:[m.value,b(m.value)],velocity:YA(k,R,m.value),damping:r,stiffness:i,restDelta:h,restSpeed:d}))};return _(0),{calculatedDuration:null,next:R=>{let D=!1;return!N&&E===void 0&&(D=!0,$(R),_(R)),E!==void 0&&R>=E?N.next(R-E):(!D&&$(R),m)}}}function TV(n,t,e){const s=[],r=e||ji.mix||KA,i=n.length-1;for(let o=0;o<i;o++){let l=r(n[o],n[o+1]);if(t){const c=Array.isArray(t)?t[o]||wr:t;l=Yh(c,l)}s.push(l)}return s}function kV(n,t,{clamp:e=!0,ease:s,mixer:r}={}){const i=n.length;if(xw(i===t.length),i===1)return()=>t[0];if(i===2&&t[0]===t[1])return()=>t[1];const o=n[0]===n[1];n[0]>n[i-1]&&(n=[...n].reverse(),t=[...t].reverse());const l=TV(t,s,r),c=l.length,h=d=>{if(o&&d<n[0])return t[0];let p=0;if(c>1)for(;p<n.length-2&&!(d<n[p+1]);p++);const m=$h(n[p],n[p+1],d);return l[p](m)};return e?d=>h(Ui(n[0],n[i-1],d)):h}function $V(n,t){const e=n[n.length-1];for(let s=1;s<=t;s++){const r=$h(0,t,s);n.push(Xe(e,1,r))}}function EV(n){const t=[0];return $V(t,n.length-1),t}function IV(n,t){return n.map(e=>e*t)}function NV(n,t){return n.map(()=>t||LA).splice(0,n.length-1)}function gh({duration:n=300,keyframes:t,times:e,ease:s="easeInOut"}){const r=BB(s)?s.map(j$):j$(s),i={done:!1,value:t[0]},o=IV(e&&e.length===t.length?e:EV(t),n),l=kV(o,t,{ease:Array.isArray(r)?r:NV(t,r)});return{calculatedDuration:n,next:c=>(i.value=l(c),i.done=c>=n,i)}}const AV=n=>n!==null;function Nw(n,{repeat:t,repeatType:e="loop"},s,r=1){const i=n.filter(AV),l=r<0||t&&e!=="loop"&&t%2===1?0:i.length-1;return!l||s===void 0?i[l]:s}const _V={decay:Zx,inertia:Zx,tween:gh,keyframes:gh,spring:vm};function ZA(n){typeof n.type=="string"&&(n.type=_V[n.type])}class Aw{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(t=>{this.resolve=t})}notifyFinished(){this.resolve()}then(t,e){return this.finished.then(t,e)}}const RV=n=>n/100;class _w extends Aw{constructor(t){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:e}=this.options;e&&e.updatedAt!==Ds.now()&&this.tick(Ds.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=t,this.initAnimation(),this.play(),t.autoplay===!1&&this.pause()}initAnimation(){const{options:t}=this;ZA(t);const{type:e=gh,repeat:s=0,repeatDelay:r=0,repeatType:i,velocity:o=0}=t;let{keyframes:l}=t;const c=e||gh;c!==gh&&typeof l[0]!="number"&&(this.mixKeyframes=Yh(RV,KA(l[0],l[1])),l=[0,100]);const h=c({...t,keyframes:l});i==="mirror"&&(this.mirroredGenerator=c({...t,keyframes:[...l].reverse(),velocity:-o})),h.calculatedDuration===null&&(h.calculatedDuration=Iw(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+r,this.totalDuration=this.resolvedDuration*(s+1)-r,this.generator=h}updateTime(t){const e=Math.round(t-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=e}tick(t,e=!1){const{generator:s,totalDuration:r,mixKeyframes:i,mirroredGenerator:o,resolvedDuration:l,calculatedDuration:c}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:p,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-r/this.speed,this.startTime)),e?this.currentTime=t:this.updateTime(t);const S=this.currentTime-h*(this.playbackSpeed>=0?1:-1),T=this.playbackSpeed>=0?S<0:S>r;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=r);let k=this.currentTime,$=s;if(p){const R=Math.min(this.currentTime,r)/l;let D=Math.floor(R),O=R%1;!O&&R>=1&&(O=1),O===1&&D--,D=Math.min(D,p+1),D%2&&(m==="reverse"?(O=1-O,y&&(O-=y/l)):m==="mirror"&&($=o)),k=Ui(0,1,O)*l}const E=T?{done:!1,value:d[0]}:$.next(k);i&&(E.value=i(E.value));let{done:N}=E;!T&&c!==null&&(N=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const _=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&N);return _&&b!==Zx&&(E.value=Nw(d,this.options,w,this.speed)),x&&x(E.value),_&&this.finish(),E}then(t,e){return this.finished.then(t,e)}get duration(){return br(this.calculatedDuration)}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+br(t)}get time(){return br(this.currentTime)}set time(t){t=oi(t),this.currentTime=t,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(t){this.updateTime(Ds.now());const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=br(this.currentTime))}play(){if(this.isStopped)return;const{driver:t=mV,startTime:e}=this.options;this.driver||(this.driver=t(r=>this.tick(r))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=e??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Ds.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}attachTimeline(t){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),t.observe(this)}}function DV(n){for(let t=1;t<n.length;t++)n[t]??(n[t]=n[t-1])}const Fa=n=>n*180/Math.PI,Jx=n=>{const t=Fa(Math.atan2(n[1],n[0]));return Qx(t)},OV={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:Jx,rotateZ:Jx,skewX:n=>Fa(Math.atan(n[1])),skewY:n=>Fa(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},Qx=n=>(n=n%360,n<0&&(n+=360),n),X$=Jx,Y$=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),Z$=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),MV={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:Y$,scaleY:Z$,scale:n=>(Y$(n)+Z$(n))/2,rotateX:n=>Qx(Fa(Math.atan2(n[6],n[5]))),rotateY:n=>Qx(Fa(Math.atan2(-n[2],n[0]))),rotateZ:X$,rotate:X$,skewX:n=>Fa(Math.atan(n[4])),skewY:n=>Fa(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function tv(n){return n.includes("scale")?1:0}function ev(n,t){if(!n||n==="none")return tv(t);const e=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,r;if(e)s=MV,r=e;else{const l=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=OV,r=l}if(!r)return tv(t);const i=s[t],o=r[1].split(",").map(LV);return typeof i=="function"?i(o):o[i]}const FV=(n,t)=>{const{transform:e="none"}=getComputedStyle(n);return ev(e,t)};function LV(n){return parseFloat(n.trim())}const jc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Gc=new Set(jc),J$=n=>n===Uc||n===Wt,PV=new Set(["x","y","z"]),zV=jc.filter(n=>!PV.has(n));function BV(n){const t=[];return zV.forEach(e=>{const s=n.getValue(e);s!==void 0&&(t.push([e,s.get()]),s.set(e.startsWith("scale")?1:0))}),t}const Ba={width:({x:n},{paddingLeft:t="0",paddingRight:e="0"})=>n.max-n.min-parseFloat(t)-parseFloat(e),height:({y:n},{paddingTop:t="0",paddingBottom:e="0"})=>n.max-n.min-parseFloat(t)-parseFloat(e),top:(n,{top:t})=>parseFloat(t),left:(n,{left:t})=>parseFloat(t),bottom:({y:n},{top:t})=>parseFloat(t)+(n.max-n.min),right:({x:n},{left:t})=>parseFloat(t)+(n.max-n.min),x:(n,{transform:t})=>ev(t,"x"),y:(n,{transform:t})=>ev(t,"y")};Ba.translateX=Ba.x;Ba.translateY=Ba.y;const Va=new Set;let nv=!1,sv=!1,rv=!1;function JA(){if(sv){const n=Array.from(Va).filter(s=>s.needsMeasurement),t=new Set(n.map(s=>s.element)),e=new Map;t.forEach(s=>{const r=BV(s);r.length&&(e.set(s,r),s.render())}),n.forEach(s=>s.measureInitialState()),t.forEach(s=>{s.render();const r=e.get(s);r&&r.forEach(([i,o])=>{s.getValue(i)?.set(o)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}sv=!1,nv=!1,Va.forEach(n=>n.complete(rv)),Va.clear()}function QA(){Va.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(sv=!0)})}function VV(){rv=!0,QA(),JA(),rv=!1}class Rw{constructor(t,e,s,r,i,o=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=s,this.motionValue=r,this.element=i,this.isAsync=o}scheduleResolve(){this.state="scheduled",this.isAsync?(Va.add(this),nv||(nv=!0,We.read(QA),We.resolveKeyframes(JA))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:s,motionValue:r}=this;if(t[0]===null){const i=r?.get(),o=t[t.length-1];if(i!==void 0)t[0]=i;else if(s&&e){const l=s.readValue(e,o);l!=null&&(t[0]=l)}t[0]===void 0&&(t[0]=o),r&&i===void 0&&r.set(t[0])}DV(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,t),Va.delete(this)}cancel(){this.state==="scheduled"&&(Va.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const UV=n=>n.startsWith("--");function jV(n,t,e){UV(t)?n.style.setProperty(t,e):n.style[t]=e}const GV=vw(()=>window.ScrollTimeline!==void 0),WV={};function HV(n,t){const e=vw(n);return()=>WV[t]??e()}const t_=HV(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),ah=([n,t,e,s])=>`cubic-bezier(${n}, ${t}, ${e}, ${s})`,Q$={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:ah([0,.65,.55,1]),circOut:ah([.55,0,1,.45]),backIn:ah([.31,.01,.66,-.59]),backOut:ah([.33,1.53,.69,.99])};function e_(n,t){if(n)return typeof n=="function"?t_()?XA(n,t):"ease-out":PA(n)?ah(n):Array.isArray(n)?n.map(e=>e_(e,t)||Q$.easeOut):Q$[n]}function qV(n,t,e,{delay:s=0,duration:r=300,repeat:i=0,repeatType:o="loop",ease:l="easeOut",times:c}={},h=void 0){const d={[t]:e};c&&(d.offset=c);const p=e_(l,r);Array.isArray(p)&&(d.easing=p);const m={delay:s,duration:r,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:i+1,direction:o==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function n_(n){return typeof n=="function"&&"applyToOptions"in n}function KV({type:n,...t}){return n_(n)&&t_()?n.applyToOptions(t):(t.duration??(t.duration=300),t.ease??(t.ease="easeOut"),t)}class XV extends Aw{constructor(t){if(super(),this.finishedTime=null,this.isStopped=!1,!t)return;const{element:e,name:s,keyframes:r,pseudoElement:i,allowFlatten:o=!1,finalKeyframe:l,onComplete:c}=t;this.isPseudoElement=!!i,this.allowFlatten=o,this.options=t,xw(typeof t.type!="string");const h=KV(t);this.animation=qV(e,s,r,h,i),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!i){const d=Nw(r,this.options,l,this.speed);this.updateMotionValue?this.updateMotionValue(d):jV(e,s,d),this.animation.cancel()}c?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:t}=this;t==="idle"||t==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const t=this.animation.effect?.getComputedTiming?.().duration||0;return br(Number(t))}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+br(t)}get time(){return br(Number(this.animation.currentTime)||0)}set time(t){this.finishedTime=null,this.animation.currentTime=oi(t)}get speed(){return this.animation.playbackRate}set speed(t){t<0&&(this.finishedTime=null),this.animation.playbackRate=t}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(t){this.animation.startTime=t}attachTimeline({timeline:t,observe:e}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,t&&GV()?(this.animation.timeline=t,wr):e(this)}}const s_={anticipate:OA,backInOut:DA,circInOut:FA};function YV(n){return n in s_}function ZV(n){typeof n.ease=="string"&&YV(n.ease)&&(n.ease=s_[n.ease])}const tE=10;class JV extends XV{constructor(t){ZV(t),ZA(t),super(t),t.startTime&&(this.startTime=t.startTime),this.options=t}updateMotionValue(t){const{motionValue:e,onUpdate:s,onComplete:r,element:i,...o}=this.options;if(!e)return;if(t!==void 0){e.set(t);return}const l=new _w({...o,autoplay:!1}),c=oi(this.finishedTime??this.time);e.setWithVelocity(l.sample(c-tE).value,l.sample(c).value,tE),l.stop()}}const eE=(n,t)=>t==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(Fo.test(n)||n==="0")&&!n.startsWith("url("));function QV(n){const t=n[0];if(n.length===1)return!0;for(let e=0;e<n.length;e++)if(n[e]!==t)return!0}function tU(n,t,e,s){const r=n[0];if(r===null)return!1;if(t==="display"||t==="visibility")return!0;const i=n[n.length-1],o=eE(r,t),l=eE(i,t);return!o||!l?!1:QV(n)||(e==="spring"||n_(e))&&s}function iv(n){n.duration=0,n.type="keyframes"}const eU=new Set(["opacity","clipPath","filter","transform"]),nU=vw(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function sU(n){const{motionValue:t,name:e,repeatDelay:s,repeatType:r,damping:i,type:o}=n;if(!(t?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:c,transformTemplate:h}=t.owner.getProps();return nU()&&e&&eU.has(e)&&(e!=="transform"||!h)&&!c&&!s&&r!=="mirror"&&i!==0&&o!=="inertia"}const rU=40;class iU extends Aw{constructor({autoplay:t=!0,delay:e=0,type:s="keyframes",repeat:r=0,repeatDelay:i=0,repeatType:o="loop",keyframes:l,name:c,motionValue:h,element:d,...p}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Ds.now();const m={autoplay:t,delay:e,type:s,repeat:r,repeatDelay:i,repeatType:o,name:c,motionValue:h,element:d,...p},y=d?.KeyframeResolver||Rw;this.keyframeResolver=new y(l,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),c,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(t,e,s,r){this.keyframeResolver=void 0;const{name:i,type:o,velocity:l,delay:c,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Ds.now(),tU(t,i,o,l)||((ji.instantAnimations||!c)&&d?.(Nw(t,s,e)),t[0]=t[t.length-1],iv(s),s.repeat=0);const m={startTime:r?this.resolvedAt?this.resolvedAt-this.createdAt>rU?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:e,...s,keyframes:t},y=!h&&sU(m)?new JV({...m,element:m.motionValue.owner.current}):new _w(m);y.finished.then(()=>this.notifyFinished()).catch(wr),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(t,e){return this.finished.finally(t).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),VV()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(t){this.animation.time=t}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(t){this.animation.speed=t}get startTime(){return this.animation.startTime}attachTimeline(t){return this._animation?this.stopTimeline=this.animation.attachTimeline(t):this.pendingTimeline=t,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const oU=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function aU(n){const t=oU.exec(n);if(!t)return[,];const[,e,s,r]=t;return[`--${e??s}`,r]}function r_(n,t,e=1){const[s,r]=aU(n);if(!s)return;const i=window.getComputedStyle(t).getPropertyValue(s);if(i){const o=i.trim();return kA(o)?parseFloat(o):o}return Tw(r)?r_(r,t,e+1):r}function Dw(n,t){return n?.[t]??n?.default??n}const i_=new Set(["width","height","top","left","right","bottom",...jc]),lU={test:n=>n==="auto",parse:n=>n},o_=n=>t=>t.test(n),a_=[Uc,Wt,ai,To,QB,JB,lU],nE=n=>a_.find(o_(n));function cU(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||EA(n):!0}const uU=new Set(["brightness","contrast","saturate","opacity"]);function hU(n){const[t,e]=n.slice(0,-1).split("(");if(t==="drop-shadow")return n;const[s]=e.match(kw)||[];if(!s)return n;const r=e.replace(s,"");let i=uU.has(t)?1:0;return s!==e&&(i*=100),t+"("+i+r+")"}const dU=/\b([a-z-]*)\(.*?\)/gu,ov={...Fo,getAnimatableNone:n=>{const t=n.match(dU);return t?t.map(hU).join(" "):n}},sE={...Uc,transform:Math.round},fU={rotate:To,rotateX:To,rotateY:To,rotateZ:To,scale:zp,scaleX:zp,scaleY:zp,scaleZ:zp,skew:To,skewX:To,skewY:To,distance:Wt,translateX:Wt,translateY:Wt,translateZ:Wt,x:Wt,y:Wt,z:Wt,perspective:Wt,transformPerspective:Wt,opacity:Eh,originX:G$,originY:G$,originZ:Wt},Ow={borderWidth:Wt,borderTopWidth:Wt,borderRightWidth:Wt,borderBottomWidth:Wt,borderLeftWidth:Wt,borderRadius:Wt,radius:Wt,borderTopLeftRadius:Wt,borderTopRightRadius:Wt,borderBottomRightRadius:Wt,borderBottomLeftRadius:Wt,width:Wt,maxWidth:Wt,height:Wt,maxHeight:Wt,top:Wt,right:Wt,bottom:Wt,left:Wt,padding:Wt,paddingTop:Wt,paddingRight:Wt,paddingBottom:Wt,paddingLeft:Wt,margin:Wt,marginTop:Wt,marginRight:Wt,marginBottom:Wt,marginLeft:Wt,backgroundPositionX:Wt,backgroundPositionY:Wt,...fU,zIndex:sE,fillOpacity:Eh,strokeOpacity:Eh,numOctaves:sE},pU={...Ow,color:bn,backgroundColor:bn,outlineColor:bn,fill:bn,stroke:bn,borderColor:bn,borderTopColor:bn,borderRightColor:bn,borderBottomColor:bn,borderLeftColor:bn,filter:ov,WebkitFilter:ov},l_=n=>pU[n];function c_(n,t){let e=l_(n);return e!==ov&&(e=Fo),e.getAnimatableNone?e.getAnimatableNone(t):void 0}const mU=new Set(["auto","none","0"]);function gU(n,t,e){let s=0,r;for(;s<n.length&&!r;){const i=n[s];typeof i=="string"&&!mU.has(i)&&Ih(i).values.length&&(r=n[s]),s++}if(r&&e)for(const i of t)n[i]=c_(e,r)}class yU extends Rw{constructor(t,e,s,r,i){super(t,e,s,r,i,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:s}=this;if(!e||!e.current)return;super.readKeyframes();for(let c=0;c<t.length;c++){let h=t[c];if(typeof h=="string"&&(h=h.trim(),Tw(h))){const d=r_(h,e.current);d!==void 0&&(t[c]=d),c===t.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!i_.has(s)||t.length!==2)return;const[r,i]=t,o=nE(r),l=nE(i);if(o!==l)if(J$(o)&&J$(l))for(let c=0;c<t.length;c++){const h=t[c];typeof h=="string"&&(t[c]=parseFloat(h))}else Ba[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,s=[];for(let r=0;r<t.length;r++)(t[r]===null||cU(t[r]))&&s.push(r);s.length&&gU(t,s,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:s}=this;if(!t||!t.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=Ba[s](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const r=e[e.length-1];r!==void 0&&t.getValue(s,r).jump(r,!1)}measureEndState(){const{element:t,name:e,unresolvedKeyframes:s}=this;if(!t||!t.current)return;const r=t.getValue(e);r&&r.jump(this.measuredOrigin,!1);const i=s.length-1,o=s[i];s[i]=Ba[e](t.measureViewportBox(),window.getComputedStyle(t.current)),o!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=o),this.removedTransforms?.length&&this.removedTransforms.forEach(([l,c])=>{t.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function bU(n,t,e){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const r=e?.[n]??s.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}const u_=(n,t)=>t&&typeof n=="number"?t.transform(n):n;function h_(n){return $A(n)&&"offsetHeight"in n}const rE=30,xU=n=>!isNaN(parseFloat(n));class vU{constructor(t,e={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const r=Ds.now();if(this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const i of this.dependents)i.dirty()},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){this.current=t,this.updatedAt=Ds.now(),this.canTrackVelocity===null&&t!==void 0&&(this.canTrackVelocity=xU(this.current))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new ww);const s=this.events[t].add(e);return t==="change"?()=>{s(),We.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t){this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t)}setWithVelocity(t,e,s){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-s}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(t){this.dependents||(this.dependents=new Set),this.dependents.add(t)}removeDependent(t){this.dependents&&this.dependents.delete(t)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const t=Ds.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||t-this.updatedAt>rE)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,rE);return IA(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Nc(n,t){return new vU(n,t)}const{schedule:Mw}=zA(queueMicrotask,!1),Or={x:!1,y:!1};function d_(){return Or.x||Or.y}function wU(n){return n==="x"||n==="y"?Or[n]?null:(Or[n]=!0,()=>{Or[n]=!1}):Or.x||Or.y?null:(Or.x=Or.y=!0,()=>{Or.x=Or.y=!1})}function f_(n,t){const e=bU(n),s=new AbortController,r={passive:!0,...t,signal:s.signal};return[e,r,()=>s.abort()]}function iE(n){return!(n.pointerType==="touch"||d_())}function SU(n,t,e={}){const[s,r,i]=f_(n,e),o=l=>{if(!iE(l))return;const{target:c}=l,h=t(c,l);if(typeof h!="function"||!c)return;const d=p=>{iE(p)&&(h(p),c.removeEventListener("pointerleave",d))};c.addEventListener("pointerleave",d,r)};return s.forEach(l=>{l.addEventListener("pointerenter",o,r)}),i}const p_=(n,t)=>t?n===t?!0:p_(n,t.parentElement):!1,Fw=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,CU=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function TU(n){return CU.has(n.tagName)||n.tabIndex!==-1}const om=new WeakSet;function oE(n){return t=>{t.key==="Enter"&&n(t)}}function lx(n,t){n.dispatchEvent(new PointerEvent("pointer"+t,{isPrimary:!0,bubbles:!0}))}const kU=(n,t)=>{const e=n.currentTarget;if(!e)return;const s=oE(()=>{if(om.has(e))return;lx(e,"down");const r=oE(()=>{lx(e,"up")}),i=()=>lx(e,"cancel");e.addEventListener("keyup",r,t),e.addEventListener("blur",i,t)});e.addEventListener("keydown",s,t),e.addEventListener("blur",()=>e.removeEventListener("keydown",s),t)};function aE(n){return Fw(n)&&!d_()}function $U(n,t,e={}){const[s,r,i]=f_(n,e),o=l=>{const c=l.currentTarget;if(!aE(l))return;om.add(c);const h=t(c,l),d=(y,b)=>{window.removeEventListener("pointerup",p),window.removeEventListener("pointercancel",m),om.has(c)&&om.delete(c),aE(y)&&typeof h=="function"&&h(y,{success:b})},p=y=>{d(y,c===window||c===document||e.useGlobalTarget||p_(c,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",p,r),window.addEventListener("pointercancel",m,r)};return s.forEach(l=>{(e.useGlobalTarget?window:l).addEventListener("pointerdown",o,r),h_(l)&&(l.addEventListener("focus",h=>kU(h,r)),!TU(l)&&!l.hasAttribute("tabindex")&&(l.tabIndex=0))}),i}function m_(n){return $A(n)&&"ownerSVGElement"in n}function EU(n){return m_(n)&&n.tagName==="svg"}const as=n=>!!(n&&n.getVelocity),IU=[...a_,bn,Fo],NU=n=>IU.find(o_(n)),Lw=St.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function lE(n,t){if(typeof n=="function")return n(t);n!=null&&(n.current=t)}function AU(...n){return t=>{let e=!1;const s=n.map(r=>{const i=lE(r,t);return!e&&typeof i=="function"&&(e=!0),i});if(e)return()=>{for(let r=0;r<s.length;r++){const i=s[r];typeof i=="function"?i():lE(n[r],null)}}}}function _U(...n){return St.useCallback(AU(...n),n)}class RU extends St.Component{getSnapshotBeforeUpdate(t){const e=this.props.childRef.current;if(e&&t.isPresent&&!this.props.isPresent){const s=e.offsetParent,r=h_(s)&&s.offsetWidth||0,i=this.props.sizeRef.current;i.height=e.offsetHeight||0,i.width=e.offsetWidth||0,i.top=e.offsetTop,i.left=e.offsetLeft,i.right=r-i.width-i.left}return null}componentDidUpdate(){}render(){return this.props.children}}function DU({children:n,isPresent:t,anchorX:e,root:s}){const r=St.useId(),i=St.useRef(null),o=St.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:l}=St.useContext(Lw),c=_U(i,n?.ref);return St.useInsertionEffect(()=>{const{width:h,height:d,top:p,left:m,right:y}=o.current;if(t||!i.current||!h||!d)return;const b=e==="left"?`left: ${m}`:`right: ${y}`;i.current.dataset.motionPopId=r;const x=document.createElement("style");l&&(x.nonce=l);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${p}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[t]),it.jsx(RU,{isPresent:t,childRef:i,sizeRef:o,children:St.cloneElement(n,{ref:c})})}const OU=({children:n,initial:t,isPresent:e,onExitComplete:s,custom:r,presenceAffectsLayout:i,mode:o,anchorX:l,root:c})=>{const h=mw(MU),d=St.useId();let p=!0,m=St.useMemo(()=>(p=!1,{id:d,initial:t,isPresent:e,custom:r,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[e,h,s]);return i&&p&&(m={...m}),St.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[e]),St.useEffect(()=>{!e&&!h.size&&s&&s()},[e]),o==="popLayout"&&(n=it.jsx(DU,{isPresent:e,anchorX:l,root:c,children:n})),it.jsx(sg.Provider,{value:m,children:n})};function MU(){return new Map}function g_(n=!0){const t=St.useContext(sg);if(t===null)return[!0,null];const{isPresent:e,onExitComplete:s,register:r}=t,i=St.useId();St.useEffect(()=>{if(n)return r(i)},[n]);const o=St.useCallback(()=>n&&s&&s(i),[i,s,n]);return!e&&s?[!1,o]:[!0]}const Bp=n=>n.key||"";function cE(n){const t=[];return St.Children.forEach(n,e=>{St.isValidElement(e)&&t.push(e)}),t}const FU=({children:n,custom:t,initial:e=!0,onExitComplete:s,presenceAffectsLayout:r=!0,mode:i="sync",propagate:o=!1,anchorX:l="left",root:c})=>{const[h,d]=g_(o),p=St.useMemo(()=>cE(n),[n]),m=o&&!h?[]:p.map(Bp),y=St.useRef(!0),b=St.useRef(p),x=mw(()=>new Map),[w,S]=St.useState(p),[T,k]=St.useState(p);TA(()=>{y.current=!1,b.current=p;for(let N=0;N<T.length;N++){const _=Bp(T[N]);m.includes(_)?x.delete(_):x.get(_)!==!0&&x.set(_,!1)}},[T,m.length,m.join("-")]);const $=[];if(p!==w){let N=[...p];for(let _=0;_<T.length;_++){const R=T[_],D=Bp(R);m.includes(D)||(N.splice(_,0,R),$.push(R))}return i==="wait"&&$.length&&(N=$),k(cE(N)),S(p),null}const{forceRender:E}=St.useContext(pw);return it.jsx(it.Fragment,{children:T.map(N=>{const _=Bp(N),R=o&&!h?!1:p===T||m.includes(_),D=()=>{if(x.has(_))x.set(_,!0);else return;let O=!0;x.forEach(A=>{A||(O=!1)}),O&&(E?.(),k(b.current),o&&d?.(),s&&s())};return it.jsx(OU,{isPresent:R,initial:!y.current||e?void 0:!1,custom:t,presenceAffectsLayout:r,mode:i,root:c,onExitComplete:R?void 0:D,anchorX:l,children:N},_)})})},y_=St.createContext({strict:!1}),uE={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Ac={};for(const n in uE)Ac[n]={isEnabled:t=>uE[n].some(e=>!!t[e])};function LU(n){for(const t in n)Ac[t]={...Ac[t],...n[t]}}const PU=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function wm(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||PU.has(n)}let b_=n=>!wm(n);function zU(n){typeof n=="function"&&(b_=t=>t.startsWith("on")?!wm(t):n(t))}try{zU(require("@emotion/is-prop-valid").default)}catch{}function BU(n,t,e){const s={};for(const r in n)r==="values"&&typeof n.values=="object"||(b_(r)||e===!0&&wm(r)||!t&&!wm(r)||n.draggable&&r.startsWith("onDrag"))&&(s[r]=n[r]);return s}const rg=St.createContext({});function ig(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function Nh(n){return typeof n=="string"||Array.isArray(n)}const Pw=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],zw=["initial",...Pw];function og(n){return ig(n.animate)||zw.some(t=>Nh(n[t]))}function x_(n){return!!(og(n)||n.variants)}function VU(n,t){if(og(n)){const{initial:e,animate:s}=n;return{initial:e===!1||Nh(e)?e:void 0,animate:Nh(s)?s:void 0}}return n.inherit!==!1?t:{}}function UU(n){const{initial:t,animate:e}=VU(n,St.useContext(rg));return St.useMemo(()=>({initial:t,animate:e}),[hE(t),hE(e)])}function hE(n){return Array.isArray(n)?n.join(" "):n}function dE(n,t){return t.max===t.min?0:n/(t.max-t.min)*100}const eh={correct:(n,t)=>{if(!t.target)return n;if(typeof n=="string")if(Wt.test(n))n=parseFloat(n);else return n;const e=dE(n,t.target.x),s=dE(n,t.target.y);return`${e}% ${s}%`}},jU={correct:(n,{treeScale:t,projectionDelta:e})=>{const s=n,r=Fo.parse(n);if(r.length>5)return s;const i=Fo.createTransformer(n),o=typeof r[0]!="number"?1:0,l=e.x.scale*t.x,c=e.y.scale*t.y;r[0+o]/=l,r[1+o]/=c;const h=Xe(l,c,.5);return typeof r[2+o]=="number"&&(r[2+o]/=h),typeof r[3+o]=="number"&&(r[3+o]/=h),i(r)}},av={borderRadius:{...eh,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:eh,borderTopRightRadius:eh,borderBottomLeftRadius:eh,borderBottomRightRadius:eh,boxShadow:jU};function v_(n,{layout:t,layoutId:e}){return Gc.has(n)||n.startsWith("origin")||(t||e!==void 0)&&(!!av[n]||n==="opacity")}const GU={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},WU=jc.length;function HU(n,t,e){let s="",r=!0;for(let i=0;i<WU;i++){const o=jc[i],l=n[o];if(l===void 0)continue;let c=!0;if(typeof l=="number"?c=l===(o.startsWith("scale")?1:0):c=parseFloat(l)===0,!c||e){const h=u_(l,Ow[o]);if(!c){r=!1;const d=GU[o]||o;s+=`${d}(${h}) `}e&&(t[o]=h)}}return s=s.trim(),e?s=e(t,r?"":s):r&&(s="none"),s}function Bw(n,t,e){const{style:s,vars:r,transformOrigin:i}=n;let o=!1,l=!1;for(const c in t){const h=t[c];if(Gc.has(c)){o=!0;continue}else if(VA(c)){r[c]=h;continue}else{const d=u_(h,Ow[c]);c.startsWith("origin")?(l=!0,i[c]=d):s[c]=d}}if(t.transform||(o||e?s.transform=HU(t,n.transform,e):s.transform&&(s.transform="none")),l){const{originX:c="50%",originY:h="50%",originZ:d=0}=i;s.transformOrigin=`${c} ${h} ${d}`}}const Vw=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function w_(n,t,e){for(const s in t)!as(t[s])&&!v_(s,e)&&(n[s]=t[s])}function qU({transformTemplate:n},t){return St.useMemo(()=>{const e=Vw();return Bw(e,t,n),Object.assign({},e.vars,e.style)},[t])}function KU(n,t){const e=n.style||{},s={};return w_(s,e,n),Object.assign(s,qU(n,t)),s}function XU(n,t){const e={},s=KU(n,t);return n.drag&&n.dragListener!==!1&&(e.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(e.tabIndex=0),e.style=s,e}const YU={offset:"stroke-dashoffset",array:"stroke-dasharray"},ZU={offset:"strokeDashoffset",array:"strokeDasharray"};function JU(n,t,e=1,s=0,r=!0){n.pathLength=1;const i=r?YU:ZU;n[i.offset]=Wt.transform(-s);const o=Wt.transform(t),l=Wt.transform(e);n[i.array]=`${o} ${l}`}function S_(n,{attrX:t,attrY:e,attrScale:s,pathLength:r,pathSpacing:i=1,pathOffset:o=0,...l},c,h,d){if(Bw(n,l,h),c){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:m}=n;p.transform&&(m.transform=p.transform,delete p.transform),(m.transform||p.transformOrigin)&&(m.transformOrigin=p.transformOrigin??"50% 50%",delete p.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete p.transformBox),t!==void 0&&(p.x=t),e!==void 0&&(p.y=e),s!==void 0&&(p.scale=s),r!==void 0&&JU(p,r,i,o,!1)}const C_=()=>({...Vw(),attrs:{}}),T_=n=>typeof n=="string"&&n.toLowerCase()==="svg";function QU(n,t,e,s){const r=St.useMemo(()=>{const i=C_();return S_(i,t,T_(s),n.transformTemplate,n.style),{...i.attrs,style:{...i.style}}},[t]);if(n.style){const i={};w_(i,n.style,n),r.style={...i,...r.style}}return r}const t4=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Uw(n){return typeof n!="string"||n.includes("-")?!1:!!(t4.indexOf(n)>-1||/[A-Z]/u.test(n))}function e4(n,t,e,{latestValues:s},r,i=!1){const l=(Uw(n)?QU:XU)(t,s,r,n),c=BU(t,typeof n=="string",i),h=n!==St.Fragment?{...c,...l,ref:e}:{},{children:d}=t,p=St.useMemo(()=>as(d)?d.get():d,[d]);return St.createElement(n,{...h,children:p})}function fE(n){const t=[{},{}];return n?.values.forEach((e,s)=>{t[0][s]=e.get(),t[1][s]=e.getVelocity()}),t}function jw(n,t,e,s){if(typeof t=="function"){const[r,i]=fE(s);t=t(e!==void 0?e:n.custom,r,i)}if(typeof t=="string"&&(t=n.variants&&n.variants[t]),typeof t=="function"){const[r,i]=fE(s);t=t(e!==void 0?e:n.custom,r,i)}return t}function am(n){return as(n)?n.get():n}function n4({scrapeMotionValuesFromProps:n,createRenderState:t},e,s,r){return{latestValues:s4(e,s,r,n),renderState:t()}}function s4(n,t,e,s){const r={},i=s(n,{});for(const m in i)r[m]=am(i[m]);let{initial:o,animate:l}=n;const c=og(n),h=x_(n);t&&h&&!c&&n.inherit!==!1&&(o===void 0&&(o=t.initial),l===void 0&&(l=t.animate));let d=e?e.initial===!1:!1;d=d||o===!1;const p=d?l:o;if(p&&typeof p!="boolean"&&!ig(p)){const m=Array.isArray(p)?p:[p];for(let y=0;y<m.length;y++){const b=jw(n,m[y]);if(b){const{transitionEnd:x,transition:w,...S}=b;for(const T in S){let k=S[T];if(Array.isArray(k)){const $=d?k.length-1:0;k=k[$]}k!==null&&(r[T]=k)}for(const T in x)r[T]=x[T]}}}return r}const k_=n=>(t,e)=>{const s=St.useContext(rg),r=St.useContext(sg),i=()=>n4(n,t,s,r);return e?i():mw(i)};function Gw(n,t,e){const{style:s}=n,r={};for(const i in s)(as(s[i])||t.style&&as(t.style[i])||v_(i,n)||e?.getValue(i)?.liveStyle!==void 0)&&(r[i]=s[i]);return r}const r4=k_({scrapeMotionValuesFromProps:Gw,createRenderState:Vw});function $_(n,t,e){const s=Gw(n,t,e);for(const r in n)if(as(n[r])||as(t[r])){const i=jc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;s[i]=n[r]}return s}const i4=k_({scrapeMotionValuesFromProps:$_,createRenderState:C_}),o4=Symbol.for("motionComponentSymbol");function yc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function a4(n,t,e){return St.useCallback(s=>{s&&n.onMount&&n.onMount(s),t&&(s?t.mount(s):t.unmount()),e&&(typeof e=="function"?e(s):yc(e)&&(e.current=s))},[t])}const Ww=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),l4="framerAppearId",E_="data-"+Ww(l4),I_=St.createContext({});function c4(n,t,e,s,r){const{visualElement:i}=St.useContext(rg),o=St.useContext(y_),l=St.useContext(sg),c=St.useContext(Lw).reducedMotion,h=St.useRef(null);s=s||o.renderer,!h.current&&s&&(h.current=s(n,{visualState:t,parent:i,props:e,presenceContext:l,blockInitialAnimation:l?l.initial===!1:!1,reducedMotionConfig:c}));const d=h.current,p=St.useContext(I_);d&&!d.projection&&r&&(d.type==="html"||d.type==="svg")&&u4(h.current,e,r,p);const m=St.useRef(!1);St.useInsertionEffect(()=>{d&&m.current&&d.update(e,l)});const y=e[E_],b=St.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return TA(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),St.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function u4(n,t,e,s){const{layoutId:r,layout:i,drag:o,dragConstraints:l,layoutScroll:c,layoutRoot:h,layoutCrossfade:d}=t;n.projection=new e(n.latestValues,t["data-framer-portal-id"]?void 0:N_(n.parent)),n.projection.setOptions({layoutId:r,layout:i,alwaysMeasureLayout:!!o||l&&yc(l),visualElement:n,animationType:typeof i=="string"?i:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:c,layoutRoot:h})}function N_(n){if(n)return n.options.allowProjection!==!1?n.projection:N_(n.parent)}function cx(n,{forwardMotionProps:t=!1}={},e,s){e&&LU(e);const r=Uw(n)?i4:r4;function i(l,c){let h;const d={...St.useContext(Lw),...l,layoutId:h4(l)},{isStatic:p}=d,m=UU(l),y=r(l,p);if(!p&&gw){d4();const b=f4(d);h=b.MeasureLayout,m.visualElement=c4(n,y,d,s,b.ProjectionNode)}return it.jsxs(rg.Provider,{value:m,children:[h&&m.visualElement?it.jsx(h,{visualElement:m.visualElement,...d}):null,e4(n,l,a4(y,m.visualElement,c),y,p,t)]})}i.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const o=St.forwardRef(i);return o[o4]=n,o}function h4({layoutId:n}){const t=St.useContext(pw).id;return t&&n!==void 0?t+"-"+n:n}function d4(n,t){St.useContext(y_).strict}function f4(n){const{drag:t,layout:e}=Ac;if(!t&&!e)return{};const s={...t,...e};return{MeasureLayout:t?.isEnabled(n)||e?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function p4(n,t){if(typeof Proxy>"u")return cx;const e=new Map,s=(i,o)=>cx(i,o,n,t),r=(i,o)=>s(i,o);return new Proxy(r,{get:(i,o)=>o==="create"?s:(e.has(o)||e.set(o,cx(o,void 0,n,t)),e.get(o))})}function A_({top:n,left:t,right:e,bottom:s}){return{x:{min:t,max:e},y:{min:n,max:s}}}function m4({x:n,y:t}){return{top:t.min,right:n.max,bottom:t.max,left:n.min}}function g4(n,t){if(!t)return n;const e=t({x:n.left,y:n.top}),s=t({x:n.right,y:n.bottom});return{top:e.y,left:e.x,bottom:s.y,right:s.x}}function ux(n){return n===void 0||n===1}function lv({scale:n,scaleX:t,scaleY:e}){return!ux(n)||!ux(t)||!ux(e)}function Ea(n){return lv(n)||__(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function __(n){return pE(n.x)||pE(n.y)}function pE(n){return n&&n!=="0%"}function Sm(n,t,e){const s=n-e,r=t*s;return e+r}function mE(n,t,e,s,r){return r!==void 0&&(n=Sm(n,r,s)),Sm(n,e,s)+t}function cv(n,t=0,e=1,s,r){n.min=mE(n.min,t,e,s,r),n.max=mE(n.max,t,e,s,r)}function R_(n,{x:t,y:e}){cv(n.x,t.translate,t.scale,t.originPoint),cv(n.y,e.translate,e.scale,e.originPoint)}const gE=.999999999999,yE=1.0000000000001;function y4(n,t,e,s=!1){const r=e.length;if(!r)return;t.x=t.y=1;let i,o;for(let l=0;l<r;l++){i=e[l],o=i.projectionDelta;const{visualElement:c}=i.options;c&&c.props.style&&c.props.style.display==="contents"||(s&&i.options.layoutScroll&&i.scroll&&i!==i.root&&xc(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),o&&(t.x*=o.x.scale,t.y*=o.y.scale,R_(n,o)),s&&Ea(i.latestValues)&&xc(n,i.latestValues))}t.x<yE&&t.x>gE&&(t.x=1),t.y<yE&&t.y>gE&&(t.y=1)}function bc(n,t){n.min=n.min+t,n.max=n.max+t}function bE(n,t,e,s,r=.5){const i=Xe(n.min,n.max,r);cv(n,t,e,i,s)}function xc(n,t){bE(n.x,t.x,t.scaleX,t.scale,t.originX),bE(n.y,t.y,t.scaleY,t.scale,t.originY)}function D_(n,t){return A_(g4(n.getBoundingClientRect(),t))}function b4(n,t,e){const s=D_(n,e),{scroll:r}=t;return r&&(bc(s.x,r.offset.x),bc(s.y,r.offset.y)),s}const xE=()=>({translate:0,scale:1,origin:0,originPoint:0}),vc=()=>({x:xE(),y:xE()}),vE=()=>({min:0,max:0}),Nn=()=>({x:vE(),y:vE()}),uv={current:null},O_={current:!1};function x4(){if(O_.current=!0,!!gw)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),t=()=>uv.current=n.matches;n.addEventListener("change",t),t()}else uv.current=!1}const v4=new WeakMap;function w4(n,t,e){for(const s in t){const r=t[s],i=e[s];if(as(r))n.addValue(s,r);else if(as(i))n.addValue(s,Nc(r,{owner:n}));else if(i!==r)if(n.hasValue(s)){const o=n.getValue(s);o.liveStyle===!0?o.jump(r):o.hasAnimated||o.set(r)}else{const o=n.getStaticValue(s);n.addValue(s,Nc(o!==void 0?o:r,{owner:n}))}}for(const s in e)t[s]===void 0&&n.removeValue(s);return t}const wE=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class S4{scrapeMotionValuesFromProps(t,e,s){return{}}constructor({parent:t,props:e,presenceContext:s,reducedMotionConfig:r,blockInitialAnimation:i,visualState:o},l={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Rw,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Ds.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,We.render(this.render,!1,!0))};const{latestValues:c,renderState:h}=o;this.latestValues=c,this.baseTarget={...c},this.initialValues=e.initial?{...c}:{},this.renderState=h,this.parent=t,this.props=e,this.presenceContext=s,this.depth=t?t.depth+1:0,this.reducedMotionConfig=r,this.options=l,this.blockInitialAnimation=!!i,this.isControllingVariants=og(e),this.isVariantNode=x_(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(t&&t.current);const{willChange:d,...p}=this.scrapeMotionValuesFromProps(e,{},this);for(const m in p){const y=p[m];c[m]!==void 0&&as(y)&&y.set(c[m])}}mount(t){this.current=t,v4.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((e,s)=>this.bindToMotionValue(s,e)),O_.current||x4(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:uv.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),Mo(this.notifyUpdate),Mo(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}addChild(t){this.children.add(t),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(t)}removeChild(t){this.children.delete(t),this.enteringChildren&&this.enteringChildren.delete(t)}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const s=Gc.has(t);s&&this.onBindTransform&&this.onBindTransform();const r=e.on("change",o=>{this.latestValues[t]=o,this.props.onUpdate&&We.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{r(),i&&i(),e.owner&&e.stop()})}sortNodePosition(t){return!this.current||!this.sortInstanceNodePosition||this.type!==t.type?0:this.sortInstanceNodePosition(this.current,t.current)}updateFeatures(){let t="animation";for(t in Ac){const e=Ac[t];if(!e)continue;const{isEnabled:s,Feature:r}=e;if(!this.features[t]&&r&&s(this.props)&&(this.features[t]=new r(this)),this.features[t]){const i=this.features[t];i.isMounted?i.update():(i.mount(),i.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):Nn()}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let s=0;s<wE.length;s++){const r=wE[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const i="on"+r,o=t[i];o&&(this.propEventSubscriptions[r]=this.on(r,o))}this.prevMotionValues=w4(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const s=this.values.get(t);e!==s&&(s&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let s=this.values.get(t);return s===void 0&&e!==void 0&&(s=Nc(e===null?void 0:e,{owner:this}),this.addValue(t,s)),s}readValue(t,e){let s=this.latestValues[t]!==void 0||!this.current?this.latestValues[t]:this.getBaseTargetFromProps(this.props,t)??this.readValueFromInstance(this.current,t,this.options);return s!=null&&(typeof s=="string"&&(kA(s)||EA(s))?s=parseFloat(s):!NU(s)&&Fo.test(e)&&(s=c_(t,e)),this.setBaseTarget(t,as(s)?s.get():s)),as(s)?s.get():s}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){const{initial:e}=this.props;let s;if(typeof e=="string"||typeof e=="object"){const i=jw(this.props,e,this.presenceContext?.custom);i&&(s=i[t])}if(e&&s!==void 0)return s;const r=this.getBaseTargetFromProps(this.props,t);return r!==void 0&&!as(r)?r:this.initialValues[t]!==void 0&&s===void 0?void 0:this.baseTarget[t]}on(t,e){return this.events[t]||(this.events[t]=new ww),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}scheduleRenderMicrotask(){Mw.render(this.render)}}class M_ extends S4{constructor(){super(...arguments),this.KeyframeResolver=yU}sortInstanceNodePosition(t,e){return t.compareDocumentPosition(e)&2?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:s}){delete e[t],delete s[t]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;as(t)&&(this.childSubscription=t.on("change",e=>{this.current&&(this.current.textContent=`${e}`)}))}}function F_(n,{style:t,vars:e},s,r){const i=n.style;let o;for(o in t)i[o]=t[o];r?.applyProjectionStyles(i,s);for(o in e)i.setProperty(o,e[o])}function C4(n){return window.getComputedStyle(n)}class T4 extends M_{constructor(){super(...arguments),this.type="html",this.renderInstance=F_}readValueFromInstance(t,e){if(Gc.has(e))return this.projection?.isProjecting?tv(e):FV(t,e);{const s=C4(t),r=(VA(e)?s.getPropertyValue(e):s[e])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(t,{transformPagePoint:e}){return D_(t,e)}build(t,e,s){Bw(t,e,s.transformTemplate)}scrapeMotionValuesFromProps(t,e,s){return Gw(t,e,s)}}const L_=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function k4(n,t,e,s){F_(n,t,void 0,s);for(const r in t.attrs)n.setAttribute(L_.has(r)?r:Ww(r),t.attrs[r])}class $4 extends M_{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=Nn}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(Gc.has(e)){const s=l_(e);return s&&s.default||0}return e=L_.has(e)?e:Ww(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,s){return $_(t,e,s)}build(t,e,s){S_(t,e,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(t,e,s,r){k4(t,e,s,r)}mount(t){this.isSVGTag=T_(t.tagName),super.mount(t)}}const E4=(n,t)=>Uw(n)?new $4(t):new T4(t,{allowProjection:n!==St.Fragment});function Sc(n,t,e){const s=n.getProps();return jw(s,t,e!==void 0?e:s.custom,n)}const hv=n=>Array.isArray(n);function I4(n,t,e){n.hasValue(t)?n.getValue(t).set(e):n.addValue(t,Nc(e))}function N4(n){return hv(n)?n[n.length-1]||0:n}function A4(n,t){const e=Sc(n,t);let{transitionEnd:s={},transition:r={},...i}=e||{};i={...i,...s};for(const o in i){const l=N4(i[o]);I4(n,o,l)}}function _4(n){return!!(as(n)&&n.add)}function dv(n,t){const e=n.getValue("willChange");if(_4(e))return e.add(t);if(!e&&ji.WillChange){const s=new ji.WillChange("auto");n.addValue("willChange",s),s.add(t)}}function P_(n){return n.props[E_]}const R4=n=>n!==null;function D4(n,{repeat:t,repeatType:e="loop"},s){const r=n.filter(R4),i=t&&e!=="loop"&&t%2===1?0:r.length-1;return r[i]}const O4={type:"spring",stiffness:500,damping:25,restSpeed:10},M4=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),F4={type:"keyframes",duration:.8},L4={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},P4=(n,{keyframes:t})=>t.length>2?F4:Gc.has(n)?n.startsWith("scale")?M4(t[1]):O4:L4;function z4({when:n,delay:t,delayChildren:e,staggerChildren:s,staggerDirection:r,repeat:i,repeatType:o,repeatDelay:l,from:c,elapsed:h,...d}){return!!Object.keys(d).length}const Hw=(n,t,e,s={},r,i)=>o=>{const l=Dw(s,n)||{},c=l.delay||s.delay||0;let{elapsed:h=0}=s;h=h-oi(c);const d={keyframes:Array.isArray(e)?e:[null,e],ease:"easeOut",velocity:t.getVelocity(),...l,delay:-h,onUpdate:m=>{t.set(m),l.onUpdate&&l.onUpdate(m)},onComplete:()=>{o(),l.onComplete&&l.onComplete()},name:n,motionValue:t,element:i?void 0:r};z4(l)||Object.assign(d,P4(n,d)),d.duration&&(d.duration=oi(d.duration)),d.repeatDelay&&(d.repeatDelay=oi(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let p=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(iv(d),d.delay===0&&(p=!0)),(ji.instantAnimations||ji.skipAnimations)&&(p=!0,iv(d),d.delay=0),d.allowFlatten=!l.type&&!l.ease,p&&!i&&t.get()!==void 0){const m=D4(d.keyframes,l);if(m!==void 0){We.update(()=>{d.onUpdate(m),d.onComplete()});return}}return l.isSync?new _w(d):new iU(d)};function B4({protectedKeys:n,needsAnimating:t},e){const s=n.hasOwnProperty(e)&&t[e]!==!0;return t[e]=!1,s}function z_(n,t,{delay:e=0,transitionOverride:s,type:r}={}){let{transition:i=n.getDefaultTransition(),transitionEnd:o,...l}=t;s&&(i=s);const c=[],h=r&&n.animationState&&n.animationState.getState()[r];for(const d in l){const p=n.getValue(d,n.latestValues[d]??null),m=l[d];if(m===void 0||h&&B4(h,d))continue;const y={delay:e,...Dw(i||{},d)},b=p.get();if(b!==void 0&&!p.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=P_(n);if(S){const T=window.MotionHandoffAnimation(S,d,We);T!==null&&(y.startTime=T,x=!0)}}dv(n,d),p.start(Hw(d,p,m,n.shouldReduceMotion&&i_.has(d)?{type:!1}:y,n,x));const w=p.animation;w&&c.push(w)}return o&&Promise.all(c).then(()=>{We.update(()=>{o&&A4(n,o)})}),c}function B_(n,t,e,s=0,r=1){const i=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(t),o=n.size,l=(o-1)*s;return typeof e=="function"?e(i,o):r===1?i*s:l-i*s}function fv(n,t,e={}){const s=Sc(n,t,e.type==="exit"?n.presenceContext?.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=s||{};e.transitionOverride&&(r=e.transitionOverride);const i=s?()=>Promise.all(z_(n,s,e)):()=>Promise.resolve(),o=n.variantChildren&&n.variantChildren.size?(c=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:p}=r;return V4(n,t,c,h,d,p,e)}:()=>Promise.resolve(),{when:l}=r;if(l){const[c,h]=l==="beforeChildren"?[i,o]:[o,i];return c().then(()=>h())}else return Promise.all([i(),o(e.delay)])}function V4(n,t,e=0,s=0,r=0,i=1,o){const l=[];for(const c of n.variantChildren)c.notify("AnimationStart",t),l.push(fv(c,t,{...o,delay:e+(typeof s=="function"?0:s)+B_(n.variantChildren,c,s,r,i)}).then(()=>c.notify("AnimationComplete",t)));return Promise.all(l)}function U4(n,t,e={}){n.notify("AnimationStart",t);let s;if(Array.isArray(t)){const r=t.map(i=>fv(n,i,e));s=Promise.all(r)}else if(typeof t=="string")s=fv(n,t,e);else{const r=typeof t=="function"?Sc(n,t,e.custom):t;s=Promise.all(z_(n,r,e))}return s.then(()=>{n.notify("AnimationComplete",t)})}function V_(n,t){if(!Array.isArray(t))return!1;const e=t.length;if(e!==n.length)return!1;for(let s=0;s<e;s++)if(t[s]!==n[s])return!1;return!0}const j4=zw.length;function U_(n){if(!n)return;if(!n.isControllingVariants){const e=n.parent?U_(n.parent)||{}:{};return n.props.initial!==void 0&&(e.initial=n.props.initial),e}const t={};for(let e=0;e<j4;e++){const s=zw[e],r=n.props[s];(Nh(r)||r===!1)&&(t[s]=r)}return t}const G4=[...Pw].reverse(),W4=Pw.length;function H4(n){return t=>Promise.all(t.map(({animation:e,options:s})=>U4(n,e,s)))}function q4(n){let t=H4(n),e=SE(),s=!0;const r=c=>(h,d)=>{const p=Sc(n,d,c==="exit"?n.presenceContext?.custom:void 0);if(p){const{transition:m,transitionEnd:y,...b}=p;h={...h,...b,...y}}return h};function i(c){t=c(n)}function o(c){const{props:h}=n,d=U_(n.parent)||{},p=[],m=new Set;let y={},b=1/0;for(let w=0;w<W4;w++){const S=G4[w],T=e[S],k=h[S]!==void 0?h[S]:d[S],$=Nh(k),E=S===c?T.isActive:null;E===!1&&(b=w);let N=k===d[S]&&k!==h[S]&&$;if(N&&s&&n.manuallyAnimateOnMount&&(N=!1),T.protectedKeys={...y},!T.isActive&&E===null||!k&&!T.prevProp||ig(k)||typeof k=="boolean")continue;const _=K4(T.prevProp,k);let R=_||S===c&&T.isActive&&!N&&$||w>b&&$,D=!1;const O=Array.isArray(k)?k:[k];let A=O.reduce(r(S),{});E===!1&&(A={});const{prevResolvedValues:z={}}=T,q={...z,...A},W=V=>{R=!0,m.has(V)&&(D=!0,m.delete(V)),T.needsAnimating[V]=!0;const G=n.getValue(V);G&&(G.liveStyle=!1)};for(const V in q){const G=A[V],tt=z[V];if(y.hasOwnProperty(V))continue;let Z=!1;hv(G)&&hv(tt)?Z=!V_(G,tt):Z=G!==tt,Z?G!=null?W(V):m.add(V):G!==void 0&&m.has(V)?W(V):T.protectedKeys[V]=!0}T.prevProp=k,T.prevResolvedValues=A,T.isActive&&(y={...y,...A}),s&&n.blockInitialAnimation&&(R=!1);const X=N&&_;R&&(!X||D)&&p.push(...O.map(V=>{const G={type:S};if(typeof V=="string"&&s&&!X&&n.manuallyAnimateOnMount&&n.parent){const{parent:tt}=n,Z=Sc(tt,V);if(tt.enteringChildren&&Z){const{delayChildren:F}=Z.transition||{};G.delay=B_(tt.enteringChildren,n,F)}}return{animation:V,options:G}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const S=Sc(n,Array.isArray(h.initial)?h.initial[0]:h.initial);S&&S.transition&&(w.transition=S.transition)}m.forEach(S=>{const T=n.getBaseTarget(S),k=n.getValue(S);k&&(k.liveStyle=!0),w[S]=T??null}),p.push({animation:w})}let x=!!p.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?t(p):Promise.resolve()}function l(c,h){if(e[c].isActive===h)return Promise.resolve();n.variantChildren?.forEach(p=>p.animationState?.setActive(c,h)),e[c].isActive=h;const d=o(c);for(const p in e)e[p].protectedKeys={};return d}return{animateChanges:o,setActive:l,setAnimateFunction:i,getState:()=>e,reset:()=>{e=SE()}}}function K4(n,t){return typeof t=="string"?t!==n:Array.isArray(t)?!V_(t,n):!1}function va(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function SE(){return{animate:va(!0),whileInView:va(),whileHover:va(),whileTap:va(),whileDrag:va(),whileFocus:va(),exit:va()}}class jo{constructor(t){this.isMounted=!1,this.node=t}update(){}}class X4 extends jo{constructor(t){super(t),t.animationState||(t.animationState=q4(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();ig(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:e}=this.node.prevProps||{};t!==e&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let Y4=0;class Z4 extends jo{constructor(){super(...arguments),this.id=Y4++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:e}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===s)return;const r=this.node.animationState.setActive("exit",!t);e&&!t&&r.then(()=>{e(this.id)})}mount(){const{register:t,onExitComplete:e}=this.node.presenceContext||{};e&&e(this.id),t&&(this.unmount=t(this.id))}unmount(){}}const J4={animation:{Feature:X4},exit:{Feature:Z4}};function Ah(n,t,e,s={passive:!0}){return n.addEventListener(t,e,s),()=>n.removeEventListener(t,e)}function Qh(n){return{point:{x:n.pageX,y:n.pageY}}}const Q4=n=>t=>Fw(t)&&n(t,Qh(t));function yh(n,t,e,s){return Ah(n,t,Q4(e),s)}const j_=1e-4,tj=1-j_,ej=1+j_,G_=.01,nj=0-G_,sj=0+G_;function xs(n){return n.max-n.min}function rj(n,t,e){return Math.abs(n-t)<=e}function CE(n,t,e,s=.5){n.origin=s,n.originPoint=Xe(t.min,t.max,n.origin),n.scale=xs(e)/xs(t),n.translate=Xe(e.min,e.max,n.origin)-n.originPoint,(n.scale>=tj&&n.scale<=ej||isNaN(n.scale))&&(n.scale=1),(n.translate>=nj&&n.translate<=sj||isNaN(n.translate))&&(n.translate=0)}function bh(n,t,e,s){CE(n.x,t.x,e.x,s?s.originX:void 0),CE(n.y,t.y,e.y,s?s.originY:void 0)}function TE(n,t,e){n.min=e.min+t.min,n.max=n.min+xs(t)}function ij(n,t,e){TE(n.x,t.x,e.x),TE(n.y,t.y,e.y)}function kE(n,t,e){n.min=t.min-e.min,n.max=n.min+xs(t)}function Cm(n,t,e){kE(n.x,t.x,e.x),kE(n.y,t.y,e.y)}function pr(n){return[n("x"),n("y")]}const W_=({current:n})=>n?n.ownerDocument.defaultView:null,$E=(n,t)=>Math.abs(n-t);function oj(n,t){const e=$E(n.x,t.x),s=$E(n.y,t.y);return Math.sqrt(e**2+s**2)}class H_{constructor(t,e,{transformPagePoint:s,contextWindow:r=window,dragSnapToOrigin:i=!1,distanceThreshold:o=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=dx(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=oj(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=Yn;this.history.push({...x,timestamp:w});const{onStart:S,onMove:T}=this.handlers;y||(S&&S(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),T&&T(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=hx(y,this.transformPagePoint),We.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const S=dx(m.type==="pointercancel"?this.lastMoveEventInfo:hx(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,S),x&&x(m,S)},!Fw(t))return;this.dragSnapToOrigin=i,this.handlers=e,this.transformPagePoint=s,this.distanceThreshold=o,this.contextWindow=r||window;const l=Qh(t),c=hx(l,this.transformPagePoint),{point:h}=c,{timestamp:d}=Yn;this.history=[{...h,timestamp:d}];const{onSessionStart:p}=e;p&&p(t,dx(c,this.history)),this.removeListeners=Yh(yh(this.contextWindow,"pointermove",this.handlePointerMove),yh(this.contextWindow,"pointerup",this.handlePointerUp),yh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(t){this.handlers=t}end(){this.removeListeners&&this.removeListeners(),Mo(this.updatePoint)}}function hx(n,t){return t?{point:t(n.point)}:n}function EE(n,t){return{x:n.x-t.x,y:n.y-t.y}}function dx({point:n},t){return{point:n,delta:EE(n,q_(t)),offset:EE(n,aj(t)),velocity:lj(t,.1)}}function aj(n){return n[0]}function q_(n){return n[n.length-1]}function lj(n,t){if(n.length<2)return{x:0,y:0};let e=n.length-1,s=null;const r=q_(n);for(;e>=0&&(s=n[e],!(r.timestamp-s.timestamp>oi(t)));)e--;if(!s)return{x:0,y:0};const i=br(r.timestamp-s.timestamp);if(i===0)return{x:0,y:0};const o={x:(r.x-s.x)/i,y:(r.y-s.y)/i};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}function cj(n,{min:t,max:e},s){return t!==void 0&&n<t?n=s?Xe(t,n,s.min):Math.max(n,t):e!==void 0&&n>e&&(n=s?Xe(e,n,s.max):Math.min(n,e)),n}function IE(n,t,e){return{min:t!==void 0?n.min+t:void 0,max:e!==void 0?n.max+e-(n.max-n.min):void 0}}function uj(n,{top:t,left:e,bottom:s,right:r}){return{x:IE(n.x,e,r),y:IE(n.y,t,s)}}function NE(n,t){let e=t.min-n.min,s=t.max-n.max;return t.max-t.min<n.max-n.min&&([e,s]=[s,e]),{min:e,max:s}}function hj(n,t){return{x:NE(n.x,t.x),y:NE(n.y,t.y)}}function dj(n,t){let e=.5;const s=xs(n),r=xs(t);return r>s?e=$h(t.min,t.max-s,n.min):s>r&&(e=$h(n.min,n.max-r,t.min)),Ui(0,1,e)}function fj(n,t){const e={};return t.min!==void 0&&(e.min=t.min-n.min),t.max!==void 0&&(e.max=t.max-n.min),e}const pv=.35;function pj(n=pv){return n===!1?n=0:n===!0&&(n=pv),{x:AE(n,"left","right"),y:AE(n,"top","bottom")}}function AE(n,t,e){return{min:_E(n,t),max:_E(n,e)}}function _E(n,t){return typeof n=="number"?n:n[t]||0}const mj=new WeakMap;class gj{constructor(t){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=Nn(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=t}start(t,{snapToCursor:e=!1,distanceThreshold:s}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const i=p=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),e&&this.snapToCursor(Qh(p).point)},o=(p,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=wU(y),!this.openDragLock))return;this.latestPointerEvent=p,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),pr(S=>{let T=this.getAxisMotionValue(S).get()||0;if(ai.test(T)){const{projection:k}=this.visualElement;if(k&&k.layout){const $=k.layout.layoutBox[S];$&&(T=xs($)*(parseFloat(T)/100))}}this.originPoint[S]=T}),x&&We.postRender(()=>x(p,m)),dv(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},l=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:S}=m;if(b&&this.currentDirection===null){this.currentDirection=yj(S),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,S),this.updateAxis("y",m.point,S),this.visualElement.render(),w&&w(p,m)},c=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m,this.stop(p,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>pr(p=>this.getAnimationState(p)==="paused"&&this.getAxisMotionValue(p).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new H_(t,{onSessionStart:i,onStart:o,onMove:l,onSessionEnd:c,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:W_(this.visualElement)})}stop(t,e){const s=t||this.latestPointerEvent,r=e||this.latestPanInfo,i=this.isDragging;if(this.cancel(),!i||!r||!s)return;const{velocity:o}=r;this.startAnimation(o);const{onDragEnd:l}=this.getProps();l&&We.postRender(()=>l(s,r))}cancel(){this.isDragging=!1;const{projection:t,animationState:e}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),e&&e.setActive("whileDrag",!1)}updateAxis(t,e,s){const{drag:r}=this.getProps();if(!s||!Vp(t,r,this.currentDirection))return;const i=this.getAxisMotionValue(t);let o=this.originPoint[t]+s[t];this.constraints&&this.constraints[t]&&(o=cj(o,this.constraints[t],this.elastic[t])),i.set(o)}resolveConstraints(){const{dragConstraints:t,dragElastic:e}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;t&&yc(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):t&&s?this.constraints=uj(s.layoutBox,t):this.constraints=!1,this.elastic=pj(e),r!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&pr(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=fj(s.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:e}=this.getProps();if(!t||!yc(t))return!1;const s=t.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const i=b4(s,r.root,this.visualElement.getTransformPagePoint());let o=hj(r.layout.layoutBox,i);if(e){const l=e(m4(o));this.hasMutatedConstraints=!!l,l&&(o=A_(l))}return o}startAnimation(t){const{drag:e,dragMomentum:s,dragElastic:r,dragTransition:i,dragSnapToOrigin:o,onDragTransitionEnd:l}=this.getProps(),c=this.constraints||{},h=pr(d=>{if(!Vp(d,e,this.currentDirection))return;let p=c&&c[d]||{};o&&(p={min:0,max:0});const m=r?200:1e6,y=r?40:1e7,b={type:"inertia",velocity:s?t[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...i,...p};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(l)}startAxisValueAnimation(t,e){const s=this.getAxisMotionValue(t);return dv(this.visualElement,t),s.start(Hw(t,s,0,e,this.visualElement,!1))}stopAnimation(){pr(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){pr(t=>this.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){return this.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){const e=`_drag${t.toUpperCase()}`,s=this.visualElement.getProps(),r=s[e];return r||this.visualElement.getValue(t,(s.initial?s.initial[t]:void 0)||0)}snapToCursor(t){pr(e=>{const{drag:s}=this.getProps();if(!Vp(e,s,this.currentDirection))return;const{projection:r}=this.visualElement,i=this.getAxisMotionValue(e);if(r&&r.layout){const{min:o,max:l}=r.layout.layoutBox[e];i.set(t[e]-Xe(o,l,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:e}=this.getProps(),{projection:s}=this.visualElement;if(!yc(e)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};pr(o=>{const l=this.getAxisMotionValue(o);if(l&&this.constraints!==!1){const c=l.get();r[o]=dj({min:c,max:c},this.constraints[o])}});const{transformTemplate:i}=this.visualElement.getProps();this.visualElement.current.style.transform=i?i({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),pr(o=>{if(!Vp(o,t,null))return;const l=this.getAxisMotionValue(o),{min:c,max:h}=this.constraints[o];l.set(Xe(c,h,r[o]))})}addListeners(){if(!this.visualElement.current)return;mj.set(this.visualElement,this);const t=this.visualElement.current,e=yh(t,"pointerdown",c=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(c)}),s=()=>{const{dragConstraints:c}=this.getProps();yc(c)&&c.current&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,i=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),We.read(s);const o=Ah(window,"resize",()=>this.scalePositionWithinConstraints()),l=r.addEventListener("didUpdate",(({delta:c,hasLayoutChanged:h})=>{this.isDragging&&h&&(pr(d=>{const p=this.getAxisMotionValue(d);p&&(this.originPoint[d]+=c[d].translate,p.set(p.get()+c[d].translate))}),this.visualElement.render())}));return()=>{o(),e(),i(),l&&l()}}getProps(){const t=this.visualElement.getProps(),{drag:e=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:i=!1,dragElastic:o=pv,dragMomentum:l=!0}=t;return{...t,drag:e,dragDirectionLock:s,dragPropagation:r,dragConstraints:i,dragElastic:o,dragMomentum:l}}}function Vp(n,t,e){return(t===!0||t===n)&&(e===null||e===n)}function yj(n,t=10){let e=null;return Math.abs(n.y)>t?e="y":Math.abs(n.x)>t&&(e="x"),e}class bj extends jo{constructor(t){super(t),this.removeGroupControls=wr,this.removeListeners=wr,this.controls=new gj(t)}mount(){const{dragControls:t}=this.node.getProps();t&&(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||wr}unmount(){this.removeGroupControls(),this.removeListeners()}}const RE=n=>(t,e)=>{n&&We.postRender(()=>n(t,e))};class xj extends jo{constructor(){super(...arguments),this.removePointerDownListener=wr}onPointerDown(t){this.session=new H_(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:W_(this.node)})}createPanHandlers(){const{onPanSessionStart:t,onPanStart:e,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:RE(t),onStart:RE(e),onMove:s,onEnd:(i,o)=>{delete this.session,r&&We.postRender(()=>r(i,o))}}}mount(){this.removePointerDownListener=yh(this.node.current,"pointerdown",t=>this.onPointerDown(t))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const lm={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let fx=!1;class vj extends St.Component{componentDidMount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:s,layoutId:r}=this.props,{projection:i}=t;i&&(e.group&&e.group.add(i),s&&s.register&&r&&s.register(i),fx&&i.root.didUpdate(),i.addEventListener("animationComplete",()=>{this.safeToRemove()}),i.setOptions({...i.options,onExitComplete:()=>this.safeToRemove()})),lm.hasEverUpdated=!0}getSnapshotBeforeUpdate(t){const{layoutDependency:e,visualElement:s,drag:r,isPresent:i}=this.props,{projection:o}=s;return o&&(o.isPresent=i,fx=!0,r||t.layoutDependency!==e||e===void 0||t.isPresent!==i?o.willUpdate():this.safeToRemove(),t.isPresent!==i&&(i?o.promote():o.relegate()||We.postRender(()=>{const l=o.getStack();(!l||!l.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:t}=this.props.visualElement;t&&(t.root.didUpdate(),Mw.postRender(()=>{!t.currentAnimation&&t.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:s}=this.props,{projection:r}=t;fx=!0,r&&(r.scheduleCheckAfterUnmount(),e&&e.group&&e.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:t}=this.props;t&&t()}render(){return null}}function K_(n){const[t,e]=g_(),s=St.useContext(pw);return it.jsx(vj,{...n,layoutGroup:s,switchLayoutGroup:St.useContext(I_),isPresent:t,safeToRemove:e})}function wj(n,t,e){const s=as(n)?n:Nc(n);return s.start(Hw("",s,t,e)),s.animation}const Sj=(n,t)=>n.depth-t.depth;class Cj{constructor(){this.children=[],this.isDirty=!1}add(t){yw(this.children,t),this.isDirty=!0}remove(t){bw(this.children,t),this.isDirty=!0}forEach(t){this.isDirty&&this.children.sort(Sj),this.isDirty=!1,this.children.forEach(t)}}function Tj(n,t){const e=Ds.now(),s=({timestamp:r})=>{const i=r-e;i>=t&&(Mo(s),n(i-t))};return We.setup(s,!0),()=>Mo(s)}const X_=["TopLeft","TopRight","BottomLeft","BottomRight"],kj=X_.length,DE=n=>typeof n=="string"?parseFloat(n):n,OE=n=>typeof n=="number"||Wt.test(n);function $j(n,t,e,s,r,i){r?(n.opacity=Xe(0,e.opacity??1,Ej(s)),n.opacityExit=Xe(t.opacity??1,0,Ij(s))):i&&(n.opacity=Xe(t.opacity??1,e.opacity??1,s));for(let o=0;o<kj;o++){const l=`border${X_[o]}Radius`;let c=ME(t,l),h=ME(e,l);if(c===void 0&&h===void 0)continue;c||(c=0),h||(h=0),c===0||h===0||OE(c)===OE(h)?(n[l]=Math.max(Xe(DE(c),DE(h),s),0),(ai.test(h)||ai.test(c))&&(n[l]+="%")):n[l]=h}(t.rotate||e.rotate)&&(n.rotate=Xe(t.rotate||0,e.rotate||0,s))}function ME(n,t){return n[t]!==void 0?n[t]:n.borderRadius}const Ej=Y_(0,.5,MA),Ij=Y_(.5,.95,wr);function Y_(n,t,e){return s=>s<n?0:s>t?1:e($h(n,t,s))}function FE(n,t){n.min=t.min,n.max=t.max}function _r(n,t){FE(n.x,t.x),FE(n.y,t.y)}function LE(n,t){n.translate=t.translate,n.scale=t.scale,n.originPoint=t.originPoint,n.origin=t.origin}function PE(n,t,e,s,r){return n-=t,n=Sm(n,1/e,s),r!==void 0&&(n=Sm(n,1/r,s)),n}function Nj(n,t=0,e=1,s=.5,r,i=n,o=n){if(ai.test(t)&&(t=parseFloat(t),t=Xe(o.min,o.max,t/100)-o.min),typeof t!="number")return;let l=Xe(i.min,i.max,s);n===i&&(l-=t),n.min=PE(n.min,t,e,l,r),n.max=PE(n.max,t,e,l,r)}function zE(n,t,[e,s,r],i,o){Nj(n,t[e],t[s],t[r],t.scale,i,o)}const Aj=["x","scaleX","originX"],_j=["y","scaleY","originY"];function BE(n,t,e,s){zE(n.x,t,Aj,e?e.x:void 0,s?s.x:void 0),zE(n.y,t,_j,e?e.y:void 0,s?s.y:void 0)}function VE(n){return n.translate===0&&n.scale===1}function Z_(n){return VE(n.x)&&VE(n.y)}function UE(n,t){return n.min===t.min&&n.max===t.max}function Rj(n,t){return UE(n.x,t.x)&&UE(n.y,t.y)}function jE(n,t){return Math.round(n.min)===Math.round(t.min)&&Math.round(n.max)===Math.round(t.max)}function J_(n,t){return jE(n.x,t.x)&&jE(n.y,t.y)}function GE(n){return xs(n.x)/xs(n.y)}function WE(n,t){return n.translate===t.translate&&n.scale===t.scale&&n.originPoint===t.originPoint}class Dj{constructor(){this.members=[]}add(t){yw(this.members,t),t.scheduleRender()}remove(t){if(bw(this.members,t),t===this.prevLead&&(this.prevLead=void 0),t===this.lead){const e=this.members[this.members.length-1];e&&this.promote(e)}}relegate(t){const e=this.members.findIndex(r=>t===r);if(e===0)return!1;let s;for(let r=e;r>=0;r--){const i=this.members[r];if(i.isPresent!==!1){s=i;break}}return s?(this.promote(s),!0):!1}promote(t,e){const s=this.lead;if(t!==s&&(this.prevLead=s,this.lead=t,t.show(),s)){s.instance&&s.scheduleRender(),t.scheduleRender(),t.resumeFrom=s,e&&(t.resumeFrom.preserveOpacity=!0),s.snapshot&&(t.snapshot=s.snapshot,t.snapshot.latestValues=s.animationValues||s.latestValues),t.root&&t.root.isUpdating&&(t.isLayoutDirty=!0);const{crossfade:r}=t.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(t=>{const{options:e,resumingFrom:s}=t;e.onExitComplete&&e.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(t=>{t.instance&&t.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function Oj(n,t,e){let s="";const r=n.x.translate/t.x,i=n.y.translate/t.y,o=e?.z||0;if((r||i||o)&&(s=`translate3d(${r}px, ${i}px, ${o}px) `),(t.x!==1||t.y!==1)&&(s+=`scale(${1/t.x}, ${1/t.y}) `),e){const{transformPerspective:h,rotate:d,rotateX:p,rotateY:m,skewX:y,skewY:b}=e;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),p&&(s+=`rotateX(${p}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const l=n.x.scale*t.x,c=n.y.scale*t.y;return(l!==1||c!==1)&&(s+=`scale(${l}, ${c})`),s||"none"}const px=["","X","Y","Z"],Mj=1e3;let Fj=0;function mx(n,t,e,s){const{latestValues:r}=t;r[n]&&(e[n]=r[n],t.setStaticValue(n,0),s&&(s[n]=0))}function Q_(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:t}=n.options;if(!t)return;const e=P_(t);if(window.MotionHasOptimisedAnimation(e,"transform")){const{layout:r,layoutId:i}=n.options;window.MotionCancelOptimisedAnimation(e,"transform",We,!(r||i))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&Q_(s)}function tR({attachResizeListener:n,defaultParent:t,measureScroll:e,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(o={},l=t?.()){this.id=Fj++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(zj),this.nodes.forEach(jj),this.nodes.forEach(Gj),this.nodes.forEach(Bj)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=l?l.root||l:this,this.path=l?[...l.path,l]:[],this.parent=l,this.depth=l?l.depth+1:0;for(let c=0;c<this.path.length;c++)this.path[c].shouldResetTransform=!0;this.root===this&&(this.nodes=new Cj)}addEventListener(o,l){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new ww),this.eventHandlers.get(o).add(l)}notifyListeners(o,...l){const c=this.eventHandlers.get(o);c&&c.notify(...l)}hasListeners(o){return this.eventHandlers.has(o)}mount(o){if(this.instance)return;this.isSVG=m_(o)&&!EU(o),this.instance=o;const{layoutId:l,layout:c,visualElement:h}=this.options;if(h&&!h.current&&h.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(c||l)&&(this.isLayoutDirty=!0),n){let d,p=0;const m=()=>this.root.updateBlockedByResize=!1;We.read(()=>{p=window.innerWidth}),n(o,()=>{const y=window.innerWidth;y!==p&&(p=y,this.root.updateBlockedByResize=!0,d&&d(),d=Tj(m,250),lm.hasAnimatedSinceResize&&(lm.hasAnimatedSinceResize=!1,this.nodes.forEach(KE)))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&h&&(l||c)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:p,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||Xj,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),S=!this.targetLayout||!J_(this.targetLayout,y),T=!p&&m;if(this.options.layoutRoot||this.resumeFrom||T||p&&(S||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const k={...Dw(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(k.delay=0,k.type=!1),this.startAnimation(k),this.setAnimationOrigin(d,T)}else p||KE(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),Mo(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Wj),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&Q_(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const p=this.path[d];p.shouldResetTransform=!0,p.updateScroll("snapshot"),p.options.layoutRoot&&p.willUpdate(!1)}const{layoutId:l,layout:c}=this.options;if(l===void 0&&!c)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(HE);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(qE);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(Uj),this.nodes.forEach(Lj),this.nodes.forEach(Pj)):this.nodes.forEach(qE),this.clearAllSnapshots();const l=Ds.now();Yn.delta=Ui(0,1e3/60,l-Yn.timestamp),Yn.timestamp=l,Yn.isProcessing=!0,sx.update.process(Yn),sx.preRender.process(Yn),sx.render.process(Yn),Yn.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Mw.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Vj),this.sharedNodes.forEach(Hj)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,We.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){We.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!xs(this.snapshot.measuredBox.x)&&!xs(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let c=0;c<this.path.length;c++)this.path[c].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=Nn(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:l}=this.options;l&&l.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let l=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(l=!1),l&&this.instance){const c=s(this.instance);this.scroll={animationId:this.root.animationId,phase:o,isRoot:c,offset:e(this.instance),wasRoot:this.scroll?this.scroll.isRoot:c}}}resetTransform(){if(!r)return;const o=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,l=this.projectionDelta&&!Z_(this.projectionDelta),c=this.getTransformTemplate(),h=c?c(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;o&&this.instance&&(l||Ea(this.latestValues)||d)&&(r(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const l=this.measurePageBox();let c=this.removeElementScroll(l);return o&&(c=this.removeTransform(c)),Yj(c),{animationId:this.root.animationId,measuredBox:l,layoutBox:c,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:o}=this.options;if(!o)return Nn();const l=o.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(Zj))){const{scroll:h}=this.root;h&&(bc(l.x,h.offset.x),bc(l.y,h.offset.y))}return l}removeElementScroll(o){const l=Nn();if(_r(l,o),this.scroll?.wasRoot)return l;for(let c=0;c<this.path.length;c++){const h=this.path[c],{scroll:d,options:p}=h;h!==this.root&&d&&p.layoutScroll&&(d.wasRoot&&_r(l,o),bc(l.x,d.offset.x),bc(l.y,d.offset.y))}return l}applyTransform(o,l=!1){const c=Nn();_r(c,o);for(let h=0;h<this.path.length;h++){const d=this.path[h];!l&&d.options.layoutScroll&&d.scroll&&d!==d.root&&xc(c,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),Ea(d.latestValues)&&xc(c,d.latestValues)}return Ea(this.latestValues)&&xc(c,this.latestValues),c}removeTransform(o){const l=Nn();_r(l,o);for(let c=0;c<this.path.length;c++){const h=this.path[c];if(!h.instance||!Ea(h.latestValues))continue;lv(h.latestValues)&&h.updateSnapshot();const d=Nn(),p=h.measurePageBox();_r(d,p),BE(l,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return Ea(this.latestValues)&&BE(l,this.latestValues),l}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==Yn.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const c=!!this.resumingFrom||this!==l;if(!(o||c&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:p}=this.options;if(!this.layout||!(d||p))return;this.resolvedRelativeTargetAt=Yn.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=Nn(),this.targetWithTransforms=Nn()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),ij(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):_r(this.target,this.layout.layoutBox),R_(this.target,this.targetDelta)):_r(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||lv(this.parent.latestValues)||__(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(o,l,c){this.relativeParent=o,this.linkedParentVersion=o.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=Nn(),this.relativeTargetOrigin=Nn(),Cm(this.relativeTargetOrigin,l,c),_r(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const o=this.getLead(),l=!!this.resumingFrom||this!==o;let c=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(c=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(c=!1),this.resolvedRelativeTargetAt===Yn.timestamp&&(c=!1),c)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;_r(this.layoutCorrected,this.layout.layoutBox);const p=this.treeScale.x,m=this.treeScale.y;y4(this.layoutCorrected,this.treeScale,this.path,l),o.layout&&!o.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(o.target=o.layout.layoutBox,o.targetWithTransforms=Nn());const{target:y}=o;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(LE(this.prevProjectionDelta.x,this.projectionDelta.x),LE(this.prevProjectionDelta.y,this.projectionDelta.y)),bh(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==p||this.treeScale.y!==m||!WE(this.projectionDelta.x,this.prevProjectionDelta.x)||!WE(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){if(this.options.visualElement?.scheduleRender(),o){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=vc(),this.projectionDelta=vc(),this.projectionDeltaWithTransform=vc()}setAnimationOrigin(o,l=!1){const c=this.snapshot,h=c?c.latestValues:{},d={...this.latestValues},p=vc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!l;const m=Nn(),y=c?c.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),S=!w||w.members.length<=1,T=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(Kj));this.animationProgress=0;let k;this.mixTargetDelta=$=>{const E=$/1e3;XE(p.x,o.x,E),XE(p.y,o.y,E),this.setTargetDelta(p),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Cm(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),qj(this.relativeTarget,this.relativeTargetOrigin,m,E),k&&Rj(this.relativeTarget,k)&&(this.isProjectionDirty=!1),k||(k=Nn()),_r(k,this.relativeTarget)),x&&(this.animationValues=d,$j(d,h,this.latestValues,E,T,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(Mo(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=We.update(()=>{lm.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Nc(0)),this.currentAnimation=wj(this.motionValue,[0,1e3],{...o,velocity:0,isSync:!0,onUpdate:l=>{this.mixTargetDelta(l),o.onUpdate&&o.onUpdate(l)},onStop:()=>{},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(Mj),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:l,target:c,layout:h,latestValues:d}=o;if(!(!l||!c||!h)){if(this!==o&&this.layout&&h&&eR(this.options.animationType,this.layout.layoutBox,h.layoutBox)){c=this.target||Nn();const p=xs(this.layout.layoutBox.x);c.x.min=o.target.x.min,c.x.max=c.x.min+p;const m=xs(this.layout.layoutBox.y);c.y.min=o.target.y.min,c.y.max=c.y.min+m}_r(l,c),xc(l,d),bh(this.projectionDeltaWithTransform,this.layoutCorrected,l,d)}}registerSharedNode(o,l){this.sharedNodes.has(o)||this.sharedNodes.set(o,new Dj),this.sharedNodes.get(o).add(l);const h=l.options.initialPromotionConfig;l.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(l):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){const{layoutId:o}=this.options;return o?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:o}=this.options;return o?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:l,preserveFollowOpacity:c}={}){const h=this.getStack();h&&h.promote(this,c),o&&(this.projectionDelta=void 0,this.needsReset=!0),l&&this.setOptions({transition:l})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetSkewAndRotation(){const{visualElement:o}=this.options;if(!o)return;let l=!1;const{latestValues:c}=o;if((c.z||c.rotate||c.rotateX||c.rotateY||c.rotateZ||c.skewX||c.skewY)&&(l=!0),!l)return;const h={};c.z&&mx("z",o,h,this.animationValues);for(let d=0;d<px.length;d++)mx(`rotate${px[d]}`,o,h,this.animationValues),mx(`skew${px[d]}`,o,h,this.animationValues);o.render();for(const d in h)o.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);o.scheduleRender()}applyProjectionStyles(o,l){if(!this.instance||this.isSVG)return;if(!this.isVisible){o.visibility="hidden";return}const c=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,o.visibility="",o.opacity="",o.pointerEvents=am(l?.pointerEvents)||"",o.transform=c?c(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(o.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,o.pointerEvents=am(l?.pointerEvents)||""),this.hasProjected&&!Ea(this.latestValues)&&(o.transform=c?c({},""):"none",this.hasProjected=!1);return}o.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let p=Oj(this.projectionDeltaWithTransform,this.treeScale,d);c&&(p=c(d,p)),o.transform=p;const{x:m,y}=this.projectionDelta;o.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?o.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:o.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in av){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:S}=av[b],T=p==="none"?d[b]:x(d[b],h);if(w){const k=w.length;for(let $=0;$<k;$++)o[w[$]]=T}else S?this.options.visualElement.renderState.vars[b]=T:o[b]=T}this.options.layoutId&&(o.pointerEvents=h===this?am(l?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>o.currentAnimation?.stop()),this.root.nodes.forEach(HE),this.root.sharedNodes.clear()}}}function Lj(n){n.updateLayout()}function Pj(n){const t=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&t&&n.hasListeners("didUpdate")){const{layoutBox:e,measuredBox:s}=n.layout,{animationType:r}=n.options,i=t.source!==n.layout.source;r==="size"?pr(d=>{const p=i?t.measuredBox[d]:t.layoutBox[d],m=xs(p);p.min=e[d].min,p.max=p.min+m}):eR(r,t.layoutBox,e)&&pr(d=>{const p=i?t.measuredBox[d]:t.layoutBox[d],m=xs(e[d]);p.max=p.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const o=vc();bh(o,e,t.layoutBox);const l=vc();i?bh(l,n.applyTransform(s,!0),t.measuredBox):bh(l,e,t.layoutBox);const c=!Z_(o);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:p,layout:m}=d;if(p&&m){const y=Nn();Cm(y,t.layoutBox,p.layoutBox);const b=Nn();Cm(b,e,m.layoutBox),J_(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:e,snapshot:t,delta:l,layoutDelta:o,hasLayoutChanged:c,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:e}=n.options;e&&e()}n.options.transition=void 0}function zj(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Bj(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Vj(n){n.clearSnapshot()}function HE(n){n.clearMeasurements()}function qE(n){n.isLayoutDirty=!1}function Uj(n){const{visualElement:t}=n.options;t&&t.getProps().onBeforeLayoutMeasure&&t.notify("BeforeLayoutMeasure"),n.resetTransform()}function KE(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function jj(n){n.resolveTargetDelta()}function Gj(n){n.calcProjection()}function Wj(n){n.resetSkewAndRotation()}function Hj(n){n.removeLeadSnapshot()}function XE(n,t,e){n.translate=Xe(t.translate,0,e),n.scale=Xe(t.scale,1,e),n.origin=t.origin,n.originPoint=t.originPoint}function YE(n,t,e,s){n.min=Xe(t.min,e.min,s),n.max=Xe(t.max,e.max,s)}function qj(n,t,e,s){YE(n.x,t.x,e.x,s),YE(n.y,t.y,e.y,s)}function Kj(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const Xj={duration:.45,ease:[.4,0,.1,1]},ZE=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),JE=ZE("applewebkit/")&&!ZE("chrome/")?Math.round:wr;function QE(n){n.min=JE(n.min),n.max=JE(n.max)}function Yj(n){QE(n.x),QE(n.y)}function eR(n,t,e){return n==="position"||n==="preserve-aspect"&&!rj(GE(t),GE(e),.2)}function Zj(n){return n!==n.root&&n.scroll?.wasRoot}const Jj=tR({attachResizeListener:(n,t)=>Ah(n,"resize",t),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),gx={current:void 0},nR=tR({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!gx.current){const n=new Jj({});n.mount(window),n.setOptions({layoutScroll:!0}),gx.current=n}return gx.current},resetTransform:(n,t)=>{n.style.transform=t!==void 0?t:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),Qj={pan:{Feature:xj},drag:{Feature:bj,ProjectionNode:nR,MeasureLayout:K_}};function tI(n,t,e){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",e==="Start");const r="onHover"+e,i=s[r];i&&We.postRender(()=>i(t,Qh(t)))}class tG extends jo{mount(){const{current:t}=this.node;t&&(this.unmount=SU(t,(e,s)=>(tI(this.node,s,"Start"),r=>tI(this.node,r,"End"))))}unmount(){}}class eG extends jo{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch{t=!0}!t||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Yh(Ah(this.node.current,"focus",()=>this.onFocus()),Ah(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function eI(n,t,e){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",e==="Start");const r="onTap"+(e==="End"?"":e),i=s[r];i&&We.postRender(()=>i(t,Qh(t)))}class nG extends jo{mount(){const{current:t}=this.node;t&&(this.unmount=$U(t,(e,s)=>(eI(this.node,s,"Start"),(r,{success:i})=>eI(this.node,r,i?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const mv=new WeakMap,yx=new WeakMap,sG=n=>{const t=mv.get(n.target);t&&t(n)},rG=n=>{n.forEach(sG)};function iG({root:n,...t}){const e=n||document;yx.has(e)||yx.set(e,{});const s=yx.get(e),r=JSON.stringify(t);return s[r]||(s[r]=new IntersectionObserver(rG,{root:n,...t})),s[r]}function oG(n,t,e){const s=iG(t);return mv.set(n,e),s.observe(n),()=>{mv.delete(n),s.unobserve(n)}}const aG={some:0,all:1};class lG extends jo{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:e,margin:s,amount:r="some",once:i}=t,o={root:e?e.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:aG[r]},l=c=>{const{isIntersecting:h}=c;if(this.isInView===h||(this.isInView=h,i&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:p}=this.node.getProps(),m=h?d:p;m&&m(c)};return oG(this.node.current,o,l)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:t,prevProps:e}=this.node;["amount","margin","root"].some(cG(t,e))&&this.startObserver()}unmount(){}}function cG({viewport:n={}},{viewport:t={}}={}){return e=>n[e]!==t[e]}const uG={inView:{Feature:lG},tap:{Feature:nG},focus:{Feature:eG},hover:{Feature:tG}},hG={layout:{ProjectionNode:nR,MeasureLayout:K_}},dG={...J4,...uG,...Qj,...hG},wa=p4(dG,E4);const fG=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),pG=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,e,s)=>s?s.toUpperCase():e.toLowerCase()),nI=n=>{const t=pG(n);return t.charAt(0).toUpperCase()+t.slice(1)},sR=(...n)=>n.filter((t,e,s)=>!!t&&t.trim()!==""&&s.indexOf(t)===e).join(" ").trim(),mG=n=>{for(const t in n)if(t.startsWith("aria-")||t==="role"||t==="title")return!0};var gG={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const yG=St.forwardRef(({color:n="currentColor",size:t=24,strokeWidth:e=2,absoluteStrokeWidth:s,className:r="",children:i,iconNode:o,...l},c)=>St.createElement("svg",{ref:c,...gG,width:t,height:t,stroke:n,strokeWidth:s?Number(e)*24/Number(t):e,className:sR("lucide",r),...!i&&!mG(l)&&{"aria-hidden":"true"},...l},[...o.map(([h,d])=>St.createElement(h,d)),...Array.isArray(i)?i:[i]]));const us=(n,t)=>{const e=St.forwardRef(({className:s,...r},i)=>St.createElement(yG,{ref:i,iconNode:t,className:sR(`lucide-${fG(nI(n))}`,`lucide-${n}`,s),...r}));return e.displayName=nI(n),e};const bG=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],xG=us("activity",bG);const vG=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],wG=us("circle-check",vG);const SG=[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]],CG=us("copy",SG);const TG=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],kG=us("cpu",TG);const $G=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],sI=us("history",$G);const EG=[["path",{d:"M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",key:"zw3jo"}],["path",{d:"M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",key:"1wduqc"}],["path",{d:"M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",key:"kqbvx6"}]],IG=us("layers",EG);const NG=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],rI=us("lock",NG);const AG=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],_G=us("log-out",AG);const RG=[["path",{d:"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",key:"1a8usu"}],["path",{d:"m15 5 4 4",key:"1mk7zo"}]],DG=us("pencil",RG);const OG=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],MG=us("search",OG);const FG=[["circle",{cx:"18",cy:"5",r:"3",key:"gq8acd"}],["circle",{cx:"6",cy:"12",r:"3",key:"w7nqdw"}],["circle",{cx:"18",cy:"19",r:"3",key:"1xt0gg"}],["line",{x1:"8.59",x2:"15.42",y1:"13.51",y2:"17.49",key:"47mynk"}],["line",{x1:"15.41",x2:"8.59",y1:"6.51",y2:"10.49",key:"1n3mei"}]],LG=us("share-2",FG);const PG=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],iI=us("trending-down",PG);const zG=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],oI=us("trending-up",zG);const BG=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],VG=us("triangle-alert",BG);const UG=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],jG=us("trophy",UG);const GG=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],aI=us("zap",GG);function ag(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e}function WG(n,t,e,s){function r(i){return i instanceof e?i:new e(function(o){o(i)})}return new(e||(e=Promise))(function(i,o){function l(d){try{h(s.next(d))}catch(p){o(p)}}function c(d){try{h(s.throw(d))}catch(p){o(p)}}function h(d){d.done?i(d.value):r(d.value).then(l,c)}h((s=s.apply(n,t||[])).next())})}const HG=n=>n?(...t)=>n(...t):(...t)=>fetch(...t);class qw extends Error{constructor(t,e="FunctionsError",s){super(t),this.name=e,this.context=s}}class qG extends qw{constructor(t){super("Failed to send a request to the Edge Function","FunctionsFetchError",t)}}class lI extends qw{constructor(t){super("Relay Error invoking the Edge Function","FunctionsRelayError",t)}}class cI extends qw{constructor(t){super("Edge Function returned a non-2xx status code","FunctionsHttpError",t)}}var gv;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(gv||(gv={}));class KG{constructor(t,{headers:e={},customFetch:s,region:r=gv.Any}={}){this.url=t,this.headers=e,this.region=r,this.fetch=HG(s)}setAuth(t){this.headers.Authorization=`Bearer ${t}`}invoke(t){return WG(this,arguments,void 0,function*(e,s={}){var r;let i,o;try{const{headers:l,method:c,body:h,signal:d,timeout:p}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${e}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(l&&!Object.prototype.hasOwnProperty.call(l,"Content-Type")||!l)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;p&&(o=new AbortController,i=setTimeout(()=>o.abort(),p),d?(w=o.signal,d.addEventListener("abort",()=>o.abort())):w=o.signal);const S=yield this.fetch(b.toString(),{method:c||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),l),body:x,signal:w}).catch(E=>{throw new qG(E)}),T=S.headers.get("x-relay-error");if(T&&T==="true")throw new lI(S);if(!S.ok)throw new cI(S);let k=((r=S.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),$;return k==="application/json"?$=yield S.json():k==="application/octet-stream"||k==="application/pdf"?$=yield S.blob():k==="text/event-stream"?$=S:k==="multipart/form-data"?$=yield S.formData():$=yield S.text(),{data:$,error:null,response:S}}catch(l){return{data:null,error:l,response:l instanceof cI||l instanceof lI?l.context:void 0}}finally{i&&clearTimeout(i)}})}}var XG=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},YG=class{constructor(n){var t,e;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(t=n.shouldThrowOnError)!==null&&t!==void 0?t:!1,this.signal=n.signal,this.isMaybeSingle=(e=n.isMaybeSingle)!==null&&e!==void 0?e:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,t){return this.headers=new Headers(this.headers),this.headers.set(n,t),this}then(n,t){var e=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let r=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async i=>{let o=null,l=null,c=null,h=i.status,d=i.statusText;if(i.ok){var p,m;if(e.method!=="HEAD"){var y;const S=await i.text();S===""||(e.headers.get("Accept")==="text/csv"||e.headers.get("Accept")&&(!((y=e.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?l=S:l=JSON.parse(S))}const x=(p=e.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),w=(m=i.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(c=parseInt(w[1])),e.isMaybeSingle&&e.method==="GET"&&Array.isArray(l)&&(l.length>1?(o={code:"PGRST116",details:`Results contain ${l.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},l=null,c=null,h=406,d="Not Acceptable"):l.length===1?l=l[0]:l=null)}else{var b;const x=await i.text();try{o=JSON.parse(x),Array.isArray(o)&&i.status===404&&(l=[],o=null,h=200,d="OK")}catch{i.status===404&&x===""?(h=204,d="No Content"):o={message:x}}if(o&&e.isMaybeSingle&&(!(o==null||(b=o.details)===null||b===void 0)&&b.includes("0 rows"))&&(o=null,h=200,d="OK"),o&&e.shouldThrowOnError)throw new XG(o)}return{error:o,data:l,count:c,status:h,statusText:d}});return this.shouldThrowOnError||(r=r.catch(i=>{var o;let l="";const c=i?.cause;if(c){var h,d,p,m;const b=(h=c?.message)!==null&&h!==void 0?h:"",x=(d=c?.code)!==null&&d!==void 0?d:"";l=`${(p=i?.name)!==null&&p!==void 0?p:"FetchError"}: ${i?.message}`,l+=`

Caused by: ${(m=c?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(l+=` (${x})`),c?.stack&&(l+=`
${c.stack}`)}else{var y;l=(y=i?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(o=i?.name)!==null&&o!==void 0?o:"FetchError"}: ${i?.message}`,details:l,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(n,t)}returns(){return this}overrideTypes(){return this}},ZG=class extends YG{select(n){let t=!1;const e=(n??"*").split("").map(s=>/\s/.test(s)&&!t?"":(s==='"'&&(t=!t),s)).join("");return this.url.searchParams.set("select",e),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:t=!0,nullsFirst:e,foreignTable:s,referencedTable:r=s}={}){const i=r?`${r}.order`:"order",o=this.url.searchParams.get(i);return this.url.searchParams.set(i,`${o?`${o},`:""}${n}.${t?"asc":"desc"}${e===void 0?"":e?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:t,referencedTable:e=t}={}){const s=typeof e>"u"?"limit":`${e}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,t,{foreignTable:e,referencedTable:s=e}={}){const r=typeof s>"u"?"offset":`${s}.offset`,i=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(r,`${n}`),this.url.searchParams.set(i,`${t-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:t=!1,settings:e=!1,buffers:s=!1,wal:r=!1,format:i="text"}={}){var o;const l=[n?"analyze":null,t?"verbose":null,e?"settings":null,s?"buffers":null,r?"wal":null].filter(Boolean).join("|"),c=(o=this.headers.get("Accept"))!==null&&o!==void 0?o:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${i}; for="${c}"; options=${l};`),i==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const uI=new RegExp("[,()]");var uc=class extends ZG{eq(n,t){return this.url.searchParams.append(n,`eq.${t}`),this}neq(n,t){return this.url.searchParams.append(n,`neq.${t}`),this}gt(n,t){return this.url.searchParams.append(n,`gt.${t}`),this}gte(n,t){return this.url.searchParams.append(n,`gte.${t}`),this}lt(n,t){return this.url.searchParams.append(n,`lt.${t}`),this}lte(n,t){return this.url.searchParams.append(n,`lte.${t}`),this}like(n,t){return this.url.searchParams.append(n,`like.${t}`),this}likeAllOf(n,t){return this.url.searchParams.append(n,`like(all).{${t.join(",")}}`),this}likeAnyOf(n,t){return this.url.searchParams.append(n,`like(any).{${t.join(",")}}`),this}ilike(n,t){return this.url.searchParams.append(n,`ilike.${t}`),this}ilikeAllOf(n,t){return this.url.searchParams.append(n,`ilike(all).{${t.join(",")}}`),this}ilikeAnyOf(n,t){return this.url.searchParams.append(n,`ilike(any).{${t.join(",")}}`),this}regexMatch(n,t){return this.url.searchParams.append(n,`match.${t}`),this}regexIMatch(n,t){return this.url.searchParams.append(n,`imatch.${t}`),this}is(n,t){return this.url.searchParams.append(n,`is.${t}`),this}isDistinct(n,t){return this.url.searchParams.append(n,`isdistinct.${t}`),this}in(n,t){const e=Array.from(new Set(t)).map(s=>typeof s=="string"&&uI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${e})`),this}notIn(n,t){const e=Array.from(new Set(t)).map(s=>typeof s=="string"&&uI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${e})`),this}contains(n,t){return typeof t=="string"?this.url.searchParams.append(n,`cs.${t}`):Array.isArray(t)?this.url.searchParams.append(n,`cs.{${t.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(t)}`),this}containedBy(n,t){return typeof t=="string"?this.url.searchParams.append(n,`cd.${t}`):Array.isArray(t)?this.url.searchParams.append(n,`cd.{${t.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(t)}`),this}rangeGt(n,t){return this.url.searchParams.append(n,`sr.${t}`),this}rangeGte(n,t){return this.url.searchParams.append(n,`nxl.${t}`),this}rangeLt(n,t){return this.url.searchParams.append(n,`sl.${t}`),this}rangeLte(n,t){return this.url.searchParams.append(n,`nxr.${t}`),this}rangeAdjacent(n,t){return this.url.searchParams.append(n,`adj.${t}`),this}overlaps(n,t){return typeof t=="string"?this.url.searchParams.append(n,`ov.${t}`):this.url.searchParams.append(n,`ov.{${t.join(",")}}`),this}textSearch(n,t,{config:e,type:s}={}){let r="";s==="plain"?r="pl":s==="phrase"?r="ph":s==="websearch"&&(r="w");const i=e===void 0?"":`(${e})`;return this.url.searchParams.append(n,`${r}fts${i}.${t}`),this}match(n){return Object.entries(n).forEach(([t,e])=>{this.url.searchParams.append(t,`eq.${e}`)}),this}not(n,t,e){return this.url.searchParams.append(n,`not.${t}.${e}`),this}or(n,{foreignTable:t,referencedTable:e=t}={}){const s=e?`${e}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,t,e){return this.url.searchParams.append(n,`${t}.${e}`),this}},JG=class{constructor(n,{headers:t={},schema:e,fetch:s}){this.url=n,this.headers=new Headers(t),this.schema=e,this.fetch=s}select(n,t){const{head:e=!1,count:s}=t??{},r=e?"HEAD":"GET";let i=!1;const o=(n??"*").split("").map(l=>/\s/.test(l)&&!i?"":(l==='"'&&(i=!i),l)).join("");return this.url.searchParams.set("select",o),s&&this.headers.append("Prefer",`count=${s}`),new uc({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:t,defaultToNull:e=!0}={}){var s;const r="POST";if(t&&this.headers.append("Prefer",`count=${t}`),e||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const i=n.reduce((o,l)=>o.concat(Object.keys(l)),[]);if(i.length>0){const o=[...new Set(i)].map(l=>`"${l}"`);this.url.searchParams.set("columns",o.join(","))}}return new uc({method:r,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:t,ignoreDuplicates:e=!1,count:s,defaultToNull:r=!0}={}){var i;const o="POST";if(this.headers.append("Prefer",`resolution=${e?"ignore":"merge"}-duplicates`),t!==void 0&&this.url.searchParams.set("on_conflict",t),s&&this.headers.append("Prefer",`count=${s}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const l=n.reduce((c,h)=>c.concat(Object.keys(h)),[]);if(l.length>0){const c=[...new Set(l)].map(h=>`"${h}"`);this.url.searchParams.set("columns",c.join(","))}}return new uc({method:o,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}update(n,{count:t}={}){var e;const s="PATCH";return t&&this.headers.append("Prefer",`count=${t}`),new uc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}delete({count:n}={}){var t;const e="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new uc({method:e,url:this.url,headers:this.headers,schema:this.schema,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}},QG=class rR{constructor(t,{headers:e={},schema:s,fetch:r}={}){this.url=t,this.headers=new Headers(e),this.schemaName=s,this.fetch=r}from(t){if(!t||typeof t!="string"||t.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new JG(new URL(`${this.url}/${t}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(t){return new rR(this.url,{headers:this.headers,schema:t,fetch:this.fetch})}rpc(t,e={},{head:s=!1,get:r=!1,count:i}={}){var o;let l;const c=new URL(`${this.url}/rpc/${t}`);let h;s||r?(l=s?"HEAD":"GET",Object.entries(e).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{c.searchParams.append(p,m)})):(l="POST",h=e);const d=new Headers(this.headers);return i&&d.set("Prefer",`count=${i}`),new uc({method:l,url:c,headers:d,schema:this.schemaName,body:h,fetch:(o=this.fetch)!==null&&o!==void 0?o:fetch})}};class tW{constructor(){}static detectEnvironment(){var t;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((t=navigator.userAgent)===null||t===void 0)&&t.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const e=process.versions;if(e&&e.node){const s=e.node,r=parseInt(s.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const t=this.detectEnvironment();if(t.constructor)return t.constructor;let e=t.error||"WebSocket not supported in this environment.";throw t.workaround&&(e+=`

Suggested solution: ${t.workaround}`),new Error(e)}static createWebSocket(t,e){const s=this.getWebSocketConstructor();return new s(t,e)}static isWebSocketSupported(){try{const t=this.detectEnvironment();return t.type==="native"||t.type==="ws"}catch{return!1}}}const eW="2.89.0",nW=`realtime-js/${eW}`,iR="1.0.0",sW="2.0.0",hI=iR,yv=1e4,rW=1e3,iW=100;var ko;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(ko||(ko={}));var In;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(In||(In={}));var Lr;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(Lr||(Lr={}));var bv;(function(n){n.websocket="websocket"})(bv||(bv={}));var Aa;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(Aa||(Aa={}));class oW{constructor(t){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=t??[]}encode(t,e){if(t.event===this.BROADCAST_EVENT&&!(t.payload instanceof ArrayBuffer)&&typeof t.payload.event=="string")return e(this._binaryEncodeUserBroadcastPush(t));let s=[t.join_ref,t.ref,t.topic,t.event,t.payload];return e(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(t){var e;return this._isArrayBuffer((e=t.payload)===null||e===void 0?void 0:e.payload)?this._encodeBinaryUserBroadcastPush(t):this._encodeJsonUserBroadcastPush(t)}_encodeBinaryUserBroadcastPush(t){var e,s;const r=(s=(e=t.payload)===null||e===void 0?void 0:e.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(t,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(t){var e,s;const r=(s=(e=t.payload)===null||e===void 0?void 0:e.payload)!==null&&s!==void 0?s:{},o=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(t,this.JSON_ENCODING,o)}_encodeUserBroadcastPush(t,e,s){var r,i;const o=t.topic,l=(r=t.ref)!==null&&r!==void 0?r:"",c=(i=t.join_ref)!==null&&i!==void 0?i:"",h=t.payload.event,d=this.allowedMetadataKeys?this._pick(t.payload,this.allowedMetadataKeys):{},p=Object.keys(d).length===0?"":JSON.stringify(d);if(c.length>255)throw new Error(`joinRef length ${c.length} exceeds maximum of 255`);if(l.length>255)throw new Error(`ref length ${l.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`topic length ${o.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+c.length+l.length+o.length+h.length+p.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,c.length),b.setUint8(x++,l.length),b.setUint8(x++,o.length),b.setUint8(x++,h.length),b.setUint8(x++,p.length),b.setUint8(x++,e),Array.from(c,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(l,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(o,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(h,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(p,S=>b.setUint8(x++,S.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(t,e){if(this._isArrayBuffer(t)){let s=this._binaryDecode(t);return e(s)}if(typeof t=="string"){const s=JSON.parse(t),[r,i,o,l,c]=s;return e({join_ref:r,ref:i,topic:o,event:l,payload:c})}return e({})}_binaryDecode(t){const e=new DataView(t),s=e.getUint8(0),r=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(t,e,r)}_decodeUserBroadcast(t,e,s){const r=e.getUint8(1),i=e.getUint8(2),o=e.getUint8(3),l=e.getUint8(4);let c=this.HEADER_LENGTH+4;const h=s.decode(t.slice(c,c+r));c=c+r;const d=s.decode(t.slice(c,c+i));c=c+i;const p=s.decode(t.slice(c,c+o));c=c+o;const m=t.slice(c,t.byteLength),y=l===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return o>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(t){var e;return t instanceof ArrayBuffer||((e=t?.constructor)===null||e===void 0?void 0:e.name)==="ArrayBuffer"}_pick(t,e){return!t||typeof t!="object"?{}:Object.fromEntries(Object.entries(t).filter(([s])=>e.includes(s)))}}class oR{constructor(t,e){this.callback=t,this.timerCalc=e,this.timer=void 0,this.tries=0,this.callback=t,this.timerCalc=e}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Pe;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Pe||(Pe={}));const dI=(n,t,e={})=>{var s;const r=(s=e.skipTypes)!==null&&s!==void 0?s:[];return t?Object.keys(t).reduce((i,o)=>(i[o]=aW(o,n,t,r),i),{}):{}},aW=(n,t,e,s)=>{const r=t.find(l=>l.name===n),i=r?.type,o=e[n];return i&&!s.includes(i)?aR(i,o):xv(o)},aR=(n,t)=>{if(n.charAt(0)==="_"){const e=n.slice(1,n.length);return hW(t,e)}switch(n){case Pe.bool:return lW(t);case Pe.float4:case Pe.float8:case Pe.int2:case Pe.int4:case Pe.int8:case Pe.numeric:case Pe.oid:return cW(t);case Pe.json:case Pe.jsonb:return uW(t);case Pe.timestamp:return dW(t);case Pe.abstime:case Pe.date:case Pe.daterange:case Pe.int4range:case Pe.int8range:case Pe.money:case Pe.reltime:case Pe.text:case Pe.time:case Pe.timestamptz:case Pe.timetz:case Pe.tsrange:case Pe.tstzrange:return xv(t);default:return xv(t)}},xv=n=>n,lW=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},cW=n=>{if(typeof n=="string"){const t=parseFloat(n);if(!Number.isNaN(t))return t}return n},uW=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},hW=(n,t)=>{if(typeof n!="string")return n;const e=n.length-1,s=n[e];if(n[0]==="{"&&s==="}"){let i;const o=n.slice(1,e);try{i=JSON.parse("["+o+"]")}catch{i=o?o.split(","):[]}return i.map(l=>aR(t,l))}return n},dW=n=>typeof n=="string"?n.replace(" ","T"):n,lR=n=>{const t=new URL(n);return t.protocol=t.protocol.replace(/^ws/i,"http"),t.pathname=t.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),t.pathname===""||t.pathname==="/"?t.pathname="/api/broadcast":t.pathname=t.pathname+"/api/broadcast",t.href};class bx{constructor(t,e,s={},r=yv){this.channel=t,this.event=e,this.payload=s,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(t){this.timeout=t,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(t){this.payload=Object.assign(Object.assign({},this.payload),t)}receive(t,e){var s;return this._hasReceived(t)&&e((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:t,callback:e}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const t=e=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=e,this._matchReceive(e)};this.channel._on(this.refEvent,{},t),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(t,e){this.refEvent&&this.channel._trigger(this.refEvent,{status:t,response:e})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:t,response:e}){this.recHooks.filter(s=>s.status===t).forEach(s=>s.callback(e))}_hasReceived(t){return this.receivedResp&&this.receivedResp.status===t}}var fI;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(fI||(fI={}));class xh{constructor(t,e){this.channel=t,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=e?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},r=>{const{onJoin:i,onLeave:o,onSync:l}=this.caller;this.joinRef=this.channel._joinRef(),this.state=xh.syncState(this.state,r,i,o),this.pendingDiffs.forEach(c=>{this.state=xh.syncDiff(this.state,c,i,o)}),this.pendingDiffs=[],l()}),this.channel._on(s.diff,{},r=>{const{onJoin:i,onLeave:o,onSync:l}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=xh.syncDiff(this.state,r,i,o),l())}),this.onJoin((r,i,o)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:i,newPresences:o})}),this.onLeave((r,i,o)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:i,leftPresences:o})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(t,e,s,r){const i=this.cloneDeep(t),o=this.transformState(e),l={},c={};return this.map(i,(h,d)=>{o[h]||(c[h]=d)}),this.map(o,(h,d)=>{const p=i[h];if(p){const m=d.map(w=>w.presence_ref),y=p.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=p.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(l[h]=b),x.length>0&&(c[h]=x)}else l[h]=d}),this.syncDiff(i,{joins:l,leaves:c},s,r)}static syncDiff(t,e,s,r){const{joins:i,leaves:o}={joins:this.transformState(e.joins),leaves:this.transformState(e.leaves)};return s||(s=()=>{}),r||(r=()=>{}),this.map(i,(l,c)=>{var h;const d=(h=t[l])!==null&&h!==void 0?h:[];if(t[l]=this.cloneDeep(c),d.length>0){const p=t[l].map(y=>y.presence_ref),m=d.filter(y=>p.indexOf(y.presence_ref)<0);t[l].unshift(...m)}s(l,d,c)}),this.map(o,(l,c)=>{let h=t[l];if(!h)return;const d=c.map(p=>p.presence_ref);h=h.filter(p=>d.indexOf(p.presence_ref)<0),t[l]=h,r(l,h,c),h.length===0&&delete t[l]}),t}static map(t,e){return Object.getOwnPropertyNames(t).map(s=>e(s,t[s]))}static transformState(t){return t=this.cloneDeep(t),Object.getOwnPropertyNames(t).reduce((e,s)=>{const r=t[s];return"metas"in r?e[s]=r.metas.map(i=>(i.presence_ref=i.phx_ref,delete i.phx_ref,delete i.phx_ref_prev,i)):e[s]=r,e},{})}static cloneDeep(t){return JSON.parse(JSON.stringify(t))}onJoin(t){this.caller.onJoin=t}onLeave(t){this.caller.onLeave=t}onSync(t){this.caller.onSync=t}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var pI;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(pI||(pI={}));var vh;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(vh||(vh={}));var Pi;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(Pi||(Pi={}));class wc{constructor(t,e={config:{}},s){var r,i;if(this.topic=t,this.params=e,this.socket=s,this.bindings={},this.state=In.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=t.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},e.config),this.timeout=this.socket.timeout,this.joinPush=new bx(this,Lr.join,this.params,this.timeout),this.rejoinTimer=new oR(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=In.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=In.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=In.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=In.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=In.errored,this.rejoinTimer.scheduleTimeout())}),this._on(Lr.reply,{},(o,l)=>{this._trigger(this._replyEventName(l),o)}),this.presence=new xh(this),this.broadcastEndpointURL=lR(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((i=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||i===void 0)&&i.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(t,e=this.timeout){var s,r,i;if(this.socket.isConnected()||this.socket.connect(),this.state==In.closed){const{config:{broadcast:o,presence:l,private:c}}=this.params,h=(r=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&r!==void 0?r:[],d=!!this.bindings[vh.PRESENCE]&&this.bindings[vh.PRESENCE].length>0||((i=this.params.config.presence)===null||i===void 0?void 0:i.enabled)===!0,p={},m={broadcast:o,presence:Object.assign(Object.assign({},l),{enabled:d}),postgres_changes:h,private:c};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(y=>t?.(Pi.CHANNEL_ERROR,y)),this._onClose(()=>t?.(Pi.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(e),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){t?.(Pi.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,S=[];for(let T=0;T<w;T++){const k=x[T],{filter:{event:$,schema:E,table:N,filter:_}}=k,R=y&&y[T];if(R&&R.event===$&&wc.isFilterValueEqual(R.schema,E)&&wc.isFilterValueEqual(R.table,N)&&wc.isFilterValueEqual(R.filter,_))S.push(Object.assign(Object.assign({},k),{id:R.id}));else{this.unsubscribe(),this.state=In.errored,t?.(Pi.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=S,t&&t(Pi.SUBSCRIBED);return}}).receive("error",y=>{this.state=In.errored,t?.(Pi.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{t?.(Pi.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(t,e={}){return await this.send({type:"presence",event:"track",payload:t},e.timeout||this.timeout)}async untrack(t={}){return await this.send({type:"presence",event:"untrack"},t)}on(t,e,s){return this.state===In.joined&&t===vh.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(t,e,s)}async httpSend(t,e,s={}){var r;if(e==null)return Promise.reject("Payload is required for httpSend()");const i={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(i.Authorization=`Bearer ${this.socket.accessTokenValue}`);const o={method:"POST",headers:i,body:JSON.stringify({messages:[{topic:this.subTopic,event:t,payload:e,private:this.private}]})},l=await this._fetchWithTimeout(this.broadcastEndpointURL,o,(r=s.timeout)!==null&&r!==void 0?r:this.timeout);if(l.status===202)return{success:!0};let c=l.statusText;try{const h=await l.json();c=h.error||h.message||c}catch{}return Promise.reject(new Error(c))}async send(t,e={}){var s,r;if(!this._canPush()&&t.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:i,payload:o}=t,l={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(l.Authorization=`Bearer ${this.socket.accessTokenValue}`);const c={method:"POST",headers:l,body:JSON.stringify({messages:[{topic:this.subTopic,event:i,payload:o,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,c,(s=e.timeout)!==null&&s!==void 0?s:this.timeout);return await((r=h.body)===null||r===void 0?void 0:r.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(i=>{var o,l,c;const h=this._push(t.type,t,e.timeout||this.timeout);t.type==="broadcast"&&!(!((c=(l=(o=this.params)===null||o===void 0?void 0:o.config)===null||l===void 0?void 0:l.broadcast)===null||c===void 0)&&c.ack)&&i("ok"),h.receive("ok",()=>i("ok")),h.receive("error",()=>i("error")),h.receive("timeout",()=>i("timed out"))})}updateJoinPayload(t){this.joinPush.updatePayload(t)}unsubscribe(t=this.timeout){this.state=In.leaving;const e=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(Lr.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(r=>{s=new bx(this,Lr.leave,{},t),s.receive("ok",()=>{e(),r("ok")}).receive("timeout",()=>{e(),r("timed out")}).receive("error",()=>{r("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(t=>t.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=In.closed,this.bindings={}}async _fetchWithTimeout(t,e,s){const r=new AbortController,i=setTimeout(()=>r.abort(),s),o=await this.socket.fetch(t,Object.assign(Object.assign({},e),{signal:r.signal}));return clearTimeout(i),o}_push(t,e,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new bx(this,t,e,s);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(t){if(t.startTimeout(),this.pushBuffer.push(t),this.pushBuffer.length>iW){const e=this.pushBuffer.shift();e&&(e.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${e.event}`,e.payload))}}_onMessage(t,e,s){return e}_isMember(t){return this.topic===t}_joinRef(){return this.joinPush.ref}_trigger(t,e,s){var r,i;const o=t.toLocaleLowerCase(),{close:l,error:c,leave:h,join:d}=Lr;if(s&&[l,c,h,d].indexOf(o)>=0&&s!==this._joinRef())return;let m=this._onMessage(o,e,s);if(e&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===o}).map(y=>y.callback(m,s)):(i=this.bindings[o])===null||i===void 0||i.filter(y=>{var b,x,w,S,T,k;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in y){const $=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return $&&((x=e.ids)===null||x===void 0?void 0:x.includes($))&&(E==="*"||E?.toLocaleLowerCase()===((w=e.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const $=(T=(S=y?.filter)===null||S===void 0?void 0:S.event)===null||T===void 0?void 0:T.toLocaleLowerCase();return $==="*"||$===((k=e?.event)===null||k===void 0?void 0:k.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===o}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:S,type:T,errors:k}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:S,eventType:T,new:{},old:{},errors:k}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===In.closed}_isJoined(){return this.state===In.joined}_isJoining(){return this.state===In.joining}_isLeaving(){return this.state===In.leaving}_replyEventName(t){return`chan_reply_${t}`}_on(t,e,s){const r=t.toLocaleLowerCase(),i={type:r,filter:e,callback:s};return this.bindings[r]?this.bindings[r].push(i):this.bindings[r]=[i],this}_off(t,e){const s=t.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(r=>{var i;return!(((i=r.type)===null||i===void 0?void 0:i.toLocaleLowerCase())===s&&wc.isEqual(r.filter,e))})),this}static isEqual(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const s in t)if(t[s]!==e[s])return!1;return!0}static isFilterValueEqual(t,e){return(t??void 0)===(e??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(t){this._on(Lr.close,{},t)}_onError(t){this._on(Lr.error,{},e=>t(e))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(t=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=In.joining,this.joinPush.resend(t))}_getPayloadRecords(t){const e={new:{},old:{}};return(t.type==="INSERT"||t.type==="UPDATE")&&(e.new=dI(t.columns,t.record)),(t.type==="UPDATE"||t.type==="DELETE")&&(e.old=dI(t.columns,t.old_record)),e}}const xx=()=>{},Up={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},fW=[1e3,2e3,5e3,1e4],pW=1e4,mW=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class gW{constructor(t,e){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=yv,this.transport=null,this.heartbeatIntervalMs=Up.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=xx,this.ref=0,this.reconnectTimer=null,this.vsn=hI,this.logger=xx,this.conn=null,this.sendBuffer=[],this.serializer=new oW,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...i)=>r(...i):(...i)=>fetch(...i),!(!((s=e?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=e.params.apikey,this.endPoint=`${t}/${bv.websocket}`,this.httpEndpoint=lR(t),this._initializeOptions(e),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(e?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=tW.createWebSocket(this.endpointURL())}catch(t){this._setConnectionState("disconnected");const e=t.message;throw e.includes("Node.js")?new Error(`${e}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${e}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(t,e){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(t?this.conn.close(t,e??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(t){const e=await t.unsubscribe();return this.channels.length===0&&this.disconnect(),e}async removeAllChannels(){const t=await Promise.all(this.channels.map(e=>e.unsubscribe()));return this.channels=[],this.disconnect(),t}log(t,e,s){this.logger(t,e,s)}connectionState(){switch(this.conn&&this.conn.readyState){case ko.connecting:return Aa.Connecting;case ko.open:return Aa.Open;case ko.closing:return Aa.Closing;default:return Aa.Closed}}isConnected(){return this.connectionState()===Aa.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(t,e={config:{}}){const s=`realtime:${t}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new wc(`realtime:${t}`,e,this);return this.channels.push(i),i}}push(t){const{topic:e,event:s,payload:r,ref:i}=t,o=()=>{this.encode(t,l=>{var c;(c=this.conn)===null||c===void 0||c.send(l)})};this.log("push",`${e} ${s} (${i})`,r),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(t=null){this._authPromise=this._performAuth(t);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var t;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(e){this.log("error","error in heartbeat callback",e)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(e){this.log("error","error in heartbeat callback",e)}this._wasManualDisconnect=!1,(t=this.conn)===null||t===void 0||t.close(rW,"heartbeat timeout"),setTimeout(()=>{var e;this.isConnected()||(e=this.reconnectTimer)===null||e===void 0||e.scheduleTimeout()},Up.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(e){this.log("error","error in heartbeat callback",e)}this._setAuthSafely("heartbeat")}onHeartbeat(t){this.heartbeatCallback=t}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(t=>t()),this.sendBuffer=[])}_makeRef(){let t=this.ref+1;return t===this.ref?this.ref=0:this.ref=t,this.ref.toString()}_leaveOpenTopic(t){let e=this.channels.find(s=>s.topic===t&&(s._isJoined()||s._isJoining()));e&&(this.log("transport",`leaving duplicate topic "${t}"`),e.unsubscribe())}_remove(t){this.channels=this.channels.filter(e=>e.topic!==t.topic)}_onConnMessage(t){this.decode(t.data,e=>{if(e.topic==="phoenix"&&e.event==="phx_reply")try{this.heartbeatCallback(e.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}e.ref&&e.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:r,payload:i,ref:o}=e,l=o?`(${o})`:"",c=i.status||"";this.log("receive",`${c} ${s} ${r} ${l}`.trim(),i),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(r,i,o)),this._triggerStateCallbacks("message",e)})}_clearTimer(t){var e;t==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):t==="reconnect"&&((e=this.reconnectTimer)===null||e===void 0||e.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=t=>this._onConnError(t),this.conn.onmessage=t=>this._onConnMessage(t),this.conn.onclose=t=>this._onConnClose(t),this.conn.readyState===ko.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===ko.open||this.conn.readyState===ko.connecting)try{this.conn.close()}catch(t){this.log("error","Error closing connection",t)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(t=>t.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(e=>{this.log("error","error waiting for auth on connect",e),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const t=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(t),this.workerRef.onerror=e=>{this.log("worker","worker error",e.message),this._terminateWorker()},this.workerRef.onmessage=e=>{e.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(t){var e;this._setConnectionState("disconnected"),this.log("transport","close",t),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(e=this.reconnectTimer)===null||e===void 0||e.scheduleTimeout(),this._triggerStateCallbacks("close",t)}_onConnError(t){this._setConnectionState("disconnected"),this.log("transport",`${t}`),this._triggerChanError(),this._triggerStateCallbacks("error",t)}_triggerChanError(){this.channels.forEach(t=>t._trigger(Lr.error))}_appendParams(t,e){if(Object.keys(e).length===0)return t;const s=t.match(/\?/)?"&":"?",r=new URLSearchParams(e);return`${t}${s}${r}`}_workerObjectUrl(t){let e;if(t)e=t;else{const s=new Blob([mW],{type:"application/javascript"});e=URL.createObjectURL(s)}return e}_setConnectionState(t,e=!1){this._connectionState=t,t==="connecting"?this._wasManualDisconnect=!1:t==="disconnecting"&&(this._wasManualDisconnect=e)}async _performAuth(t=null){let e,s=!1;if(t)e=t,s=!0;else if(this.accessToken)try{e=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),e=this.accessTokenValue}else e=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=e&&(this.accessTokenValue=e,this.channels.forEach(r=>{const i={access_token:e,version:nW};e&&r.updateJoinPayload(i),r.joinedOnce&&r._isJoined()&&r._push(Lr.access_token,{access_token:e})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(t="general"){this._isManualToken()||this.setAuth().catch(e=>{this.log("error",`Error setting auth in ${t}`,e)})}_triggerStateCallbacks(t,e){try{this.stateChangeCallbacks[t].forEach(s=>{try{s(e)}catch(r){this.log("error",`error in ${t} callback`,r)}})}catch(s){this.log("error",`error triggering ${t} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new oR(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},Up.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(t){var e,s,r,i,o,l,c,h,d,p,m,y;switch(this.transport=(e=t?.transport)!==null&&e!==void 0?e:null,this.timeout=(s=t?.timeout)!==null&&s!==void 0?s:yv,this.heartbeatIntervalMs=(r=t?.heartbeatIntervalMs)!==null&&r!==void 0?r:Up.HEARTBEAT_INTERVAL,this.worker=(i=t?.worker)!==null&&i!==void 0?i:!1,this.accessToken=(o=t?.accessToken)!==null&&o!==void 0?o:null,this.heartbeatCallback=(l=t?.heartbeatCallback)!==null&&l!==void 0?l:xx,this.vsn=(c=t?.vsn)!==null&&c!==void 0?c:hI,t?.params&&(this.params=t.params),t?.logger&&(this.logger=t.logger),(t?.logLevel||t?.log_level)&&(this.logLevel=t.logLevel||t.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=t?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>fW[b-1]||pW),this.vsn){case iR:this.encode=(d=t?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(p=t?.decode)!==null&&p!==void 0?p:((b,x)=>x(JSON.parse(b)));break;case sW:this.encode=(m=t?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=t?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=t?.workerUrl}}}var _h=class extends Error{constructor(n,t){super(n),this.name="IcebergError",this.status=t.status,this.icebergType=t.icebergType,this.icebergCode=t.icebergCode,this.details=t.details,this.isCommitStateUnknown=t.icebergType==="CommitStateUnknownException"||[500,502,504].includes(t.status)&&t.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function yW(n,t,e){const s=new URL(t,n);if(e)for(const[r,i]of Object.entries(e))i!==void 0&&s.searchParams.set(r,i);return s.toString()}async function bW(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function xW(n){const t=n.fetchImpl??globalThis.fetch;return{async request({method:e,path:s,query:r,body:i,headers:o}){const l=yW(n.baseUrl,s,r),c=await bW(n.auth),h=await t(l,{method:e,headers:{...i?{"Content-Type":"application/json"}:{},...c,...o},body:i?JSON.stringify(i):void 0}),d=await h.text(),p=(h.headers.get("content-type")||"").includes("application/json"),m=p&&d?JSON.parse(d):d;if(!h.ok){const y=p?m:void 0,b=y?.error;throw new _h(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function jp(n){return n.join("")}var vW=class{constructor(n,t=""){this.client=n,this.prefix=t}async listNamespaces(n){const t=n?{parent:jp(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:t})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,t){const e={namespace:n.namespace,properties:t?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:e})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${jp(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${jp(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${jp(n.namespace)}`}),!0}catch(t){if(t instanceof _h&&t.status===404)return!1;throw t}}async createNamespaceIfNotExists(n,t){try{return await this.createNamespace(n,t)}catch(e){if(e instanceof _h&&e.status===409)return;throw e}}};function ec(n){return n.join("")}var wW=class{constructor(n,t="",e){this.client=n,this.prefix=t,this.accessDelegation=e}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${ec(n.namespace)}/tables`})).data.identifiers}async createTable(n,t){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${ec(n.namespace)}/tables`,body:t,headers:e})).data.metadata}async updateTable(n,t){const e=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${ec(n.namespace)}/tables/${n.name}`,body:t});return{"metadata-location":e.data["metadata-location"],metadata:e.data.metadata}}async dropTable(n,t){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${ec(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(t?.purge??!1)}})}async loadTable(n){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${ec(n.namespace)}/tables/${n.name}`,headers:t})).data.metadata}async tableExists(n){const t={};this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${ec(n.namespace)}/tables/${n.name}`,headers:t}),!0}catch(e){if(e instanceof _h&&e.status===404)return!1;throw e}}async createTableIfNotExists(n,t){try{return await this.createTable(n,t)}catch(e){if(e instanceof _h&&e.status===409)return await this.loadTable({namespace:n.namespace,name:t.name});throw e}}},SW=class{constructor(n){let t="v1";n.catalogName&&(t+=`/${n.catalogName}`);const e=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=xW({baseUrl:e,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new vW(this.client,t),this.tableOps=new wW(this.client,t,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,t){return this.namespaceOps.createNamespace(n,t)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,t){return this.tableOps.createTable(n,t)}async updateTable(n,t){return this.tableOps.updateTable(n,t)}async dropTable(n,t){await this.tableOps.dropTable(n,t)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,t){return this.namespaceOps.createNamespaceIfNotExists(n,t)}async createTableIfNotExists(n,t){return this.tableOps.createTableIfNotExists(n,t)}},lg=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function Ke(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var CW=class extends lg{constructor(n,t,e){super(n),this.name="StorageApiError",this.status=t,this.statusCode=e}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},vv=class extends lg{constructor(n,t){super(n),this.name="StorageUnknownError",this.originalError=t}};const Kw=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),TW=()=>Response,wv=n=>{if(Array.isArray(n))return n.map(e=>wv(e));if(typeof n=="function"||n!==Object(n))return n;const t={};return Object.entries(n).forEach(([e,s])=>{const r=e.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));t[r]=wv(s)}),t},kW=n=>{if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},$W=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function Rh(n){"@babel/helpers - typeof";return Rh=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Rh(n)}function EW(n,t){if(Rh(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var s=e.call(n,t);if(Rh(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function IW(n){var t=EW(n,"string");return Rh(t)=="symbol"?t:t+""}function NW(n,t,e){return(t=IW(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function mI(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);t&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),e.push.apply(e,s)}return e}function Ut(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?mI(Object(e),!0).forEach(function(s){NW(n,s,e[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):mI(Object(e)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(e,s))})}return n}const vx=n=>{var t;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(t=n.error)===null||t===void 0?void 0:t.message)||JSON.stringify(n)},AW=async(n,t,e)=>{n instanceof await TW()&&!e?.noResolveJson?n.json().then(s=>{const r=n.status||500,i=s?.statusCode||r+"";t(new CW(vx(s),r,i))}).catch(s=>{t(new vv(vx(s),s))}):t(new vv(vx(n),n))},_W=(n,t,e,s)=>{const r={method:n,headers:t?.headers||{}};return n==="GET"||!s?r:(kW(s)?(r.headers=Ut({"Content-Type":"application/json"},t?.headers),r.body=JSON.stringify(s)):r.body=s,t?.duplex&&(r.duplex=t.duplex),Ut(Ut({},r),e))};async function td(n,t,e,s,r,i){return new Promise((o,l)=>{n(e,_W(t,s,r,i)).then(c=>{if(!c.ok)throw c;return s?.noResolveJson?c:c.json()}).then(c=>o(c)).catch(c=>AW(c,l,s))})}async function Dh(n,t,e,s){return td(n,"GET",t,e,s)}async function Fr(n,t,e,s,r){return td(n,"POST",t,s,r,e)}async function Sv(n,t,e,s,r){return td(n,"PUT",t,s,r,e)}async function RW(n,t,e,s){return td(n,"HEAD",t,Ut(Ut({},e),{},{noResolveJson:!0}),s)}async function Xw(n,t,e,s,r){return td(n,"DELETE",t,s,r,e)}var DW=class{constructor(n,t){this.downloadFn=n,this.shouldThrowOnError=t}then(n,t){return this.execute().then(n,t)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(t){if(n.shouldThrowOnError)throw t;if(Ke(t))return{data:null,error:t};throw t}}};let cR;cR=Symbol.toStringTag;var OW=class{constructor(n,t){this.downloadFn=n,this.shouldThrowOnError=t,this[cR]="BlobDownloadBuilder",this.promise=null}asStream(){return new DW(this.downloadFn,this.shouldThrowOnError)}then(n,t){return this.getPromise().then(n,t)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(t){if(n.shouldThrowOnError)throw t;if(Ke(t))return{data:null,error:t};throw t}}};const MW={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},gI={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var FW=class{constructor(n,t={},e,s){this.shouldThrowOnError=!1,this.url=n,this.headers=t,this.bucketId=e,this.fetch=Kw(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,t,e,s){var r=this;try{let i;const o=Ut(Ut({},gI),s);let l=Ut(Ut({},r.headers),n==="POST"&&{"x-upsert":String(o.upsert)});const c=o.metadata;typeof Blob<"u"&&e instanceof Blob?(i=new FormData,i.append("cacheControl",o.cacheControl),c&&i.append("metadata",r.encodeMetadata(c)),i.append("",e)):typeof FormData<"u"&&e instanceof FormData?(i=e,i.has("cacheControl")||i.append("cacheControl",o.cacheControl),c&&!i.has("metadata")&&i.append("metadata",r.encodeMetadata(c))):(i=e,l["cache-control"]=`max-age=${o.cacheControl}`,l["content-type"]=o.contentType,c&&(l["x-metadata"]=r.toBase64(r.encodeMetadata(c))),(typeof ReadableStream<"u"&&i instanceof ReadableStream||i&&typeof i=="object"&&"pipe"in i&&typeof i.pipe=="function")&&!o.duplex&&(o.duplex="half")),s?.headers&&(l=Ut(Ut({},l),s.headers));const h=r._removeEmptyFolders(t),d=r._getFinalPath(h),p=await(n=="PUT"?Sv:Fr)(r.fetch,`${r.url}/object/${d}`,i,Ut({headers:l},o?.duplex?{duplex:o.duplex}:{}));return{data:{path:h,id:p.Id,fullPath:p.Key},error:null}}catch(i){if(r.shouldThrowOnError)throw i;if(Ke(i))return{data:null,error:i};throw i}}async upload(n,t,e){return this.uploadOrUpdate("POST",n,t,e)}async uploadToSignedUrl(n,t,e,s){var r=this;const i=r._removeEmptyFolders(n),o=r._getFinalPath(i),l=new URL(r.url+`/object/upload/sign/${o}`);l.searchParams.set("token",t);try{let c;const h=Ut({upsert:gI.upsert},s),d=Ut(Ut({},r.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&e instanceof Blob?(c=new FormData,c.append("cacheControl",h.cacheControl),c.append("",e)):typeof FormData<"u"&&e instanceof FormData?(c=e,c.append("cacheControl",h.cacheControl)):(c=e,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:i,fullPath:(await Sv(r.fetch,l.toString(),c,{headers:d})).Key},error:null}}catch(c){if(r.shouldThrowOnError)throw c;if(Ke(c))return{data:null,error:c};throw c}}async createSignedUploadUrl(n,t){var e=this;try{let s=e._getFinalPath(n);const r=Ut({},e.headers);t?.upsert&&(r["x-upsert"]="true");const i=await Fr(e.fetch,`${e.url}/object/upload/sign/${s}`,{},{headers:r}),o=new URL(e.url+i.url),l=o.searchParams.get("token");if(!l)throw new lg("No token returned by API");return{data:{signedUrl:o.toString(),path:n,token:l},error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ke(s))return{data:null,error:s};throw s}}async update(n,t,e){return this.uploadOrUpdate("PUT",n,t,e)}async move(n,t,e){var s=this;try{return{data:await Fr(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:t,destinationBucket:e?.destinationBucket},{headers:s.headers}),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ke(r))return{data:null,error:r};throw r}}async copy(n,t,e){var s=this;try{return{data:{path:(await Fr(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:t,destinationBucket:e?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ke(r))return{data:null,error:r};throw r}}async createSignedUrl(n,t,e){var s=this;try{let r=s._getFinalPath(n),i=await Fr(s.fetch,`${s.url}/object/sign/${r}`,Ut({expiresIn:t},e?.transform?{transform:e.transform}:{}),{headers:s.headers});const o=e?.download?`&download=${e.download===!0?"":e.download}`:"";return i={signedUrl:encodeURI(`${s.url}${i.signedURL}${o}`)},{data:i,error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ke(r))return{data:null,error:r};throw r}}async createSignedUrls(n,t,e){var s=this;try{const r=await Fr(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:t,paths:n},{headers:s.headers}),i=e?.download?`&download=${e.download===!0?"":e.download}`:"";return{data:r.map(o=>Ut(Ut({},o),{},{signedUrl:o.signedURL?encodeURI(`${s.url}${o.signedURL}${i}`):null})),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ke(r))return{data:null,error:r};throw r}}download(n,t){const e=typeof t?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(t?.transform||{}),r=s?`?${s}`:"",i=this._getFinalPath(n),o=()=>Dh(this.fetch,`${this.url}/${e}/${i}${r}`,{headers:this.headers,noResolveJson:!0});return new OW(o,this.shouldThrowOnError)}async info(n){var t=this;const e=t._getFinalPath(n);try{return{data:wv(await Dh(t.fetch,`${t.url}/object/info/${e}`,{headers:t.headers})),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ke(s))return{data:null,error:s};throw s}}async exists(n){var t=this;const e=t._getFinalPath(n);try{return await RW(t.fetch,`${t.url}/object/${e}`,{headers:t.headers}),{data:!0,error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ke(s)&&s instanceof vv){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,t){const e=this._getFinalPath(n),s=[],r=t?.download?`download=${t.download===!0?"":t.download}`:"";r!==""&&s.push(r);const i=typeof t?.transform<"u"?"render/image":"object",o=this.transformOptsToQueryString(t?.transform||{});o!==""&&s.push(o);let l=s.join("&");return l!==""&&(l=`?${l}`),{data:{publicUrl:encodeURI(`${this.url}/${i}/public/${e}${l}`)}}}async remove(n){var t=this;try{return{data:await Xw(t.fetch,`${t.url}/object/${t.bucketId}`,{prefixes:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}async list(n,t,e){var s=this;try{const r=Ut(Ut(Ut({},MW),t),{},{prefix:n||""});return{data:await Fr(s.fetch,`${s.url}/object/list/${s.bucketId}`,r,{headers:s.headers},e),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ke(r))return{data:null,error:r};throw r}}async listV2(n,t){var e=this;try{const s=Ut({},n);return{data:await Fr(e.fetch,`${e.url}/object/list-v2/${e.bucketId}`,s,{headers:e.headers},t),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ke(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const t=[];return n.width&&t.push(`width=${n.width}`),n.height&&t.push(`height=${n.height}`),n.resize&&t.push(`resize=${n.resize}`),n.format&&t.push(`format=${n.format}`),n.quality&&t.push(`quality=${n.quality}`),t.join("&")}};const uR="2.89.0",hR={"X-Client-Info":`storage-js/${uR}`};var LW=class{constructor(n,t={},e,s){this.shouldThrowOnError=!1;const r=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=Ut(Ut({},hR),t),this.fetch=Kw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var t=this;try{const e=t.listBucketOptionsToQueryString(n);return{data:await Dh(t.fetch,`${t.url}/bucket${e}`,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}async getBucket(n){var t=this;try{return{data:await Dh(t.fetch,`${t.url}/bucket/${n}`,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}async createBucket(n,t={public:!1}){var e=this;try{return{data:await Fr(e.fetch,`${e.url}/bucket`,{id:n,name:n,type:t.type,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ke(s))return{data:null,error:s};throw s}}async updateBucket(n,t){var e=this;try{return{data:await Sv(e.fetch,`${e.url}/bucket/${n}`,{id:n,name:n,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ke(s))return{data:null,error:s};throw s}}async emptyBucket(n){var t=this;try{return{data:await Fr(t.fetch,`${t.url}/bucket/${n}/empty`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Xw(t.fetch,`${t.url}/bucket/${n}`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}listBucketOptionsToQueryString(n){const t={};return n&&("limit"in n&&(t.limit=String(n.limit)),"offset"in n&&(t.offset=String(n.offset)),n.search&&(t.search=n.search),n.sortColumn&&(t.sortColumn=n.sortColumn),n.sortOrder&&(t.sortOrder=n.sortOrder)),Object.keys(t).length>0?"?"+new URLSearchParams(t).toString():""}},PW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},hR),t),this.fetch=Kw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var t=this;try{return{data:await Fr(t.fetch,`${t.url}/bucket`,{name:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}async listBuckets(n){var t=this;try{const e=new URLSearchParams;n?.limit!==void 0&&e.set("limit",n.limit.toString()),n?.offset!==void 0&&e.set("offset",n.offset.toString()),n?.sortColumn&&e.set("sortColumn",n.sortColumn),n?.sortOrder&&e.set("sortOrder",n.sortOrder),n?.search&&e.set("search",n.search);const s=e.toString(),r=s?`${t.url}/bucket?${s}`:`${t.url}/bucket`;return{data:await Dh(t.fetch,r,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Xw(t.fetch,`${t.url}/bucket/${n}`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ke(e))return{data:null,error:e};throw e}}from(n){var t=this;if(!$W(n))throw new lg("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const e=new SW({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>t.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(e,{get(r,i){const o=r[i];return typeof o!="function"?o:async(...l)=>{try{return{data:await o.apply(r,l),error:null}}catch(c){if(s)throw c;return{data:null,error:c}}}}})}};const Yw={"X-Client-Info":`storage-js/${uR}`,"Content-Type":"application/json"};var dR=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function Ks(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var wx=class extends dR{constructor(n,t,e){super(n),this.name="StorageVectorsApiError",this.status=t,this.statusCode=e}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},zW=class extends dR{constructor(n,t){super(n),this.name="StorageVectorsUnknownError",this.originalError=t}};const Zw=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),BW=n=>{if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},yI=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),VW=async(n,t,e)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!e?.noResolveJson){const s=n.status||500,r=n;if(typeof r.json=="function")r.json().then(i=>{const o=i?.statusCode||i?.code||s+"";t(new wx(yI(i),s,o))}).catch(()=>{const i=s+"";t(new wx(r.statusText||`HTTP ${s} error`,s,i))});else{const i=s+"";t(new wx(r.statusText||`HTTP ${s} error`,s,i))}}else t(new zW(yI(n),n))},UW=(n,t,e,s)=>{const r={method:n,headers:t?.headers||{}};return s?(BW(s)?(r.headers=Ut({"Content-Type":"application/json"},t?.headers),r.body=JSON.stringify(s)):r.body=s,Ut(Ut({},r),e)):r};async function jW(n,t,e,s,r,i){return new Promise((o,l)=>{n(e,UW(t,s,r,i)).then(c=>{if(!c.ok)throw c;if(s?.noResolveJson)return c;const h=c.headers.get("content-type");return!h||!h.includes("application/json")?{}:c.json()}).then(c=>o(c)).catch(c=>VW(c,l,s))})}async function Xs(n,t,e,s,r){return jW(n,"POST",t,s,r,e)}var GW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Yw),t),this.fetch=Zw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/CreateIndex`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async getIndex(n,t){var e=this;try{return{data:await Xs(e.fetch,`${e.url}/GetIndex`,{vectorBucketName:n,indexName:t},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ks(s))return{data:null,error:s};throw s}}async listIndexes(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/ListIndexes`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async deleteIndex(n,t){var e=this;try{return{data:await Xs(e.fetch,`${e.url}/DeleteIndex`,{vectorBucketName:n,indexName:t},{headers:e.headers})||{},error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ks(s))return{data:null,error:s};throw s}}},WW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Yw),t),this.fetch=Zw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var t=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await Xs(t.fetch,`${t.url}/PutVectors`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async getVectors(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/GetVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async listVectors(n){var t=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await Xs(t.fetch,`${t.url}/ListVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async queryVectors(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/QueryVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async deleteVectors(n){var t=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await Xs(t.fetch,`${t.url}/DeleteVectors`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}},HW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Yw),t),this.fetch=Zw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async getBucket(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/GetVectorBucket`,{vectorBucketName:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async listBuckets(n={}){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/ListVectorBuckets`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Xs(t.fetch,`${t.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ks(e))return{data:null,error:e};throw e}}},qW=class extends HW{constructor(n,t={}){super(n,t.headers||{},t.fetch)}from(n){return new KW(this.url,this.headers,n,this.fetch)}async createBucket(n){var t=()=>super.createBucket,e=this;return t().call(e,n)}async getBucket(n){var t=()=>super.getBucket,e=this;return t().call(e,n)}async listBuckets(n={}){var t=()=>super.listBuckets,e=this;return t().call(e,n)}async deleteBucket(n){var t=()=>super.deleteBucket,e=this;return t().call(e,n)}},KW=class extends GW{constructor(n,t,e,s){super(n,t,s),this.vectorBucketName=e}async createIndex(n){var t=()=>super.createIndex,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName}))}async listIndexes(n={}){var t=()=>super.listIndexes,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName}))}async getIndex(n){var t=()=>super.getIndex,e=this;return t().call(e,e.vectorBucketName,n)}async deleteIndex(n){var t=()=>super.deleteIndex,e=this;return t().call(e,e.vectorBucketName,n)}index(n){return new XW(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},XW=class extends WW{constructor(n,t,e,s,r){super(n,t,r),this.vectorBucketName=e,this.indexName=s}async putVectors(n){var t=()=>super.putVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async getVectors(n){var t=()=>super.getVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async listVectors(n={}){var t=()=>super.listVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async queryVectors(n){var t=()=>super.queryVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async deleteVectors(n){var t=()=>super.deleteVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}},YW=class extends LW{constructor(n,t={},e,s){super(n,t,e,s)}from(n){return new FW(this.url,this.headers,n,this.fetch)}get vectors(){return new qW(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new PW(this.url+"/iceberg",this.headers,this.fetch)}};const fR="2.89.0",hc=30*1e3,Cv=3,Sx=Cv*hc,ZW="http://localhost:9999",JW="supabase.auth.token",QW={"X-Client-Info":`gotrue-js/${fR}`},Tv="X-Supabase-Api-Version",pR={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},tH=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,eH=600*1e3;class Oh extends Error{constructor(t,e,s){super(t),this.__isAuthError=!0,this.name="AuthError",this.status=e,this.code=s}}function Dt(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class nH extends Oh{constructor(t,e,s){super(t,e,s),this.name="AuthApiError",this.status=e,this.code=s}}function sH(n){return Dt(n)&&n.name==="AuthApiError"}class _a extends Oh{constructor(t,e){super(t),this.name="AuthUnknownError",this.originalError=e}}class Ki extends Oh{constructor(t,e,s,r){super(t,s,r),this.name=e,this.status=s}}class qs extends Ki{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function rH(n){return Dt(n)&&n.name==="AuthSessionMissingError"}class nc extends Ki{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class Gp extends Ki{constructor(t){super(t,"AuthInvalidCredentialsError",400,void 0)}}class Wp extends Ki{constructor(t,e=null){super(t,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function iH(n){return Dt(n)&&n.name==="AuthImplicitGrantRedirectError"}class bI extends Ki{constructor(t,e=null){super(t,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class oH extends Ki{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class kv extends Ki{constructor(t,e){super(t,"AuthRetryableFetchError",e,void 0)}}function Cx(n){return Dt(n)&&n.name==="AuthRetryableFetchError"}class xI extends Ki{constructor(t,e,s){super(t,"AuthWeakPasswordError",e,"weak_password"),this.reasons=s}}class $v extends Ki{constructor(t){super(t,"AuthInvalidJwtError",400,"invalid_jwt")}}const Tm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),vI=` 	
\r=`.split(""),aH=(()=>{const n=new Array(128);for(let t=0;t<n.length;t+=1)n[t]=-1;for(let t=0;t<vI.length;t+=1)n[vI[t].charCodeAt(0)]=-2;for(let t=0;t<Tm.length;t+=1)n[Tm[t].charCodeAt(0)]=t;return n})();function wI(n,t,e){if(n!==null)for(t.queue=t.queue<<8|n,t.queuedBits+=8;t.queuedBits>=6;){const s=t.queue>>t.queuedBits-6&63;e(Tm[s]),t.queuedBits-=6}else if(t.queuedBits>0)for(t.queue=t.queue<<6-t.queuedBits,t.queuedBits=6;t.queuedBits>=6;){const s=t.queue>>t.queuedBits-6&63;e(Tm[s]),t.queuedBits-=6}}function mR(n,t,e){const s=aH[n];if(s>-1)for(t.queue=t.queue<<6|s,t.queuedBits+=6;t.queuedBits>=8;)e(t.queue>>t.queuedBits-8&255),t.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function SI(n){const t=[],e=o=>{t.push(String.fromCodePoint(o))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=o=>{uH(o,s,e)};for(let o=0;o<n.length;o+=1)mR(n.charCodeAt(o),r,i);return t.join("")}function lH(n,t){if(n<=127){t(n);return}else if(n<=2047){t(192|n>>6),t(128|n&63);return}else if(n<=65535){t(224|n>>12),t(128|n>>6&63),t(128|n&63);return}else if(n<=1114111){t(240|n>>18),t(128|n>>12&63),t(128|n>>6&63),t(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function cH(n,t){for(let e=0;e<n.length;e+=1){let s=n.charCodeAt(e);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(e+1)-56320&65535|r)+65536,e+=1}lH(s,t)}}function uH(n,t,e){if(t.utf8seq===0){if(n<=127){e(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){t.utf8seq=s;break}if(t.utf8seq===2)t.codepoint=n&31;else if(t.utf8seq===3)t.codepoint=n&15;else if(t.utf8seq===4)t.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");t.utf8seq-=1}else if(t.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");t.codepoint=t.codepoint<<6|n&63,t.utf8seq-=1,t.utf8seq===0&&e(t.codepoint)}}function Cc(n){const t=[],e={queue:0,queuedBits:0},s=r=>{t.push(r)};for(let r=0;r<n.length;r+=1)mR(n.charCodeAt(r),e,s);return new Uint8Array(t)}function hH(n){const t=[];return cH(n,e=>t.push(e)),new Uint8Array(t)}function La(n){const t=[],e={queue:0,queuedBits:0},s=r=>{t.push(r)};return n.forEach(r=>wI(r,e,s)),wI(null,e,s),t.join("")}function dH(n){return Math.round(Date.now()/1e3)+n}function fH(){return Symbol("auth-callback")}const Xn=()=>typeof window<"u"&&typeof document<"u",Sa={tested:!1,writable:!1},gR=()=>{if(!Xn())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(Sa.tested)return Sa.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),Sa.tested=!0,Sa.writable=!0}catch{Sa.tested=!0,Sa.writable=!1}return Sa.writable};function pH(n){const t={},e=new URL(n);if(e.hash&&e.hash[0]==="#")try{new URLSearchParams(e.hash.substring(1)).forEach((r,i)=>{t[i]=r})}catch{}return e.searchParams.forEach((s,r)=>{t[r]=s}),t}const yR=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),mH=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",dc=async(n,t,e)=>{await n.setItem(t,JSON.stringify(e))},Ca=async(n,t)=>{const e=await n.getItem(t);if(!e)return null;try{return JSON.parse(e)}catch{return e}},Kn=async(n,t)=>{await n.removeItem(t)};class cg{constructor(){this.promise=new cg.promiseConstructor((t,e)=>{this.resolve=t,this.reject=e})}}cg.promiseConstructor=Promise;function Tx(n){const t=n.split(".");if(t.length!==3)throw new $v("Invalid JWT structure");for(let s=0;s<t.length;s++)if(!tH.test(t[s]))throw new $v("JWT not in base64url format");return{header:JSON.parse(SI(t[0])),payload:JSON.parse(SI(t[1])),signature:Cc(t[2]),raw:{header:t[0],payload:t[1]}}}async function gH(n){return await new Promise(t=>{setTimeout(()=>t(null),n)})}function yH(n,t){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const o=await n(i);if(!t(i,null,o)){s(o);return}}catch(o){if(!t(i,o)){r(o);return}}})()})}function bH(n){return("0"+n.toString(16)).substr(-2)}function xH(){const t=new Uint32Array(56);if(typeof crypto>"u"){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=e.length;let r="";for(let i=0;i<56;i++)r+=e.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(t),Array.from(t,bH).join("")}async function vH(n){const e=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",e),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function wH(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const e=await vH(n);return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function sc(n,t,e=!1){const s=xH();let r=s;e&&(r+="/PASSWORD_RECOVERY"),await dc(n,`${t}-code-verifier`,r);const i=await wH(s);return[i,s===i?"plain":"s256"]}const SH=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function CH(n){const t=n.headers.get(Tv);if(!t||!t.match(SH))return null;try{return new Date(`${t}T00:00:00.0Z`)}catch{return null}}function TH(n){if(!n)throw new Error("Missing exp claim");const t=Math.floor(Date.now()/1e3);if(n<=t)throw new Error("JWT has expired")}function kH(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const $H=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function rc(n){if(!$H.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function kx(){const n={};return new Proxy(n,{get:(t,e)=>{if(e==="__isUserNotAvailableProxy")return!0;if(typeof e=="symbol"){const s=e.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${e}" property of the session object is not supported. Please use getUser() instead.`)},set:(t,e)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${e}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(t,e)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${e}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function EH(n,t){return new Proxy(n,{get:(e,s,r)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const i=s.toString();if(i==="Symbol(Symbol.toPrimitive)"||i==="Symbol(Symbol.toStringTag)"||i==="Symbol(util.inspect.custom)"||i==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(e,s,r)}return!t.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),t.value=!0),Reflect.get(e,s,r)}})}function CI(n){return JSON.parse(JSON.stringify(n))}const Ia=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),IH=[502,503,504];async function TI(n){var t;if(!mH(n))throw new kv(Ia(n),0);if(IH.includes(n.status))throw new kv(Ia(n),n.status);let e;try{e=await n.json()}catch(i){throw new _a(Ia(i),i)}let s;const r=CH(n);if(r&&r.getTime()>=pR["2024-01-01"].timestamp&&typeof e=="object"&&e&&typeof e.code=="string"?s=e.code:typeof e=="object"&&e&&typeof e.error_code=="string"&&(s=e.error_code),s){if(s==="weak_password")throw new xI(Ia(e),n.status,((t=e.weak_password)===null||t===void 0?void 0:t.reasons)||[]);if(s==="session_not_found")throw new qs}else if(typeof e=="object"&&e&&typeof e.weak_password=="object"&&e.weak_password&&Array.isArray(e.weak_password.reasons)&&e.weak_password.reasons.length&&e.weak_password.reasons.reduce((i,o)=>i&&typeof o=="string",!0))throw new xI(Ia(e),n.status,e.weak_password.reasons);throw new nH(Ia(e),n.status||500,s)}const NH=(n,t,e,s)=>{const r={method:n,headers:t?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},t?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),e))};async function Vt(n,t,e,s){var r;const i=Object.assign({},s?.headers);i[Tv]||(i[Tv]=pR["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const o=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(o.redirect_to=s.redirectTo);const l=Object.keys(o).length?"?"+new URLSearchParams(o).toString():"",c=await AH(n,t,e+l,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(c):{data:Object.assign({},c),error:null}}async function AH(n,t,e,s,r,i){const o=NH(t,s,r,i);let l;try{l=await n(e,Object.assign({},o))}catch(c){throw console.error(c),new kv(Ia(c),0)}if(l.ok||await TI(l),s?.noResolveJson)return l;try{return await l.json()}catch(c){await TI(c)}}function Dr(n){var t;let e=null;DH(n)&&(e=Object.assign({},n),n.expires_at||(e.expires_at=dH(n.expires_in)));const s=(t=n.user)!==null&&t!==void 0?t:n;return{data:{session:e,user:s},error:null}}function kI(n){const t=Dr(n);return!t.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((e,s)=>e&&typeof s=="string",!0)&&(t.data.weak_password=n.weak_password),t}function Eo(n){var t;return{data:{user:(t=n.user)!==null&&t!==void 0?t:n},error:null}}function _H(n){return{data:n,error:null}}function RH(n){const{action_link:t,email_otp:e,hashed_token:s,redirect_to:r,verification_type:i}=n,o=ag(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),l={action_link:t,email_otp:e,hashed_token:s,redirect_to:r,verification_type:i},c=Object.assign({},o);return{data:{properties:l,user:c},error:null}}function $I(n){return n}function DH(n){return n.access_token&&n.refresh_token&&n.expires_in}const $x=["global","local","others"];class OH{constructor({url:t="",headers:e={},fetch:s}){this.url=t,this.headers=e,this.fetch=yR(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(t,e=$x[0]){if($x.indexOf(e)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${$x.join(", ")}`);try{return await Vt(this.fetch,"POST",`${this.url}/logout?scope=${e}`,{headers:this.headers,jwt:t,noResolveJson:!0}),{data:null,error:null}}catch(s){if(Dt(s))return{data:null,error:s};throw s}}async inviteUserByEmail(t,e={}){try{return await Vt(this.fetch,"POST",`${this.url}/invite`,{body:{email:t,data:e.data},headers:this.headers,redirectTo:e.redirectTo,xform:Eo})}catch(s){if(Dt(s))return{data:{user:null},error:s};throw s}}async generateLink(t){try{const{options:e}=t,s=ag(t,["options"]),r=Object.assign(Object.assign({},s),e);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await Vt(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:RH,redirectTo:e?.redirectTo})}catch(e){if(Dt(e))return{data:{properties:null,user:null},error:e};throw e}}async createUser(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/users`,{body:t,headers:this.headers,xform:Eo})}catch(e){if(Dt(e))return{data:{user:null},error:e};throw e}}async listUsers(t){var e,s,r,i,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Vt(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=t?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:$I});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Dt(h))return{data:{users:[]},error:h};throw h}}async getUserById(t){rc(t);try{return await Vt(this.fetch,"GET",`${this.url}/admin/users/${t}`,{headers:this.headers,xform:Eo})}catch(e){if(Dt(e))return{data:{user:null},error:e};throw e}}async updateUserById(t,e){rc(t);try{return await Vt(this.fetch,"PUT",`${this.url}/admin/users/${t}`,{body:e,headers:this.headers,xform:Eo})}catch(s){if(Dt(s))return{data:{user:null},error:s};throw s}}async deleteUser(t,e=!1){rc(t);try{return await Vt(this.fetch,"DELETE",`${this.url}/admin/users/${t}`,{headers:this.headers,body:{should_soft_delete:e},xform:Eo})}catch(s){if(Dt(s))return{data:{user:null},error:s};throw s}}async _listFactors(t){rc(t.userId);try{const{data:e,error:s}=await Vt(this.fetch,"GET",`${this.url}/admin/users/${t.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:e,error:s}}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _deleteFactor(t){rc(t.userId),rc(t.id);try{return{data:await Vt(this.fetch,"DELETE",`${this.url}/admin/users/${t.userId}/factors/${t.id}`,{headers:this.headers}),error:null}}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _listOAuthClients(t){var e,s,r,i,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Vt(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=t?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:$I});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Dt(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:t,headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _getOAuthClient(t){try{return await Vt(this.fetch,"GET",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _updateOAuthClient(t,e){try{return await Vt(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${t}`,{body:e,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(Dt(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(t){try{return await Vt(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _regenerateOAuthClientSecret(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/oauth/clients/${t}/regenerate_secret`,{headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Dt(e))return{data:null,error:e};throw e}}}function EI(n={}){return{getItem:t=>n[t]||null,setItem:(t,e)=>{n[t]=e},removeItem:t=>{delete n[t]}}}const ic={debug:!!(globalThis&&gR()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class bR extends Error{constructor(t){super(t),this.isAcquireTimeout=!0}}class MH extends bR{}async function FH(n,t,e){ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,t);const s=new globalThis.AbortController;return t>0&&setTimeout(()=>{s.abort(),ic.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},t),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,t===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await e()}finally{ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(t===0)throw ic.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new MH(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(ic.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await e()}}))}function LH(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function xR(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function PH(n){return parseInt(n,16)}function zH(n){const t=new TextEncoder().encode(n);return"0x"+Array.from(t,s=>s.toString(16).padStart(2,"0")).join("")}function BH(n){var t;const{chainId:e,domain:s,expirationTime:r,issuedAt:i=new Date,nonce:o,notBefore:l,requestId:c,resources:h,scheme:d,uri:p,version:m}=n;{if(!Number.isInteger(e))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${e}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(o&&o.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((t=n.statement)===null||t===void 0)&&t.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=xR(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let S=`URI: ${p}
Version: ${m}
Chain ID: ${e}${o?`
Nonce: ${o}`:""}
Issued At: ${i.toISOString()}`;if(r&&(S+=`
Expiration Time: ${r.toISOString()}`),l&&(S+=`
Not Before: ${l.toISOString()}`),c&&(S+=`
Request ID: ${c}`),h){let T=`
Resources:`;for(const k of h){if(!k||typeof k!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${k}`);T+=`
- ${k}`}S+=T}return`${w}
${S}`}class yn extends Error{constructor({message:t,code:e,cause:s,name:r}){var i;super(t,{cause:s}),this.__isWebAuthnError=!0,this.name=(i=r??(s instanceof Error?s.name:void 0))!==null&&i!==void 0?i:"Unknown Error",this.code=e}}class km extends yn{constructor(t,e){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e,message:t}),this.name="WebAuthnUnknownError",this.originalError=e}}function VH({error:n,options:t}){var e,s,r;const{publicKey:i}=t;if(!i)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(t.signal instanceof AbortSignal)return new yn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((e=i.authenticatorSelection)===null||e===void 0?void 0:e.requireResidentKey)===!0)return new yn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(t.mediation==="conditional"&&((s=i.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new yn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((r=i.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new yn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new yn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new yn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return i.pubKeyCredParams.filter(l=>l.type==="public-key").length===0?new yn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new yn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const o=window.location.hostname;if(vR(o)){if(i.rp.id!==o)return new yn({message:`The RP ID "${i.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new yn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new yn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new yn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new yn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function UH({error:n,options:t}){const{publicKey:e}=t;if(!e)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(t.signal instanceof AbortSignal)return new yn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new yn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(vR(s)){if(e.rpId!==s)return new yn({message:`The RP ID "${e.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new yn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new yn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new yn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class jH{createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const GH=new jH;function WH(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:t,user:e,excludeCredentials:s}=n,r=ag(n,["challenge","user","excludeCredentials"]),i=Cc(t).buffer,o=Object.assign(Object.assign({},e),{id:Cc(e.id).buffer}),l=Object.assign(Object.assign({},r),{challenge:i,user:o});if(s&&s.length>0){l.excludeCredentials=new Array(s.length);for(let c=0;c<s.length;c++){const h=s[c];l.excludeCredentials[c]=Object.assign(Object.assign({},h),{id:Cc(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return l}function HH(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:t,allowCredentials:e}=n,s=ag(n,["challenge","allowCredentials"]),r=Cc(t).buffer,i=Object.assign(Object.assign({},s),{challenge:r});if(e&&e.length>0){i.allowCredentials=new Array(e.length);for(let o=0;o<e.length;o++){const l=e[o];i.allowCredentials[o]=Object.assign(Object.assign({},l),{id:Cc(l.id).buffer,type:l.type||"public-key",transports:l.transports})}}return i}function qH(n){var t;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const e=n;return{id:n.id,rawId:n.id,response:{attestationObject:La(new Uint8Array(n.response.attestationObject)),clientDataJSON:La(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(t=e.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function KH(n){var t;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const e=n,s=n.getClientExtensionResults(),r=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:La(new Uint8Array(r.authenticatorData)),clientDataJSON:La(new Uint8Array(r.clientDataJSON)),signature:La(new Uint8Array(r.signature)),userHandle:r.userHandle?La(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(t=e.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function vR(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function II(){var n,t;return!!(Xn()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((t=navigator?.credentials)===null||t===void 0?void 0:t.get)=="function")}async function XH(n){try{const t=await navigator.credentials.create(n);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new km("Browser returned unexpected credential type",t)}:{data:null,error:new km("Empty credential response",t)}}catch(t){return{data:null,error:VH({error:t,options:n})}}}async function YH(n){try{const t=await navigator.credentials.get(n);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new km("Browser returned unexpected credential type",t)}:{data:null,error:new km("Empty credential response",t)}}catch(t){return{data:null,error:UH({error:t,options:n})}}}const ZH={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},JH={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function $m(...n){const t=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),e=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),s={};for(const r of n)if(r)for(const i in r){const o=r[i];if(o!==void 0)if(Array.isArray(o))s[i]=o;else if(e(o))s[i]=o;else if(t(o)){const l=s[i];t(l)?s[i]=$m(l,o):s[i]=$m(o)}else s[i]=o}return s}function QH(n,t){return $m(ZH,n,t||{})}function t5(n,t){return $m(JH,n,t||{})}class e5{constructor(t){this.client=t,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(t){return this.client.mfa.enroll(Object.assign(Object.assign({},t),{factorType:"webauthn"}))}async _challenge({factorId:t,webauthn:e,friendlyName:s,signal:r},i){try{const{data:o,error:l}=await this.client.mfa.challenge({factorId:t,webauthn:e});if(!o)return{data:null,error:l};const c=r??GH.createNewAbortSignal();if(o.webauthn.type==="create"){const{user:h}=o.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(o.webauthn.type){case"create":{const h=QH(o.webauthn.credential_options.publicKey,i?.create),{data:d,error:p}=await XH({publicKey:h,signal:c});return d?{data:{factorId:t,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}case"request":{const h=t5(o.webauthn.credential_options.publicKey,i?.request),{data:d,error:p}=await YH(Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:h,signal:c}));return d?{data:{factorId:t,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}}}catch(o){return Dt(o)?{data:null,error:o}:{data:null,error:new _a("Unexpected error in challenge",o)}}}async _verify({challengeId:t,factorId:e,webauthn:s}){return this.client.mfa.verify({factorId:e,challengeId:t,webauthn:s})}async _authenticate({factorId:t,webauthn:{rpId:e=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!e)return{data:null,error:new Oh("rpId is required for WebAuthn authentication")};try{if(!II())return{data:null,error:new _a("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this.challenge({factorId:t,webauthn:{rpId:e,rpOrigins:s},signal:r},{request:i});if(!o)return{data:null,error:l};const{webauthn:c}=o;return this._verify({factorId:t,challengeId:o.challengeId,webauthn:{type:c.type,rpId:e,rpOrigins:s,credential_response:c.credential_response}})}catch(o){return Dt(o)?{data:null,error:o}:{data:null,error:new _a("Unexpected error in authenticate",o)}}}async _register({friendlyName:t,webauthn:{rpId:e=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!e)return{data:null,error:new Oh("rpId is required for WebAuthn registration")};try{if(!II())return{data:null,error:new _a("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this._enroll({friendlyName:t});if(!o)return await this.client.mfa.listFactors().then(d=>{var p;return(p=d.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===t&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:l};const{data:c,error:h}=await this._challenge({factorId:o.id,friendlyName:o.friendly_name,webauthn:{rpId:e,rpOrigins:s},signal:r},{create:i});return c?this._verify({factorId:o.id,challengeId:c.challengeId,webauthn:{rpId:e,rpOrigins:s,type:c.webauthn.type,credential_response:c.webauthn.credential_response}}):{data:null,error:h}}catch(o){return Dt(o)?{data:null,error:o}:{data:null,error:new _a("Unexpected error in register",o)}}}}LH();const n5={url:ZW,storageKey:JW,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:QW,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function NI(n,t,e){return await e()}const oc={};class Mh{get jwks(){var t,e;return(e=(t=oc[this.storageKey])===null||t===void 0?void 0:t.jwks)!==null&&e!==void 0?e:{keys:[]}}set jwks(t){oc[this.storageKey]=Object.assign(Object.assign({},oc[this.storageKey]),{jwks:t})}get jwks_cached_at(){var t,e;return(e=(t=oc[this.storageKey])===null||t===void 0?void 0:t.cachedAt)!==null&&e!==void 0?e:Number.MIN_SAFE_INTEGER}set jwks_cached_at(t){oc[this.storageKey]=Object.assign(Object.assign({},oc[this.storageKey]),{cachedAt:t})}constructor(t){var e,s,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const i=Object.assign(Object.assign({},n5),t);if(this.storageKey=i.storageKey,this.instanceID=(e=Mh.nextInstanceID[this.storageKey])!==null&&e!==void 0?e:0,Mh.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!i.debug,typeof i.debug=="function"&&(this.logger=i.debug),this.instanceID>0&&Xn()){const o=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(o),this.logDebugMessages&&console.trace(o)}if(this.persistSession=i.persistSession,this.autoRefreshToken=i.autoRefreshToken,this.admin=new OH({url:i.url,headers:i.headers,fetch:i.fetch}),this.url=i.url,this.headers=i.headers,this.fetch=yR(i.fetch),this.lock=i.lock||NI,this.detectSessionInUrl=i.detectSessionInUrl,this.flowType=i.flowType,this.hasCustomAuthorizationHeader=i.hasCustomAuthorizationHeader,this.throwOnError=i.throwOnError,i.lock?this.lock=i.lock:this.persistSession&&Xn()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=FH:this.lock=NI,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new e5(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(i.storage?this.storage=i.storage:gR()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=EI(this.memoryStorage)),i.userStorage&&(this.userStorage=i.userStorage)):(this.memoryStorage={},this.storage=EI(this.memoryStorage)),Xn()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(o){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",o)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async o=>{this._debug("received broadcast notification from other tab or client",o),await this._notifyAllSubscribers(o.data.event,o.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(t){if(this.throwOnError&&t&&t.error)throw t.error;return t}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${fR}) ${new Date().toISOString()}`}_debug(...t){return this.logDebugMessages&&this.logger(this._logPrefix(),...t),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var t;try{let e={},s="none";if(Xn()&&(e=pH(window.location.href),this._isImplicitGrantCallback(e)?s="implicit":await this._isPKCECallback(e)&&(s="pkce")),Xn()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(e,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),iH(i)){const c=(t=i.details)===null||t===void 0?void 0:t.code;if(c==="identity_already_exists"||c==="identity_not_found"||c==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:o,redirectType:l}=r;return this._debug("#_initialize()","detected session in URL",o,"redirect type",l),await this._saveSession(o),setTimeout(async()=>{l==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",o):await this._notifyAllSubscribers("SIGNED_IN",o)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(e){return Dt(e)?this._returnResult({error:e}):this._returnResult({error:new _a("Unexpected error during initialization",e)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(t){var e,s,r;try{const i=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(e=t?.options)===null||e===void 0?void 0:e.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=t?.options)===null||r===void 0?void 0:r.captchaToken}},xform:Dr}),{data:o,error:l}=i;if(l||!o)return this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(Dt(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signUp(t){var e,s,r;try{let i;if("email"in t){const{email:d,password:p,options:m}=t;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await sc(this.storage,this.storageKey)),i=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:p,data:(e=m?.data)!==null&&e!==void 0?e:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:Dr})}else if("phone"in t){const{phone:d,password:p,options:m}=t;i=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:p,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:Dr})}else throw new Gp("You must provide either an email or phone number and a password");const{data:o,error:l}=i;if(l||!o)return await Kn(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signInWithPassword(t){try{let e;if("email"in t){const{email:i,password:o,options:l}=t;e=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:kI})}else if("phone"in t){const{phone:i,password:o,options:l}=t;e=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:kI})}else throw new Gp("You must provide either an email or phone number and a password");const{data:s,error:r}=e;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!s||!s.session||!s.user){const i=new nc;return this._returnResult({data:{user:null,session:null},error:i})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async signInWithOAuth(t){var e,s,r,i;return await this._handleProviderSignIn(t.provider,{redirectTo:(e=t.options)===null||e===void 0?void 0:e.redirectTo,scopes:(s=t.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=t.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=t.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(t){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(t))}async signInWithWeb3(t){const{chain:e}=t;switch(e){case"ethereum":return await this.signInWithEthereum(t);case"solana":return await this.signInWithSolana(t);default:throw new Error(`@supabase/auth-js: Unsupported chain "${e}"`)}}async signInWithEthereum(t){var e,s,r,i,o,l,c,h,d,p,m;let y,b;if("message"in t)y=t.message,b=t.signature;else{const{chain:x,wallet:w,statement:S,options:T}=t;let k;if(Xn())if(typeof w=="object")k=w;else{const D=window;if("ethereum"in D&&typeof D.ethereum=="object"&&"request"in D.ethereum&&typeof D.ethereum.request=="function")k=D.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!T?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=w}const $=new URL((e=T?.url)!==null&&e!==void 0?e:window.location.href),E=await k.request({method:"eth_requestAccounts"}).then(D=>D).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const N=xR(E[0]);let _=(s=T?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!_){const D=await k.request({method:"eth_chainId"});_=PH(D)}const R={domain:$.host,address:N,statement:S,uri:$.href,version:"1",chainId:_,nonce:(r=T?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(o=(i=T?.signInWithEthereum)===null||i===void 0?void 0:i.issuedAt)!==null&&o!==void 0?o:new Date,expirationTime:(l=T?.signInWithEthereum)===null||l===void 0?void 0:l.expirationTime,notBefore:(c=T?.signInWithEthereum)===null||c===void 0?void 0:c.notBefore,requestId:(h=T?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=T?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=BH(R),b=await k.request({method:"personal_sign",params:[zH(y),N]})}try{const{data:x,error:w}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((p=t.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=t.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:Dr});if(w)throw w;if(!x||!x.session||!x.user){const S=new nc;return this._returnResult({data:{user:null,session:null},error:S})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(Dt(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(t){var e,s,r,i,o,l,c,h,d,p,m,y;let b,x;if("message"in t)b=t.message,x=t.signature;else{const{chain:w,wallet:S,statement:T,options:k}=t;let $;if(Xn())if(typeof S=="object")$=S;else{const N=window;if("solana"in N&&typeof N.solana=="object"&&("signIn"in N.solana&&typeof N.solana.signIn=="function"||"signMessage"in N.solana&&typeof N.solana.signMessage=="function"))$=N.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof S!="object"||!k?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");$=S}const E=new URL((e=k?.url)!==null&&e!==void 0?e:window.location.href);if("signIn"in $&&$.signIn){const N=await $.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},k?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),T?{statement:T}:null));let _;if(Array.isArray(N)&&N[0]&&typeof N[0]=="object")_=N[0];else if(N&&typeof N=="object"&&"signedMessage"in N&&"signature"in N)_=N;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in _&&"signature"in _&&(typeof _.signedMessage=="string"||_.signedMessage instanceof Uint8Array)&&_.signature instanceof Uint8Array)b=typeof _.signedMessage=="string"?_.signedMessage:new TextDecoder().decode(_.signedMessage),x=_.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in $)||typeof $.signMessage!="function"||!("publicKey"in $)||typeof $!="object"||!$.publicKey||!("toBase58"in $.publicKey)||typeof $.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,$.publicKey.toBase58(),...T?["",T,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(r=(s=k?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=k?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${k.signInWithSolana.notBefore}`]:[],...!((o=k?.signInWithSolana)===null||o===void 0)&&o.expirationTime?[`Expiration Time: ${k.signInWithSolana.expirationTime}`]:[],...!((l=k?.signInWithSolana)===null||l===void 0)&&l.chainId?[`Chain ID: ${k.signInWithSolana.chainId}`]:[],...!((c=k?.signInWithSolana)===null||c===void 0)&&c.nonce?[`Nonce: ${k.signInWithSolana.nonce}`]:[],...!((h=k?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${k.signInWithSolana.requestId}`]:[],...!((p=(d=k?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||p===void 0)&&p.length?["Resources",...k.signInWithSolana.resources.map(_=>`- ${_}`)]:[]].join(`
`);const N=await $.signMessage(new TextEncoder().encode(b),"utf8");if(!N||!(N instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=N}}try{const{data:w,error:S}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:La(x)},!((m=t.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=t.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:Dr});if(S)throw S;if(!w||!w.session||!w.user){const T=new nc;return this._returnResult({data:{user:null,session:null},error:T})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:S})}catch(w){if(Dt(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(t){const e=await Ca(this.storage,`${this.storageKey}-code-verifier`),[s,r]=(e??"").split("/");try{if(!s&&this.flowType==="pkce")throw new oH;const{data:i,error:o}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:t,code_verifier:s},xform:Dr});if(await Kn(this.storage,`${this.storageKey}-code-verifier`),o)throw o;if(!i||!i.session||!i.user){const l=new nc;return this._returnResult({data:{user:null,session:null,redirectType:null},error:l})}return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",i.session)),this._returnResult({data:Object.assign(Object.assign({},i),{redirectType:r??null}),error:o})}catch(i){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(i))return this._returnResult({data:{user:null,session:null,redirectType:null},error:i});throw i}}async signInWithIdToken(t){try{const{options:e,provider:s,token:r,access_token:i,nonce:o}=t,l=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:r,access_token:i,nonce:o,gotrue_meta_security:{captcha_token:e?.captchaToken}},xform:Dr}),{data:c,error:h}=l;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!c||!c.session||!c.user){const d=new nc;return this._returnResult({data:{user:null,session:null},error:d})}return c.session&&(await this._saveSession(c.session),await this._notifyAllSubscribers("SIGNED_IN",c.session)),this._returnResult({data:c,error:h})}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async signInWithOtp(t){var e,s,r,i,o;try{if("email"in t){const{email:l,options:c}=t;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await sc(this.storage,this.storageKey));const{error:p}=await Vt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:l,data:(e=c?.data)!==null&&e!==void 0?e:{},create_user:(s=c?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:c?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in t){const{phone:l,options:c}=t,{data:h,error:d}=await Vt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:l,data:(r=c?.data)!==null&&r!==void 0?r:{},create_user:(i=c?.shouldCreateUser)!==null&&i!==void 0?i:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},channel:(o=c?.channel)!==null&&o!==void 0?o:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new Gp("You must provide either an email or phone number.")}catch(l){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(l))return this._returnResult({data:{user:null,session:null},error:l});throw l}}async verifyOtp(t){var e,s;try{let r,i;"options"in t&&(r=(e=t.options)===null||e===void 0?void 0:e.redirectTo,i=(s=t.options)===null||s===void 0?void 0:s.captchaToken);const{data:o,error:l}=await Vt(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},t),{gotrue_meta_security:{captcha_token:i}}),redirectTo:r,xform:Dr});if(l)throw l;if(!o)throw new Error("An error occurred on token verification.");const c=o.session,h=o.user;return c?.access_token&&(await this._saveSession(c),await this._notifyAllSubscribers(t.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(r){if(Dt(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(t){var e,s,r,i,o;try{let l=null,c=null;this.flowType==="pkce"&&([l,c]=await sc(this.storage,this.storageKey));const h=await Vt(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in t?{provider_id:t.providerId}:null),"domain"in t?{domain:t.domain}:null),{redirect_to:(s=(e=t.options)===null||e===void 0?void 0:e.redirectTo)!==null&&s!==void 0?s:void 0}),!((r=t?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:t.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:l,code_challenge_method:c}),headers:this.headers,xform:_H});return!((i=h.data)===null||i===void 0)&&i.url&&Xn()&&!(!((o=t.options)===null||o===void 0)&&o.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(l){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(l))return this._returnResult({data:null,error:l});throw l}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async t=>{const{data:{session:e},error:s}=t;if(s)throw s;if(!e)throw new qs;const{error:r}=await Vt(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:e.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(t){if(Dt(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async resend(t){try{const e=`${this.url}/resend`;if("email"in t){const{email:s,type:r,options:i}=t,{error:o}=await Vt(this.fetch,"POST",e,{headers:this.headers,body:{email:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}},redirectTo:i?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:o})}else if("phone"in t){const{phone:s,type:r,options:i}=t,{data:o,error:l}=await Vt(this.fetch,"POST",e,{headers:this.headers,body:{phone:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:o?.message_id},error:l})}throw new Gp("You must provide either an email or phone number and a type")}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async e=>e))}async _acquireLock(t,e){this._debug("#_acquireLock","begin",t);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await s,await e()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,t,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=e();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(t){this._debug("#_useSession","begin");try{const e=await this.__loadSession();return await t(e)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let t=null;const e=await Ca(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",e),e!==null&&(this._isValidSession(e)?t=e:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!t)return{data:{session:null},error:null};const s=t.expires_at?t.expires_at*1e3-Date.now()<Sx:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",t.expires_at),!s){if(this.userStorage){const o=await Ca(this.userStorage,this.storageKey+"-user");o?.user?t.user=o.user:t.user=kx()}if(this.storage.isServer&&t.user&&!t.user.__isUserNotAvailableProxy){const o={value:this.suppressGetSessionWarning};t.user=EH(t.user,o),o.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:t},error:null}}const{data:r,error:i}=await this._callRefreshToken(t.refresh_token);return i?this._returnResult({data:{session:null},error:i}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(t){if(t)return await this._getUser(t);await this.initializePromise;const e=await this._acquireLock(-1,async()=>await this._getUser());return e.data.user&&(this.suppressGetSessionWarning=!0),e}async _getUser(t){try{return t?await Vt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:t,xform:Eo}):await this._useSession(async e=>{var s,r,i;const{data:o,error:l}=e;if(l)throw l;return!(!((s=o.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new qs}:await Vt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(i=(r=o.session)===null||r===void 0?void 0:r.access_token)!==null&&i!==void 0?i:void 0,xform:Eo})})}catch(e){if(Dt(e))return rH(e)&&(await this._removeSession(),await Kn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:e});throw e}}async updateUser(t,e={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(t,e))}async _updateUser(t,e={}){try{return await this._useSession(async s=>{const{data:r,error:i}=s;if(i)throw i;if(!r.session)throw new qs;const o=r.session;let l=null,c=null;this.flowType==="pkce"&&t.email!=null&&([l,c]=await sc(this.storage,this.storageKey));const{data:h,error:d}=await Vt(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:e?.emailRedirectTo,body:Object.assign(Object.assign({},t),{code_challenge:l,code_challenge_method:c}),jwt:o.access_token,xform:Eo});if(d)throw d;return o.user=h.user,await this._saveSession(o),await this._notifyAllSubscribers("USER_UPDATED",o),this._returnResult({data:{user:o.user},error:null})})}catch(s){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(t))}async _setSession(t){try{if(!t.access_token||!t.refresh_token)throw new qs;const e=Date.now()/1e3;let s=e,r=!0,i=null;const{payload:o}=Tx(t.access_token);if(o.exp&&(s=o.exp,r=s<=e),r){const{data:l,error:c}=await this._callRefreshToken(t.refresh_token);if(c)return this._returnResult({data:{user:null,session:null},error:c});if(!l)return{data:{user:null,session:null},error:null};i=l}else{const{data:l,error:c}=await this._getUser(t.access_token);if(c)throw c;i={access_token:t.access_token,refresh_token:t.refresh_token,user:l.user,token_type:"bearer",expires_in:s-e,expires_at:s},await this._saveSession(i),await this._notifyAllSubscribers("SIGNED_IN",i)}return this._returnResult({data:{user:i.user,session:i},error:null})}catch(e){if(Dt(e))return this._returnResult({data:{session:null,user:null},error:e});throw e}}async refreshSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(t))}async _refreshSession(t){try{return await this._useSession(async e=>{var s;if(!t){const{data:o,error:l}=e;if(l)throw l;t=(s=o.session)!==null&&s!==void 0?s:void 0}if(!t?.refresh_token)throw new qs;const{data:r,error:i}=await this._callRefreshToken(t.refresh_token);return i?this._returnResult({data:{user:null,session:null},error:i}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async _getSessionFromURL(t,e){try{if(!Xn())throw new Wp("No browser detected.");if(t.error||t.error_description||t.error_code)throw new Wp(t.error_description||"Error in URL with unspecified error_description",{error:t.error||"unspecified_error",code:t.error_code||"unspecified_code"});switch(e){case"implicit":if(this.flowType==="pkce")throw new bI("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Wp("Not a valid implicit grant flow url.");break;default:}if(e==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!t.code)throw new bI("No code detected.");const{data:T,error:k}=await this._exchangeCodeForSession(t.code);if(k)throw k;const $=new URL(window.location.href);return $.searchParams.delete("code"),window.history.replaceState(window.history.state,"",$.toString()),{data:{session:T.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:r,access_token:i,refresh_token:o,expires_in:l,expires_at:c,token_type:h}=t;if(!i||!l||!o||!h)throw new Wp("No session defined in URL");const d=Math.round(Date.now()/1e3),p=parseInt(l);let m=d+p;c&&(m=parseInt(c));const y=m-d;y*1e3<=hc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${p}s`);const b=m-p;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(i);if(w)throw w;const S={provider_token:s,provider_refresh_token:r,access_token:i,expires_in:p,expires_at:m,refresh_token:o,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:S,redirectType:t.type},error:null})}catch(s){if(Dt(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(t){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),t):!!(t.access_token||t.error_description)}async _isPKCECallback(t){const e=await Ca(this.storage,`${this.storageKey}-code-verifier`);return!!(t.code&&e)}async signOut(t={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(t))}async _signOut({scope:t}={scope:"global"}){return await this._useSession(async e=>{var s;const{data:r,error:i}=e;if(i)return this._returnResult({error:i});const o=(s=r.session)===null||s===void 0?void 0:s.access_token;if(o){const{error:l}=await this.admin.signOut(o,t);if(l&&!(sH(l)&&(l.status===404||l.status===401||l.status===403)))return this._returnResult({error:l})}return t!=="others"&&(await this._removeSession(),await Kn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(t){const e=fH(),s={id:e,callback:t,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",e),this.stateChangeEmitters.delete(e)}};return this._debug("#onAuthStateChange()","registered callback with id",e),this.stateChangeEmitters.set(e,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(e)})))(),{data:{subscription:s}}}async _emitInitialSession(t){return await this._useSession(async e=>{var s,r;try{const{data:{session:i},error:o}=e;if(o)throw o;await((s=this.stateChangeEmitters.get(t))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",i)),this._debug("INITIAL_SESSION","callback id",t,"session",i)}catch(i){await((r=this.stateChangeEmitters.get(t))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",t,"error",i),console.error(i)}})}async resetPasswordForEmail(t,e={}){let s=null,r=null;this.flowType==="pkce"&&([s,r]=await sc(this.storage,this.storageKey,!0));try{return await Vt(this.fetch,"POST",`${this.url}/recover`,{body:{email:t,code_challenge:s,code_challenge_method:r,gotrue_meta_security:{captcha_token:e.captchaToken}},headers:this.headers,redirectTo:e.redirectTo})}catch(i){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(i))return this._returnResult({data:null,error:i});throw i}}async getUserIdentities(){var t;try{const{data:e,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(t=e.user.identities)!==null&&t!==void 0?t:[]},error:null})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async linkIdentity(t){return"token"in t?this.linkIdentityIdToken(t):this.linkIdentityOAuth(t)}async linkIdentityOAuth(t){var e;try{const{data:s,error:r}=await this._useSession(async i=>{var o,l,c,h,d;const{data:p,error:m}=i;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,t.provider,{redirectTo:(o=t.options)===null||o===void 0?void 0:o.redirectTo,scopes:(l=t.options)===null||l===void 0?void 0:l.scopes,queryParams:(c=t.options)===null||c===void 0?void 0:c.queryParams,skipBrowserRedirect:!0});return await Vt(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=p.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(r)throw r;return Xn()&&!(!((e=t.options)===null||e===void 0)&&e.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:t.provider,url:s?.url},error:null})}catch(s){if(Dt(s))return this._returnResult({data:{provider:t.provider,url:null},error:s});throw s}}async linkIdentityIdToken(t){return await this._useSession(async e=>{var s;try{const{error:r,data:{session:i}}=e;if(r)throw r;const{options:o,provider:l,token:c,access_token:h,nonce:d}=t,p=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=i?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:l,id_token:c,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:Dr}),{data:m,error:y}=p;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new nc}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(r){if(await Kn(this.storage,`${this.storageKey}-code-verifier`),Dt(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(t){try{return await this._useSession(async e=>{var s,r;const{data:i,error:o}=e;if(o)throw o;return await Vt(this.fetch,"DELETE",`${this.url}/user/identities/${t.identity_id}`,{headers:this.headers,jwt:(r=(s=i.session)===null||s===void 0?void 0:s.access_token)!==null&&r!==void 0?r:void 0})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _refreshAccessToken(t){const e=`#_refreshAccessToken(${t.substring(0,5)}...)`;this._debug(e,"begin");try{const s=Date.now();return await yH(async r=>(r>0&&await gH(200*Math.pow(2,r-1)),this._debug(e,"refreshing attempt",r),await Vt(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:t},headers:this.headers,xform:Dr})),(r,i)=>{const o=200*Math.pow(2,r);return i&&Cx(i)&&Date.now()+o-s<hc})}catch(s){if(this._debug(e,"error",s),Dt(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(e,"end")}}_isValidSession(t){return typeof t=="object"&&t!==null&&"access_token"in t&&"refresh_token"in t&&"expires_at"in t}async _handleProviderSignIn(t,e){const s=await this._getUrlForProvider(`${this.url}/authorize`,t,{redirectTo:e.redirectTo,scopes:e.scopes,queryParams:e.queryParams});return this._debug("#_handleProviderSignIn()","provider",t,"options",e,"url",s),Xn()&&!e.skipBrowserRedirect&&window.location.assign(s),{data:{provider:t,url:s},error:null}}async _recoverAndRefresh(){var t,e;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const r=await Ca(this.storage,this.storageKey);if(r&&this.userStorage){let o=await Ca(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!o&&(o={user:r.user},await dc(this.userStorage,this.storageKey+"-user",o)),r.user=(t=o?.user)!==null&&t!==void 0?t:kx()}else if(r&&!r.user&&!r.user){const o=await Ca(this.storage,this.storageKey+"-user");o&&o?.user?(r.user=o.user,await Kn(this.storage,this.storageKey+"-user"),await dc(this.storage,this.storageKey,r)):r.user=kx()}if(this._debug(s,"session from storage",r),!this._isValidSession(r)){this._debug(s,"session is not valid"),r!==null&&await this._removeSession();return}const i=((e=r.expires_at)!==null&&e!==void 0?e:1/0)*1e3-Date.now()<Sx;if(this._debug(s,`session has${i?"":" not"} expired with margin of ${Sx}s`),i){if(this.autoRefreshToken&&r.refresh_token){const{error:o}=await this._callRefreshToken(r.refresh_token);o&&(console.error(o),Cx(o)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",o),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:o,error:l}=await this._getUser(r.access_token);!l&&o?.user?(r.user=o.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(o){console.error("Error getting user data:",o),this._debug(s,"error getting user data, skipping SIGNED_IN notification",o)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(s,"error",r),console.error(r);return}finally{this._debug(s,"end")}}async _callRefreshToken(t){var e,s;if(!t)throw new qs;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${t.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new cg;const{data:i,error:o}=await this._refreshAccessToken(t);if(o)throw o;if(!i.session)throw new qs;await this._saveSession(i.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",i.session);const l={data:i.session,error:null};return this.refreshingDeferred.resolve(l),l}catch(i){if(this._debug(r,"error",i),Dt(i)){const o={data:null,error:i};return Cx(i)||await this._removeSession(),(e=this.refreshingDeferred)===null||e===void 0||e.resolve(o),o}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(i),i}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(t,e,s=!0){const r=`#_notifyAllSubscribers(${t})`;this._debug(r,"begin",e,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:t,session:e});const i=[],o=Array.from(this.stateChangeEmitters.values()).map(async l=>{try{await l.callback(t,e)}catch(c){i.push(c)}});if(await Promise.all(o),i.length>0){for(let l=0;l<i.length;l+=1)console.error(i[l]);throw i[0]}}finally{this._debug(r,"end")}}async _saveSession(t){this._debug("#_saveSession()",t),this.suppressGetSessionWarning=!0,await Kn(this.storage,`${this.storageKey}-code-verifier`);const e=Object.assign({},t),s=e.user&&e.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&e.user&&await dc(this.userStorage,this.storageKey+"-user",{user:e.user});const r=Object.assign({},e);delete r.user;const i=CI(r);await dc(this.storage,this.storageKey,i)}else{const r=CI(e);await dc(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await Kn(this.storage,this.storageKey),await Kn(this.storage,this.storageKey+"-code-verifier"),await Kn(this.storage,this.storageKey+"-user"),this.userStorage&&await Kn(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const t=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{t&&Xn()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",t)}catch(e){console.error("removing visibilitychange callback failed",e)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const t=setInterval(()=>this._autoRefreshTokenTick(),hc);this.autoRefreshTicker=t,t&&typeof t=="object"&&typeof t.unref=="function"?t.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(t),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const t=this.autoRefreshTicker;this.autoRefreshTicker=null,t&&clearInterval(t)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const t=Date.now();try{return await this._useSession(async e=>{const{data:{session:s}}=e;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((s.expires_at*1e3-t)/hc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${hc}ms, refresh threshold is ${Cv} ticks`),r<=Cv&&await this._callRefreshToken(s.refresh_token)})}catch(e){console.error("Auto refresh tick failed with error. This is likely a transient error.",e)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(t){if(t.isAcquireTimeout||t instanceof bR)this._debug("auto refresh token tick lock not available");else throw t}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!Xn()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(t){console.error("_handleVisibilityChange",t)}}async _onVisibilityChanged(t){const e=`#_onVisibilityChanged(${t})`;this._debug(e,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),t||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(e,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(t,e,s){const r=[`provider=${encodeURIComponent(e)}`];if(s?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&r.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[i,o]=await sc(this.storage,this.storageKey),l=new URLSearchParams({code_challenge:`${encodeURIComponent(i)}`,code_challenge_method:`${encodeURIComponent(o)}`});r.push(l.toString())}if(s?.queryParams){const i=new URLSearchParams(s.queryParams);r.push(i.toString())}return s?.skipBrowserRedirect&&r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${t}?${r.join("&")}`}async _unenroll(t){try{return await this._useSession(async e=>{var s;const{data:r,error:i}=e;return i?this._returnResult({data:null,error:i}):await Vt(this.fetch,"DELETE",`${this.url}/factors/${t.factorId}`,{headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _enroll(t){try{return await this._useSession(async e=>{var s,r;const{data:i,error:o}=e;if(o)return this._returnResult({data:null,error:o});const l=Object.assign({friendly_name:t.friendlyName,factor_type:t.factorType},t.factorType==="phone"?{phone:t.phone}:t.factorType==="totp"?{issuer:t.issuer}:{}),{data:c,error:h}=await Vt(this.fetch,"POST",`${this.url}/factors`,{body:l,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(t.factorType==="totp"&&c.type==="totp"&&(!((r=c?.totp)===null||r===void 0)&&r.qr_code)&&(c.totp.qr_code=`data:image/svg+xml;utf-8,${c.totp.qr_code}`),this._returnResult({data:c,error:null}))})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _verify(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async e=>{var s;const{data:r,error:i}=e;if(i)return this._returnResult({data:null,error:i});const o=Object.assign({challenge_id:t.challengeId},"webauthn"in t?{webauthn:Object.assign(Object.assign({},t.webauthn),{credential_response:t.webauthn.type==="create"?qH(t.webauthn.credential_response):KH(t.webauthn.credential_response)})}:{code:t.code}),{data:l,error:c}=await Vt(this.fetch,"POST",`${this.url}/factors/${t.factorId}/verify`,{body:o,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return c?this._returnResult({data:null,error:c}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+l.expires_in},l)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",l),this._returnResult({data:l,error:c}))})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}})}async _challenge(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async e=>{var s;const{data:r,error:i}=e;if(i)return this._returnResult({data:null,error:i});const o=await Vt(this.fetch,"POST",`${this.url}/factors/${t.factorId}/challenge`,{body:t,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});if(o.error)return o;const{data:l}=o;if(l.type!=="webauthn")return{data:l,error:null};switch(l.webauthn.type){case"create":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:WH(l.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:HH(l.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}})}async _challengeAndVerify(t){const{data:e,error:s}=await this._challenge({factorId:t.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:t.factorId,challengeId:e.id,code:t.code})}async _listFactors(){var t;const{data:{user:e},error:s}=await this.getUser();if(s)return{data:null,error:s};const r={all:[],phone:[],totp:[],webauthn:[]};for(const i of(t=e?.factors)!==null&&t!==void 0?t:[])r.all.push(i),i.status==="verified"&&r[i.factor_type].push(i);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var t,e;const{data:{session:s},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:i}=Tx(s.access_token);let o=null;i.aal&&(o=i.aal);let l=o;((e=(t=s.user.factors)===null||t===void 0?void 0:t.filter(d=>d.status==="verified"))!==null&&e!==void 0?e:[]).length>0&&(l="aal2");const h=i.amr||[];return{data:{currentLevel:o,nextLevel:l,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(t){try{return await this._useSession(async e=>{const{data:{session:s},error:r}=e;return r?this._returnResult({data:null,error:r}):s?await Vt(this.fetch,"GET",`${this.url}/oauth/authorizations/${t}`,{headers:this.headers,jwt:s.access_token,xform:i=>({data:i,error:null})}):this._returnResult({data:null,error:new qs})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _approveAuthorization(t,e){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new qs});const o=await Vt(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Xn()&&!e?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(Dt(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(t,e){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new qs});const o=await Vt(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Xn()&&!e?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(Dt(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async t=>{const{data:{session:e},error:s}=t;return s?this._returnResult({data:null,error:s}):e?await Vt(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:e.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new qs})})}catch(t){if(Dt(t))return this._returnResult({data:null,error:t});throw t}}async _revokeOAuthGrant(t){try{return await this._useSession(async e=>{const{data:{session:s},error:r}=e;return r?this._returnResult({data:null,error:r}):s?(await Vt(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:t.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new qs})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async fetchJwk(t,e={keys:[]}){let s=e.keys.find(l=>l.kid===t);if(s)return s;const r=Date.now();if(s=this.jwks.keys.find(l=>l.kid===t),s&&this.jwks_cached_at+eH>r)return s;const{data:i,error:o}=await Vt(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(o)throw o;return!i.keys||i.keys.length===0||(this.jwks=i,this.jwks_cached_at=r,s=i.keys.find(l=>l.kid===t),!s)?null:s}async getClaims(t,e={}){try{let s=t;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:r,payload:i,signature:o,raw:{header:l,payload:c}}=Tx(s);e?.allowExpired||TH(i.exp);const h=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,e?.keys?{keys:e.keys}:e?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:i,header:r,signature:o},error:null}}const d=kH(r.alg),p=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,p,o,hH(`${l}.${c}`)))throw new $v("Invalid JWT signature");return{data:{claims:i,header:r,signature:o},error:null}}catch(s){if(Dt(s))return this._returnResult({data:null,error:s});throw s}}}Mh.nextInstanceID={};const s5=Mh,r5="2.89.0";let lh="";typeof Deno<"u"?lh="deno":typeof document<"u"?lh="web":typeof navigator<"u"&&navigator.product==="ReactNative"?lh="react-native":lh="node";const i5={"X-Client-Info":`supabase-js-${lh}/${r5}`},o5={headers:i5},a5={schema:"public"},l5={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},c5={};function Fh(n){"@babel/helpers - typeof";return Fh=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Fh(n)}function u5(n,t){if(Fh(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var s=e.call(n,t);if(Fh(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function h5(n){var t=u5(n,"string");return Fh(t)=="symbol"?t:t+""}function d5(n,t,e){return(t=h5(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function AI(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);t&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),e.push.apply(e,s)}return e}function Je(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?AI(Object(e),!0).forEach(function(s){d5(n,s,e[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):AI(Object(e)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(e,s))})}return n}const f5=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),p5=()=>Headers,m5=(n,t,e)=>{const s=f5(e),r=p5();return async(i,o)=>{var l;const c=(l=await t())!==null&&l!==void 0?l:n;let h=new r(o?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${c}`),s(i,Je(Je({},o),{},{headers:h}))}};function g5(n){return n.endsWith("/")?n:n+"/"}function y5(n,t){var e,s;const{db:r,auth:i,realtime:o,global:l}=n,{db:c,auth:h,realtime:d,global:p}=t,m={db:Je(Je({},c),r),auth:Je(Je({},h),i),realtime:Je(Je({},d),o),storage:{},global:Je(Je(Je({},p),l),{},{headers:Je(Je({},(e=p?.headers)!==null&&e!==void 0?e:{}),(s=l?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function b5(n){const t=n?.trim();if(!t)throw new Error("supabaseUrl is required.");if(!t.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(g5(t))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var x5=class extends s5{constructor(n){super(n)}},v5=class{constructor(n,t,e){var s,r;this.supabaseUrl=n,this.supabaseKey=t;const i=b5(n);if(!t)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",i),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",i),this.storageUrl=new URL("storage/v1",i),this.functionsUrl=new URL("functions/v1",i);const o=`sb-${i.hostname.split(".")[0]}-auth-token`,l={db:a5,realtime:c5,auth:Je(Je({},l5),{},{storageKey:o}),global:o5},c=y5(e??{},l);if(this.storageKey=(s=c.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(r=c.global.headers)!==null&&r!==void 0?r:{},c.accessToken)this.accessToken=c.accessToken,this.auth=new Proxy({},{get:(d,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=c.auth)!==null&&h!==void 0?h:{},this.headers,c.global.fetch)}this.fetch=m5(t,this._getAccessToken.bind(this),c.global.fetch),this.realtime=this._initRealtimeClient(Je({headers:this.headers,accessToken:this._getAccessToken.bind(this)},c.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new QG(new URL("rest/v1",i).href,{headers:this.headers,schema:c.db.schema,fetch:this.fetch}),this.storage=new YW(this.storageUrl.href,this.headers,this.fetch,e?.storage),c.accessToken||this._listenForAuthEvents()}get functions(){return new KG(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,t={},e={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,t,e)}channel(n,t={config:{}}){return this.realtime.channel(n,t)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,t,e;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(t=(e=s.session)===null||e===void 0?void 0:e.access_token)!==null&&t!==void 0?t:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:t,detectSessionInUrl:e,storage:s,userStorage:r,storageKey:i,flowType:o,lock:l,debug:c,throwOnError:h},d,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new x5({url:this.authUrl.href,headers:Je(Je({},m),d),storageKey:i,autoRefreshToken:n,persistSession:t,detectSessionInUrl:e,storage:s,userStorage:r,flowType:o,lock:l,debug:c,throwOnError:h,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new gW(this.realtimeUrl.href,Je(Je({},n),{},{params:Je(Je({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,t)=>{this._handleTokenChanged(n,"CLIENT",t?.access_token)})}_handleTokenChanged(n,t,e){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==e?(this.changedAccessToken=e,this.realtime.setAuth(e)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),t=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const w5=(n,t,e)=>new v5(n,t,e);function S5(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const t=n.match(/^v(\d+)\./);return t?parseInt(t[1],10)<=18:!1}S5()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const C5="https://brrjoheinakfhohesogc.supabase.co",T5="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",k5={getItem:n=>typeof chrome<"u"&&chrome.storage&&chrome.storage.local?new Promise(t=>{chrome.storage.local.get([n],e=>t(e[n]||null))}):localStorage.getItem(n),setItem:(n,t)=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.set({[n]:t}):localStorage.setItem(n,t)},removeItem:n=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.remove([n]):localStorage.removeItem(n)}},ms=w5(C5,T5,{auth:{storage:k5,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!1}}),wR=St.createContext(),$5=({children:n})=>{const[t,e]=St.useState(null),[s,r]=St.useState(null),[i,o]=St.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[l,c]=St.useState(!0);St.useEffect(()=>{p(),ms.auth.getSession().then(({data:{session:y}})=>{e(y?.user||null),y?.user?h(y.user.id,y.user.email):c(!1)});const{data:{subscription:m}}=ms.auth.onAuthStateChange((y,b)=>{e(b?.user||null),b?.user?h(b.user.id,b.user.email):(r(null),c(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await ms.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:S}=await ms.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();S||(b=w)}b&&b.subscription_tier==="pro"&&b.pro_expires_at&&new Date(b.pro_expires_at)<new Date&&(console.log("Pro status expired. Downgrading to free tier..."),await ms.from("profiles").update({subscription_tier:"free"}).eq("id",m),b.subscription_tier="free"),r(b)}catch(b){console.error("Profile fetch error:",b)}finally{c(!1)}},d=()=>{t&&h(t.id,t.email)},p=async()=>{try{const{data:m,error:y}=await ms.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&o(m)}catch(m){console.error("Neural state sync error:",m)}};return it.jsx(wR.Provider,{value:{user:t,profile:s,neuralState:i,loading:l,refreshProfile:d,fetchNeuralState:p,setUser:e,setProfile:r,setNeuralState:o},children:n})},E5=()=>St.useContext(wR),Ev=(n,t)=>{if(!n||n.length<t)return[];const e=[];for(let s=t-1;s<n.length;s++){const r=n.slice(s-t+1,s+1).reduce((i,o)=>i+o,0);e.push(r/t)}return e},wh=(n,t)=>{if(n.length<t)return[];const e=2/(t+1);let s=[n[0]];for(let r=1;r<n.length;r++)s.push(n[r]*e+s[r-1]*(1-e));return s},I5=(n,t=14)=>{if(n.length<t+1)return[];let e=0,s=0;for(let c=1;c<=t;c++){const h=n[c]-n[c-1];h>=0?e+=h:s+=Math.abs(h)}let r=e/t,i=s/t;const o=[];let l=i===0?100:r/i;o.push(100-100/(1+l));for(let c=t+1;c<n.length;c++){const h=n[c]-n[c-1];h>=0?(r=(r*(t-1)+h)/t,i=(i*(t-1)+0)/t):(r=(r*(t-1)+0)/t,i=(i*(t-1)+Math.abs(h))/t),l=i===0?100:r/i,o.push(100-100/(1+l))}return o},N5=(n,t=20,e=2)=>{if(n.length<t)return[];const s=[],r=[],i=Ev(n,t);for(let o=0;o<i.length;o++){const l=n.slice(o,o+t),c=i[o],d=l.map(m=>Math.pow(m-c,2)).reduce((m,y)=>m+y,0)/t,p=Math.sqrt(d);r.push(c+e*p),s.push(c-e*p)}return{basis:i,upper:r,lower:s}},A5=(n,t=12,e=26,s=9)=>{const r=wh(n,t),i=wh(n,e),o=[],l=Math.min(r.length,i.length);for(let d=0;d<l;d++)o.push(r[d]-i[d]);const c=wh(o,s),h=[];for(let d=0;d<Math.min(o.length,c.length);d++)h.push(o[d]-c[d]);return{macdLine:o,signalLine:c,histogram:h}},_5=(n,t=[],e=[],s=[])=>{if(n.length<50)return[{name:"Insufficient Data",sentiment:"Neutral",confidence:0}];const r=n[n.length-1],i=n[n.length-2],o=s.length>0?s[s.length-1]:i,l=t.length>0?t[t.length-1]:Math.max(r,o),c=e.length>0?e[e.length-1]:Math.min(r,o),h=Math.abs(r-o),d=l-c||1e-4,p=(r+o)/2,m=r>o,y=r<o;let b=[];h/d<.1&&(p>l-d*.2?b.push({name:"Dragonfly Doji",sentiment:"Bullish",icon:"zap"}):p<c+d*.2?b.push({name:"Gravestone Doji",sentiment:"Bearish",icon:"trending-down"}):b.push({name:"Doji Star",sentiment:"Neutral",icon:"minus"}));const x=Math.min(o,r)-c,w=l-Math.max(o,r);if(x>h*2&&w<h*.5&&b.push({name:"Hammer",sentiment:"Bullish",icon:"thumbs-up"}),w>h*2&&x<h*.5&&b.push({name:m?"Inverted Hammer":"Shooting Star",sentiment:m?"Bullish":"Bearish",icon:m?"zap":"trending-down"}),s.length>1){const A=s[s.length-2],z=n[n.length-2],q=z<A,W=z>A;m&&q&&r>A&&o<z?b.push({name:"Bullish Engulfing",sentiment:"Bullish",icon:"zap"}):y&&W&&r<A&&o>z&&b.push({name:"Bearish Engulfing",sentiment:"Bearish",icon:"trending-down"})}if(s.length>1){const A=s[s.length-2],z=n[n.length-2],q=t[t.length-2]||Math.max(A,z),W=e[e.length-2]||Math.min(A,z);l<q&&c>W&&b.push({name:"Harami (Inside Bar)",sentiment:m?"Bullish":"Bearish",icon:"activity"})}h/d>.9&&b.push({name:m?"Bullish Marubozu":"Bearish Marubozu",sentiment:m?"Bullish":"Bearish",icon:"zap"});const S=Ev(n.slice(-20),10),T=Ev(n.slice(-50),40),k=S[S.length-1],$=T[T.length-1],E=k>$,{upper:N,lower:_}=N5(n,20),R=N[N.length-1],D=_[_.length-1];return(R-D)/r<.05&&b.push({name:"Volatility Squeeze",sentiment:"Neutral",icon:"activity"}),b.length===0&&(E?b.push({name:"Bullish Continuation",sentiment:"Bullish",icon:"trending-up"}):b.push({name:"Bearish Continuation",sentiment:"Bearish",icon:"trending-down"})),b},R5=(n,t,e,s=14)=>{let r=[];const i=Array.isArray(n)&&Array.isArray(t)&&Array.isArray(e),o=i||Array.isArray(n)?n.length:0;if(o<s+1)return[];for(let d=1;d<o;d++){let p;if(i){const m=n[d],y=t[d],b=e[d-1];p=Math.max(m-y,Math.abs(m-b),Math.abs(y-b))}else{const m=n[d],y=n[d-1],b=Math.abs(m-y);p=Math.max(b,m*.0075)}r.push(p)}const l=[];let c=r.slice(0,s).reduce((d,p)=>d+p,0)/s;l.push(c);for(let d=s;d<r.length;d++){const p=(l[l.length-1]*(s-1)+r[d])/s;l.push(p)}return[...new Array(o-l.length).fill(l[0]),...l]},D5=(n,t,e)=>{const s=Array.isArray(n)?n:[];if(s.length<20)return{support:Math.min(...s),resistance:Math.max(...s),strength:{s:1,r:1}};const r=Array.isArray(t)&&Array.isArray(e)&&t.length===s.length,i=[],o=5;for(let p=o;p<s.length-o;p++)if(r){const m=t.slice(p-o,p+o+1),y=t[p];m.every(w=>w<=y)&&i.push({price:y,type:"Resistance"});const b=e.slice(p-o,p+o+1),x=e[p];b.every(w=>w>=x)&&i.push({price:x,type:"Support"})}else{const m=s.slice(p-o,p+o+1),y=s[p],b=m.every(w=>w<=y),x=m.every(w=>w>=y);b&&i.push({price:y,type:"Resistance"}),x&&i.push({price:y,type:"Support"})}const l=s[s.length-1],c=(p,m)=>{const y=i.filter(S=>S.type===p&&(p==="Support"?S.price<m:S.price>m));if(y.length===0)return{price:p==="Support"?Math.min(...s):Math.max(...s),strength:1};const x=y.sort((S,T)=>Math.abs(S.price-m)-Math.abs(T.price-m))[0].price,w=i.filter(S=>S.type===p&&Math.abs(S.price-x)/x<.005).length;return{price:x,strength:Math.min(5,w)}},h=c("Support",l),d=c("Resistance",l);return{support:h.price,resistance:d.price,strength:{s:h.strength,r:d.strength}}},O5=(n,t,e,s)=>{if(!s||s.length===0||s.length!==e.length)return e;let r=0,i=0;const o=[];for(let l=0;l<e.length;l++){const c=(n[l]+t[l]+e[l])/3;r+=c*s[l],i+=s[l],o.push(i===0?c:r/i)}return o},M5=n=>{if(!n||n.length<50)return .5;const t=wh(n.slice(-20),10),e=wh(n.slice(-50),40),s=t[t.length-1],r=e[e.length-1];let i=.5;s>r&&(i=.75),s<r&&(i=.25);const o=n[n.length-1];return o>s&&s>r&&(i=.9),o<s&&s<r&&(i=.1),i};const F5=1e-7,L5=1e-4;class SR{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Jw{refCount(t){return _s("refCount")}incRef(t){return _s("incRef")}timerAvailable(){return!0}time(t){return _s("time")}read(t){return _s("read")}readSync(t){return _s("readSync")}readToGPU(t,e){return _s("readToGPU")}numDataIds(){return _s("numDataIds")}disposeData(t,e){return _s("disposeData")}write(t,e,s){return _s("write")}move(t,e,s,r,i){return _s("move")}createTensorFromGPUData(t,e,s){return _s("createTensorFromGPUData")}memory(){return _s("memory")}floatPrecision(){return _s("floatPrecision")}epsilon(){return this.floatPrecision()===32?F5:L5}dispose(){return _s("dispose")}}function _s(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function P5(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,fc(n,t,e)}function Wa(n,t,e){return Math.max(n,Math.min(t,e))}function Qw(n){return n%2===0?n:n+1}function fc(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function z5(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function L(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function t1(n,t,e=""){L(we(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function e1(n){L(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ft(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function we(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function _c(n){return n%1===0}function Iv(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Tc(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function _I(n,t=r=>0,e,s){return new Promise((r,i)=>{let o=0;const l=()=>{if(n()){r();return}o++;const c=t(o);if(e!=null&&o>=e){i();return}s!=null?s(l,c):setTimeout(l,c)};l()})}function CR(n,t){let e=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[s]=t/e,r}function te(n,t){const e=t.length;return n=n==null?t.map((s,r)=>r):[].concat(n),L(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),L(n.every(s=>_c(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function Go(n,t){const e=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:te(t,n).sort();let o=0;for(let l=0;l<n.length;++l){if(i!=null){if(i[o]===l&&n[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${n[l]}' is not 1`);(i[o]==null||i[o]>l)&&n[l]===1&&(e.push(n[l]),s.push(l)),i[o]<=l&&o++}n[l]!==1&&(e.push(n[l]),s.push(l))}return{newShape:e,keptDims:s}}function Zn(n,t){return tn(n,t)}function tn(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function B5(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function V5(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function TR(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function Em(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function U5(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function ed(n){return typeof n=="string"||n instanceof String}function j5(n){return typeof n=="boolean"}function Nv(n){return typeof n=="number"}function Wc(n){return Array.isArray(n)?Wc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Nv(n)?"float32":ed(n)?"string":j5(n)?"bool":"float32"}function Av(n){return!!(n&&n.constructor&&n.call&&n.apply)}function _v(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function Ot(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function kR(n,t,e,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=e[n+o]}else{const i=t[0],o=t.slice(1),l=o.reduce((c,h)=>c*h)*(s?2:1);for(let c=0;c<i;c++)r[c]=kR(n+c*l,o,e,s)}return r}function Vr(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((r,i)=>r*i)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return kR(0,n,t,e)}function G5(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function n1(n,t){const e=Jn(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function Jn(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function $R(n,t){const e=n.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return Vr(n,new Float32Array(e));if(t==="int32")return Vr(n,new Int32Array(e));if(t==="bool")return Vr(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Xi(n){n.forEach(t=>{L(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function li(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function Hc(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function s1(n){return n&&n.then&&typeof n.then=="function"}const RI="tfjsflags";class W5{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=H5,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(ct().getBool("IS_TEST")||ct().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];ct().getBool("IS_TEST")||ct().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(s1(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);RI in t&&t[RI].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=K5(r,i)})}}function H5(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(q5(t,s[0],s[1]),s.join("="))),t}function q5(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function K5(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function ct(){return ER}let ER=null;function X5(n){ER=n}let Ex;function IR(){if(Ex==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Ex=n}return Ex}function Y5(){const n=IR();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function r1(n,t){const e=Y5();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const ug="Abs",nd="Acos",sd="Acosh",qc="Add",i1="AddN",o1="All",a1="Any",hg="ArgMax",dg="ArgMin",rd="Asin",id="Asinh",od="Atan",ad="Atanh",ld="Atan2",fg="AvgPool",l1="AvgPoolGrad",pg="AvgPool3D",c1="AvgPool3DGrad",mg="BatchMatMul",gg="BatchToSpaceND",u1="Bincount",h1="BitwiseAnd",Z5="BroadcastTo",NR="BroadcastArgs",cd="Cast",ud="Ceil",hd="ClipByValue",d1="Complex",yg="ComplexAbs",bg="Concat",xg="Conv2D",f1="Conv2DBackpropFilter",vg="Conv2DBackpropInput",wg="Conv3D",p1="Conv3DBackpropFilterV2",m1="Conv3DBackpropInputV2",dd="Cos",fd="Cosh",g1="Cumprod",Sg="Cumsum",y1="CropAndResize",b1="DenseBincount",x1="DepthToSpace",Cg="DepthwiseConv2dNative",v1="DepthwiseConv2dNativeBackpropFilter",w1="DepthwiseConv2dNativeBackpropInput",AR="Diag",Tg="Dilation2D",Rv="Dilation2DBackpropInput",Dv="Dilation2DBackpropFilter",J5="Draw",pd="RealDiv",S1="Einsum",md="Elu",C1="EluGrad",gd="Erf",kg="Equal",yd="Exp",$g="ExpandDims",bd="Expm1",T1="FFT",k1="Fill",$1="FlipLeftRight",xd="Floor",vd="FloorDiv",Eg="FusedBatchNorm",Ig="GatherV2",_R="GatherNd",Ng="Greater",wd="GreaterEqual",Sd="Identity",E1="IFFT",I1="Imag",Cd="IsFinite",Td="IsInf",kd="IsNan",Ag="LeakyRelu",_g="Less",Rg="LessEqual",RR="LinSpace",$d="Log",Ed="Log1p",Dg="LogicalAnd",Og="LogicalNot",Mg="LogicalOr",Q5="LogSoftmax",Fg="LRN",N1="LRNGrad",Lg="Max",Id="Maximum",Pg="MaxPool",A1="MaxPoolGrad",zg="MaxPool3D",_1="MaxPool3DGrad",DR="MaxPoolWithArgmax",Bg="Mean",Vg="Min",Nd="Minimum",Ug="MirrorPad",Ad="Mod",OR="Multinomial",_d="Multiply",jg="Neg",Gg="NotEqual",R1="NonMaxSuppressionV3",D1="NonMaxSuppressionV4",O1="NonMaxSuppressionV5",Wg="OnesLike",Hg="OneHot",qg="Pack",Kg="PadV2",Rd="Pow",Xg="Prelu",Yg="Prod",MR="RaggedGather",FR="RaggedRange",LR="RaggedTensorToTensor",M1="Range",F1="Real",Dd="Reciprocal",Od="Relu",Zg="Reshape",Jg="ResizeNearestNeighbor",L1="ResizeNearestNeighborGrad",Qg="ResizeBilinear",P1="ResizeBilinearGrad",Md="Relu6",t0="Reverse",Fd="Round",Ld="Rsqrt",PR="ScatterNd",zR="TensorScatterUpdate",BR="SearchSorted",e0="Select",Pd="Selu",n0="Slice",zd="Sin",Bd="Sinh",Vd="Sign",Ud="Sigmoid",jd="Softplus",Gd="Sqrt",s0="Sum",r0="SpaceToBatchND",i0="SplitV",o0="Softmax",VR="SparseFillEmptyRows",UR="SparseReshape",jR="SparseSegmentMean",GR="SparseSegmentSum",WR="SparseToDense",Wd="SquaredDifference",z1="Square",B1="StaticRegexReplace",V1="StridedSlice",HR="StringNGrams",qR="StringSplit",KR="StringToHashBucketFast",Hd="Sub",qd="Tan",Kd="Tanh",Xd="Tile",U1="TopK",j1="Transform",kc="Transpose",G1="Unique",a0="Unpack",l0="UnsortedSegmentSum",c0="ZerosLike",Yd="Step",t6="FromPixels",W1="RotateWithOffset",Im="_FusedMatMul",Nm="FusedConv2D",XR="FusedDepthwiseConv2D";function Ys(...n){ct().getBool("IS_TEST")||ct().getBool("PROD")||console.warn(...n)}function e6(...n){ct().getBool("IS_TEST")||ct().getBool("PROD")||console.log(...n)}const Am=r1("kernelRegistry",()=>new Map),Ov=r1("gradRegistry",()=>new Map);function DI(n,t){const e=ZR(n,t);return Am.get(e)}function OI(n){return Ov.get(n)}function MI(n){const t=Am.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[l]=i.split("_");l===n&&e.push(o)}return e}function YR(n){const{kernelName:t,backendName:e}=n,s=ZR(t,e);Am.has(s)&&Ys(`The kernel '${t}' for backend '${e}' is already registered`),Am.set(s,n)}function n6(n){const{kernelName:t}=n;Ov.has(t)&&ct().getBool("DEBUG")&&Ys(`Overriding the gradient for '${t}'`),Ov.set(t,n)}function ZR(n,t){return`${t}_${n}`}function JR(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Ix,FI;function s6(){if(FI)return Ix;FI=1,Ix=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(O,A,z){this.low=O|0,this.high=A|0,this.unsigned=!!z}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(O){return(O&&O.__isLong__)===!0}t.isLong=e;var s={},r={};function i(O,A){var z,q,W;return A?(O>>>=0,(W=0<=O&&O<256)&&(q=r[O],q)?q:(z=l(O,(O|0)<0?-1:0,!0),W&&(r[O]=z),z)):(O|=0,(W=-128<=O&&O<128)&&(q=s[O],q)?q:(z=l(O,O<0?-1:0,!1),W&&(s[O]=z),z))}t.fromInt=i;function o(O,A){if(isNaN(O))return A?T:S;if(A){if(O<0)return T;if(O>=b)return _}else{if(O<=-x)return R;if(O+1>=x)return N}return O<0?o(-O,A).neg():l(O%y|0,O/y|0,A)}t.fromNumber=o;function l(O,A,z){return new t(O,A,z)}t.fromBits=l;var c=Math.pow;function h(O,A,z){if(O.length===0)throw Error("empty string");if(O==="NaN"||O==="Infinity"||O==="+Infinity"||O==="-Infinity")return S;if(typeof A=="number"?(z=A,A=!1):A=!!A,z=z||10,z<2||36<z)throw RangeError("radix");var q;if((q=O.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return h(O.substring(1),A,z).neg();for(var W=o(c(z,8)),X=S,P=0;P<O.length;P+=8){var V=Math.min(8,O.length-P),G=parseInt(O.substring(P,P+V),z);if(V<8){var tt=o(c(z,V));X=X.mul(tt).add(o(G))}else X=X.mul(W),X=X.add(o(G))}return X.unsigned=A,X}t.fromString=h;function d(O,A){return typeof O=="number"?o(O,A):typeof O=="string"?h(O,A):l(O.low,O.high,typeof A=="boolean"?A:O.unsigned)}t.fromValue=d;var p=65536,m=1<<24,y=p*p,b=y*y,x=b/2,w=i(m),S=i(0);t.ZERO=S;var T=i(0,!0);t.UZERO=T;var k=i(1);t.ONE=k;var $=i(1,!0);t.UONE=$;var E=i(-1);t.NEG_ONE=E;var N=l(-1,2147483647,!1);t.MAX_VALUE=N;var _=l(-1,-1,!0);t.MAX_UNSIGNED_VALUE=_;var R=l(0,-2147483648,!1);t.MIN_VALUE=R;var D=t.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},D.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var z=o(A),q=this.div(z),W=q.mul(z).sub(this);return q.toString(A)+W.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var X=o(c(A,6),this.unsigned),P=this,V="";;){var G=P.div(X),tt=P.sub(G.mul(X)).toInt()>>>0,Z=tt.toString(A);if(P=G,P.isZero())return Z+V;for(;Z.length<6;)Z="0"+Z;V=""+Z+V}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,z=31;z>0&&(A&1<<z)==0;z--);return this.high!=0?z+33:z+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(A){return e(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},D.eq=D.equals,D.notEquals=function(A){return!this.eq(A)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(A){return this.comp(A)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(A){return this.comp(A)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(A){return this.comp(A)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(A){return this.comp(A)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(A){if(e(A)||(A=d(A)),this.eq(A))return 0;var z=this.isNegative(),q=A.isNegative();return z&&!q?-1:!z&&q?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(k)},D.neg=D.negate,D.add=function(A){e(A)||(A=d(A));var z=this.high>>>16,q=this.high&65535,W=this.low>>>16,X=this.low&65535,P=A.high>>>16,V=A.high&65535,G=A.low>>>16,tt=A.low&65535,Z=0,F=0,B=0,Q=0;return Q+=X+tt,B+=Q>>>16,Q&=65535,B+=W+G,F+=B>>>16,B&=65535,F+=q+V,Z+=F>>>16,F&=65535,Z+=z+P,Z&=65535,l(B<<16|Q,Z<<16|F,this.unsigned)},D.subtract=function(A){return e(A)||(A=d(A)),this.add(A.neg())},D.sub=D.subtract,D.multiply=function(A){if(this.isZero())return S;if(e(A)||(A=d(A)),n){var z=n.mul(this.low,this.high,A.low,A.high);return l(z,n.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(R))return A.isOdd()?R:S;if(A.eq(R))return this.isOdd()?R:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return o(this.toNumber()*A.toNumber(),this.unsigned);var q=this.high>>>16,W=this.high&65535,X=this.low>>>16,P=this.low&65535,V=A.high>>>16,G=A.high&65535,tt=A.low>>>16,Z=A.low&65535,F=0,B=0,Q=0,lt=0;return lt+=P*Z,Q+=lt>>>16,lt&=65535,Q+=X*Z,B+=Q>>>16,Q&=65535,Q+=P*tt,B+=Q>>>16,Q&=65535,B+=W*Z,F+=B>>>16,B&=65535,B+=X*tt,F+=B>>>16,B&=65535,B+=P*G,F+=B>>>16,B&=65535,F+=q*Z+W*tt+X*G+P*V,F&=65535,l(Q<<16|lt,F<<16|B,this.unsigned)},D.mul=D.multiply,D.divide=function(A){if(e(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var z=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return l(z,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:S;var q,W,X;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return T;if(A.gt(this.shru(1)))return $;X=T}else{if(this.eq(R)){if(A.eq(k)||A.eq(E))return R;if(A.eq(R))return k;var P=this.shr(1);return q=P.div(A).shl(1),q.eq(S)?A.isNegative()?k:E:(W=this.sub(A.mul(q)),X=q.add(W.div(A)),X)}else if(A.eq(R))return this.unsigned?T:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();X=S}for(W=this;W.gte(A);){q=Math.max(1,Math.floor(W.toNumber()/A.toNumber()));for(var V=Math.ceil(Math.log(q)/Math.LN2),G=V<=48?1:c(2,V-48),tt=o(q),Z=tt.mul(A);Z.isNegative()||Z.gt(W);)q-=G,tt=o(q,this.unsigned),Z=tt.mul(A);tt.isZero()&&(tt=k),X=X.add(tt),W=W.sub(Z)}return X},D.div=D.divide,D.modulo=function(A){if(e(A)||(A=d(A)),n){var z=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return l(z,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return l(~this.low,~this.high,this.unsigned)},D.and=function(A){return e(A)||(A=d(A)),l(this.low&A.low,this.high&A.high,this.unsigned)},D.or=function(A){return e(A)||(A=d(A)),l(this.low|A.low,this.high|A.high,this.unsigned)},D.xor=function(A){return e(A)||(A=d(A)),l(this.low^A.low,this.high^A.high,this.unsigned)},D.shiftLeft=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):l(0,this.low<<A-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):l(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(A){if(e(A)&&(A=A.toInt()),A&=63,A===0)return this;var z=this.high;if(A<32){var q=this.low;return l(q>>>A|z<<32-A,z>>>A,this.unsigned)}else return A===32?l(z,0,this.unsigned):l(z>>>A-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},D.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var A=this.high,z=this.low;return[z&255,z>>>8&255,z>>>16&255,z>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},D.toBytesBE=function(){var A=this.high,z=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,z>>>24,z>>>16&255,z>>>8&255,z&255]},t.fromBytes=function(A,z,q){return q?t.fromBytesLE(A,z):t.fromBytesBE(A,z)},t.fromBytesLE=function(A,z){return new t(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,z)},t.fromBytesBE=function(A,z){return new t(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],z)},Ix}var QR=s6();const tD=dw(QR),r6=vB({__proto__:null,default:tD},[QR]);const Ra=tD||r6;function u0(n){return Ra.fromString(n,!0,16)}const eD=u0("c3a5c85c97cb3127"),Na=u0("b492b66fbe98f273"),is=u0("9ae16a3b2f90404f");function Mv(n){return n.xor(n.shru(47))}function nD(n,t,e){const s=n.slice(t,t+e);return Ra.fromBytes(Array.from(s),!0,!0)}function Me(n,t){return nD(n,t,8)}function LI(n,t){return nD(n,t,4)}function _n(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function _o(n,t,e=u0("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let r=t.xor(s).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function i6(n,t,e,s,r,i){r=r.add(n),i=_n(i.add(r).add(s),21);const o=r;return r=r.add(t),r=r.add(e),i=i.add(_n(r,44)),[r.add(s),i.add(o)]}function Hp(n,t,e,s){return i6(Me(n,t),Me(n,t+8),Me(n,t+16),Me(n,t+24),e,s)}function o6(n,t=n.length){if(t>=8){const e=is.add(t*2),s=Me(n,0).add(is),r=Me(n,t-8),i=_n(r,37).mul(e).add(s),o=_n(s,25).add(r).mul(e);return _o(i,o,e)}if(t>=4){const e=is.add(t*2),s=LI(n,0);return _o(s.shl(3).add(t),LI(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],r=n[t-1],i=e+(s<<8),o=t+(r<<2);return Mv(is.mul(i).xor(eD.mul(o))).mul(is)}return is}function a6(n,t=n.length){const e=is.add(t*2),s=Me(n,0).mul(Na),r=Me(n,8),i=Me(n,t-8).mul(e),o=Me(n,t-16).mul(is);return _o(_n(s.add(r),43).add(_n(i,30)).add(o),s.add(_n(r.add(is),18)).add(i),e)}function l6(n,t=n.length){const e=is.add(t*2),s=Me(n,0).mul(is),r=Me(n,8),i=Me(n,t-8).mul(e),o=Me(n,t-16).mul(is),l=_n(s.add(r),43).add(_n(i,30)).add(o),c=_o(l,s.add(_n(r.add(is),18)).add(i),e),h=Me(n,16).mul(e),d=Me(n,24),p=l.add(Me(n,t-32)).mul(e),m=c.add(Me(n,t-24)).mul(e);return _o(_n(h.add(d),43).add(_n(p,30)).add(m),h.add(_n(d.add(s),18)).add(p),e)}function c6(n,t=n.length){const e=Ra.fromNumber(81,!0);if(t<=32)return t<=16?o6(n,t):a6(n,t);if(t<=64)return l6(n,t);let s=e,r=e.mul(Na).add(113),i=Mv(r.mul(is).add(113)).mul(is),o=[Ra.UZERO,Ra.UZERO],l=[Ra.UZERO,Ra.UZERO];s=s.mul(is).add(Me(n,0));let c=0;const h=(t-1>>6)*64,d=h+(t-1&63)-63;do s=_n(s.add(r).add(o[0]).add(Me(n,c+8)),37).mul(Na),r=_n(r.add(o[1]).add(Me(n,c+48)),42).mul(Na),s=s.xor(l[1]),r=r.add(o[0]).add(Me(n,c+40)),i=_n(i.add(l[0]),33).mul(Na),o=Hp(n,c,o[1].mul(Na),s.add(l[0])),l=Hp(n,c+32,i.add(l[1]),r.add(Me(n,c+16))),[i,s]=[s,i],c+=64;while(c!==h);const p=Na.add(i.and(255).shl(1));return c=d,l[0]=l[0].add(t-1&63),o[0]=o[0].add(l[0]),l[0]=l[0].add(o[0]),s=_n(s.add(r).add(o[0]).add(Me(n,c+8)),37).mul(p),r=_n(r.add(o[1]).add(Me(n,c+48)),42).mul(p),s=s.xor(l[1].mul(9)),r=r.add(o[0].mul(9).add(Me(n,c+40))),i=_n(i.add(l[0]),33).mul(p),o=Hp(n,c,o[1].mul(p),s.add(l[0])),l=Hp(n,c+32,i.add(l[1]),r.add(Me(n,c+16))),[i,s]=[s,i],_o(_o(o[0],l[0],p).add(Mv(r).mul(eD)).add(i),_o(o[1],l[1],p).add(s),p)}function Wo(n,t){return t==="string"?Ro(n):ol([n],t)}function u6(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function ol(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ha(n)),ct().getBool("DEBUG")&&B5(n,t),u6(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function gs(){return ct().platform.now()}function Ro(n,t="utf-8"){return t=t||"utf-8",ct().platform.encode(n,t)}function Lo(n,t="utf-8"){return t=t||"utf-8",ct().platform.decode(n,t)}function Sr(n){return ct().platform.isTypedArray!=null?ct().platform.isTypedArray(n):JR(n)}function Ha(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||s1(n)||n==null||Sr(n)&&e)t.push(n);else if(Array.isArray(n)||Sr(n))for(let s=0;s<n.length;++s)Ha(n[s],t,e);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ha(n[r],t,e)}return t}class h6{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new f6)}profileKernel(t,e,s){let r;const i=()=>{r=s()};let o;const l=gs();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const h of r)h.dataSync();o=Promise.resolve({kernelMs:gs()-l})}if(ct().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(p=>{d6(p,d.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(h=>h.kernelMs),extraInfo:o.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(l=>{Promise.all([l.data(),r,o]).then(c=>{this.logger.logKernelProfile(e,l,c[0],c[1],i,c[2])})})}}function d6(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class f6{logKernelProfile(t,e,s,r,i,o){const l=typeof r=="number"?Tc(`${r}ms`,9):r.error,c=Tc(t,25),h=e.rank,d=e.size,p=Tc(e.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const x=b.shape||e.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${c}	%c${l}	%c${h}D ${p}	%c${d}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function p6(n,t,e){const s={},r={};for(let c=0;c<t.length;c++)s[t[c].id]=!0;for(let c=0;c<n.length;c++){const h=n[c],d=h.inputs;for(const p in d){const m=d[p];let y=!1;for(let b=0;b<t.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const i={};i[e.id]=!0;const o={};for(let c=n.length-1;c>=0;c--){const h=n[c],d=h.inputs;for(let p=0;p<h.outputs.length;p++)if(i[h.outputs[p].id]){for(const m in d)i[d[m].id]=!0,o[h.id]=!0;break}}const l=[];for(let c=0;c<n.length;c++){const h=n[c];if(r[h.id]&&o[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const p=Object.assign({},h);p.inputs=d,p.outputs=h.outputs,l.push(p)}}return l}function m6(n,t,e,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(c=>{const h=n[c.id];h!=null?o.push(h):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const c in i.inputs){if(!(c in l))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(l)}.`);const h=e(()=>l[c]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${h.dtype}'`);const d=i.inputs[c];if(!we(h.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${c}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const p=n[d.id];n[d.id]=s(p,h),p.dispose()}}}}const PI=20,nh=3,Nx=7;function g6(n,t,e,s){const r=Ot(t),i=y6(n,t,e,r),o=t.length,l=cm(n,t,e,r,i),c=["Tensor"];return s&&(c.push(`  dtype: ${e}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map(h=>"    "+h).join(`
`)),c.join(`
`)}function y6(n,t,e,s){const r=ft(t),i=s[s.length-1],o=new Array(i).fill(0),l=t.length,c=e==="complex64"?uh(n):n;if(l>1)for(let h=0;h<r/i;h++){const d=h*i;for(let p=0;p<i;p++)o[p]=Math.max(o[p],ch(c[d+p],0,e).length)}return o}function ch(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Nx))} + ${parseFloat(n[1].toFixed(Nx))}j`:ed(n)?s=`'${n}'`:e==="bool"?s=sD(n):s=parseFloat(n.toFixed(Nx)).toString(),Tc(s,t)}function sD(n){return n===0?"false":"true"}function cm(n,t,e,s,r,i=!0){const o=e==="complex64"?2:1,l=t[0],c=t.length;if(c===0){if(e==="complex64"){const x=uh(n);return[ch(x[0],0,e)]}return e==="bool"?[sD(n[0])]:[n[0].toString()]}if(c===1){if(l>PI){const w=nh*o;let S=Array.from(n.slice(0,w)),T=Array.from(n.slice((l-nh)*o,l*o));return e==="complex64"&&(S=uh(S),T=uh(T)),["["+S.map((k,$)=>ch(k,r[$],e)).join(", ")+", ..., "+T.map((k,$)=>ch(k,r[l-nh+$],e)).join(", ")+"]"]}return["["+(e==="complex64"?uh(n):Array.from(n)).map((w,S)=>ch(w,r[S],e)).join(", ")+"]"]}const h=t.slice(1),d=s.slice(1),p=s[0]*o,m=[];if(l>PI){for(let x=0;x<nh;x++){const w=x*p,S=w+p;m.push(...cm(n.slice(w,S),h,e,d,r,!1))}m.push("...");for(let x=l-nh;x<l;x++){const w=x*p,S=w+p;m.push(...cm(n.slice(w,S),h,e,d,r,x===l-1))}}else for(let x=0;x<l;x++){const w=x*p,S=w+p;m.push(...cm(n.slice(w,S),h,e,d,r,x===l-1))}const y=c===2?",":"";m[0]="["+(l>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<c;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function uh(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Pn{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=ft(t),s!=null){const r=s.length;L(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||tn(e,this.size),this.strides=Ot(t)}set(t,...e){e.length===0&&(e=[0]),L(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Pr().makeTensor(this.values,this.shape,this.dtype)}}let Pr=null,pc=null;function b6(n){Pr=n}function x6(n){pc=n}class xn{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ft(t),this.strides=Ot(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return pc.buffer(this.shape,this.dtype,t)}bufferSync(){return pc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Vr(this.shape,t,this.dtype==="complex64")}arraySync(){return Vr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Pr().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>Lo(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Pr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Pr().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Lo(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Pr().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Pr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return pc.print(this,t)}clone(){return this.throwIfDisposed(),pc.clone(this)}toString(t=!1){const e=this.dataSync();return g6(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),pc.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Pr().makeVariable(this,t,e,s)}}Object.defineProperty(xn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function dt(){return r1("Tensor",()=>xn)}dt();class _m extends xn{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!we(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Pr().disposeTensor(this),this.dataId=t.dataId,Pr().incRef(this,null)}dispose(){Pr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(_m,Symbol.hasInstance,{value:n=>n instanceof xn&&n.assign!=null&&n.assign instanceof Function});var zI;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(zI||(zI={}));var Fv;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Fv||(Fv={}));var Lv;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Lv||(Lv={}));var Pv;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Pv||(Pv={}));var zv;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(zv||(zv={}));const v6={float32:Pv,int32:Fv,bool:Lv,complex64:zv};function Ms(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return v6[n][t]}function H1(n){return Ms(n,"int32")}function rD(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function iD(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function nn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ms(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function oD(n){const t=[];return aD(n,t,new Set),t}function aD(n,t,e){if(n==null)return;if(n instanceof xn){t.push(n);return}if(!w6(n))return;const s=n;for(const r in s){const i=s[r];e.has(i)||(e.add(i),aD(i,t,e))}}function w6(n){return Array.isArray(n)||typeof n=="object"}function Ax(n){return n.kernelName!=null}class BI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Rc{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new BI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Ys(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new h6(this.backendInstance),!0}setupRegisteredKernels(){MI(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){MI(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof Jw)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Ys(`Initialization of backend ${t} failed`),Ys(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Ys(`Initialization of backend ${t} failed`),Ys(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),r=s.backend,i=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),s.backend=t,t.move(e,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,s){t();try{const r=s();return e(),r}catch(r){throw e(),r}}nextTensorId(){return Rc.nextTensorId++}nextVariableId(){return Rc.nextVariableId++}clone(t){const e=J.runKernel(Sd,{x:t}),s={x:t},r=o=>({x:()=>{const l="float32",c={x:o},h={dtype:l};return J.runKernel(cd,c,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[e],r,i,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(DI(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const r=this.backend.numDataIds();let i=0;s.forEach(c=>{i+=c.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-e-i-o;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let c;const h=Ax(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ax(t)){const{kernelName:b,inputs:x,attrs:w}=t;this.backendName==null&&this.backend;const S=DI(b,this.backendName);L(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),l=()=>{const T=this.backend.numDataIds();c=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const k=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,T,k);const $=k.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(b,x,$);s=this.saveTensorsForBackwardMode(E)}return $}}else{const{forwardFunc:b}=t,x=w=>{r&&(s=w.map(S=>this.keep(this.clone(S))))};l=()=>{const w=this.backend.numDataIds();c=this.tidy(()=>b(this.backend,x));const S=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,S),S}}const{inputs:d,attrs:p}=t,m=Ax(t)?null:t.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=l():(y=this.profiler.profileKernel(h,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),r&&this.addTapeNode(h,d,e,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:e.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(c)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const r=OI(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let l;r.saveAllInputs?(L(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(e).map(h=>e[h])):l=i.map(h=>e[h]);const c=s.filter((h,d)=>o[d]);return l.concat(c)}return[]}makeTensor(t,e,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&ed(t[0])&&(i=t.map(c=>Ro(c)));const o=r.write(i,e,s),l=new xn(e,s,o,this.nextTensorId());if(this.trackTensor(l,r),s==="string"){const c=this.state.tensorInfo.get(o),h=U5(i);this.state.numBytes+=h-c.bytes,c.bytes=h}return l}makeTensorFromDataId(t,e,s,r){s=s||"float32";const i={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:r,dtype:i}=t,o=new xn(r,i,s,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new _m(t,e,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Em(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof _m||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Em(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,r,i,o){const l={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:i},c=OI(t);c!=null&&(r=c.gradFunc),r!=null&&(l.gradient=h=>(h=h.map((d,p)=>{if(d==null){const m=s[p],y=Jn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],i,o))),this.state.activeTape.push(l)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=oD(t),s=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,e,s,r=!1){if(L(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));L(i instanceof xn,()=>"The result y returned by f() must be a tensor.");const o=p6(this.state.activeTape,e,i);if(!r&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??S6(i.shape),m6(l,o,h=>this.tidy(h),C6);const c=e.map(h=>l[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(t){return L(Av(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{L(e.every(l=>l instanceof xn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};e.forEach((l,c)=>{r[c]=l});const i=(l,c)=>(s=t(...e,c),L(s.value instanceof xn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),L(Av(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(l,c)=>{const h=s.gradFunc(l,c),d=Array.isArray(h)?h:[h];L(d.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),L(d.every(m=>m instanceof xn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,y)=>{p[y]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=gs(),s=await this.backend.time(t);return s.wallMs=gs()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new BI;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Rc.nextTensorId=0;Rc.nextVariableId=0;function S6(n){const t=n1(ft(n),"float32");return J.makeTensor(t,n,"float32")}function lD(){const n=IR();if(n._tfengine==null){const t=new W5(n);n._tfengine=new Rc(t)}return X5(n._tfengine.ENV),b6(()=>n._tfengine),n._tfengine}const J=lD();function C6(n,t){const e={a:n,b:t};return J.runKernel(qc,e)}function T6(){return typeof navigator<"u"&&navigator!=null}function cD(n){if(n||T6()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function uD(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const ws=ct();ws.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ws.registerFlag("IS_BROWSER",()=>uD());ws.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ws.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ws.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ws.registerFlag("PROD",()=>!1);ws.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ws.getBool("DEBUG"));ws.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ws.registerFlag("IS_TEST",()=>!1);ws.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ws.getBool("DEBUG"));ws.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ws.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ws.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Zd(n,t){let e=n;if(Sr(n))return t==="string"?[]:[n.length];if(rD(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(iD(n))return[n.buffer.size/(t==null?4:Em(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||Sr(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&ct().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&hD(n,s,[]),s}function hD(n,t,e){if(e=e||[],!Array.isArray(n)&&!Sr(n)){L(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}L(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),L(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)hD(n[r],s,e.concat(r))}function VI(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function U(n,t,e,s="numeric"){if(n instanceof dt())return VI(s,n.dtype,t,e),n;let r=Wc(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),VI(s,r,t,e),n==null||!Sr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${c}'`)}const i=Zd(n,r);!Sr(n)&&!Array.isArray(n)&&(n=[n]);const l=r!=="string"?ol(n,r):Ha(n,[],!0);return J.makeTensor(l,i,r)}function dD(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>U(i,`${t}[${o}]`,e,s))}const k6="__op";function nt(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+k6;const r=(...i)=>{J.startScope(e);try{const o=s(...i);return s1(o)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(o),o}catch(o){throw J.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}function $6(n,t){const e=U(n,"real","complex"),s=U(t,"imag","complex");t1(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:e,imag:s};return J.runKernel(d1,r)}const qa=nt({complex_:$6});function Jd(n,t,e,s){if(s==null)s=Wc(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(iD(n)||rD(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return J.backend.createTensorFromGPUData(n,t||e,s)}if(!Sr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Xi(t);const r=ft(t),i=ft(e);L(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<e.length;++o){const l=e[o],c=o===e.length-1?l!==ft(t.slice(o)):!0;L(e[o]===t[o]||!c,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Sr(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?ol(n,s):Ha(n,[],!0),J.makeTensor(n,t,s)}function Sh(n,t,e){const s=Zd(n,e);return Jd(n,t,s,e)}const Rm={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ho{static join(t){return new Ho(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>Sr(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+r.byteLength;this.shards.push({buffer:r,start:e,end:i}),e=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=e-t,i=new ArrayBuffer(r),o=new Uint8Array(i);let l=0;for(let c=s;c<this.shards.length;c++){const h=this.shards[c],p=t+l-h.start,m=l,b=Math.min(e,h.end)-h.start,x=new Uint8Array(h.buffer,p,b-p);if(o.set(x,m),l+=x.length,e<h.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=E6(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function E6(n,t){let e=0,s=n.length;for(;e<=s;){const r=Math.floor((s-e)/2)+e,i=t(n[r]);if(i===0)return r;i<0?s=r:e=r+1}return-1}function ti(){return J}function UI(){return J.memory()}function rt(n,t){return J.tidy(n,t)}function Zt(n){oD(n).forEach(e=>e.dispose())}function ci(n){return J.keep(n)}function jI(n){return J.setBackend(n)}function I6(){return J.ready()}function fD(n,t,e=1){return J.registerBackend(n,t,e)}function N6(){return J.backend}const Dc=4;async function GI(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const l=r[o],c=Array.isArray(n)?n[o].tensor:n[l];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${c.dtype}`);const h={name:l,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const d=new Promise(async p=>{const m=await c.bytes(),y=m.reduce((w,S)=>w+S.length,0)+Dc*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const S=m[w],T=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(T,x),x+=Dc,b.set(S,x),x+=S.length}p(b)});s.push(d)}else s.push(c.data());t!=null&&(h.group=t),e.push(h)}const i=await Promise.all(s);return{data:D6(i),specs:e}}function A6(n,t){const e=new Ho(n),s={};let r=0;for(const i of t){const o=_6(i,(l,c)=>e.slice(r+l,r+c));s[i.name]=R6(i,e.slice(r,r+o)),r+=o}return s}function _6(n,t){const e=ft(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Rm[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<e;i++)r+=Dc+new Uint32Array(t(r,r+Dc))[0];return r}else s=Rm[n.dtype];return e*s}function R6(n,t){const e=n.name,s=n.dtype,r=n.shape,i=ft(r);let o,l=0;if("quantization"in n){const c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=Rm[c.dtype],d=c.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){o=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=m*c.scale+c.min}}else if(c.dtype==="float16")o=j6()(d);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(s==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);o=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=Math.round(m*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);l+=i*h}else if(s==="string"){const c=ft(n.shape);o=[];for(let h=0;h<c;h++){const d=new Uint32Array(t.slice(l,l+Dc))[0];l+=Dc;const p=new Uint8Array(t.slice(l,l+d));o.push(p),l+=d}}else{const c=Rm[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);const h=new Float32Array(o.length/2),d=new Float32Array(o.length/2);for(let b=0;b<h.length;b++)h[b]=o[b*2],d[b]=o[b*2+1];const p=Sh(h,r,"float32"),m=Sh(d,r,"float32"),y=qa(p,m);return p.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);l+=i*c}return Sh(o,r,s)}function D6(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const q1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function WI(n){return q1?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function O6(n){if(q1)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function M6(n){if(q1){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function F6(n){return Ho.join(n)}function L6(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function P6(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function z6(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),P6(n,e,s)}function K1(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:WI(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:WI(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Ho(n.weightData).byteLength}}function HI(n){const t=[];for(const e of n)t.push(...e.weights);return t}function B6(){const n=e=>{let s=e<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function V6(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function U6(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function j6(){const n=B6(),t=V6(),e=U6();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const l=s[o],c=n[e[l>>10]+(l&1023)]+t[l>>10];i[o]=c}return new Float32Array(r)}}class An{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return An.instance==null&&(An.instance=new An),An.instance}static registerSaveRouter(t){An.getInstance().saveRouters.push(t)}static registerLoadRouter(t){An.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return An.getHandlers(t,"save")}static getLoadHandlers(t,e){return An.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return(e==="load"?An.getInstance().loadRouters:An.getInstance().saveRouters).forEach(o=>{const l=o(t,s);l!==null&&r.push(l)}),r}}const G6=n=>An.getSaveHandlers(n),W6=(n,t)=>An.getLoadHandlers(n,t);const Bv="tensorflowjs",Vv=1,Pa="models_store",Io="model_info_store";function pD(){if(!ct().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Uv(n){const t=n.result;t.createObjectStore(Pa,{keyPath:"modelPath"}),t.createObjectStore(Io,{keyPath:"modelPath"})}class Ka{constructor(t){if(this.indexedDB=pD(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,r)=>{const i=this.indexedDB.open(Bv,Vv);i.onupgradeneeded=()=>Uv(i),i.onsuccess=()=>{const o=i.result;if(e==null){const l=o.transaction(Pa,"readonly"),h=l.objectStore(Pa).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(o.close(),r(h.error)),l.oncomplete=()=>o.close()}else{e.weightData=Ho.join(e.weightData);const l=K1(e),c=o.transaction(Io,"readwrite");let h=c.objectStore(Io),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(m){return r(m)}let p;d.onsuccess=()=>{p=o.transaction(Pa,"readwrite");const m=p.objectStore(Pa);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:l})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:l}),y.onerror=b=>{h=c.objectStore(Io);const x=h.delete(this.modelPath);x.onsuccess=()=>(o.close(),r(y.error)),x.onerror=w=>(o.close(),r(y.error))}},d.onerror=m=>(o.close(),r(d.error)),c.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Ka.URL_SCHEME="indexeddb://";const mD=n=>ct().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ka.URL_SCHEME)?H6(n.slice(Ka.URL_SCHEME.length)):null;An.registerSaveRouter(mD);An.registerLoadRouter(mD);function H6(n){return new Ka(n)}function q6(n){return n.startsWith(Ka.URL_SCHEME)?n.slice(Ka.URL_SCHEME.length):n}class K6{constructor(){this.indexedDB=pD()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(Bv,Vv);s.onupgradeneeded=()=>Uv(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Io,"readonly"),l=i.objectStore(Io).getAll();l.onsuccess=()=>{const c={};for(const h of l.result)c[h.modelPath]=h.modelArtifactsInfo;t(c)},l.onerror=c=>(r.close(),e(l.error)),i.oncomplete=()=>r.close()},s.onerror=r=>e(s.error)})}async removeModel(t){return t=q6(t),new Promise((e,s)=>{const r=this.indexedDB.open(Bv,Vv);r.onupgradeneeded=()=>Uv(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Io,"readwrite"),l=o.objectStore(Io),c=l.get(t);let h;c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),p=()=>{h=i.transaction(Pa,"readwrite");const y=h.objectStore(Pa).delete(t);y.onsuccess=()=>e(c.result.modelArtifactsInfo),y.onerror=b=>s(c.error)};d.onsuccess=p,d.onerror=m=>(p(),i.close(),s(c.error))}},c.onerror=d=>(i.close(),s(c.error)),o.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const Bi="/",mc="tensorflowjs_models",gD="info",X6="model_topology",Y6="weight_specs",Z6="weight_data",J6="model_metadata";function yD(n){return{info:[mc,n,gD].join(Bi),topology:[mc,n,X6].join(Bi),weightSpecs:[mc,n,Y6].join(Bi),weightData:[mc,n,Z6].join(Bi),modelMetadata:[mc,n,J6].join(Bi)}}function bD(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function Q6(n){const t=n.split(Bi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Bi)}function tq(n){return n.startsWith(Xa.URL_SCHEME)?n.slice(Xa.URL_SCHEME.length):n}class Xa{constructor(t){if(!ct().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=yD(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=K1(t),i=Ho.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,O6(i));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw bD(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const l=JSON.parse(i);e.format=l.format,e.generatedBy=l.generatedBy,e.convertedBy=l.convertedBy,l.signature!=null&&(e.signature=l.signature),l.userDefinedMetadata!=null&&(e.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(e.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(e.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(e.trainingConfig=l.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=M6(o),e}}Xa.URL_SCHEME="localstorage://";const xD=n=>ct().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xa.URL_SCHEME)?eq(n.slice(Xa.URL_SCHEME.length)):null;An.registerSaveRouter(xD);An.registerLoadRouter(xD);function eq(n){return new Xa(n)}class nq{constructor(){L(ct().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),L(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=mc+Bi,s=Bi+gD;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(s)){const o=Q6(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=tq(t);const e=yD(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return bD(e),s}}const qI="://";class ei{constructor(){this.managers={}}static getInstance(){return ei.instance==null&&(ei.instance=new ei),ei.instance}static registerManager(t,e){L(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(qI)&&(t=t.slice(0,t.indexOf(qI))),L(t.length>0,()=>"scheme must not be an empty string.");const s=ei.getInstance();L(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=ei.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(ei.getInstance().managers)}}class sq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!ct().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return JR(t)}}if(ct().get("IS_BROWSER")){ct().setPlatform("browser",new sq);try{ei.registerManager(Xa.URL_SCHEME,new nq)}catch{}try{ei.registerManager(Ka.URL_SCHEME,new K6)}catch{}}const rq={importFetch:()=>require("node-fetch")};let _x;class iq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return ct().global.fetch!=null?ct().global.fetch(t,e):(_x==null&&(_x=rq.importFetch()),_x(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}ct().get("IS_NODE")&&!ct().get("IS_BROWSER")&&ct().setPlatform("node",new iq);function Qt(n,t="float32",e){return t=t||"float32",Xi(n),new Pn(n,t,e)}function oq(n,t){const e=U(n,"x","cast");if(!V5(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},r={dtype:t};return J.runKernel(cd,s,r)}const Et=nt({cast_:oq});function aq(n){const e={x:U(n,"x","clone","string_or_numeric")};return J.runKernel(Sd,e)}const Ua=nt({clone_:aq});function lq(n,t=!1){console.log(n.toString(t))}lD();const cq={buffer:Qt,cast:Et,clone:Ua,print:lq};x6(cq);function uq(n,t){let e=U(n,"a","add"),s=U(t,"b","add");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(qc,r)}const wt=nt({add_:uq});function hq(n,t){let e=U(n,"a","floorDiv"),s=U(t,"b","floorDiv");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(vd,r)}const vD=nt({floorDiv_:hq});function dq(n,t){let e=U(n,"a","div"),s=U(t,"b","div");if([e,s]=nn(e,s),e.dtype==="int32"&&s.dtype==="int32")return vD(e,s);const r={a:e,b:s},i={};return J.runKernel(pd,r,i)}const Lt=nt({div_:dq});function fq(n,t){let e=U(n,"a","mul"),s=U(t,"b","mul");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(_d,r)}const Y=nt({mul_:fq});function pq(n){const t=U(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return J.runKernel(yg,e)}else{const e={x:t};return J.runKernel(ug,e)}}const rs=nt({abs_:pq});function mq(n){const e={x:U(n,"x","acos")};return J.runKernel(nd,e)}const gq=nt({acos_:mq});function yq(n){const e={x:U(n,"x","acosh")};return J.runKernel(sd,e)}const bq=nt({acosh_:yq});function xq(n,t=null,e=!1){const r={x:U(n,"x","all","bool")},i={axis:t,keepDims:e};return J.runKernel(o1,r,i)}const wD=nt({all_:xq});function vq(n,t=null,e=!1){const r={x:U(n,"x","any","bool")},i={axis:t,keepDims:e};return J.runKernel(a1,r,i)}const jv=nt({any_:vq});function wq(n,t=0){const s={x:U(n,"x","argMax")},r={axis:t};return J.runKernel(hg,s,r)}const Lh=nt({argMax_:wq});function Sq(n,t=0){const s={x:U(n,"x","argMin")},r={axis:t};return J.runKernel(dg,s,r)}const Cq=nt({argMin_:Sq});function Tq(n){const e={x:U(n,"x","asin")};return J.runKernel(rd,e)}const kq=nt({asin_:Tq});function $q(n){const e={x:U(n,"x","asinh")};return J.runKernel(id,e)}const Eq=nt({asinh_:$q});function Iq(n){const e={x:U(n,"x","atan")};return J.runKernel(od,e)}const Nq=nt({atan_:Iq});function Aq(n,t){let e=U(n,"a","atan2"),s=U(t,"b","atan2");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(ld,r)}const _q=nt({atan2_:Aq});function Rq(n){const e={x:U(n,"x","atanh")};return J.runKernel(ad,e)}const Dq=nt({atanh_:Rq});function Qd(n,t,e,s,r="NHWC",i){const o=n[3],l=[...t,o],c=Zi(r);return zn(n,l,e,i,s,null,null,c)}function Tr(n,t,e,s,r,i,o="channelsLast"){const[l,c]=Ph(t);let h;if(o==="channelsLast")h=[l,c,n[3],n[3]];else if(o==="channelsFirst")h=[l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return zn(n,h,e,s,r,i,!1,o)}function Yi(n,t,e,s,r,i,o="NDHWC"){const[l,c,h]=Gv(t);let d,p;if(o==="NDHWC")p="channelsLast",d=[l,c,h,n[4],n[4]];else if(o==="NCDHW")p="channelsFirst",d=[l,c,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return qo(n,d,e,s,r,!1,p,i)}function zn(n,t,e,s,r,i,o=!1,l="channelsLast"){let[c,h,d,p]=[-1,-1,-1,-1];if(l==="channelsLast")[c,h,d,p]=n;else if(l==="channelsFirst")[c,p,h,d]=n;else throw new Error(`Unknown dataFormat ${l}`);const[m,y,,b]=t,[x,w]=Ph(e),[S,T]=Ph(s),k=$c(m,S),$=$c(y,T),{padInfo:E,outHeight:N,outWidth:_}=Fq(r,h,d,x,w,k,$,i,l),R=o?b*p:b;let D;return l==="channelsFirst"?D=[c,R,N,_]:l==="channelsLast"&&(D=[c,N,_,R]),{batchSize:c,dataFormat:l,inHeight:h,inWidth:d,inChannels:p,outHeight:N,outWidth:_,outChannels:R,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:k,effectiveFilterWidth:$,dilationHeight:S,dilationWidth:T,inShape:n,outShape:D,filterShape:t}}function qo(n,t,e,s,r,i=!1,o="channelsLast",l){let[c,h,d,p,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[c,h,d,p,m]=n;else if(o==="channelsFirst")[c,m,h,d,p]=n;else throw new Error(`Unknown dataFormat ${o}`);const[y,b,x,,w]=t,[S,T,k]=Gv(e),[$,E,N]=Gv(s),_=$c(y,$),R=$c(b,E),D=$c(x,N),{padInfo:O,outDepth:A,outHeight:z,outWidth:q}=Lq(r,h,d,p,S,T,k,_,R,D,l),W=i?w*m:w;let X;return o==="channelsFirst"?X=[c,W,A,z,q]:o==="channelsLast"&&(X=[c,A,z,q,W]),{batchSize:c,dataFormat:o,inDepth:h,inHeight:d,inWidth:p,inChannels:m,outDepth:A,outHeight:z,outWidth:q,outChannels:W,padInfo:O,strideDepth:S,strideHeight:T,strideWidth:k,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:_,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:$,dilationHeight:E,dilationWidth:N,inShape:n,outShape:X,filterShape:t}}function Oq(n,t,e,s,r){s==null&&(s=X1(n,t,e));const i=n[0],o=n[1],l=zh((i-t+2*s)/e+1,r),c=zh((o-t+2*s)/e+1,r);return[l,c]}function Mq(n,t,e,s,r,i){r==null&&(r=X1(n,t[0],s[0]));const o=[0,0,0,e];for(let l=0;l<3;l++)n[l]+2*r>=t[l]&&(o[l]=zh((n[l]-t[l]+2*r)/s[l]+1,i));return o}function X1(n,t,e,s=1){const r=$c(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function Ph(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Gv(n){return typeof n=="number"?[n,n,n]:n}function $c(n,t){return t<=1?n:n+(n-1)*(t-1)}function Fq(n,t,e,s,r,i,o,l,c){let h,d,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=Oq([t,e],i,s,n,l);d=y[0],p=y[1]}else if(n==="same"){d=Math.ceil(t/s),p=Math.ceil(e/r);const m=Math.max(0,(d-1)*s+i-t),y=Math.max(0,(p-1)*r+o-e),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),S=y-w;h={top:b,bottom:x,left:w,right:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-i+1)/s),p=Math.ceil((e-o+1)/r);else if(typeof n=="object"){const m=c==="channelsLast"?n[1][0]:n[2][0],y=c==="channelsLast"?n[1][1]:n[2][1],b=c==="channelsLast"?n[2][0]:n[3][0],x=c==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=zh((t-i+m+y)/s+1,l),p=zh((e-o+b+x)/r+1,l)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:p}}function Lq(n,t,e,s,r,i,o,l,c,h,d){let p,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=Mq([t,e,s,1],[l,c,h],1,[r,i,o],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(t/r),y=Math.ceil(e/i),b=Math.ceil(s/o);const x=(m-1)*r+l-t,w=(y-1)*i+c-e,S=(b-1)*o+h-s,T=Math.floor(x/2),k=x-T,$=Math.floor(w/2),E=w-$,N=Math.floor(S/2),_=S-N;p={top:$,bottom:E,left:N,right:_,front:T,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:y,outWidth:b}}function zh(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ya(n){const[t,e,s]=Ph(n);return t===1&&e===1&&s===1}function ts(n,t){return Ya(n)||Ya(t)}function Za(n){return Ph(n).every(t=>t>0)}function Zi(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Cs(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")L(_c(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{L(_c(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function Pq(n,t){const s={x:U(n,"x","reshape","string_or_numeric")},r={shape:t};return J.runKernel(Zg,s,r)}const et=nt({reshape_:Pq});function zq(n,t,e,s,r){const i=U(n,"x","avgPool","float32"),o=1;L(ts(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let l=i,c=!1;i.rank===3&&(c=!0,l=et(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),Cs("avgPool",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r};let p=J.runKernel(fg,h,d);return p=Et(p,i.dtype),c?et(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Y1=nt({avgPool_:zq});function Bq(n,t,e,s,r,i="NDHWC"){const o=U(n,"x","avgPool3d","float32");let l=o,c=!1;o.rank===4&&(c=!0,l=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),L(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),L(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Cs("avgPool3d",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i};let p=J.runKernel(pg,h,d);return p=Et(p,l.dtype),c?et(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Vq=nt({avgPool3d_:Bq});function Uq(n,t=0){L(n.length>=1,()=>"Pass at least one tensor to concat");const e=dD(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Ua(e[0]);const s=e,r={axis:t};return J.runKernel(bg,s,r)}const vs=nt({concat_:Uq});function jq(n,t,e=!1,s=!1){let r=U(n,"a","matMul"),i=U(t,"b","matMul");[r,i]=nn(r,i);const o={a:r,b:i},l={transposeA:e,transposeB:s};return J.runKernel(mg,o,l)}const xe=nt({matMul_:jq});function Gq(n){const e={x:U(n,"x","sigmoid","float32")};return J.runKernel(Ud,e)}const Kc=nt({sigmoid_:Gq});function Wq(n,t,e){const s=U(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:e};return J.runKernel(n0,r,i)}const Fe=nt({slice_:Wq});function Hq(n){const e={x:U(n,"x","tanh","float32")};return J.runKernel(Kd,e)}const h0=nt({tanh_:Hq});function qq(n,t,e){const s=U(n,"x","batchToSpaceND"),r=t.reduce((l,c)=>l*c);L(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),L(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),L(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},o={blockShape:t,crops:e};return J.runKernel(gg,i,o)}const Z1=nt({batchToSpaceND_:qq});function Kq(n){let t;return n.rank===0||n.rank===1?t=et(n,[1,1,1,n.size]):n.rank===2?t=et(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=et(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function Xq(n,t,e,s,r,i){i==null&&(i=.001);const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;s!=null&&(d=U(s,"offset","batchNorm")),L(l.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(h==null||l.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:Kq(o),scale:h,offset:d,mean:l,variance:c},y={varianceEpsilon:i},b=J.runKernel(Eg,m,y);return et(b,o.shape)}const d0=nt({batchNorm_:Xq});function Yq(n,t,e,s,r,i){const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),L(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),L(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),L(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),d0(o,l,c,d,h,i)}const Zq=nt({batchNorm2d_:Yq});function Jq(n,t,e,s,r,i){const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),L(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),L(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),L(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),d0(o,l,c,d,h,i)}const Qq=nt({batchNorm3d_:Jq});function t8(n,t,e,s,r,i){const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;r!=null&&(h=U(r,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),L(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),L(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),L(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),d0(o,l,c,d,h,i)}const e8=nt({batchNorm4d_:t8});function n8(n,t,e){const s=U(n,"x","bincount"),r=U(t,"weights","bincount");L(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),L(e>=0,()=>`size must be non-negative, but got ${e}.`),L(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:e};return J.runKernel(u1,i,o)}const s8=nt({bincount_:n8});function r8(n,t){let e=U(n,"broadcastTo","x");const s=e.shape;if(Xi(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const h=e.shape.slice();for(;h.length<t.length;)h.unshift(1);e=et(e,h)}const r=e.shape,i=Array.from(t);for(let h=t.length-1;h>=0;h--)if(r[h]===t[h])i[h]=1;else if(e.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Ua(e);const l={x:e},c={reps:i};return J.runKernel(Xd,l,c)}const Ch=nt({broadcastTo_:r8});function i8(n){const e={x:U(n,"x","ceil","float32")};return J.runKernel(ud,e)}const o8=nt({ceil_:i8});function f0(n,t,e){Xi(n),e=e||Wc(t);const s={shape:n,value:t,dtype:e};return J.runKernel(k1,{},s)}function a8(n,t,e){const s=U(n,"x","clipByValue");if(L(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return f0(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:e};return J.runKernel(hd,r,i)}const Qs=nt({clipByValue_:a8});function l8(n){return vs(n,0)}const c8=nt({concat1d_:l8});function u8(n,t){return vs(n,t)}const h8=nt({concat2d_:u8});function d8(n,t){return vs(n,t)}const f8=nt({concat3d_:d8});function p8(n,t){return vs(n,t)}const m8=nt({concat4d_:p8});function g8(n,t,e,s,r="NHWC",i=[1,1],o){const l=U(n,"x","conv2d","float32"),c=U(t,"filter","conv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),L(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Cs("conv2d",s,o);const p=r==="NHWC"?h.shape[3]:h.shape[1];L(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),L(ts(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),L(Za(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),L(Za(e),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:c},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=J.runKernel(xg,m,y);return d?et(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Ja=nt({conv2d_:g8});function y8(n,t,e,s,r="NWC",i=1,o){const l=U(n,"x","conv1d"),c=U(t,"filter","conv1d");let h=l,d=!1;l.rank===2&&(d=!0,h=et(l,[1,l.shape[0],l.shape[1]])),L(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),L(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Cs("conv1d",s,o),L(h.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${c.shape[1]}.`),L(ts(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),L(Za(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),L(Za(e),()=>"Error in conv1D: Stride should be larger than 0."),L(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=et(c,[1,c.shape[0],c.shape[1],c.shape[2]]),m=et(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=Ja(m,p,[1,e],s,"NHWC",[1,i],o);return d?et(w,[w.shape[2],w.shape[3]]):et(w,[w.shape[0],w.shape[2],w.shape[3]])}const SD=nt({conv1d_:y8});function b8(n,t,e,s,r,i="NHWC",o){L(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let l=n,c=t,h=!1;t.rank===3&&(h=!0,c=et(t,[1,t.shape[0],t.shape[1],t.shape[2]]),l=[1,n[0],n[1],n[2]]),L(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),L(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),L(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const d=i==="NHWC"?l[3]:l[1],p=i==="NHWC"?c.shape[3]:c.shape[1];L(d===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${e.shape[2]}.`),L(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Cs("conv2dDerInput",r,o);const m={dy:c,filter:e},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:l},b=J.runKernel(vg,m,y);return h?et(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const J1=nt({conv2DBackpropInput_:b8});function x8(n,t,e,s,r,i){const o=U(n,"x","conv2dTranspose"),l=U(t,"filter","conv2dTranspose");return J1(e,o,l,s,r,"NHWC",i)}const CD=nt({conv2dTranspose_:x8});function v8(n,t,e,s,r="NDHWC",i=[1,1,1]){const o=U(n,"x","conv3d"),l=U(t,"filter","conv3d");let c=o,h=!1;o.rank===4&&(h=!0,c=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),L(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),L(c.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${l.shape[3]}.`),L(ts(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),L(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),L(Za(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),L(Za(e),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:e,pad:s,dataFormat:r,dilations:i},m=J.runKernel(wg,d,p);return h?et(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const w8=nt({conv3d_:v8});function S8(n,t,e,s,r){L(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,l=!1;t.rank===4&&(l=!0,o=et(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const c=i[4],h=o.shape[4];L(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),L(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),L(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),L(c===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[3]}.`),L(h===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[4]}.`);const d={dy:o,filter:e},p={pad:r,strides:s,inputShape:i},m=J.runKernel(m1,d,p);return l?et(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const TD=nt({conv3DBackpropInput_:S8});function C8(n,t,e,s,r){const i=U(n,"x","conv3dTranspose"),o=U(t,"filter","conv3dTranspose");return TD(e,i,o,s,r)}const T8=nt({conv3dTranspose_:C8});function k8(n){const e={x:U(n,"x","cos","float32")};return J.runKernel(dd,e)}const Q1=nt({cos_:k8});function $8(n){const e={x:U(n,"x","cosh","float32")};return J.runKernel(fd,e)}const kD=nt({cosh_:$8});function E8(n,t=0,e=!1,s=!1){const i={x:U(n,"x","cumprod")},o={axis:t,exclusive:e,reverse:s};return J.runKernel(g1,i,o)}const Wv=nt({cumprod_:E8});function I8(n,t=0,e=!1,s=!1){const i={x:U(n,"x","cumsum")},o={axis:t,exclusive:e,reverse:s};return J.runKernel(Sg,i,o)}const $D=nt({cumsum_:I8});function N8(n,t,e,s=!1){const r=U(n,"x","denseBincount"),i=U(t,"weights","denseBincount");L(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),L(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),L(e>=0,()=>`size must be non-negative, but got ${e}.`),L(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},l={size:e,binaryOutput:s};return J.runKernel(b1,o,l)}const KI=nt({denseBincount_:N8});function A8(n,t,e="NHWC"){const s=U(n,"x","depthToSpace","float32"),r=e==="NHWC"?s.shape[1]:s.shape[2],i=e==="NHWC"?s.shape[2]:s.shape[3],o=e==="NHWC"?s.shape[3]:s.shape[1];L(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),L(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),L(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),L(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const l={x:s},c={blockSize:t,dataFormat:e};return J.runKernel(x1,l,c)}const _8=nt({depthToSpace_:A8});function R8(n,t,e,s,r="NHWC",i=[1,1],o){const l=U(n,"x","depthwiseConv2d","float32"),c=U(t,"filter","depthwiseConv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),L(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const p=r==="NHWC"?h.shape[3]:h.shape[1];L(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),Cs("depthwiseConv2d",s,o);const m={x:h,filter:c},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=J.runKernel(Cg,m,y);return d?et(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const tS=nt({depthwiseConv2d_:R8});function D8(n,t,e,s,r=[1,1],i="NHWC"){const o=U(n,"x","dilation2d"),l=U(t,"filter","dilation2d");L(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),L(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),L(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let c=o,h=!1;o.rank===3&&(c=et(o,[1,o.shape[0],o.shape[1],o.shape[2]]),h=!0),L(c.shape[3]===l.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${l.shape[2]}`);const d={x:c,filter:l},p={strides:e,pad:s,dilations:r},m=J.runKernel(Tg,d,p);return h?et(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const O8=nt({dilation2d_:D8});function Oc(n,t){const e=n.length,s=[];for(let r=0;r<e;r++){const i=e-1-r,o=n[i]||1;(t[t.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function Tn(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],i=t.length-s-1,o=t[i];(r==null||r===1&&o>1)&&e.unshift(i)}return e}function qt(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let r=0;r<e;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)s[e-r-1]=o;else if(o===1)s[e-r-1]=i;else if(i!==o){const l=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(l)}else s[e-r-1]=i}return s}function M8(n,t){let e=U(n,"a","equal","string_or_numeric"),s=U(t,"b","equal","string_or_numeric");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(kg,r)}const pi=nt({equal_:M8});function F8(n,t,e){const s=U(t,"a","where"),r=U(e,"b","where"),i=U(n,"condition","where","bool"),o=qt(qt(i.shape,s.shape),r.shape),l=Ch(i,o),c=Ch(s,o),h=Ch(r,o),d={condition:l,t:c,e:h};return J.runKernel(e0,d)}const ls=nt({where_:F8});function L8(n){const e={x:U(n,"x","zerosLike")};return J.runKernel(c0,e)}const ue=nt({zerosLike_:L8});function P8(n,t){let e=U(n,"a","div"),s=U(t,"b","div");[e,s]=nn(e,s);const r=Lt(e,s),i=ue(r),o=pi(s,i);return ls(o,i,r)}const z8=nt({divNoNan_:P8});function B8(n,t){const e=U(n,"t1","dot"),s=U(t,"t2","dot");L((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const r=e.rank===1?e.size:e.shape[1],i=s.rank===1?s.size:s.shape[0];if(L(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),e.rank===1&&s.rank===1){const o=et(e,[1,-1]),l=et(s,[-1,1]),c=xe(o,l);return et(c,[])}else if(e.rank===1&&s.rank===2){const o=et(e,[1,-1]),l=et(s,[s.shape[0],s.shape[1]]),c=xe(o,l);return et(c,[c.size])}else if(e.rank===2&&s.rank===1){const o=et(s,[-1,1]),l=xe(e,o);return et(l,[l.size])}else{const o=et(s,[s.shape[0],s.shape[1]]);return xe(e,o)}}const V8=nt({dot_:B8});function U8(n,...t){const e=t.map((r,i)=>U(r,`tensors${i}`,"einsum")),s={equation:n};return J.runKernel(S1,e,s)}const sh=nt({einsum_:U8});function j8(n){const e={x:U(n,"x","elu","float32")};return J.runKernel(md,e)}const p0=nt({elu_:j8});function G8(n){let t=U(n,"x","erf");L(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Et(t,"float32"));const e={x:t};return J.runKernel(gd,e)}const ED=nt({erf_:G8});function eS(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function ID(n,t,e){const s=n.length+t.length,r=[];let i=0,o=0;for(let l=0;l<s;l++)e.indexOf(l)===-1?r.push(n[i++]):r.push(t[o++]);return r}function On(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&e.push(n[i]);const r=t.map(i=>n[i]);return[e,r]}function hn(n,t){const e=t.map(s=>1);return ID(n,e,t)}function Bn(n,t,e){L(eS(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function qe(n,t){if(eS(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function Ko(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function sn(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}function W8(n,t=null,e=!1){const r={x:U(n,"x","max")},i={reductionIndices:t,keepDims:e};return J.runKernel(Lg,r,i)}const Ur=nt({max_:W8});function H8(n,t=null,e=!1){const r={x:U(n,"x","min")},i={axis:t,keepDims:e};return J.runKernel(Vg,r,i)}const Dm=nt({min_:H8});function q8(n,t){let e=U(n,"base","pow"),s=U(t,"exp","pow");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(Rd,r)}const Qa=nt({pow_:q8});function ve(n,t){if((Sr(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Sr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Jd(n,[],[],t)}function K8(n){const e={x:U(n,"x","sqrt","float32")};return J.runKernel(Gd,e)}const Qn=nt({sqrt_:K8});function X8(n){const t=U(n,"x","square"),e={};return J.runKernel("Square",{x:t},e)}const ze=nt({square_:X8});function Y8(n,t=null,e=!1){let s=U(n,"x","sum");s.dtype==="bool"&&(s=Et(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return J.runKernel(s0,r,i)}const Mt=nt({sum_:Y8});function Z8(n,t="euclidean",e=null,s=!1){n=U(n,"x","norm");const r=ND(n,t,e);let i=r.shape;if(s){const o=te(e,n.shape);i=hn(r.shape,o)}return et(r,i)}function ND(n,t,e=null){if(n.rank===0)return rs(n);if(n.rank!==1&&e===null)return ND(et(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return Mt(rs(n),e);if(t===1/0)return Ur(rs(n),e);if(t===-1/0)return Dm(rs(n),e);if(t==="euclidean"||t===2)return Qn(Mt(Qa(rs(n),ve(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Ur(Mt(rs(n),e[0]),e[1]-1);if(t===1/0)return Ur(Mt(rs(n),e[1]),e[0]);if(t===-1/0)return Dm(Mt(rs(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Qn(Mt(ze(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const m0=nt({norm_:Z8});function J8(n,t=null,e=!1){return m0(n,"euclidean",t,e)}const Q8=nt({euclideanNorm_:J8});function tK(n){const e={x:U(n,"x","exp")};return J.runKernel(yd,e)}const mi=nt({exp_:tK});function eK(n,t=0){const e=U(n,"x","expandDims","string_or_numeric");L(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},r={dim:t};return J.runKernel($g,s,r)}const ys=nt({expandDims_:eK});function nK(n){const e={x:U(n,"x","expm1")};return J.runKernel(bd,e)}const sK=nt({expm1_:nK});function rK(n,t){const e=U(n,"x","tile","string_or_numeric");L(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},r={reps:t};return J.runKernel(Xd,s,r)}const Br=nt({tile_:rK});function iK(n,t,e,s="float32"){t==null&&(t=n);const r=Qt([n,t],s),i=n<=t?n:t;for(let l=0;l<i;++l)r.set(1,l,l);const o=et(r.toTensor(),[n,t]);if(e==null)return o;if(e.length===1)return Br(ys(o,0),[e[0],1,1]);if(e.length===2)return Br(ys(ys(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return Br(ys(ys(ys(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const AD=nt({eye_:iK});function oK(n){const e={x:U(n,"x","floor","float32")};return J.runKernel(xd,e)}const g0=nt({floor_:oK});function aK(n,t,e=0,s=0){const r=U(n,"x","gather"),i=U(t,"indices","gather","int32"),o={x:r,indices:i},l={axis:e,batchDims:s};return J.runKernel(Ig,o,l)}const nS=nt({gather_:aK});function lK(n,t){let e=U(n,"a","greater","string_or_numeric"),s=U(t,"b","greater","string_or_numeric");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Ng,r)}const tr=nt({greater_:lK});function cK(n,t){let e=U(n,"a","greaterEqual","string_or_numeric"),s=U(t,"b","greaterEqual","string_or_numeric");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(wd,r)}const al=nt({greaterEqual_:cK});function uK(n){const e={input:U(n,"input","imag")};return J.runKernel(I1,e)}const sS=nt({imag_:uK});function hK(n){const e={x:U(n,"x","isFinite")};return J.runKernel(Cd,e)}const dK=nt({isFinite_:hK});function fK(n){const e={x:U(n,"x","isInf")};return J.runKernel(Td,e)}const pK=nt({isInf_:fK});function mK(n){const e={x:U(n,"x","isNaN")};return J.runKernel(kd,e)}const gK=nt({isNaN_:mK});function yK(n,t=.2){const s={x:U(n,"x","leakyRelu")},r={alpha:t};return J.runKernel(Ag,s,r)}const rS=nt({leakyRelu_:yK});function bK(n,t){let e=U(n,"a","less","string_or_numeric"),s=U(t,"b","less","string_or_numeric");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(_g,r)}const Om=nt({less_:bK});function xK(n,t){let e=U(n,"a","lessEqual","string_or_numeric"),s=U(t,"b","lessEqual","string_or_numeric");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Rg,r)}const Xc=nt({lessEqual_:xK});function vK(n,t=5,e=1,s=1,r=.5){const i=U(n,"x","localResponseNormalization");L(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),L(_c(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,l=!1;i.rank===3&&(l=!0,o=et(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c={x:o},h={depthRadius:t,bias:e,alpha:s,beta:r},d=J.runKernel(Fg,c,h);return l?et(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const wK=nt({localResponseNormalization_:vK});function SK(n){const e={x:U(n,"x","log","float32")};return J.runKernel($d,e)}const gi=nt({log_:SK});function CK(n){const e={x:U(n,"x","log1p")};return J.runKernel(Ed,e)}const _D=nt({log1p_:CK});function TK(n,t){L(Av(n),()=>"The f passed in variableGrads(f) must be a function"),L(t==null||Array.isArray(t)&&t.every(h=>h instanceof _m),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const h in J.registeredVariables)t.push(J.registeredVariables[h])}const s=e?t.filter(h=>!h.trainable):null,r=t.length;t=t.filter(h=>h.trainable),L(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:l}=J.gradients(n,t,null,i);L(l.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),L(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const c={};return t.forEach((h,d)=>{l[d]!=null&&(c[h.name]=l[d])}),s?.forEach(h=>c[h.name]=null),{value:o,grads:c}}function Mc(n){return J.customGrad(n)}function kK(n){const e={x:U(n,"x","neg")};return J.runKernel(jg,e)}const en=nt({neg_:kK});function $K(n){const e={x:U(n,"x","softplus")};return J.runKernel(jd,e)}const tf=nt({softplus_:$K});function EK(n){const t=U(n,"x","logSigmoid");return Mc(s=>({value:en(tf(en(s))),gradFunc:o=>Y(o,Kc(en(s)))}))(t)}const IK=nt({logSigmoid_:EK});function NK(n,t){let e=U(n,"a","sub"),s=U(t,"b","sub");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(Hd,r)}const Bt=nt({sub_:NK});function AK(n,t=-1){const e=U(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Mc((r,i)=>{const l=Ur(r,t,!0),c=Bt(r,l),h=Bt(Et(c,"float32"),gi(Mt(mi(c),t,!0)));return i([h]),{value:h,gradFunc:(p,m)=>{const[y]=m,b=!0,x=mi(y);return Bt(p,Y(Mt(p,t,b),x))}}})(e)}const RD=nt({logSoftmax_:AK});function _K(n,t=null,e=!1){const s=U(n,"x","logSumExp"),r=te(t,s.shape),i=Ur(s,r,!0),o=Bt(s,i),l=mi(o),c=Mt(l,r),h=gi(c),d=wt(et(i,h.shape),h);if(e){const p=hn(d.shape,r);return et(d,p)}return d}const DD=nt({logSumExp_:_K});function RK(n,t){const e=U(n,"a","logicalAnd","bool"),s=U(t,"b","logicalAnd","bool");qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Dg,r)}const Gi=nt({logicalAnd_:RK});function DK(n){const e={x:U(n,"x","logicalNot","bool")};return J.runKernel(Og,e)}const iS=nt({logicalNot_:DK});function OK(n,t){const e=U(n,"a","logicalOr","bool"),s=U(t,"b","logicalOr","bool");qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Mg,r)}const OD=nt({logicalOr_:OK});function MK(n,t){const e=U(n,"a","logicalXor","bool"),s=U(t,"b","logicalXor","bool");return qt(e.shape,s.shape),Gi(OD(n,t),iS(Gi(n,t)))}const FK=nt({logicalXor_:MK});function LK(n,t,e,s,r){const i=U(n,"x","maxPool"),o=1;let l=i,c=!1;i.rank===3&&(c=!0,l=et(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),L(ts(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),Cs("maxPool",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r},p=J.runKernel(Pg,h,d);return c?et(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const oS=nt({maxPool_:LK});function PK(n,t=[1,1,1],e,s,r,i="NDHWC"){const o=U(n,"x","maxPool3d");let l=o,c=!1;o.rank===4&&(c=!0,l=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),L(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Cs("maxPool3d",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i},p=J.runKernel(zg,h,d);return c?et(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const zK=nt({maxPool3d_:PK});function BK(n,t){let e=U(n,"a","maximum"),s=U(t,"b","maximum");[e,s]=nn(e,s),e.dtype==="bool"&&(e=Et(e,"int32"),s=Et(s,"int32")),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Id,r)}const Xo=nt({maximum_:BK});function VK(n,t=null,e=!1){const r={x:U(n,"x","mean")},i={axis:t,keepDims:e};return J.runKernel(Bg,r,i)}const un=nt({mean_:VK});function Rn(n,t="float32"){if(Xi(n),t==="complex64"){const s=Rn(n,"float32"),r=Rn(n,"float32");return qa(s,r)}const e=Jn(ft(n),t);return J.makeTensor(e,n,t)}function Yo(n,t="float32"){if(Xi(n),t==="complex64"){const s=Yo(n,"float32"),r=Rn(n,"float32");return qa(s,r)}const e=n1(ft(n),t);return J.makeTensor(e,n,t)}function UK(n,t){let e=U(n,"a","minimum"),s=U(t,"b","minimum");[e,s]=nn(e,s),e.dtype==="bool"&&(e=Et(e,"int32"),s=Et(s,"int32")),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Nd,r)}const Bh=nt({minimum_:UK});function jK(n,t,e){L(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=U(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");L(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=e==="reflect"?1:0;for(let l=0;l<s.rank;l++)L(t[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),L(t[l][0]>=0&&t[l][0]<=s.shape[l]-r&&t[l][1]>=0&&t[l][1]<=s.shape[l]-r,()=>`Padding in dimension ${l} cannot be greater than or equal to ${s.shape[l]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:e},o={x:s};return J.runKernel(Ug,o,i)}const GK=nt({mirrorPad_:jK});function WK(n,t){let e=U(n,"a","mod"),s=U(t,"b","mod");[e,s]=nn(e,s);const r={a:e,b:s};return J.runKernel(Ad,r)}const HK=nt({mod_:WK});function qK(n,t=null,e=!1){n=U(n,"x","moments");const s=te(t,n.shape),r=un(n,s,e);let i=r.shape;e||(i=hn(r.shape,s));const o=ze(Bt(Et(n,"float32"),et(r,i))),l=un(o,s,e);return{mean:r,variance:l}}const aS=nt({moments_:qK});function KK(n,t){let e=U(n,"a","notEqual","string_or_numeric"),s=U(t,"b","notEqual","string_or_numeric");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Gg,r)}const Mm=nt({notEqual_:KK});function XK(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:U(n,"indices","oneHot","int32")},l={dtype:r,depth:t,onValue:e,offValue:s};return J.runKernel(Hg,o,l)}const MD=nt({oneHot_:XK});function YK(n){const e={x:U(n,"x","onesLike")};return J.runKernel(Wg,e)}const Cr=nt({onesLike_:YK});function ZK(n,t,e=0){const s=U(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:e},i={x:s};return J.runKernel(Kg,i,r)}const lS=nt({pad_:ZK});function JK(n,t,e){const s=U(n,"x","spaceToBatchND");L(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),L(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),L(s.shape.reduce((o,l,c)=>c>0&&c<=t.length?o&&(l+e[c-1][0]+e[c-1][1])%t[c-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:e};return J.runKernel(r0,r,i)}const cS=nt({spaceToBatchND_:JK});function QK(n,t,e,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const l=U(n,"x","maxPool");let c=l,h=!1;l.rank===3&&(h=!0,c=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(ts(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=Tr(c.shape,t,i,r,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=eX([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const y=p[0]===1&&p[1]===1,[b,x]=tX([d.inHeight,d.inWidth],p,m),w=y?s:"valid",S=y?c:cS(c,p,b),k=(e==="avg"?()=>Y1(S,t,i,w,o):()=>oS(S,t,i,w,o))(),$=y?k:Z1(k,p,x);return h?et($,[$.shape[1],$.shape[2],$.shape[3]]):$}function tX(n,t,e){const s=e.map(d=>d[0]),r=e.map(d=>d[1]),i=n.concat(s,r),o=t.map((d,p)=>(d-i[p]%d)%d),l=r.map((d,p)=>d+o[p]),c=t.map((d,p)=>[s[p],l[p]]),h=t.map((d,p)=>[0,o[p]]);return[c,h]}function eX(n,t){const s=n.map((o,l)=>o+(o-1)*(t[l]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,l)=>o-r[l]);return s.map((o,l)=>[r[l],i[l]])}const nX=nt({pool_:QK});function sX(n,t){const e=U(n,"x","prelu"),s=U(t,"alpha","prelu"),r={x:e,alpha:s};return J.runKernel(Xg,r)}const uS=nt({prelu_:sX});function rX(n,t=null,e=!1){let s=U(n,"x","prod");s.dtype==="bool"&&(s=Et(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return J.runKernel(Yg,r,i)}const iX=nt({prod_:rX});var um={exports:{}},oX=um.exports,XI;function aX(){return XI||(XI=1,(function(n){(function(t,e,s){function r(c){var h=this,d=l();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(c),h.s0<0&&(h.s0+=1),h.s1-=d(c),h.s1<0&&(h.s1+=1),h.s2-=d(c),h.s2<0&&(h.s2+=1),d=null}function i(c,h){return h.c=c.c,h.s0=c.s0,h.s1=c.s1,h.s2=c.s2,h}function o(c,h){var d=new r(c),p=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,d),m.state=function(){return i(d,{})}),m}function l(){var c=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){c+=d.charCodeAt(p);var m=.02519603282416938*c;c=m>>>0,m-=c,m*=c,c=m>>>0,m-=c,c+=m*4294967296}return(c>>>0)*23283064365386963e-26};return h}e&&e.exports?e.exports=o:this.alea=o})(oX,n)})(um)),um.exports}var hm={exports:{}},lX=hm.exports,YI;function cX(){return YI||(YI=1,(function(n){(function(t,e,s){function r(l){var c=this,h="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xor128=o})(lX,n)})(hm)),hm.exports}var dm={exports:{}},uX=dm.exports,ZI;function hX(){return ZI||(ZI=1,(function(n){(function(t,e,s){function r(l){var c=this,h="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,d==h.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xorwow=o})(uX,n)})(dm)),dm.exports}var fm={exports:{}},dX=fm.exports,JI;function fX(){return JI||(JI=1,(function(n){(function(t,e,s){function r(l){var c=this;c.next=function(){var d=c.x,p=c.i,m,y;return m=d[p],m^=m>>>7,y=m^m<<24,m=d[p+1&7],y^=m^m>>>10,m=d[p+3&7],y^=m^m>>>3,m=d[p+4&7],y^=m^m<<7,m=d[p+7&7],m=m^m<<13,y^=m^m<<9,d[p]=y,c.i=p+1&7,y};function h(d,p){var m,y=[];if(p===(p|0))y[0]=p;else for(p=""+p,m=0;m<p.length;++m)y[m&7]=y[m&7]<<15^p.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(c,l)}function i(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.x&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xorshift7=o})(dX,n)})(fm)),fm.exports}var pm={exports:{}},pX=pm.exports,QI;function mX(){return QI||(QI=1,(function(n){(function(t,e,s){function r(l){var c=this;c.next=function(){var d=c.w,p=c.X,m=c.i,y,b;return c.w=d=d+1640531527|0,b=p[m+34&127],y=p[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=p[m]=b^y,c.i=m,b+(d^d>>>16)|0};function h(d,p){var m,y,b,x,w,S=[],T=128;for(p===(p|0)?(y=p,p=null):(p=p+"\0",y=0,T=Math.max(T,p.length)),b=0,x=-32;x<T;++x)p&&(y^=p.charCodeAt((x+32)%p.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=S[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(S[(p&&p.length||0)&127]=-1),b=127,x=512;x>0;--x)y=S[b+34&127],m=S[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,S[b]=y^m;d.w=w,d.X=S,d.i=b}h(c,l)}function i(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.X&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xor4096=o})(pX,n)})(pm)),pm.exports}var mm={exports:{}},gX=mm.exports,tN;function yX(){return tN||(tN=1,(function(n){(function(t,e,s){function r(l){var c=this,h="";c.next=function(){var p=c.b,m=c.c,y=c.d,b=c.a;return p=p<<25^p>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-p|0,c.b=p=p<<20^p>>>12^m,c.c=m=m-y|0,c.d=y<<16^m>>>16^b,c.a=b-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):h+=l;for(var d=0;d<h.length+20;d++)c.b^=h.charCodeAt(d)|0,c.next()}function i(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.tychei=o})(gX,n)})(mm)),mm.exports}var gm={exports:{}};const bX={},xX=Object.freeze(Object.defineProperty({__proto__:null,default:bX},Symbol.toStringTag,{value:"Module"})),vX=wB(xX);var wX=gm.exports,eN;function SX(){return eN||(eN=1,(function(n){(function(t,e,s){var r=256,i=6,o=52,l="random",c=s.pow(r,i),h=s.pow(2,o),d=h*2,p=r-1,m;function y($,E,N){var _=[];E=E==!0?{entropy:!0}:E||{};var R=S(w(E.entropy?[$,k(e)]:$??T(),3),_),D=new b(_),O=function(){for(var A=D.g(i),z=c,q=0;A<h;)A=(A+q)*r,z*=r,q=D.g(1);for(;A>=d;)A/=2,z/=2,q>>>=1;return(A+q)/z};return O.int32=function(){return D.g(4)|0},O.quick=function(){return D.g(4)/4294967296},O.double=O,S(k(D.S),e),(E.pass||N||function(A,z,q,W){return W&&(W.S&&x(W,D),A.state=function(){return x(D,{})}),q?(s[l]=A,z):A})(O,R,"global"in E?E.global:this==s,E.state)}function b($){var E,N=$.length,_=this,R=0,D=_.i=_.j=0,O=_.S=[];for(N||($=[N++]);R<r;)O[R]=R++;for(R=0;R<r;R++)O[R]=O[D=p&D+$[R%N]+(E=O[R])],O[D]=E;(_.g=function(A){for(var z,q=0,W=_.i,X=_.j,P=_.S;A--;)z=P[W=p&W+1],q=q*r+P[p&(P[W]=P[X=p&X+z])+(P[X]=z)];return _.i=W,_.j=X,q})(r)}function x($,E){return E.i=$.i,E.j=$.j,E.S=$.S.slice(),E}function w($,E){var N=[],_=typeof $,R;if(E&&_=="object")for(R in $)try{N.push(w($[R],E-1))}catch{}return N.length?N:_=="string"?$:$+"\0"}function S($,E){for(var N=$+"",_,R=0;R<N.length;)E[p&R]=p&(_^=E[p&R]*19)+N.charCodeAt(R++);return k(E)}function T(){try{var $;return m&&($=m.randomBytes)?$=$(r):($=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues($)),k($)}catch{var E=t.navigator,N=E&&E.plugins;return[+new Date,t,N,t.screen,k(e)]}}function k($){return String.fromCharCode.apply(0,$)}if(S(s.random(),e),n.exports){n.exports=y;try{m=vX}catch{}}else s["seed"+l]=y})(typeof self<"u"?self:wX,[],Math)})(gm)),gm.exports}var Rx,nN;function CX(){if(nN)return Rx;nN=1;var n=aX(),t=cX(),e=hX(),s=fX(),r=mX(),i=yX(),o=SX();return o.alea=n,o.xor128=t,o.xorwow=e,o.xorshift7=s,o.xor4096=r,o.tychei=i,Rx=o,Rx}var hS=CX();class FD{constructor(t,e,s,r,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=hS.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const l=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*l,e=this.mean+this.stdDev*i*l,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class TX{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=hS.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function kX(n,t=0,e=1,s,r){if(Xi(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new FD(t,e,s,!1,r),o=Qt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const $X=nt({randomNormal_:kX});function EX(n,t=0,e=1,s="float32",r){Xi(n);const i=Qt(n,s),o=new TX(t,e,null,r);for(let l=0;l<i.values.length;l++)i.values[l]=o.nextValue();return i.toTensor()}const ef=nt({randomUniform_:EX});function Vh(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:t,step:e,dtype:s};return J.runKernel(M1,{},r)}function IX(n){const e={input:U(n,"input","real")};return J.runKernel(F1,e)}const Fm=nt({real_:IX});function NX(n){const e={x:U(n,"x","reciprocal")};return J.runKernel(Dd,e)}const AX=nt({reciprocal_:NX});function _X(n){const e={x:U(n,"x","relu")};return J.runKernel(Od,e)}const ll=nt({relu_:_X});function RX(n){const e={x:U(n,"x","relu6")};return J.runKernel(Md,e)}const LD=nt({relu6_:RX});function DX(n,t){const s={x:U(n,"x","reverse")},r={dims:t};return J.runKernel(t0,s,r)}const tl=nt({reverse_:DX});function OX(n){const e={x:U(n,"x","round")};return J.runKernel(Fd,e)}const PD=nt({round_:OX});function MX(n){const e={x:U(n,"x","rsqrt","float32")};return J.runKernel(Ld,e)}const zD=nt({rsqrt_:MX});function FX(n){const e={x:U(n,"x","selu")};return J.runKernel(Pd,e)}const BD=nt({selu_:FX});function LX(n,t,e,s,r,i=[1,1],o="NHWC"){const l=U(n,"x","separableConv2d"),c=U(t,"depthwiseFilter","separableConv2d"),h=U(e,"pointwiseFilter","separableConv2d");let d=l,p=!1;if(l.rank===3&&(p=!0,d=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");L(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),L(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),L(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),L(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),L(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=c.shape[2],y=c.shape[3];L(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=tS(d,c,s,r,o,i),w=Ja(b,h,1,"valid",o);return p?et(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const VD=nt({separableConv2d_:LX});function PX(n){const e={x:U(n,"x","sign")};return J.runKernel(Vd,e)}const zX=nt({sign_:PX});function BX(n){const e={x:U(n,"x","sin","float32")};return J.runKernel(zd,e)}const UD=nt({sin_:BX});function VX(n){const e={x:U(n,"x","sinh")};return J.runKernel(Bd,e)}const jD=nt({sinh_:VX});function UX(n,t,e){const s=U(n,"x","slice1d");return L(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Fe(s,[t],[e])}const dS=nt({slice1d_:UX});function jX(n,t,e){const s=U(n,"x","slice2d");return L(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Fe(s,t,e)}const GD=nt({slice2d_:jX});function GX(n,t,e){const s=U(n,"x","slice3d");return L(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Fe(s,t,e)}const fS=nt({slice3d_:GX});function WX(n,t,e){const s=U(n,"x","slice4d");return L(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Fe(s,t,e)}const Lm=nt({slice4d_:WX});function HX(n,t=-1){const e=U(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},r={dim:t};return J.runKernel(o0,s,r)}const pS=nt({softmax_:HX});function qX(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return J.runKernel(T1,t)}const WD=nt({fft_:qX});function KX(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return J.runKernel(E1,t)}const Hv=nt({ifft_:KX});function XX(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const r=et(n,[e,t]);s=Hv(r)}else{const r=[e,2*(t-1)],i=et(Fm(n),[e,t]),o=et(sS(n),[e,t]),l=tl(Fe(i,[0,1],[e,t-2]),1),c=Y(tl(Fe(o,[0,1],[e,t-2]),1),ve(-1)),h=vs([i,l],1),d=vs([o,c],1),p=et(qa(h,d),[r[0],r[1]]);s=Hv(p)}if(s=Fm(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=et(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const YX=nt({irfft_:XX});function ZX(n,t,e=0){const r={x:U(n,"x","split")},i={numOrSizeSplits:t,axis:e};return J.runKernel(i0,r,i)}const Js=nt({split_:ZX});function JX(n,t){L(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let r;if(t!=null&&t<e){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=t,r=Fe(n,b,x),e=t}else if(t!=null&&t>e){const b=n.shape.map(x=>x);b[n.shape.length-1]=t-e,r=vs([n,Rn(b)],n.shape.length-1),e=t}else r=n;const i=ue(r),o=et(qa(r,i),[s,e]),l=WD(o),c=Math.floor(e/2)+1,h=Fm(l),d=sS(l),p=Js(h,[c,e-c],h.shape.length-1),m=Js(d,[c,e-c],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=c,et(qa(p[0],m[0]),y)}const QX=nt({rfft_:JX});function t9(n,t){let e=U(n,"a","squaredDifference"),s=U(t,"b","squaredDifference");[e,s]=nn(e,s),qt(e.shape,s.shape);const r={a:e,b:s},i={};return J.runKernel(Wd,r,i)}const e9=nt({squaredDifference_:t9});function n9(n,t){const e=U(n,"x","squeeze","string_or_numeric");return et(e,Go(e.shape,t).newShape)}const nf=nt({squeeze_:n9});function s9(n,t=0){const e=dD(n,"tensors","stack","string_or_numeric");L(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&L(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,r={axis:t};return J.runKernel(qg,s,r)}const Wi=nt({stack_:s9});function r9(n,t=0){const s={x:U(n,"x","step")},r={alpha:t};return J.runKernel(Yd,s,r)}const sf=nt({step_:r9});function i9(n,t,e,s,r=0,i=0,o=0,l=0,c=0){const d={x:U(n,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};return J.runKernel(V1,d,p)}const o9=nt({stridedSlice_:i9});function a9(n){const e={x:U(n,"x","tan","float32")};return J.runKernel(qd,e)}const l9=nt({tan_:a9});function Os(n,t){e1(n);const e=Zd(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Jd(n,null,e,t)}function Dx(n,t,e){if(e1(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Zd(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Jd(n,t,s,e)}function c9(n,t,e){if(e1(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Zd(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Jd(n,t,s,e)}function HD(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(i+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function u9(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}HD(e,t,n)}function cl(n,t,e){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=e.length;let o=1;for(let p=r;p<i;++p)o*=e[p];const l=r<1?1:r,c=ft(t.shape)/l,h=[...Ot(e.slice(0,r)),1],d=ft(e);return{sliceRank:r,numUpdates:c,sliceSize:o,strides:h,outputSize:d}}function h9(n,t=1,e=!0){const s=U(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},o={k:t,sorted:e},[l,c]=J.runKernel(U1,i,o);return{values:l,indices:c}}const d9=nt({topk_:h9});function f9(n,t=0,e=1,s,r){if(Xi(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new FD(t,e,s,!0,r),o=Qt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const qD=nt({truncatedNormal_:f9});function p9(n,t=0){const e=U(n,"x","unique","string_or_numeric");L(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},r={axis:t},[i,o]=J.runKernel(G1,s,r);return{values:i,indices:o}}const m9=nt({unique_:p9});function g9(n,t,e){const s=U(n,"x","unsortedSegmentSum"),r=U(t,"segmentIds","unsortedSegmentSum","int32");L(_c(e),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:e};return J.runKernel(l0,i,o)}const KD=nt({unsortedSegmentSum_:g9});function y9(n,t=0){const e=U(n,"x","unstack","string_or_numeric");L(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},r={axis:t};return J.runKernel(a0,s,r)}const el=nt({unstack_:y9});function b9(n,t=!0,e,s){return J.makeVariable(n,t,e,s)}function XD(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const s=Qt(n,"int32"),r=Qt([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=s.indexToLoc(e[i]),l=i*n.length;r.values.set(o,l)}return r.toTensor()}function x9(n,t,e){const s=U(n,"x","transpose");if(t==null&&(t=s.shape.map((o,l)=>l).reverse()),L(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{L(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?rt(()=>{let o=Fm(s),l=sS(s);return o=J.runKernel(kc,{x:o},i),l=J.runKernel(kc,{x:l},i),e&&(l=en(l)),qa(o,l)}):J.runKernel(kc,r,i)}const ce=nt({transpose_:x9});function v9(n,t){if(t==null)return n.shape.slice();if(we(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function w9(n,t,e,s){const r=U(n,"x","dropout");if(L(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),L(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof xn?r.clone():r;const i=v9(r,e),o=1-t,l=Lt(g0(wt(ef(i,0,1,"float32",s),o)),o);return Y(r,l)}const S9=nt({dropout_:w9});function C9(n,t,e,s,r,i="NHWC",o){let l=n;n.rank===3&&(l=et(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=et(t,[1,t.shape[0],t.shape[1],t.shape[2]])),L(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),L(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),L(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const h=i==="NHWC"?l.shape[3]:l.shape[1],d=i==="NHWC"?c.shape[3]:c.shape[1];L(h===e[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${e[2]}.`),L(d===e[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${e[3]}).`),Cs("conv2dDerFilter",r,o);const p={x:l,dy:c},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:e};return J.runKernel(f1,p,m)}const mS=nt({conv2DBackpropFilter_:C9});function gS(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return Y(n,sf(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function yS(n,t){let e=t;const s=Tn(n.shape,t.shape);return s.length>0&&(e=Mt(e,s)),et(e,n.shape)}function bS(n,t,e,s){if(t==="linear")return n;if(t==="relu")return ll(n);if(t==="elu")return p0(n);if(t==="relu6")return LD(n);if(t==="prelu")return uS(n,e);if(t==="leakyrelu")return rS(n,s);if(t==="sigmoid")return Kc(n);throw new Error(`Unknown fused activation ${t}.`)}const xS=(n,t)=>!(n>0)||t==="linear";function T9({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:c="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(c=c||"linear",xS(J.state.gradientDepth,c)===!1){L(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=Ja(n,t,e,s,r,i,o);return l!=null&&(N=wt(N,l)),bS(N,c,h,d)}const p=U(n,"x","conv2d","float32"),m=U(t,"filter","conv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=et(p,[1,p.shape[0],p.shape[1],p.shape[2]])),L(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),L(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Cs("fused conv2d",s,o);const x=r==="NHWC"?y.shape[3]:y.shape[1];L(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),L(ts(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const w=zn(y.shape,m.shape,e,i,s,o);let S;l!=null&&(S=U(l,"bias","fused conv2d"),[S]=nn(S,p),r==="NHWC"?qt(w.outShape,S.shape):(L(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),L(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let T;if(h!=null){const N=h.shape;if(L(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)L(N[0]===1||N[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${w.outChannels}).`);else if(N.length===3)try{qt(N,w.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(R)}T=U(h,"prelu weights","fused conv2d")}const k=(N,_)=>{L(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,D,O,A]=_,z=gS(N,O,c);L(Ya(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const q=J1(D.shape,z,R,e,s),W=mS(D,z,R.shape,e,s),X=[q,W];if(A!=null){const P=yS(A,z);X.push(P)}return X},$={x:y,filter:m,bias:S,preluActivationWeights:T},E={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:c,leakyreluAlpha:d};return l==null?Mc((_,R,D)=>{let O=J.runKernel(Nm,$,E);return D([R,_,O]),b&&(O=et(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:k}})(y,m):Mc((_,R,D,O)=>{let A=J.runKernel(Nm,$,E);return O([R,_,A,D]),b&&(A=et(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:k}})(y,m,S)}const k9=nt({fusedConv2d_:T9});function $9(n,t,e,s,r,i=[1,1],o){let l=n;n.rank===3&&(l=et(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=et(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:l,dy:c},d={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:e};return J.runKernel(v1,h,d)}const E9=nt({depthwiseConv2dNativeBackpropFilter_:$9});function I9(n,t,e,s,r,i=[1,1],o){let l=t,c=!1;t.rank===3&&(c=!0,l=et(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:l,filter:e},d={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},p=J.runKernel(w1,h,d);return c?et(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const N9=nt({depthwiseConv2dNativeBackpropInput_:I9});function A9({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}){if(xS(J.state.gradientDepth,i)===!1){let A=xe(n,t,e,s);return r!=null&&(A=wt(A,r)),bS(A,i,o,l)}let c=U(n,"a","fused matMul"),h=U(t,"b","fused matMul");[c,h]=nn(c,h);const d=e?c.shape[c.rank-2]:c.shape[c.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=e?c.shape[c.rank-1]:c.shape[c.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=c.shape.slice(0,-2),x=h.shape.slice(0,-2),w=ft(b),S=ft(x);L(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${c.shape} and ${h.shape} and transposeA=${e} and transposeB=${s} must match.`);const k=qt(c.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),$=e?et(c,[w,d,m]):et(c,[w,m,d]),E=s?et(h,[S,y,p]):et(h,[S,p,y]);let N;r!=null&&(N=U(r,"bias","fused matMul"),[N]=nn(N,c),qt(k,N.shape));let _;o!=null&&(_=U(o,"prelu weights","fused matMul"));const R=(A,z)=>{const[q,W,X,P]=z,V=gS(et(A,X.shape),X,i);let G,tt;if(!e&&!s?(G=xe(V,W,!1,!0),tt=xe(q,V,!0,!1)):!e&&s?(G=xe(V,W,!1,!1),tt=xe(V,q,!0,!1)):e&&!s?(G=xe(W,V,!1,!0),tt=xe(q,V,!1,!1)):(G=xe(W,V,!0,!0),tt=xe(V,q,!0,!0)),r!=null){const Z=yS(P,V);return[G,tt,Z]}else return[G,tt]},D={a:$,b:E,bias:N,preluActivationWeights:_},O={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:l};return r==null?Mc((z,q,W)=>{const X=J.runKernel(Im,D,O);return W([z,q,X]),{value:et(X,k),gradFunc:R}})($,E):Mc((z,q,W,X)=>{const P=J.runKernel(Im,D,O);return X([z,q,P,W]),{value:et(P,k),gradFunc:R}})($,E,N)}const sN=nt({fusedMatMul_:A9});function _9(n,t,e,s,r="bilinear",i=0){const o=U(n,"image","cropAndResize"),l=U(t,"boxes","cropAndResize","float32"),c=U(e,"boxInd","cropAndResize","int32"),h=l.shape[0];L(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),L(l.rank===2&&l.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${l.shape}.`),L(c.rank===1&&c.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${l.shape}.`),L(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),L(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),L(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:o,boxes:l,boxInd:c},p={method:r,extrapolationValue:i,cropSize:s};return J.runKernel(y1,d,p)}const R9=nt({cropAndResize_:_9});function D9(n){const t=U(n,"image","flipLeftRight","float32");L(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return J.runKernel($1,e,{})}const O9=nt({flipLeftRight_:D9});function M9(n){const t=U(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];L(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),L(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,Br(t,r)}const F9=nt({grayscaleToRGB_:M9});function L9(n){const t=U(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];L(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),L(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,i=Et(t,"float32"),o=Os([.2989,.587,.114]);let l;switch(t.rank){case 2:l=sh("ij,j->i",i,o);break;case 3:l=sh("ijk,k->ij",i,o);break;case 4:l=sh("ijkl,l->ijk",i,o);break;case 5:l=sh("ijklm,m->ijkl",i,o);break;case 6:l=sh("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return l=ys(l,-1),Et(l,r)}const P9=nt({rgbToGrayscale_:L9});function z9(n,t,e=0,s=.5){const r=U(n,"image","rotateWithOffset","float32");L(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:e,center:s};return J.runKernel(W1,i,o)}const B9=nt({rotateWithOffset_:z9});function Yc(n,t,e,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return e=Math.min(e,o),L(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),L(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),L(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),L(t.rank===1,()=>"scores must be a 1D tensor"),L(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),L(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function V9(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppression","float32"),o=U(t,"scores","nonMaxSuppression","float32"),l=Yc(i,o,e,s,r);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const c={maxOutputSize:e,iouThreshold:s,scoreThreshold:r};return J.runKernel(R1,{boxes:i,scores:o},c)}const U9=nt({nonMaxSuppression_:V9});function j9(n,t,e){const s=G9(n,t,e),r=s<0?-(s+1):s;n.splice(r,0,t)}function G9(n,t,e){return H9(n,t,e||W9)}function W9(n,t){return n>t?1:n<t?-1:0}function H9(n,t,e){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const l=e(t,n[i]);l>0?s=i+1:(r=i,o=!l)}return o?s:-s-1}function vS(n,t,e,s,r){return CS(n,t,e,s,r,0)}function wS(n,t,e,s,r,i){return CS(n,t,e,s,r,0,!1,i,!0)}function SS(n,t,e,s,r,i){return CS(n,t,e,s,r,i,!0)}function CS(n,t,e,s,r,i,o=!1,l=!1,c=!1){const h=[];for(let w=0;w<t.length;w++)t[w]>r&&h.push({score:t[w],boxIndex:w,suppressBeginIndex:0});h.sort(rN);const d=i>0?-.5/i:0,p=[],m=[];for(;p.length<e&&h.length>0;){const w=h.pop(),{score:S,boxIndex:T,suppressBeginIndex:k}=w;if(S<r)break;let $=!1;for(let E=p.length-1;E>=k;--E){const N=q9(n,T,p[E]);if(N>=s){$=!0;break}if(w.score=w.score*K9(s,d,N),w.score<=r)break}w.suppressBeginIndex=p.length,$||(w.score===S?(p.push(T),m.push(w.score)):w.score>r&&j9(h,w,rN))}const y=p.length,b=e-y;l&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:p};return o&&(x.selectedScores=m),c&&(x.validOutputs=y),x}function q9(n,t,e){const s=n.subarray(t*4,t*4+4),r=n.subarray(e*4,e*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(l-i)*(c-o),b=(p-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(i,h),w=Math.max(o,d),S=Math.min(l,p),T=Math.min(c,m),k=Math.max(S-x,0)*Math.max(T-w,0);return k/(y+b-k)}function K9(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function rN(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function X9(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=U(n,"boxes","nonMaxSuppressionAsync"),o=U(t,"scores","nonMaxSuppressionAsync"),l=Yc(i,o,e,s,r);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const c=await Promise.all([i.data(),o.data()]),h=c[0],d=c[1],{selectedIndices:p}=vS(h,d,e,s,r);return i!==n&&i.dispose(),o!==t&&o.dispose(),Os(p,"int32")}const Y9=X9;function Z9(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=U(n,"boxes","nonMaxSuppression"),l=U(t,"scores","nonMaxSuppression"),c=Yc(o,l,e,s,r,i);e=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,i=c.softNmsSigma;const h={boxes:o,scores:l},d={maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},p=J.runKernel(O1,h,d);return{selectedIndices:p[0],selectedScores:p[1]}}const J9=nt({nonMaxSuppressionWithScore_:Z9});async function Q9(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=U(n,"boxes","nonMaxSuppressionAsync"),l=U(t,"scores","nonMaxSuppressionAsync"),c=Yc(o,l,e,s,r,i);e=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,i=c.softNmsSigma;const h=await Promise.all([o.data(),l.data()]),d=h[0],p=h[1],{selectedIndices:m,selectedScores:y}=SS(d,p,e,s,r,i);return o!==n&&o.dispose(),l!==t&&l.dispose(),{selectedIndices:Os(m,"int32"),selectedScores:Os(y)}}const t7=Q9;function e7(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=U(n,"boxes","nonMaxSuppression"),l=U(t,"scores","nonMaxSuppression"),c=Yc(o,l,e,s,r,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,m={boxes:o,scores:l},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:i},b=J.runKernel(D1,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const n7=nt({nonMaxSuppressionPadded_:e7});async function s7(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=U(n,"boxes","nonMaxSuppressionAsync"),l=U(t,"scores","nonMaxSuppressionAsync"),c=Yc(o,l,e,s,r,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,[m,y]=await Promise.all([o.data(),l.data()]),{selectedIndices:b,validOutputs:x}=wS(m,y,h,d,p,i);return o!==n&&o.dispose(),l!==t&&l.dispose(),{selectedIndices:Os(b,"int32"),validOutputs:ve(x,"int32")}}const r7=s7;function i7(n,t,e=!1,s=!1){const r=U(n,"images","resizeBilinear");L(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),L(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),L(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=et(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},c={alignCorners:e,halfPixelCenters:s,size:t},h=J.runKernel(Qg,l,c);return o?et(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const YD=nt({resizeBilinear_:i7});function o7(n,t,e=!1,s=!1){const r=U(n,"images","resizeNearestNeighbor");L(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),L(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),L(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),L(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=et(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},c={alignCorners:e,halfPixelCenters:s,size:t},h=J.runKernel(Jg,l,c);return o?et(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ZD=nt({resizeNearestNeighbor_:o7});function a7(n,t="binary",e=!1,s=.5){const r=U(n,"image","threshold"),i=.2989,o=.587,l=.114,c=r.shape[0]*r.shape[1];let h=Y(Os([s]),255),d,p,m,y;if(L(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),L(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),L(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),L(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[d,p,m]=Js(r,[1,1,1],-1);const w=Y(d,i),S=Y(p,o),T=Y(m,l);y=wt(wt(w,S),T)}else y=n;if(t==="otsu"){const w=s8(Et(PD(y),"int32"),Sh([]),256);h=l7(w,c)}const b=e?Xc(y,h):tr(y,h);return Et(Y(b,255),"int32")}function l7(n,t){let e=Os([-1]),s=Os([0]),r=Os([0]),i,o,l,c,h,d;for(let p=0;p<n.size-1;p++){i=Fe(n,0,p+1),o=Fe(n,p+1),h=Lt(Mt(i),t),d=Lt(Mt(o),t);const m=Mt(Y(i,Vh(0,i.size)));l=Lt(m,Mt(i));const y=f0(o.shape,i.size),b=wt(Vh(0,o.size),y),x=Y(o,b);c=Lt(Mt(x),Mt(o));const w=Bt(l,c),S=Bt(l,c),T=Y(h,d);r=Y(Y(T,w),S);const k=tr(r,s);s=ls(k,r,s),e=ls(k,Os([p]),e)}return e}const c7=nt({threshold_:a7});function u7(n,t,e="nearest",s="constant",r=0,i){const o=U(n,"image","transform","float32"),l=U(t,"transforms","transform","float32");L(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),L(l.rank===2&&(l.shape[0]===o.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),L(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const c={image:o,transforms:l},h={interpolation:e,fillMode:s,fillValue:r,outputShape:i};return J.runKernel(j1,c,h)}const h7=nt({transform_:u7});function d7(n,t,e){const s=U(n,"a","bandPart");L(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let l,c;typeof t=="number"?(L(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),L(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),l=U(t<0?i:t,"numLower","bandPart")):(L(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),l=ls(Om(t,0),i,Bh(t,i))),typeof e=="number"?(L(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),L(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),c=U(e<0?o:e,"numUpper","bandPart")):(L(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=ls(Om(e,0),o,Bh(e,o)));const h=et(Vh(0,i,1,"int32"),[-1,1]),d=Vh(0,o,1,"int32"),p=Bt(h,d),m=Gi(Xc(p,l),al(p,en(c))),y=Rn([i,o],s.dtype);return et(Wi(el(et(s,[-1,i,o])).map(b=>ls(m,b,y))),r)}const f7=nt({bandPart_:d7});function p7(n){let t;if(Array.isArray(n)){t=!1,L(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)L(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else t=!0,n=Js(n,n.shape[0],0).map(r=>nf(r,[0]));L(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(J.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const l=Y(Mt(Y(e[o],i)),e[o]);i=Bt(i,l)}return Lt(i,m0(i,"euclidean"))}));return t?Wi(e,0):e}const m7=nt({gramSchmidt_:p7});function g7(n,t=!1){if(L(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return iN(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((c,h)=>c*h),s=el(et(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(c=>{const[h,d]=iN(c,t);r.push(h),i.push(d)});const o=et(Wi(r,0),n.shape),l=et(Wi(i,0),n.shape);return[o,l]}}function iN(n,t=!1){return J.tidy(()=>{L(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=AD(e),i=Ua(n);const o=Dx([[1]],[1,1]);let l=Ua(o);const c=e>=s?s:e;for(let h=0;h<c;++h){const d=i,p=l,m=r;[l,i,r]=J.tidy(()=>{const y=Fe(i,[h,h],[e-h,1]),b=m0(y),x=Fe(i,[h,h],[1,1]),w=ls(tr(x,0),Dx([[-1]]),Dx([[1]])),S=Bt(x,Y(w,b)),T=Lt(y,S);T.shape[0]===1?l=Ua(o):l=vs([o,Fe(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const k=en(Lt(xe(w,S),b)),$=Fe(i,[h,0],[e-h,s]),E=Y(k,l),N=ce(l);if(h===0)i=Bt($,xe(E,xe(N,$)));else{const D=Bt($,xe(E,xe(N,$)));i=vs([Fe(i,[0,0],[h,s]),D],0)}const _=ce(E),R=Fe(r,[0,h],[e,r.shape[1]-h]);if(h===0)r=Bt(R,xe(xe(R,l),_));else{const D=Bt(R,xe(xe(R,l),_));r=vs([Fe(r,[0,0],[e,h]),D],1)}return[l,i,r]}),Zt([d,p,m])}return!t&&e>s&&(r=Fe(r,[0,0],[e,s]),i=Fe(i,[0,0],[s,s])),[r,i]})}const y7=nt({qr_:g7});const Vi={flipLeftRight:O9,grayscaleToRGB:F9,resizeNearestNeighbor:ZD,resizeBilinear:YD,rgbToGrayscale:P9,rotateWithOffset:B9,cropAndResize:R9,nonMaxSuppression:U9,nonMaxSuppressionAsync:Y9,nonMaxSuppressionWithScore:J9,nonMaxSuppressionWithScoreAsync:t7,nonMaxSuppressionPadded:n7,nonMaxSuppressionPaddedAsync:r7,threshold:c7,transform:h7},b7={bandPart:f7,gramSchmidt:m7,qr:y7};const x7=new Map,v7=new Map;class Zc{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class yr{constructor(){this.classNameMap={}}static getMap(){return yr.instance==null&&(yr.instance=new yr),yr.instance}static register(t){yr.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function xt(n,t,e){L(n.className!=null,()=>"Class being registered does not have the static className property defined."),L(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),L(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,r=t+">"+s;return yr.register(n),x7.set(r,n),v7.set(n,r),n}class Zo extends Zc{minimize(t,e=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(s!=null){const o=s.map(l=>({name:l.name,tensor:i[l.name]}));this.applyGradients(o)}else this.applyGradients(i);return Zt(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return TK(t,e)}dispose(){this.iterations_!=null&&Zt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Zo,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class JD extends Zo{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:rt(()=>ue(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:rt(()=>ue(i).variable(o))});const l=Array.isArray(t)?t[r].tensor:t[s];if(l==null)return;const c=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;rt(()=>{const d=wt(Y(c,this.rho),Y(ze(l),1-this.rho)),p=Y(Lt(Qn(wt(h,this.epsilon)),Qn(wt(c,this.epsilon))),l),m=wt(Y(h,this.rho),Y(ze(p),1-this.rho));c.assign(d),h.assign(m);const y=wt(Y(p,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Zt(this.accumulatedGrads.map(t=>t.variable)),Zt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}class QD extends Zo{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:rt(()=>f0(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const l=this.accumulatedGrads[r].variable;rt(()=>{const c=wt(l,ze(o));l.assign(c);const h=wt(Y(Lt(o,Qn(wt(c,J.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Zt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}class tO extends Zo{static get className(){return"Adam"}constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],rt(()=>{this.accBeta1=ve(e).variable(),this.accBeta2=ve(s).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);rt(()=>{const s=Bt(1,this.accBeta1),r=Bt(1,this.accBeta2);e.forEach((i,o)=>{const l=J.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:rt(()=>ue(l).variable(c))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:rt(()=>ue(l).variable(c))});const h=Array.isArray(t)?t[o].tensor:t[i];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedSecondMoment[o].variable,m=wt(Y(d,this.beta1),Y(h,1-this.beta1)),y=wt(Y(p,this.beta2),Y(ze(h),1-this.beta2)),b=Lt(m,s),x=Lt(y,r);d.assign(m),p.assign(y);const w=wt(Y(Lt(b,wt(Qn(x),this.epsilon)),-this.learningRate),l);l.assign(w)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Zt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Zt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),rt(()=>{this.accBeta1.assign(Qa(this.beta1,this.iterations_+1)),this.accBeta2.assign(Qa(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}class eO extends Zo{static get className(){return"Adamax"}constructor(t,e,s,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],rt(()=>{this.iteration=ve(0).variable(),this.accBeta1=ve(e).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);rt(()=>{const s=Bt(1,this.accBeta1),r=Lt(-this.learningRate,wt(Y(this.iteration,this.decay),1));e.forEach((i,o)=>{const l=J.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ue(l).variable(c)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:ue(l).variable(c)});const h=Array.isArray(t)?t[o].tensor:t[i];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedWeightedInfNorm[o].variable,m=wt(Y(d,this.beta1),Y(h,1-this.beta1)),y=Y(p,this.beta2),b=rs(h),x=Xo(y,b);d.assign(m),p.assign(x);const w=wt(Y(Lt(r,s),Lt(m,wt(x,this.epsilon))),l);l.assign(w)}),this.iteration.assign(wt(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Zt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Zt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class TS extends Zo{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const o=J.registeredVariables[s];rt(()=>{const l=wt(Y(this.c,i),o);o.assign(l)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=ci(ve(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class nO extends TS{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=ve(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:rt(()=>ue(i).variable(!1))});const o=this.accumulations[r].variable,l=Array.isArray(t)?t[r].tensor:t[s];l!=null&&rt(()=>{let c;const h=wt(Y(this.m,o),l);this.useNesterov?c=wt(Y(this.c,wt(l,Y(h,this.m))),i):c=wt(Y(this.c,h),i),o.assign(h),i.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Zt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class sO extends Zo{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=J.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:rt(()=>ue(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:rt(()=>ue(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:rt(()=>ue(i).variable(o))});const l=Array.isArray(t)?t[r].tensor:t[s];if(l==null)return;const c=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;rt(()=>{const d=wt(Y(c,this.decay),Y(ze(l),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,m=wt(Y(p,this.decay),Y(l,1-this.decay)),y=Lt(Y(l,this.learningRate),Qn(Bt(d,wt(ze(m),this.epsilon)))),b=wt(Y(h,this.momentum),y);c.assign(d),p.assign(m),h.assign(b);const x=Bt(i,b);i.assign(x)}else{const p=wt(Y(c,this.decay),Y(ze(l),1-this.decay)),m=wt(Y(h,this.momentum),Lt(Y(l,this.learningRate),Qn(wt(p,this.epsilon))));c.assign(p),h.assign(m);const y=Bt(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Zt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Zt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Zt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const w7=[JD,QD,tO,eO,nO,sO,TS];function S7(){for(const n of w7)xt(n)}function oN(n,t,e,s){o(n),e=e??0,s=s??1,l(e,s);let r=0;const i=c=>(c.then(h=>{const d=e+ ++r/n.length*(s-e);return t(d),h}),c);function o(c){L(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function l(c,h){L(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),L(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),L(h>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${h}`)}return Promise.all(n.map(i))}async function C7(n,t){t==null&&(t={});const e=t.fetchFunc==null?ct().platform.fetch:t.fetchFunc,s=n.map(p=>e(p,t.requestInit,{isBinary:!0})),l=(t.onProgress==null?await Promise.all(s):await oN(s,t.onProgress,0,.5)).map(p=>p.arrayBuffer());return t.onProgress==null?await Promise.all(l):await oN(l,t.onProgress,.5,1)}function T7(n,t){var e;const s=t.fetchFunc==null?ct().platform.fetch:t.fetchFunc;let r=0,i;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async o=>{for(var l;r<n.length;){i||(i=(await s(n[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:c,value:h}=await i.read();if(c){r++,i=void 0,(l=t.onProgress)===null||l===void 0||l.call(t,r/n.length);continue}o.enqueue(h);return}o.close()}})}const k7="application/octet-stream",$7="application/json";class kS{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(L(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=ct().platform.fetch,L(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&L(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=L6(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(r)],{type:$7}),"model.json"),t.weightData!=null){const o=Ho.join(t.weightData);e.body.append("model.weights.bin",new Blob([o],{type:k7}),"model.weights.bin")}const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:K1(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=e.modelTopology,r=e.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return z6(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=HI(t.weightsManifest),r=()=>T7(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=E7(e),i=this.weightPathPrefix||s,o=[],l=[];for(const c of t)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):o.push(i+h+r);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(t){const e=await this.getWeightUrls(t),s=HI(t),r=await C7(e,this.loadOptions);return[s,r]}}kS.URL_SCHEME_REGEX=/^https?:\/\//;function E7(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),r=e>t?n.substring(e):"";return[s+"/",r]}function aN(n){return n.match(kS.URL_SCHEME_REGEX)!=null}const rO=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>aN(s)):e=aN(n),e)return iO(n,t)}return null};An.registerSaveRouter(rO);An.registerLoadRouter(rO);function iO(n,t){return new kS(n,t)}function I7(n,t){return iO(n,t)}class Ox{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class N7{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function A7(n,t,e,s){const r=arguments;return new N7(_7(...r))}function _7(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Ox(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ox({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ox({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function $S(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(ft(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,i=r[r.length-1];let o=1;for(let p=0;p<r.length-1;++p)o*=r[p];const l=n.shape,c=r.slice();c.pop();let h=1;for(let p=i;p<e;++p)h*=l[p],c.push(l[p]);const d=[...Ot(n.shape).map(p=>p/h),1].slice(0,i);return[c,o,h,d]}const qv=-2,R7=-1;function ES(n,t,e){const s=n.shape.length;L(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),L(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)L(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function D7(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function IS(n,t,e){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function oO(n,t,e,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<e;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function aO(n,t,e){return e<=n?e:e-(t-1)}function lO(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function O7(n,t,e,s,r,i,o,l,c){const h=n.length;let d=new Array(h),p=new Array(h),m=new Array(h);if(t.length&&e>0){const y=t[0],b=e+1;d=cO(o,y,b,s,n),p=uO(l,y,b,r,n),m=oO(i,y,b,n)}else for(let y=0;y<h;y++)d[y]=dO(o,s,i,n,y,c),p[y]=fO(l,r,i,n,y,c),m[y]=hO(i,y,c);return{begin:d,end:p,strides:m}}function cO(n,t,e,s,r){const i=[...r],o=lO(e,t);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=0;else{const c=aO(t,e,l);let h=s[c];n&1<<c&&(h=0),i[l]=h}return i}function uO(n,t,e,s,r){const i=[...r],o=lO(e,t);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=Number.MAX_SAFE_INTEGER;else{const c=aO(t,e,l);let h=s[c];n&1<<c&&(h=Number.MAX_SAFE_INTEGER),i[l]=h}for(let l=0;l<i.length;l++){const c=r[l];i[l]<0&&(i[l]+=c),i[l]=Wa(0,i[l],r[l])}return i}function hO(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function dO(n,t,e,s,r,i){let o=t[r];const l=e[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),o=Wa(0,o,c-1),o}function fO(n,t,e,s,r,i){let o=t[r];const l=e[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),l>0?o=Wa(0,o,c):o=Wa(-1,o,c-1),o}function NS(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function AS(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function y0(n,t,e){let s;const r=n.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{L(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(r).fill(-1):typeof e=="number"?i=[e,...new Array(r-1).fill(-1)]:e.length<r?i=e.concat(new Array(r-e.length).fill(-1)):i=e,i=i.map((o,l)=>o>=0?o:(L(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,i]}function _S(n,t,e,s,r,i,o,l,c){let h;if(s==null?(h=new Array(t.length),h.fill(1)):h=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:h.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};for(let k=0;k<p.dims;k++)d&&(1<<k&l)!==0&&p.numAddAxisAfterEllipsis++,1<<k&o&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};M7(p,m);let y=!0,b=!0,x=!0;const w=[],S=[];for(let k=0;k<n.length;++k){if(m.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);const $=!!(m.shrinkAxisMask&1<<k),E=n[k];if(E===-1){w.push($?1:-1);continue}const N=[m.beginMask&1<<k,m.endMask&1<<k],_=[m.strides[k]>0?0:-1,m.strides[k]>0?E:E-1];if($&&m.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[k]===1;const R=!!(m.beginMask&1<<k&&m.endMask&1<<k);if(m.beginValid&&m.endValid){if($){const z=m.begin[k]<0?E+m.begin[k]:m.begin[k];if(m.begin[k]=z,m.end[k]=m.begin[k]+1,z<0||z>=E)throw Error(`slice index ${m.begin[k]} of dimension ${k} out of bounds.`)}else m.begin[k]=lN(m.begin[k],0,m.strides[k],E,N,_),m.end[k]=lN(m.end[k],1,m.strides[k],E,N,_);const A=m.strides[k]===1&&m.begin[k]===0&&m.end[k]===E;y=y&&A,b=b&&(k===0&&m.strides[k]===1||A)}else y=y&&m.strides[k]===1&&R,b=b&&(k===0&&m.strides[k]===1||R);let D,O=!1;if(m.beginValid&&m.endValid?(D=m.end[k]-m.begin[k],O=!0):$?(D=1,O=!0):R&&E>=0&&(m.strides[k]<0?D=-E:D=E,O=!0),O){let A;D===0||D<0!=m.strides[k]<0?A=0:A=Math.trunc(D/m.strides[k])+(D%m.strides[k]!==0?1:0),w.push(A)}else w.push(-1)}for(let k=0;k<m.finalShapeGatherIndices.length;++k){const $=m.finalShapeGatherIndices[k];$>=0?S.push(w[$]):$===qv&&S.push(1)}return{finalShapeSparse:S.filter((k,$)=>m.finalShapeGatherIndices[$]!==qv),finalShape:S,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function M7(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(qv),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(R7),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function lN(n,t,e,s,r,i){if(r[t])return e>0?i[t]:i[t+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const F7=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ES,computeFlatOffset:AS,computeOutShape:IS,getNormalizedAxes:O7,isSliceContinous:NS,maskToAxes:D7,parseSliceParams:y0,sliceInfo:_S,startForAxis:dO,startIndicesWithElidedDims:cO,stopForAxis:fO,stopIndicesWithElidedDims:uO,stridesForAxis:hO,stridesWithElidedDims:oO},Symbol.toStringTag,{value:"Module"}));class L7{static sgd(t){return new TS(t)}static momentum(t,e,s=!1){return new nO(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,i=!1){return new sO(t,e,s,r,i)}static adam(t=.001,e=.9,s=.999,r=null){return new tO(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new JD(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,i=0){return new eO(t,e,s,r,i)}static adagrad(t,e=.1){return new QD(t,e)}}const ac=L7;const P7=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function pO(){return new Promise(n=>P7(()=>n()))}function RS(n,t){const e=n[0].length;n.forEach((r,i)=>{L(r.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),L(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<e;o++)L(o===t||r[o]===s[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function ui(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var zr;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(zr||(zr={}));function mO(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let r=1;r<e.length;++r){const i=e[r],o=s[s.length-e.length+r],l=s[o];if(i>=0)if(l>=0){if(l!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${l}`)}else s[o]=i}return s}function gO(n){const t={FIRST_DIM_SIZE:zr.FIRST_DIM_SIZE,VALUE_ROWIDS:zr.VALUE_ROWIDS,ROW_LENGTHS:zr.ROW_LENGTHS,ROW_SPLITS:zr.ROW_SPLITS,ROW_LIMITS:zr.ROW_LIMITS,ROW_STARTS:zr.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function yO(n){return n.length===0?0:n[0]===zr.FIRST_DIM_SIZE?n.length-1:n.length}function bO(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(e,s-1);++r){const i=n[r],o=t[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const DS=30;function b0(n){return n<=DS?n:_v(n,Math.floor(Math.sqrt(n)))}function OS(n,t,e){const s=e*(typeof n=="number"?n:n[0]),r=t*(typeof n=="number"?n:n[1]);return[s,r]}function rf(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/t[o],t[o]]);r=r.concat(n.slice(i+1))}return r}function of(n,t,e=!0){const s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=t*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function af(n,t,e,s=!0){const r=[];s?r.push(n[0]/e):r.push(n[0]*e);for(let i=1;i<n.length;++i)i<=t.length?s?r.push(t[i-1]*n[i]):r.push(n[i]/t[i-1]):r.push(n[i]);return r}function MS(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function FS(n,t,e){const s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}const x0=1.7580993408473768,v0=1.0507009873554805;const LS=.3275911,PS=.254829592,zS=-.284496736,BS=1.421413741,VS=-1.453152027,US=1.061405429;function Hi(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function xO(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function vO(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function wO(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function jS(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function SO(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function CO(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:e,imag:s}}function TO(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const Mx="->",z7=/->/g,cN=",",uN="...";function GS(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(z7,"").length)/Mx.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${Mx}").`);const[s,r]=n.split(Mx);L(s.indexOf(uN)===-1,()=>`The ellipsis notation ("${uN}") is not supported yet.`);const i=s.split(cN),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);l.indexOf(y)===-1&&l.push(y)}for(let m=0;m<s.length;++m){const y=s[m];l.indexOf(y)===-1&&y!==cN&&l.push(y)}const c=new Array(i.length);for(let m=0;m<o;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);c[m]=[];for(let y=0;y<i[m].length;++y)c[m].push(l.indexOf(i[m][y]))}const h=l.length,d=r.length,p=[];for(let m=d;m<h;++m)p.push(m);return{allDims:l,summedDims:p,idDims:c}}function WS(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const s=[];for(let r=0;r<n;++r)e[r]===-1&&s.push(r);return e=e.filter(r=>r!==-1),{permutationIndices:e,expandDims:s}}function HS(n,t,e){const s=new Array(n);for(let r=0;r<e.length;++r){const i=e[r].shape;for(let o=0;o<t[r].length;++o)s[t[r][o]]===void 0?s[t[r][o]]=i[o]:L(s[t[r][o]]===i[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function qS(n,t){const e=n,s=[];let r=0;n.length===0&&e.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<e.length;++o){const l=e[o],c=B7(t,l);for(const h of c)i.indexOf(h)===-1&&(s[o].push(h),i.push(h))}return{path:e,steps:s}}function KS(n){return n.every((t,e)=>t===e)}function B7(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function XS(n,t,e=0){let s=[];if(typeof t=="number")L(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const r=t.reduce((o,l)=>(l===-1&&(o+=1),o),0);L(r<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const o=t.reduce((l,c)=>c>0?l+c:l);t[i]=n.shape[e]-o}L(n.shape[e]===t.reduce((o,l)=>o+l),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function kO(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function $O(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function EO(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function IO(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function NO(n,t){return`size ${n} must be non-negative, not ${t}`}function AO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function _O(n,t){const e=ft(n),s=ft(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function RO(n,t){const e=ft(n),s=ft(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}function Kv(){return"segment ids must be >= 0"}function DO(){return"segment ids are not increasing"}function OO(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function MO(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function FO(n,t){let e=!1,s;for(n<=DS?(s=n,e=!0):s=_v(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=_v(n,s+1);return s}function LO(n,t,e){const s=[],r=n.length;for(let i=0;i<r;i++)i!==t?s.push(n[i]):s.push(e);return s}function YS(n,t,e,s){const r=t.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let p=0;p<s;++p)if(n.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);const o=n.shape[e],l=[];let c=1,h=1,d=1;for(let p=0;p<s;++p)l.push(n.shape[p]),c*=n.shape[p];for(let p=s;p<e;p++)l.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<r;p++)l.push(t.shape[p]);for(let p=e+1;p<i;p++)l.push(n.shape[p]),d*=n.shape[p];return{batchSize:c,sliceSize:d,outerSize:h,dimSize:o,outputShape:l}}const V7=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:YS,computeOutShape:LO,segOpComputeOptimalWindowSize:FO},Symbol.toStringTag,{value:"Module"}));function qi(n){try{return n.map(t=>Lo(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function PO(n){return n.map(t=>Ro(t))}const U7=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:PS,ERF_A2:zS,ERF_A3:BS,ERF_A4:VS,ERF_A5:US,ERF_P:LS,PARALLELIZE_THRESHOLD:DS,get RowPartitionType(){return zr},SELU_SCALE:v0,SELU_SCALEALPHA:x0,applyActivation:bS,assertAndGetBroadcastShape:qt,assertAxesAreInnerMostDims:Bn,assertParamsConsistent:RS,assignToTypedArray:SO,axesAreInnerMostDims:eS,calculateShapes:cl,checkEinsumDimSizes:HS,checkPadOnDimRoundingMode:Cs,combineLocations:ID,combineRaggedTensorToTensorShapes:mO,complexWithEvenIndex:vO,complexWithOddIndex:wO,computeConv2DInfo:zn,computeConv3DInfo:qo,computeDefaultPad:X1,computeDilation2DInfo:Qd,computeOptimalWindowSize:b0,computeOutAndReduceShapes:On,computeOutShape:ui,computePool2DInfo:Tr,computePool3DInfo:Yi,convertConv2DDataFormat:Zi,decodeEinsumEquation:GS,eitherStridesOrDilationsAreOne:ts,expandShapeToKeepDim:hn,exponent:TO,exponents:CO,fromStringArrayToUint8:PO,fromUint8ToStringArray:qi,getAxesPermutation:qe,getBroadcastDims:Oc,getComplexWithIndex:jS,getEinsumComputePath:qS,getEinsumPermutation:WS,getFusedBiasGradient:yS,getFusedDyActivation:gS,getImageCenter:OS,getInnerMostAxes:sn,getPermuted:of,getRaggedRank:yO,getReductionAxes:Tn,getReshaped:rf,getReshapedPermuted:af,getRowPartitionTypesHelper:gO,getSliceBeginCoords:MS,getSliceSize:FS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:kO,getSparseFillEmptyRowsNegativeIndexErrorMessage:$O,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:EO,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:AO,getSparseReshapeInputOutputMismatchErrorMessage:RO,getSparseReshapeInputOutputMultipleErrorMessage:_O,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:IO,getSparseReshapeNegativeOutputDimErrorMessage:NO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:MO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Kv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:DO,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:OO,getUndoAxesPermutation:Ko,isIdentityPermutation:KS,log:e6,mergeRealAndImagArrays:Hi,prepareAndValidate:$S,prepareSplitSize:XS,segment_util:V7,shouldFuse:xS,slice_util:F7,splitRealAndImagArrays:xO,stridesOrDilationsArePositive:Za,tupleValuesAreOne:Ya,upcastType:Ms,validateDefaultValueShape:bO,validateInput:u9,validateUpdateShape:HD,warn:Ys},Symbol.toStringTag,{value:"Module"}));S7();const zO={kernelName:ug,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,sf(Et(e,"float32"),-1))}}};const j7={kernelName:nd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ze(Et(e,"float32")),r=Qn(Bt(ve(1),s));return en(Lt(n,r))}}}};const G7={kernelName:sd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Qn(Bt(ze(Et(e,"float32")),1));return Lt(n,s)}}}};const W7={kernelName:qc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{let l=n;const c=Tn(e.shape,r);return c.length>0&&(l=Mt(l,c)),et(l,e.shape)},b:()=>{let l=n;const c=Tn(s.shape,r);return c.length>0&&(l=Mt(l,c)),et(l,s.shape)}}}};const H7={kernelName:i1,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}};const q7={kernelName:hg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ue(e)}}};const K7={kernelName:dg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ue(e)}}};const X7={kernelName:rd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Qn(Bt(ve(1),ze(Et(e,"float32")))))}}};const Y7={kernelName:id,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Qn(wt(ve(1),ze(Et(e,"float32"))));return Lt(n,s)}}}};const Z7={kernelName:ld,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=wt(ze(e),ze(s));let c=Y(n,Lt(s,l));const h=Tn(e.shape,r);return h.length>0&&(c=Mt(c,h)),et(c,e.shape)},b:()=>{const l=wt(ze(e),ze(s));let c=en(Y(n,Lt(e,l)));const h=Tn(s.shape,r);return h.length>0&&(c=Mt(c,h)),et(c,s.shape)}}}};const J7={kernelName:od,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,wt(ze(Et(e,"float32")),1))}}};const Q7={kernelName:ad,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Bt(ve(1),ze(Et(e,"float32"))))}}};function tY(n,t,e,s,r,i){const o=U(n,"dy","avgPool3dGrad"),l=U(t,"input","avgPool3dGrad");let c=o,h=l,d=!1;l.rank===4&&(d=!0,c=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=et(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),L(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),L(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),Cs("avgPool3dGrad",r,i);const p={dy:c,input:h},m={filterSize:e,strides:s,pad:r,dimRoundingMode:i},y=J.runKernel(c1,p,m);return d?et(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const eY=nt({avgPool3dGrad_:tY});const nY={kernelName:pg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:l}=e;return{x:()=>eY(n,s,r,i,o,l)}}};function sY(n,t,e,s,r){const i=U(n,"dy","avgPoolGrad"),o=U(t,"input","avgPoolGrad");L(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let l=o,c=i,h=!1;o.rank===3&&(h=!0,l=et(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=et(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),L(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);const d={dy:c,input:l},p={filterSize:e,strides:s,pad:r},m=J.runKernel(l1,d,p);return h?et(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const rY=nt({avgPoolGrad_:sY});const iY={kernelName:fg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o}=e;return{x:()=>rY(n,s,r,i,o)}}};const oY={kernelName:mg,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:i,transposeB:o}=e;return!i&&!o?{a:()=>xe(n,r,!1,!0),b:()=>xe(s,n,!0,!1)}:!i&&o?{a:()=>xe(n,r,!1,!1),b:()=>xe(n,s,!0,!1)}:i&&!o?{a:()=>xe(r,n,!1,!0),b:()=>xe(s,n,!1,!1)}:{a:()=>xe(r,n,!0,!0),b:()=>xe(n,s,!0,!0)}}};const aY={kernelName:gg,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>cS(n,s,r)}}};const lY={kernelName:Z5,gradFunc:(n,t,e)=>{const s=e,r=s.inputShape,i=s.shape,o=Array.from(i);for(let c=r.length-1;c>=0;c--)if(r[c]===i[c])o[c]=1;else if(r[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const l=[];for(let c=0;c<o.length;c++)o[c]>1&&l.push(c);return{x:()=>Mt(n,l,!0)}}};const cY={kernelName:cd,gradFunc:n=>({x:()=>n.clone()})};const uY={kernelName:ud,gradFunc:n=>({x:()=>ue(n)})};const hY={kernelName:hd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=e;return{x:()=>ls(Gi(al(s,r),Xc(s,i)),n,ue(n))}}};const dY={kernelName:yg,inputsToSave:["x"],gradFunc:zO.gradFunc};const fY={kernelName:bg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(c=>c.shape),{axis:r}=e,i=te(r,t[0].shape)[0],o=s.map(c=>c[i]);return Js(n,o,i).map(c=>()=>c)}};const pY={kernelName:xg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:i,strides:o,pad:l,dataFormat:c}=e;return L(Ya(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>J1(s.shape,n,r,o,l,c),filter:()=>mS(s,n,r.shape,o,l,c)}}};const mY={kernelName:vg,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c}=e;return{dy:()=>Ja(n,r,i,o,l,1,c),filter:()=>mS(n,s,r.shape,i,o,l,c)}}};function gY(n,t,e,s,r){let i=n;n.rank===4&&(i=et(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;o.rank===4&&(o=et(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),L(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),L(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),L(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),L(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),L(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const l={x:i,dy:o},c={strides:s,pad:r,filterShape:e};return J.runKernel(p1,l,c)}const yY=nt({conv3DBackpropFilter_:gY});const bY={kernelName:wg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i}=e;L(Ya(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,l]=t;return{x:()=>TD(o.shape,n,l,r,i),filter:()=>yY(o,n,l.shape,r,i)}}};const xY={kernelName:dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(en(UD(Et(e,"float32"))),n)}}};const vY={kernelName:fd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(jD(Et(e,"float32")),n)}}};const wY={kernelName:Sg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:i,reverse:o}=e;return{x:()=>{const l=qe([r],s.rank);let c=$D(n,r,i,!o);return l!=null&&(c=ce(c,l)),c}}}};const SY={kernelName:Cg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=e,l=s??[1,1];L(Ya(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);const[c,h]=t;return L(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),L(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),L(c.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),L(ts(r,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${l}'.`),Cs("depthwiseConv2d",i,o),{x:()=>N9(c.shape,n,h,r,i,l,o),filter:()=>E9(c,n,h.shape,r,i,l,o)}}};const CY={kernelName:Tg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>J.runKernel(Rv,i,e),filter:()=>J.runKernel(Dv,o,e)}}};const TY={kernelName:md,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>J.runKernel(C1,s)}}};const kY={kernelName:gd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Y(mi(en(ze(e))),2/Math.sqrt(Math.PI));return{x:()=>Y(n,s)}}};const $Y={kernelName:yd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,e)}}};const EY={kernelName:$g,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>et(n,e.shape)}}};const IY={kernelName:bd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,mi(e))}}};const NY={kernelName:xd,gradFunc:n=>({x:()=>ue(n)})};const AY={kernelName:vd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Lt(n,Et(s,"float32")),c=Tn(e.shape,r);return c.length>0?et(Mt(l,c),e.shape):l},b:()=>{let l=Y(n,Et(e,"float32"));const c=Tn(s.shape,r);c.length>0&&(l=et(Mt(l,c),s.shape));const h=ze(s);return en(Lt(l,Et(h,"float32")))}}}};const _Y={kernelName:Eg,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,i,o,l]=t,c=l??ve(1),h=Tn(i.shape,r.shape),d=[];if(i.rank===1){for(let $=0;$<r.shape.length-1;++$)d.push(r.shape[$]);d.push(1)}const p=Bt(r,i),m=Y(n,c),y=zD(wt(o,ve(s))),b=Y(Y(Y(y,y),y),ve(-.5));return{x:()=>i.rank===1?et(Y(Y(n,Br(et(y,[1,1,1,i.shape[0]]),d)),c),r.shape):et(Y(Y(n,y),c),r.shape),mean:()=>{let $=Y(Y(y,ve(-1)),m);return i.rank===1&&($=Mt($,h)),et($,i.shape)},variance:()=>{let $=Y(Y(b,p),m);return i.rank===1&&($=Mt($,h)),et($,i.shape)},scale:()=>{const $=Y(p,y);let E=Y(n,$);return i.rank===1&&(E=Mt(E,h)),et(E,i.shape)},offset:()=>{let $=n;return i.rank===1&&($=Mt($,h)),et($,i.shape)}}}};const RY={kernelName:Ig,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:i,batchDims:o}=e,l=te(i,s.shape)[0],c=(h,d,p)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,l),x=b.length,w=m.slice(i,m.length).slice(1),S=w.length,T=hN(0,x),k=hN(x+1,x+1+S),$=dN([b,[y],w]),E=et(p,$),N=et(d,[y]),_=dN([[x],T,k]),R=ce(E,_);let D=KD(R,N,h.shape[l]);const O=Ko(_);return D=ce(D,O),D};if(o===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>Wi(d.map((y,b)=>c(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:c(s,r,n),indices:()=>r}}};function hN(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function dN(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const DY={kernelName:wd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>ue(e),b:()=>ue(s)}}};const OY={kernelName:Sd,gradFunc:n=>({x:()=>Et(n,"float32")})};const MY={kernelName:Cd,gradFunc:n=>({x:()=>ue(n)})};const FY={kernelName:Td,gradFunc:n=>({x:()=>ue(n)})};const LY={kernelName:kd,gradFunc:n=>({x:()=>ue(n)})};const PY={kernelName:Ag,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,i=tr(s,0);return{x:()=>ls(i,n,Y(n,r))}}};const zY={kernelName:Ed,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,wt(e,1))}}};const BY={kernelName:$d,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Et(e,"float32"))}}};const VY={kernelName:Q5,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const o=mi(s);return Bt(n,Y(Mt(n,r,!0),o))}}}};function UY(n,t,e,s=5,r=1,i=1,o=.5){const l={x:n,y:t,dy:e},c={depthRadius:s,bias:r,alpha:i,beta:o};return J.runKernel(N1,l,c)}const jY=nt({localResponseNormalizationBackprop_:UY});const GY={kernelName:Fg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:i,bias:o,alpha:l,beta:c}=e;return{x:()=>jY(s,r,n,i,o,l,c)}}};function BO(n,t,e,s){return t.rank<e.rank&&(t=et(t,hn(t.shape,s))),n.rank<e.rank&&(n=et(n,hn(n.shape,s))),{x:()=>Y(n,Et(pi(e,t),n.dtype))}}const fN={kernelName:Lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,i=t[0],o=t[1],l=te(r,i.shape),c=BO(n,o,i,l);return{x:()=>c.x()}}};const WY={kernelName:Id,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Y(n,Et(al(e,s),"float32")),b:()=>Y(n,Et(Om(e,s),"float32"))}}};function HY(n,t,e,s,r,i,o){const l=U(n,"dy","maxPool3dGrad"),c=U(t,"input","maxPool3dGrad"),h=U(e,"output","maxPool3dGrad");let d=l,p=c,m=h,y=!1;c.rank===4&&(y=!0,d=et(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=et(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),m=et(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),L(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),L(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),L(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Cs("maxPool3dGrad",i,o);const b={dy:d,input:p,output:m},x={filterSize:s,strides:r,pad:i,dimRoundingMode:o},w=J.runKernel(_1,b,x);return y?et(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const qY=nt({maxPool3dGrad_:HY});const KY={kernelName:zg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=e;return{x:()=>qY(n,s,r,i,o,l,c)}}};function XY(n,t,e,s,r,i,o){const l=U(n,"dy","maxPoolGrad"),c=U(t,"input","maxPoolGrad"),h=U(e,"output","maxPoolGrad");L(c.rank===l.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${l.rank})`),L(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),L(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),Cs("maxPoolGrad",i,o);const d={dy:l,input:c,output:h},p={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return J.runKernel(A1,d,p)}const YY=nt({maxPoolGrad_:XY});const ZY={kernelName:Pg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:l}=e;return{x:()=>YY(n,s,r,i,o,l)}}};const JY={kernelName:Bg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,i=te(r,s.shape),l=On(s.shape,i)[1],c=ft(l);return{x:()=>{const d=s.shape.slice();i.forEach(y=>{d[y]=1});const p=et(n,d);return Lt(Y(p,Yo(s.shape,"float32")),c)}}}};const QY={kernelName:Vg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[i,o]=t,l=te(r,i.shape),c=BO(n,o,i,l);return{x:()=>c.x()}}};const tZ={kernelName:Nd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Y(n,Et(Xc(e,s),"float32")),b:()=>Y(n,Et(tr(e,s),"float32"))}}};const eZ={kernelName:Ug,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Fe(n,i,s.shape)}}};const nZ={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Tn(e.shape,r);return l.length>0?et(Mt(n,l),e.shape):n},b:()=>{const l=Y(n,en(g0(Lt(e,s)))),c=Tn(s.shape,r);return c.length>0?et(Mt(l,c),s.shape):l}}}};const sZ={kernelName:_d,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Y(n,Et(s,"float32")),c=Tn(e.shape,r);return c.length>0?et(Mt(l,c),e.shape):l},b:()=>{const l=Y(n,Et(e,"float32")),c=Tn(s.shape,r);return c.length>0?et(Mt(l,c),s.shape):l}}}};const rZ={kernelName:jg,gradFunc:n=>({x:()=>en(n)})};const iZ={kernelName:Hg,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Rn(e.shape,"float32")}}};const oZ={kernelName:Wg,gradFunc:n=>({x:()=>ue(n)})};const aZ={kernelName:qg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return el(n,s).map(i=>()=>i)}};const pN={kernelName:Kg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Fe(n,i,s.shape)}}};const lZ={kernelName:Rd,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,i=e,o=s,l=qt(i.shape,o.shape);return{a:()=>{const d=Et(o,"float32");let p=Y(n,Y(d,Qa(i,Bt(d,ve(1)))));const m=Tn(i.shape,l);return m.length>0&&(p=Mt(p,m)),et(p,i.shape)},b:()=>{const d=tr(i,0),p=ls(d,gi(i),ue(i));let m=Y(n,Y(r,p));const y=Tn(o.shape,l);return y.length>0&&(m=Mt(m,y)),et(m,o.shape)}}}};const cZ={kernelName:Xg,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=tr(e,0);return{x:()=>ls(r,n,Y(n,s)),alpha:()=>{let i=ls(r,ue(n),Y(n,e));const o=Tn(s.shape,n.shape);return o.length>0&&(i=Mt(i,o)),et(i,s.shape)}}}};function uZ(n,t,e){const s=n.shape.slice();s[e]=1;const r=et(t,s),i=Wv(n,e,!0,!1),o=Wv(n,e,!0,!0),l=Y(i,o);return Y(r,l)}function hZ(n,t,e){const s=n.shape.length,r=s-e.length,i=qe(e,s);let o=n;i!=null&&(o=ce(n,i));const l=o.shape.slice(),h=l.splice(s-e.length,e.length).reduce((m,y)=>m*y,1);l.push(h);const d=o.reshape(l);let p=uZ(d,t,r);if(p=p.reshape(o.shape),i!=null){const m=Ko(i);p=ce(p,m)}return p}const dZ={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let i=[];return r==null?i=s.shape.map((o,l)=>l):typeof r=="number"?i=[r]:i=r,{x:()=>hZ(s,n,i)}}};const fZ={kernelName:pd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Lt(n,Et(s,"float32")),c=Tn(e.shape,r);return c.length>0?et(Mt(l,c),e.shape):l},b:()=>{let l=Y(n,Et(e,"float32"));const c=Tn(s.shape,r);c.length>0&&(l=et(Mt(l,c),s.shape));const h=ze(s);return en(Lt(l,Et(h,"float32")))}}}};const pZ={kernelName:Dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,en(ze(e)))}}};const mZ={kernelName:Md,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Y(Xc(e,6),sf(e));return{x:()=>Y(n,Et(s,"float32"))}}};const gZ={kernelName:Od,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Et(sf(e),"float32"))}}};const yZ={kernelName:Zg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,e.shape)}}};const bZ={kernelName:Qg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>J.runKernel(P1,r,e)}}};const xZ={kernelName:Jg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>J.runKernel(L1,r,e)}}};const vZ={kernelName:t0,gradFunc:(n,t,e)=>{const{dims:s}=e,r=te(s,n.shape);return{x:()=>tl(n,r)}}};const wZ={kernelName:Fd,gradFunc:n=>({x:()=>ue(n)})};const SZ={kernelName:Ld,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>en(Lt(n,Y(Qa(e,1.5),2)))}}};const CZ={kernelName:e0,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Et(ue(e),"float32"),t:()=>Y(n,Et(e,n.dtype)),e:()=>Y(n,Et(iS(e),n.dtype))}}};const TZ={kernelName:Pd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=tr(e,ve(0)),r=ve(x0),i=ve(v0),o=Y(n,i),l=Y(Y(n,r),mi(Et(e,"float32")));return ls(s,o,l)}}}};const kZ={kernelName:Ud,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Y(e,Bt(ve(1),e)))}}};const $Z={kernelName:Vd,gradFunc:n=>({x:()=>ue(n)})};const EZ={kernelName:zd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(Q1(Et(e,"float32")),n)}}};const IZ={kernelName:Bd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(kD(Et(e,"float32")),n)}}};const NZ={kernelName:n0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:i}=e,o=s.shape,[l,c]=y0(s,r,i),h=[];for(let d=0;d<n.rank;d++)h.push([l[d],o[d]-l[d]-c[d]]);return{x:()=>lS(n,h)}}};const AZ={kernelName:o0,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,i=!0,o=Y(n,s);return{logits:()=>Bt(o,Y(Mt(o,[r],i),s))}}};const _Z={kernelName:jd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Kc(e))}}};const mN={kernelName:r0,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>Z1(n,s,r)}}};const gN={kernelName:i0,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>vs(n,s)}}};const RZ={kernelName:Gd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Y(Qn(Et(e,"float32")),2))}}};const DZ={kernelName:z1,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Y(Et(e,"float32"),2))}}};const OZ={kernelName:Wd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=ve(2);return{a:()=>Y(n,Y(r,Bt(e,s))),b:()=>Y(n,Y(r,Bt(s,e)))}}};const MZ={kernelName:Yd,gradFunc:n=>({x:()=>ue(n)})};const FZ={kernelName:Hd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{let l=n;const c=Tn(e.shape,r);return c.length>0&&(l=Mt(l,c)),et(l,e.shape)},b:()=>{let l=n;const c=Tn(s.shape,r);return c.length>0&&(l=Mt(l,c)),et(en(l),s.shape)}}}};const LZ={kernelName:s0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:i}=e;te(i,s.shape).forEach(h=>{r[h]=1});const l=et(n,r),c=Y(l,Yo(s.shape,"float32"));return{x:()=>c}}};const PZ={kernelName:qd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,ze(Q1(e)))}}};const zZ={kernelName:Kd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(Bt(ve(1),ze(e)),n)}}};const BZ={kernelName:Xd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let o=ue(s);if(s.rank===1)for(let l=0;l<r[0];++l)o=wt(o,Fe(n,[l*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)o=wt(o,Fe(n,[l*s.shape[0],c*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let h=0;h<r[2];++h)o=wt(o,Fe(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let h=0;h<r[2];++h)for(let d=0;d<r[3];++d)o=wt(o,Fe(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};const VZ={kernelName:kc,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,i=Ko(r);return{x:()=>ce(n,i)}}};const UZ={kernelName:a0,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>Wi(n,r)}}};const jZ={kernelName:l0,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>GZ(n,e)}}};function GZ(n,t){const e=Xo(t,ue(t)),s=nS(n,e);let r=al(t,ve(0,"int32"));const i=s.rank-r.rank;for(let l=0;l<i;++l)r=ys(r,l+1);r=Gi(r,Yo(s.shape,"bool"));const o=ue(s);return ls(r,s,o)}const WZ={kernelName:c0,gradFunc:n=>({x:()=>ue(n)})};const HZ=[zO,j7,G7,W7,H7,q7,K7,X7,Y7,Z7,J7,Q7,nY,iY,oY,aY,lY,cY,uY,hY,dY,fY,mY,pY,bY,xY,vY,wY,SY,CY,fZ,TY,kY,$Y,EY,IY,AY,NY,_Y,RY,DY,OY,MY,FY,LY,PY,zY,BY,VY,GY,fN,fN,WY,KY,ZY,JY,QY,tZ,eZ,nZ,sZ,rZ,iZ,oZ,aZ,pN,pN,lZ,cZ,dZ,pZ,mZ,gZ,yZ,bZ,xZ,vZ,wZ,SZ,CZ,TZ,kZ,$Z,EZ,IZ,NZ,AZ,_Z,mN,mN,gN,gN,RZ,OZ,DZ,MZ,FZ,LZ,PZ,zZ,BZ,VZ,UZ,jZ,WZ];for(const n of HZ)n6(n);dt().prototype.abs=function(){return this.throwIfDisposed(),rs(this)};dt().prototype.acos=function(){return this.throwIfDisposed(),gq(this)};dt().prototype.acosh=function(){return this.throwIfDisposed(),bq(this)};dt().prototype.add=function(n){return this.throwIfDisposed(),wt(this,n)};dt().prototype.all=function(n,t){return this.throwIfDisposed(),wD(this,n,t)};dt().prototype.any=function(n,t){return this.throwIfDisposed(),jv(this,n,t)};dt().prototype.argMax=function(n){return this.throwIfDisposed(),Lh(this,n)};dt().prototype.argMin=function(n){return this.throwIfDisposed(),Cq(this,n)};dt().prototype.asScalar=function(){return this.throwIfDisposed(),L(this.size===1,()=>"The array must have only 1 element."),et(this,[])};dt().prototype.asType=function(n){return this.throwIfDisposed(),Et(this,n)};dt().prototype.as1D=function(){return this.throwIfDisposed(),et(this,[this.size])};dt().prototype.as2D=function(n,t){return this.throwIfDisposed(),et(this,[n,t])};dt().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),et(this,[n,t,e])};dt().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),et(this,[n,t,e,s])};dt().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),et(this,[n,t,e,s,r])};dt().prototype.asin=function(){return this.throwIfDisposed(),kq(this)};dt().prototype.asinh=function(){return this.throwIfDisposed(),Eq(this)};dt().prototype.atan=function(){return this.throwIfDisposed(),Nq(this)};dt().prototype.atan2=function(n){return this.throwIfDisposed(),_q(this,n)};dt().prototype.atanh=function(){return this.throwIfDisposed(),Dq(this)};dt().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),Y1(this,n,t,e,s)};dt().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Z1(this,n,t)};dt().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),d0(this,n,t,e,s,r)};dt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Ch(this,n)};dt().prototype.cast=function(n){return this.throwIfDisposed(),Et(this,n)};dt().prototype.ceil=function(){return this.throwIfDisposed(),o8(this)};dt().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Qs(this,n,t)};dt().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof xn&&(n=[n]),vs([this,...n],t)};dt().prototype.conv1d=function(n,t,e,s,r,i){return this.throwIfDisposed(),SD(this,n,t,e,s,r,i)};dt().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),CD(this,n,t,e,s,r)};dt().prototype.conv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),Ja(this,n,t,e,s,r,i)};dt().prototype.cos=function(){return this.throwIfDisposed(),Q1(this)};dt().prototype.cosh=function(){return this.throwIfDisposed(),kD(this)};dt().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Wv(this,n,t,e)};dt().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),$D(this,n,t,e)};dt().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),_8(this,n,t)};dt().prototype.depthwiseConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),tS(this,n,t,e,s,r,i)};dt().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),O8(this,n,t,e,s,r)};dt().prototype.divNoNan=function(n){return this.throwIfDisposed(),z8(this,n)};dt().prototype.div=function(n){return this.throwIfDisposed(),Lt(this,n)};dt().prototype.dot=function(n){return this.throwIfDisposed(),V8(this,n)};dt().prototype.elu=function(){return this.throwIfDisposed(),p0(this)};dt().prototype.equal=function(n){return this.throwIfDisposed(),pi(this,n)};dt().prototype.erf=function(){return this.throwIfDisposed(),ED(this)};dt().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),Q8(this,n,t)};dt().prototype.exp=function(){return this.throwIfDisposed(),mi(this)};dt().prototype.expandDims=function(n){return this.throwIfDisposed(),ys(this,n)};dt().prototype.expm1=function(){return this.throwIfDisposed(),sK(this)};dt().prototype.fft=function(){return this.throwIfDisposed(),WD(this)};dt().prototype.flatten=function(){return this.throwIfDisposed(),et(this,[this.size])};dt().prototype.floor=function(){return this.throwIfDisposed(),g0(this)};dt().prototype.floorDiv=function(n){return this.throwIfDisposed(),vD(this,n)};dt().prototype.gather=function(n,t,e){return this.throwIfDisposed(),nS(this,n,t,e)};dt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),al(this,n)};dt().prototype.greater=function(n){return this.throwIfDisposed(),tr(this,n)};dt().prototype.ifft=function(){return this.throwIfDisposed(),Hv(this)};dt().prototype.irfft=function(){return this.throwIfDisposed(),YX(this)};dt().prototype.isFinite=function(){return this.throwIfDisposed(),dK(this)};dt().prototype.isInf=function(){return this.throwIfDisposed(),pK(this)};dt().prototype.isNaN=function(){return this.throwIfDisposed(),gK(this)};dt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),rS(this,n)};dt().prototype.lessEqual=function(n){return this.throwIfDisposed(),Xc(this,n)};dt().prototype.less=function(n){return this.throwIfDisposed(),Om(this,n)};dt().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),wK(this,n,t,e,s)};dt().prototype.logSigmoid=function(){return this.throwIfDisposed(),IK(this)};dt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),RD(this,n)};dt().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),DD(this,n,t)};dt().prototype.log=function(){return this.throwIfDisposed(),gi(this)};dt().prototype.log1p=function(){return this.throwIfDisposed(),_D(this)};dt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Gi(this,n)};dt().prototype.logicalNot=function(){return this.throwIfDisposed(),iS(this)};dt().prototype.logicalOr=function(n){return this.throwIfDisposed(),OD(this,n)};dt().prototype.logicalXor=function(n){return this.throwIfDisposed(),FK(this,n)};dt().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),xe(this,n,t,e)};dt().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),oS(this,n,t,e,s)};dt().prototype.max=function(n,t){return this.throwIfDisposed(),Ur(this,n,t)};dt().prototype.maximum=function(n){return this.throwIfDisposed(),Xo(this,n)};dt().prototype.mean=function(n,t){return this.throwIfDisposed(),un(this,n,t)};dt().prototype.min=function(n,t){return this.throwIfDisposed(),Dm(this,n,t)};dt().prototype.minimum=function(n){return this.throwIfDisposed(),Bh(this,n)};dt().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),GK(this,n,t)};dt().prototype.mod=function(n){return this.throwIfDisposed(),HK(this,n)};dt().prototype.mul=function(n){return this.throwIfDisposed(),Y(this,n)};dt().prototype.neg=function(){return this.throwIfDisposed(),en(this)};dt().prototype.norm=function(n,t,e){return this.throwIfDisposed(),m0(this,n,t,e)};dt().prototype.notEqual=function(n){return this.throwIfDisposed(),Mm(this,n)};dt().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),MD(this,n,t,e)};dt().prototype.onesLike=function(){return this.throwIfDisposed(),Cr(this)};dt().prototype.pad=function(n,t){return this.throwIfDisposed(),lS(this,n,t)};dt().prototype.pool=function(n,t,e,s,r,i){return this.throwIfDisposed(),nX(this,n,t,e,s,r,i)};dt().prototype.pow=function(n){return this.throwIfDisposed(),Qa(this,n)};dt().prototype.prelu=function(n){return this.throwIfDisposed(),uS(this,n)};dt().prototype.prod=function(n,t){return this.throwIfDisposed(),iX(this,n,t)};dt().prototype.reciprocal=function(){return this.throwIfDisposed(),AX(this)};dt().prototype.relu=function(){return this.throwIfDisposed(),ll(this)};dt().prototype.relu6=function(){return this.throwIfDisposed(),LD(this)};dt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),et(this,n.shape)};dt().prototype.reshape=function(n){return this.throwIfDisposed(),et(this,n)};dt().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),YD(this,n,t,e)};dt().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),ZD(this,n,t,e)};dt().prototype.reverse=function(n){return this.throwIfDisposed(),tl(this,n)};dt().prototype.rfft=function(){return this.throwIfDisposed(),QX(this)};dt().prototype.round=function(){return this.throwIfDisposed(),PD(this)};dt().prototype.rsqrt=function(){return this.throwIfDisposed(),zD(this)};dt().prototype.selu=function(){return this.throwIfDisposed(),BD(this)};dt().prototype.separableConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),VD(this,n,t,e,s,r,i)};dt().prototype.sigmoid=function(){return this.throwIfDisposed(),Kc(this)};dt().prototype.sign=function(){return this.throwIfDisposed(),zX(this)};dt().prototype.sin=function(){return this.throwIfDisposed(),UD(this)};dt().prototype.sinh=function(){return this.throwIfDisposed(),jD(this)};dt().prototype.slice=function(n,t){return this.throwIfDisposed(),Fe(this,n,t)};dt().prototype.softmax=function(n){return this.throwIfDisposed(),pS(this,n)};dt().prototype.softplus=function(){return this.throwIfDisposed(),tf(this)};dt().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),cS(this,n,t)};dt().prototype.split=function(n,t){return this.throwIfDisposed(),Js(this,n,t)};dt().prototype.sqrt=function(){return this.throwIfDisposed(),Qn(this)};dt().prototype.square=function(){return this.throwIfDisposed(),ze(this)};dt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),e9(this,n)};dt().prototype.squeeze=function(n){return this.throwIfDisposed(),nf(this,n)};dt().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof xn?[this,n]:[this,...n];return Wi(e,t)};dt().prototype.step=function(n){return this.throwIfDisposed(),sf(this,n)};dt().prototype.stridedSlice=function(n,t,e,s,r,i,o,l){return this.throwIfDisposed(),o9(this,n,t,e,s,r,i,o,l)};dt().prototype.sub=function(n){return this.throwIfDisposed(),Bt(this,n)};dt().prototype.sum=function(n,t){return this.throwIfDisposed(),Mt(this,n,t)};dt().prototype.tan=function(){return this.throwIfDisposed(),l9(this)};dt().prototype.tanh=function(){return this.throwIfDisposed(),h0(this)};dt().prototype.tile=function(n){return this.throwIfDisposed(),Br(this,n)};dt().prototype.toBool=function(){return this.throwIfDisposed(),Et(this,"bool")};dt().prototype.toFloat=function(){return this.throwIfDisposed(),Et(this,"float32")};dt().prototype.toInt=function(){return this.throwIfDisposed(),Et(this,"int32")};dt().prototype.topk=function(n,t){return this.throwIfDisposed(),d9(this,n,t)};dt().prototype.transpose=function(n){return this.throwIfDisposed(),ce(this,n)};dt().prototype.unique=function(n){return this.throwIfDisposed(),m9(this,n)};dt().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),KD(this,n,t)};dt().prototype.unstack=function(n){return this.throwIfDisposed(),el(this,n)};dt().prototype.where=function(n,t){return this.throwIfDisposed(),ls(n,this,t)};dt().prototype.zerosLike=function(){return this.throwIfDisposed(),ue(this)};class ni extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ni.prototype)}}class xr extends Error{constructor(t){super(t),Object.setPrototypeOf(this,xr.prototype)}}class H extends Error{constructor(t){super(t),Object.setPrototypeOf(this,H.prototype)}}class Xt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Xt.prototype)}}class ZS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ZS.prototype)}}class VO{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function nl(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function si(n,t){if(!n)throw new ZS(t)}function yN(n,t){let e=0;for(const s of n)s===t&&e++;return e}function bs(n){return n.length===1?n[0]:n}function Te(n){return Array.isArray(n)?n:[n]}function zi(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Da(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let dr={};function JS(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function Xv(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>Xv(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:Xv(s))}}}function lf(n,t={},e={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in e)o=e[i];else if(i in dr)o=dr[i];else if(o=t[i],o==null)throw new H(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new H(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let l,c;if(o in e?[l,c]=e[o]:o in dr?[l,c]=dr.className:o in t&&([l,c]=t[o]),l==null)throw new H(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const h={};for(const y of Object.keys(dr))h[y]=dr[y];for(const y of Object.keys(e))h[y]=e[y];const d=i.config;d.customObjects=h;const p=Object.assign({},dr);for(const y of Object.keys(e))dr[y]=e[y];Xv(i.config);const m=c(l,i.config,e,r);return dr=Object.assign({},p),m}else{const h=Object.assign({},dr);for(const p of Object.keys(e))dr[p]=e[p];const d=new l(i.config);return dr=Object.assign({},h),d}}}function qZ(n,t){return n<t?-1:n>t?1:0}function qp(n,t){return-1*qZ(n,t)}function Do(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function KZ(n){if(n==null)throw new H(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function ul(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new H(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function QS(n,t,e=0,s=1/0){return si(e>=0),si(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function Dn(n,t){Array.isArray(n)?(L(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Dn(e,`element ${s+1} of ${t}`))):L(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${UO(n)}.`)}function UO(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>UO(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function XZ(n,t,e){let s=e!=null?e():gs(),r;return(...o)=>{const l=e!=null?e():gs();return l-s<t||(s=l,r=n(...o)),r}}function jO(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let YZ=0;function GO(){return YZ++}const Kp={};function w0(n=""){return n in Kp||(Kp[n]=0),Kp[n]+=1,n+Kp[n].toString()}const ZZ=["channelsFirst","channelsLast"],JZ=["nearest","bilinear"],QZ=["valid","same","causal"],tJ=["max","avg"],eJ=["sum","mul","concat","ave"];const lc=new Map;function rn(n){ul(ZZ,"DataFormat",n)}function nJ(n){ul(JZ,"InterpolationFormat",n)}function er(n){ul(QZ,"PaddingMode",n)}function WO(n){ul(tJ,"PoolMode",n)}const Th=[],bN="/";function ja(n,t){Th.push(n);try{const e=t();return Th.pop(),e}catch(e){throw Th.pop(),e}}function sJ(){return Th.length===0?"":Th.join(bN)+bN}function HO(n){if(!KO(n))throw new Error("Not a valid tensor name: '"+n+"'");return sJ()+n}function qO(n){if(!KO(n))throw new Error("Not a valid tensor name: '"+n+"'");lc.has(n)||lc.set(n,0);const t=lc.get(n);if(lc.set(n,lc.get(n)+1),t>0){const e=`${n}_${t}`;return lc.set(e,1),e}else return n}const rJ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function KO(n){return!!n.match(rJ)}function iJ(n){return n===parseInt(n.toString(),10)}function Oo(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function Fc(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function Po(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function Gr(n,t){if(t<n)throw new H(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let Fx;function vn(){return Fx==null&&(Fx=N6().epsilon()),Fx}function Wr(){return"channelsLast"}function hi(n,t){return Et(n,t)}function cf(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),et(n,e)}function oJ(n,t){return rt(()=>{if(n.shape.length!==2)throw new H(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=cf(n,1);return Yv(e,[1,t,1])})}function aJ(n){const t=[Oo(n.shape)];return et(n,t)}function lJ(n){if(n.rank<=1)throw new H(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Oo(n.shape,1)];return et(n,t)}function Ga(n,t,e){return rt(()=>{switch(n.rank){case 1:return dS(n,t,e);case 2:return GD(n,[t,0],[e,n.shape[1]]);case 3:return fS(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Lm(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Fe(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Fe(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new H(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Lx(n,t,e){return rt(()=>{switch(n.rank){case 1:return dS(n,t,e);case 2:return GD(n,[0,t],[n.shape[0],e]);case 3:return fS(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Lm(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Xp(n,t,e,s){return rt(()=>{switch(n.rank){case 1:return dS(n,t,e);case 2:switch(s){case 1:return Ga(n,t,e);case 2:return Lx(n,t,e);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ga(n,t,e);case 2:return fS(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return Lx(n,t,e);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ga(n,t,e);case 2:return Lm(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Lm(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return Lx(n,t,e);default:throw new H(`The axis is not within the rank of the tensor ${s}`)}default:throw new H(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function tC(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),vs(n,t)}function xN(n,t){switch(n.rank){case 1:return c8([n,t]);case 2:return h8([n,t],0);case 3:return f8([n,t],0);case 4:return m8([n,t],0);default:throw new H(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Yv(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new H(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Br(n,t)}function S0(n,t=0,e=1,s,r){return $X(n,t,e,s,r)}function di(n,t,e,s){if(n.rank<2||t.rank<2)throw new Xt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=n.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new Xt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return sN({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Zv(n.rank,s,Wr()):null,activation:e});{const r=n.shape.slice(),i=r.pop();n=et(n,[-1,i]);const o=t.shape.slice(),l=o.pop(),c=o.pop(),h=[...o,l],d=Array.from({length:t.rank},(b,x)=>x===0?t.rank-2:x<=t.rank-2?x-1:x);t=et(ce(t,d),[c,-1]);const p=[...r,...h];return et(sN({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Zv(n.rank,s,Wr()):null,activation:e}),p)}}function XO(n,t,e){return rt(()=>(Array.isArray(t)?t=Os(t,"int32"):t=Et(t,"int32"),nS(n,t,e)))}function uf(n){return Y(n,n)}function Zv(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new H(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?et(t,[1,s[0],1,1,1]):et(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?et(t,[1,1,1,1,s[0]]):et(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?et(t,[1,s[0],1,1]):et(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?et(t,[1,1,1,s[0]]):et(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?et(t,[1,s[0],1]):et(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?et(t,[1,1,s[0]]):et(t,[1].concat(s))}else if(n<3)return t;throw new H(`Unsupported input rank by biasAdd: ${t.rank}`)}function qr(n,t,e){return rt(()=>(e==null&&(e=Wr()),rn(e),wt(n,Zv(n.rank,t,e))))}function cJ(n,t=1){if(t!==1)throw new Xt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return p0(n)}function uJ(n){return rt(()=>Lt(n,wt(rs(n),1)))}function YO(n,t,e,s){return rt(()=>S9(n,t,e,s))}function hJ(n){return rt(()=>{const t=wt(.5,Y(.2,n));return Qs(t,0,1)})}function hf(n,t,e=!1){return e?n():t()}const dJ=["fanIn","fanOut","fanAvg"],fJ=["normal","uniform","truncatedNormal"];function pJ(n){ul(dJ,"FanMode",n)}function mJ(n){ul(fJ,"Distribution",n)}class kr extends Zc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class ZO extends kr{apply(t,e){return Rn(t,e)}}ZO.className="Zeros";xt(ZO);class eC extends kr{apply(t,e){return Yo(t,e)}}eC.className="Ones";xt(eC);class JO extends kr{constructor(t){if(super(),typeof t!="object")throw new H(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new H(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return rt(()=>Y(ve(this.value),Yo(t,e)))}getConfig(){return{value:this.value}}}JO.className="Constant";xt(JO);class QO extends kr{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ef(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}QO.className="RandomUniform";xt(QO);class tM extends kr{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Xt(`randomNormal does not support dType ${e}.`);return S0(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}tM.className="RandomNormal";xt(tM);class eM extends kr{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Xt(`truncatedNormal does not support dType ${e}.`);return qD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}eM.className="TruncatedNormal";xt(eM);class nM extends kr{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return rt(()=>{if(t.length!==2||t[0]!==t[1])throw new H("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,AD(t[0]))})}getConfig(){return{gain:this.gain}}}nM.className="Identity";xt(nM);function gJ(n,t="channelsLast"){let e,s;if(rn(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const r=Oo(n,2);e=n[1]*r,s=n[0]*r}else if(t==="channelsLast"){const r=Oo(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Oo(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}class Fs extends kr{constructor(t){if(super(),t.scale<0)throw new H(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,pJ(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,mJ(this.distribution),this.seed=t.seed}apply(t,e){const s=gJ(t),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const l=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Xt(`${this.getClassName()} does not support dType ${e}.`);return qD(t,0,l,e,this.seed)}else{const l=Math.sqrt(3*o);return ef(t,-l,l,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Fs.className="VarianceScaling";xt(Fs);class nC extends Fs{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Fs.className}}nC.className="GlorotUniform";xt(nC);class sC extends Fs{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Fs.className}}sC.className="GlorotNormal";xt(sC);class rC extends Fs{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Fs.className}}rC.className="HeNormal";xt(rC);class iC extends Fs{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Fs.className}}iC.className="HeUniform";xt(iC);class oC extends Fs{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Fs.className}}oC.className="LeCunNormal";xt(oC);class aC extends Fs{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Fs.className}}aC.className="LeCunUniform";xt(aC);class sM extends kr{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return rt(()=>{if(t.length<2)throw new Xt("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=ft(t.slice(0,-1)),r=t[t.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],l=S0(o,0,1,e,this.seed),c=b7.qr(l,!1);let h=c[0];const p=c[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return h=Y(h,p.sign()),s<r&&(h=h.transpose()),Y(ve(this.gain),h.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}sM.className="Orthogonal";xt(sM);const vN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function wN(n,t={}){return lf(n,yr.getMap().classNameMap,t,"initializer")}function He(n){return JS(n)}function Ue(n){if(typeof n=="string"){const t=n in vN?vN[n]:n;if(t==="GlorotNormal")return new sC;if(t==="GlorotUniform")return new nC;if(t==="HeNormal")return new rC;if(t==="HeUniform")return new iC;if(t==="LeCunNormal")return new oC;if(t==="LeCunUniform")return new aC;{const e={};return e.className=t,e.config={},wN(e)}}else return n instanceof kr?n:wN(n)}function Jv(n){return Array.isArray(n)&&Array.isArray(n[0])}function Pm(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function jt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new H(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function fe(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new H(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function zm(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,r)=>s*r);return t}const SN="Variable";class yJ{constructor(t,e="float32",s=SN,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=GO(),s=s??SN,this.originalName=HO(s),this.name=qO(this.originalName),this.trainable_=r,this.constraint=i,this.val=b9(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),bJ(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function bJ(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function Qv(n){return n.map(t=>t.read())}function lC(n){n.forEach(t=>{t[0].write(t[1])})}class wn{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class yi{constructor(t,e,s,r,i,o,l){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=l,this.id=GO(),o!=null&&(this.originalName=HO(o),this.name=qO(this.originalName)),this.rank=e.length}}let xJ=0;class C0{constructor(t,e){this.callArgs=e,this.id=xJ++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let vJ=0;class ee extends Zc{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=vJ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=zi(s)+"_"+w0(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new xr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new H(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return bs(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return bs(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ni(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ni(`Layer ${this.name} is not connected, no input to return.`);return bs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ni(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ni(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return bs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=Te(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Te(this.inputSpec);if(e.length!==s.length)throw new H(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let r=0;r<e.length;r++){const i=e[r],o=s[r];if(o==null)continue;const l=i.rank;if(o.ndim!=null&&l!==o.ndim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${l}`);if(o.maxNDim!=null&&l>o.maxNDim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${l}`);if(o.minNDim!=null&&l<o.minNDim)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${l}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new H(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const c=i.shape;for(const h in o.axes){const d=Number(h),p=o.axes[h],m=d>=0?c[d]:c[c.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${c}.`)}}if(o.shape!=null)for(let c=0;c<o.shape.length;++c){const h=o.shape[c],d=i.shape[c];if(h!=null&&d!=null&&h!==d)throw new H(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=Te(t),r=CJ(t),i=TJ(t);if(r===i)throw new H("Arguments to apply() must be all SymbolicTensors or all Tensors");return ja(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const l of Te(t))o.push(l.shape);this.build(bs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const l=Te(o),c=[];for(let h of l)s.indexOf(h)!==-1&&(h=h.clone()),c.push(h);if(o=bs(c),this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=wJ(t),l=this.computeOutputShape(o);let c;const h=SJ(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l!=null&&l.length>0&&Array.isArray(l[0])?c=l.map((d,p)=>new yi(h,d,this,Te(t),e,this.name,p)):c=new yi(h,l,this,Te(t),e,this.name),this.addInboundNode(t,c,null,null,o,l,e),this._refCount++,this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&t[r]!=null&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ni(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new ni(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new xr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Qv(t?this.trainableWeights:this.weights)}setWeights(t){rt(()=>{const e=this.weights;if(e.length!==t.length)throw new H(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],r=Qv(e);for(let i=0;i<r.length;++i){const o=r[i],l=e[i],c=t[i];if(!we(o.shape,c.shape))throw new H(`Layer weight shape ${o.shape} not compatible with provided weight shape ${c.shape}`);s.push([l,c])}lC(s)})}addWeight(t,e,s,r,i,o,l,c){if(this._addedWeightNames.indexOf(t)!==-1)throw new H(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=c!=null?c():Ue("zeros"));const h=r.apply(e,s),d=new yJ(h,s,t,o,l);return h.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),o==null&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Te(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const r=this.computeMask(t,s),i=Te(e),o=Te(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let l=0;l<i.length;l++)i[l].kerasMask=o[l]}addInboundNode(t,e,s,r,i,o,l=null){const c=Te(t);e=Te(e),s=Te(s),r=Te(r),i=Pm(i),o=Pm(o);const h=[],d=[],p=[];for(const m of c)h.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new C0({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:p,inputTensors:c,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},l);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function wJ(n){n=Te(n);const t=[];for(const e of n)t.push(e.shape);return bs(t)}function SJ(n){return"float32"}function rM(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],l=s.inboundLayers[i],c=s.nodeIndices[i],h=rM(o,l,c);for(const d of h)r.indexOf(d)===-1&&r.push(d)}return r}}}function CJ(n){let t=!0;for(const e of Te(n))if(!(e instanceof yi)){t=!1;break}return t}function TJ(n){let t=!0;for(const e of Te(n))if(e instanceof yi){t=!1;break}return t}class df extends ee{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:w0("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new H("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new H("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new H("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const r=new yi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new C0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new H(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}df.className="InputLayer";xt(df);function kJ(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new H("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new df({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function $J(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return Et(t,n.dtype)}catch{throw new H(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class No{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof No)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=$J(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new H(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof yi){if(this.id2Value[t.id]==null)throw new H(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new H(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof yi){if(this.id2Value[t.id]==null)throw new H(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new H(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Zt(this.id2Mask)}}const Bm=new VO,Vm=new VO;function EJ(n){Bm?.setMaxEntries(n),Vm?.setMaxEntries(n)}function hh(n,t,e,s){const r=e==null?!1:e.training,i=Array.isArray(n),o=i?n:[n],l=o.map(b=>b.name),c=[],h=t.names();for(const b of l)h.indexOf(b)!==-1?c.push(t.getValue(b)):c.push(null);const d=l.join(",")+"|"+t.names().sort().join(",");let p=Bm.get(d),m;if(p==null){const b=IJ(o,t);p=b.sorted,m=b.recipientCounts,Bm.put(d,p),Vm.put(d,m)}m={},r||Object.assign(m,Vm.get(d));const y=new No(t);for(let b=0;b<p.length;++b){const x=p[b],w=x.sourceLayer;if(w instanceof df)continue;const S=[],T=[],k=[];let $=!1;for(const D of x.inputs){const O=y.getValue(D),A=y.getMask(D);S.push(O),T.push(A),A!=null&&($=!0),r||(m[D.name]--,m[D.name]===0&&!t.hasKey(D)&&l.indexOf(D.name)===-1&&!O.isDisposed&&D.sourceLayer.stateful!==!0&&k.push(O))}$&&(e=e||{},e.mask=T[0]);const E=Te(w.apply(S,e));let N=null;w.supportsMasking&&(N=w.computeMask(S,T));const _=AJ(x),R=Array.isArray(_)?_:[_];for(let D=0;D<R.length;++D){y.hasKey(R[D])||y.add(R[D],E[D],Array.isArray(N)?N[0]:N);const O=l.indexOf(R[D].name);O!==-1&&(c[O]=E[D])}r||Zt(k)}return y.disposeMasks(),i?c:c[0]}function IJ(n,t){L(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const r=CN(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:l}=CN(i,t);for(const c of o)r.has(c.name)||(e.push(c),r.add(c.name));for(const c in l)s[c]==null&&(s[c]=new Set),l[c].forEach(h=>s[c].add(h))}}return{sorted:e,recipientCounts:NJ(s)}}function NJ(n){const t={};for(const e in n)t[e]=n[e].size;return t}function CN(n,t){const e=new Set,s=[],r={};for(const l of t.names())e.add(l);const i=[],o=[];for(i.push(n);i.length>0;){const l=i[i.length-1];if(e.has(l.name)){i.pop();continue}const c=o[o.length-1]===i.length-1;if(l.inputs.length===0||c)i.pop(),s.push(l),e.add(l.name),c&&o.pop();else{o.push(i.length-1);for(const h of l.inputs)r[h.name]==null&&(r[h.name]=new Set),r[h.name].add(l.name),!e.has(h.name)&&i.push(h)}}return{sorted:s,recipientMap:r}}function AJ(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}const _J=ct();_J.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,EJ);function cC(n,t){return rt(()=>Qn(Mt(Y(n,n),t,!0)))}class ff extends Zc{getConfig(){return{}}}class iM extends ff{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return rt(()=>{const e=cC(t,this.axis),s=Qs(e,0,this.maxValue);return Y(t,Lt(s,wt(vn(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}iM.className="MaxNorm";xt(iM);class oM extends ff{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return rt(()=>Lt(t,wt(vn(),cC(t,this.axis))))}getConfig(){return{axis:this.axis}}}oM.className="UnitNorm";xt(oM);class aM extends ff{apply(t){return ll(t)}}aM.className="NonNeg";xt(aM);class lM extends ff{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return rt(()=>{const e=cC(t,this.axis),s=wt(Y(this.rate,Qs(e,this.minValue,this.maxValue)),Y(1-this.rate,e));return Y(t,Lt(s,wt(vn(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}lM.className="MinMaxNorm";xt(lM);const TN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Sn(n){return JS(n)}function kN(n,t={}){return lf(n,yr.getMap().classNameMap,t,"constraint")}function Cn(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in TN?TN[n]:n,config:{}};return kN(e)}else return n instanceof ff?n:kN(n)}async function Ta(n){if(n==null)return;const t=[],e=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;t.push(o.data()),e.push(r),s.push(o)}}if(t.length>0){const r=await Promise.all(t);for(let i=0;i<r.length;++i)n[e[i]]=r[i][0];Zt(s)}}function cM(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var $N;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})($N||($N={}));const RJ=125;class Uh{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class DJ{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class OJ extends Uh{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const r in e){const i=e[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const l=rt(()=>wt(this.totals[r],Y(i,s)));this.totals[r]=l,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:rt(()=>{const r=Y(Lt(1,this.seen),this.totals[s]);e[s]=r,this.totals[s].dispose(),ci(e[s])}))}}class MJ extends Uh{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const i in this.history){const o=this.history[i];for(let l=0;l<o.length;++l)if(typeof o[l]!="number"){const c=o[l];t.push(c.data()),e.push(i),s.push(l)}}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][s[i]].dispose(),this.history[e[i]][s[i]]=r[i][0]}}class FJ extends Uh{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||pO,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=RJ),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Nv(this.yieldEvery)&&(this.maybeWait=XZ(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const r=[];this.yield!=null&&(await Ta(s),r.push(this.yield(t,e,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ta(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Ta(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ta(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Ta(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Nv(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Ta(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ta(t),await this.trainEnd(t))}}function uM(n,t){return n==null&&(n={}),n instanceof Uh?[n]:Array.isArray(n)&&n[0]instanceof Uh?n:Te(n).map(s=>new FJ(s,t))}class mr{constructor(){}static registerCallbackConstructor(t,e){L(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),mr.checkForDuplicate(e),mr.constructors[t]==null&&(mr.constructors[t]=[]),mr.constructors[t].push(e)}static checkForDuplicate(t){for(const e in mr.constructors)mr.constructors[+e].forEach(r=>{if(r===t)throw new H("Duplicate callback constructor.")})}static clear(){mr.constructors={}}static createCallbacks(t){const e=[];for(const s in mr.constructors){const r=+s;t>=r&&e.push(...mr.constructors[r])}return e.map(s=>new s)}}mr.constructors={};function hM(n,t,e,s,r,i,o,l,c){const h=new MJ,d=[new OJ,...mr.createCallbacks(t)];n!=null&&d.push(...n),d.push(h);const p=new DJ(d);return p.setParams({epochs:e,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:t,doValidation:l,metrics:c}),{callbackList:p,history:h}}function fi(n,t={},e=!1){return lf(n,yr.getMap().classNameMap,t,"layer",e)}function Um(n,t){return rt(()=>{n.dtype!=="float32"&&(n=Et(n,"float32"));const e=Mt(uf(n),t,!0),s=f0(e.shape,vn()),r=Qn(Xo(e,s));return Lt(n,r)})}function T0(n,t){return rt(()=>un(uf(Bt(t,n)),-1))}function uC(n,t){return rt(()=>un(rs(Bt(t,n)),-1))}function hC(n,t){return rt(()=>{const e=Bt(n,t),s=Qs(rs(n),vn(),Number.MAX_VALUE),r=rs(Lt(e,s));return Y(100,un(r,-1))})}function LJ(n,t){return rt(()=>{const e=Qs(t,vn(),Number.MAX_VALUE),s=gi(wt(1,e)),r=Qs(n,vn(),Number.MAX_VALUE),i=gi(wt(1,r));return un(uf(Bt(s,i)),-1)})}function PJ(n,t){return rt(()=>{const e=Xo(0,Bt(1,Y(n,t)));return un(uf(e),-1)})}function zJ(n,t){return rt(()=>{const e=Xo(0,Bt(1,Y(n,t)));return un(e,-1)})}function BJ(n,t){return rt(()=>{const e=Mt(Y(n,t),-1),s=Ur(Y(Bt(1,n),t),-1);return Xo(0,wt(1,Bt(s,e)))})}function VJ(n,t){return rt(()=>{const e=Math.log(2),s=Bt(t,n),r=Bt(wt(s,tf(Y(-2,s))),e);return un(r,-1)})}function jh(n,t,e=!1){return rt(()=>{if(e)t=pS(t);else{const s=Mt(t,t.shape.length-1,!0);t=Lt(t,s)}return t=Qs(t,vn(),1-vn()),en(Mt(Y(Et(n,"float32"),gi(t)),t.shape.length-1))})}function jm(n,t,e=!1){return rt(()=>{const s=Et(g0(aJ(n)),"int32");t=Qs(t,vn(),1-vn());const r=t.shape,i=et(MD(s,r[r.length-1]),r);return jh(i,t,e)})}function UJ(n,t){if(!we(n.shape,t.shape))throw new H(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return rt(()=>{const e=ll(t),s=en(rs(t));return wt(Bt(e,Y(t,n)),_D(mi(s)))})}function k0(n,t){return rt(()=>{let e;return e=Qs(t,vn(),1-vn()),e=gi(Lt(e,Bt(1,e))),un(UJ(n,e),-1)})}function jJ(n,t){return rt(()=>{const e=Qs(n,vn(),1),s=Qs(t,vn(),1);return Mt(Y(n,gi(Lt(e,s))),-1)})}function GJ(n,t){return rt(()=>{const e=gi(wt(vn(),t));return un(Bt(t,Y(n,e)),-1)})}function dM(n,t){return rt(()=>{const e=Um(n,-1),s=Um(t,-1),r=Y(e,s);return en(Mt(r,-1))})}const Gm={meanSquaredError:T0,meanAbsoluteError:uC,meanAbsolutePercentageError:hC,meanSquaredLogarithmicError:LJ,squaredHinge:PJ,hinge:zJ,categoricalHinge:BJ,logcosh:VJ,categoricalCrossentropy:jh,sparseCategoricalCrossentropy:jm,binaryCrossentropy:k0,kullbackLeiblerDivergence:jJ,poisson:GJ,cosineProximity:dM};function Px(n){if(typeof n=="string"){if(n in Gm)return Gm[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new H(t)}else return n}function fM(n,t){return rt(()=>{const e=Y(.5,Cr(t)),s=hi(tr(t,e),n.dtype);return un(pi(n,s),-1)})}function pM(n,t){return rt(()=>hi(pi(Lh(n,-1),Lh(t,-1)),"float32"))}function WJ(n,t){return rt(()=>Et(Mt(Gi(pi(n,1),pi(t,1))),"float32"))}function HJ(n,t){return rt(()=>Et(Mt(Gi(pi(n,0),pi(t,1))),"float32"))}function qJ(n,t){return rt(()=>{const e=WJ(n,t),s=HJ(n,t),r=wt(e,s);return Et(ls(tr(r,0),Lt(e,r),0),"float32")})}function KJ(n,t){return k0(n,t)}function XJ(n,t){return n.rank===t.rank&&(n=nf(n,[n.rank-1])),t=Lh(t,-1),t.dtype!==n.dtype&&(t=Et(t,n.dtype)),Et(pi(n,t),"float32")}const YJ=T0,ZJ=T0,JJ=uC,QJ=uC,tQ=hC,eQ=hC,mM=jh,nQ=dM,gM=jm,Wm={binaryAccuracy:fM,categoricalAccuracy:pM,precision:qJ,categoricalCrossentropy:mM,sparseCategoricalCrossentropy:gM,mse:YJ,MSE:ZJ,mae:JJ,MAE:QJ,mape:tQ,MAPE:eQ,cosine:nQ};function sQ(n){if(typeof n=="string"&&n in Wm)return Wm[n];if(typeof n!="string"&&n!=null)return n;throw new H(`Unknown metric ${n}`)}function Yp(n){if(si(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(Gm))if(Gm[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(Wm))if(Wm[e]===n){t=e;break}return t!==void 0?t:n.name}}function rQ(n){const t={Adagrad:()=>ac.adagrad(.01),Adadelta:()=>ac.adadelta(1,.95,vn()),Adam:()=>ac.adam(.001,.9,.999,vn()),Adamax:()=>ac.adamax(.002,.9,.999,vn(),0),RMSProp:()=>ac.rmsprop(.001,.9,0,vn()),SGD:()=>ac.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new H(`Unknown Optimizer ${n}`)}const EN=1*1024*1024;function IN(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!tw(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>EN&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${EN}.`)}}function tw(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!tw(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!tw(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function iQ(n,t,e,s=console.log){const r=aQ(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(t*d)));let o;if(!r){i.push("Receives inputs"),o=[];for(const d in n.nodesByDepth)o.push(...n.nodesByDepth[d])}s("_".repeat(t)),Hm(i,e,s),s("=".repeat(t));const l=n.layers;for(let d=0;d<l.length;++d)r?lQ(l[d],e,s):cQ(l[d],e,o,s),s((d===l.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const c=oQ(n),h=zm(n.nonTrainableWeights);s(`Total params: ${c+h}`),s(`Trainable params: ${c}`),s(`Non-trainable params: ${h}`),s("_".repeat(t))}function oQ(n){let t;return n.collectedTrainableWeights!=null?t=zm(n.collectedTrainableWeights):t=zm(n.trainableWeights),t}function aQ(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function Hm(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function lQ(n,t,e){let s,r;try{r=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),l=[`${i} (${o})`,r,s,n.countParams().toString()];Hm(l,t,e)}function cQ(n,t,e,s){let r,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const p of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const y=p.inboundLayers[m].name,b=p.nodeIndices[m],x=p.tensorIndices[m];o.push(`${y}[${b}][${x}]`)}const l=n.name,c=n.getClassName(),h=o.length===0?"":o[0],d=[`${l} (${c})`,i,r,n.countParams().toString(),h];Hm(d,t,s);for(let p=1;p<o.length;++p)Hm(["","","","",o[p]],t,s)}function yM(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function qm(n,t){if(n===null)return null;if(typeof n=="string")return Da(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];yM(t,r,i)?e.push(i):e.push(qm(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")e[s]=r;else{const i=Da(s);e[i]=qm(r,i)}}return e}}function ew(n,t){if(n==null)return null;if(typeof n=="string")return zi(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];yM(t,r,i)?e.push(i):e.push(ew(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s],i=zi(s);(s==="name"||s==="className")&&typeof r=="string"?e[i]=r:e[i]=ew(r,s)}return e}}const bM="4.22.0";const uQ=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class Mr extends ee{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=w0(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Do(this.inputs).length!==this.inputs.length)throw new H(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Do(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push($),this.outputLayersTensorIndices.push(E)}for(const T of this.inputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;si($===0,"input layer has >1 nodes"),si(E===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push($),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const k=this.inputLayers[T];if(!(k instanceof df))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${T} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const e={},s={},r={},i={},o={},l=[],c=(T,k,$,E,N,_)=>{(E==null||N==null||_==null)&&(E=T.sourceLayer,N=T.nodeIndex,_=T.tensorIndex);const R=E.inboundNodes[N];if($.indexOf(R)!==-1)throw new xr(`The tensor ${T.name} at layer "${E.name}" is part of a cycle.`);if(k.indexOf(R)!==-1)return;this.containerNodes.add(Mr.nodeKey(E,N)),E.id in o||(o[E.id]=Object.keys(o).length),$.indexOf(R)===-1&&$.push(R);const D=R.inboundLayers.length;for(let O=0;O<D;O++){const A=R.inputTensors[O],z=R.inboundLayers[O],q=R.nodeIndices[O],W=R.tensorIndices[O];c(A,k,$,z,q,W)}for(k.push(R);$.indexOf(R)>=0;)$.splice($.indexOf(R),1);l.push(R)},h=[],d=[];for(const T of this.outputs)c(T,h,d);const p=l.slice().reverse();for(const T of p){s[T.id]=T,T.id in e||(e[T.id]=0);let k=e[T.id];const $=r[T.outboundLayer.id]==null?0:r[T.outboundLayer.id];k=Math.max(k,$),r[T.outboundLayer.id]=k,i[T.outboundLayer.id]=T.outboundLayer,e[T.id]=k;for(let E=0;E<T.inboundLayers.length;E++){const N=T.inboundLayers[E],_=T.nodeIndices[E],R=N.inboundNodes[_],D=e[R.id]==null?0:e[R.id];e[R.id]=Math.max(k+1,D),s[R.id]=R}}const m={};for(const T in e){const k=e[T];k in m||(m[k]=[]),m[k].push(s[T])}const y={};for(const T in r){const k=r[T];k in y||(y[k]=[]),y[k].push(i[T])}let b=Object.keys(y).map(T=>parseInt(T,10)).sort(qp);this.layers=[];for(const T of b){const k=y[T];k.sort(($,E)=>{const N=o[$.id],_=o[E.id];return N<_?-1:N>_?1:0});for(const $ of k)$ instanceof Mr&&this.internalContainerRefs.push($),this.layers.push($)}this.layersByDepth=y,b=Object.keys(m).map(T=>parseInt(T,10)).sort(qp);const x=this.inputs.slice(),w=[];for(const T of b)for(const k of m[T]){const $=k.outboundLayer;if($!=null){for(const E of k.inputTensors)if(x.indexOf(E)===-1)throw new xr(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${$.name}". The following previous layers were accessed without issue: ${w}`);for(const E of k.outputTensors)x.push(E);w.push($.name)}}this.nodesByDepth=m;const S=this.layers.map(T=>T.name);for(const T of S){const k=S.filter($=>$===T).length;if(k!==1)throw new xr(`The name "${T}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new C0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new H("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;const i=uQ(t);i&&this.parseWeights(t);for(const l of this.layers)for(const[c,h]of l.weights.entries()){const d=i?`${h.name.split("/").slice(0,-1).join("/")+"/"}${c}`:h.originalName;if(s[d]!=null)throw new H(`Duplicate weight name: ${d}`);s[d]=h,r++}const o=[];for(const l in t){let c=l;if(s[l]==null){const h=l.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[c]!=null)o.push([s[c],t[l]]);else if(e)throw new H(`Provided weight data has no target variable: ${l}`);delete s[c]}if(e){const l=[];for(const c in s)l.push(c);if(l.length>0)throw new H(`${l.length} of ${r} weights are not set: ${l}`)}lC(o)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==e&&(t[i]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${bM}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=ew(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return rt(()=>{t=Te(t);const s=new No;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return hh(this.outputs,s,e)})}computeMask(t,e){return rt(()=>{t=Te(t);let s;return e==null?s=nl(null,t.length):s=Te(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=Pm(t);if(e.length!==this.inputLayers.length)throw new H(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let l=0;l<e.length;l++){const c=this.inputLayers[l],h=e[l],d=c.name+"_0_0";s[d]=h}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(qp);if(r.length>1)for(const l of r){const c=this.nodesByDepth[l];for(const h of c){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const p=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],S=h.nodeIndices[x],T=h.tensorIndices[x],k=`${w.name}_${S}_${T}`,$=s[k];p.push($)}const m=d.computeOutputShape(bs(p)),y=Pm(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const i=[],o=[];for(let l=0;l<this.outputLayers.length;l++){const c=this.outputLayers[l],h=this.outputLayersNodeIndices[l],d=this.outputLayersTensorIndices[l],p=`${c.name}_${h}_${d}`;o.push(p)}for(let l=0;l<o.length;l++){const c=o[l];si(c in s),i.push(s[c])}return bs(i)}runInternalGraph(t,e){e==null&&(e=nl(null,t.length));const s={};for(let c=0;c<this.inputs.length;++c){const h=this.inputs[c],d=t[c],p=e[c];s[h.id]=[d,p]}const r=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(qp);for(const c of r){const h=this.nodesByDepth[c];for(const d of h){const p=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,S,T,k;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[$,E]=b[0];x.mask==null&&(x.mask=E),T=Te(p.call($,x)),k=Te(p.computeMask($,E)),w=[$],S=[E]}else w=b.map($=>$[0]),S=b.map($=>$[1]),x.mask==null&&(x.mask=S),T=Te(p.call(w,x)),k=Te(p.computeMask(w,S));if(p.activityRegularizer)throw new Xt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let $=0;$<y.length;++$){const E=y[$],N=T[$],_=k[$];s[E.id]=[N,_]}}}}const i=[],o=[],l=[];for(const c of this.outputs){si(c.id in s,`Could not compute output ${c.name} : ${c.id}`);const[h,d]=s[c.id];l.push(h.shape),i.push(h),o.push(d)}return[i,o,l]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof Mr?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Mr.nodeKey(r,i);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new H("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new H(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new H(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return rt(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=Mr.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const l=o.getClassName(),c=o.getConfig(),h=[];for(let p=0;p<o.inboundNodes.length;p++){const m=o.inboundNodes[p],y=Mr.nodeKey(o,p);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const S=m.inboundLayers[w],T=m.nodeIndices[w],k=m.tensorIndices[w],$=Mr.nodeKey(S,T);let E=e[$];E==null&&(E=0),x.push([S.name,E,k,b])}h.push(x)}}}const d={};d.name=o.name,d.className=l,d.config=c,d.inboundNodes=h,s.push(d)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const l=this.inputLayers[o],c=this.inputLayersNodeIndices[o],h=Mr.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=e[h];d==null&&(d=0);const p=this.inputLayersTensorIndices[o];r.push([l.name,d,p])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=Mr.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=e[h];d==null&&(d=0);const p=this.outputLayersTensorIndices[o];i.push([l.name,d,p])}return t.outputLayers=i,t}static fromConfig(t,e,s={},r=!1){const i={},o={};function l(w,S){w.name in o?o[w.name].push(S):o[w.name]=[S]}function c(w,S){const T=[];let k;for(const $ of S){const E=$[0],N=$[1],_=$[2];if(k=$[3]==null?{}:$[3],!(E in i)){l(w,S);return}const R=i[E];if(R.inboundNodes.length<=N){l(w,S);return}const D=R.inboundNodes[N];T.push(D.outputTensors[_])}T.length>0&&w.apply(bs(T),k)}function h(w){const S=w.name,T=fi(w,e.customObjects!=null?e.customObjects:{});T.setFastWeightInitDuringBuild(r),i[S]=T,w.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new H(`Corrupted configuration, expected array for nodeData: ${$}`);l(T,$)})}const d=e.name,p=e.layers;for(const w of p)h(w);for(;!KZ(o);)for(const w of p){const S=i[w.name];if(S.name in o){const T=o[S.name];delete o[S.name];for(const k of T)c(S,k)}}const m=[],y=[],b=e.inputLayers;for(const w of b){const S=w[0],T=w[1],k=w[2];si(S in i);const E=i[S].inboundNodes[T].outputTensors;m.push(E[k])}const x=e.outputLayers;for(const w of x){const S=w[0],T=w[1],k=w[2];si(S in i);const E=i[S].inboundNodes[T].outputTensors;y.push(E[k])}return new t({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new H("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){rt(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function hQ(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return t.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function xM(n,t){return hQ(n,t,"classWeight")}async function vM(n,t,e,s){if(e!=null){const r=rt(()=>{if(n.shape.length===1)return Ua(n);if(n.shape.length===2){if(n.shape[1]>1)return Lh(n,1);if(n.shape[1]===1)return et(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Zt(r);const o=[];return i.forEach(l=>{if(e[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);o.push(e[l])}),Os(o,"float32")}else return null}function dQ(n,t){return Y(n,t)}const fQ=32;function wM(n,t){let e,s;const r=t;e=r.xs,s=r.ys,L(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=NN("input",n.inputNames,e),o=NN("output",n.outputNames,s),l=i[0].shape[0];L(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),L(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<i.length;c++)L(i[c].shape[0]===l,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${i[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);for(let c=0;c<o.length;c++)L(o[c].shape[0]===l,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${o[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function NN(n,t,e){if(e instanceof xn)return[e];if(Array.isArray(e))return L(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(e[r]==null)throw new H(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function pQ(n){if(n.length===3)throw new Xt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function mQ(n,t,e){const s=e.batchesPerEpoch!=null;if(L(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),L(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),L(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),L(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),L(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=e.validationData!=null;let i,o;if(r)if(AN(e.validationData))L(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const w=pQ(e.validationData);i=w.xs,o=w.ys}const l=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let h;r?h=c.slice().concat(c.map(w=>"val_"+w)):h=c.slice();const d=uM(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:y}=hM(d,p,e.epochs,null,null,gQ(t,e),null,r,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=e.initialEpoch==null?0:e.initialEpoch,x=await t.iterator();for(;b<e.epochs;){const w={};await m.onEpochBegin(b);let S=0,T=0;for(s||(x=await t.iterator());!s||S<e.batchesPerEpoch;){const k=await x.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:$,ys:E}=wM(n,k.value),N={};N.batch=T,N.size=$[0].shape[0],await m.onBatchBegin(T,N);const _=[];if(e.classWeight!=null){const O=xM(e.classWeight,n.outputNames);for(let A=0;A<O.length;++A)_.push(await vM(E[A],null,O[A]))}const R=$.concat(E).concat(_),D=l(R);Zt(R);for(let O=0;O<c.length;++O){const A=c[O],z=D[O];N[A]=z,ci(z)}await m.onBatchEnd(T,N),cM(N),T++,S++}if(s?S>=e.batchesPerEpoch:k.done){if(r){let $;AN(e.validationData)?$=Te(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):$=Te(n.evaluate(i,o,{batchSize:e.validationBatchSize==null?fQ:e.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=$[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function gQ(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function AN(n){return typeof n.iterator=="function"}function yQ(n){return typeof n.next=="function"}async function bQ(n,t,e){e=e||{};const s=e.batches!=null,r=n.testFunction;let i=[];if(e.verbose>0)throw new Xt("Verbose mode is not implemented yet.");L(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=yQ(t)?t:await t.iterator();let l=0,c=0;for(;!s||c<e.batches;){const h=await o.next();if(i=rt(()=>{if(h.value){const{xs:d,ys:p}=wM(n,h.value),m=d.concat(p),y=rt(()=>r(m));if(Zt(m),c===0)for(let x=0;x<y.length;++x)i.push(ve(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],S=i[x];i[x]=rt(()=>wt(i[x],Y(b,w))),c>0&&Zt(S)}Zt(y),l+=b,++c}return i}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<i.length;++h){const d=i[h];i[h]=Lt(i[h],l),Zt(d)}return bs(i)}function zx(n){L(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function rh(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Ga(s,t,e-t)):Ga(n,t,e-t)}function nw(n,t){return rt(()=>n==null?null:Array.isArray(n)?n.map(e=>nw(e,t)):XO(n,t.dtype==="int32"?t:Et(t,"int32")))}function Bx(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}function SM(n){const t=[];n instanceof xn&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(cf(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Rr(n,t){if(n==null)return;const e=[];if(t instanceof xn)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(t!=null)for(const r in t){const i=t[r];e.push(i.id)}const s=[];if(n instanceof xn)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{e.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];e.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function xQ(n){return n instanceof xn}function sw(n){return Array.isArray(n)}function _N(n){return!xQ(n)&&!sw(n)}function RN(n,t,e,s=!0,r=""){if(t==null||t.length===0){if(n!=null){let o=!1;if(sw(n)&&n.length>0)o=!0;else if(_N(n)){for(const l in n)if(n.hasOwnProperty(l)){o=!0;break}}else o=!0;if(o)throw new H(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(o=>null);let i;if(_N(n)){n=n,i=[];for(const o of t){if(n[o]==null)throw new H(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(sw(n)){if(n=n,n.length!==t.length)throw new H(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,t.length>1)throw new H(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=SM(i),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const l=i[o];if(l.shape.length!==e[o].length)throw new H(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${l.shape}`);for(let c=0;c<e[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=e[o][c];if(d!=null&&d>=0&&h!==d)throw new H(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${l.shape[0]} examples, each with shape [${l.shape.slice(1,l.shape.length)}] (tensor shape [${l.shape}])`)}}return i}function vQ(n,t,e){const s=Do(n.map(i=>i.shape[0]));s.sort();const r=Do(t.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new H(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new H(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!we(s,r))throw new H(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function wQ(n,t,e){const s=[T0,k0,jh];for(let r=0;r<n.length;++r){const i=n[r],o=t[r],l=e[r];if(o!=null){if(o===jh&&i.shape[i.shape.length-1]===1)throw new H(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const c=i.shape.slice(1),h=l.slice(1);for(let d=0;d<c.length;++d){const p=c[d],m=h[d];if(m!=null&&p!==m)throw new H(`A target Tensor with shape ${i.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function DN(n,t,e,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new H(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new H(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const l=i[o];if(l.shape.length!==e[o].length)throw new H(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let c=0;c<e[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=e[o][c];if(d!=null&&d!==h)throw new H(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function SQ(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let i=e.hasOwnProperty(r)?e[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const CQ="layers-model";class Ec extends Mr{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new H("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");iQ(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=rQ(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Zo))throw new H("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new H(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(Px(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new H(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(l=>Px(l))}else{const o=Px(t.loss);this.outputs.forEach(l=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const l=this.internalOutputShapes[o],c=this.outputNames[o];this.feedOutputNames.push(c),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ja("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([l,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=SQ(t.metrics,this.outputNames),i=(o,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[o]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,o])};ja("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=r[o];(h=>{let p,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[o];w[w.length-1]===1||this.lossFunctions[o]===k0?["accuracy","acc"].indexOf(b)!==-1?m=fM:["crossentropy","ce"].indexOf(b)!==-1&&(m=KJ):this.lossFunctions[o]===jm?["accuracy","acc"].indexOf(b)!==-1?m=XJ:["crossentropy","ce"].indexOf(b)!==-1&&(m=gM):["accuracy","acc"].indexOf(b)!==-1?m=pM:["crossentropy","ce"].indexOf(b)!==-1&&(m=mM);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,p=""+S}else y=sQ(b),p=""+Yp(b);let x;ja(p,()=>{x=y}),i(o,p,x)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const r=s.batchSize==null?32:s.batchSize;zx(r);const o=this.standardizeUserDataXY(t,e,!0,r);try{const l=o[0].concat(o[1]);this.makeTestFunction();const c=this.testFunction,h=this.testLoop(c,l,r,s.verbose,s.steps);return bs(h)}finally{Rr(o[0],t),Rr(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),bQ(this,t,e)}checkNumSamples(t,e,s,r="steps"){let i;if(s!=null){if(i=null,e!=null)throw new H(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new H(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new H("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),r=s?e:[e],i=this.retrieveSymbolicTensors(r),o=new No;if(t instanceof xn&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new H(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)o.add(this.inputs[c],t[c])}else for(const c of this.inputs){const h=t[c.name];if(h==null)throw new H(`No value is provided for the model's input ${c.name}`);o.add(c,h)}const l=hh(i,o);return s?l:l[0]}retrieveSymbolicTensors(t){const e=nl(null,t.length);let s=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(l=>l.name);for(let l=0;l<t.length;++l){const c=o.indexOf(t[l]);if(c!==-1&&(e[l]=i[c],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw e.forEach((i,o)=>{i==null&&r.push(t[o])}),new H(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,s=!1){return rt(()=>{const r=this.checkNumSamples(t);if(s)throw new Xt("Verbose predictLoop() is not implemented yet.");const i=Bx(r,e),o=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)rt(()=>{const h=i[l][0],d=i[l][1],p=rh(t,h,d),m=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)m.push({key:this.inputs[b],value:p[b]});else m.push({key:this.inputs[0],value:p});const y=new No(m);return hh(this.outputs,y)}).forEach((h,d)=>o[d].push(h));return bs(o.map(l=>vs(l,0)))})}predict(t,e={}){const s=SM(t);DN(s,this.inputNames,this.feedInputShapes,!1);try{const r=e.batchSize==null?32:e.batchSize;return zx(r),this.predictLoop(s,r)}finally{Rr(s,t)}}predictOnBatch(t){DN(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,r){if(this.optimizer_==null)throw new xr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const l=this.feedOutputShapes[o];this.feedLossFns[o]===jm?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(t=RN(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=RN(e,this.feedOutputNames,i,!1,"target"),vQ(t,e),wQ(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new H(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,r,i=!0,o){const[l,c]=this.standardizeUserDataXY(t,e,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(r!=null){const d=xM(r,this.outputNames);h=[];for(let p=0;p<d.length;++p)h.push(await vM(c[p],null,d[p]))}return[l,c,h]}testLoop(t,e,s,r=0,i){return rt(()=>{const o=this.checkNumSamples(e,s,i,"steps"),l=[];if(r>0)throw new Xt("Verbose mode is not implemented yet.");if(i!=null)throw new Xt("steps mode in testLoop() is not implemented yet");{const c=Bx(o,s),h=Os(Gr(0,o));for(let d=0;d<c.length;++d){const p=c[d][0],m=c[d][1],y=Ga(h,p,m-p),b=nw(e,y),x=t(b);if(d===0)for(let w=0;w<x.length;++w)l.push(ve(0));for(let w=0;w<x.length;++w){const S=x[w];l[w]=wt(l[w],Y(m-p,S))}}for(let d=0;d<l.length;++d)l[d]=Lt(l[d],o)}return l})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const r=t[s];let i=r;if(yN(t,r)>1){const o=yN(t.slice(0,s),r);i+=`_${o}`}e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],l=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const m=new No(p),y=hh(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let S=w(r[x],y[x]);i[x]!=null&&(S=dQ(S,i[x]));const T=un(S);e.push(T),x===0?b=S:b=wt(b,S)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=e[x];else{const S=this.metricsTensors[x][0],T=this.metricsTensors[x][1];w=un(S(r[T],y[T]))}ci(w),o.push(w)}return b=un(b),this.calculateLosses().forEach(x=>{b=wt(b,x)}),b},c=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(l,!0,c)].concat(o)}}makeTestFunction(){this.testFunction=t=>rt(()=>{const e=[];let s;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let h=0;h<this.inputs.length;++h)o.push({key:this.inputs[h],value:r[h]});const l=new No(o),c=hh(this.outputs,l);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],p=un(d(i[h],c[h]));h===0?s=p:s=wt(s,p),e.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],p=this.metricsTensors[h][1],m=un(d(i[p],c[p]));e.push(m)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,l,c,h,d,p,m;try{const y=s.batchSize==null?32:s.batchSize;zx(y);const x=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,y);r=x[0],i=x[1],m=x[2];let w=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)c=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Xt("validationData including sample weights is not supported yet."):new H(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const O=await this.standardizeUserData(c,h,null,null,!0,y);d=O[0],p=O[1],S=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const D=Math.floor(r[0].shape[0]*(1-s.validationSplit)),O=r[0].shape[0];d=rh(r,D,O),o=r,r=rh(r,0,D),p=rh(i,D,O),l=i,i=rh(i,0,D),S=d.concat(p)}else s.validationSteps!=null&&(w=!0);const T=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),$=this.getDedupedMetricsNames();let E,N;w?(this.makeTestFunction(),E=this.testFunction,N=$.slice().concat($.map(D=>"val_"+D))):(E=null,S=[],N=$.slice());const _=uM(s.callbacks,s.yieldEvery);return await this.fitLoop(k,T,$,y,s.epochs,s.verbose,_,E,S,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,Rr(r,t),Rr(i,e),Rr(o,t),Rr(l,e),Rr(d,c),Rr(p,h),m!=null&&Zt(m)}}async fitLoop(t,e,s,r,i,o,l,c,h,d,p,m,y,b){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(c!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new H("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(e,r,y,"steps_per_epoch");let S;w!=null&&(S=Gr(0,w)),o==null&&(o=1);const{callbackList:T,history:k}=hM(l,o,i,m,w,y,r,x,p);T.setModel(this),this.history=k,await T.onTrainBegin(),this.stopTraining_=!1;for(let $=m;$<i;++$){await T.onEpochBegin($);const E={};if(y!=null)throw new Xt("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Xt("batch shuffling is not implemneted yet");d&&P5(S);const N=Os(S),_=Bx(w,r);for(let R=0;R<_.length;++R){const D={};if(await T.onBatchBegin(R,D),rt(()=>{const O=_[R][0],A=_[R][1],z=Ga(N,O,A-O);D.batch=R,D.size=A-O;const q=nw(e,z),W=t(q);for(let X=0;X<s.length;++X){const P=s[X],V=W[X];D[P]=V,ci(V)}if(R===_.length-1&&x){const X=this.testLoop(c,h,r);for(let P=0;P<s.length;++P){const V=s[P],G=X[P];ci(G),E["val_"+V]=G}}}),await T.onBatchEnd(R,D),cM(D),this.stopTraining_)break}N.dispose()}if(await T.onEpochEnd($,E),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return mQ(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),r=s[0],i=s[1],l=this.makeTrainFunction()(r.concat(i)),c=[];for(const h of l){const d=await h.data();c.push(d[0])}return Zt(l),Rr(s[0],t),Rr(s[1],e),bs(c)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||e.push({name:r[o].originalName,tensor:i[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=UI().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-UI().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=zi(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>zi(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const r of e)if(typeof s[r]=="string")t[r]=zi(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[zi(Yp(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>zi(Yp(t)));{const t={};for(const e in this.metrics)t[e]=zi(Yp(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=qm(t.optimizer_config),s=fi(e);let r;if(typeof t.loss=="string")r=Da(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(o=>Da(o));else if(t.loss!=null){r={};for(const o in t.loss)r[o]=Da(t.loss[o])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(o=>Da(o));else if(t.metrics!=null){i={};for(const o in t.metrics)i[o]=Da(t.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(t,e){if(typeof t=="string"){const h=G6(t);if(h.length===0)throw new H(`Cannot find any save handlers for URL '${t}'`);if(h.length>1)throw new H(`Found more than one (${h.length}) save handlers for URL '${t}'`);t=h[0]}if(t.save==null)throw new H("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await GI(this.getNamedWeights(e)),l={modelTopology:this.toJSON(null,!1),format:CQ,generatedBy:`TensorFlow.js tfjs-layers v${bM}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:p}=await GI(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=F6([s.data,d])}return this.userDefinedMetadata!=null&&(IN(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=s.data,l.weightSpecs=s.specs,t.save(l)}setUserDefinedMetadata(t){IN(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ec.className="Model";xt(Ec);class CM extends Ec{}CM.className="Functional";xt(CM);async function TQ(n,t){if(t==null&&(t={}),typeof n=="string"){const e=W6(n,t);if(e.length===0)e.push(I7(n,t));else if(e.length>1)throw new H(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return kQ(n,void 0,t)}async function kQ(n,t,e){if(e==null&&(e={}),n.load==null)throw new H("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=e.strict==null?!0:e.strict,o=s.weightData!=null&&s.weightSpecs!=null&&i,l=fi(qm(r),t,o),c=s.trainingConfig;if(c!=null&&l.loadTrainingConfig(c),s.userDefinedMetadata!=null&&l.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new H("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=$Q(s.weightData,s.weightSpecs);l.loadWeights(h,i),l.optimizer!=null&&d.length>0&&await l.optimizer.setWeights(d),Zt(h),Zt(d.map(p=>p.tensor))}return l}function $Q(n,t){const e=A6(n,t),s={},r=[];return t.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:e[i.name]}):s[i.name]=e[i.name]}),{modelWeights:s,optimizerWeights:r}}class Gh extends Ec{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:w0("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new H(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof Gh||t instanceof Ec;let s;if(e){if(s=t,s.outputs.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new H("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new H("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=kJ({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new H(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new H("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=rM(this.outputs[0])}this.inboundNodes=[],new C0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:nl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(fe(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ec({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new xr("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new xr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new xr("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new xr("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},r=!1){let i,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new H("Legacy serialization format not supported yet.");i=e}else L(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const l=new t(o);if(!(l instanceof Gh))throw new Xt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of i){const d=fi(c,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(t){if(this.model==null)throw new H("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new H("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}Gh.className="Sequential";xt(Gh);let es=class extends Zc{getConfig(){return{}}};class TM extends es{apply(t,e=1){return cJ(t,e)}}TM.className="elu";xt(TM);class kM extends es{apply(t){return BD(t)}}kM.className="selu";xt(kM);class $M extends es{apply(t){return ll(t)}}$M.className="relu";xt($M);class EM extends es{apply(t){return rt(()=>Bh(6,ll(t)))}}EM.className="relu6";xt(EM);class IM extends es{apply(t){return t}}IM.className="linear";xt(IM);class NM extends es{apply(t){return Kc(t)}}NM.className="sigmoid";xt(NM);class AM extends es{apply(t){return hJ(t)}}AM.className="hardSigmoid";xt(AM);class _M extends es{apply(t){return tf(t)}}_M.className="softplus";xt(_M);class RM extends es{apply(t){return uJ(t)}}RM.className="softsign";xt(RM);class DM extends es{apply(t){return h0(t)}}DM.className="tanh";xt(DM);let dC=class extends es{apply(t,e=-1){return pS(t,e)}};dC.className="softmax";xt(dC);class OM extends es{apply(t,e=-1){return RD(t,e)}}OM.className="logSoftmax";xt(OM);class MM extends es{apply(t){return rt(()=>rt(()=>{const e=Math.sqrt(2),s=Y(.5,wt(1,ED(Lt(t,e))));return Y(t,s)}))}}MM.className="gelu";xt(MM);class FM extends es{apply(t){return rt(()=>Y(.5,Y(t,wt(1,h0(Y(Qn(Lt(2,Math.PI)),wt(t,Y(.044715,Qa(t,3)))))))))}}FM.className="gelu_new";xt(FM);class LM extends es{apply(t){return rt(()=>Y(t,h0(tf(t))))}}LM.className="mish";xt(LM);class PM extends es{apply(t,e=1){return rt(()=>Y(Kc(Y(t,e)),t))}}PM.className="swish";xt(PM);function zo(n){return n.getClassName()}function Vx(n,t={}){return lf(n,yr.getMap().classNameMap,t,"activation")}function Bo(n){if(n==null){const t={};return t.className="linear",t.config={},Vx(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},Vx(t)}else return n instanceof es?n:Vx(n)}function EQ(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class zM extends Zc{}class BM extends zM{constructor(t){super(),EQ(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return rt(()=>{let e=Rn([1]);return this.hasL1&&(e=wt(e,Mt(Y(this.l1,rs(t))))),this.hasL2&&(e=wt(e,Mt(Y(this.l2,uf(t))))),et(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}BM.className="L1L2";xt(BM);const ON={l1l2:"L1L2"};function De(n){return JS(n)}function MN(n,t={}){return lf(n,yr.getMap().classNameMap,t,"regularizer")}function je(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in ON?ON[n]:n,config:{}};return MN(e)}else return n instanceof zM?n:MN(n)}class VM extends ee{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=jt(t);let s=ll(t);return this.maxValue!=null&&(s=Qs(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}VM.className="ReLU";xt(VM);class UM extends ee{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=jt(t);return rS(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}UM.className="LeakyReLU";xt(UM);class jM extends ee{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Ue(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=je(t.alphaRegularizer),this.alphaConstraint=Cn(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new H(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=fe(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)s[r]=t[r];this.inputSpec=[new wn({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=jt(t),uS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:He(this.alphaInitializer),alphaRegularizer:De(this.alphaRegularizer),alphaConstraint:Sn(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}jM.className="PReLU";xt(jM);let GM=class extends ee{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Xt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=jt(t);return p0(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};GM.className="ELU";xt(GM);class WM extends ee{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=jt(t);return Y(s,Et(tr(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}WM.className="ThresholdedReLU";xt(WM);class HM extends ee{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new dC().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return rt(()=>{let s=jt(t);const r=e.mask;if(r!=null){const i=Y(Bt(Yo(s.shape),Et(r,s.dtype)),ve(-1e9));s=wt(s,i)}return this.axis instanceof Array?this.axis.length>1?mi(Bt(s,DD(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}HM.className="Softmax";xt(HM);function Ic(n,t,e){if(typeof n=="number")return nl(n,t);if(n.length!==t)throw new H(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!iJ(r))throw new H(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function jr(n,t,e,s,r=1){if(n==null)return n;const i=t+(t-1)*(r-1);let o;return e==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function ri(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+Po([e-t,0]);else if(s==="same")n=n*t;else throw new H(`Unsupport padding mode: ${s}.`);return n}function fC(n,t){return rt(()=>(rn(t),t==="channelsFirst"?ce(n,[0,2,3,1]):n))}function qM(n,t){return rt(()=>(rn(t),t==="channelsFirst"?ce(n,[0,2,3,4,1]):n))}function IQ(n,t,e,s=1,r="valid",i,o=1){return rt(()=>{if(i==null&&(i=Wr()),rn(i),n.shape.length!==3)throw new H(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new H(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new H(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=ce(n,[0,2,1])),r==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=SD(n,t,s,r==="same"?"same":"valid","NWC",o);return e!=null&&(l=qr(l,e)),l})}function FN(n,t,e,s=[1,1],r="valid",i,o,l=null){return rt(()=>{if(i==null&&(i=Wr()),rn(i),n.rank!==3&&n.rank!==4)throw new H(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new H(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=fC(n,i);if(r==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=k9({x:c,filter:t,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:l}),i==="channelsFirst"&&(c=ce(c,[0,3,1,2])),c})}function NQ(n,t,e,s=[1,1,1],r="valid",i,o){return rt(()=>{if(i==null&&(i=Wr()),rn(i),n.rank!==4&&n.rank!==5)throw new H(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new H(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let l=qM(n,i);if(r==="causal")throw new Xt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=w8(l,t,s,r==="same"?"same":"valid","NDHWC",o),e!=null&&(l=qr(l,e)),i==="channelsFirst"&&(l=ce(l,[0,4,1,2,3])),l})}class $0 extends ee{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$0.verifyArgs(e),this.rank=t,Dn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Xt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ic(e.kernelSize,t,"kernelSize"),this.strides=Ic(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,er(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,rn(this.dataFormat),this.activation=Bo(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Ue(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Cn(e.biasConstraint),this.biasRegularizer=je(e.biasRegularizer),this.activityRegularizer=je(e.activityRegularizer),this.dilationRate=Ic(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new H(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new H(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new H(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(si("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!QS(t.kernelSize,"number",1,3))throw new H(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:zo(this.activation),useBias:this.useBias,biasInitializer:He(this.biasInitializer),biasRegularizer:De(this.biasRegularizer),activityRegularizer:De(this.activityRegularizer),biasConstraint:Sn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Jc extends $0{constructor(t,e){super(t,e),this.kernel=null,Jc.verifyArgs(e),this.filters=e.filters,Dn(this.filters,"filters"),this.kernelInitializer=Ue(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Cn(e.kernelConstraint),this.kernelRegularizer=je(e.kernelRegularizer)}build(t){t=fe(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new H(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return rt(()=>{t=jt(t);let s;const r=this.bias==null?null:this.bias.read(),i=jO(this.activation.getClassName());if(i!=null&&this.rank===2)s=FN(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=IQ(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=FN(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=NQ(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Xt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=fe(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const o=jr(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);e.push(o)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:He(this.kernelInitializer),kernelRegularizer:De(this.kernelRegularizer),kernelConstraint:Sn(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new H(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class pf extends Jc{constructor(t){super(2,t),pf.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!QS(t.kernelSize,"number",1,2))throw new H(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}pf.className="Conv2D";xt(pf);class mf extends Jc{constructor(t){super(3,t),mf.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new H(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}mf.className="Conv3D";xt(mf);class KM extends pf{constructor(t){if(super(t),this.inputSpec=[new wn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=fe(t),t.length!==4)throw new H("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return rt(()=>{let s=jt(t);if(s.shape.length!==4)throw new H(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l;this.dataFormat==="channelsFirst"?(o=2,l=3):(o=1,l=2);const c=r[o],h=r[l],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=ri(c,m,d,this.padding),x=ri(h,y,p,this.padding),w=[i,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=ce(s,[0,2,3,1]));let S=CD(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=ce(S,[0,3,1,2])),this.bias!=null&&(S=qr(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=fe(t);const e=t.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1];return e[s]=this.filters,e[r]=ri(e[r],c,o,this.padding),e[i]=ri(e[i],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}KM.className="Conv2DTranspose";xt(KM);class XM extends mf{constructor(t){if(super(t),this.inputSpec=[new wn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new H(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=fe(t),t.length!==5)throw new H("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new H("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return rt(()=>{let s=jt(t);if(s.shape.length!==5)throw new H(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l,c;this.dataFormat==="channelsFirst"?(c=2,o=3,l=4):(c=1,o=2,l=3);const h=r[c],d=r[o],p=r[l],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],S=this.strides[2],T=ri(h,x,m,this.padding),k=ri(d,w,y,this.padding),$=ri(p,S,b,this.padding),E=[i,T,k,$,this.filters];this.dataFormat!=="channelsLast"&&(s=ce(s,[0,2,3,4,1]));let N=T8(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=ce(N,[0,4,1,2,3])),this.bias!==null&&(N=qr(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=fe(t);const e=t.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const l=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return e[s]=this.filters,e[r]=ri(e[r],d,l,this.padding),e[i]=ri(e[i],p,c,this.padding),e[o]=ri(e[o],m,h,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}XM.className="Conv3DTranspose";xt(XM);class YM extends Jc{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new H("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new H("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new H(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Ue(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=je(e.depthwiseRegularizer),this.depthwiseConstraint=Cn(e.depthwiseConstraint),this.pointwiseInitializer=Ue(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=je(e.pointwiseRegularizer),this.pointwiseConstraint=Cn(e.pointwiseConstraint)}build(t){if(t=fe(t),t.length<this.rank+2)throw new H(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new H(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new wn({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return rt(()=>{t=jt(t);let s;if(this.rank===1)throw new Xt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=ce(t,[0,2,3,1])),s=VD(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=qr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=ce(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=He(this.depthwiseInitializer),t.pointwiseInitializer=He(this.pointwiseInitializer),t.depthwiseRegularizer=De(this.depthwiseRegularizer),t.pointwiseRegularizer=De(this.pointwiseRegularizer),t.depthwiseConstraint=Sn(this.depthwiseConstraint),t.pointwiseConstraint=Sn(this.pointwiseConstraint),t}}YM.className="SeparableConv";class ZM extends YM{constructor(t){super(2,t)}}ZM.className="SeparableConv2D";xt(ZM);class E0 extends Jc{constructor(t){super(1,t),E0.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!QS(t.kernelSize,"number",1,1))throw new H(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}E0.className="Conv1D";xt(E0);class JM extends ee{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return rt(()=>{if(t=jt(t),this.dataFormat==="channelsLast"){const s=Xp(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Xp(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Xp(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Xp(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}JM.className="Cropping2D";xt(JM);class QM extends ee{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,rn(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,nJ(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return rt(()=>{let s=jt(t);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=ce(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],l=this.interpolation==="nearest"?Vi.resizeNearestNeighbor(s,[i,o]):Vi.resizeBilinear(s,[i,o]);return ce(l,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Vi.resizeNearestNeighbor(s,[i,o]):Vi.resizeBilinear(s,[i,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}QM.className="UpSampling2D";xt(QM);function AQ(n,t,e=[1,1],s="valid",r,i){return rt(()=>{r==null&&(r=Wr()),rn(r);let o=fC(n,r);if(n.rank!==4)throw new H(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new H(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=tS(o,t,e,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=ce(o,[0,3,1,2])),o})}class t3 extends $0{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Ue(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Cn(t.depthwiseConstraint),this.depthwiseRegularizer=je(t.depthwiseRegularizer)}build(t){if(t=fe(t),t.length<4)throw new H(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new H(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return rt(()=>{t=jt(t);let s=AQ(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=qr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=fe(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=jr(e,this.kernelSize[0],this.padding,this.strides[0]),o=jr(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,o]:[t[0],i,o,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=He(this.depthwiseInitializer),t.depthwiseRegularizer=De(this.depthwiseRegularizer),t.depthwiseConstraint=Sn(this.depthwiseRegularizer),t}}t3.className="DepthwiseConv2D";xt(t3);function e3(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new H("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),e=r(e),{inputs:n,initialState:t,constants:e}}function n3(n,t,e,s=!1,r,i,o=!1,l=!1){return rt(()=>{const c=t.shape.length;if(c<3)throw new H(`Input should be at least 3D, but is ${c}D.`);const h=[1,0].concat(Gr(2,c));t=ce(t,h),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Et(Et(r,"bool"),"float32"),r.rank===c-1&&(r=ys(r,-1)),r=ce(r,h)),s&&(t=tl(t,0),r!=null&&(r=tl(r,0)));const d=[];let p,m=e;const y=t.shape[0],b=el(t);let x;r!=null&&(x=el(r));for(let S=0;S<y;++S){const T=b[S],k=rt(()=>n(T,m));if(r==null)p=k[0],m=k[1];else{const $=rt(()=>{const E=x[S],N=Bt(Cr(E),E),_=wt(Y(k[0],E),Y(m[0],N)),R=m.map((D,O)=>wt(Y(k[1][O],E),Y(D,N)));return{output:_,newStates:R}});p=$.output,m=$.newStates}l&&d.push(p)}let w;return l&&(w=Wi(d,1)),[p,w,m]})}class Jo extends ee{constructor(t){super(t);let e;if(t.cell==null)throw new H("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new gC({cells:t.cell}):e=t.cell,e.stateSize==null)throw new H("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new wn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Gr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Jv(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let r;if(this.returnSequences?r=[t[0],t[1],s]:r=[t[0],s],this.returnState){const i=[];for(const o of e)i.push([t[0],o]);return[r].concat(i)}else return r}computeMask(t,e){return rt(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Xt("Constants support is not implemented in RNN yet.");Jv(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new wn({shape:[e,null,...s]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!we(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new H(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new wn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){rt(()=>{if(!this.stateful)throw new ni("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Rn([s,r])):this.states_=[Rn([s,this.cell.stateSize])];else if(t==null)Zt(this.states_),this.keptStates!=null&&(Zt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Rn([s,r])):this.states_[0]=Rn([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Zt(this.states_);for(let r=0;r<this.states_.length;++r){const i=t[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,l=[s,o];if(!we(i.shape,l))throw new H(`State ${r} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>ci(r.clone()))})}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=e3(t,s,r,this.numConstants);t=i.inputs,s=i.initialState,r=i.constants;let o=[],l=[];if(s!=null){e.initialState=s,o=o.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new wn({shape:h.shape}));l=l.concat(this.stateSpec)}if(r!=null&&(e.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof yi){const h=[t].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return rt(()=>{const s=e==null?null:e.mask,r=e==null?null:e.training;let i=e==null?null:e.initialState;t=jt(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new H(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:r},h=n3((b,x)=>{const w=this.cell.call([b].concat(x),l);return[w[0],w.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],p=h[1],m=h[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?p:d;return this.returnState?[y].concat(m):y})}getInitialState(t){return rt(()=>{let e=Rn(t.shape);return e=Mt(e,[1,2]),e=cf(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Yv(e,[1,s]):e):this.cell.stateSize>1?[Yv(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Jo.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const r=e.cell,i=fi(r,s);return new t(Object.assign(e,{cell:i}))}}Jo.className="RNN";xt(Jo);class I0 extends ee{}class pC extends I0{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Dn(this.units,"units"),this.activation=Bo(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Ue(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ue(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ue(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=je(t.kernelRegularizer),this.recurrentRegularizer=je(t.recurrentRegularizer),this.biasRegularizer=je(t.biasRegularizer),this.kernelConstraint=Cn(t.kernelConstraint),this.recurrentConstraint=Cn(t.recurrentConstraint),this.biasConstraint=Cn(t.biasConstraint),this.dropout=Fc([1,Po([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Fc([1,Po([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=fe(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return rt(()=>{if(t=t,t.length!==2)throw new H(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>Cr(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>Cr(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,l=this.recurrentDropoutMask;o!=null?i=di(Y(t,o),this.kernel.read()):i=di(t,this.kernel.read()),this.bias!=null&&(i=qr(i,this.bias.read())),l!=null&&(s=Y(s,l));let c=wt(i,di(s,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:He(this.kernelInitializer),recurrentInitializer:He(this.recurrentInitializer),biasInitializer:He(this.biasInitializer),kernelRegularizer:De(this.kernelRegularizer),recurrentRegularizer:De(this.recurrentRegularizer),biasRegularizer:De(this.biasRegularizer),activityRegularizer:De(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),recurrentConstraint:Sn(this.recurrentConstraint),biasConstraint:Sn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}pC.className="SimpleRNNCell";xt(pC);class s3 extends Jo{constructor(t){t.cell=new pC(t),super(t)}call(t,e){return rt(()=>{this.cell.dropoutMask!=null&&(Zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return new t(e)}}s3.className="SimpleRNN";xt(s3);class mC extends I0{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new H("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Dn(this.units,"units"),this.activation=Bo(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Bo(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Ue(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ue(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ue(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=je(t.kernelRegularizer),this.recurrentRegularizer=je(t.recurrentRegularizer),this.biasRegularizer=je(t.biasRegularizer),this.kernelConstraint=Cn(t.kernelConstraint),this.recurrentConstraint=Cn(t.recurrentConstraint),this.biasConstraint=Cn(t.biasConstraint),this.dropout=Fc([1,Po([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Fc([1,Po([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=fe(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return rt(()=>{if(t=t,t.length!==2)throw new H(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>Cr(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>Cr(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h;0<this.dropout&&this.dropout<1&&(t=Y(t,i[0]));let d=di(t,this.kernel.read());this.useBias&&(d=qr(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,o[0]));const p=this.recurrentKernel.read(),[m,y]=Js(p,[2*this.units,this.units],p.rank-1),b=di(r,m),[x,w,S]=Js(d,3,d.rank-1),[T,k]=Js(b,2,b.rank-1);l=this.recurrentActivation.apply(wt(x,T)),c=this.recurrentActivation.apply(wt(w,k));const $=di(Y(c,r),y);h=this.activation.apply(wt(S,$));const E=wt(Y(l,r),Y(wt(1,en(l)),h));return[E,E]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:He(this.kernelInitializer),recurrentInitializer:He(this.recurrentInitializer),biasInitializer:He(this.biasInitializer),kernelRegularizer:De(this.kernelRegularizer),recurrentRegularizer:De(this.recurrentRegularizer),biasRegularizer:De(this.biasRegularizer),activityRegularizer:De(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),recurrentConstraint:Sn(this.recurrentConstraint),biasConstraint:Sn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}mC.className="GRUCell";xt(mC);class r3 extends Jo{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new mC(t),super(t)}call(t,e){return rt(()=>{this.cell.dropoutMask!=null&&(Zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}r3.className="GRU";xt(r3);class N0 extends I0{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Dn(this.units,"units"),this.activation=Bo(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Bo(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Ue(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ue(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ue(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=je(t.kernelRegularizer),this.recurrentRegularizer=je(t.recurrentRegularizer),this.biasRegularizer=je(t.biasRegularizer),this.kernelConstraint=Cn(t.kernelConstraint),this.recurrentConstraint=Cn(t.recurrentConstraint),this.biasConstraint=Cn(t.biasConstraint),this.dropout=Fc([1,Po([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Fc([1,Po([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=fe(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(e=class extends kr{apply(c,h){const d=i.apply([o]),p=new eC().apply([o]),m=i.apply([o*2]);return xN(xN(d,p),m)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return rt(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new H(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>Cr(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>Cr(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=this.recurrentDropoutMask;let c,h,d,p;0<this.dropout&&this.dropout<1&&(t=Y(t,o[0]));let m=di(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,l[0])),m=wt(m,di(r,this.recurrentKernel.read())),this.useBias&&(m=qr(m,this.bias.read()));const[y,b,x,w]=Js(m,4,m.rank-1);c=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=wt(Y(h,i),Y(c,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const S=Y(p,this.activation.apply(d));return[S,S,d]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:He(this.kernelInitializer),recurrentInitializer:He(this.recurrentInitializer),biasInitializer:He(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:De(this.kernelRegularizer),recurrentRegularizer:De(this.recurrentRegularizer),biasRegularizer:De(this.biasRegularizer),activityRegularizer:De(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),recurrentConstraint:Sn(this.recurrentConstraint),biasConstraint:Sn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}N0.className="LSTMCell";xt(N0);class i3 extends Jo{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new N0(t),super(t)}call(t,e){return rt(()=>{this.cell.dropoutMask!=null&&(Zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}i3.className="LSTM";xt(i3);class gC extends I0{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return rt(()=>{t=t;let s=t.slice(1);const r=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?r.push(s.splice(0,l.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=r[l],l===0?o=[t[0]].concat(s):o=[o[0]].concat(s),o=c.call(o,e),i.push(o.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[o[0]].concat(s)})}build(t){Jv(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,r)=>{ja(`RNNCell_${r}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),r)}static fromConfig(t,e,s={}){const r=[];for(const i of e.cells)r.push(fi(i,s));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return Qv(t)}setWeights(t){const e=[];for(const s of this.cells){const r=s.weights.length,i=t.splice(r);for(let o=0;o<s.weights.length;++o)e.push([s.weights[o],i[o]])}lC(e)}}gC.className="StackedRNNCells";xt(gC);function Vo(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(t(),e):YO(t(),e),l=()=>hf(o,t,s);return!r||r<=1?ci(l().clone()):Array(r).fill(void 0).map(l).map(h=>ci(h.clone()))}var _Q=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e};class o3 extends Jo{constructor(t){if(t.unroll)throw new Xt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Xt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new wn({ndim:5})]}call(t,e){return rt(()=>{if(this.cell.dropoutMask!=null&&(Zt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Zt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new H("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return rt(()=>{const{stateSize:e}=this.cell,s=t.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=Rn(i);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){rt(()=>{if(!this.stateful)throw new ni("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new H("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Rn(i)):this.states_=[Rn(i)];else if(t==null)Zt(this.states_),this.keptStates!=null&&(Zt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Rn(i)):this.states_[0]=Rn(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new H(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Zt(this.states_);for(let l=0;l<this.states_.length;++l){const c=t[l],h=i;if(!we(c.shape,h))throw new H(`State ${l} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>ci(l.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:l}=this.cell,c=e==="channelsFirst",h=t[c?3:2],d=t[c?4:3],p=jr(h,r[0],i,o[0],l[0]),m=jr(d,r[1],i,o[1],l[1]);return[...t.slice(0,2),...c?[s,p,m]:[p,m,s]]}}o3.className="ConvRNN2D";class yC extends N0{constructor(t){const{filters:e,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:l}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Dn(this.filters,"filters"),this.kernelSize=Ic(s,2,"kernelSize"),this.kernelSize.forEach(c=>Dn(c,"kernelSize")),this.strides=Ic(r||1,2,"strides"),this.strides.forEach(c=>Dn(c,"strides")),this.padding=i||"valid",er(this.padding),this.dataFormat=o||"channelsLast",rn(this.dataFormat),this.dilationRate=Ic(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Dn(c,"dilationRate"))}build(t){var e;t=fe(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new H(`The channel dimension of the input should be defined. Found ${t[s]}`);const r=t[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;c=new(e=class extends kr{apply(m,y){const b=h.apply([d]),x=Yo([d]),w=h.apply([d*2]);return tC([b,x,w])}},e.className="CustomInit",e)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return rt(()=>{if(t.length!==3)throw new H(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,r=t[0],i=t[1],o=t[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Vo({ones:()=>Cr(r),rate:this.dropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,h=(Z,F,B)=>!F||!F[B]?Z:Y(F[B],Z);let d=h(r,c,0),p=h(r,c,1),m=h(r,c,2),y=h(r,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Vo({ones:()=>Cr(i),rate:this.recurrentDropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(i,b,0),w=h(i,b,1),S=h(i,b,2),T=h(i,b,3);const k=3,[$,E,N,_]=Js(this.kernel.read(),l,k),[R,D,O,A]=this.useBias?Js(this.bias.read(),l):[null,null,null,null];d=this.inputConv(d,$,R,this.padding),p=this.inputConv(p,E,D,this.padding),m=this.inputConv(m,N,O,this.padding),y=this.inputConv(y,_,A,this.padding);const[z,q,W,X]=Js(this.recurrentKernel.read(),l,k);x=this.recurrentConv(x,z),w=this.recurrentConv(w,q),S=this.recurrentConv(S,W),T=this.recurrentConv(T,X);const P=this.recurrentActivation.apply(wt(d,x)),V=this.recurrentActivation.apply(wt(p,w)),G=wt(Y(V,o),Y(P,this.activation.apply(wt(m,S)))),tt=Y(this.recurrentActivation.apply(wt(y,T)),this.activation.apply(G));return[tt,tt,G]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=_Q(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(t,e,s,r){const i=Ja(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?qr(i,s,this.dataFormat):i}recurrentConv(t,e){return Ja(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}yC.className="ConvLSTM2DCell";xt(yC);class a3 extends o3{constructor(t){const e=new yC(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}a3.className="ConvLSTM2D";xt(a3);class bC extends ee{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return s}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);if(0<this.rate&&this.rate<1){const r=e.training==null?!1:e.training,i=this.getNoiseShape(s);return hf(()=>YO(s,this.rate,i,this.seed),()=>s,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}bC.className="Dropout";xt(bC);class l3 extends bC{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}l3.className="SpatialDropout1D";xt(l3);class c3 extends ee{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Dn(this.units,"units"),this.activation=Bo(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Ue(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Ue(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Cn(t.kernelConstraint),this.biasConstraint=Cn(t.biasConstraint),this.kernelRegularizer=je(t.kernelRegularizer),this.biasRegularizer=je(t.biasRegularizer),this.activityRegularizer=je(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=fe(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=fe(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t),r=jO(this.activation.getClassName());let i;return r!=null?i=di(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=di(s,this.kernel.read()),this.bias!=null&&(i=qr(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:He(this.kernelInitializer),biasInitializer:He(this.biasInitializer),kernelRegularizer:De(this.kernelRegularizer),biasRegularizer:De(this.biasRegularizer),activityRegularizer:De(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),biasConstraint:Sn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}c3.className="Dense";xt(c3);class u3 extends ee{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=fe(t);for(const e of t.slice(1))if(e==null)throw new H(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Oo(t,1)]}call(t,e){return rt(()=>{this.invokeCallHook(t,e);let s=jt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=ce(s,r)}return lJ(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}u3.className="Flatten";xt(u3);class h3 extends ee{constructor(t){super(t),this.supportsMasking=!0,this.activation=Bo(t.activation)}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);return this.activation.apply(s)})}getConfig(){const t={activation:zo(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}h3.className="Activation";xt(h3);class d3 extends ee{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return rt(()=>(t=jt(t),oJ(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}d3.className="RepeatVector";xt(d3);class f3 extends ee{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",r=e.slice();let i=1,o=null;for(let c=0;c<r.length;++c){const h=r[c];if(this.isUnknown(h))if(o===null)o=c;else throw new H("Can only specifiy one unknown dimension.");else i*=h}const l=Oo(t);if(o!==null){if(i===0||l%i!==0)throw new H(s);r[o]=l/i}else if(l!==i)throw new H(s);return r}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return et(s,i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}f3.className="Reshape";xt(f3);class p3 extends ee{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=Gr(1,t.dims.length+1);if(!we(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new wn({ndim:this.dims.length+1})]}computeOutputShape(t){t=fe(t);const e=t.slice();return this.dims.forEach((s,r)=>{e[r+1]=t[s]}),e}call(t,e){return ce(jt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}p3.className="Permute";xt(p3);class m3 extends ee{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=jt(t);return jv(Mm(s,this.maskValue),-1)}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t),o=jv(Mm(s,this.maskValue),-1,!0);return Y(s,Et(o,s.dtype))})}}m3.className="Masking";xt(m3);class g3 extends ee{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Te(t.inputLength))}this.inputDim=t.inputDim,Dn(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Dn(this.outputDim,"outputDim"),this.embeddingsInitializer=Ue(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=je(t.embeddingsRegularizer),this.activityRegularizer=je(t.activityRegularizer),this.embeddingsConstraint=Cn(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return rt(()=>this.maskZero?(t=jt(t),Mm(t,ue(t))):null)}computeOutputShape(t){if(t=fe(t),this.inputLength==null)return[...t,this.outputDim];const e=Te(this.inputLength);if(e.length!==t.length-1)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let r=0;r<e.length;++r){const i=e[r],o=t[r+1];if(i!=null&&o!=null&&i!==o)throw new H(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[s]=o),s++}}return[t[0],...e,this.outputDim]}call(t,e){return rt(()=>{this.invokeCallHook(t,e);let s=jt(t);s.dtype!=="int32"&&(s=hi(s,"int32"));const r=XO(this.embeddings.read(),et(s,[s.size]));return et(r,fe(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:He(this.embeddingsInitializer),embeddingsRegularizer:De(this.embeddingsRegularizer),activityRegularizer:De(this.activityRegularizer),embeddingsConstraint:Sn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}g3.className="Embedding";xt(g3);class hl extends ee{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Xt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],o=e[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new H("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[fe(t)]),t=t,t.length<2)throw new H(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=Do(e),e.length>1)throw new H(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(i=>i.length);t.indexOf(null)===-1&&Do(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return rt(()=>{if(t=t,this.reshapeRequired){const s=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Po(r);for(let o of t){const l=o.rank;for(let c=0;c<i-l;++c)o=cf(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const c of t){const h=c.rank;if(h==null){const d=c.shape,p=d[0],m=d.slice(1).concat([p]);let y=et(c,[p].concat(Oo(d.slice(1))));y=ce(y,[1,0]),y=et(y,m),s.push(y),i=!0}else if(h>1){const d=Gr(1,h).concat([0]);s.push(ce(c,d)),i=!0}else s.push(c)}let o=this.mergeFunction(s);const l=o.rank;if(i){if(l==null){const c=o.shape,h=c.length,d=c[h-1],p=[d].concat(c.slice(0,c.length-1));o=et(ce(et(o,[-1,d]),[1,0]),p)}else if(l>1){const c=[l-1].concat(Gr(0,l-1));o=ce(o,c)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){const i=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let s=[];for(const r of t)r!=null&&r[0]!==null&&s.push(r[0]);return s=Do(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return rt(()=>{if(e==null)return null;if(!Array.isArray(e))throw new H("`mask` should be an Array");if(!Array.isArray(t))throw new H("`inputs` should be an Array");if(e.length!==t.length)throw new H(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:ys(r,0));let s=e[0];for(let r=1;r<e.length-1;++r)s=Gi(s,e[r]);return s})}}class y3 extends hl{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=wt(e,t[s]);return e})}}y3.className="Add";xt(y3);class b3 extends hl{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Y(e,t[s]);return e})}}b3.className="Multiply";xt(b3);class x3 extends hl{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=wt(e,t[s]);return Y(1/t.length,e)})}}x3.className="Average";xt(x3);class v3 extends hl{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Xo(e,t[s]);return e})}}v3.className="Maximum";xt(v3);class w3 extends hl{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Bh(e,t[s]);return e})}}w3.className="Minimum";xt(w3);class S3 extends hl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new H("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(r!=null){e=!1;break}if(e)return;const s=[];for(let r=0;r<t.length;++r){const i=t[r].slice();i.splice(this.axis,1);let o=!1;for(const l of s)if(we(l,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new H("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return rt(()=>tC(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new H("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of e.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new H("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new H("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new H(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return rt(()=>{let s=!0;if(e.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<t.length;++o)e[o]==null?r.push(Et(Cr(t[o]),"bool")):e[o].rank<t[o].rank?r.push(ys(e[o],-1)):r.push(e[o]);const i=vs(r,this.axis);return wD(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}S3.className="Concatenate";xt(S3);function ih(n,t){for(;n<0;)n+=t;return n}function RQ(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Xt("batchDot is not implemented for tensors of 4D or higher rank yet");if(L(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),L(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Xt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;e==null&&(e=[s-1,r-2]);const i=e;return rt(()=>{let o;if(s>r){o=s-r;const c=[];for(let h=0;h<o;++h)c.push(1);t=et(t,t.shape.concat(c))}else if(r>s){o=r-s;const c=[];for(let h=0;h<o;++h)c.push(1);n=et(n,n.shape.concat(c))}else o=0;let l;if(n.shape.length===2&&t.shape.length===2)i[0]===i[1]?l=Mt(Y(n,t),i[0]):l=Mt(Y(ce(n,[1,0]),t),i[1]);else{const c=i[0]!==n.shape.length-1,h=i[1]===t.shape.length-1;l=xe(n,t,c,h)}if(o>0){let c;s>r?c=s+r-3:c=s-1;const h=[];for(let d=c;d<c+o;++d)h.push(d);l=nf(l,h)}return l.shape.length===1&&(l=ys(l,1)),l})}class C3 extends hl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){L(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);if(e[r[0]]!==s[r[1]])throw new H(`Dimension incompatibility: ${e[r[0]]} !== ${s[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new H(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>ih(i,t[o].shape.length)):r=[ih(this.axes,e.shape.length),ih(this.axes,s.shape.length)],this.normalize&&(e=Um(e,r[0]),s=Um(s,r[1])),RQ(e,s,r)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[ih(this.axes,t.length),ih(this.axes,e.length)],s}computeOutputShape(t){L(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);e.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=e.concat(s);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}C3.className="Dot";xt(C3);class T3 extends ee{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);return hf(()=>wt(S0(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}T3.className="GaussianNoise";xt(T3);class k3 extends ee{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);return this.rate>0&&this.rate<1?hf(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return Y(s,S0(s.shape,1,i))},()=>s,e.training||!1):s})}}k3.className="GaussianDropout";xt(k3);class $3 extends ee{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||jt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return rt(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return hf(()=>{const i=jt(t),l=-1.6732632423543772*1.0507009873554805;let c=al(ef(s),this.rate);c=hi(c,"float32");const h=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-h*l*this.rate,p=wt(Y(i,c),Y(wt(c,-1),l));return wt(Y(p,h),d)},()=>jt(t),e.training||!1)}return t})}}$3.className="AlphaDropout";xt($3);function Wh(n,t,e,s,r,i=.001){let o;if(n.rank===2)o=Zq(n,t,e,s,r,i);else if(n.rank===3)o=Qq(n,t,e,s,r,i);else if(n.rank===4)o=e8(n,t,e,s,r,i);else throw new Xt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function DQ(n,t,e,s,r=.001){return rt(()=>{const i=aS(n,s),o=i.mean,l=i.variance;return[Wh(n,o,l,e,t,r),o,l]})}function OQ(n,t,e,s,r=.001){return rt(()=>{const i=aS(n,s),o=i.mean,l=i.variance,c=[];for(const b of Gr(0,n.rank))s.indexOf(b)!==-1?c.push(1):c.push(n.shape[b]);const h=et(o,c),d=et(l,c),p=t==null?null:et(t,c),m=e==null?null:et(e,c);return[Wh(n,h,d,m,p,r),o,l]})}function MQ(n,t,e,s,r=.001){return we(s.slice().sort(),Gr(0,n.rank-1))?DQ(n,t,e,s,r):OQ(n,t,e,s,r)}class E3 extends ee{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Ue(t.betaInitializer||"zeros"),this.gammaInitializer=Ue(t.gammaInitializer||"ones"),this.movingMeanInitializer=Ue(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Ue(t.movingVarianceInitializer||"ones"),this.betaConstraint=Cn(t.betaConstraint),this.gammaConstraint=Cn(t.gammaConstraint),this.betaRegularizer=je(t.betaRegularizer),this.gammaRegularizer=je(t.gammaRegularizer)}build(t){t=fe(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new H(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new wn({ndim:t.length,axes:{[e]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return rt(()=>{const s=e.training==null?!1:e.training,r=jt(t),i=r.shape,o=i.length,l=Gr(0,o),c=this.axis>=0?this.axis:this.axis+o;l.splice(c,1);const h=nl(1,o);h[c]=i[c];const d=l.slice();d.sort();const p=!we(d,Gr(0,o).slice(0,o-1)),m=()=>{if(p){const T=et(this.movingMean.read(),h),k=et(this.movingVariance.read(),h),$=this.center?et(this.beta.read(),h):null,E=this.scale?et(this.gamma.read(),h):null;return Wh(r,T,k,$,E,this.epsilon)}else return Wh(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=MQ(r,this.gamma.read(),this.beta.read(),l,this.epsilon),w=(T,k,$)=>{rt(()=>{const E=1-$,N=T.read(),_=Y(Bt(N,k),E);T.write(Bt(N,_))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:He(this.betaInitializer),gammaInitializer:He(this.gammaInitializer),movingMeanInitializer:He(this.movingMeanInitializer),movingVarianceInitializer:He(this.movingVarianceInitializer),betaRegularizer:De(this.betaRegularizer),gammaRegularizer:De(this.gammaRegularizer),betaConstraint:Sn(this.betaConstraint),gammaConstraint:Sn(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}E3.className="BatchNormalization";xt(E3);class I3 extends ee{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Ue(t.betaInitializer||"zeros"),this.gammaInitializer=Ue(t.gammaInitializer||"ones"),this.betaRegularizer=je(t.betaRegularizer),this.gammaRegularizer=je(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=fe(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Do(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){const s=jt(t),r=s.shape,i=r.length;return rt(()=>{let{mean:l,variance:c}=aS(s,this.axis,!0);const h=nl(1,i);for(const x of this.axis)h[x]=r[x];const d=x=>x!=null&&x.shape.length!==i?et(x,h):x;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<i;++x)this.axis.indexOf(x)!==-1?(y.push(r[x]),b.push(1)):(y.push(1),b.push(r[x]));return l=Br(l,y),c=Br(c,y),p!=null&&(p=Br(p,b)),m!=null&&(m=Br(m,b)),Wh(s,l,c,m,p,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:He(this.betaInitializer),gammaInitializer:He(this.gammaInitializer),betaRegularizer:De(this.betaRegularizer),gammaRegularizer:De(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}I3.className="LayerNormalization";xt(I3);function FQ(n,t,e){return rt(()=>{if(n.rank!==4)throw new H(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new H("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=Wr()),e!=="channelsLast"&&e!=="channelsFirst")throw new H(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],lS(n,s)})}class N3 extends ee{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?Wr():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new H(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new H(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new H(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){t=fe(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return rt(()=>FQ(jt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}N3.className="ZeroPadding2D";xt(N3);function A0(n,t,e,s,r,i){return rt(()=>{rn(r),WO(i),er(s),e==null&&(e=[1,1]),s==null&&(s="valid"),r==null&&(r=Wr()),i==null&&(i="max"),n=fC(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=oS(n,t,e,l):o=Y1(n,t,e,l),r==="channelsFirst"&&(o=ce(o,[0,3,1,2])),o})}function A3(n,t,e,s,r,i){return rt(()=>{rn(r),WO(i),er(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Wr()),i==null&&(i="max"),n=qM(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=zK(n,t,e,l):o=Vq(n,t,e,l),r==="channelsFirst"&&(o=ce(o,[0,4,1,2,3])),o})}class _3 extends ee{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new H(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Dn(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new H(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Dn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,er(this.padding),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(t){t=fe(t);const e=jr(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return rt(()=>{this.invokeCallHook(t,e),t=cf(jt(t),2);const s=this.poolingFunction(jt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return nf(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class R3 extends _3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return rn(i),er(r),A0(t,e,s,r,i,"max")}}R3.className="MaxPooling1D";xt(R3);class D3 extends _3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return rn(i),er(r),A0(t,e,s,r,i,"avg")}}D3.className="AveragePooling1D";xt(D3);class O3 extends ee{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new H(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Dn(this.poolSize,"poolSize"),Dn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,rn(this.dataFormat),er(this.padding),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){t=fe(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=jr(e,this.poolSize[0],this.padding,this.strides[0]),s=jr(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return rt(()=>(this.invokeCallHook(t,e),this.poolingFunction(jt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class M3 extends O3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return rn(i),er(r),A0(t,e,s,r,i,"max")}}M3.className="MaxPooling2D";xt(M3);class F3 extends O3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return rn(i),er(r),A0(t,e,s,r,i,"avg")}}F3.className="AveragePooling2D";xt(F3);class L3 extends ee{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new H(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Dn(this.poolSize,"poolSize"),Dn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,rn(this.dataFormat),er(this.padding),this.inputSpec=[new wn({ndim:5})]}computeOutputShape(t){t=fe(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=jr(e,this.poolSize[0],this.padding,this.strides[0]),s=jr(s,this.poolSize[1],this.padding,this.strides[1]),r=jr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return rt(()=>(this.invokeCallHook(t,e),this.poolingFunction(jt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class P3 extends L3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return rn(i),er(r),A3(t,e,s,r,i,"max")}}P3.className="MaxPooling3D";xt(P3);class z3 extends L3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return rn(i),er(r),A3(t,e,s,r,i,"avg")}}z3.className="AveragePooling3D";xt(z3);class B3 extends ee{constructor(t){super(t),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Xt}}class V3 extends B3{constructor(t){super(t||{})}call(t,e){return rt(()=>{const s=jt(t);return un(s,1)})}}V3.className="GlobalAveragePooling1D";xt(V3);class U3 extends B3{constructor(t){super(t||{})}call(t,e){return rt(()=>{const s=jt(t);return Ur(s,1)})}}U3.className="GlobalMaxPooling1D";xt(U3);class j3 extends ee{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,rn(this.dataFormat),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Xt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class G3 extends j3{call(t,e){return rt(()=>{const s=jt(t);return this.dataFormat==="channelsLast"?un(s,[1,2]):un(s,[2,3])})}}G3.className="GlobalAveragePooling2D";xt(G3);class W3 extends j3{call(t,e){return rt(()=>{const s=jt(t);return this.dataFormat==="channelsLast"?Ur(s,[1,2]):Ur(s,[2,3])})}}W3.className="GlobalMaxPooling2D";xt(W3);class H3 extends ee{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const r=e.layer,i=fi(r,s);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}class q3 extends H3{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=fe(t),t.length<3)throw new H(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=fe(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),r=t[1];return[s[0],r].concat(s.slice(1))}call(t,e){return rt(()=>(t=jt(t),n3((o,l)=>[jt(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}q3.className="TimeDistributed";xt(q3);function LQ(n){ul(eJ,"BidirectionalMergeMode",n)}const PQ="concat";class K3 extends H3{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=fi(s),e.goBackwards=e.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=fi(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?PQ:t.mergeMode,LQ(this.mergeMode),t.weights)throw new Xt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,r,i;return this.returnState&&(i=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):bs(r)}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=e3(t,s,r,this.numConstants);if(t=i.inputs,s=i.initialState,r=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&r==null)return super.apply(t,e);const o=[],l=[];if(s!=null){const h=s.length;if(h%2>0)throw new H("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,o.push(...s);const d=s.map(p=>new wn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),l.push(...d)}if(r!=null)throw new Xt("Support for constants in Bidirectional layers is not implemented yet.");const c=o[0]instanceof yi;for(const h of o)if(h instanceof yi!==c)throw new H("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const h=[t].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return rt(()=>{const s=e.initialState;let r,i;if(s==null)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const c=s.slice(0,s.length/2),h=s.slice(s.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:c})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:h}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=tl(i,1));let l;return this.mergeMode==="concat"?l=tC([r,i]):this.mergeMode==="sum"?l=wt(r,i):this.mergeMode==="ave"?l=Y(.5,wt(r,i)):this.mergeMode==="mul"?l=Y(r,i):this.mergeMode==null&&(l=[r,i]),this.returnState?this.mergeMode==null?l.concat(o):[l].concat(o):l})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){ja(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),ja(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=fi(e.layer);if(delete e.layer,e.numConstants!=null)throw new Xt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=s,new t(r)}}K3.className="Bidirectional";xt(K3);class X3 extends ee{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return rt(()=>(t=jt(t),t.dtype!=="float32"&&(t=hi(t,"float32")),wt(Y(t,this.scale),this.offset)))}}X3.className="Rescaling";xt(X3);const{resizeBilinear:zQ,cropAndResize:BQ}=Vi;class Y3 extends ee{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,r,i,o,l,c){return rt(()=>{let h,d=!1;const p=e/o,m=s/l,y=(r+e)/o,b=(i+s)/l,x=[p,m,y,b],w=[];t.rank===3?(d=!0,h=Wi([t])):h=t;for(let E=0;E<h.shape[0];E++)w.push(x);const S=Sh(w,[w.length,4]),T=Vh(0,w.length,1,"int32"),$=BQ(h,S,T,[r,i],"nearest");return hi(d?jt(el($)):$,c)})}upsize(t,e,s,r){return rt(()=>{const i=zQ(t,[e,s]);return hi(i,r)})}call(t,e){return rt(()=>{const s=jt(t),r=s.dtype,i=s.shape,o=i[i.length-3],l=i[i.length-2];let c=0;o!==this.height&&(c=Math.floor((o-this.height)/2));let h=0;return l!==this.width&&(h=Math.floor((l-this.width)/2),h===0&&(h=1)),c>=0&&h>=0?this.centerCrop(s,c,h,this.height,this.width,o,l,r):this.upsize(t,this.height,this.width,r)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=fe(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}Y3.className="CenterCrop";xt(Y3);function VQ(n,t,e,s){let r=jt(n);if(r.dtype!=="int32"&&(r=hi(r,"int32")),t==="int")return r;const i=r.shape;if(r.rank===0&&(r=ys(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=ys(r,-1)),r.rank>2)throw new H(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t),l=r;let c;if(typeof s<"u"&&t==="count"?c=KI(l,s,e,o):c=KI(l,[],e,o),t!=="tfIdf")return c;if(s)return Y(c,s);throw new H("When outputMode is 'tfIdf', weights must be provided.")}class Z3 extends ee{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=fe(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return rt(()=>{t=jt(t),t.dtype!=="int32"&&(t=hi(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new H(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=jt(e.countWeights)}const r=Ur(t),i=Dm(t),o=tr(this.numTokens,r).bufferSync().get(0),l=al(i,0).bufferSync().get(0);if(!(o&&l))throw new H(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return VQ(t,this.outputMode,this.numTokens,s)})}}Z3.className="CategoryEncoding";xt(Z3);const UQ=["bilinear","nearest"],LN=new Set(UQ);class J3 extends ee{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(LN.has(t.interpolation))this.interpolation=t.interpolation;else throw new H(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=fe(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return rt(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Vi.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Vi.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...LN]} are supported`)})}}J3.className="Resizing";xt(J3);class Q3{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}Q3.className="RandomSeed";class tF extends ee{constructor(t){super(t),this.randomGenerator=new Q3(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}tF.className="BaseRandomLayer";const jQ=["bilinear","nearest"],PN=new Set(jQ);class eF extends tF{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new H(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new H(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new H(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(PN.has(s))this.interpolation=s;else throw new H(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=fe(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return rt(()=>{const s=jt(t);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=ef([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Vi.resizeBilinear(t,o);case"nearest":return Vi.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...PN]} are supported`)}})}}eF.className="RandomWidth";xt(eF);const GQ=ct();GQ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var zN;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(zN||(zN={}));var BN;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(BN||(BN={}));var VN;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(VN||(VN={}));function Nt(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&L(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const WQ=XD;class _0 extends Jw{nextDataId(){return _0.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new SR(this,ti())}write(t,e,s){this.firstUse&&(this.firstUse=!1,ct().get("IS_NODE")&&Ys(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:s,refCount:1}),r}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&ed(s[0])){const i=s.map(o=>Ro(o));r=this.write(i,t,e)}else r=this.write(s,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,r,i){this.data.set(t,{values:e,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Hi(r,i)}return G5(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>Lo(r));return Qt(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qt(t.shape,t.dtype,e)}makeOutput(t,e,s){return ti().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=gs();return t(),{kernelMs:gs()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Nt([t],"where");const e=this.readSync(t.dataId);return WQ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}_0.nextDataId=0;function nF(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const HQ=n=>{const{x:t}=n.inputs,e=n.backend;Nt(t,"abs");let s=new Float32Array(ft(t.shape));const r=e.data.get(t.dataId).values;return s=nF(r),e.makeOutput(s,t.shape,t.dtype)},qQ={kernelName:ug,backendName:"cpu",kernelFunc:HQ};function on(n){return(t,e,s,r,i)=>{const o=qt(t,e),l=o.length,c=Ot(o),h=ft(o),d=Zn(i,h),p=t.length,m=e.length,y=Ot(t),b=Ot(e),x=Oc(t,o),w=Oc(e,o);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=n(s[S%s.length],r[S%r.length]);else for(let S=0;S<d.length;++S){const T=Hc(S,l,c),k=T.slice(-p);x.forEach(_=>k[_]=0);const $=li(k,p,y),E=T.slice(-m);w.forEach(_=>E[_]=0);const N=li(E,m,b);d[S]=n(s[$],r[N])}return[d,o]}}function Rs(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,l=e.makeTensorInfo(s.shape,"complex64"),c=e.data.get(l.dataId);return c.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",i),imag:e.makeTensorInfo(r.shape,"float32",o)},l}const KQ={kernelName:d1,backendName:"cpu",kernelFunc:Rs};function Km(n,t,e="float32"){if(e==="complex64"){const r=Km(n,t,"float32"),i=Km(n,t,"float32");return Rs({inputs:{real:r,imag:i},backend:n})}const s=Jn(ft(t),e);return n.makeTensorInfo(t,e,s)}function bi(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const XQ={kernelName:Sd,backendName:"cpu",kernelFunc:bi};function sl(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const YQ={kernelName:F1,backendName:"cpu",kernelFunc:sl};function sF(n,t,e,s){if(s==="int32"){const r=Int32Array.from(n);return[t,"int32",r]}if(s==="bool"){const r=ol([0],e),[i,o]=on((l,c)=>l!==c?1:0)(t,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function Uo(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return bi({inputs:{x:r},backend:e});const d=Km(e,r.shape,r.dtype),p=Uo({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),m=Rs({inputs:{real:p,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){const d=sl({inputs:{input:r},backend:e}),p=Uo({inputs:{x:d},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(d),p}if(!TR(r.dtype,i)){const d=bi({inputs:{x:r},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:i}}const o=e.data.get(r.dataId).values,[l,c,h]=sF(o,r.shape,r.dtype,i);return e.makeTensorInfo(l,c,h)}const ZQ={kernelName:cd,backendName:"cpu",kernelFunc:Uo};function kn(n,t,e,s){return e==null?({inputs:r,backend:i})=>{const{a:o,b:l}=r,c=i;Nt([o,l],n);const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=o.dtype==="string"?qi(h):h,m=o.dtype==="string"?qi(d):d,y=s||o.dtype,[b,x]=t(o.shape,l.shape,p,m,y);return c.makeTensorInfo(x,y,b)}:({inputs:r,backend:i})=>{const{a:o,b:l}=r,c=i;if(o.dtype==="complex64"||l.dtype==="complex64"){const h=Uo({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(h.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=c.data.get(p.dataId).values,b=c.data.get(m.dataId).values,x=Uo({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),w=c.data.get(x.dataId),S=w.complexTensorInfos.real,T=w.complexTensorInfos.imag,k=c.data.get(S.dataId).values,$=c.data.get(T.dataId).values,[E,N,_]=e(o.shape,l.shape,y,b,k,$),R=c.makeTensorInfo(_,"float32",E),D=c.makeTensorInfo(_,"float32",N),O=Rs({inputs:{real:R,imag:D},backend:c});return c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(R),c.disposeIntermediateTensorInfo(D),O}else{const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=s||o.dtype,[m,y]=t(o.shape,l.shape,h,d,p);return c.makeTensorInfo(y,p,m)}}}function xC(n){return(t,e,s,r,i,o)=>{const l=qt(t,e),c=ft(l),h=l.length,d=Ot(l),p=Zn("float32",c),m=Zn("float32",c),y=Oc(t,l),b=Oc(e,l),x=Hi(s,r),w=Hi(i,o),S=t.length,T=Ot(t),k=e.length,$=Ot(e);if(y.length+b.length===0)for(let E=0;E<p.length;E++){const N=E%x.length,_=E%w.length,R=n(x[N*2],x[N*2+1],w[_*2],w[_*2+1]);p[E]=R.real,m[E]=R.imag}else for(let E=0;E<p.length;E++){const N=Hc(E,h,d),_=N.slice(-S);y.forEach(z=>_[z]=0);const R=li(_,S,T),D=N.slice(-k);b.forEach(z=>D[z]=0);const O=li(D,k,$),A=n(x[R*2],x[R*2+1],w[O*2],w[O*2+1]);p[E]=A.real,m[E]=A.imag}return[p,m,l]}}const rF=on(((n,t)=>n+t)),JQ=xC(((n,t,e,s)=>({real:n+e,imag:t+s}))),Lc=kn(qc,rF,JQ),QQ={kernelName:qc,backendName:"cpu",kernelFunc:Lc};function vC(n,t,e,s,r){const i=ft(s),o=Jn(r,e);for(let l=0;l<n.length;l++){const c=n[l];if(c<0)throw new Error("Input x must be non-negative!");c>=r||(i>0?o[c]+=t[l]:o[c]+=1)}return o}function iF(n,t,e,s=!1){const r=n.shape[0],i=n.shape[1],o=Qt([r,e],t.dtype);for(let l=0;l<r;l++)for(let c=0;c<i;c++){const h=n.get(l,c);if(h<0)throw new Error("Input x must be non-negative!");h>=e||(s?o.set(1,l,h):t.size>0?o.set(o.get(l,h)+t.get(l,c),l,h):o.set(o.get(l,h)+1,l,h))}return o}const oF=on(((n,t)=>n&t)),ttt=kn(h1,oF),ett={kernelName:h1,backendName:"cpu",kernelFunc:ttt};function xi(n){return(t,e,s)=>{const r=tn(e,t.length);for(let i=0;i<t.length;++i)r[i]=n(t[i],s);return r}}function ke(n,t,e){const s=xi(t);return Qo(n,s,e)}function Qo(n,t,e){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;Nt(o,n);const l=i,c=l.data.get(o.dataId).values;let h;if(o.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");h=qi(c)}else h=c;const d=e||o.dtype,p=t(h,d,r);return l.makeTensorInfo(o.shape,d,p)}}const aF=xi(n=>Math.ceil(n)),ntt=Qo(ud,aF),stt={kernelName:ud,backendName:"cpu",kernelFunc:ntt};function lF(n,t,e,s){const r=tn(e,ft(t));if(s&&e!=="string"){let i=0;n.forEach(o=>{const l=ft(o.shape);r.set(o.vals,i),i+=l})}else{let i=0;n.forEach(o=>{const l=e==="string"?qi(o.vals):o.vals;let c=0;for(let h=0;h<o.shape[0];++h){const d=h*t[1]+i;for(let p=0;p<o.shape[1];++p)r[d+p]=l[c++]}i+=o.shape[1]})}return r}const cF=on((n,t)=>n===t?1:0),uF=kn(kg,cF,null,"bool"),rtt={kernelName:kg,backendName:"cpu",kernelFunc:uF};const hF=xi(n=>Math.exp(n)),dF=Qo(yd,hF,"float32"),itt={kernelName:yd,backendName:"cpu",kernelFunc:dF};const fF=xi(n=>Math.expm1(n)),ott=Qo(bd,fF),att={kernelName:bd,backendName:"cpu",kernelFunc:ott};const pF=xi(n=>Math.floor(n)),ltt=Qo(xd,pF),ctt={kernelName:xd,backendName:"cpu",kernelFunc:ltt};const mF=on((n,t)=>Math.floor(n/t)),utt=kn(vd,mF,null,"int32"),htt={kernelName:vd,backendName:"cpu",kernelFunc:utt};function gF(n,t,e,s,r,i,o,l,c){const h=Qt([s,i],e);for(let d=0;d<s;d++){const p=[];let m=0;for(let y=0;y<r;y++){const b=n[d*r+y];m+=b*o[y],p.push(b)}if(m<0||m>=c/i)throw new Error(`Invalid indices: ${p} does not index into ${l}`);for(let y=0;y<i;y++)h.values[d*i+y]=t.get(...t.indexToLoc(m*i+y))}return h}function yF(n,t,e){const s=Qt(e,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),l=o[0],c=o[2],h=t.locToIndex([l,c]);o[2]=t.values[h];const d=n.locToIndex(o);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const bF=on((n,t)=>n>t?1:0),dtt=kn(Ng,bF,null,"bool"),ftt={kernelName:Ng,backendName:"cpu",kernelFunc:dtt};const xF=on((n,t)=>n>=t?1:0),ptt=kn(wd,xF,null,"bool"),mtt={kernelName:wd,backendName:"cpu",kernelFunc:ptt};const vF=on((n,t)=>n<t?1:0),gtt=kn(_g,vF,null,"bool"),ytt={kernelName:_g,backendName:"cpu",kernelFunc:gtt};const wF=on((n,t)=>n<=t?1:0),btt=kn(Rg,wF,null,"bool"),xtt={kernelName:Rg,backendName:"cpu",kernelFunc:btt};function SF(n,t,e){const s=(t-n)/(e-1),r=Jn(e,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const CF=xi(n=>Math.log(n)),vtt=Qo($d,CF),wtt={kernelName:$d,backendName:"cpu",kernelFunc:vtt};function TF(n,t,e,s){const r=Zn(s,ft(e));for(let i=0;i<r.length;++i){const o=i*t;let l=n[o];for(let c=0;c<t;++c){const h=n[o+c];(Number.isNaN(h)||h>l)&&(l=h)}r[i]=l}return r}const kF=on(((n,t)=>Math.max(n,t))),Stt=kn(Id,kF),Ctt={kernelName:Id,backendName:"cpu",kernelFunc:Stt};const $F=on(((n,t)=>Math.min(n,t))),Ttt=kn(Nd,$F),ktt={kernelName:Nd,backendName:"cpu",kernelFunc:Ttt};const wC=on(((n,t)=>n*t)),$tt=xC(((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e}))),R0=kn(_d,wC,$tt),Ett={kernelName:_d,backendName:"cpu",kernelFunc:R0};function EF(n,t,e){const s=Wo(-1,e);return wC([],t,s,n,e)}function Itt(n){const{inputs:t,backend:e}=n,{x:s}=t;Nt(s,"neg");const r=e.data.get(s.dataId).values,[i,o]=EF(r,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,i)}const Ntt={kernelName:jg,backendName:"cpu",kernelFunc:Itt};const IF=on(((n,t)=>n!==t?1:0)),Att=kn(Gg,IF,null,"bool"),_tt={kernelName:Gg,backendName:"cpu",kernelFunc:Att};function SC(n,t,e,s,r){const i=t.length,o=ft(t),l=Ot(t),c=Ot(r),h=Zn(e,ft(r));for(let d=0;d<o;++d){const p=Hc(d,i,l),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[s[b]];const y=li(m,i,c);h[y]=n[d]}return h}function Ss(n){const{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:i}=e;Nt(r,"transpose");const o=r.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=r.shape[i[p]];const c=s.data.get(r.dataId).values,h=SC(c,r.shape,r.dtype,i,l);return{dataId:s.write(h,l,r.dtype),shape:l,dtype:r.dtype}}const Rtt={kernelName:kc,backendName:"cpu",kernelFunc:Ss};function NF(n,t,e,s){const[r,i]=On(n,s),o=Ms(t,"int32"),l=Jn(ft(r),o),c=ft(i);for(let h=0;h<l.length;++h){const d=h*c;let p=1;for(let m=0;m<c;++m)p*=e[d+m];l[h]=p}return{outVals:l,outShape:r,outDtype:o}}function Dtt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"prod");const l=r.shape.length,c=te(i,r.shape),h=qe(c,l);let d=c,p=r;const m=[];h!=null&&(p=Ss({inputs:{x:r},backend:e,attrs:{perm:h}}),m.push(p),d=sn(d.length,l));const y=e.data.get(p.dataId).values,{outVals:b,outShape:x,outDtype:w}=NF(p.shape,p.dtype,y,d);let S=x;return o&&(S=hn(x,c)),m.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(S,w,b)}const Ott={kernelName:Yg,backendName:"cpu",kernelFunc:Dtt};function Mtt(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const i=Hc(r,t.length,Ot(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${e})`)}})}function Ftt(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Ltt(n,t,e,s){const r=[];let i=0;const o=t.length-1+e.length,l=new Array(o).fill(null).map(()=>[0]);Ftt(e,s);let c=1;for(let h=0;h<t.length-1;++h){c*=t[h];const d=t[h+1];for(let p=1;p<c+1;++p)l[h].push(p*d)}for(let h=0;h<n.length;++h){let d=n[h],p=n[h]+1;for(let m=0;m<e.length;++m){const y=e[m],b=m+t.length-1;if(b>=0){const x=l[b],w=x[x.length-1]-y[d];for(let S=d;S<p;++S)l[b].push(y[S+1]+w)}d=y[d],p=y[p]}p!==d&&(r.push([d,p]),i+=p-d)}return{outSplits:l,valueSlices:r,numValues:i}}function Ptt(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,r=tn("int32",s);t.push(r),n[e].forEach((i,o)=>r[o]=i)}return t}function UN(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function ztt(n,t,e,s,r,i){const o=UN(t,2)[1],l=UN(i,2)[1];let c=0;for(const h of e)for(let d=h[0];d<h[1];++d){for(let p=0;p<s;++p)r[c*l+p]=n[d*o+p];++c}}function Btt(n,t,e,s,r){const i=t.slice();i[0]=r;const o=tn(e,ft(i)),l=n.length,c=l===0?0:l/t[0];return ztt(n,t,s,c,o,i),[o,i]}function AF(n,t,e,s,r,i,o,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const c=t[0][0]-1;if(Mtt(i,o,c),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:p,numValues:m}=Ltt(i,o,n,h),y=Ptt(d),b=Btt(e,s,r,p,m);return[y,b[0],b[1]]}const jN=2147483647;function _F(n,t,e,s,r,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const l=t.length===0,c=r.length===0,h=o.length===0,d=[];l||d.push(t[0]),c||d.push(r[0]),h||d.push(o[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=tn("int32",p+1);m[0]=0;for(let w=0;w<p;++w){const S=l?n[0]:n[w],T=c?s[0]:s[w],k=h?i[0]:i[w];if(k===0)throw new Error("Requires delta != 0");let $;if(k>0&&T<S||k<0&&T>S)$=0;else if($=Math.ceil(Math.abs((T-S)/k)),$>jN)throw new Error(`Requires ((limit - start) / delta) <= ${jN}`);m[w+1]=m[w]+$}const y=m[p],b=tn(e,y);let x=0;for(let w=0;w<p;++w){const S=m[w+1]-m[w];let T=l?n[0]:n[w];const k=h?i[0]:i[w];for(let $=0;$<S;++$)b[x++]=T,T+=k}return[m,b]}var fr=zr;class Xm{constructor(t,e,s,r,i,o,l,c,h,d){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=l,this.rowPartitionValues=c,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=gO(d),this.raggedRank=yO(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===fr.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===fr.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case fr.VALUE_ROWIDS:return Xm.getMaxWidthValueRowID(e);case fr.ROW_SPLITS:return Xm.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${fr[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let r=0;r<e-1;++r){const i=t[r+1]-t[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,r=t[0],i=0;for(let o=1;o<e;++o){const l=t[o];l!==r&&(r=l,i=Math.max(o-s,i),s=o)}return Math.max(e-s,i)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return WN(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;bO(s,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=mO(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let l=1;l<=this.raggedRank;++l)o[l]<0&&(o[l]=this.getMaxWidth(l));return o}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),i=[];let o=0;for(let l=0;l<r;++l,o+=e)i.push(o);for(let l=r;l<t;++l)i.push(-1);return L(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,s,r){const i=t.length,o=[];for(let l=0;l<i-1;++l){const c=t[l+1]-t[l];let h=Math.min(r,c),d=e[l];d===-1&&(h=0);for(let p=0;p<h;++p)o.push(d),d+=s;for(let p=0;p<c-h;++p)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,s,r){const i=t.length,o=[];if(i===0)return[];let l=0,c=t[0];if(c>=e.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${e.length}`);let h=e[c];o.push(h);for(let d=1;d<i;++d){const p=t[d];if(p===c)h>=0&&(++l,l<r?h+=s:h=-1);else{if(l=0,c=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);h=e[p]}o.push(h)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,s,r){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case fr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,s,r);case fr.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,s,r);default:throw new Error(`Unsupported partition type: ${fr[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case fr.FIRST_DIM_SIZE:return t[0];case fr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fr[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let c=r.length-2;c>=0;--c)r[c]=r[c+1]*s[c+1];const i=WN(s,!1),o=tn(this.valuesDType,ft(i));if(r[0]*s[0]>0){let c=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)c=this.calculateOutputIndex(h-1,c,r[h],s[h]);this.setOutput(this.raggedRank,c,o,i)}return[i,o]}setOutput(t,e,s,r){if(s.length===0)return;const i=this.values,o=s;let l=r.slice();l=l.slice(t+1);const c=ft(l),h=e.length;let d=this.defaultValue;if(d.length!==c&&d.length!==1){const b=this.defaultValueShape;rt(()=>{const x=et(d,b);d=Ch(x,l).dataSync()})}let p=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?e[b]:-1;if(x===y){++y;continue}if(m<y){const w=i.subarray(p*c),S=o.subarray(m*c),T=(y-m)*c;GN(S,w,T)}if(b>=h){const w=s.length;x=Math.floor(w/c)}if(x>y)if(this.defaultValue.length===1)o.subarray(y*c,x*c).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=o.slice(y*c);GN(w,d,c),++y}x<0?(p=b+1,m=y):(p=b,m=y,y=m+1)}}}function GN(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function WN(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function RF(n,t,e,s,r,i,o,l,c,h){return new Xm(n,t,e,s,r,i,o,l,c,h).compute()}function DF(n,t,e,s){const r=n===t,i=n<t&&e<0,o=t<n&&e>1;if(r||i||o)return Jn(0,s);const l=Math.abs(Math.ceil((t-n)/e)),c=Jn(l,s);t<n&&e===1&&(e=-1),c[0]=n;for(let h=1;h<c.length;h++)c[h]=c[h-1]+e;return c}const OF=xi(n=>1/Math.sqrt(n)),Vtt=Qo(Ld,OF),Utt={kernelName:Ld,backendName:"cpu",kernelFunc:Vtt};function za(n,t,e,s,r,i,o,l,c,h){const d=[s/r,r],p=n.values,m=t.values;if(s===0)return Qt(e,t.dtype);const y=c instanceof Pn?c:Qt(d,t.dtype);typeof c=="string"||typeof c=="number"?y.values.fill(c):typeof c=="boolean"&&y.values.fill(+c);for(let b=0;b<i;b++){const x=[];let w=0;for(let S=0;S<o;S++){const T=p[b*o+S];x.push(T),w+=T*l[S]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${e}`);for(let S=0;S<r;S++)h?y.values[w*r+S]+=m[b*r+S]:y.values[w*r+S]=t.rank===0?m[0]:m[b*r+S]}return y}const jtt=xi(n=>1/(1+Math.exp(-n))),MF=ke(Ud,n=>1/(1+Math.exp(-n))),Gtt={kernelName:Ud,backendName:"cpu",kernelFunc:MF};function FF(n,t,e,s,r){const i=NS(s,t,e),o=ft(e),l=Ot(s);if(i){const p=AS(t,l);return r==="string"?n.slice(p,p+o):n.subarray(p,p+o)}const c=r==="string"?qi(n):n,h=Qt(s,r,c),d=Qt(e,r);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),y=m.map((b,x)=>b+t[x]);d.set(h.get(...y),...m)}return r==="string"?PO(d.values):d.values}function rl(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s;Nt(r,"slice");const[l,c]=y0(r,i,o);ES(r,l,c);const h=e.data.get(r.dataId).values,d=FF(h,l,c,r.shape,r.dtype);return e.makeTensorInfo(c,r.dtype,d)}const Wtt={kernelName:n0,backendName:"cpu",kernelFunc:rl};function LF(n,t,e,s,r,i,o){const l=t[0],c=i[0],h=new Array(c),d=new Array(l),p=t[1];if(c===0){if(l!==0)throw new Error(kO(l));const w=tn(e,0),S=tn(r,0);return[w,[0,p],S,h,d]}let m=!0,y=0;const b=new Array(c).fill(0);for(let w=0;w<l;++w){const S=n[w*p];if(S<0)throw new Error($O(w,S));if(S>=c)throw new Error(EO(w,S,c));++b[S],m=m&&S>=y,y=S}let x=!0;for(let w=0;w<c;++w){const S=b[w]===0;h[w]=S,x=x&&!S,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,S=s;for(let T=0;T<l;++T)d[T]=T;return[w,[l,p],S,h,d]}else{const w=b[c-1],S=tn(e,w*p),T=tn(r,w),k=new Array(c).fill(0);for(let $=0;$<l;++$){const E=n[$*p],N=k[E],_=(E===0?0:b[E-1])+N;k[E]++;for(let R=0;R<p;++R)S[_*p+R]=n[$*p+R];T[_]=s[$],d[$]=_}for(let $=0;$<c;++$)if(k[$]===0){const N=$===0?0:b[$-1];S[N*p+0]=$;for(let _=1;_<p;++_)S[N*p+_]=0;T[N]=o}return[S,[w,p],T,h,d]}}function PF(n,t,e,s,r){const i=ft(s),o=t[0],l=r.length,c=[];let h=1,d=-1;for(let w=0;w<l;++w){const S=r[w];if(S===-1){if(d!==-1)throw new Error(IO(d,w));d=w,c.push(1)}else{if(S<0)throw new Error(NO(w,S));h*=S,c.push(S)}}if(d!==-1){if(h<=0)throw new Error(AO());const w=Math.trunc(i/h);if(h*w!==i)throw new Error(_O(s,c));c[d]=w}if(ft(c)!==i)throw new Error(RO(s,c));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(l>0){b[l-1]=1;for(let w=l-2;w>=0;--w)b[w]=b[w+1]*c[w+1]}const x=tn(e,o*l);for(let w=0;w<o;++w){let S=0;for(let T=0;T<m;++T)S+=n[w*m+T]*y[T];for(let T=0;T<l;++T)x[w*l+T]=Math.trunc(S/b[T]),S%=b[T]}return[x,[o,l],c]}function CC(n,t,e,s,r,i=!1,o=0){const l=s.length,c=[t[0],n.length/t[0]],h=c[1],p=l>0?r[l-1]+1:0;if(p<0)throw new Error(Kv());const m=t.slice();m[0]=p;const y=m.reduce((k,$)=>k*$,1),b=tn(e,y);if(l===0)return p>0&&b.fill(o),[b,m];if(p<=0)throw new Error(Kv());let x=0,w=1,S=0,T=r[x];for(;;){let k=0;if(w<l){if(k=r[w],T===k){++w;continue}if(T>=k)throw new Error(DO())}if(T<0||T>=p)throw new Error(OO(T,p));T>S&&b.fill(o,S*h,T*h);for(let $=x;$<w;++$){const E=s[$];if(E<0||E>=c[0])throw new Error(MO($,s[$],c[0]));for(let N=0;N<h;N++)b[T*h+N]+=n[E*h+N]}if(i)for(let $=0;$<h;$++)b[T*h+$]/=w-x;if(x=w,++w,S=T+1,T=k,w>l)break}return S<p&&b.fill(o,S*h,p*h),[b,m]}const Htt=xi(n=>Math.sqrt(n)),qtt=ke(Gd,n=>Math.sqrt(n)),Ktt={kernelName:Gd,backendName:"cpu",kernelFunc:qtt};const zF=on(((n,t)=>{const e=n-t;return e*e})),Xtt=kn(Wd,zF),Ytt={kernelName:Wd,backendName:"cpu",kernelFunc:Xtt};const BF=xi((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)}),Ztt=Qo(B1,BF),Jtt={kernelName:B1,backendName:"cpu",kernelFunc:Ztt};function VF(n,t,e,s){const r=Qt(n,t.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),l=new Array(o.length);for(let c=0;c<l.length;c++)l[c]=o[c]*e[c]+s[c];r.set(t.get(...l),...o)}return r}class Qtt{constructor(t,e,s,r,i,o){this.separator=Ro(t),this.nGramWidths=e,this.leftPad=Ro(s),this.rightPad=Ro(r),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,i,o){for(let l=0;l<i;++l){const c=this.getPadWidth(o),h=Math.max(0,c-l),d=Math.max(0,c-(i-(l+1))),p=o-(h+d),m=e+(h>0?0:l-c);let y=0;y+=h*this.leftPad.length;for(let T=0;T<p;++T)y+=t[m+T].length;y+=d*this.rightPad.length;const b=h+d+p-1;y+=b*this.separator.length,s[r+l]=new Uint8Array(y);const x=s[r+l];let w=0;const S=T=>T.forEach(k=>x[w++]=k);for(let T=0;T<h;++T)S(this.leftPad),S(this.separator);for(let T=0;T<p-1;++T)S(t[m+T]),S(this.separator);if(p>0){S(t[m+p-1]);for(let T=0;T<d;++T)S(this.separator),S(this.rightPad)}else{for(let T=0;T<d-1;++T)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let c=e[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let h=1;h<r;++h){let d=e[h]>=c;if(d=d&&e[h]<=s,!d)throw new Error(`Invalid split value ${e[h]}, must be in [${c}, ${s}]`);c=e[h]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const i=r-1,o=tn("int32",r);if(s===0||r===0){const c=new Array(s);for(let h=0;h<=i;++h)o[h]=0;return[c,o]}o[0]=0;for(let c=1;c<=i;++c){const h=e[c]-e[c-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&d===0&&(d=1),o[c]=o[c-1]+d}const l=new Array(o[i]);for(let c=0;c<i;++c){const h=e[c];let d=o[c];if(this.nGramWidths.forEach(p=>{const m=e[c+1]-e[c],y=this.getNumNGrams(m,p);this.createNGrams(t,h,l,d,y,p),d+=y}),this.preserveShort&&d===o[c]){const p=e[c+1]-e[c];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(t,h,l,d,1,m)}}return[l,o]}}function UF(n,t,e,s,r,i,o,l){return new Qtt(e,s,r,i,o,l).compute(n,t)}function tet(n,t,e,s){if(!n.length)return;if(t.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(t.length===1){const i=t[0];let o=n.indexOf(i);for(;o!==-1;){const l=n.subarray(0,o);(!e||l.length!==0)&&s.push(l),n=n.subarray(o+1),o=n.indexOf(i)}(!e||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||t.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!e||o.length!==0)&&s.push(o),r=i+1}}function jF(n,t,e){const s=n.length,r=[];let i=0,o=0;const l=new Array(s);for(let m=0;m<s;++m){const y=r.length;tet(n[m],t,e,r);const b=r.length-y;l[m]=b,i+=b,o=Math.max(o,b)}const c=tn("int32",i*2),h=new Array(i),d=[s,o];let p=0;for(let m=0;m<s;++m)for(let y=0;y<l[m];++y)c[p*2]=m,c[p*2+1]=y,h[p]=r[p],++p;return[c,h,d]}function GF(n,t){const e=tn("int32",n.length);for(let s=0;s<n.length;++s)e[s]=c6(n[s]).modulo(t).getLowBitsUnsigned();return e}const WF=on(((n,t)=>n-t)),eet=xC(((n,t,e,s)=>({real:n-e,imag:t-s}))),TC=kn(Hd,WF,eet),net={kernelName:Hd,backendName:"cpu",kernelFunc:TC};function HF(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=Qt(e,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let c=0;c<o.length;c++)o[c]=i[c]%n.shape[c];const l=n.locToIndex(o);s.values[r]=n.values[l]}return s}const dh=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function qF(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const l=s-e+1,c=t-e+1,h=Math.log(l),d=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*d*(l-d)/l)*Math.sign(c-l/2),m=Math.max(e,Math.floor(t-c*d/l+p)),y=Math.min(s,Math.floor(t+(l-c)*d/l+p));qF(n,t,m,y)}const r=n[t];let i=e,o=s;for(fc(n,e,t),dh(n[s],r)>0&&fc(n,e,s);i<o;){for(fc(n,i,o),i++,o--;dh(n[i],r)<0;)i=i+1;for(;dh(n[o],r)>0;)o=o-1}dh(n[e],r)===0?fc(n,e,o):(o=o+1,fc(n,o,s)),o<=t&&(e=o+1),t<=o&&(s=o-1)}}function KF(n,t,e,s,r){const i=t[t.length-1],[o,l]=[n.length/i,i],c=Zn(e,o*s),h=Zn("int32",o*s);for(let p=0;p<o;p++){const m=p*l,y=n.subarray(m,m+l);let b=new Array(y.length);y.forEach((T,k)=>b[k]={value:T,index:k}),s<b.length&&(qF(b,s),b=b.slice(0,s)),r&&b.sort(dh);const x=p*s,w=c.subarray(x,x+s),S=h.subarray(x,x+s);for(let T=0;T<s;T++)w[T]=b[T].value,S[T]=b[T].index}const d=t.slice();return d[d.length-1]=s,[Qt(d,e,c),Qt(d,"int32",h)]}function XF(n,t,e,s){const r=te(t,e)[0],i=[1,e[0],1];for(let b=0;b<r;b++)i[0]*=e[b];i[1]=e[r];for(let b=r+1;b<e.length;b++)i[2]*=e[b];const o=new Map,l=new Int32Array(e[r]),c=new Pn(i,s,n),h=[],d=i[0]===1&&i[2]===1;for(let b=0;b<e[r];b++){let x;if(d)x=n[b].toString();else{const S=[];for(let T=0;T<i[0];T++)for(let k=0;k<i[2];k++)S.push(c.get(T,b,k));x=S.join(",")}const w=o.get(x);if(w!=null)l[b]=w;else{const S=o.size;o.set(x,S),l[b]=S,h.push(b)}}const p=i.slice();p[1]=o.size;const m=new Pn(p,s);h.forEach((b,x)=>{for(let w=0;w<i[0];w++)for(let S=0;S<i[2];S++)m.set(c.get(w,b,S),w,x,S)});const y=e.slice();return y[r]=p[1],{outputValues:m.values,outputShape:y,indices:l}}const set=Object.freeze(Object.defineProperty({__proto__:null,addImpl:rF,bincountImpl:vC,bincountReduceImpl:iF,bitwiseAndImpl:oF,castImpl:sF,ceilImpl:aF,concatImpl:lF,equalImpl:cF,expImpl:hF,expm1Impl:fF,floorDivImpl:mF,floorImpl:pF,gatherNdImpl:gF,gatherV2Impl:yF,greaterEqualImpl:xF,greaterImpl:bF,lessEqualImpl:wF,lessImpl:vF,linSpaceImpl:SF,logImpl:CF,maxImpl:TF,maximumImpl:kF,minimumImpl:$F,multiplyImpl:wC,negImpl:EF,notEqualImpl:IF,prodImpl:NF,raggedGatherImpl:AF,raggedRangeImpl:_F,raggedTensorToTensorImpl:RF,rangeImpl:DF,rsqrtImpl:OF,scatterImpl:za,sigmoidImpl:jtt,simpleAbsImpl:nF,sliceImpl:FF,sparseFillEmptyRowsImpl:LF,sparseReshapeImpl:PF,sparseSegmentReductionImpl:CC,sqrtImpl:Htt,squaredDifferenceImpl:zF,staticRegexReplaceImpl:BF,stridedSliceImpl:VF,stringNGramsImpl:UF,stringSplitImpl:jF,stringToHashBucketFastImpl:GF,subImpl:WF,tileImpl:HF,topKImpl:KF,transposeImpl:SC,uniqueImpl:XF},Symbol.toStringTag,{value:"Module"}));fD("cpu",()=>new _0,1);const YF=ke(md,n=>n>=0?n:Math.exp(n)-1),ret={kernelName:md,backendName:"cpu",kernelFunc:YF};function ZF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s;Nt([r],"leakyRelu");const o=ft(r.shape),l=e.data.get(r.dataId).values,c=Zn("float32",o);for(let h=0;h<l.length;h++)c[h]=l[h]<0?i*l[h]:l[h];return e.makeTensorInfo(r.shape,"float32",c)}const iet={kernelName:Ag,backendName:"cpu",kernelFunc:ZF};const oet=on((n,t)=>n<0?t*n:n);function JF(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t;Nt([s,r],"prelu");const i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,[l,c]=oet(s.shape,r.shape,i,o,"float32");return e.makeTensorInfo(c,"float32",l)}const aet={kernelName:Xg,backendName:"cpu",kernelFunc:JF};const QF=ke(Od,n=>Math.max(0,n)),cet={kernelName:Od,backendName:"cpu",kernelFunc:QF};const tL=ke(Md,n=>Math.min(Math.max(0,n),6)),uet={kernelName:Md,backendName:"cpu",kernelFunc:tL};function Ym(n,t,e,s,r){if(e==="linear")return bi({inputs:{x:t},backend:n});if(e==="relu")return QF({inputs:{x:t},backend:n});if(e==="elu")return YF({inputs:{x:t},backend:n});if(e==="relu6")return tL({inputs:{x:t},backend:n});if(e==="prelu")return JF({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return ZF({inputs:{x:t},backend:n,attrs:{alpha:r}});if(e==="sigmoid")return MF({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Le(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=ft(r.shape),l=CR(i,o),c=ft(l);L(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const h=e.data.get(r.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;d.shape=l,p.shape=l}return{dataId:r.dataId,shape:l,dtype:r.dtype}}const het={kernelName:Zg,backendName:"cpu",kernelFunc:Le};function eL(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:l}=s;Nt([r,i],"matMul");const c=r.shape.length,h=i.shape.length,d=o?r.shape[c-2]:r.shape[c-1],p=l?i.shape[h-1]:i.shape[h-2],m=o?r.shape[c-1]:r.shape[c-2],y=l?i.shape[h-2]:i.shape[h-1],b=r.shape.slice(0,-2),x=i.shape.slice(0,-2),w=ft(b),S=ft(x),k=qt(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,y]);L(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${l} must match.`);const $=o?[w,d,m]:[w,m,d],E=l?[S,y,p]:[S,p,y],N=Le({inputs:{x:r},backend:e,attrs:{shape:$}}),_=Le({inputs:{x:i},backend:e,attrs:{shape:E}}),R=o?N.shape[1]:N.shape[2],D=o?N.shape[2]:N.shape[1],O=l?_.shape[1]:_.shape[2],A=Math.max(w,S),z=e.data.get(N.dataId).values,q=e.data.get(_.dataId).values,W=Ot(N.shape),X=Ot(_.shape),[P,V,G]=o?[W[0],1,W[1]]:[W[0],W[1],1],[tt,Z,F]=l?[1,X[1],X[0]]:[X[1],1,X[0]],B=D*O,Q=Qt([A,D,O],N.dtype),lt=Q.values,pt=e.blockSize;for(let gt=0;gt<A;gt++){const vt=gt%w,kt=gt%S;for(let Ct=0;Ct<D;Ct+=pt){const Rt=Math.min(Ct+pt,D);for(let Gt=0;Gt<O;Gt+=pt){const re=Math.min(Gt+pt,O);for(let ge=0;ge<R;ge+=pt){const de=Math.min(ge+pt,R);for(let pe=Ct;pe<Rt;pe++)for(let ae=Gt;ae<re;ae++){let Ne=0;for(let Ce=ge;Ce<de;Ce++){const Pt=z[vt*P+pe*V+Ce*G],Jt=q[Ce*tt+ae*Z+kt*F];Ne+=Pt*Jt}lt[gt*B+(pe*O+ae)]+=Ne}}}}}return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(_),e.makeTensorInfo(k,Q.dtype,Q.values)}const det={kernelName:mg,backendName:"cpu",kernelFunc:eL};function fet(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=t,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;let m,y,b;const x=[];m=eL({inputs:{a:r,b:i},attrs:{transposeA:c,transposeB:h},backend:e}),o&&(y=Lc({inputs:{a:m,b:o},backend:e}),x.push(m),m=y),d&&(b=Ym(e,m,d,l,p),x.push(m),m=b);for(const S of x)e.disposeIntermediateTensorInfo(S);return m}const pet={kernelName:Im,backendName:"cpu",kernelFunc:fet};const met=ke(nd,n=>Math.acos(n)),get={kernelName:nd,backendName:"cpu",kernelFunc:met};const yet=ke(sd,n=>Math.acosh(n)),bet={kernelName:sd,backendName:"cpu",kernelFunc:yet};function xet(n){const{inputs:t,backend:e}=n,s=t;Nt(t,"addN");const r=s.map(l=>e.data.get(l.dataId).values),i=Qt(s[0].shape,s[0].dtype),o=i.values;for(let l=0;l<s.length;l++){const c=r[l];for(let h=0;h<o.length;h++)o[h]+=c[h]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}const vet={kernelName:i1,backendName:"cpu",kernelFunc:xet};function wet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"all");const l=te(i,r.shape);let c=l;const h=qe(c,r.shape.length);let d=r;h!=null&&(d=Ss({inputs:{x:r},backend:e,attrs:{perm:h}}),c=sn(c.length,r.shape.length)),Bn("all",c,d.shape.length);const[p,m]=On(d.shape,c),y=ft(m),b=Jn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k&&E}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=hn(p,l),T=Le({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const Cet={kernelName:o1,backendName:"cpu",kernelFunc:wet};function Tet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"any");const l=te(i,r.shape);let c=l;const h=qe(c,r.shape.length);let d=r;h!=null&&(d=Ss({inputs:{x:r},backend:e,attrs:{perm:h}}),c=sn(c.length,r.shape.length)),Bn("any",c,d.shape.length);const[p,m]=On(d.shape,c),y=ft(m),b=Jn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k||E}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=hn(p,l),T=Le({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const ket={kernelName:a1,backendName:"cpu",kernelFunc:Tet};function $et(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;Nt(r,"argMax");let o=te(i,r.shape);const l=qe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=Ss({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=sn(o.length,c.shape.length)),o=[o[0]],Bn("argMax",o,c.shape.length);const[d,p]=On(c.shape,o),m=ft(d),y=Jn(m,"int32"),b=ft(p),x=e.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E>T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(d,"int32",y)}const Eet={kernelName:hg,backendName:"cpu",kernelFunc:$et};function Iet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;Nt(r,"argMin");let o=te(i,r.shape);const l=qe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=Ss({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=sn(o.length,c.shape.length)),o=[o[0]],Bn("argMin",o,c.shape.length);const[d,p]=On(c.shape,o),m=ft(d),y=Jn(m,"int32"),b=ft(p),x=e.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E<T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(d,"int32",y)}const Net={kernelName:dg,backendName:"cpu",kernelFunc:Iet};const Aet=ke(rd,n=>Math.asin(n)),_et={kernelName:rd,backendName:"cpu",kernelFunc:Aet};const Ret=ke(id,n=>Math.asinh(n)),Det={kernelName:id,backendName:"cpu",kernelFunc:Ret};const Oet=ke(od,n=>Math.atan(n)),Met={kernelName:od,backendName:"cpu",kernelFunc:Oet};const Fet=on((n,t)=>Math.atan2(n,t)),Let=kn(ld,Fet),Pet={kernelName:ld,backendName:"cpu",kernelFunc:Let};const zet=ke(ad,n=>Math.atanh(n)),Bet={kernelName:ad,backendName:"cpu",kernelFunc:zet};function kC(n,t,e,s,r,i){const o=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Qt(r.outShape,e),w=x.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3],T=r.outShape[2]*r.outShape[3],k=r.outShape[3];for(let $=0;$<r.batchSize;++$){const E=$*S,N=$*s[0];for(let _=0;_<r.inChannels;++_)for(let R=0;R<r.outHeight;++R){const D=R*o-m,O=Math.max(0,D),A=Math.min(r.inHeight,d+D),z=E+R*T;for(let q=0;q<r.outWidth;++q){const W=q*l-y,X=Math.max(0,W),P=Math.min(r.inWidth,p+W);let V=b,G=0,tt=0;for(let F=O;F<A;F+=c){const B=N+F*s[1];for(let Q=X;Q<P;Q+=h){const lt=B+Q*s[2],pt=n[lt+_];i==="max"&&pt>V?V=pt:i==="avg"&&(G+=pt,tt++)}if(isNaN(V))break}const Z=z+q*k+_;w[Z]=i==="avg"?G/tt:V}}}return x}function nL(n,t,e,s,r=!1,i=!1){const o=Qt(s.outShape,"int32"),l=s.strideHeight,c=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=Qt(t,e,n);for(let w=0;w<s.batchSize;++w)for(let S=0;S<s.inChannels;++S)for(let T=0;T<s.outHeight;++T){const k=T*l-y;let $=k;for(;$<0;)$+=h;const E=Math.min(s.inHeight,p+k);for(let N=0;N<s.outWidth;++N){const _=N*c-b;let R=_;for(;R<0;)R+=d;const D=Math.min(s.inWidth,m+_);let O=Number.NEGATIVE_INFINITY,A=-1;for(let z=$;z<E;z+=h){const q=z-k;for(let W=R;W<D;W+=d){const X=W-_,P=x.get(w,z,W,S);P>O&&(O=P,r?A=i?((w*s.inHeight+z)*s.inWidth+W)*s.inChannels+S:(z*s.inWidth+W)*s.inChannels+S:A=q*m+X)}}o.set(A,w,T,N,S)}}return o}function sL(n,t,e,s,r,i){const o=r.strideDepth,l=r.strideHeight,c=r.strideWidth,h=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,S=r.padInfo.left,T=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=Qt(r.outShape,e),$=k.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[3]*r.outShape[4],R=r.outShape[4];for(let D=0;D<r.batchSize;++D){const O=D*E,A=D*s[0];for(let z=0;z<r.inChannels;++z)for(let q=0;q<r.outDepth;++q){const W=q*o-x;let X=W;for(;X<0;)X+=h;const P=Math.min(r.inDepth,m+W),V=O+q*N;for(let G=0;G<r.outHeight;++G){const tt=G*l-w;let Z=tt;for(;Z<0;)Z+=d;const F=Math.min(r.inHeight,y+tt),B=V+G*_;for(let Q=0;Q<r.outWidth;++Q){const lt=Q*c-S;let pt=lt;for(;pt<0;)pt+=p;const gt=Math.min(r.inWidth,b+lt),vt=B+Q*R;let kt=T,Ct=0,Rt=0;for(let re=X;re<P;re+=h){const ge=A+re*s[1];for(let de=Z;de<F;de+=d){const pe=ge+de*s[2];for(let ae=pt;ae<gt;ae+=p){const Ne=pe+ae*s[3],Ce=n[Ne+z];if(i==="max"&&Ce>kt?kt=Ce:i==="avg"&&(Ct+=Ce,Rt++),isNaN(kt))break}if(isNaN(kt))break}if(isNaN(kt))break}const Gt=vt+z;$[Gt]=i==="avg"?Ct/Math.max(Rt,1):kt}}}}return k}function Vet(n,t){const e=Qt(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,h=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;for(let x=0;x<t.batchSize;++x)for(let w=0;w<t.inChannels;++w)for(let S=0;S<t.outDepth;++S){const T=S*s-m;let k=T;for(;k<0;)k+=o;const $=Math.min(t.inDepth,h+T);for(let E=0;E<t.outHeight;++E){const N=E*r-y;let _=N;for(;_<0;)_+=l;const R=Math.min(t.inHeight,d+N);for(let D=0;D<t.outWidth;++D){const O=D*i-b;let A=O;for(;A<0;)A+=c;const z=Math.min(t.inWidth,p+O);let q=Number.NEGATIVE_INFINITY,W=-1;for(let X=k;X<$;X+=o){const P=X-T;for(let V=_;V<R;V+=l){const G=V-N;for(let tt=A;tt<z;tt+=c){const Z=tt-O,F=n.get(x,X,V,tt,w);F>=q&&(q=F,W=P*d*p+G*d+Z)}}}e.set(W,x,S,E,D,w)}}}return e}function Uet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Nt(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(ts(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Tr(r.shape,i,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))p=bi({inputs:{x:r},backend:e});else{const m=e.data.get(r.dataId).values,y=Ot(r.shape),b=kC(m,r.shape,r.dtype,y,d,"avg");p=e.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const jet={kernelName:fg,backendName:"cpu",kernelFunc:Uet};function Get(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Nt(r,"avgPool3d");const d=Yi(r.shape,i,o,1,l,c,h),p=e.data.get(r.dataId).values,m=sL(p,r.shape,r.dtype,Ot(r.shape),d,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}const Wet={kernelName:pg,backendName:"cpu",kernelFunc:Get};function Het(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Nt([r,i],"avgPool3DGrad");const d=Yi(i.shape,o,l,1,c,h),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,S=d.dilationDepth,T=d.dilationHeight,k=d.dilationWidth,$=d.effectiveFilterDepth,E=d.effectiveFilterHeight,N=d.effectiveFilterWidth,_=$-1-d.padInfo.front,R=N-1-d.padInfo.left,D=E-1-d.padInfo.top,O=Qt(i.shape,"float32"),A=1/(b*x*w),z=e.bufferSync(r);for(let q=0;q<d.batchSize;++q)for(let W=0;W<d.inChannels;++W)for(let X=0;X<d.inDepth;++X)for(let P=0;P<d.inHeight;++P)for(let V=0;V<d.inWidth;++V){const G=X-_,tt=P-D,Z=V-R;let F=0;for(let B=0;B<$;B+=S){const Q=(G+B)/p;if(!(Q<0||Q>=d.outDepth||Math.floor(Q)!==Q))for(let lt=0;lt<E;lt+=T){const pt=(tt+lt)/m;if(!(pt<0||pt>=d.outHeight||Math.floor(pt)!==pt))for(let gt=0;gt<N;gt+=k){const vt=(Z+gt)/y;if(vt<0||vt>=d.outWidth||Math.floor(vt)!==vt)continue;const kt=z.get(q,Q,pt,vt,W);F+=kt}}}O.set(F*A,q,X,P,V,W)}return e.makeTensorInfo(O.shape,O.dtype,O.values)}const qet={kernelName:c1,backendName:"cpu",kernelFunc:Het};function Ket(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;Nt([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=Tr(o.shape,l,c,1,h),p=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,S=d.effectiveFilterHeight,T=d.effectiveFilterWidth,k=T-1-d.padInfo.left,$=S-1-d.padInfo.top,E=Qt(o.shape,"float32"),N=1/(y*b),_=e.data.get(r.dataId).values,R=Qt(r.shape,"float32",_);for(let D=0;D<d.batchSize;++D)for(let O=0;O<d.inChannels;++O)for(let A=0;A<d.inHeight;++A)for(let z=0;z<d.inWidth;++z){const q=A-$,W=z-k;let X=0;for(let P=0;P<S;P+=x){const V=(q+P)/p;if(!(V<0||V>=d.outHeight||Math.floor(V)!==V))for(let G=0;G<T;G+=w){const tt=(W+G)/m;if(tt<0||tt>=d.outWidth||Math.floor(tt)!==tt)continue;const Z=R.get(D,V,tt,O);X+=Z}}E.set(X*N,D,A,z,O)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}const Xet={kernelName:l1,backendName:"cpu",kernelFunc:Ket};function Yet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,scale:i,offset:o,mean:l,variance:c}=t;L(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(i==null||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Nt([r,l,c,i,o],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=e.data.get(r.dataId).values,p=e.data.get(l.dataId).values,m=e.data.get(c.dataId).values,y=i?e.data.get(i.dataId).values:new Float32Array([1]),b=o?e.data.get(o.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,S=y.length,T=m.length,k=p.length;let $=0,E=0,N=0,_=0;for(let R=0;R<d.length;++R)x[R]=b[$++]+(d[R]-p[E++])*y[N++]/Math.sqrt(m[_++]+h),$>=w&&($=0),E>=k&&(E=0),N>=S&&(N=0),_>=T&&(_=0);return e.makeTensorInfo(r.shape,r.dtype,x)}const Zet={kernelName:Eg,backendName:"cpu",kernelFunc:Yet};function Jet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;Nt([r],"batchToSpaceND");const l=i.reduce((S,T)=>S*T),c=rf(r.shape,i,l),h=of(c.length,i.length),d=af(r.shape,i,l),p=MS(o,i.length),m=FS(d,o,i.length),y=Le({inputs:{x:r},backend:e,attrs:{shape:c}}),b=Ss({inputs:{x:y},backend:e,attrs:{perm:h}}),x=Le({inputs:{x:b},backend:e,attrs:{shape:d}}),w=rl({inputs:{x},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),w}const Qet={kernelName:gg,backendName:"cpu",kernelFunc:Jet};function tnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,h=vC(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,h)}const ent={kernelName:u1,backendName:"cpu",kernelFunc:tnt};function nnt(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,l=qt(Array.from(i),Array.from(o));return e.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const snt={kernelName:NR,backendName:"cpu",kernelFunc:nnt};const rnt=ke(hd,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),int={kernelName:hd,backendName:"cpu",kernelFunc:rnt};const ont=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(ft(t.shape)),r=e.data.get(t.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,l=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values;for(let h=0;h<l.length;h++){const d=l[h],p=c[h];s[h]=Math.hypot(d,p)}return e.makeOutput(s,t.shape,"float32")},ant={kernelName:yg,backendName:"cpu",kernelFunc:ont};function Pc(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const lnt={kernelName:I1,backendName:"cpu",kernelFunc:Pc};function zc(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=te(r,t[0].shape)[0],o=t.map(x=>x.shape);RS(o,i);let l=ui(t.map(x=>x.shape),i);if(ft(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const c=t.filter(x=>ft(x.shape)>0);if(c.length===1)return bi({inputs:{x:c[0]},backend:e});if(c[0].dtype==="complex64"){const x=c.map($=>sl({inputs:{input:$},backend:e})),w=c.map($=>Pc({inputs:{input:$},backend:e})),S=zc({inputs:x,backend:e,attrs:{axis:i}}),T=zc({inputs:w,backend:e,attrs:{axis:i}}),k=Rs({inputs:{real:S,imag:T},backend:e});return x.forEach($=>e.disposeIntermediateTensorInfo($)),w.forEach($=>e.disposeIntermediateTensorInfo($)),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),k}const h=c.map(x=>{const S=[-1,ft(x.shape.slice(i))];return Le({inputs:{x},backend:e,attrs:{shape:S}})}),d=h.map(x=>({vals:e.data.get(x.dataId).values,shape:x.shape}));l=ui(h.map(x=>x.shape),1);const p=h[0].shape[0]===1,m=lF(d,l,t[0].dtype,p),y=ui(c.map(x=>x.shape),i),b=e.makeTensorInfo(y,t[0].dtype,m);return h.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const cnt={kernelName:bg,backendName:"cpu",kernelFunc:zc};function rL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s;Nt([r,i],"conv2d");const p=Zi(c),m=zn(r.shape,i.shape,o,h,l,d,!1,p),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,S=m.padInfo.left,T=m.padInfo.top,k=m.dataFormat==="channelsLast",$=new Pn(m.outShape,r.dtype),E=Ot(r.shape),N=Ot(i.shape),_=E[0],R=k?E[1]:E[2],D=k?E[2]:1,O=k?1:E[1],A=$.strides[0],z=k?$.strides[1]:$.strides[2],q=k?$.strides[2]:1,W=k?1:$.strides[1],X=e.data.get(r.dataId).values,P=e.data.get(i.dataId).values,V=$.values;for(let G=0;G<m.batchSize;++G){const tt=G*_,Z=G*A;for(let F=0;F<m.outHeight;++F){const B=Z+F*z,Q=F*m.strideHeight-T;for(let lt=0;lt<y;++lt){const pt=Q+lt*x;if(pt<0||pt>=m.inHeight)continue;const gt=lt*N[0],vt=tt+pt*R;for(let kt=0;kt<m.outWidth;++kt){const Ct=B+kt*q,Rt=kt*m.strideWidth-S;for(let Gt=0;Gt<b;++Gt){const re=Rt+Gt*w;if(re<0||re>=m.inWidth)continue;const ge=gt+Gt*N[1],de=vt+re*D;let pe=ge;for(let ae=0;ae<m.inChannels;++ae){const Ne=X[de+ae*O];for(let Ce=0;Ce<m.outChannels;++Ce)V[Ct+Ce*W]+=Ne*P[pe+Ce];pe+=m.outChannels}}}}}}return e.makeTensorInfo($.shape,$.dtype,V)}const unt={kernelName:xg,backendName:"cpu",kernelFunc:rL};function hnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s;Nt([r,i],"conv2dBackpropFilter");const p=Zi(c),m=zn(r.shape,d,o,1,l,h,!1,p),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,S=m.dataFormat==="channelsLast",T=new Pn(m.filterShape,"float32"),k=m.padInfo.left,$=m.padInfo.top,E=e.data.get(r.dataId).values,N=e.data.get(i.dataId).values,_=new Pn(r.shape,r.dtype,E),R=new Pn(i.shape,i.dtype,N);for(let D=0;D<x;++D){const O=Math.max(0,Math.ceil(($-D)/y)),A=Math.min(m.outHeight,(m.inHeight+$-D)/y);for(let z=0;z<w;++z){const q=Math.max(0,Math.ceil((k-z)/b)),W=Math.min(m.outWidth,(m.inWidth+k-z)/b);for(let X=0;X<m.inChannels;++X)for(let P=0;P<m.outChannels;++P){let V=0;for(let G=0;G<m.batchSize;++G)for(let tt=O;tt<A;++tt){const Z=D+tt*y-$;for(let F=q;F<W;++F){const B=z+F*b-k;S?V+=_.get(G,Z,B,X)*R.get(G,tt,F,P):V+=_.get(G,X,Z,B)*R.get(G,P,tt,F)}}T.set(V,D,z,X,P)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const dnt={kernelName:f1,backendName:"cpu",kernelFunc:hnt};function fnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s;Nt([r,i],"conv2dBackpropInput");const p=Ot(i.shape),m=Ot(r.shape);let y=Zi(h);const b=zn(o,i.shape,l,1,c,d,!1,y),x=new Pn(b.inShape,"float32"),w=x.values,S=e.data.get(r.dataId).values,T=e.data.get(i.dataId).values,[k,$,E]=p,{batchSize:N,filterHeight:_,filterWidth:R,inChannels:D,inHeight:O,inWidth:A,outChannels:z,outHeight:q,outWidth:W,strideHeight:X,strideWidth:P}=b;y=b.dataFormat;const V=_-1-b.padInfo.top,G=R-1-b.padInfo.left,tt=y==="channelsLast",Z=x.strides[0],F=tt?x.strides[1]:x.strides[2],B=tt?x.strides[2]:1,Q=tt?1:x.strides[1],lt=m[0],pt=tt?m[1]:m[2],gt=tt?m[2]:1,vt=tt?1:m[1];for(let kt=0;kt<N;++kt)for(let Ct=0;Ct<D;++Ct)for(let Rt=0;Rt<O;++Rt){const Gt=Rt-V,re=Math.max(0,Math.ceil(Gt/X)),ge=Math.min(q,(_+Gt)/X);for(let de=0;de<A;++de){const pe=de-G,ae=Math.max(0,Math.ceil(pe/P)),Ne=Math.min(W,(R+pe)/P);let Ce=0;for(let Jt=re;Jt<ge;++Jt){const $n=Jt*X-Gt;for(let dn=ae;dn<Ne;++dn){const ds=dn*P-pe,me=lt*kt+pt*Jt+gt*dn,an=k*(_-1-$n)+$*(R-1-ds)+E*Ct;for(let Un=0;Un<z;++Un){const Er=S[me+vt*Un],Ps=T[an+Un];Ce+=Er*Ps}}}const Pt=Z*kt+F*Rt+B*de+Q*Ct;w[Pt]=Ce}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const pnt={kernelName:vg,backendName:"cpu",kernelFunc:fnt};function mnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c}=s;Nt([r,i],"conv3d");const h=qo(r.shape,i.shape,o,c,l),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,S=w.front,T=w.left,k=w.top,$=new Pn(h.outShape,r.dtype),E=e.data.get(r.dataId).values,N=e.data.get(i.dataId).values,_=$.values,R=Ot(r.shape),D=Ot(i.shape);for(let O=0;O<h.batchSize;++O){const A=O*R[0],z=O*$.strides[0];for(let q=0;q<h.outDepth;++q){const W=z+q*$.strides[1],X=q*h.strideDepth-S;for(let P=0;P<d;++P){const V=X+P*y;if(V<0||V>=h.inDepth)continue;const G=P*D[0],tt=A+V*R[1];for(let Z=0;Z<h.outHeight;++Z){const F=W+Z*$.strides[2],B=Z*h.strideHeight-k;for(let Q=0;Q<p;++Q){const lt=B+Q*b;if(lt<0||lt>=h.inHeight)continue;const pt=G+Q*D[1],gt=tt+lt*R[2];for(let vt=0;vt<h.outWidth;++vt){const kt=F+vt*h.outChannels,Ct=vt*h.strideWidth-T;for(let Rt=0;Rt<m;++Rt){const Gt=Ct+Rt*x;if(Gt<0||Gt>=h.inWidth)continue;const re=pt+Rt*D[2],ge=gt+Gt*h.inChannels;let de=re;for(let pe=0;pe<h.inChannels;++pe){const ae=E[ge+pe];for(let Ne=0;Ne<h.outChannels;++Ne)_[kt+Ne]+=ae*N[de+Ne];de+=h.outChannels}}}}}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const gnt={kernelName:wg,backendName:"cpu",kernelFunc:mnt};function ynt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,filterShape:c}=s;Nt([r,i],"conv3dBackpropFilterV2");const h=Ot(r.shape),d=Ot(i.shape),p=qo(r.shape,c,o,1,l),m=p.strideDepth,y=p.strideHeight,b=p.strideWidth,x=p.filterDepth,w=p.filterHeight,S=p.filterWidth,T=new Pn(p.filterShape,"float32"),k=T.values,[$,E,N,_]=T.strides,R=e.data.get(i.dataId).values,[D,O,A,z]=d,q=e.data.get(r.dataId).values,[W,X,P,V]=h,G=p.padInfo.front,tt=p.padInfo.left,Z=p.padInfo.top;for(let F=0;F<x;++F){const B=Math.max(0,Math.ceil((G-F)/m)),Q=Math.min(p.outDepth,(p.inDepth+G-F)/m),lt=F*$;for(let pt=0;pt<w;++pt){const gt=Math.max(0,Math.ceil((Z-pt)/y)),vt=Math.min(p.outHeight,(p.inHeight+Z-pt)/y),kt=pt*E+lt;for(let Ct=0;Ct<S;++Ct){const Rt=Math.max(0,Math.ceil((tt-Ct)/b)),Gt=Math.min(p.outWidth,(p.inWidth+tt-Ct)/b),re=Ct*N+kt;for(let ge=0;ge<p.inChannels;++ge){const de=ge*_+re;for(let pe=0;pe<p.outChannels;++pe){let ae=0;for(let Ne=0;Ne<p.batchSize;++Ne){const Ce=Ne*W,Pt=Ne*D;for(let Jt=B;Jt<Q;++Jt){const dn=(F+Jt*m-G)*X+Ce,ds=Jt*O+Pt;for(let me=gt;me<vt;++me){const Un=(pt+me*y-Z)*P+dn,Er=me*A+ds;for(let Ps=Rt;Ps<Gt;++Ps){const gl=(Ct+Ps*b-tt)*V+Un,au=Ps*z+Er;ae+=q[gl+ge]*R[au+pe]}}}}k[de+pe]=ae}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const bnt={kernelName:p1,backendName:"cpu",kernelFunc:ynt};function xnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:l,inputShape:c}=s;Nt([r],"conv3dBackpropInputV2");const h=Ot(r.shape),d=Ot(i.shape),p=qo(c,i.shape,l,1,o),m=new Pn(p.inShape,"float32"),y=m.values,[b,x,w,S]=m.strides,T=e.data.get(r.dataId).values,[k,$,E,N]=h,_=e.data.get(i.dataId).values,[R,D,O,A]=d,{batchSize:z,filterDepth:q,filterHeight:W,filterWidth:X,inChannels:P,inDepth:V,inHeight:G,inWidth:tt,outChannels:Z,outDepth:F,outHeight:B,outWidth:Q,strideDepth:lt,strideHeight:pt,strideWidth:gt}=p,vt=q-1-p.padInfo.front,kt=W-1-p.padInfo.top,Ct=X-1-p.padInfo.left;for(let Rt=0;Rt<z;++Rt)for(let Gt=0;Gt<P;++Gt)for(let re=0;re<V;++re){const ge=re-vt,de=Math.max(0,Math.ceil(ge/lt)),pe=Math.min(F,(q+ge)/lt);for(let ae=0;ae<G;++ae){const Ne=ae-kt,Ce=Math.max(0,Math.ceil(Ne/pt)),Pt=Math.min(B,(W+Ne)/pt);for(let Jt=0;Jt<tt;++Jt){const $n=Jt-Ct,dn=Math.max(0,Math.ceil($n/gt)),ds=Math.min(Q,(X+$n)/gt);let me=0;for(let an=de;an<pe;++an){const Un=an*lt-ge;for(let Er=Ce;Er<Pt;++Er){const Ps=Er*pt-Ne;for(let ea=dn;ea<ds;++ea){const gl=ea*gt-$n,au=k*Rt+$*an+E*Er+N*ea,P0=R*(q-1-Un)+D*(W-1-Ps)+O*(X-1-gl)+A*Gt;for(let Kr=0;Kr<Z;++Kr){const fs=T[au+Kr],Xr=_[P0+Kr];me+=fs*Xr}}}}y[b*Rt+x*re+w*ae+S*Jt+Gt]=me}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const vnt={kernelName:m1,backendName:"cpu",kernelFunc:xnt};const wnt=ke(dd,n=>Math.cos(n)),Snt={kernelName:dd,backendName:"cpu",kernelFunc:wnt};const Cnt=ke(fd,n=>Math.cosh(n)),Tnt={kernelName:fd,backendName:"cpu",kernelFunc:Cnt};function knt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:l,method:c,extrapolationValue:h}=s,[d,p,m,y]=r.shape,b=i.shape[0],[x,w]=l,S=Qt([b,x,w,y],"float32"),T=e.data.get(i.dataId).values,k=e.data.get(o.dataId).values,$=e.data.get(r.dataId).values,E=Ot(r.shape),N=Ot(S.shape);for(let _=0;_<b;_++){const R=_*4,D=T[R],O=T[R+1],A=T[R+2],z=T[R+3],q=k[_];if(q>=d)continue;const W=x>1?(A-D)*(p-1)/(x-1):0,X=w>1?(z-O)*(m-1)/(w-1):0;for(let P=0;P<x;P++){const V=x>1?D*(p-1)+P*W:.5*(D+A)*(p-1);if(V<0||V>p-1){for(let G=0;G<w;G++)for(let tt=0;tt<y;tt++){const Z=tt+G*N[2]+P*N[1]+_*N[0];S.values[Z]=h}continue}if(c==="bilinear"){const G=Math.floor(V),tt=Math.ceil(V),Z=V-G;for(let F=0;F<w;F++){const B=w>1?O*(m-1)+F*X:.5*(O+z)*(m-1);if(B<0||B>m-1){for(let gt=0;gt<y;gt++){const vt=gt+F*N[2]+P*N[1]+_*N[0];S.values[vt]=h}continue}const Q=Math.floor(B),lt=Math.ceil(B),pt=B-Q;for(let gt=0;gt<y;gt++){let vt=gt+Q*E[2]+G*E[1]+q*E[0];const kt=$[vt];vt=gt+lt*E[2]+G*E[1]+q*E[0];const Ct=$[vt];vt=gt+Q*E[2]+tt*E[1]+q*E[0];const Rt=$[vt];vt=gt+lt*E[2]+tt*E[1]+q*E[0];const Gt=$[vt],re=kt+(Ct-kt)*pt,ge=Rt+(Gt-Rt)*pt;vt=gt+F*N[2]+P*N[1]+_*N[0],S.values[vt]=re+(ge-re)*Z}}}else for(let G=0;G<w;++G){const tt=w>1?O*(m-1)+G*X:.5*(O+z)*(m-1);if(tt<0||tt>m-1){for(let B=0;B<y;B++){const Q=B+G*N[2]+P*N[1]+_*N[0];S.values[Q]=h}continue}const Z=Math.round(tt),F=Math.round(V);for(let B=0;B<y;B++){const Q=B+Z*E[2]+F*E[1]+q*E[0],lt=B+G*N[2]+P*N[1]+_*N[0];S.values[lt]=$[Q]}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const $nt={kernelName:y1,backendName:"cpu",kernelFunc:knt};function Ent(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;Nt(r,"cumprod");const c=qe([i],r.shape.length);let h=r;c!=null&&(h=Ss({inputs:{x:r},backend:e,attrs:{perm:c}}));const d=sn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=Ms(h.dtype,"int32"),m=n1(ft(h.shape),p),y=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?1:y[k];else{const $=x(S,T-1);m[k]=o?y[$]*m[$]:y[k]*m[$]}}const w=e.makeTensorInfo(h.shape,p,m);if(c!=null){const S=Ko(c),T=Ss({inputs:{x:w},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(h),T}return w}const Int={kernelName:g1,backendName:"cpu",kernelFunc:Ent};function Nnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;Nt(r,"cumsum");const c=qe([i],r.shape.length);let h=r;c!=null&&(h=Ss({inputs:{x:r},backend:e,attrs:{perm:c}}));const d=sn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=Ms(h.dtype,"int32"),m=Jn(ft(h.shape),p),y=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?0:y[k];else{const $=x(S,T-1);m[k]=o?y[$]+m[$]:y[k]+m[$]}}const w=e.makeTensorInfo(h.shape,p,m);if(c!=null){const S=Ko(c),T=Ss({inputs:{x:w},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(h),T}return w}const Ant={kernelName:Sg,backendName:"cpu",kernelFunc:Nnt};function _nt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const c=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=vC(c,h,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,d)}else if(r.shape.length===2){const c=e.bufferSync(r),h=e.bufferSync(i),d=iF(c,h,o,l);return e.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Rnt={kernelName:b1,backendName:"cpu",kernelFunc:_nt};function Dnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s;L(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const l=r.shape[0],c=r.shape[1],h=r.shape[2],d=r.shape[3],p=c*i,m=h*i,y=d/(i*i),b=e.data.get(r.dataId).values,x=new Float32Array(l*p*m*y);let w=0;for(let S=0;S<l;++S)for(let T=0;T<p;++T){const k=Math.floor(T/i),$=T%i;for(let E=0;E<m;++E){const N=Math.floor(E/i),_=E%i,R=($*i+_)*y;for(let D=0;D<y;++D){const A=D+R+d*(N+h*(k+c*S));x[w++]=b[A]}}}return e.makeTensorInfo([l,p,m,y],r.dtype,x)}const Ont={kernelName:x1,backendName:"cpu",kernelFunc:Dnt};function iL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;Nt([r,i],"depthwiseConv2DNative");const d=Ot(r.shape),p=Ot(i.shape);let m=c;m==null&&(m=[1,1]),L(ts(o,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);const y=zn(r.shape,i.shape,o,m,l,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:S,padInfo:T}=y,k=T.left,$=T.top,E=y.outChannels/y.inChannels,N=new Pn(y.outShape,r.dtype),_=e.data.get(r.dataId).values,R=e.data.get(i.dataId).values,D=N.values;for(let O=0;O<y.batchSize;++O){const A=O*d[0],z=O*N.strides[0];for(let q=0;q<y.outHeight;++q){const W=z+q*N.strides[1],X=q*y.strideHeight-$;for(let P=0;P<b;++P){const V=X+P*w;if(V<0||V>=y.inHeight)continue;const G=P*p[0],tt=A+V*d[1];for(let Z=0;Z<y.outWidth;++Z){const F=W+Z*N.strides[2],B=Z*y.strideWidth-k;for(let Q=0;Q<x;++Q){const lt=B+Q*S;if(lt<0||lt>=y.inWidth)continue;const pt=G+Q*p[1],gt=tt+lt*y.inChannels;let vt=F,kt=pt;for(let Ct=0;Ct<y.inChannels;++Ct){const Rt=_[gt+Ct];for(let Gt=0;Gt<E;++Gt)D[vt+Gt]+=Rt*R[kt+Gt];vt+=E,kt+=E}}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const Mnt={kernelName:Cg,backendName:"cpu",kernelFunc:iL};function Fnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s;Nt([r,i],"depthwiseConv2dNativeBackpropFilter");const p=zn(r.shape,d,o,l,c,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=p,w=new Pn(p.filterShape,"float32"),S=p.padInfo.left,T=p.padInfo.top,k=p.outChannels/p.inChannels,$=e.data.get(r.dataId).values,E=new Pn(r.shape,r.dtype,$),N=e.data.get(i.dataId).values,_=new Pn(i.shape,i.dtype,N);for(let R=0;R<b;++R){const D=Math.max(0,Math.ceil((T-R)/m)),O=Math.min(p.outHeight,(p.inHeight+T-R)/m);for(let A=0;A<x;++A){const z=Math.max(0,Math.ceil((S-A)/y)),q=Math.min(p.outWidth,(p.inWidth+S-A)/y);for(let W=0;W<p.outChannels;++W){const X=Math.trunc(W/k),P=W%k;let V=0;for(let G=0;G<p.batchSize;++G)for(let tt=D;tt<O;++tt){const Z=R+tt*m-T;for(let F=z;F<q;++F){const B=A+F*y-S;V+=E.get(G,Z,B,X)*_.get(G,tt,F,W)}}w.set(V,R,A,X,P)}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const Lnt={kernelName:v1,backendName:"cpu",kernelFunc:Fnt};function Pnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s;Nt([r,i],"depthwiseConv2DNativeBackpropInput");const p=Ot(r.shape),m=Ot(i.shape),y=zn(d,i.shape,o,l,c,h,!0),b=new Pn(y.inShape,"float32"),x=b.values,[w,S,T]=b.strides,k=e.data.get(r.dataId).values,[$,E,N]=p,_=e.data.get(i.dataId).values,[R,D,O]=m,{batchSize:A,filterHeight:z,filterWidth:q,inChannels:W,inHeight:X,inWidth:P,outChannels:V,outHeight:G,outWidth:tt,strideHeight:Z,strideWidth:F}=y,B=z-1-y.padInfo.top,Q=q-1-y.padInfo.left,lt=V/W;for(let pt=0;pt<A;++pt)for(let gt=0;gt<W;++gt)for(let vt=0;vt<X;++vt){const kt=vt-B,Ct=Math.max(0,Math.ceil(kt/Z)),Rt=Math.min(G,(z+kt)/Z);for(let Gt=0;Gt<P;++Gt){const re=Gt-Q,ge=Math.max(0,Math.ceil(re/F)),de=Math.min(tt,(q+re)/F);let pe=0;for(let ae=Ct;ae<Rt;++ae){const Ne=ae*Z-kt;for(let Ce=ge;Ce<de;++Ce){const Pt=Ce*F-re,Jt=$*pt+E*ae+N*Ce,$n=R*(z-1-Ne)+D*(q-1-Pt)+O*gt;for(let dn=0;dn<lt;++dn){const ds=gt*lt+dn,me=k[Jt+ds],an=_[$n+dn];pe+=me*an}}}x[w*pt+S*vt+T*Gt+gt]=pe}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const znt={kernelName:w1,backendName:"cpu",kernelFunc:Pnt};function Bnt(n){const{inputs:t,backend:e}=n,{x:s}=t,r=ft(s.shape),i=e.data.get(s.dataId).values,o=Qt([r,r],s.dtype),l=o.values;for(let h=0;h<i.length;h++)l[h*r+h]=i[h];const c=[...s.shape,...s.shape];return e.makeTensorInfo(c,o.dtype,o.values)}const Vnt={kernelName:AR,backendName:"cpu",kernelFunc:Bnt};const Unt={kernelName:Tg,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:l}=e,c=t,h=c.data.get(s.dataId).values,d=s.shape.length,p=c.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:S,outWidth:T,padInfo:k,strideHeight:$,strideWidth:E,filterHeight:N,filterWidth:_,dilationHeight:R,dilationWidth:D,outShape:O}=Qd(s.shape,r.shape,i,o,"NHWC",l),A=ft(O),z=O.length,q=tn(s.dtype,A);for(let X=0;X<y;++X)for(let P=0;P<S;++P){const V=P*$-k.top;for(let G=0;G<T;++G){const tt=G*E-k.left;for(let Z=0;Z<w;++Z){let F=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<N;++Q){const lt=V+Q*R;if(lt>=0&&lt<b)for(let pt=0;pt<_;++pt){const gt=tt+pt*D;if(gt>=0&&gt<x){const vt=li([X,lt,gt,Z],d,Ot(s.shape)),kt=li([Q,pt,Z],m,Ot(r.shape)),Ct=h[vt]+p[kt];Ct>F&&(F=Ct)}}}const B=li([X,P,G,Z],z,Ot(O));q[B]=F}}}return{dataId:c.write(ol(q,s.dtype),O,s.dtype),shape:O,dtype:s.dtype}}};const jnt={kernelName:Dv,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:c}=e,h=t,d=Vr(s.shape,h.data.get(s.dataId).values),p=Vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Qd(s.shape,r.shape,o,l,"NHWC",c);L(i.rank===D.length,()=>`Error in ${Dv}, dy must have the same rank as output ${D.length}, but got ${i.rank}`);const O=Vr(D,h.data.get(i.dataId).values),A=$R(r.shape,r.dtype);for(let q=0;q<m;++q)for(let W=0;W<w;++W){const X=W*k-T.top;for(let P=0;P<S;++P){const V=P*$-T.left;for(let G=0;G<x;++G){let tt=Number.MIN_SAFE_INTEGER,Z=0,F=0;for(let B=0;B<E;++B){const Q=X+B*_;if(Q>=0&&Q<y)for(let lt=0;lt<N;++lt){const pt=V+lt*R;if(pt>=0&&pt<b){const gt=d[q][Q][pt][G]+p[B][lt][G];gt>tt&&(tt=gt,Z=B,F=lt)}}}A[Z][F][G]+=O[q][W][P][G]}}}return{dataId:h.write(ol(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const Gnt={kernelName:Rv,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:c}=e,h=t,d=Vr(s.shape,h.data.get(s.dataId).values),p=Vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Qd(s.shape,r.shape,o,l,"NHWC",c);L(i.rank===D.length,()=>`Error in ${Rv}, dy must have the same rank as output ${D.length}, but got ${i.rank}`);const O=Vr(D,h.data.get(i.dataId).values),A=$R(s.shape,s.dtype);for(let q=0;q<m;++q)for(let W=0;W<w;++W){const X=W*k-T.top;for(let P=0;P<S;++P){const V=P*$-T.left;for(let G=0;G<x;++G){let tt=Number.MIN_SAFE_INTEGER,Z=X<0?0:X,F=V<0?0:V;for(let B=0;B<E;++B){const Q=X+B*_;if(Q>=0&&Q<y)for(let lt=0;lt<N;++lt){const pt=V+lt*R;if(pt>=0&&pt<b){const gt=d[q][Q][pt][G]+p[B][lt][G];gt>tt&&(tt=gt,Z=Q,F=pt)}}}A[q][Z][F][G]+=O[q][W][P][G]}}}return{dataId:h.write(ol(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Wnt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r}=t,{canvas:i,options:o}=s,{contextOptions:l,imageOptions:c}=o||{},h=c?.alpha||1,d=l?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const p=i.getContext(d,l?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],x=e.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,S=new Uint8ClampedArray(y*m*4);for(let k=0;k<m*y;++k){const $=[0,0,0,255*h];for(let N=0;N<b;N++){const _=x[k*b+N];if(r.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(r.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);b===1?($[0]=_*w,$[1]=_*w,$[2]=_*w):$[N]=_*w}const E=k*4;S[E+0]=Math.round($[0]),S[E+1]=Math.round($[1]),S[E+2]=Math.round($[2]),S[E+3]=Math.round($[3])}i.width=y,i.height=m;const T=new ImageData(S,y,m);return p.putImageData(T,0,0),r}const Hnt={kernelName:J5,backendName:"cpu",kernelFunc:Wnt};function gf(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"sum");let l;r.dtype==="bool"?l=Uo({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):l=bi({inputs:{x:r},backend:e});const c=l.shape.length,h=te(i,l.shape),d=qe(h,c);let p=h,m=l;d!=null&&(m=Ss({inputs:{x:l},backend:e,attrs:{perm:d}}),p=sn(p.length,c)),Bn("sum",p,m.shape.length);const[y,b]=On(m.shape,p),x=Ms(m.dtype,"int32");let w=Km(e,y,x);const S=ft(b),T=e.data.get(w.dataId).values,k=e.data.get(m.dataId).values;for(let $=0;$<T.length;++$){const E=$*S;let N=0;for(let _=0;_<S;++_)N+=k[E+_];T[$]=N}if(o){const $=hn(w.shape,h),E=w;w=Le({inputs:{x:w},backend:e,attrs:{shape:$}}),e.disposeIntermediateTensorInfo(E)}return e.disposeIntermediateTensorInfo(l),d!=null&&e.disposeIntermediateTensorInfo(m),w}const qnt={kernelName:s0,backendName:"cpu",kernelFunc:gf};function Knt(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:l,idDims:c}=GS(r,i.length);HS(o.length,c,i);const{path:h,steps:d}=qS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=WS(y,c[w]);let k;KS(S)?k=i[w]:(k=Ss({inputs:{x:i[w]},backend:e,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);we(k.shape,$)||(k=Le({inputs:{x:k},backend:e,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=R0({inputs:{a:k,b:m},backend:e}),b.push(m))}x<p-1&&(h[x]>=0&&(m=gf({inputs:{x:m},backend:e,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&e.disposeIntermediateTensorInfo(x);return m}const Xnt={kernelName:S1,backendName:"cpu",kernelFunc:Knt};function Ynt(n){const{inputs:t,backend:e}=n,{dy:s,y:r}=t;Nt([s,r],"eluGrad");const i=new Float32Array(ft(r.shape)),o=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values;for(let c=0;c<o.length;++c){const h=o[c];h>=0?i[c]=l[c]:i[c]=l[c]*(h+1)}return e.makeTensorInfo(r.shape,"float32",i)}const Znt={kernelName:C1,backendName:"cpu",kernelFunc:Ynt};const Jnt=LS,Qnt=PS,tst=zS,est=BS,nst=VS,sst=US,rst=ke(gd,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+Jnt*e);return t*(1-((((sst*s+nst)*s+est)*s+tst)*s+Qnt)*s*Math.exp(-e*e))}),ist={kernelName:gd,backendName:"cpu",kernelFunc:rst};function Zm(n){const{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:i}=s,o=r.shape.length,l=r.shape.slice();let c=i;return i<0&&(L(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+i+1),l.splice(c,0,1),Le({inputs:{x:r},backend:e,attrs:{shape:l}})}const ost={kernelName:$g,backendName:"cpu",kernelFunc:Zm};const ast=on((n,t)=>n/t),$C=kn(pd,ast),rw={kernelName:pd,backendName:"cpu",kernelFunc:$C};function oL(n,t,e){const s=n.shape,r=s[0],i=s[1],o=e.data.get(n.dataId),l=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,h=[r,i],d=ft(h),p=Zn("float32",d),m=Zn("float32",d);for(let w=0;w<r;w++){const S=rl({inputs:{x:l},backend:e,attrs:{begin:[w,0],size:[1,i]}}),T=rl({inputs:{x:c},backend:e,attrs:{begin:[w,0],size:[1,i]}}),k=Rs({inputs:{real:S,imag:T},backend:e}),{real:$,imag:E}=lst(k,t,e),N=Hi($,E);for(let _=0;_<i;_++){const R=jS(N,_);p[w*i+_]=R.real,m[w*i+_]=R.imag}e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(k)}const y=e.makeTensorInfo(h,"float32",p),b=e.makeTensorInfo(h,"float32",m),x=Rs({inputs:{real:y,imag:b},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),x}function lst(n,t,e){const s=ft(n.shape),r=e.data.get(n.dataId),i=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(cst(s)){const l=iw(i,o,s,t,e),c=[n.shape[0],n.shape[1]];if(t){const h=e.makeTensorInfo(c,"float32",l.real),d=e.makeTensorInfo(c,"float32",l.imag),p=e.makeTensorInfo([],"float32",Wo(s,"float32")),m=bi({inputs:{x:p},backend:e}),y=rw.kernelFunc({inputs:{a:h,b:p},backend:e}),b=rw.kernelFunc({inputs:{a:d,b:m},backend:e}),x=e.data.get(y.dataId).values,w=e.data.get(b.dataId).values;return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return l}else{const l=Hi(i,o),c=ust(l,s,t);return xO(c)}}function cst(n){return(n&n-1)===0}function iw(n,t,e,s,r){if(e===1)return{real:n,imag:t};const i=Hi(n,t),o=e/2,l=vO(i),c=l.real,h=l.imag,d=[c.length],p=r.makeTensorInfo(d,"float32",c),m=r.makeTensorInfo(d,"float32",h),y=Rs({inputs:{real:p,imag:m},backend:r}),b=wO(i),x=b.real,w=b.imag,S=[x.length],T=r.makeTensorInfo(S,"float32",x),k=r.makeTensorInfo(S,"float32",w),$=Rs({inputs:{real:T,imag:k},backend:r}),E=iw(c,h,o,s,r),N=E.real,_=E.imag,R=[N.length],D=r.makeTensorInfo(R,"float32",N),O=r.makeTensorInfo(R,"float32",_),A=Rs({inputs:{real:D,imag:O},backend:r}),z=iw(x,w,o,s,r),q=z.real,W=z.imag,X=[q.length],P=r.makeTensorInfo(X,"float32",q),V=r.makeTensorInfo(X,"float32",W),G=Rs({inputs:{real:P,imag:V},backend:r}),tt=CO(e,s),Z=[tt.real.length],F=r.makeTensorInfo(Z,"float32",tt.real),B=r.makeTensorInfo(Z,"float32",tt.imag),Q=Rs({inputs:{real:F,imag:B},backend:r}),lt=R0({inputs:{a:Q,b:G},backend:r}),pt=Lc({inputs:{a:A,b:lt},backend:r}),gt=TC({inputs:{a:A,b:lt},backend:r}),vt=sl({inputs:{input:pt},backend:r}),kt=sl({inputs:{input:gt},backend:r}),Ct=Pc({inputs:{input:pt},backend:r}),Rt=Pc({inputs:{input:gt},backend:r}),Gt=zc({inputs:[vt,kt],backend:r,attrs:{axis:0}}),re=zc({inputs:[Ct,Rt],backend:r,attrs:{axis:0}}),ge=r.data.get(Gt.dataId).values,de=r.data.get(re.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(lt),r.disposeIntermediateTensorInfo(pt),r.disposeIntermediateTensorInfo(gt),r.disposeIntermediateTensorInfo(vt),r.disposeIntermediateTensorInfo(Ct),r.disposeIntermediateTensorInfo(kt),r.disposeIntermediateTensorInfo(Rt),r.disposeIntermediateTensorInfo(Gt),r.disposeIntermediateTensorInfo(re),{real:ge,imag:de}}function ust(n,t,e){const s=new Float32Array(t*2);for(let r=0;r<t;r++){let i=0,o=0;for(let l=0;l<t;l++){const c=TO(r*l,t,e),h=jS(n,l);i+=h.real*c.real-h.imag*c.imag,o+=h.real*c.imag+h.imag*c.real}e&&(i/=t,o/=t),SO(s,i,o,r)}return s}function hst(n){const{inputs:t,backend:e}=n,{input:s}=t,r=ft(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=Le({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),c=oL(l,!1,e),h=Le({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const dst={kernelName:T1,backendName:"cpu",kernelFunc:hst};function EC(n){const{backend:t,attrs:e}=n,{shape:s,value:r,dtype:i}=e,o=i||Wc(r),l=tn(o,ft(s));return pst(l,r,o),t.makeTensorInfo(s,o,l)}const fst={kernelName:k1,backendName:"cpu",kernelFunc:EC};function pst(n,t,e){n.fill(t)}const mst={kernelName:$1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,r=e,i=Zn(s.dtype,ft(s.shape)),[o,l,c,h]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<o;m++){const y=m*c*l*h;for(let b=0;b<l;b++){const x=b*(c*h);for(let w=0;w<c;w++){const S=w*h;for(let T=0;T<h;T++){const k=Math.round(c-w-1),$=y+x+S+T;let E=d[$];if(k>=0&&k<c){const N=k*h,_=y+x+N+T;E=d[_]}i[$]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function gst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=rL({inputs:{x:r,filter:i},backend:e,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;if(d==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const S=Le({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});x=Lc({inputs:{a:x,b:S},backend:e}),e.disposeIntermediateTensorInfo(S)}else x=Lc({inputs:{a:x,b:o},backend:e});e.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const S=Le({inputs:{x:l},backend:e,attrs:{shape:[l.shape[0],1,1]}});x=Ym(e,x,y,S,b),e.disposeIntermediateTensorInfo(S)}else x=Ym(e,x,y,l,b);e.disposeIntermediateTensorInfo(w)}return x}const yst={kernelName:Nm,backendName:"cpu",kernelFunc:gst};function bst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=iL({inputs:{x:r,filter:i},backend:e,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;x=Lc({inputs:{a:x,b:o},backend:e}),e.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=Ym(e,x,y,l,b),e.disposeIntermediateTensorInfo(w)}return x}const xst={kernelName:XR,backendName:"cpu",kernelFunc:bst};function vst(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=ft(s.shape),o=r.shape,l=o[o.length-1],[c,h,d,p]=$S(s,r);if(h===0)return e.makeTensorInfo(c,s.dtype,[]);const m=e.data.get(r.dataId).values,y=e.bufferSync(s),b=gF(m,y,s.dtype,h,l,d,p,s.shape,i);return e.makeTensorInfo(c,s.dtype,b.values)}const wst={kernelName:_R,backendName:"cpu",kernelFunc:vst};function Sst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:l}=s;Nt([r,i],"gatherV2");const c=te(o,r.shape)[0],h=e.data.get(i.dataId).values,d=r.shape[c];for(let $=0;$<h.length;++$){const E=h[$];L(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=l;l==null&&(p=0);const m=ft(i.shape),y=YS(r,i,c,p),b=Le({inputs:{x:r},backend:e,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=Le({inputs:{x:i},backend:e,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],S=e.bufferSync(x),T=e.bufferSync(b),k=yF(T,S,w);return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.makeTensorInfo(y.outputShape,k.dtype,k.values)}const Cst={kernelName:Ig,backendName:"cpu",kernelFunc:Sst};function Tst(n){const{inputs:t,backend:e}=n,{input:s}=t,r=ft(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=Le({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),c=oL(l,!0,e),h=Le({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const kst={kernelName:E1,backendName:"cpu",kernelFunc:Tst};const $st=ke(Cd,n=>Number.isFinite(n)?1:0,"bool"),Est={kernelName:Cd,backendName:"cpu",kernelFunc:$st};const Ist=ke(Td,n=>Math.abs(n)===1/0?1:0,"bool"),Nst={kernelName:Td,backendName:"cpu",kernelFunc:Ist};const Ast=ke(kd,n=>Number.isNaN(n)?1:0,"bool"),_st={kernelName:kd,backendName:"cpu",kernelFunc:Ast};function Rst(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=SF(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const Dst={kernelName:RR,backendName:"cpu",kernelFunc:Rst};const Ost=ke(Ed,n=>Math.log1p(n)),Mst={kernelName:Ed,backendName:"cpu",kernelFunc:Ost};const Fst=on((n,t)=>n&&t),Lst=kn(Dg,Fst,null,"bool"),Pst={kernelName:Dg,backendName:"cpu",kernelFunc:Lst};const zst=ke(Og,n=>n?0:1,"bool"),Bst={kernelName:Og,backendName:"cpu",kernelFunc:zst};const Vst=on((n,t)=>n||t),Ust=kn(Mg,Vst,null,"bool"),jst={kernelName:Mg,backendName:"cpu",kernelFunc:Ust};function Gst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:l,beta:c}=s;Nt(r,"LRN");const h=r.shape[3],d=h-1,p=e.data.get(r.dataId).values,m=ft(r.shape),y=new Float32Array(m);function b(x){const w=x%h;let S=x-w+Math.max(0,w-i);const T=x-w+Math.min(w+i,d);let k=0;for(;S<=T;S++){const $=p[S];k+=$*$}return k}for(let x=0;x<m;x++){const w=b(x),S=p[x]*Math.pow(o+l*w,-c);y[x]=S}return e.makeTensorInfo(r.shape,r.dtype,y)}const Wst={kernelName:Fg,backendName:"cpu",kernelFunc:Gst};function Hst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:l,bias:c,alpha:h,beta:d}=s;Nt(o,"LRNGrad");const p=ft(o.shape),m=o.shape[3],y=e.data.get(o.dataId).values,b=e.data.get(r.dataId).values,x=e.data.get(i.dataId).values,w=new Float32Array(p),S=p;for(let T=0;T<S;T++){const k=T%m,$=T-k+Math.max(0,k-l),E=T-k+Math.min(m,k+l+1);let N=0;for(let _=$;_<E;_++)N+=Math.pow(b[_],2);N=h*N+c;for(let _=$;_<E;_++){let R=-2*h*d*b[_]*x[T]/N;T===_&&(R+=Math.pow(N,-d)),R*=y[T],w[_]+=R}}return e.makeTensorInfo(o.shape,r.dtype,w)}const qst={kernelName:N1,backendName:"cpu",kernelFunc:Hst};function aL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,l=e;let c=r.shape;const h=c.length,d=te(i,c);let p=d;const m=qe(p,h);let y=l.data.get(r.dataId).values;if(m!=null){const $=new Array(h);for(let E=0;E<$.length;E++)$[E]=c[m[E]];y=SC(y,c,r.dtype,m,$),p=sn(p.length,h),c=$}Nt(r,"max"),Bn("max",p,h);const[b,x]=On(c,p),w=ft(x),S=TF(y,w,b,r.dtype),T=l.write(S,b,r.dtype);let k=b;return o&&(k=hn(b,d)),{dataId:T,shape:k,dtype:r.dtype}}const Kst={kernelName:Lg,backendName:"cpu",kernelFunc:aL};function Xst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Nt(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(ts(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Tr(r.shape,i,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))p=bi({inputs:{x:r},backend:e});else{const m=e.data.get(r.dataId).values,y=Ot(r.shape),b=kC(m,r.shape,r.dtype,y,d,"max");p=e.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const Yst={kernelName:Pg,backendName:"cpu",kernelFunc:Xst};function Zst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Nt(r,"maxPool3d");const d=Yi(r.shape,i,o,1,l,c,h),p=e.data.get(r.dataId).values,m=sL(p,r.shape,r.dtype,Ot(r.shape),d,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}const Jst={kernelName:zg,backendName:"cpu",kernelFunc:Zst};function Qst(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Nt([r,i],"maxPool3DGrad");const d=Yi(i.shape,o,l,1,c,h),p=e.bufferSync(i),m=Vet(p,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,S=d.dilationHeight,T=d.dilationWidth,k=d.effectiveFilterDepth,$=d.effectiveFilterHeight,E=d.effectiveFilterWidth,N=k-1-d.padInfo.front,_=E-1-d.padInfo.left,R=$-1-d.padInfo.top,D=Qt(i.shape,"float32"),O=e.bufferSync(r);for(let A=0;A<d.batchSize;++A)for(let z=0;z<d.inChannels;++z)for(let q=0;q<d.inDepth;++q)for(let W=0;W<d.inHeight;++W)for(let X=0;X<d.inWidth;++X){const P=q-N,V=W-R,G=X-_;let tt=0;for(let Z=0;Z<k;Z+=w){const F=(P+Z)/y;if(!(F<0||F>=d.outDepth||Math.floor(F)!==F))for(let B=0;B<$;B+=S){const Q=(V+B)/b;if(!(Q<0||Q>=d.outHeight||Math.floor(Q)!==Q))for(let lt=0;lt<E;lt+=T){const pt=(G+lt)/x;if(pt<0||pt>=d.outWidth||Math.floor(pt)!==pt)continue;const gt=k*$*E-1-m.get(A,F,Q,pt,z),vt=Z*$*E+B*E+lt,kt=gt===vt?1:0;if(kt===0)continue;const Ct=O.get(A,F,Q,pt,z);tt+=Ct*kt}}}D.set(tt,A,q,W,X,z)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}const trt={kernelName:_1,backendName:"cpu",kernelFunc:Qst};function ert(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,l=i;Nt([i,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=Tr(l.shape,c,h,1,d,p),y=e.data.get(l.dataId).values,b=Qt(m.outShape,l.dtype,nL(y,l.shape,l.dtype,m).values),x=m.strideHeight,w=m.strideWidth,S=m.dilationHeight,T=m.dilationWidth,k=m.effectiveFilterHeight,$=m.effectiveFilterWidth,E=$-1-m.padInfo.left,N=k-1-m.padInfo.top,_=Qt(l.shape,"float32"),R=e.data.get(r.dataId).values,D=Qt(r.shape,"float32",R);for(let O=0;O<m.batchSize;++O)for(let A=0;A<m.inChannels;++A)for(let z=0;z<m.inHeight;++z)for(let q=0;q<m.inWidth;++q){const W=z-N,X=q-E;let P=0;for(let V=0;V<k;V+=S){const G=(W+V)/x;if(!(G<0||G>=m.outHeight||Math.floor(G)!==G))for(let tt=0;tt<$;tt+=T){const Z=(X+tt)/w;if(Z<0||Z>=m.outWidth||Math.floor(Z)!==Z)continue;const F=k*$-1-b.get(O,G,Z,A),B=V*$+tt,Q=F===B?1:0;if(Q===0)continue;const lt=D.get(O,G,Z,A);P+=lt*Q}}_.set(P,O,z,q,A)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const nrt={kernelName:A1,backendName:"cpu",kernelFunc:ert};function srt(n,t,e,s,r){const i=Ot(t),o=kC(n,t,e,i,r,"max"),l=nL(n,t,e,r,!0,s);return[o.values,l.values]}const rrt={kernelName:DR,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=t,c=e;Nt(s,"MaxPoolWithArgmax");const h=c.data.get(s.dataId).values,d=Tr(s.shape,r,i,[1,1],o),[p,m]=srt(h,s.shape,s.dtype,l,d),y=c.write(p,d.outShape,s.dtype),b=c.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function irt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=te(i,r.shape),h=On(r.shape,l)[1],d=ft(h),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const y=Uo({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});p.push(y);const b=$C({inputs:{a:y,b:m},backend:e});p.push(b);const x=gf({inputs:{x:b},backend:e,attrs:{axis:i,keepDims:o}});return p.forEach(w=>e.disposeIntermediateTensorInfo(w)),x}const ort={kernelName:Bg,backendName:"cpu",kernelFunc:irt};function art(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"min");const l=te(i,r.shape);let c=l;const h=qe(c,r.shape.length);let d=r;h!=null&&(d=Ss({inputs:{x:r},backend:e,attrs:{perm:h}}),c=sn(c.length,r.shape.length)),Bn("min",c,d.shape.length);const[p,m]=On(d.shape,c),y=ft(m),b=Jn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];(Number.isNaN(E)||E<k)&&(k=E)}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=hn(p,l),T=Le({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const lrt={kernelName:Vg,backendName:"cpu",kernelFunc:art};function crt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,mode:o}=s;Nt(r,"mirrorPad");const l=i.map((k,$)=>k[0]+r.shape[$]+k[1]),c=i.map(k=>k[0]),h=i.map((k,$)=>k[0]+r.shape[$]),d=o==="reflect"?0:1,p=e.data.get(r.dataId).values,m=r.shape.length,y=Ot(r.shape),b=ft(l),x=l.length,w=Ot(l),S=Zn(r.dtype,b);for(let k=0;k<b;k++){let $=Hc(k,x,w);for(let N=0;N<x;N++)$[N]<c[N]?$[N]=c[N]*2-$[N]-d:$[N]>=h[N]&&($[N]=(h[N]-1)*2-$[N]+d);$=$.map((N,_)=>N-c[_]);const E=li($,m,y);S[k]=p[E]}return{dataId:e.write(S,l,r.dtype),shape:l,dtype:r.dtype}}const urt={kernelName:Ug,backendName:"cpu",kernelFunc:crt};const hrt=on(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),drt=kn(Ad,hrt),frt={kernelName:Ad,backendName:"cpu",kernelFunc:drt};function lL(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=r.shape.length;let l=i;if(l===-1&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const c=te([l],r.shape),h=aL({inputs:{x:r},backend:e,attrs:{reductionIndices:c,keepDims:!1}}),d=hn(h.shape,c),p=Le({inputs:{x:h},backend:e,attrs:{shape:d}}),m=TC({inputs:{a:r,b:p},backend:e}),y=dF({inputs:{x:m},backend:e}),b=gf({inputs:{x:y},backend:e,attrs:{axis:c,keepDims:!1}}),x=Le({inputs:{x:b},backend:e,attrs:{shape:d}}),w=$C({inputs:{a:y,b:x},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),w}const prt={kernelName:o0,backendName:"cpu",kernelFunc:lL};function mrt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:l}=s;Nt(r,"multinomial");const c=l?r:lL({inputs:{logits:r},backend:e,attrs:{dim:-1}}),h=c.shape[0],d=c.shape[1],p=e.data.get(c.dataId).values,m=[h,i],y=Jn(ft(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=p[x];for(let k=1;k<w.length;++k)w[k]=w[k-1]+p[x+k];const S=hS.alea(o.toString()),T=b*i;for(let k=0;k<i;++k){const $=S();y[T+k]=w.length;for(let E=0;E<w.length;E++)if($<w[E]){y[T+k]=E;break}}}return l||e.disposeIntermediateTensorInfo(c),e.makeTensorInfo(m,"int32",y)}const grt={kernelName:OR,backendName:"cpu",kernelFunc:mrt};const yrt=vS;function brt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s;Nt(r,"NonMaxSuppression");const h=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:p}=yrt(h,d,o,l,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const xrt={kernelName:R1,backendName:"cpu",kernelFunc:brt};const vrt=wS;function wrt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s;Nt(r,"NonMaxSuppressionPadded");const d=e.data.get(r.dataId).values,p=e.data.get(i.dataId).values,{selectedIndices:m,validOutputs:y}=vrt(d,p,o,l,c,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const Srt={kernelName:D1,backendName:"cpu",kernelFunc:wrt};const Crt=SS;function Trt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s;Nt(r,"NonMaxSuppressionWithScore");const d=e.data.get(r.dataId).values,p=e.data.get(i.dataId).values,m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=Crt(d,p,m,y,b,x);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const krt={kernelName:O1,backendName:"cpu",kernelFunc:Trt};function $rt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:l,offValue:c}=s;Nt(r,"oneHot");const h=ft(r.shape),d=new Float32Array(h*o);d.fill(c);const p=e.data.get(r.dataId).values;for(let m=0;m<h;++m)p[m]>=0&&p[m]<o&&(d[m*o+p[m]]=l);return e.makeTensorInfo([...r.shape,o],i,d)}const Ert={kernelName:Hg,backendName:"cpu",kernelFunc:$rt};function Jm(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=sl({inputs:{input:s},backend:e}),i=Jm({inputs:{x:r},backend:e}),o=Pc({inputs:{input:s},backend:e}),l=Jm({inputs:{x:o},backend:e}),c=Rs({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return EC({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const Irt={kernelName:c0,backendName:"cpu",kernelFunc:Jm};function cL(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=sl({inputs:{input:s},backend:e}),i=cL({inputs:{x:r},backend:e}),o=Pc({inputs:{input:s},backend:e}),l=Jm({inputs:{x:o},backend:e}),c=Rs({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return EC({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const Nrt={kernelName:Wg,backendName:"cpu",kernelFunc:cL};function uL(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return Zm({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(d=>{t1(i,d.shape,"All tensors passed to stack must have matching shapes"),L(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=t.map(d=>{const p=Zm({inputs:{input:d},backend:e,attrs:{dim:r}});return l.push(p),p}),h=zc({inputs:c,backend:e,attrs:{axis:r}});return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const Art={kernelName:qg,backendName:"cpu",kernelFunc:uL};function _rt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;Nt(r,"pad");const l=i.map((T,k)=>T[0]+r.shape[k]+T[1]),c=i.map(T=>T[0]),h=e.data.get(r.dataId).values,d=ft(r.shape),p=r.shape.length,m=Ot(r.shape),y=ft(l),b=l.length,x=Ot(l),w=Zn(r.dtype,y);o!==0&&w.fill(o);for(let T=0;T<d;T++){const $=Hc(T,p,m).map((N,_)=>N+c[_]),E=li($,b,x);w[E]=h[T]}return{dataId:e.write(w,l,r.dtype),shape:l,dtype:r.dtype}}const hL={kernelName:Kg,backendName:"cpu",kernelFunc:_rt};const Rrt=on((n,t)=>Math.pow(n,t)),Drt=kn(Rd,Rrt),Ort={kernelName:Rd,backendName:"cpu",kernelFunc:Drt};function Mrt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:l}=s,c=r.map(S=>e.data.get(S.dataId).values),h=r.map(S=>S.shape),d=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values,[m,y,b]=AF(c,h,d,i.shape,i.dtype,p,o.shape),x=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),w=e.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const Frt={kernelName:MR,backendName:"cpu",kernelFunc:Mrt};function Lrt(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,[h,d]=_F(o,s.shape,s.dtype,l,r.shape,c,i.shape),p=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Prt={kernelName:FR,backendName:"cpu",kernelFunc:Lrt};function zrt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=t,{rowPartitionTypes:c}=s,h=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values,m=l.map(w=>e.data.get(w.dataId).values),y=l.map(w=>w.shape),[b,x]=RF(h,r.shape,d,i.shape,i.dtype,p,o.shape,m,y,c);return e.makeTensorInfo(b,i.dtype,x)}const Brt={kernelName:LR,backendName:"cpu",kernelFunc:zrt};function Vrt(n){const{backend:t,attrs:e}=n,{start:s,stop:r,dtype:i,step:o}=e,l=DF(s,r,o,i);return t.makeTensorInfo([l.length],i,l)}const Urt={kernelName:M1,backendName:"cpu",kernelFunc:Vrt};const jrt=ke(Dd,n=>1/n),Grt={kernelName:Dd,backendName:"cpu",kernelFunc:jrt};function Wrt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s;Nt(r,"resizeBilinear");const c=Ot(r.shape),[h,d]=l,[p,m,y,b]=r.shape,x=e.data.get(r.dataId).values,w=new Float32Array(ft([p,h,d,b])),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],T=[i&&h>1?h-1:h,i&&d>1?d-1:d];let k=0;const $=S[0]/T[0],E=S[1]/T[1];for(let N=0;N<p;N++)for(let _=0;_<h;_++){let R;o?R=$*(_+.5)-.5:R=$*_;const D=Math.max(0,Math.floor(R)),O=R-D,A=Math.min(m-1,Math.ceil(R)),z=N*c[0]+D*c[1],q=N*c[0]+A*c[1];for(let W=0;W<d;W++){let X;o?X=E*(W+.5)-.5:X=E*W;const P=Math.max(0,Math.floor(X)),V=X-P,G=Math.min(y-1,Math.ceil(X)),tt=z+P*c[2],Z=q+P*c[2],F=z+G*c[2],B=q+G*c[2];for(let Q=0;Q<b;Q++){const lt=x[tt+Q],pt=x[Z+Q],gt=x[F+Q],vt=x[B+Q],kt=lt+(gt-lt)*V,Ct=pt+(vt-pt)*V,Rt=kt+(Ct-kt)*O;w[k++]=Rt}}}return e.makeTensorInfo([p,h,d,b],"float32",w)}const Hrt={kernelName:Qg,backendName:"cpu",kernelFunc:Wrt};function qrt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;Nt([i,r],"resizeBilinearGrad");const l=Ot(r.shape),[c,h,d,p]=r.shape,[,m,y]=i.shape,b=new Float32Array(c*h*d*p),x=[o&&m>1?h-1:h,o&&y>1?d-1:d],w=[o&&m>1?m-1:m,o&&y>1?y-1:y],S=x[0]/w[0],T=x[1]/w[1],k=e.data.get(i.dataId).values;let $=0;for(let E=0;E<c;E++){const N=E*l[0];for(let _=0;_<m;_++){const R=_*S,D=Math.floor(R),O=Math.min(Math.ceil(R),h-1),A=N+D*l[1],z=N+O*l[1],q=R-D,W=1-q;for(let X=0;X<y;X++){const P=X*T,V=Math.floor(P),G=Math.min(Math.ceil(P),d-1),tt=P-V,Z=1-tt,F=A+V*l[2],B=A+G*l[2],Q=z+V*l[2],lt=z+G*l[2],pt=W*Z,gt=W*tt,vt=q*Z,kt=q*tt;for(let Ct=0;Ct<p;Ct++){const Rt=k[$++];b[F+Ct]+=Rt*pt,b[B+Ct]+=Rt*gt,b[Q+Ct]+=Rt*vt,b[lt+Ct]+=Rt*kt}}}}return e.makeTensorInfo([c,d,h,p],"float32",b)}const Krt={kernelName:P1,backendName:"cpu",kernelFunc:qrt};function Xrt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s;Nt(r,"resizeNearestNeighbor");const c=Ot(r.shape),[h,d]=l,[p,m,y,b]=r.shape,x=e.data.get(r.dataId).values,w=new Float32Array(p*h*d*b),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],T=[i&&h>1?h-1:h,i&&d>1?d-1:d],k=S[0]/T[0],$=S[1]/T[1];let E=0;for(let N=0;N<p;N++){const _=N*c[0];for(let R=0;R<h;R++){const D=o?k*(R+.5):k*R;let O=Math.min(m-1,i?Math.round(D):Math.floor(D));o&&(O=Math.max(0,O));const A=_+O*c[1];for(let z=0;z<d;z++){const q=o?$*(z+.5):$*z;let W=Math.min(y-1,i?Math.round(q):Math.floor(q));o&&(W=Math.max(0,W));const X=A+W*c[2];for(let P=0;P<b;P++){const V=x[X+P];w[E++]=V}}}}return e.makeTensorInfo([p,h,d,b],r.dtype,w)}const Yrt={kernelName:Jg,backendName:"cpu",kernelFunc:Xrt};function Zrt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;Nt([i,r],"resizeNearestNeighborGrad");const l=Ot(r.shape),c=Ot(i.shape),[h,d,p,m]=r.shape,[,y,b]=i.shape,x=new Float32Array(h*d*p*m),w=e.data.get(i.dataId).values,S=[o&&y>1?d-1:d,o&&b>1?p-1:p],T=[o&&y>1?y-1:y,o&&b>1?b-1:b],k=S[0]/T[0],$=S[1]/T[1],E=1/k,N=1/$,_=Math.ceil(E)*2+2,R=Math.ceil(N)*2+2;for(let D=0;D<h;D++){const O=D*l[0];for(let A=0;A<d;A++){const z=O+A*l[1],q=Math.floor(A*E),W=Math.floor(q-_/2);for(let X=0;X<p;X++){const P=z+X*l[2],V=Math.floor(X*N),G=Math.floor(V-R/2);for(let tt=0;tt<m;tt++){let Z=0;for(let F=0;F<_;F++){const B=F+W;if(B<0||B>=y)continue;const Q=O+B*c[1],lt=B*k,pt=Math.min(d-1,o?Math.round(lt):Math.floor(lt));if(A===pt)for(let gt=0;gt<R;gt++){const vt=gt+G;if(vt<0||vt>=b)continue;const kt=Q+vt*c[2],Ct=vt*$,Rt=Math.min(p-1,o?Math.round(Ct):Math.floor(Ct));X===Rt&&(Z+=w[kt+tt])}}x[P+tt]=Z}}}}return e.makeTensorInfo(r.shape,r.dtype,x)}const Jrt={kernelName:L1,backendName:"cpu",kernelFunc:Zrt};function Qrt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s;Nt(r,"reverse");const o=r.shape.length,l=te(i,r.shape);if(o===0)return bi({inputs:{x:r},backend:e});const c=new Pn(r.shape,r.dtype),h=e.bufferSync(r);for(let d=0;d<c.size;d++){const p=c.indexToLoc(d),m=p.slice();l.forEach(y=>m[y]=r.shape[y]-1-m[y]),c.set(h.get(...m),...p)}return e.makeTensorInfo(c.shape,c.dtype,c.values)}const tit={kernelName:t0,backendName:"cpu",kernelFunc:Qrt};const eit={kernelName:W1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,l=e,c=Zn(s.dtype,ft(s.shape)),[h,d,p,m]=s.shape,[y,b]=OS(o,d,p),x=255,w=Math.sin(r),S=Math.cos(r),T=l.data.get(s.dataId).values;for(let $=0;$<h;$++){const E=$*p*d*m;for(let N=0;N<d;N++){const _=N*(p*m);for(let R=0;R<p;R++){const D=R*m;for(let O=0;O<m;O++){const A=[h,N,R,O],z=A[2],q=A[1];let W=(z-y)*S-(q-b)*w,X=(z-y)*w+(q-b)*S;W=Math.round(W+y),X=Math.round(X+b);let P=i;if(typeof i!="number"&&(O===3?P=x:P=i[O]),W>=0&&W<p&&X>=0&&X<d){const G=X*(p*m),tt=W*m,Z=E+G+tt+O;P=T[Z]}const V=E+_+D+O;c[V]=P}}}}return{dataId:l.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const nit=ke(Fd,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),sit={kernelName:Fd,backendName:"cpu",kernelFunc:nit};function rit(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(i,r,o),m=!0,y=e.bufferSync(r),b=e.bufferSync(i),x=za(y,b,o,p,h,c,l,d,0,m);return e.makeTensorInfo(o,x.dtype,x.values)}const iit={kernelName:PR,backendName:"cpu",kernelFunc:rit};function oit(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<t?e=r+1:s=r;return s}function ait(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<=t?e=r+1:s=r;return s}function lit(n,t,e,s,r,i){const o=tn("int32",e*r);for(let l=0;l<e;++l){const c=n.slice(l*s,(l+1)*s),h=l*r;for(let d=0;d<r;++d)o[h+d]=i==="left"?oit(c,t[d+h]):ait(c,t[d+h])}return o}function cit(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,h=lit(l,c,r.shape[0],r.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",h)}const uit={kernelName:BR,backendName:"cpu",kernelFunc:cit};function hit(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t;Nt([s,r,i],"select");const o=s.shape.length,l=e.data.get(s.dataId).values,c=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=Ms(r.dtype,i.dtype),p=Jn(ft(r.shape),d);let m=0;const y=o===0||o>1||r.shape.length===1?1:ft(r.shape.slice(1));for(let b=0;b<l.length;b++)for(let x=0;x<y;x++)l[b]===1?p[m++]=c[b]:p[m++]=h[b];return e.makeTensorInfo(r.shape,d,p)}const dit={kernelName:e0,backendName:"cpu",kernelFunc:hit};const fit=x0,pit=v0,mit=ke(Pd,n=>n>=0?pit*n:fit*(Math.exp(n)-1)),git={kernelName:Pd,backendName:"cpu",kernelFunc:mit};const yit=ke(Vd,n=>n<0?-1:n>0?1:0),bit={kernelName:Vd,backendName:"cpu",kernelFunc:yit};const xit=ke(zd,n=>Math.sin(n)),vit={kernelName:zd,backendName:"cpu",kernelFunc:xit};const wit=ke(Bd,n=>Math.sinh(n)),Sit={kernelName:Bd,backendName:"cpu",kernelFunc:wit};const Cit=11920928955078125e-23,HN=Math.log(Cit)+2,Tit=ke(jd,n=>{const t=n>-HN,e=n<HN,s=Math.exp(n);let r;return e?r=s:t?r=n:r=Math.log(1+s),r}),kit={kernelName:jd,backendName:"cpu",kernelFunc:Tit};function $it(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;Nt([r],"spaceToBatchND");const l=ft(i),c=[[0,0]];c.push(...o);for(let N=1+i.length;N<r.shape.length;++N)c.push([0,0]);const h=hL.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:c,constantValue:0}}),d=rf(h.shape,i,l,!1),p=of(d.length,i.length,!1),m=af(h.shape,i,l,!1),x=Le({inputs:{x:h},backend:e,attrs:{shape:d}}),T=Ss({inputs:{x},backend:e,attrs:{perm:p}}),E=Le({inputs:{x:T},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),E}const Eit={kernelName:r0,backendName:"cpu",kernelFunc:$it};function Iit(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=e.data.get(s.dataId).values,c=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values[0],[p,m,y,b,x]=LF(l,s.shape,s.dtype,c,r.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,p),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),e.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const Nit={kernelName:VR,backendName:"cpu",kernelFunc:Iit};function Ait(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(r.dataId).values),l=e.data.get(s.dataId).values,c=Array.from(e.data.get(i.dataId).values),[h,d,p]=PF(l,s.shape,s.dtype,o,c);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const _it={kernelName:UR,backendName:"cpu",kernelFunc:Ait};function Rit(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,[h,d]=CC(o,s.shape,s.dtype,l,c,!0);return e.makeTensorInfo(d,s.dtype,h)}const Dit={kernelName:jR,backendName:"cpu",kernelFunc:Rit};function Oit(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,[h,d]=CC(o,s.shape,s.dtype,l,c);return e.makeTensorInfo(d,s.dtype,h)}const Mit={kernelName:GR,backendName:"cpu",kernelFunc:Oit};function Fit(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=cl(i,r,l),y=!1,b=e.bufferSync(r);let x;switch(i.dtype){case"bool":{const w=e.bufferSync(i),S=!!e.data.get(o.dataId).values[0];x=za(b,w,l,m,d,h,c,p,S,y);break}case"float32":{const w=e.bufferSync(i),S=e.data.get(o.dataId).values[0];x=za(b,w,l,m,d,h,c,p,S,y);break}case"int32":{const w=e.bufferSync(i),S=e.data.get(o.dataId).values[0];x=za(b,w,l,m,d,h,c,p,S,y);break}case"string":{const w=e.bufferSync(i),S=Lo(e.data.get(o.dataId).values[0]);x=za(b,w,l,m,d,h,c,p,S,y);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(l,x.dtype,x.values)}const Lit={kernelName:WR,backendName:"cpu",kernelFunc:Fit};function Pit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,l=te(o,r.shape)[0],c=XS(r,i,l),h=new Array(r.shape.length).fill(0),d=r.shape.slice();return c.map(p=>{const m=[...d];m[l]=p;const y=rl({inputs:{x:r},backend:e,attrs:{begin:h,size:m}});return h[l]+=p,y})}const zit={kernelName:i0,backendName:"cpu",kernelFunc:Pit};const Bit={kernelName:z1,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;Nt(e,"square");const r=s.data.get(e.dataId).values,i=new Float32Array(r.length);for(let l=0;l<r.length;++l){const c=r[l];i[l]=c*c}return{dataId:s.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const Vit=ke(Yd,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Uit={kernelName:Yd,backendName:"cpu",kernelFunc:Vit};function jit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;Nt(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=_S(r.shape,i,o,l,c,h,d,p,m);let E;if(x)E=Le({inputs:{x:r},backend:e,attrs:{shape:b}});else if(w||S){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=IS(T,k,$),_=rl({inputs:{x:r},backend:e,attrs:{begin:T,size:N}});E=Le({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else{const N=e.bufferSync(r),_=VF(y,N,$,T);E=e.makeTensorInfo(b,_.dtype,_.values)}return E}const Git={kernelName:V1,backendName:"cpu",kernelFunc:jit};function Wit(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=t,m=e.data.get(d.dataId).values,y=e.data.get(p.dataId).values,[b,x]=UF(m,y,r,i,o,l,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",x)]}const Hit={kernelName:HR,backendName:"cpu",kernelFunc:Wit};function qit(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values[0],[h,d,p]=jF(l,c,r),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const Kit={kernelName:qR,backendName:"cpu",kernelFunc:qit};function Xit(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.data.get(i.dataId).values,l=GF(o,r);return e.makeTensorInfo(i.shape,"int32",l)}const Yit={kernelName:KR,backendName:"cpu",kernelFunc:Xit};const Zit=ke(qd,n=>Math.tan(n)),Jit={kernelName:qd,backendName:"cpu",kernelFunc:Zit};const Qit=ke(Kd,n=>Math.tanh(n)),tot={kernelName:Kd,backendName:"cpu",kernelFunc:Qit};function eot(n){const{inputs:t,backend:e}=n,{tensor:s,indices:r,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=cl(i,r,s.shape),p=!1,m=e.bufferSync(r),y=e.bufferSync(i),b=e.bufferSync(s),x=za(m,y,s.shape,d,c,l,o,h,b,p);return e.makeTensorInfo(s.shape,x.dtype,x.values)}const not={kernelName:zR,backendName:"cpu",kernelFunc:eot};function sot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;Nt(r,"tile");const o=HF(e.bufferSync(r),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}const rot={kernelName:Xd,backendName:"cpu",kernelFunc:sot};function iot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s;Nt(r,"topk");const l=e.data.get(r.dataId).values,[c,h]=KF(l,r.shape,r.dtype,i,o);return[e.makeTensorInfo(c.shape,c.dtype,c.values),e.makeTensorInfo(h.shape,h.dtype,h.values)]}const oot={kernelName:U1,backendName:"cpu",kernelFunc:iot};function aot(n){const{inputs:t,attrs:e,backend:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=e,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=Ot(r.shape),T=S[0],k=S[1],$=S[2],E=Ot(w),N=E[0],_=E[1],R=E[2],D=Zn(r.dtype,ft(w));D.fill(c);const O=s.data.get(r.dataId).values,A=s.data.get(i.dataId).values;for(let q=0;q<d;++q){const W=i.shape[0]===1?A:A.subarray(q*8,q*8+8);for(let X=0;X<b;++X)for(let P=0;P<x;++P)for(let V=0;V<y;++V){let G;const tt=W[6]*P+W[7]*X+1;if(tt===0)continue;const Z=(W[0]*P+W[1]*X+W[2])/tt,F=(W[3]*P+W[4]*X+W[5])/tt,B=qN(Z,m,l),Q=qN(F,p,l);switch(o){case"nearest":G=fot(O,p,m,T,k,$,q,Q,B,V,c);break;case"bilinear":G=pot(O,p,m,T,k,$,q,Q,B,V,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const lt=q*N+X*_+P*R+V;D[lt]=G}return s.makeTensorInfo(w,r.dtype,D)}return{dataId:s.write(D,w,r.dtype),shape:r.shape,dtype:r.dtype}}const lot={kernelName:j1,backendName:"cpu",kernelFunc:aot};function qN(n,t,e){switch(e){case"reflect":return cot(n,t);case"wrap":return uot(n,t);case"nearest":return dot(n,t);default:return hot(n)}}function cot(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Wa(0,e,t-1)}function uot(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return Wa(0,e,t-1)}function hot(n,t){return n}function dot(n,t){return Wa(0,n,t-1)}function fh(n,t,e,s,r,i,o,l,c,h,d){const p=o*s+l*r+c*i+h;return 0<=l&&l<t&&0<=c&&c<e?n[p]:d}function fot(n,t,e,s,r,i,o,l,c,h,d){const p=Math.round(l),m=Math.round(c);return fh(n,t,e,s,r,i,o,p,m,h,d)}function pot(n,t,e,s,r,i,o,l,c,h,d){const p=Math.floor(l),m=Math.floor(c),y=p+1,b=m+1,x=(b-c)*fh(n,t,e,s,r,i,o,p,m,h,d)+(c-m)*fh(n,t,e,s,r,i,o,p,b,h,d),w=(b-c)*fh(n,t,e,s,r,i,o,y,m,h,d)+(c-m)*fh(n,t,e,s,r,i,o,y,b,h,d);return(y-l)*x+(l-p)*w}function mot(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;Nt(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:l,outputShape:c,indices:h}=XF(o,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const got={kernelName:G1,backendName:"cpu",kernelFunc:mot};function yot(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,l=r.shape[i],c=new Array(o-1);let h=0;for(let y=0;y<o;y++)y!==i&&(c[h++]=r.shape[y]);const d=new Array(o).fill(0),p=r.shape.slice();p[i]=1;const m=new Array(l);for(let y=0;y<m.length;y++){d[i]=y;const b=rl({inputs:{x:r},backend:e,attrs:{begin:d,size:p}});m[y]=Le({inputs:{x:b},backend:e,attrs:{shape:c}}),e.disposeIntermediateTensorInfo(b)}return m}const bot={kernelName:a0,backendName:"cpu",kernelFunc:yot};function xot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s;Nt(r,"unsortedSegmentSum");const l=r.shape.length,c=i.shape.length,h=[],d=[],p=l-c;let m=i;for(let b=0;b<p;++b){const x=Zm({inputs:{input:m},backend:e,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<o;++b){const x=Wo(b,"int32"),w=e.makeTensorInfo([],"int32",x),S=uF({inputs:{a:w,b:m},backend:e}),T=Uo({inputs:{x:S},backend:e,attrs:{dtype:"float32"}}),k=R0({inputs:{a:T,b:r},backend:e}),$=gf({inputs:{x:k},backend:e,attrs:{axis:0,keepDims:!1}});h.push($),d.push(w),d.push(S),d.push(T),d.push(k),d.push($)}const y=uL({inputs:h,backend:e,attrs:{axis:0}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const vot={kernelName:l0,backendName:"cpu",kernelFunc:xot};const wot=[pet,qQ,get,bet,QQ,vet,Cet,ket,Eet,Net,_et,Det,Met,Pet,Bet,jet,Wet,qet,Xet,det,Zet,Qet,ent,ett,snt,ZQ,stt,int,KQ,ant,cnt,unt,dnt,pnt,gnt,bnt,vnt,Snt,Tnt,$nt,Int,Ant,Rnt,Ont,Mnt,Lnt,znt,Vnt,Unt,jnt,Gnt,Hnt,Xnt,ret,Znt,rtt,ist,itt,ost,att,dst,fst,mst,ctt,htt,yst,xst,wst,Cst,ftt,mtt,XQ,kst,lnt,Est,Nst,_st,iet,ytt,xtt,Dst,wtt,Mst,Pst,Bst,jst,Wst,qst,Kst,Ctt,Yst,Jst,trt,nrt,rrt,ort,lrt,ktt,urt,frt,grt,Ett,Ntt,xrt,Srt,krt,_tt,Ert,Nrt,Art,hL,Ort,aet,Ott,Frt,Prt,Brt,Urt,YQ,rw,Grt,cet,uet,het,Hrt,Krt,Yrt,Jrt,tit,eit,sit,Utt,iit,uit,dit,git,Gtt,bit,vit,Sit,Wtt,prt,kit,Eit,Nit,_it,Dit,Mit,Lit,zit,Ktt,Bit,Ytt,Jtt,Uit,Git,Hit,Kit,Yit,net,qnt,Jit,tot,not,rot,oot,lot,Rtt,got,bot,vot,Irt];for(const n of wot)YR(n);const Oa={},Zp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Sot(n,t){Oa[n]=t}function Hr(n,t){if(!(n in Oa)||t!=null){const s=Tot(n,t);if(s!==null)Oa[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=Oa[n];return e==null||e.isContextLost()?(delete Oa[n],Hr(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Oa[n])}function Cot(n){if(!ct().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Tot(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??Cot(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Oa[n]},!1),ct().getBool("SOFTWARE_WEBGL_ENABLED")&&(Zp.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",Zp)||e.getContext("experimental-webgl",Zp):e.getContext("webgl2",Zp)}var Hh;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Hh||(Hh={}));var Zs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Zs||(Zs={}));var Ln;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ln||(Ln={}));function yf(n,t){return[t,n]}function kot(n,t){return n*t}function Jp(n){const t=ft(n),e=Math.ceil(t/4);return Iv(e)}function Qc(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function $ot(n,t){const[e,s]=Qc(n,t);return e*s*4}function IC(n,t){const e=n;let s,r,i,o,l,c,h,d,p,m;return ct().getNumber("WEBGL_VERSION")===2?(s=e.R32F,r=e.R16F,i=e.RGBA16F,o=e.RGBA32F,l=e.RED,h=4,d=1,p=e.HALF_FLOAT,m=e.FLOAT,c=e.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=e.RGBA,l=n.RGBA,h=4,d=4,p=t!=null?t.HALF_FLOAT_OES:null,m=n.FLOAT,c=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:c,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function $t(n,t){const e=t();return ct().getBool("DEBUG")&&Eot(n),e}function Eot(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+_ot(n,t))}const Iot=596e-10,Not=65504;function Aot(n){return!!(ct().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Iot<Math.abs(n)&&Math.abs(n)<Not)}function _ot(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Qp(n,t){return Ji(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Rot(n,t){const e=Ji(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if($t(n,()=>n.shaderSource(e,t)),$t(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function Dot(n,t){const e=Ji(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if($t(n,()=>n.shaderSource(e,t)),$t(n,()=>n.compileShader(e)),ct().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw dL(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const Oot=/ERROR: [0-9]+:([0-9]+):/g;function dL(n,t){const e=Oot.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((p,m)=>Tc((m+1).toString(),i)+p);let l=0;for(let p=0;p<o.length;p++)l=Math.max(o[p].length,l);const c=o.slice(0,s-1),h=o.slice(s-1,s),d=o.slice(s);console.log(c.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Tc(h[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function Mot(n){return Ji(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Fot(n,t){if($t(n,()=>n.linkProgram(t)),!ct().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Ux(n,t){if($t(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Lot(n,t){const e=Ji(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return $t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),$t(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Pot(n,t){const e=Ji(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return $t(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),$t(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function zot(n){return Ji(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Bot(n,t){const e=ct().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,r=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Vot(n){return Ji(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function KN(n,t,e,s,r,i,o){const l=n.getAttribLocation(t,e);return l===-1?!1:($t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),$t(n,()=>n.vertexAttribPointer(l,r,n.FLOAT,!1,i,o)),$t(n,()=>n.enableVertexAttribArray(l)),!0)}function Uot(n,t,e){qot(n,e),$t(n,()=>n.activeTexture(n.TEXTURE0+e)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function jot(n,t,e){return Ji(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function Got(n,t,e){return n.getUniformLocation(t,e)}function Wot(n,t,e,s){$t(n,()=>Uot(n,t,s)),$t(n,()=>n.uniform1i(e,s))}function jx(n,t,e){$t(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),$t(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function XN(n,t){$t(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),$t(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function tm(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Hot(n,t))}function Hot(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ji(n,t,e){const s=$t(n,()=>t());if(s==null)throw new Error(e);return s}function qot(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const r=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${r}.`)}}function Bc(n,t=2){return ft(n.slice(0,n.length-t))}function Vc(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function em(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[Bc(n),...Vc(n)]),t}function Kot(n,t=!1){let e=ct().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ct().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ct().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((l,c)=>c>=n.length-2?Qw(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Go(n).newShape);let r=ft(n),i=null;n.length<=1&&r<=e?i=[1,r]:n.length===2&&n[0]<=e&&n[1]<=e?i=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||o)if(t){const l=Bc(n);let c=2,h=2;n.length&&([c,h]=Vc(n)),r=l*(c/2)*(h/2),i=Iv(r).map(d=>d*2)}else i=Iv(r);return i}function nm(n){return n%2===0}function Qm(n,t){if(n=n.slice(-2),t=t.slice(-2),we(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||nm(e)&&nm(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&nm(n[0])&&nm(t[0])}let Gx,Wx;function Xot(n){if(Gx==null){const t=Hr(n);Gx=t.getParameter(t.MAX_TEXTURE_SIZE)}return Gx}function Yot(n){if(Wx==null){const t=Hr(n);Wx=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Wx)}function Zot(n){if(n===0)return 0;let t;const e=Hr(n);return vr(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:vr(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function vr(n,t){return n.getExtension(t)!=null}function YN(n){try{if(Hr(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Jot(n){if(n===0)return!1;const t=Hr(n);if(n===1){if(!vr(t,"OES_texture_float"))return!1}else if(!vr(t,"EXT_color_buffer_float"))return!1;return ow(t)}function Qot(n){if(n===0)return!1;const t=Hr(n);if(n===1){if(!vr(t,"OES_texture_float")||!vr(t,"WEBGL_color_buffer_float"))return!1}else{if(vr(t,"EXT_color_buffer_float"))return ow(t);const s="EXT_color_buffer_half_float";if(vr(t,s)){const r=t.getExtension(s);return tat(t,r)}return!1}return ow(t)}function ow(n){const t=IC(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function tat(n,t){const e=IC(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),l}function eat(n){return n!==2?!1:Hr(n).fenceSync!=null}function bf(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&L(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const At=ct();At.registerFlag("HAS_WEBGL",()=>At.getNumber("WEBGL_VERSION")>0);At.registerFlag("WEBGL_VERSION",()=>YN(2)?2:YN(1)?1:0);At.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);At.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>At.get("WEBGL_VERSION")===2);At.registerFlag("WEBGL_CPU_FORWARD",()=>!0);At.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);At.registerFlag("WEBGL_PACK",()=>At.getBool("HAS_WEBGL"));At.registerFlag("WEBGL_PACK_NORMALIZATION",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CLIP",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_REDUCE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_LAZILY_UNPACK",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_CONV_IM2COL",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Xot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Yot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=At.getNumber("WEBGL_VERSION");return n===0?0:Zot(n)});At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>At.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!cD());At.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Jot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>At.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:At.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));At.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Qot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_FENCE_API_ENABLED",()=>eat(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>At.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);At.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});At.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>cD()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});At.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);At.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);At.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);At.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);At.registerFlag("WEBGL_EXP_CONV",()=>!1);At.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>At.getBool("IS_TEST"));At.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);At.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);At.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);At.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function hs(){let n,t,e,s,r,i,o,l,c,h;return ct().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",l=ct().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",r="texture2D",i="gl_FragColor",o="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:c,defineRound:h}}function dl(n,t,e="index"){const s=Ot(t);return s.map((r,i)=>{const o=`int ${n[i]} = ${e} / ${r}`,l=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${l};`}).join("")}function D0(n,t,e="index"){const s=Ot(t);return s.map((r,i)=>{const o=`int ${n[i]} = ${e} / outShapeStrides[${i}]`,l=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${l};`}).join("")}function nat(n,t){const e=n.length,s=n.map(i=>`${t}[${i}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function sat(n,t,e="index"){const s=n.map((i,o)=>o),r=nat(s,t);return r.map((i,o)=>{const l=`int ${n[o]} = ${e} / ${r[o]}`,c=o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${l}; ${c};`}).join("")}function NC(n){const t=Ot(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function AC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const fL=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:pL}=U7;function rat(n,t,e){const s=[];if(n.forEach(y=>{const b=ft(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),e.enableShapeUniforms){const{uniformShape:x}=_C(e.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>iat(y,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),o=t.texShape,l=hs(),c=lat(l);let h,d,p=hat(l);return t.isPacked?(h=oat(t.logicalShape,o,e.enableShapeUniforms),d=uat(l)):(h=aat(t.logicalShape,o,e.enableShapeUniforms),d=cat(l)),e.packedInputs&&(p+=mat),[p,c,d,r,h,i,e.userCode].join(`
`)}function tu(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return Eat(n,t);case 1:return Nat(n,t);case 2:return _at(n,t);case 3:return Dat(n,t);case 4:return Mat(n,t);case 5:return Fat(n);case 6:return Lat(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function mL(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return $at(n);case 1:return Iat(n,t);case 2:return Aat(n,t);case 3:return Rat(n,t);default:return Oat(n,t)}}function iat(n,t,e=!1,s){let r="";e?r+=mL(n,s):r+=tu(n,s);const i=n.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(e?r+=Pat(n,t):r+=zat(n,t)),r}function oat(n,t,e){switch(n.length){case 0:return gL();case 1:return gat(n,t,e);case 2:return Tat(n,t,e);case 3:return bat(n,t,e);default:return vat(n,t,e)}}function aat(n,t,e){switch(n.length){case 0:return gL();case 1:return yat(n,t,e);case 2:return kat(n,t,e);case 3:return xat(n,t,e);case 4:return wat(n,t,e);case 5:return Sat(n,t);case 6:return Cat(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function lat(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function cat(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function uat(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function hat(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${dat}
    ${fat}
    ${pat}
  `}const dat=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,fat=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,pat=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,mat=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function gL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function gat(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function yat(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function bat(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function xat(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${D0(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=dl(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function vat(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,l="",c="b, r, c";for(let h=2;h<n.length-1;h++)o*=n[n.length-h-1],l=`
      int b${h} = index / ${o};
      index -= b${h} * ${o};
    `+l,c=`b${h}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${c});
    }
  `}function wat(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${D0(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=dl(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function Sat(n,t){const e=dl(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Cat(n,t){const e=dl(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Tat(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(we(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function kat(n,t,e){return we(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function fl(n){return`offset${n}`}function $at(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=hs();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function Eat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=fl(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});
      return sampleTexture(${e}, uv);
    }
  `;const[l,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${c}, ${o});
      return sampleTexture(${e}, uv);
    }
  `}function Iat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,i=hs();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${e}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${e}, uv);
    }
  `}function Nat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${eu(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const l=fl(e);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${i}.0);
        return sampleTexture(${e}, uv);
      }
    `:i===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${l});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${l});
      return sampleTexture(${e}, uv);
    }
  `}function Aat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],l=i[1],c=hs();if(i!=null&&we(e,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${o}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(e[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function _at(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&we(e,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:l}=Go(e),c=o;if(c.length<e.length){const m=nu(n,c),y=["row","col"];return`
      ${tu(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${su(y,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${eu(n)}
      }
    `;const h=i[0],d=i[1],p=fl(s);return d===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function Rat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(e[0]===1){const m=e.slice(1),y=[1,2],b=nu(n,m),x=["b","row","col"];return`
        ${mL(b,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${su(x,y)});
        }
      `}const l=hs();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=o[0],h=o[1],d=Math.ceil(e[2]/2),p=d*Math.ceil(e[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${h}, ${p}, ${d}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Dat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[1]*e[2],o=e[2],{newShape:l,keptDims:c}=Go(e),h=l;if(h.length<e.length){const x=nu(n,h),w=["row","col","depth"];return`
        ${tu(x,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${su(w,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${eu(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===o&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=fl(s);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Oat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=hs();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,l=n.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],h=c[0],d=c[1],p=Math.ceil(i[o-1]/2);let m=p*Math.ceil(i[o-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<o-1;x++)y=`int b${x}, `+y,m*=i[o-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${e}, uv);
    }
  `}function Mat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[3],o=e[2]*i,l=e[1]*o,{newShape:c,keptDims:h}=Go(e);if(c.length<e.length){const T=nu(n,c),k=["row","col","depth","depth2"];return`
      ${tu(T,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${su(k,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${i}, 1)));
        ${eu(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===l&&d==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&d==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const S=fl(s);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${S});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${S});
      return sampleTexture(${s}, uv);
    }
  `}function Fat(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,l=t[1]*o,{newShape:c,keptDims:h}=Go(t);if(c.length<t.length){const x=nu(n,c),w=["row","col","depth","depth2","depth3"];return`
      ${tu(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${su(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${i}, ${r})) +
          depth3;
        ${eu(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===l&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;const b=fl(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Lat(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:i}=Go(t);if(r.length<t.length){const w=nu(n,r),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${tu(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${su(S,i)});
      }
    `}const o=t[5],l=t[4]*o,c=t[3]*l,h=t[2]*c,d=t[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${c}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${eu(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${c}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(b===o&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;const x=fl(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${c} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${e}, uv);
    }
  `}function eu(n){const t=n.name,e=ft(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Pat(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=pL(n.shapeInfo.logicalShape,t.logicalShape),c=Ie(o),h=o-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":o<2&&l.length>=1?d="coords = 0;":d=l.map(T=>`coords.${p[T+h]} = 0;`).join(`
`);let m="";o<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((T,k)=>`coords.${p[k+h]}`).join(", ");let y="return outputValue;";const x=ft(n.shapeInfo.logicalShape)===1,S=ft(t.logicalShape)===1;if(i===1&&!x&&!S)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)o===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(l.length){const T=i-2,k=i-1;l.indexOf(T)>-1&&l.indexOf(k)>-1?y="return vec4(outputValue.x);":l.indexOf(T)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(k)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function zat(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=t.texShape,o=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!n.shapeInfo.isUniform&&l===c&&n.shapeInfo.flatOffset==null&&we(o,i))return`
      float ${r}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const h=Ie(c),d=pL(n.shapeInfo.logicalShape,t.logicalShape),p=c-l;let m;const y=["x","y","z","w","u","v"];l===0?m="":c<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+p]} = 0;`).join(`
`);let b="";return c<2&&l>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+p]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function Ie(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function _C(n,t,e){const{newShape:s,keptDims:r}=Go(t),i=t.length,o=n&&i===3&&t[0]===1,l=o?t.slice(1):s,c=!n&&i>1&&!we(t,e)&&s.length<i||o;return{useSqueezeShape:c,uniformShape:c?l:t,keptDims:r}}function nu(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function su(n,t){return t.map(e=>n[e]).join(", ")}function Bat(n,t,e,s){const r=e.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=rat(r,o,t),c=Dot(n.gl,l),h=n.createProgram(c);return ct().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:t,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:i,outShapeInfo:o},yL(n,t,h)))}function yL(n,t,e){const s=[],r=[];let i,o,l,c=null,h=null;h=n.getUniformLocation(e,"NAN",!1),ct().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const p of t.variableNames){const m={name:p,uniform:n.getUniformLocation(e,p,d),offset:n.getUniformLocation(e,`offset${p}`,d)};t.enableShapeUniforms&&(m.shape=n.getUniformLocation(e,`${p}Shape`,d),m.texShape=n.getUniformLocation(e,`${p}TexShape`,d)),s.push(m)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",d),l=n.getUniformLocation(e,"outShapeStrides",d),o=n.getUniformLocation(e,"outTexShape",d)),t.customUniforms)for(const p of t.customUniforms)r.push(n.getUniformLocation(e,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:c,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:o}}function ZN(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,i=t[s],o=i.shape;if(!we(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const l=e.texShape,c=i.isUniform?null:i.texData.texShape;if(!we(l,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${c} must match`)})}function Vat(n,t,e,s,r){t.program.enableShapeUniforms||(ZN(t.inShapeInfos,e),ZN([t.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),ct().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<e.length;++c){const h=e[c],{uniform:d,offset:p,shape:m,texShape:y}=t.variablesLocations[c];if(m){const{uniformShape:b}=_C(t.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(ft(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,c)}}const l=t.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const c=Ot(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(c));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const h=t.program.customUniforms[c],d=t.customUniformLocations[c],p=r[c];if(h.type==="float")n.gl.uniform1fv(d,p);else if(h.type==="vec2")n.gl.uniform2fv(d,p);else if(h.type==="vec3")n.gl.uniform3fv(d,p);else if(h.type==="vec4")n.gl.uniform4fv(d,p);else if(h.type==="int")n.gl.uniform1iv(d,p);else if(h.type==="ivec2")n.gl.uniform2iv(d,p);else if(h.type==="ivec3")n.gl.uniform3iv(d,p);else if(h.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function Uat(n,t,e){let s="";t.concat(e).forEach(o=>{const l=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const c=o.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:p}=_C(n.packedInputs,o.shape,c);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Ot(d);b=`${E[0]===c[1]}_${E[E.length-1]===c[1]}`}const x=o.shape.length,w=d.length===2&&we(o.shape,c),S=ft(o.shape)===1,T=Oc(o.shape,e.shape),k=!n.packedInputs&&x===e.shape.length&&we(c,e.texData.texShape),$=n.packedInputs||d.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${x}_${k}_${h?p:""}_${d.length}_${S}_${T}_${w}_${m}_${y}_${b}_${$}_${l}`}else{const c=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${c}_${l}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${ct().getNumber("WEBGL_VERSION")}`,i}function ns(n){return ct().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class jat{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Hh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=hs();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?D0(["r","c","d"],t):dl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class Gat{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Hh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=hs();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?D0(["r","c","d"],t):dl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class Wat{constructor(t){this.variableNames=["A"],this.outTexUsage=Zs.DOWNLOAD;const e=hs();this.outputShape=t,this.userCode=`
      ${fL}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class Hat{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Zs.DOWNLOAD;const e=hs();this.outputShape=t,this.userCode=`
      ${fL}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const qat={R:0,G:1,B:2,A:3};class JN{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=hs();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let l=0;l<s.length;l++){const c=s[l];o+=`
          if(offset == ${l}) {
            result = values[${qat[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?AC():NC(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class Kat{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=hs();this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){const c=o*2+l;r+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?AC():NC(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function Xat(n){const t=hs(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Rot(n,e)}function Yat(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Lot(n,t)}function Zat(n){const t=new Uint16Array([0,1,2,2,1,3]);return Pot(n,t)}function xf(n,t,e,s,r,i){Bot(t,e);const o=zot(n),l=n.TEXTURE_2D;return $t(n,()=>n.bindTexture(l,o)),$t(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),$t(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),$t(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),$t(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),ct().getNumber("WEBGL_VERSION")===1?$t(n,()=>n.texImage2D(l,0,s,t,e,0,r,i,null)):$t(n,()=>n.texStorage2D(l,1,s,t,e)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function bL(n){return n.internalFormatFloat}function Jat(n,t,e,s){const[r,i]=yf(t,e);return xf(n,r,i,bL(s),s.textureFormatFloat,n.FLOAT)}function xL(n){return n.internalFormatHalfFloat}function Qat(n,t,e,s){const[r,i]=yf(t,e);return xf(n,r,i,xL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function vL(n){return n.downloadTextureFormat}function tlt(n,t,e,s){const[r,i]=yf(t,e);return xf(n,r,i,vL(s),n.RGBA,n.UNSIGNED_BYTE)}function wL(n){return n.internalFormatPackedFloat}function elt(n,t,e,s){const[r,i]=Qc(t,e);return xf(n,r,i,wL(s),n.RGBA,n.FLOAT)}function SL(n){return n.internalFormatPackedHalfFloat}function nlt(n,t,e,s){const[r,i]=Qc(t,e);return xf(n,r,i,SL(s),n.RGBA,s.textureTypeHalfFloat)}function slt(n,t,e){return $t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),KN(n,t,"clipSpacePos",e,3,20,0)&&KN(n,t,"uv",e,2,20,12)}function rlt(n,t,e,s,r,i){$t(n,()=>n.bindTexture(n.TEXTURE_2D,t));let o,l,c;r instanceof Uint8Array?(o=new Uint8Array(e*s*4),l=n.UNSIGNED_BYTE,c=n.RGBA):(o=new Float32Array(e*s*4),l=n.FLOAT,c=i.internalFormatPackedFloat),o.set(r),ct().getNumber("WEBGL_VERSION")===2?$t(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,l,o)):$t(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,e,s,0,n.RGBA,l,o)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function ilt(n,t,e){$t(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?ct().getNumber("WEBGL_VERSION")===2?$t(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):$t(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):ct().getNumber("WEBGL_VERSION")===2?$t(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):$t(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function olt(n,t,e,s){const r=n.createBuffer();$t(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const l=4*4*t*e;return $t(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),$t(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),$t(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function alt(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function llt(n,t,e,s){const[r,i]=yf(t,e),o=4,l=new Uint8Array(kot(t*e,o));return $t(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function clt(n,t,e,s,r,i,o,l){const c=n,h=new Float32Array($ot(i,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,h),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),h}function ult(n,t,e){const s=new Float32Array(t*e*4);return $t(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}class Hx{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=ct().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,Sot(e,t)):this.gl=Hr(e),t=this.gl,ct().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>$t(i,()=>i.createVertexArray()),this.bindVertexArray=o=>$t(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>$t(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>$t(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>$t(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>$t(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>$t(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>$t(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ct().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Qp(this.gl,i),vr(this.gl,o))this.textureHalfFloatExtension=Qp(this.gl,o);else if(ct().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),vr(this.gl,r))this.colorBufferHalfFloatExtension=Qp(this.gl,r);else if(ct().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",vr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(vr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Yat(this.gl),this.indexBuffer=Zat(this.gl),this.framebuffer=Vot(this.gl),this.textureConfig=IC(this.gl,this.textureHalfFloatExtension)}get debug(){return ct().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;$t(t,()=>t.finish()),$t(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),$t(t,()=>t.deleteFramebuffer(this.framebuffer)),$t(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),$t(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),$t(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),Jat(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),Qat(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),tlt(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),ilt(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),rlt(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),nlt(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),elt(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(XN(this.gl,this.framebuffer),this.outputTexture=null),$t(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>llt(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,i,o){return clt(this.gl,t,e,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return alt(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=olt(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(ct().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=i}else ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>ult(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=Xat(e));const s=Mot(e);$t(e,()=>e.attachShader(s,this.vertexShader)),$t(e,()=>e.attachShader(s,t)),Fot(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Ux(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;$t(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),slt(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&($t(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Ux(this.gl,this.program),$t(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?jot(this.gl,t,e):Got(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),$t(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),Wot(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,i]=Qc(e,s);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Ux(this.gl,this.program),tm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}$t(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),$t(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Qp(this.gl,ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await _I(()=>this.disposed||this.isQueryAvailable(t,ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=hlt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ct().platform&&(s=ct().platform.setTimeoutCustom.bind(ct().platform)),_I(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),jx(this.gl,t,this.framebuffer),this.debug&&tm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(jx(this.gl,this.outputTexture,this.framebuffer),this.debug&&tm(this.gl)):XN(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;jx(r,t,this.framebuffer),this.debug&&tm(r),this.outputTexture=t,$t(r,()=>r.viewport(0,0,e,s)),$t(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),$t(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function hlt(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}const{addImpl:dlt,bincountImpl:CL,bincountReduceImpl:flt,bitwiseAndImpl:plt,castImpl:mlt,ceilImpl:glt,concatImpl:ylt,equalImpl:blt,expImpl:xlt,expm1Impl:vlt,floorImpl:wlt,gatherNdImpl:Slt,gatherV2Impl:Clt,greaterImpl:Tlt,greaterEqualImpl:klt,lessImpl:$lt,lessEqualImpl:Elt,linSpaceImpl:Ilt,logImpl:Nlt,maxImpl:Alt,maximumImpl:_lt,minimumImpl:Rlt,multiplyImpl:Dlt,negImpl:Olt,notEqualImpl:Mlt,prodImpl:Flt,raggedGatherImpl:Llt,raggedRangeImpl:Plt,raggedTensorToTensorImpl:zlt,rangeImpl:Blt,rsqrtImpl:Vlt,scatterImpl:Ult,sigmoidImpl:jlt,simpleAbsImpl:TL,sliceImpl:Glt,sparseFillEmptyRowsImpl:Wlt,sparseReshapeImpl:Hlt,sparseSegmentReductionImpl:kL,sqrtImpl:qlt,staticRegexReplaceImpl:Klt,stridedSliceImpl:Xlt,stringNGramsImpl:Ylt,stringSplitImpl:Zlt,stringToHashBucketFastImpl:Jlt,subImpl:Qlt,tileImpl:tct,topKImpl:ect,transposeImpl:RC,uniqueImpl:nct}=set;function $L(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function os(n,t){return t===1?[n]:$L(n,t)}function sct(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}class rct{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ns(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=os("rc",this.rank),s=Ie(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class EL{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${ict(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?AC():NC(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function ict(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?sat(["r","c","d"],"inputShape"):dl(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class oct{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=tA(e,s),i=eA(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=QN(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const c=this.freeTextures[i].pop();return this.usedTextures[i].push(c),c}let l;return r===Ln.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Ln.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Ln.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Ln.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Ln.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(l),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),l}releaseTexture(t,e,s,r){if(this.freeTextures==null)return;const i=tA(s,r),o=eA(e,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const l=QN(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),c=ct().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=l):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const h=this.usedTextures[o],d=h&&h.indexOf(t);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function act(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function QN(n,t,e,s,r){const i=lct(t,s);let o;if(r){const[c,h]=Qc(n[0],n[1]);o=c*h}else{const[c,h]=yf(n[0],n[1]);o=c*h}const l=act(e,i);return o*l}function lct(n,t){switch(n){case Ln.PACKED_2X2_FLOAT32:return wL(t);case Ln.PACKED_2X2_FLOAT16:return SL(t);case Ln.UNPACKED_FLOAT32:return bL(t);case Ln.UNPACKED_FLOAT16:return xL(t);case Ln.PACKED_4X1_UNSIGNED_BYTE:return vL(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function cct(n){return ct().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ln.PACKED_2X2_FLOAT32:Ln.UNPACKED_FLOAT32:n?Ln.PACKED_2X2_FLOAT16:Ln.UNPACKED_FLOAT16}function tA(n,t){if(n===Zs.UPLOAD)return Ln.PACKED_2X2_FLOAT32;if(n===Zs.RENDER||n==null)return cct(t);if(n===Zs.DOWNLOAD||n===Zs.PIXELS)return Ln.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function eA(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class ii{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const $r="if (isnan(x)) return x;",uct="return x;",nA="return abs(x);",hct="return (x >= 0.0) ? x : (exp(x) - 1.0);",dct=$r+`
  return (x < 0.0) ? 0.0 : x;
`,fct=$r+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,$o="return x;",pct="return 1.0 / (1.0 + exp(-1.0 * x));";const mct="return x;",gct=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,yct=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bct=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xct="return 1.0 / (1.0 + exp(-1.0 * x));";class Ao{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class vct{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);const e=t.length,s=os("rc",e),r=Ie(e),i=sct(e,s),o=s.slice(-2),l=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}const wct=XD,Sct=1e-7,Cct=1e-4,sm={};function Tct(n){return n in sm||(sm[n]={}),sm[n]}const kct=ct().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),$ct=600;function Ect(){return ct().global.screen==null?1024:ct().global.screen.height*ct().global.screen.width*window.devicePixelRatio*$ct/1024/1024}class O0 extends Jw{nextDataId(){return O0.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ct().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof Hx)e=t;else{const s=Hr(ct().getNumber("WEBGL_VERSION"),t);e=new Hx(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Hr(ct().getNumber("WEBGL_VERSION"));e=new Hx(s),this.binaryCache=Tct(ct().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new oct(this.gpgpu),this.numMBBeforeWarning=Ect(),this.texData=new SR(this,ti())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,r,i,o){const l=this.makeTensorInfo(e,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:t,texShape:[r,i]},c.texShape=[r,i];const h=em(e),d=new JN(h,!1,o),p=this.runWebGLProgram(d,[l],s,[[r,i]]);return p.shape=e,c.texture=null,this.disposeIntermediateTensorInfo(l),p.dataId}write(t,e,s){if((ct().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ct().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:s,values:t,usage:Zs.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,r,i){if(ct().getBool("DEBUG")&&this.checkNumericalProblems(e),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:r,values:e,usage:Zs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:l,isPacked:c}=e;if(o!=null){let m;c?m=new Ao(l,$o):m=new ii(l,$o);const y=this.runWebGLProgram(m,[{dataId:t,shape:l,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=gs());let p;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);p=Hi(m,y)}else p=this.getValuesFromTexture(t);return h&&(this.downloadWaitMs+=gs()-d),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){const b=this.pendingRead.get(t);return new Promise(x=>b.push(x))}const e=this.texData.get(t),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:l,isPacked:c}=e;if(i!=null){let b;c?b=new Ao(r,$o):b=new ii(r,$o);const x=this.runWebGLProgram(b,[{dataId:t,shape:r,dtype:o}],o),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(t);if(ct().getBool("DEBUG")&&!ct().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ct().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(o!=="complex64"&&ct().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(t);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Jp(r))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(o==="complex64"){const b=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),x=b[0],w=b[1];p=Hi(x,w)}else if(h==null)p=this.getValuesFromTexture(t);else{const b=ft(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;$t(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(t,p),y=this.pendingRead.get(t);return this.pendingRead.delete(t),y.forEach(b=>b(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ti().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){const s=this.texData.get(t),{values:r,shape:i,slice:o,dtype:l,isPacked:c,texture:h}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let y;c?y=new Ao(i,$o):y=new ii(i,$o);const b=this.runWebGLProgram(y,[{dataId:t,shape:i,dtype:l}],l),x=this.readToGPU(b,e);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(t,e.customTexShape),p=ti().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>Lo(r));return Qt(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qt(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!Aot(s))throw ct().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:r}=this.texData.get(t),i=ft(e);if(ct().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(t),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Jp(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),b}const o=ct().getBool("WEBGL_PACK")&&r===!0,l=o?em(e):e,c=o?new Hat(l):new Wat(l),h=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:t}],"float32"),d=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=Ha(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Ha(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=e,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(i);l.kernelMs=z5(c),l.getExtraProfileInfo=()=>c.map((h,d)=>({name:o[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:gs(),endMs:null}}endTimer(t){return ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=gs(),t)}async getQueryTime(t){if(ct().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:r,usage:i,isPacked:o,slice:l}=this.texData.get(t),c=l&&l.origDataId||t,h=this.dataRefCount.get(c);h>1?this.dataRefCount.set(c,h-1):(this.dataRefCount.delete(c),e!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(e,r,i,o)));const d=this.texData.get(t);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=kct){return ct().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&ft(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Ys("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return wct(t.shape,e)}packedUnaryOp(t,e,s){const r=new Ao(t.shape,e),i=this.compileAndRun(r,[t],s);return ti().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=TL(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(ct().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,nA,t.dtype);const e=new ii(t.shape,nA),s=this.compileAndRun(e,[t]);return ti().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&ed(s[0])){const i=s.map(o=>Ro(o));r=this.write(i,t,e)}else r=this.write(s,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,s){return ti().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new vct(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new rct(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[Bc(t.shape),...Vc(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[Bc(e),...Vc(e)],o=new EL(i,s),l=!0,c=[s],h=this.runWebGLProgram(o,[r],t.dtype,c,l);return{dataId:h.dataId,shape:e,dtype:h.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:r,shape:i,dtype:o}=s;if(e!=null){const m=ft(i),y=e[0]*e[1]*4;L(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=em(i);let c;r?c=new Gat(l):c=new jat(l);const h=!0,d=[e??Jp(l)],p=this.runWebGLProgram(c,[{shape:l,dtype:o,dataId:t}],o,d,h,e);return{dtype:o,shape:i,dataId:p.dataId}}runWebGLProgram(t,e,s,r,i=!1,o){const l=this.makeTensorInfo(t.outputShape,s),c=this.texData.get(l.dataId);if(t.packedOutput&&(c.isPacked=!0),t.outPackingScheme===Hh.DENSE){const S=o??Jp(t.outputShape);c.texShape=S.map(T=>T*2)}if(t.outTexUsage!=null&&(c.usage=t.outTexUsage),ft(l.shape)===0)return c.values=Zn(l.dtype,0),l;const h=[],d=e.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(S.dataId);if(T.texture==null){if(!t.packedInputs&&ft(S.shape)<=ct().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:T.values};t.packedInputs&&(T.isPacked=!0,T.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!T.isPacked!=!!t.packedInputs)S=T.isPacked?this.unpackTensor(S):this.packTensor(S),h.push(S),T=this.texData.get(S.dataId);else if(T.isPacked&&!Qm(T.shape,S.shape)){const k=S,$=S.shape;S.shape=T.shape,S=this.packedReshape(S,$),h.push(S),T=this.texData.get(S.dataId),k.shape=$}return{shape:S.shape,texData:T,isUniform:!1}});this.uploadToGPU(l.dataId);const p={shape:l.shape,texData:c,isUniform:!1},m=Uat(t,d,p),y=this.getAndSaveBinary(m,()=>Bat(this.gpgpu,t,d,p)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),ct().get("ENGINE_COMPILE_ONLY")||Vat(this.gpgpu,y,d,p,r),h.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(x=this.endTimer(x),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(x)}));const w=ct().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=gs();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!ct().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){const S=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),S}return l}compileAndRun(t,e,s,r,i=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,r,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ct().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=rt(()=>{if(!ct().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=ct().getBool("DEBUG");ct().set("DEBUG",!1);const e=this.abs(ve(1e-8)).dataSync()[0];if(ct().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Sct:Cct}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:r,values:i,texture:o,usage:l,isPacked:c}=e;if(o!=null)return;const h=this.activeTimers!=null;let d;h&&(d=gs());let p=e.texShape;if(p==null&&(p=Kot(s,c),e.texShape=p),i!=null){const m=em(s);let y,b=p[1],x=p[0];const w=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!w)&&([b,x]=Qc(p[0],p[1])),c?y=new Kat(m,w):y=new JN(m,w);const S=w?[x,b]:p,T=this.makeTensorInfo(S,r),k=this.texData.get(T.dataId);w?k.usage=Zs.PIXELS:k.usage=Zs.UPLOAD,k.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),b,x,i);const $=[[x,b]],N=this.runWebGLProgram(y,[T],r,$,!0),_=this.texData.get(N.dataId);e.texShape=_.texShape,e.isPacked=_.isPacked,e.usage=_.usage,ct().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(e.texture=_.texture,e.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(T),h&&(this.uploadWaitMs+=gs()-d)}else{const m=this.acquireTexture(p,l,r,c);e.texture=m}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:r}=s;return e!=null&&(s.values=Ict(e,r)),s.values}acquireTexture(t,e,s,r){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*Em(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(e),r(!0)}catch(i){throw i}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await pO(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(dL(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:c}=yL(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=r,t.nanLoc=i,t.outShapeLocation=o,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:r,height:i,width:o,channels:l}=t,c=ti().backend;if(!c.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=c.writeTexture(r,e,s,i,o,l);return ti().makeTensorFromDataId(h,e,s,c)}}O0.nextDataId=0;function Ict(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}uD()&&fD("webgl",()=>new O0,2);const DC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class il{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=qt(e,s),this.enableShapeUniforms=ns(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const pl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ru{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=qt(e,s);const i=this.outputShape.length;this.enableShapeUniforms=ns(i);let o="";if(r)if(i===0||ft(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Ie(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=os("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function Ls(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Nct={kernelName:Sd,backendName:"webgl",kernelFunc:Ls};function ta(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.makeTensorInfo(s.shape,"complex64"),o=e.texData.get(i.dataId),l=Ls({inputs:{x:s},backend:e}),c=Ls({inputs:{x:r},backend:e});return o.complexTensorInfos={real:l,imag:c},i}const Act={kernelName:d1,backendName:"webgl",kernelFunc:ta};const IL="return (a < 0.) ? b * a : a;",NL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function _ct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s,o=e.makeTensorInfo([],"float32",Wo(i,"float32")),l=ct().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(NL,r.shape,o.shape):new il(IL,r.shape,o.shape),c=e.runWebGLProgram(l,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),c}const Rct={kernelName:Ag,backendName:"webgl",kernelFunc:_ct};const AL="return (a < 0.) ? b * a : a;",_L=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Dct(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,i=ct().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(_L,s.shape,r.shape):new il(AL,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],"float32")}const Oct={kernelName:Xg,backendName:"webgl",kernelFunc:Dct};const iu="if (isnan(x)) return x;";function he({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,l=i,c=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&e!=null){const p=l.texData.get(o.dataId),m=e(p.values,c);return l.makeTensorInfo(o.shape,c,m)}const h=ct().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let d;return h?d=new Ao(o.shape,t):d=new ii(o.shape,n),l.runWebGLProgram(d,[o],c)}}function Vn({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:l})=>{const{a:c,b:h}=o,d=l;if(s&&c.dtype==="complex64"){const b=d.texData.get(c.dataId),x=d.texData.get(h.dataId),[w,S]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(k=>{const[$,E]=k,N={dataId:$.dataId,dtype:$.dtype,shape:c.shape},_={dataId:E.dataId,dtype:E.dtype,shape:h.shape},R=new il(n,c.shape,h.shape);return d.runWebGLProgram(R,[N,_],Ms($.dtype,E.dtype))}),T=ta({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),T}const p=i||Ms(c.dtype,h.dtype);if((c.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([c,h]))&&r!=null){const b=d.texData.get(c.dataId).values,x=d.texData.get(h.dataId).values,w=c.dtype==="string"?qi(b):b,S=c.dtype==="string"?qi(x):x,[T,k]=r(c.shape,h.shape,w,S,p),$=d.makeTensorInfo(k,p),E=d.texData.get($.dataId);return E.values=T,$}const m=ct().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let y;return m?y=new ru(t,c.shape,h.shape,e):y=new il(n,c.shape,h.shape),d.runWebGLProgram(y,[c,h],p)}}function qh(n,t=!1){if(n==="linear")return t?mct:uct;if(n==="relu")return t?yct:dct;if(n==="elu")return t?gct:hct;if(n==="relu6")return t?bct:fct;if(n==="prelu")return t?_L:AL;if(n==="leakyrelu")return t?NL:IL;if(n==="sigmoid")return t?xct:pct;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class RL{constructor(t,e,s,r=!1,i=!1,o=!1,l=null,c=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=ns(this.outputShape.length);const d=r?t[1]:t[2],p=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";l&&(c?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:w=`vec4 activation(vec4 x) {
          ${l}
        }`,S="result = activation(result);");const T=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let k="rc.x",$="rc.x";t[0]<e[0]?k=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&($=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${$};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${S}

        setOutput(result);
      }
    `}}const sA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class rA{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=qt(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const iA="return a * b;";function OC(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=Ms(s.dtype,r.dtype);if(s.dtype==="complex64"){const l=e.texData.get(s.dataId),c=e.texData.get(r.dataId),h=new rA(sA.REAL,s.shape,r.shape),d=new rA(sA.IMAG,s.shape,r.shape),p=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:r.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:r.shape}],m=e.runWebGLProgram(h,p,"float32"),y=e.runWebGLProgram(d,p,"float32"),b=ta({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}if(e.shouldExecuteOnCPU([s,r])){const l=e.texData.get(s.dataId),c=e.texData.get(r.dataId),[h,d]=Dlt(s.shape,r.shape,l.values,c.values,i),p=e.makeTensorInfo(d,i),m=e.texData.get(p.dataId);return m.values=h,p}let o;return ct().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new ru(iA,s.shape,r.shape):o=new il(iA,s.shape,r.shape),e.runWebGLProgram(o,[s,r],i)}const Mct={kernelName:_d,backendName:"webgl",kernelFunc:OC};function Fct(n,t,e){const s=[Bc(n.shape),...Vc(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[Bc(t),...Vc(t)],o=new EL(i,s),l=!0,c=[s],h=e.runWebGLProgram(o,[r],n.dtype,c,l);return{dataId:h.dataId,shape:t,dtype:h.dtype}}function Tt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=e,l=ft(r.shape),c=CR(i,l),h=ft(c);L(l===h,()=>`The new shape (${c}) has ${h} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(r.dataId);return d.isPacked&&!Qm(r.shape,c)&&!(d.texture!==null&&Qm(d.shape,c))?Fct(r,c,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype})}const Lct={kernelName:Zg,backendName:"webgl",kernelFunc:Tt};class oA{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];const l=Math.floor(s/4)*4,c=s%4;let h="sumValue += dot(values, ones);";if(e!=null){const p=1/e;h=`sumValue += dot(values * ${_c(p)?p.toPrecision(2):p}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class Pct{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];let l="0.0",c="";e==="prod"?l="1.0":e==="min"?(l="1.0 / 1e-20",c="min"):e==="max"&&(l="-1.0 / 1e-20",c="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?h="sumValue":e==="prod"?h="prodValue":e==="all"?h="allValue":e==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";e==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):e==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function zct(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=b0(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function ml(n,t,e,s){const r=zct(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:l,windowSize:c,outSize:h}=r[o];let d,p;e==="mean"?d=o===0?new oA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},l):new oA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h}):d=new Pct({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},e),p=i,i=s.runWebGLProgram(d,[i],t),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}class Bct{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[e[o]];this.outputShape=s,this.rank=s.length;const r=Ie(this.rank),i=Vct(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Vct(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}class Uct{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let d=0;d<s.length;d++)s[d]=t[e[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ie(this.rank),i=$L("rc",this.rank),o=new Array(this.rank);for(let d=0;d<e.length;d++)o[e[d]]=i[d];const l=`vec2(${o.slice(-2).join()})`,c=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${o.join()}), ${l})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${c}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${c}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function M0(n,t,e){const s=ct().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uct(n.shape,t):new Bct(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function jct(n,t,e,s){const r=t,i=n.shape.length,o=te(r,n.shape);let l=o;const c=qe(l,i),h=c!=null;let d=n;h&&(d=M0(n,c,s),l=sn(l.length,i)),Bn("sum",l,i);const[p,m]=On(d.shape,l);let y=p;e&&(y=hn(p,o));const b=ft(m),w=ft(n.shape)/b,S=Tt({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),T=H1(n.dtype),k=ml(S,T,"sum",s),$=Tt({inputs:{x:k},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(k),h&&s.disposeIntermediateTensorInfo(d),$}function F0(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;return jct(r,i,o,e)}const Gct={kernelName:s0,backendName:"webgl",kernelFunc:F0};function cs(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:i}=s,o=e,l=r.shape.length,c=new Array(l);for(let d=0;d<c.length;d++)c[d]=r.shape[i[d]];let h;if(o.shouldExecuteOnCPU([r])){const p=o.texData.get(r.dataId).values,m=RC(p,r.shape,r.dtype,i,c);h=o.makeTensorInfo(c,r.dtype);const y=o.texData.get(h.dataId);y.values=m}else h=M0(r,i,o);return h}const Wct={kernelName:kc,backendName:"webgl",kernelFunc:cs};const DL=1e3;function tg({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:c=null}){const h=n.shape.length,d=t.shape.length,p=e?n.shape[h-2]:n.shape[h-1],m=s?t.shape[d-1]:t.shape[d-2],y=e?n.shape[h-1]:n.shape[h-2],b=s?t.shape[d-2]:t.shape[d-1],x=n.shape.slice(0,-2),w=t.shape.slice(0,-2),S=ft(x),T=ft(w),$=qt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([y,b]);L(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const E=e?[S,p,y]:[S,y,p],N=s?[T,b,m]:[T,m,b],_=Tt({inputs:{x:n},backend:r,attrs:{shape:E}}),R=Tt({inputs:{x:t},backend:r,attrs:{shape:N}}),D=[_,R],O=Math.max(S,T),A=e?_.shape[1]:_.shape[2],z=i!=null,q=o!=null,W=c==="leakyrelu",X=c!=null?qh(c,!0):null,P=z||q||W||X!=null;let V;if((y===1||b===1)&&A>DL&&P===!1){let tt=_,Z=R;e&&(tt=cs({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),D.push(tt)),s&&(Z=cs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),D.push(Z));const F=b!==1,B=b===1;let Q=tt;F&&(Q=Tt({inputs:{x:tt},backend:r,attrs:{shape:[O,A,1]}}),D.push(Q));const lt=b===1?2:1;let pt=Z;B&&(pt=Tt({inputs:{x:Z},backend:r,attrs:{shape:[O,1,A]}}),D.push(pt));const gt=OC({inputs:{a:Q,b:pt},backend:r});V=F0({inputs:{x:gt},backend:r,attrs:{axis:lt,keepDims:!0}}),D.push(gt)}else{const tt=Ms(n.dtype,t.dtype),Z=new RL(E,N,[O,y,b],e,s,z,X,q,W),F=[_,R];if(i!=null&&F.push(i),q&&F.push(o),W){const B=r.makeTensorInfo([],"float32",Wo(l,"float32"));F.push(B),D.push(B)}V=r.runWebGLProgram(Z,F,tt)}const G=Tt({inputs:{x:V},backend:r,attrs:{shape:$}});D.push(V);for(const tt of D)r.disposeIntermediateTensorInfo(tt);return G}function Hct(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=t,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;return tg({a:r,b:i,transposeA:c,transposeB:h,backend:e,bias:o,preluActivationWeights:l,leakyreluAlpha:p,activation:d})}const qct={kernelName:Im,backendName:"webgl",kernelFunc:Hct};const aA="return abs(x);";function Kct(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=e.texData.get(s.dataId),o=TL(i.values);return e.makeTensorInfo(s.shape,s.dtype,o)}let r;return ct().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ao(s.shape,aA):r=new ii(s.shape,aA),e.runWebGLProgram(r,[s],s.dtype)}const Xct={kernelName:ug,backendName:"webgl",kernelFunc:Kct};const Yct=$r+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Zct=he({opSnippet:Yct}),Jct={kernelName:nd,backendName:"webgl",kernelFunc:Zct};const Qct=$r+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,tut=he({opSnippet:Qct}),eut={kernelName:sd,backendName:"webgl",kernelFunc:tut};const lA="return a + b;",nut=Vn({opSnippet:lA,packedOpSnippet:lA,supportsComplex:!0,cpuKernelImpl:dlt}),sut={kernelName:qc,backendName:"webgl",kernelFunc:nut};class rut{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class iut{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function ym(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return Ls({inputs:{x:s[0]},backend:e});if(s.length>ct().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),h=ym({inputs:s.slice(0,c),backend:e}),d=ym({inputs:s.slice(c),backend:e});return ym({inputs:[h,d],backend:e})}const r=s.map(c=>c.dtype).reduce((c,h)=>Ms(c,h)),i=s.map(c=>c.shape),l=ct().getBool("WEBGL_PACK")?new iut(s[0].shape,i):new rut(s[0].shape,i);return e.runWebGLProgram(l,s,r)}const out={kernelName:i1,backendName:"webgl",kernelFunc:ym};function aut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=te(i,r.shape);let h=c;const d=qe(h,l);let p=r;d!=null&&(p=cs({inputs:{x:r},backend:e,attrs:{perm:d}}),h=sn(h.length,l)),Bn("all",h,l);const[m,y]=On(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"all",e);let S;if(o){const T=hn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const lut={kernelName:o1,backendName:"webgl",kernelFunc:aut};function cut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=te(i,r.shape);let h=c;const d=qe(h,l);let p=r;d!=null&&(p=cs({inputs:{x:r},backend:e,attrs:{perm:d}}),h=sn(h.length,l)),Bn("any",h,l);const[m,y]=On(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"any",e);let S;if(o){const T=hn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const uut={kernelName:a1,backendName:"webgl",kernelFunc:cut};class hut{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const l=e==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class dut{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,L(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],o=Math.ceil(i/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,c=l.length,h=Ie(c),d=os("coords",c);let p,m;if(o===1){m=c+1;const R=Ie(m);p=`
        ${R} sourceLocR = ${R}(${d.join()}, 0);
        ++${d[c-1]};
        ${R} sourceLocG = ${R}(${d.join()}, 0);
        ++${d[c-2]};
        ${R} sourceLocA = ${R}(${d.join()}, 0);
        --${d[c-1]};
        ${R} sourceLocB = ${R}(${d.join()}, 0);
        --${d[c-2]};`}else m=c,p=`
        ${h} sourceLocR = coords;
        ++${d[c-1]};
        ${h} sourceLocG = coords;
        ++${d[c-2]};
        ${h} sourceLocA = coords;
        --${d[c-1]};
        ${h} sourceLocB = coords;
        --${d[c-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(R=>"int "+R),w=os("sourceLocR",m-1).concat("inIdx.r"),S=os("sourceLocG",m-1).concat("inIdx.g"),T=os("sourceLocB",m-1).concat("inIdx.b"),k=os("sourceLocA",m-1).concat("inIdx.a"),$=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${k.join()})));`,N=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,_=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[c-1]} < ${l[c-1]-1};
        bool hasNextRow = ${d[c-2]} < ${l[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function OL(n,t,e,s=null){let r=t.shape[0],i=t.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=b0(i),l={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},c=new hut(l,e,s==null),h=[t];s!=null&&h.push(s);const d=n.runWebGLProgram(c,h,"int32");if(d.shape[1]===1)return d;const p=OL(n,t,e,d);return n.disposeIntermediateTensorInfo(d),p}function ML(n,t,e,s=null){const r=s!=null?s.shape:t.shape,i=r[r.length-1],o=b0(i),l=new dut(r,o,e,s==null),c=s==null?[t]:[t,s],h=n.runWebGLProgram(l,c,"int32");if(h.shape.length===t.shape.length){const d=ML(n,t,e,h);return n.disposeIntermediateTensorInfo(h),d}return h}function FL(n,t,e,s){const r=[e];if(Bn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!ct().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId),l=o!==null&&o.isPacked;let c=t;l&&(c=n.unpackTensor(t),i.push(c));const[h,d]=On(c.shape,r),p=ft(d),m=Tt({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});i.push(m);const y=OL(n,m,s);i.push(y);const b=Tt({inputs:{x:y},backend:n,attrs:{shape:h}});return i.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return ML(n,t,s)}function fut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=te(i,r.shape);const l=qe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=cs({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=sn(o.length,c.shape.length)),Bn("argMax",[o[0]],c.shape.length);const d=FL(e,c,o[0],"max");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}const put={kernelName:hg,backendName:"webgl",kernelFunc:fut};function mut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=te(i,r.shape);const l=qe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=cs({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=sn(o.length,c.shape.length)),Bn("argMin",[o[0]],c.shape.length);const d=FL(e,c,o[0],"min");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}const gut={kernelName:dg,backendName:"webgl",kernelFunc:mut};const yut=$r+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,but=he({opSnippet:yut}),xut={kernelName:rd,backendName:"webgl",kernelFunc:but};const vut=$r+"return log(x + sqrt(x * x + 1.0));",wut=he({opSnippet:vut}),Sut={kernelName:id,backendName:"webgl",kernelFunc:wut};const Cut=$r+`
  return atan(x);
`,Tut=he({opSnippet:Cut}),kut={kernelName:od,backendName:"webgl",kernelFunc:Tut};const $ut=DC+`
  return atan(a, b);
`,Eut=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,Iut=Vn({opSnippet:$ut,packedOpSnippet:Eut}),Nut={kernelName:ld,backendName:"webgl",kernelFunc:Iut};const Aut=$r+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,_ut=he({opSnippet:Aut}),Rut={kernelName:ad,backendName:"webgl",kernelFunc:_ut};class Kh{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,l=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const x=e==="avg",w=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,S=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let T="0.0";if(x||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${l}, ${c});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?w:S:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const k="max";let $=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&($="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,N=o%4,_=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${E};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${$});
      }
    `}}class MC{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,l=t.strideDepth,c=t.strideHeight,h=t.strideWidth,d=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,y=t.effectiveFilterDepth,b=t.effectiveFilterHeight,x=t.effectiveFilterWidth,w=t.padInfo.front,S=t.padInfo.top,T=t.padInfo.left;this.outputShape=t.outShape;const k=e==="avg";let $="0.0";if(k||($="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${c}, ${h});
        const ivec3 pads = ivec3(${w}, ${S}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let N=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(N="avgValue / max(count, 1.0)");const _=Math.floor(o/4)*4,R=o%4,D=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${c}, ${h});
      const ivec3 pads = ivec3(${w}, ${S}, ${T});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${_};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${N});
      }
    `}}function Dut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;bf(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(ts(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Tr(r.shape,i,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))return Ls({inputs:{x:r},backend:e});const p=new Kh(d,"avg",!1);return e.runWebGLProgram(p,[r],"float32")}const Out={kernelName:fg,backendName:"webgl",kernelFunc:Dut};function Mut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s,d=[1,1,1],p=Yi(r.shape,i,o,d,l,c,h),m=new MC(p,"avg",!1);return e.runWebGLProgram(m,[r],"float32")}const Fut={kernelName:pg,backendName:"webgl",kernelFunc:Mut};class Lut{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=c-1-t.padInfo.top,p=h-1-t.padInfo.left,m=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Put{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=p-1-t.padInfo.front,x=m-1-t.padInfo.top,w=y-1-t.padInfo.left,S=1/(e*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function zut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Yi(o.shape,l,c,p,h,d),y=new Put(m);return e.runWebGLProgram(y,[r],o.dtype)}const But={kernelName:c1,backendName:"webgl",kernelFunc:zut};function Vut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;bf([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=Tr(o.shape,l,c,1,h),p=new Lut(d);return e.runWebGLProgram(p,[r],o.dtype)}const Uut={kernelName:l1,backendName:"webgl",kernelFunc:Vut};function jut(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:l}=s;return tg({a:r,b:i,transposeA:o,transposeB:l,backend:e})}const Gut={kernelName:mg,backendName:"webgl",kernelFunc:jut};class Wut{constructor(t,e,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],qt(t,e),qt(t,s);let l="0.0";r!=null&&(qt(t,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="1.0";i!=null&&(qt(t,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Hut{constructor(t,e,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],qt(t,e),qt(t,s);let l="vec4(0.0)";r!=null&&(qt(t,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="vec4(1.0)";i!=null&&(qt(t,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const qut=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:i,offset:o,scale:l}=n;L(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(l==null||r.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=e;c==null&&(c=.001);const h=[s,r,i];let d=null;o!=null&&(d=o.shape,h.push(o));let p=null;l!=null&&(p=l.shape,h.push(l));const m=ct().getBool("WEBGL_PACK_NORMALIZATION")?new Hut(s.shape,r.shape,i.shape,d,p,c):new Wut(s.shape,r.shape,i.shape,d,p,c);return t.runWebGLProgram(m,h,h[0].dtype)},Kut={kernelName:Eg,backendName:"webgl",kernelFunc:qut};class Xut{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Ie(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Yut(this.rank);let r;const i=t.map((o,l)=>`sourceLoc.${aw[l]} = start[${l}] + coords.${aw[l]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const aw=["x","y","z","w","u","v"];function Yut(n){if(n===1)return"sourceLoc";if(n<=6)return aw.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Zut{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Ie(this.rank),s=os("coords",this.rank),r=os("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,l=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((d,p)=>`start[${p}]`).join()});`:t.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${l}
        ${c}
        setOutput(result);
      }
    `}}function Jut(n,t,e,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(e,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=n.dtype;let l=AS(t,Ot(n.shape));r.slice&&(l+=r.slice.flatOffset),o.slice={flatOffset:l,origDataId:r.slice&&r.slice.origDataId||n.dataId};const c=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,c+1),i}function ou(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s,[l,c]=y0(r,i,o);if(ES(r,l,c),ft(c)===0)return e.makeTensorInfo(c,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=e.texData.get(r.dataId),m=Glt(p.values,l,c,r.shape,r.dtype);return e.makeTensorInfo(c,r.dtype,m)}const{isPacked:h}=e.texData.get(r.dataId),d=NS(r.shape,l,c);if(h||!d){const p=ct().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zut(c):new Xut(c),m=[l];return e.runWebGLProgram(p,[r],r.dtype,m)}return e.uploadToGPU(r.dataId),Jut(r,l,c,e)}const Qut={kernelName:n0,backendName:"webgl",kernelFunc:ou};const tht=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;L(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((T,k)=>T*k),c=rf(r.shape,i,l),h=of(c.length,i.length),d=af(r.shape,i,l),p=MS(o,i.length),m=FS(d,o,i.length),y=[],b=Tt({inputs:{x:r},backend:e,attrs:{shape:c}}),x=cs({inputs:{x:b},backend:e,attrs:{perm:h}}),w=Tt({inputs:{x},backend:e,attrs:{shape:d}}),S=ou({inputs:{x:w},backend:e,attrs:{begin:p,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(T=>e.disposeIntermediateTensorInfo(T)),S},eht={kernelName:gg,backendName:"webgl",kernelFunc:tht};function nht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,l=e.readSync(r.dataId),c=e.readSync(i.dataId),h=CL(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,h)}const sht={kernelName:u1,backendName:"webgl",kernelFunc:nht};const rht=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,iht=`
  return float(int(a.r) & int(b.r));
`;function oht(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=ct().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=ct().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,r])||o===1){const c=e.texData.get(s.dataId).values,h=e.texData.get(r.dataId).values,[d,p]=plt(s.shape,r.shape,c,h,s.dtype),m=e.makeTensorInfo(p,s.dtype),y=e.texData.get(m.dataId);return y.values=d,m}let l;return i?l=new ru(rht,s.shape,r.shape,!1):l=new il(iht,s.shape,r.shape),e.runWebGLProgram(l,[s,r],s.dtype)}const aht={kernelName:h1,backendName:"webgl",kernelFunc:oht};function lht(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.readSync(s.dataId),o=e.readSync(r.dataId),l=qt(Array.from(i),Array.from(o));return e.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const cht={kernelName:NR,backendName:"webgl",kernelFunc:lht};const uht="return float(a != b);",LL=Vn({opSnippet:uht,cpuKernelImpl:Mlt,dtype:"bool"}),hht={kernelName:Gg,backendName:"webgl",kernelFunc:LL};function vf(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return Ls({inputs:{x:r.complexTensorInfos.real},backend:e})}const dht={kernelName:F1,backendName:"webgl",kernelFunc:vf};const fht="return float(int(x));";function pht(n,t){const e=new ii(n.shape,fht),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function lw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Ls({inputs:{x:r},backend:e});const o=Rn(r.shape),l=lw({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),c=ta({inputs:{real:l,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(l),c}if(r.dtype==="complex64"){const o=vf({inputs:{input:r},backend:e}),l=lw({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),l}if(!TR(r.dtype,i)){const o=Ls({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[l,c,h]=mlt(o,r.shape,r.dtype,i);return e.makeTensorInfo(l,c,h)}if(i==="int32")return pht(r,e);if(i==="bool"){const o=e.makeTensorInfo([],"bool",Zn("bool",1)),c=LL({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),c}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const mht={kernelName:cd,backendName:"webgl",kernelFunc:lw};const cA="return ceil(x);",ght=he({opSnippet:cA,packedOpSnippet:cA,cpuKernelImpl:glt}),yht={kernelName:ud,backendName:"webgl",kernelFunc:ght};class bht{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class xht{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function vht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:i,clipValueMax:o}=s;let l;ct().getBool("WEBGL_PACK_CLIP")?l=new xht(r.shape):l=new bht(r.shape);const c=[[i],[o]];return e.runWebGLProgram(l,[r],r.dtype,c)}const wht={kernelName:hd,backendName:"webgl",kernelFunc:vht};class Sht{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function uA(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function Cht(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),i=new Sht(s.shape),o=[uA(s,r.complexTensorInfos.real),uA(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}const Tht={kernelName:yg,backendName:"webgl",kernelFunc:Cht};class kht{constructor(t){this.outputShape=[],this.outputShape=ui(t,1),this.variableNames=t.map((o,l)=>`T${l}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++){const l=e[o-1];s.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${l}));`)}const r=e.length,i=e[e.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class $ht{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ui(t,e);const s=this.outputShape,r=s.length,i=Ie(r),o=os("coords",r),l=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((x,w)=>`T${w}`);const c=new Array(t.length-1);c[0]=t[0][e];for(let x=1;x<c.length;x++)c[x]=c[x-1]+t[x][e];const h=l[e],d=l.slice(-2),p=l.join();let m=`if (${h} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let x=1;x<c.length;x++){const w=c[x-1];m+=`
        if (${h} < ${c[x]}  && ${h} >= ${c[x-1]}) {
          return getChannel(
            getT${x}(${rm(l,h,w)}),
            vec2(${rm(d,h,w)}));
        }`}const y=c.length,b=c[c.length-1];m+=`
        return getChannel(
          getT${y}(${rm(l,h,b)}),
          vec2(${rm(d,h,b)}));`,this.userCode=`
      float getValue(${l.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function rm(n,t,e){const s=n.indexOf(t);return n.map((i,o)=>o===s?`${i} - ${e}`:i).join()}function L0(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return Ls({inputs:{x:r.complexTensorInfos.imag},backend:e})}const Eht={kernelName:I1,backendName:"webgl",kernelFunc:L0};function ph(n,t,e){const s=n[0].dtype;if(s==="complex64"){const y=n.map(T=>vf({inputs:{input:T},backend:e})),b=n.map(T=>L0({inputs:{input:T},backend:e})),x=ph(y,t,e),w=ph(b,t,e),S=ta({inputs:{real:x,imag:w},backend:e});return y.forEach(T=>e.disposeIntermediateTensorInfo(T)),b.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),S}let r=e.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map($=>{const N=[-1,ft($.shape.slice(t))];return Tt({inputs:{x:$},backend:e,attrs:{shape:N}})}),b=y.map($=>({vals:e.readSync($.dataId),shape:$.shape})),x=ui(y.map($=>$.shape),1),w=y[0].shape[0]===1,S=ylt(b,x,s,w),T=ui(n.map($=>$.shape),t),k=e.makeTensorInfo(T,s,S);return y.forEach($=>e.disposeIntermediateTensorInfo($)),k}const i=n.filter(y=>ft(y.shape)>0),o=ct().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=o?new ii(n[0].shape,$o):new Ao(n[0].shape,$o);return e.runWebGLProgram(y,n,s)}const l=ct().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const y=[];for(let x=0;x<i.length;x+=l){const w=i.slice(x,x+l);y.push(ph(w,t,e))}const b=ph(y,t,e);for(const x of y)e.disposeIntermediateTensorInfo(x);return b}if(o){const y=new $ht(i.map(b=>b.shape),t);return e.runWebGLProgram(y,i,s)}const{tensors2D:c,outShape:h}=Iht(i,t,e),d=new kht(c.map(y=>y.shape)),p=e.runWebGLProgram(d,c,s);c.forEach(y=>e.disposeIntermediateTensorInfo(y));const m=Tt({inputs:{x:p},attrs:{shape:h},backend:e});return e.disposeIntermediateTensorInfo(p),m}function Iht(n,t,e){const s=ui(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>Tt({inputs:{x:i},attrs:{shape:[-1,ft(i.shape.slice(t))]},backend:e})),outShape:s}}function PL(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=te(r,t[0].shape)[0],o=t.map(h=>h.shape);RS(o,i);const l=ui(t.map(h=>h.shape),i);if(ft(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const c=t.filter(h=>ft(h.shape)>0);return c.length===1?Ls({inputs:{x:c[0]},backend:e}):ph(c,i,e)}const Nht={kernelName:bg,backendName:"webgl",kernelFunc:PL};class zL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,l=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,x=t.inChannels%4,w=t.dataFormat==="channelsLast",S=w?1:2,T=w?2:3,k=w?3:1;let $="",E="";s&&(r?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:$=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const N=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${c}, ${h});
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${E}
        setOutput(result);
      }
    `}}class Aht{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,x=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${e}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class BL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ns(this.outputShape.length);const o=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const S=w*2;if(m+=`
           xC = xCCorner + ${S*c};
           `,l===1){if(S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,c===1&&S>0?m+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const T=o%2===0?Qw(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,c>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:m+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):T===1?m+=`
                     xC${S+1} = xTexelC${S};
                     `:m+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(m+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(m+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(m+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class _ht{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ns(this.outputShape.length);const{dataFormat:s}=e,r=hs(),i=s==="channelsLast",o=i?1:2,l=i?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}function eg(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function VL({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape,h=s.texData.get(n.dataId),d=e.inChannels,p=c[0]*c[1]*c[2],m=e.outChannels,y=e.dataFormat==="channelsLast",b=!1,x=!1;let w;const S=[];if(i!=null){const $=eg(i.shape,y);$!=null&&(i=Tt({inputs:{x:i},backend:s,attrs:{shape:$}}),S.push(i))}if(r!=null){const $=eg(r.shape,y);$!=null&&(r=Tt({inputs:{x:r},backend:s,attrs:{shape:$}}),S.push(r))}if(!((p===1||m===1)&&d>DL)&&h.isPacked&&y&&h.texture!=null&&c[2]%2!==0&&we(h.shape.slice(-3),c.slice(-3))){const $=c[0]*c[1]*(c[2]+1),E={dataId:n.dataId,shape:[1,$,e.inChannels],dtype:n.dtype},N=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,L(Qm(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const _=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});S.push(_);const R=tg({a:E,b:_,backend:s,transposeA:b,transposeB:x,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),D=s.texData.get(R.dataId);L(D.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=N,D.shape=e.outShape,w=Ls({inputs:{x:R},backend:s}),w.shape=e.outShape,S.push(R)}else{const $=e.outHeight*e.outWidth,E=Tt({inputs:{x:n},backend:s,attrs:{shape:y?[e.batchSize,$,e.inChannels]:[e.batchSize,e.inChannels,$]}}),N=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),_=tg({a:y?E:N,b:y?N:E,transposeA:!y,transposeB:x,backend:s,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o});w=Tt({inputs:{x:_},backend:s,attrs:{shape:e.outShape}}),S.push(E),S.push(N),S.push(_)}for(const $ of S)s.disposeIntermediateTensorInfo($);return w}function UL({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:c,filterHeight:h,inChannels:d,outWidth:p,outHeight:m,dataFormat:y}=e,b=y==="channelsLast",x=c*h*d,w=m*p,S=[e.batchSize,x,w],T=!0,k=!1,$=[];if(i!=null){const G=eg(i.shape,b);G!=null&&(i=Tt({inputs:{x:i},backend:s,attrs:{shape:G}}),$.push(i))}if(r!=null){const G=eg(r.shape,b);G!=null&&(r=Tt({inputs:{x:r},backend:s,attrs:{shape:G}}),$.push(r))}const E=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,x,ft(t.shape)/x]}});$.push(E);const N=new _ht(S,e),_=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],R=s.runWebGLProgram(N,[n],"float32",_),D=Tt({inputs:{x:R},backend:s,attrs:{shape:S}});$.push(R),$.push(D);const O=r!=null,A=i!=null,z=l==="leakyrelu",q=l?qh(l,!0):null,W=new RL(b?D.shape:E.shape,b?E.shape:D.shape,b?[e.batchSize,w,e.outChannels]:[e.batchSize,e.outChannels,w],T,k,O,q,A,z),X=b?[D,E]:[E,D];if(r&&X.push(r),A&&X.push(i),z){const G=s.makeTensorInfo([],"float32",Wo(o,"float32"));X.push(G),$.push(G)}const P=s.runWebGLProgram(W,X,"float32"),V=Tt({inputs:{x:P},backend:s,attrs:{shape:e.outShape}});$.push(P);for(const G of $)s.disposeIntermediateTensorInfo(G);return V}function Rht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s,p=Zi(c),m=zn(r.shape,i.shape,o,h,l,d,!1,p);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=VL({x:r,filter:i,convInfo:m,backend:e});else if(m.strideWidth<=2&&p==="channelsLast"&&ct().getBool("WEBGL_EXP_CONV")){const x=new BL(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=e.runWebGLProgram(x,[r,i],"float32",w)}else if(ct().getBool("WEBGL_CONV_IM2COL"))y=UL({x:r,filter:i,convInfo:m,backend:e});else{const x=new zL(m);y=e.runWebGLProgram(x,[r,i],"float32")}const b=Tt({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(y),b}const Dht={kernelName:xg,backendName:"webgl",kernelFunc:Rht};class Oht{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Mht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dataFormat==="channelsLast",l=e-1-t.padInfo.top,c=s-1-t.padInfo.left,h=o?1:2,d=o?2:3,p=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Fht{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,o=t.padInfo.top,l=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${l};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Lht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=e-1-t.padInfo.front,h=s-1-t.padInfo.top,d=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Pht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s,p=Zi(c),m=zn(r.shape,d,o,1,l,h,!1,p),y=new Oht(m);return e.runWebGLProgram(y,[r,i],"float32")}const zht={kernelName:f1,backendName:"webgl",kernelFunc:Pht};class Bht{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=ns(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,r=e-1-t.padInfo.top,i=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Vht(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s,p=Zi(h),m=zn(o,i.shape,l,1,c,d,!1,p);if(ct().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new Bht(m);return e.runWebGLProgram(b,[r,i],"float32",y)}else{const y=new Mht(m);return e.runWebGLProgram(y,[r,i],"float32")}}const Uht={kernelName:vg,backendName:"webgl",kernelFunc:Vht};function jht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c}=s,h=qo(r.shape,i.shape,o,c,l),d=new Aht(h);return e.runWebGLProgram(d,[r,i],"float32")}const Ght={kernelName:wg,backendName:"webgl",kernelFunc:jht};function Wht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,filterShape:c}=s,h=qo(r.shape,c,o,1,l),d=new Fht(h);return e.runWebGLProgram(d,[r,i],"float32")}const Hht={kernelName:p1,backendName:"webgl",kernelFunc:Wht};function qht(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:l,inputShape:c}=s,h=qo(c,i.shape,l,1,o),d=new Lht(h);return e.runWebGLProgram(d,[r,i],"float32")}const Kht={kernelName:m1,backendName:"webgl",kernelFunc:qht};const Xht=iu+`
  return cos(x);
`,Yht=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${pl}
  return result;
`,Zht=he({opSnippet:Xht,packedOpSnippet:Yht}),Jht={kernelName:dd,backendName:"webgl",kernelFunc:Zht};const Qht=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,tdt=he({opSnippet:Qht}),edt={kernelName:fd,backendName:"webgl",kernelFunc:tdt};class ndt{constructor(t,e,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,l,c,h]=t,[d]=e,[p,m]=s;this.outputShape=[d,p,m,h];const y=r==="bilinear"?1:0,[b,x]=[`${l-1}.0`,`${c-1}.0`],[w,S,T]=p>1?[`${(l-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[k,$,E]=m>1?[`${(c-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${$};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const sdt=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:l,method:c,extrapolationValue:h}=s,d=new ndt(r.shape,i.shape,l,c,h);return e.runWebGLProgram(d,[r,i,o],"float32")},rdt={kernelName:y1,backendName:"webgl",kernelFunc:sdt};var Xh;(function(n){n.Prod="*",n.Sum="+"})(Xh||(Xh={}));class hA{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Xh.Prod?"1.0":"0.0",l=s?o:`getX(${dA(i,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${c-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${c}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ie(i)} coords = getOutputCoords();
        int end = ${fA(i,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${fA(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${dA(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function dA(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function fA(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function jL(n,t,e,s,r,i){const o=t.shape.length,l=qe([s],o);let c=t;l!=null&&(c=cs({inputs:{x:t},backend:e,attrs:{perm:l}}));const h=sn(1,o)[0];if(h!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=c.shape[h];let p=Ls({inputs:{x:c},backend:e});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new hA(n,c.shape,!1,i),b=[[m]],x=p;p=e.runWebGLProgram(y,[p],p.dtype,b),e.disposeIntermediateTensorInfo(x)}if(r){const m=new hA(n,c.shape,r,i),y=p;p=e.runWebGLProgram(m,[p],p.dtype),e.disposeIntermediateTensorInfo(y)}if(l!=null){const m=Ko(l),y=cs({inputs:{x:p},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(c),y}return p}function idt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;return jL(Xh.Prod,r,e,i,o,l)}const odt={kernelName:g1,backendName:"webgl",kernelFunc:idt};function adt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;return jL(Xh.Sum,r,e,i,o,l)}const ldt={kernelName:Sg,backendName:"webgl",kernelFunc:adt};function cdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const c=e.readSync(r.dataId),h=e.readSync(i.dataId),d=CL(c,h,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,d)}else if(r.shape.length===2){const c=e.bufferSync(r),h=e.bufferSync(i),d=flt(c,h,o,l);return e.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const udt={kernelName:b1,backendName:"webgl",kernelFunc:cdt};class hdt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function ddt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s,l=r.shape[0],c=o==="NHWC"?r.shape[1]:r.shape[2],h=o==="NHWC"?r.shape[2]:r.shape[3],d=o==="NHWC"?r.shape[3]:r.shape[1],p=c*i,m=h*i,y=d/(i*i),b=o==="NHWC"?[l,p,m,y]:[l,y,p,m],x=new hdt(b,i,o);return e.runWebGLProgram(x,[r],r.dtype)}const fdt={kernelName:x1,backendName:"webgl",kernelFunc:ddt};class GL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ns(this.outputShape.length);const o=t.filterHeight,l=t.filterWidth,c=t.outChannels/t.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}}class WL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ns(this.outputShape.length);const o=t.outChannels/t.inChannels,l=t.padInfo.left,c=t.strideWidth,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,m=p;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<p;S++)y+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<p;S++)y+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const T=S*2;if(y+=`
          xC = xCCorner + ${T*h};
          `,c===1){if(T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,h===1&&T>0?y+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<p)){const k=l%2===0?Qw(h):h;h%2===0&&l%2===1||h%2!==0&&l%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:y+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):k===1?y+=`
                    xC${T+1} = xTexelC${T};
                    `:y+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<p&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<p&&(y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<p&&(y+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<p&&(y+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function pdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;let d=c;d==null&&(d=[1,1]),L(ts(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=zn(r.shape,i.shape,o,d,l,h,!0);let m;ct().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new WL(p):m=new GL(p);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[r,i],"float32",y)}const mdt={kernelName:Cg,backendName:"webgl",kernelFunc:pdt};class gdt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ydt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=e-1-t.padInfo.top,l=s-1-t.padInfo.left,c=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function bdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s,p=zn(r.shape,d,o,l,c,h,!0),m=new gdt(p);return e.runWebGLProgram(m,[r,i],"float32")}const xdt={kernelName:v1,backendName:"webgl",kernelFunc:bdt};function vdt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s,p=zn(d,i.shape,o,l,c,h,!0),m=new ydt(p);return e.runWebGLProgram(m,[r,i],"float32")}const wdt={kernelName:w1,backendName:"webgl",kernelFunc:vdt};class Sdt{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function Cdt(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],i=ft(s.shape),o=Tt({inputs:{x:s},backend:e,attrs:{shape:[i]}}),l=new Sdt(i),c=e.runWebGLProgram(l,[o],o.dtype),h=Tt({inputs:{x:c},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(c),h}const Tdt={kernelName:AR,backendName:"webgl",kernelFunc:Cdt};class kdt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:l,filterWidth:c,dilationHeight:h,dilationWidth:d}=t,{top:p,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function $dt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c}=s,h=Qd(r.shape,i.shape,o,l,"NHWC",c);let d;const p=new kdt(h);d=e.runWebGLProgram(p,[r,i],"float32");const m=Tt({inputs:{x:d},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(d),m}const Edt={kernelName:Tg,backendName:"webgl",kernelFunc:$dt};function Idt(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:l,idDims:c}=GS(r,i.length);HS(o.length,c,i);const{path:h,steps:d}=qS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=WS(y,c[w]);let k;KS(S)?k=i[w]:(k=cs({inputs:{x:i[w]},backend:e,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);we(k.shape,$)||(k=Tt({inputs:{x:k},backend:e,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=OC({inputs:{a:k,b:m},backend:e}),b.push(m))}x<p-1&&(h[x]>=0&&(m=F0({inputs:{x:m},backend:e,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&e.disposeIntermediateTensorInfo(x);return m}const Ndt={kernelName:S1,backendName:"webgl",kernelFunc:Idt};const Adt="return (x >= 0.0) ? x : (exp(x) - 1.0);",_dt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Rdt=he({opSnippet:Adt,packedOpSnippet:_dt}),Ddt={kernelName:md,backendName:"webgl",kernelFunc:Rdt};const Odt="return (b >= 0.0) ? a : a * (b + 1.0);",Mdt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Fdt=n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,i=ct().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(Mdt,s.shape,r.shape):new il(Odt,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],s.dtype)},Ldt={kernelName:C1,backendName:"webgl",kernelFunc:Fdt};const Pdt=`
  return vec4(equal(a, b));
`,zdt="return float(a == b);",Bdt=Vn({opSnippet:zdt,packedOpSnippet:Pdt,dtype:"bool",cpuKernelImpl:blt}),Vdt={kernelName:kg,backendName:"webgl",kernelFunc:Bdt};const Udt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${LS};
  float a1 = ${PS};
  float a2 = ${zS};
  float a3 = ${BS};
  float a4 = ${VS};
  float a5 = ${US};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,jdt=he({opSnippet:Udt}),Gdt={kernelName:gd,backendName:"webgl",kernelFunc:jdt};const Wdt=iu+`
  return exp(x);
`,Hdt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HL=he({opSnippet:Wdt,packedOpSnippet:Hdt,cpuKernelImpl:xlt,dtype:"float32"}),qdt={kernelName:yd,backendName:"webgl",kernelFunc:HL};function cw(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:i}=t,o=i.shape.length,l=i.shape.slice();let c=r;return r<0&&(L(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+r+1),l.splice(c,0,1),Tt({inputs:{x:i},backend:s,attrs:{shape:l}})}const Kdt={kernelName:$g,backendName:"webgl",kernelFunc:cw};const pA="return exp(x) - 1.0;",Xdt=he({opSnippet:pA,packedOpSnippet:pA,cpuKernelImpl:vlt}),Ydt={kernelName:bd,backendName:"webgl",kernelFunc:Xdt};class mA{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let l;if(t==="real")l="return real * expR - imag * expI;";else if(t==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function qL(n,t,e){const s=e.texData.get(n.dataId),r=ft(n.shape),i=n.shape[n.shape.length-1],o=r/i,l=Tt({inputs:{x:n},backend:e,attrs:{shape:[o,i]}}),c=l.shape,h=new mA("real",c,t),d=new mA("imag",c,t),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],m=e.runWebGLProgram(h,p,"float32"),y=e.runWebGLProgram(d,p,"float32"),b=ta({inputs:{real:m,imag:y},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y);const x=Tt({inputs:{x:b},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(b),x}function Zdt(n){const{inputs:t,backend:e}=n,{input:s}=t;return qL(s,!1,e)}const Jdt={kernelName:T1,backendName:"webgl",kernelFunc:Zdt};class Qdt{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function wf(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:i}=e;if(i=i||Wc(r),i==="string"){const o=tn(i,ft(s));return o.fill(r),t.makeTensorInfo(s,i,o)}else{const o=new Qdt(s,r),l=[[r]];return t.runWebGLProgram(o,[],i,l)}}const tft={kernelName:k1,backendName:"webgl",kernelFunc:wf};class eft{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const nft={kernelName:$1,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new eft(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}};const gA="return floor(x);",sft=he({opSnippet:gA,packedOpSnippet:gA,cpuKernelImpl:wlt}),rft={kernelName:xd,backendName:"webgl",kernelFunc:sft};const ift=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,oft=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,aft=Vn({opSnippet:ift,packedOpSnippet:oft,dtype:"int32"}),lft={kernelName:vd,backendName:"webgl",kernelFunc:aft};class cft{constructor(t){this.variableNames=["A"];const e=hs(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class uft{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=hs(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const hft={kernelName:t6,backendName:"webgl",kernelFunc:dft};let cc,qx=ct().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function dft(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[c,h]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,c],p=[h,c,i];if(l||o){const x=ct().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(cc==null||x!==qx)&&(qx=x,cc=document.createElement("canvas").getContext("2d",{willReadFrequently:qx})),cc.canvas.width=c,cc.canvas.height=h,cc.drawImage(r,0,0,c,h),r=cc.canvas}const m=e.makeTensorInfo(d,"int32");e.texData.get(m.dataId).usage=Zs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),r);const y=ct().getBool("WEBGL_PACK")?new uft(p):new cft(p),b=e.runWebGLProgram(y,[m],"int32");return e.disposeData(m.dataId),b}function fft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=Zi(d),w=zn(r.shape,i.shape,c,p,h,m,!1,x);let S;const T=[],k=o!=null,$=l!=null,E=y==="leakyrelu",N=()=>{const R=[r,i],D=(O,A)=>{if(A==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const z=Tt({inputs:{x:O},backend:e,attrs:{shape:[O.shape[0],1,1]}});return T.push(z),z}return O};if(k&&R.push(D(o,d)),$&&R.push(D(l,d)),E){const O=e.makeTensorInfo([],"float32",Wo(b,"float32"));R.push(O),T.push(O)}return R};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=VL({x:r,filter:i,convInfo:w,backend:e,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&ct().getBool("WEBGL_EXP_CONV")){const R=y?qh(y,!0):null,D=new BL(w,k,R,$,E),O=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=N();S=e.runWebGLProgram(D,A,"float32",O)}else if(ct().getBool("WEBGL_CONV_IM2COL"))S=UL({x:r,filter:i,convInfo:w,backend:e,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else{const R=y?qh(y,!1):null,D=new zL(w,k,R,$,E),O=N();S=e.runWebGLProgram(D,O,"float32")}const _=Tt({inputs:{x:S},backend:e,attrs:{shape:w.outShape}});return T.push(S),T.forEach(R=>e.disposeIntermediateTensorInfo(R)),_}const pft={kernelName:Nm,backendName:"webgl",kernelFunc:fft};function mft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),L(ts(c,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${x}'`);const w=zn(r.shape,i.shape,c,x,h,p,!0),S=ct().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,T=m?qh(m,S):null,k=[r,i],$=o!=null,E=l!=null,N=m==="leakyrelu";if($&&k.push(o),E&&k.push(l),N){const O=e.makeTensorInfo([],"float32",Wo(y,"float32"));k.push(O),b.push(O)}let _;S?_=new WL(w,$,T,E,N):_=new GL(w,$,T,E,N);const R=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],D=e.runWebGLProgram(_,k,"float32",R);return b.forEach(O=>e.disposeIntermediateTensorInfo(O)),D}const gft={kernelName:XR,backendName:"webgl",kernelFunc:mft};class yft{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Ie(s.length);let o=`
    int index;`;for(let l=0;l<this.sliceDim;l++)o+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function bft(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=r.shape,o=i[i.length-1],l=ft(s.shape),[c,h,d,p]=$S(s,r),m=Tt({inputs:{x:r},backend:e,attrs:{shape:[h,o]}}),y=Tt({inputs:{x:s},backend:e,attrs:{shape:[ft(s.shape)/d,d]}});if(e.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const S=e.readSync(r.dataId),T=e.bufferSync(s),k=Slt(S,T,s.dtype,h,o,d,p,s.shape,l);return e.makeTensorInfo(c,s.dtype,k.values)}const b=new yft(o,p,[h,d],s.shape),x=e.runWebGLProgram(b,[y,m],y.dtype),w=Tt({inputs:{x},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),w}const xft={kernelName:_R,backendName:"webgl",kernelFunc:bft};class vft{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=Ie(this.rank),r=wft(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function wft(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${e[r]}`);return s.join()}function KL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:l}=s,c=te(o,r.shape)[0];if(ct().get("DEBUG")){const T=e.readSync(i.dataId),k=r.shape[c];for(let $=0;$<T.length;++$){const E=T[$];L(E<=k-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${k-1}]`)}}const h=YS(r,i,c,l),d=ft(i.shape),p=[],m=Tt({inputs:{x:r},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=Tt({inputs:{x:i},backend:e,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(m),p.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const T=e.bufferSync(y),k=e.bufferSync(m),$=Clt(k,T,b);return p.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.makeTensorInfo(h.outputShape,$.dtype,$.values)}const x=new vft(m.shape,b),w=e.runWebGLProgram(x,[m,y],m.dtype);p.push(w);const S=Tt({inputs:{x:w},backend:e,attrs:{shape:h.outputShape}});return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),S}const Sft={kernelName:Ig,backendName:"webgl",kernelFunc:KL};const Cft="return float(a > b);",Tft=`
  return vec4(greaterThan(a, b));
`,kft=Vn({opSnippet:Cft,packedOpSnippet:Tft,cpuKernelImpl:Tlt,dtype:"bool"}),$ft={kernelName:Ng,backendName:"webgl",kernelFunc:kft};const Eft="return float(a >= b);",Ift=`
  return vec4(greaterThanEqual(a, b));
`,Nft=Vn({opSnippet:Eft,packedOpSnippet:Ift,dtype:"bool",cpuKernelImpl:klt}),Aft={kernelName:wd,backendName:"webgl",kernelFunc:Nft};function _ft(n){const{inputs:t,backend:e}=n,{input:s}=t;return qL(s,!0,e)}const Rft={kernelName:E1,backendName:"webgl",kernelFunc:_ft};const Dft="return float(!isnan(x) && !isinf(x));",Oft=he({opSnippet:Dft,dtype:"bool"}),Mft={kernelName:Cd,backendName:"webgl",kernelFunc:Oft};const Fft="return float(isinf(x));",Lft=he({opSnippet:Fft,dtype:"bool"}),Pft={kernelName:Td,backendName:"webgl",kernelFunc:Lft};const zft="return float(isnan(x));",Bft=he({opSnippet:zft,dtype:"bool"}),Vft={kernelName:kd,backendName:"webgl",kernelFunc:Bft};const Uft="return float(a < b);",jft=`
  return vec4(lessThan(a, b));
`,Gft=Vn({opSnippet:Uft,packedOpSnippet:jft,cpuKernelImpl:$lt,dtype:"bool"}),Wft={kernelName:_g,backendName:"webgl",kernelFunc:Gft};const Hft="return float(a <= b);",qft=`
  return vec4(lessThanEqual(a, b));
`,Kft=Vn({opSnippet:Hft,packedOpSnippet:qft,cpuKernelImpl:Elt,dtype:"bool"}),Xft={kernelName:Rg,backendName:"webgl",kernelFunc:Kft};function Yft(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=Ilt(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const Zft={kernelName:RR,backendName:"webgl",kernelFunc:Yft};const Jft=iu+`
  return x < 0.0 ? 0./0. : log(x);
`,Qft=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,tpt=he({opSnippet:Jft,packedOpSnippet:Qft,cpuKernelImpl:Nlt}),ept={kernelName:$d,backendName:"webgl",kernelFunc:tpt};const npt=iu+`
  return log(1.0 + x);
`,spt=he({opSnippet:npt}),rpt={kernelName:Ed,backendName:"webgl",kernelFunc:spt};const ipt="return float(a >= 1.0 && b >= 1.0);",opt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,apt=Vn({opSnippet:ipt,packedOpSnippet:opt,dtype:"bool"}),lpt={kernelName:Dg,backendName:"webgl",kernelFunc:apt};const cpt="return float(!(x >= 1.0));",upt=he({opSnippet:cpt}),hpt={kernelName:Og,backendName:"webgl",kernelFunc:upt};const dpt="return float(a >= 1.0 || b >= 1.0);",fpt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ppt=Vn({opSnippet:dpt,packedOpSnippet:fpt,dtype:"bool"}),mpt={kernelName:Mg,backendName:"webgl",kernelFunc:ppt};class gpt{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=e,l=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}class ypt{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,l=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}const bpt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:l,beta:c}=s,h=ct().getBool("WEBGL_PACK_NORMALIZATION")?new ypt(r.shape,i,o,l,c):new gpt(r.shape,i,o,l,c);return e.runWebGLProgram(h,[r],r.dtype)},xpt={kernelName:Fg,backendName:"webgl",kernelFunc:bpt};class vpt{constructor(t,e,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const wpt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:l,bias:c,alpha:h,beta:d}=s,p=new vpt(r.shape,l,c,h,d);return e.runWebGLProgram(p,[r,i,o],r.dtype)},Spt={kernelName:N1,backendName:"webgl",kernelFunc:wpt};function Cpt(n,t,e,s){const r=ft(t),o=ft(n.shape)/r,l=Tt({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=ml(l,n.dtype,"max",s),h=Tt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}function XL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,l=r.shape.length,c=te(i,r.shape);let h=c;const d=qe(h,l),p=d!=null,m=e.shouldExecuteOnCPU([r]);let y=r;if(p){if(m){const k=e.texData.get(y.dataId).values,$=new Array(l);for(let _=0;_<$.length;_++)$[_]=r.shape[d[_]];const E=RC(k,r.shape,r.dtype,d,$);y=e.makeTensorInfo($,r.dtype);const N=e.texData.get(y.dataId);N.values=E}else y=M0(r,d,e);h=sn(h.length,l)}Bn("max",h,l);const[b,x]=On(y.shape,h);let w=b;o&&(w=hn(b,c));let S;if(m){const k=e.texData.get(y.dataId).values,$=Alt(k,ft(x),w,r.dtype);S=e.makeTensorInfo(w,r.dtype);const E=e.texData.get(S.dataId);E.values=$}else S=Cpt(y,x,w,e);return p&&e.disposeIntermediateTensorInfo(y),S}const Tpt={kernelName:Lg,backendName:"webgl",kernelFunc:XL};const kpt=DC+`
  return max(a, b);
`,$pt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,Ept=Vn({opSnippet:kpt,packedOpSnippet:$pt,cpuKernelImpl:_lt}),Ipt={kernelName:Id,backendName:"webgl",kernelFunc:Ept};function Npt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;bf(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(ts(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Tr(r.shape,i,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))return Ls({inputs:{x:r},backend:e});const p=new Kh(d,"max",!1);return e.runWebGLProgram(p,[r],r.dtype)}const Apt={kernelName:Pg,backendName:"webgl",kernelFunc:Npt};function _pt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=[1,1,1],p=Yi(r.shape,i,o,d,l,h,c),m=new MC(p,"max",!1);return e.runWebGLProgram(m,[r],r.dtype)}const Rpt={kernelName:zg,backendName:"webgl",kernelFunc:_pt};class Dpt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,o=t.effectiveFilterWidth,l=i-1-t.padInfo.top,c=o-1-t.padInfo.left,h=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Opt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,m=h-1-t.padInfo.top,y=d-1-t.padInfo.left,b=c*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Mpt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Yi(o.shape,l,c,p,h,d),y=new MC(m,"max",!0),b=e.runWebGLProgram(y,[o],o.dtype),x=new Opt(m),w=e.runWebGLProgram(x,[r,b],o.dtype);return e.disposeIntermediateTensorInfo(b),w}const Fpt={kernelName:_1,backendName:"webgl",kernelFunc:Mpt};function Lpt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,l=i;bf([i,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=Tr(l.shape,c,h,1,d,p),y=!0,b=new Kh(m,"max",y),x=e.runWebGLProgram(b,[l],l.dtype),w=new Dpt(m),S=e.runWebGLProgram(w,[r,x],l.dtype);return e.disposeIntermediateTensorInfo(x),S}const Ppt={kernelName:A1,backendName:"webgl",kernelFunc:Lpt};function zpt(n,t,e,s){let r=new Kh(e,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new Kh(e,"max",!0,!0,t);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}const Bpt={kernelName:DR,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=t,c=e;L(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];L(ts(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Tr(s.shape,r,i,h,o),[p,m]=zpt(s,l,d,c);return[p,m]}};function Vpt(n,t,e,s){const r=ft(t),o=ft(n.shape)/r,l=Tt({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=ml(l,"float32","mean",s),h=Tt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}const Upt={kernelName:Bg,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:i}=t,o=e,l=s.shape.length,c=te(i,s.shape);let h=c;const d=qe(h,l),p=d!=null,m=o.shouldExecuteOnCPU([s]),y=[];let b=s;if(p){if(m){const $=o.texData.get(b.dataId).values,E=new Array(l);for(let R=0;R<E.length;R++)E[R]=s.shape[d[R]];const N=RC($,s.shape,s.dtype,d,E);b=o.makeTensorInfo(E,s.dtype);const _=o.texData.get(b.dataId);_.values=N}else b=M0(s,d,o);y.push(b),h=sn(h.length,l)}Bn("sum",h,l);const[x,w]=On(b.shape,h);let S=x;r&&(S=hn(x,c));const T=Vpt(b,w,S,o);for(const k of y)o.disposeIntermediateTensorInfo(k);return T}};function jpt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=te(i,r.shape);let h=c;const d=qe(h,l);let p=r;d!=null&&(p=cs({inputs:{x:r},backend:e,attrs:{perm:d}}),h=sn(h.length,r.shape.length)),Bn("min",h,l);const[m,y]=On(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"min",e);let S;if(o){const T=hn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const Gpt={kernelName:Vg,backendName:"webgl",kernelFunc:jpt};const Wpt=DC+`
  return min(a, b);
`,Hpt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,qpt=Vn({opSnippet:Wpt,packedOpSnippet:Hpt,cpuKernelImpl:Rlt}),Kpt={kernelName:Nd,backendName:"webgl",kernelFunc:qpt};class Xpt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((d,p)=>d[0]+t[p]+d[1]);const r=t.length,i=Ie(r),o=e.map(d=>d[0]).join(","),l=e.map((d,p)=>d[0]+t[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}class Ypt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((b,x)=>b[0]+t[x]+b[1]);const r=t.length,i=Ie(r),o=e.map(b=>b[0]).join(","),l=e.map((b,x)=>b[0]+t[x]).join(","),c=os("rc",r),h=os("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${c[r-2]} += 1;
        if(${c[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${c[r-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const Zpt=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:i}=e,o=ct().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ypt(s.shape,r,i):new Xpt(s.shape,r,i);return t.runWebGLProgram(o,[s],s.dtype)},Jpt={kernelName:Ug,backendName:"webgl",kernelFunc:Zpt};const Qpt=`if (b == 0.0) return NAN;
  return mod(a, b);`,tmt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+pl+`
  return result;
`,emt=Vn({opSnippet:Qpt,packedOpSnippet:tmt}),nmt={kernelName:Ad,backendName:"webgl",kernelFunc:emt};class smt{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const rmt=`
if (a == b) {
  return 1.0;
};
return a / b;`,imt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,YL=Vn({opSnippet:rmt,packedOpSnippet:imt,checkOutOfBounds:!0}),omt={kernelName:pd,backendName:"webgl",kernelFunc:YL};const yA="return a - b;",ZL=Vn({opSnippet:yA,packedOpSnippet:yA,supportsComplex:!0,cpuKernelImpl:Qlt}),amt={kernelName:Hd,backendName:"webgl",kernelFunc:ZL};function JL(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=te([i],r.shape),l=XL({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),c=hn(l.shape,o),h=Tt({inputs:{x:l},backend:e,attrs:{shape:c}}),d=ZL({inputs:{a:r,b:h},backend:e}),p=HL({inputs:{x:d},backend:e}),m=F0({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:!1}}),y=Tt({inputs:{x:m},backend:e,attrs:{shape:c}}),b=YL({inputs:{a:p,b:y},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}const lmt={kernelName:o0,backendName:"webgl",kernelFunc:JL};function cmt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:l}=s,c=l?r:JL({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),h=c.shape[0],d=c.shape[1],p=new smt(h,d,i),m=[[o]],y=e.runWebGLProgram(p,[c],"int32",m);return l||e.disposeIntermediateTensorInfo(c),y}const umt={kernelName:OR,backendName:"webgl",kernelFunc:cmt};const hmt=$r+`
  return -x;
`,dmt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function fmt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId),[o,l]=Olt(i.values,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,o)}let r;return ct().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Ao(s.shape,dmt):r=new ii(s.shape,hmt),e.runWebGLProgram(r,[s],s.dtype)}const pmt={kernelName:jg,backendName:"webgl",kernelFunc:fmt};const mmt=vS;function gmt(n){Ys("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),{selectedIndices:p}=mmt(h,d,o,l,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const ymt={kernelName:R1,backendName:"webgl",kernelFunc:gmt};const bmt=wS;function xmt(n){Ys("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s,d=e.readSync(r.dataId),p=e.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=bmt(d,p,o,l,c,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const vmt={kernelName:D1,backendName:"webgl",kernelFunc:xmt};const wmt=SS;function Smt(n){Ys("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s,d=e.readSync(r.dataId),p=e.readSync(i.dataId),m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=wmt(d,p,m,y,b,x);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const Cmt={kernelName:O1,backendName:"webgl",kernelFunc:Smt};class Tmt{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const kmt=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:l,offValue:c}=s,h=ft(r.shape),d=new Tmt(h,o,l,c),p=Tt({inputs:{x:r},backend:e,attrs:{shape:[h]}}),m=e.runWebGLProgram(d,[p],i);e.disposeIntermediateTensorInfo(p);const y=[...r.shape,o],b=Tt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),b},$mt={kernelName:Hg,backendName:"webgl",kernelFunc:kmt};function ng(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const r=vf({inputs:{input:s},backend:e}),i=ng({inputs:{x:r},backend:e}),o=L0({inputs:{input:s},backend:e}),l=ng({inputs:{x:o},backend:e}),c=ta({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return wf({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const Emt={kernelName:c0,backendName:"webgl",kernelFunc:ng};function QL(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=vf({inputs:{input:s},backend:e}),i=QL({inputs:{x:r},backend:e}),o=L0({inputs:{input:s},backend:e}),l=ng({inputs:{x:o},backend:e}),c=ta({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return wf({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const Imt={kernelName:Wg,backendName:"webgl",kernelFunc:QL};function Nmt(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return cw({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(d=>{t1(i,d.shape,"All tensors passed to stack must have matching shapes"),L(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=t.map(d=>{const p=cw({inputs:{input:d},backend:e,attrs:{dim:r}});return l.push(p),p}),h=PL({inputs:c,backend:e,attrs:{axis:r}});return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const Amt={kernelName:qg,backendName:"webgl",kernelFunc:Nmt};class _mt{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,d)=>h[0]+t[d]+h[1]);const r=t.length,i=Ie(r),o=e.map(h=>h[0]).join(","),l=e.map((h,d)=>h[0]+t[d]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}class Rmt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((x,w)=>x[0]+t[w]+x[1]);const r=t.length,i=Ie(r),o=e.map(x=>x[0]).join(","),l=e.map((x,w)=>x[0]+t[w]).join(","),c=os("rc",r),h=os("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${c[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${c[r-2]} += 1;
       if(${c[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${c[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=r===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const tP=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;if(ft(r.shape)===0){const h=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return wf({backend:e,attrs:{shape:h,value:o,dtype:r.dtype}})}const l=ct().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rmt(r.shape,i,o):new _mt(r.shape,i,o),c=[[o]];return e.runWebGLProgram(l,[r],r.dtype,c)},Dmt={kernelName:Kg,backendName:"webgl",kernelFunc:tP};const Omt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Mmt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+pl+`
  return result;
`,Fmt=Vn({opSnippet:Omt,packedOpSnippet:Mmt}),Lmt={kernelName:Rd,backendName:"webgl",kernelFunc:Fmt};function Pmt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=[],h=te(i,r.shape);let d=h;const p=qe(d,l);let m=r;p!=null&&(m=cs({inputs:{x:r},backend:e,attrs:{perm:p}}),d=sn(d.length,l),c.push(m)),Bn("prod",d,l);let y;if(e.shouldExecuteOnCPU([m])){const b=e.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:S}=Flt(m.shape,m.dtype,b,d);y=e.makeTensorInfo(w,S,x)}else{const[b,x]=On(m.shape,d),w=ft(x),S=Tt({inputs:{x:m},backend:e,attrs:{shape:[-1,w]}}),T=H1(r.dtype),k=ml(S,T,"prod",e);y=Tt({inputs:{x:k},backend:e,attrs:{shape:b}}),c.push(S),c.push(k)}if(o){c.push(y);const b=hn(y.shape,h);y=Tt({inputs:{x:y},backend:e,attrs:{shape:b}})}return c.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const zmt={kernelName:Yg,backendName:"webgl",kernelFunc:Pmt};function Bmt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:l}=s,c=r.map(S=>e.readSync(S.dataId)),h=r.map(S=>S.shape),d=e.readSync(i.dataId),p=e.readSync(o.dataId),[m,y,b]=Llt(c,h,d,i.shape,i.dtype,p,o.shape,l),x=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),w=e.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const Vmt={kernelName:MR,backendName:"webgl",kernelFunc:Bmt};function Umt(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),[h,d]=Plt(o,s.shape,s.dtype,l,r.shape,c,i.shape),p=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const jmt={kernelName:FR,backendName:"webgl",kernelFunc:Umt};function Gmt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=t,{rowPartitionTypes:c}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),p=e.readSync(o.dataId),m=l.map(w=>e.readSync(w.dataId)),y=l.map(w=>w.shape),[b,x]=zlt(h,r.shape,d,i.shape,i.dtype,p,o.shape,m,y,c);return e.makeTensorInfo(b,i.dtype,x)}const Wmt={kernelName:LR,backendName:"webgl",kernelFunc:Gmt};const eP=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:i,dtype:o}=e,l=Blt(s,r,i,o);return t.makeTensorInfo([l.length],o,l)},Hmt={kernelName:M1,backendName:"webgl",kernelFunc:eP};const qmt="return 1.0 / x;",Kmt=he({opSnippet:qmt}),Xmt={kernelName:Dd,backendName:"webgl",kernelFunc:Kmt};const Ymt=$r+`
  return (x < 0.0) ? 0.0 : x;
`,Zmt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Jmt=he({opSnippet:Ymt,packedOpSnippet:Zmt}),Qmt={kernelName:Od,backendName:"webgl",kernelFunc:Jmt};const tgt=$r+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,egt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ngt=he({opSnippet:tgt,packedOpSnippet:egt}),sgt={kernelName:Md,backendName:"webgl",kernelFunc:ngt};class rgt{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class igt{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function ogt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s,[c,h]=l,d=ct().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new igt(r.shape,c,h,i,o):new rgt(r.shape,c,h,i,o);return e.runWebGLProgram(d,[r],"float32")}const agt={kernelName:Qg,backendName:"webgl",kernelFunc:ogt};class lgt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,l]=t,c=[s&&o>1?r-1:r,s&&l>1?i-1:i],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function cgt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,l=new lgt(i.shape,r.shape,o);return e.runWebGLProgram(l,[i],i.dtype)}const ugt={kernelName:P1,backendName:"webgl",kernelFunc:cgt};class hgt{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class dgt{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function fgt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s,[c,h]=l,d=ct().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dgt(r.shape,c,h,i,o):new hgt(r.shape,c,h,i,o);return e.runWebGLProgram(d,[r],r.dtype)}const pgt={kernelName:Jg,backendName:"webgl",kernelFunc:fgt};class mgt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,l]=t,c=[s&&o>1?r-1:r,s&&l>1?i-1:i],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function ggt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,l=new mgt(i.shape,r.shape,o);return e.runWebGLProgram(l,[i],i.dtype)}const ygt={kernelName:L1,backendName:"webgl",kernelFunc:ggt};class bgt{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=l=>e.indexOf(l)!==-1&&t[l]!==1?`${t[l]} - coords[${l}] - 1`:`coords[${l}]`,i=t.map((l,c)=>r(c)).join(","),o=Ie(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class xgt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=os("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,l=Ie(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(r.slice())};
          if(${i}){
            result.g = ${h(r.slice())};
          }
          if(${o}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=t.map((T,k)=>y(k,b)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function y(b,x){return e.indexOf(b)!==-1&&t[b]!==1?`${t[b]} - ${x[b]} - 1`:`${x[b]}`}}}function vgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s,o=r.shape.length,l=te(i,r.shape);if(o===0)return Ls({inputs:{x:r},backend:e});const c=ct().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xgt(r.shape,l):new bgt(r.shape,l);return e.runWebGLProgram(c,[r],r.dtype)}const wgt={kernelName:t0,backendName:"webgl",kernelFunc:vgt};class Sgt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const Cgt={kernelName:W1,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,l=e,c=new Sgt(s.shape,i),[h,d]=OS(o,s.shape[1],s.shape[2]),p=[[h,d,Math.sin(r),Math.cos(r)]];return l.runWebGLProgram(c,[s],s.dtype,p)}};const Tgt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,kgt=he({opSnippet:Tgt}),$gt={kernelName:Fd,backendName:"webgl",kernelFunc:kgt};const Egt="return inversesqrt(x);",Igt=he({opSnippet:Egt,cpuKernelImpl:Vlt}),Ngt={kernelName:Ld,backendName:"webgl",kernelFunc:Igt};class FC{constructor(t,e,s,r,i,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const h=Ie(i.length),d=Ie(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=e>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class Agt{constructor(t,e,s,r,i,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const h=Ie(i.length),d=Ie(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=e>1?"strides[j]":"strides",T=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function _gt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(i,r,o),m=[p/h,h];if(p===0)return e.makeTensorInfo(o,r.dtype);const y=Tt({inputs:{x:r},backend:e,attrs:{shape:[c,l]}}),b=Tt({inputs:{x:i},backend:e,attrs:{shape:[c,h]}}),x=e.makeTensorInfo([],"float32",new Float32Array([0]));let w;ct().getBool("WEBGL_PACK")?w=new Agt(c,l,y.shape.length,b.shape.length,d,m):w=new FC(c,l,y.shape.length,b.shape.length,d,m);const S=e.runWebGLProgram(w,[b,y,x],b.dtype),T=Tt({inputs:{x:S},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(x),T}const Rgt={kernelName:PR,backendName:"webgl",kernelFunc:_gt};class Dgt{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,l=ct().getNumber("WEBGL_VERSION")===2?i:o,c=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function Ogt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,l=new Dgt(r.shape[0],r.shape[1],i.shape[1],o),c=[[r.shape[1]]];return e.runWebGLProgram(l,[r,i],"int32",c)}const Mgt={kernelName:BR,backendName:"webgl",kernelFunc:Ogt};class Fgt{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],h=[];for(let d=0;d<e.length;d++)h.push(`${l[d]}`),d<t&&c.push(`${l[d]}`);r=c.join(),i=h.join()}const o=Ie(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function Lgt(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t,o=new Fgt(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[s,r,i],Ms(r.dtype,i.dtype))}const Pgt={kernelName:e0,backendName:"webgl",kernelFunc:Lgt};const zgt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${x0};
  float scale = ${v0};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Bgt=he({opSnippet:zgt}),Vgt={kernelName:Pd,backendName:"webgl",kernelFunc:Bgt};const Ugt=iu+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,jgt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ggt=he({opSnippet:Ugt,packedOpSnippet:jgt,cpuKernelImpl:jlt}),Wgt={kernelName:Ud,backendName:"webgl",kernelFunc:Ggt};const Hgt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,qgt=he({opSnippet:Hgt}),Kgt={kernelName:Vd,backendName:"webgl",kernelFunc:qgt};const Xgt=iu+`
  return sin(x);
`,Ygt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${pl}
  return result;
`,Zgt=he({opSnippet:Xgt,packedOpSnippet:Ygt}),Jgt={kernelName:zd,backendName:"webgl",kernelFunc:Zgt};const Qgt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,t0t=he({opSnippet:Qgt}),e0t={kernelName:Bd,backendName:"webgl",kernelFunc:t0t};const n0t=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,s0t=he({opSnippet:n0t}),r0t={kernelName:jd,backendName:"webgl",kernelFunc:s0t};const i0t=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;L(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((S,T)=>S*T),c=[[0,0]];c.push(...o);for(let S=1+i.length;S<r.shape.length;++S)c.push([0,0]);const h=[],d=tP({inputs:{x:r},backend:e,attrs:{paddings:c,constantValue:0}}),p=rf(d.shape,i,l,!1),m=of(p.length,i.length,!1),y=af(d.shape,i,l,!1),b=Tt({inputs:{x:d},backend:e,attrs:{shape:p}}),x=cs({inputs:{x:b},backend:e,attrs:{perm:m}}),w=Tt({inputs:{x},backend:e,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(S=>e.disposeIntermediateTensorInfo(S)),w},o0t={kernelName:r0,backendName:"webgl",kernelFunc:i0t};function a0t(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=e.readSync(s.dataId),c=e.readSync(r.dataId),h=e.readSync(i.dataId),d=e.readSync(o.dataId)[0],[p,m,y,b,x]=Wlt(l,s.shape,s.dtype,c,r.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,p),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),e.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const l0t={kernelName:VR,backendName:"webgl",kernelFunc:a0t};function c0t(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(r.dataId)),l=e.readSync(s.dataId),c=Array.from(e.readSync(i.dataId)),[h,d,p]=Hlt(l,s.shape,s.dtype,o,c);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const u0t={kernelName:UR,backendName:"webgl",kernelFunc:c0t};function h0t(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),[h,d]=kL(o,s.shape,s.dtype,l,c,!0);return e.makeTensorInfo(d,s.dtype,h)}const d0t={kernelName:jR,backendName:"webgl",kernelFunc:h0t};function f0t(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),[h,d]=kL(o,s.shape,s.dtype,l,c);return e.makeTensorInfo(d,s.dtype,h)}const p0t={kernelName:GR,backendName:"webgl",kernelFunc:f0t};function m0t(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=cl(i,r,l),y=!1;if(i.dtype==="string"){const S=e.bufferSync(r),T=e.bufferSync(i),k=Lo(e.readSync(o.dataId)[0]),$=Ult(S,T,l,m,d,h,c,p,k,y);return e.makeTensorInfo(l,$.dtype,$.values)}const b=new FC(h,c,r.shape.length,i.shape.length,p,[m,1],y),x=e.runWebGLProgram(b,[i,r,o],i.dtype),w=Tt({inputs:{x},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(x),w}const g0t={kernelName:WR,backendName:"webgl",kernelFunc:m0t};function y0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,l=te(o,r.shape)[0],c=XS(r,i,l),h=r.shape.length,d=new Array(h).fill(0),p=r.shape.slice();return c.map(m=>{const y=[...p];y[l]=m;const b=ou({inputs:{x:r},backend:e,attrs:{begin:d,size:y}});return d[l]+=m,b})}const b0t={kernelName:i0,backendName:"webgl",kernelFunc:y0t};const bA="return sqrt(x);",x0t=he({opSnippet:bA,packedOpSnippet:bA,cpuKernelImpl:qlt}),v0t={kernelName:Gd,backendName:"webgl",kernelFunc:x0t};const w0t="return x * x;",S0t=he({opSnippet:w0t}),C0t={kernelName:z1,backendName:"webgl",kernelFunc:S0t};const xA="return (a - b) * (a - b);",T0t=Vn({opSnippet:xA,packedOpSnippet:xA}),k0t={kernelName:Wd,backendName:"webgl",kernelFunc:T0t};function $0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=e.readSync(r.dataId),o=qi(i),l=Klt(o,"string",s);return e.makeTensorInfo(r.shape,"string",l)}const E0t={kernelName:B1,backendName:"webgl",kernelFunc:$0t};function I0t({inputs:n,attrs:t,backend:e}){const{x:s}=n,r=$r+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new ii(s.shape,r);return e.runWebGLProgram(i,[s],s.dtype)}const N0t={kernelName:Yd,backendName:"webgl",kernelFunc:I0t};class A0t{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Ie(s.length),o=Ie(s.length);let l="";if(r===1)l="coords * strides + begin";else{let c=0;l=s.map((h,d)=>(c++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${c-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}function _0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=_S(r.shape,i,o,l,c,h,d,p,m);let E;if(x)E=Tt({inputs:{x:r},backend:e,attrs:{shape:b}});else if(w||S){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const _=IS(T,k,$),R=ou({inputs:{x:r},backend:e,attrs:{begin:T,size:_}});E=Tt({inputs:{x:R},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(R)}else if(e.shouldExecuteOnCPU([r])){const R=e.readSync(r.dataId),D=Qt(r.shape,r.dtype,R),O=Xlt(y,D,$,T);E=e.makeTensorInfo(b,r.dtype,O.values)}else{const R=new A0t(T,$,y);E=e.runWebGLProgram(R,[r],r.dtype)}const N=Tt({inputs:{x:E},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(E),N}const R0t={kernelName:V1,backendName:"webgl",kernelFunc:_0t};function D0t(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=t,m=e.readSync(d.dataId),y=e.readSync(p.dataId),[b,x]=Ylt(m,y,r,i,o,l,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",x)]}const O0t={kernelName:HR,backendName:"webgl",kernelFunc:D0t};function M0t(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=e.readSync(i.dataId),c=e.readSync(o.dataId)[0],[h,d,p]=Zlt(l,c,r),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const F0t={kernelName:qR,backendName:"webgl",kernelFunc:M0t};function L0t(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),l=Jlt(o,r);return e.makeTensorInfo(i.shape,"int32",l)}const P0t={kernelName:KR,backendName:"webgl",kernelFunc:L0t};const z0t="return tan(x);",B0t=he({opSnippet:z0t}),V0t={kernelName:qd,backendName:"webgl",kernelFunc:B0t};const U0t=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,j0t=he({opSnippet:U0t}),G0t={kernelName:Kd,backendName:"webgl",kernelFunc:j0t};function W0t(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:r,indices:i,updates:o}=t,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(o,i,r.shape),m=[p/h,h];if(p===0)return e.makeTensorInfo(r.shape,i.dtype);const y=Tt({inputs:{x:i},backend:e,attrs:{shape:[c,l]}}),b=Tt({inputs:{x:o},backend:e,attrs:{shape:[c,h]}}),x=Tt({inputs:{x:r},backend:e,attrs:{shape:m}}),w=new FC(c,l,y.shape.length,b.shape.length,d,m,!1,!0),S=e.runWebGLProgram(w,[b,y,x],x.dtype),T=Tt({inputs:{x:S},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(S),T}const H0t={kernelName:zR,backendName:"webgl",kernelFunc:W0t};class q0t{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*e[o];this.outputShape=s,this.rank=s.length;const r=Ie(this.rank),i=K0t(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function K0t(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}function nP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const c=e.readSync(r.dataId),h=r.dtype==="string"?c.map(m=>Lo(m)):c,d=Qt(r.shape,r.dtype,h),p=tct(d,i);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new q0t(r.shape,i);return e.runWebGLProgram(o,[r],r.dtype)}const X0t={kernelName:Xd,backendName:"webgl",kernelFunc:nP};class Y0t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Z0t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function ka(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function vA(n){let t=1;for(;t<n;)t*=2;return t}function J0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s,l=ct().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=ct().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(e.shouldExecuteOnCPU([r])||d<l||i>c){const O=e.readSync(r.dataId),[A,z]=ect(O,h,r.dtype,i,o);return[e.makeTensorInfo(A.shape,A.dtype,A.values),e.makeTensorInfo(z.shape,z.dtype,z.values)]}if(i===0)return h[h.length-1]=0,[e.makeTensorInfo(h,r.dtype,[]),e.makeTensorInfo(h,"int32",[])];if(d===1)return[r,wf({attrs:{shape:h,dtype:"int32",value:0},backend:e})];const p=e.texData.get(r.dataId),m=p!==null&&p.isPacked,y=m?e.unpackTensor(r):r,x=ft(h)/d,w=Tt({inputs:{x:y},attrs:{shape:[x,d]},backend:e});m&&ka(e,y);const S=vA(i),T=vA(d);let k=null;const $=()=>k===null?[w,w]:[w,k],E=(O,A,z)=>{const q=$(),W=new Y0t(z),P=[[d],[k===null?1:0],[Number.NEGATIVE_INFINITY],[O],[A]],V=k;k=e.runWebGLProgram(W,q,"int32",P),ka(e,V)};for(let O=1;O<S;O*=2){const A=O*2;for(let z=O;z>=1;z/=2)E(A,z,[x,T])}for(let O=T;O>S;O/=2){const A=$(),z=new Z0t([x,O/2]),W=[[d],[k===null?1:0],[S]],X=k;k=e.runWebGLProgram(z,A,"int32",W),ka(e,X);const P=S/2,V=P*2;for(let G=P;G>=1;G/=2)E(V,G,k.shape)}let N=k;k=ou({inputs:{x:k},backend:e,attrs:{begin:0,size:[x,i]}}),ka(e,N);let _=KL({inputs:{x:w,indices:k},backend:e,attrs:{axis:1,batchDims:1}});ka(e,w);const R=h.slice(0,-1);R.push(i),N=k,k=Tt({inputs:{x:k},attrs:{shape:R},backend:e}),ka(e,N);const D=_;return _=Tt({inputs:{x:_},attrs:{shape:R},backend:e}),ka(e,D),[_,k]}const Q0t={kernelName:U1,backendName:"webgl",kernelFunc:J0t};class tyt{constructor(t,e,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const l=s==="nearest"?1:2;let c;switch(r){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function eyt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=s,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=new tyt(p,m,o,l,c,w);return e.runWebGLProgram(S,[r,i],"float32")}const nyt={kernelName:j1,backendName:"webgl",kernelFunc:eyt};function syt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;bf(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:l,outputShape:c,indices:h}=nct(o,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const ryt={kernelName:G1,backendName:"webgl",kernelFunc:syt};function iyt(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,l=o.shape.length,c=r.shape[i],h=new Array(l-1);let d=0;for(let x=0;x<l;x++)x!==i&&(h[d++]=o.shape[x]);const p=[],m=new Array(l).fill(0),y=o.shape.slice();y[i]=1;const b=new Array(c);for(let x=0;x<b.length;x++){m[i]=x;const w=ou({inputs:{x:o},backend:e,attrs:{begin:m,size:y}}),S=Tt({inputs:{x:w},backend:e,attrs:{shape:h}});b[x]=S,p.push(w)}return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const oyt={kernelName:a0,backendName:"webgl",kernelFunc:iyt};class ayt{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,i=t.inSize,o=t.numSegments,l=o*Math.ceil(i/s);this.outputShape=[r,l];const c="0.0",h="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function lyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s,l=r.shape.length,c=[];let h=0;const d=qe([h],l);let p=r;d!=null&&(p=cs({inputs:{x:r},backend:e,attrs:{perm:d}}),c.push(p),h=sn(1,l)[0]);const m=LO(p.shape,h,o),y=ft([p.shape[h]]),b=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,y]}});c.push(b);const x=H1(r.dtype),w=($,E,N,_,R)=>{const D=$.shape[0],O=$.shape[1],A=FO(O,R),z={windowSize:A,inSize:O,batchSize:D,numSegments:R},q=new ayt(z,E),W=e.compileAndRun(q,[$,N],_);if(c.push(W),W.shape[1]===R)return W;const X=eP({backend:e,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),P=nP({inputs:{x:X},backend:e,attrs:{reps:[O/A]}});return c.push(X),c.push(P),w(W,E,P,_,R)},S=w(b,"unsortedSegmentSum",i,x,o),T=Tt({inputs:{x:S},backend:e,attrs:{shape:m}});let k=T;if(d!=null){c.push(T);const $=Ko(d);k=cs({inputs:{x:k},backend:e,attrs:{perm:$}})}return c.forEach($=>e.disposeIntermediateTensorInfo($)),k}const cyt={kernelName:l0,backendName:"webgl",kernelFunc:lyt};const uyt=[qct,Xct,Jct,eut,sut,out,lut,uut,put,gut,xut,Sut,kut,Nut,Rut,Out,Fut,But,Uut,Gut,Kut,eht,sht,aht,cht,mht,yht,wht,Act,Tht,Nht,Dht,zht,Uht,Ght,Hht,Kht,Jht,edt,rdt,odt,ldt,udt,fdt,mdt,xdt,wdt,Tdt,Edt,Ndt,Ddt,Ldt,Vdt,Gdt,qdt,Kdt,Ydt,Jdt,tft,nft,rft,lft,hft,pft,gft,xft,Sft,$ft,Aft,Nct,Rft,Eht,Mft,Pft,Vft,Rct,Wft,Xft,Zft,ept,rpt,lpt,hpt,mpt,xpt,Spt,Tpt,Ipt,Apt,Rpt,Fpt,Ppt,Bpt,Upt,Gpt,Kpt,Jpt,nmt,umt,Mct,pmt,ymt,vmt,Cmt,hht,$mt,Imt,Amt,Dmt,Lmt,Oct,zmt,Vmt,jmt,Wmt,Hmt,dht,omt,Xmt,Qmt,sgt,Lct,agt,ugt,pgt,ygt,wgt,Cgt,$gt,Ngt,Rgt,Mgt,Pgt,Vgt,Wgt,Kgt,Jgt,e0t,Qut,lmt,r0t,o0t,l0t,u0t,d0t,p0t,g0t,b0t,v0t,C0t,k0t,E0t,N0t,R0t,O0t,F0t,P0t,amt,Gct,V0t,G0t,H0t,X0t,Q0t,nyt,Wct,ryt,oyt,cyt,Emt];for(const n of uyt)YR(n);const wA=(n,t,e=252)=>{if(!n||n.length<t+1)return[];const s=[];for(let i=1;i<n.length;i++)s.push((n[i]-n[i-1])/n[i-1]);const r=[];for(let i=t-1;i<s.length;i++){const o=s.slice(i-t+1,i+1),l=o.reduce((d,p)=>d+p,0)/t,c=o.reduce((d,p)=>d+Math.pow(p-l,2),0)/t,h=Math.sqrt(c)*Math.sqrt(e);r.push(h)}return r},hyt=(n,t=0,e=252)=>{if(!n||n.length===0)return 0;const s=n.map(l=>l-t/e),r=s.reduce((l,c)=>l+c,0)/n.length;if(n.length<2)return 0;const i=s.reduce((l,c)=>l+Math.pow(c-r,2),0)/n.length,o=Math.sqrt(i);return o===0?0:r/o*Math.sqrt(e)},dyt=(n,t=0,e=252)=>{if(!n||n.length===0)return 0;const s=n.reduce((c,h)=>c+h,0)/n.length,r=t/e,o=n.map(c=>c<r?Math.pow(c-r,2):0).reduce((c,h)=>c+h,0)/n.length,l=Math.sqrt(o);return l===0?0:(s-r)/l*Math.sqrt(e)},fyt=n=>{if(!n||n.length<2)return 0;let t=n[0],e=0;for(let s=1;s<n.length;s++){n[s]>t&&(t=n[s]);const r=(t-n[s])/t;r>e&&(e=r)}return e*100},pyt=(n,t=7,e=21)=>{const s=wA(n,t),r=wA(n,e);if(s.length===0||r.length===0)return 1;const i=s[s.length-1],o=r[r.length-1];return o===0?1:i/o},myt=(n,t=1e-4,e=2e-4)=>{const s=t+e;return n.map(r=>Math.abs(r)<1e-7?0:r-s)},gyt=async()=>{try{await jI("webgl"),await I6()}catch{console.warn("WebGL failed, falling back to CPU. Performance will be reduced."),await jI("cpu")}};gyt();const SA=3e5,yyt=n=>new Promise((t,e)=>{const s=new Worker(new URL(""+new URL("assets/brain.worker-DDZKTW9C.js",import.meta.url).href,import.meta.url),{type:"module"});let r=!1;const i=setTimeout(()=>{r||(r=!0,s.terminate(),e(new Error(`Neural Training Timed Out (${SA/1e3}s Limit). Try again or use Fast Mode.`)))},SA);if(s.onmessage=o=>{const{type:l,data:c}=o.data;l==="TRAIN_SUCCESS"?r||(r=!0,clearTimeout(i),s.terminate(),t(c)):l==="ERROR"&&(r||(r=!0,clearTimeout(i),s.terminate(),e(new Error(c))))},s.onerror=o=>{r||(r=!0,clearTimeout(i),s.terminate(),e(o))},n.historicalPrices?.length<gr+20){clearTimeout(i),e(new Error(`Insufficient price history for neural training. Got ${n.historicalPrices?.length||0} bars, need ${gr+20}.`));return}s.postMessage({type:"TRAIN_AND_PREDICT",data:n})}),gr=45,uw=6,oh=(n,t,e)=>(n-t)/(e||1),byt=n=>{const t=[...n].sort((o,l)=>o-l),e=t[Math.floor(t.length/2)],s=t[Math.floor(t.length*.25)],i=t[Math.floor(t.length*.75)]-s||1;return{median:e,iqr:i}},xyt=n=>{const{prices:t,rsi:e,macd:s,atr:r,roc:i,vol:o}=n,l=Math.min(t.length,e.length,s.length,r?.length||0,i?.length||0,o?.length||0),c=t.slice(-l),h=e.slice(-l),d=s.slice(-l),p=r.slice(-l),m=i.slice(-l),y=o.slice(-l),b=[];return[h,d,p].forEach(x=>{const w=x.reduce((T,k)=>T+k,0)/x.length,S=Math.sqrt(x.reduce((T,k)=>T+Math.pow(k-w,2),0)/x.length)||1;b.push({mean:w,std:S})}),[m,y].forEach(x=>{const{median:w,iqr:S}=byt(x);b.push({median:w,iqr:S})}),[{base:c[0]},...b]},vyt=(n,t,e)=>{const s=t.prices[0],r=[];for(let c=0;c<gr;c++)r.push([(t.prices[c]-s)/(s||1),oh(t.rsi[c],e[1].mean,e[1].std),oh(t.macd[c],e[2].mean,e[2].std),oh(t.atr[c],e[3].mean,e[3].std),oh(t.roc[c],e[4].mean,e[4].std),oh(t.vol[c],e[5].mean,e[5].std)]);const i=c9([r],[1,gr,uw]),o=n.predict(i),l=o.dataSync()[0];return i.dispose(),o.dispose(),l*s+s},wyt=n=>{n&&n.dispose()},Syt=async(n,t,e,s)=>{if(n)try{if(t.weightData instanceof ArrayBuffer){const i=new Uint8Array(t.weightData);let o="";for(let l=0;l<i.byteLength;l++)o+=String.fromCharCode(i[l]);t.weightData=btoa(o)}const{error:r}=await ms.from("neural_models").upsert([{user_id:n.id,name:e,model_json:t,accuracy:s,created_at:new Date().toISOString()}],{onConflict:"user_id, name"});if(r)throw r;return!0}catch(r){return console.error("Cloud Artifact Save Error:",r),!1}},Cyt=async(n,t)=>{if(!n)return null;try{const{data:e,error:s}=await ms.from("neural_models").select("model_json").eq("name",t).order("created_at",{ascending:!1}).limit(1).maybeSingle();if(s||!e)return null;const r=e.model_json;if(typeof r.weightData=="string"){const l=atob(r.weightData),c=new Uint8Array(l.length);for(let h=0;h<l.length;h++)c[h]=l.charCodeAt(h);r.weightData=c.buffer}else Array.isArray(r.weightData)&&(r.weightData=new Uint8Array(r.weightData).buffer);const i=await TQ(A7(r)),o=i.inputs[0].shape;return o[1]!==gr||o[2]!==uw?(console.warn(`[Brain] Model shape mismatch detected (${o[1]}x${o[2]} vs ${gr}x${uw}). Discarding legacy model.`),i.dispose(),null):i}catch(e){return console.error("Cloud Model Load Error:",e),null}},kh={BTC:"bitcoin",ETH:"ethereum",SOL:"solana",XRP:"ripple",ADA:"cardano",DOGE:"dogecoin",AVAX:"avalanche-2",DOT:"polkadot",MATIC:"matic-network",LINK:"chainlink",LTC:"litecoin",SHIB:"shiba-inu",TRX:"tron",UNI:"uniswap",ATOM:"cosmos",XMR:"monero",ETC:"ethereum-classic",XLM:"stellar",BCH:"bitcoin-cash",FIL:"filecoin",APT:"aptos",QNT:"quant-network",NEAR:"near",ARB:"arbitrum",VET:"vechain",MKR:"maker",AAVE:"aave",GRT:"the-graph",ALGO:"algorand",AXS:"axie-infinity",SAND:"the-sandbox",EOS:"eos",MANA:"decentraland",THETA:"theta-token",EGLD:"elrond-erd-2",FTM:"fantom",XTZ:"tezos",FLOW:"flow",IMX:"immutable-x",SNX:"havven",NEO:"neo",CVX:"convex-finance",CRV:"curve-dao-token",BAT:"basic-attention-token",CHZ:"chiliz",ENJ:"enjincoin",DASH:"dash",COMP:"compound-governance-token",ZEC:"zcash",XEM:"nem",HOT:"holo",IOTX:"iotex",RUNE:"thorchain",KSM:"kusama",ZIL:"zilliqa",RVN:"ravencoin",CELO:"celo",ONE:"harmony",QTUM:"qtum",BNB:"binancecoin"},Tyt=120*1e3,kyt=n=>{try{const t=localStorage.getItem(`cache_${n}`);if(t){const{data:e,timestamp:s}=JSON.parse(t);if(Date.now()-s<Tyt)return e}}catch(t){console.warn("Cache read compile error",t)}return null},$yt=(n,t)=>{try{localStorage.setItem(`cache_${n}`,JSON.stringify({data:t,timestamp:Date.now()}))}catch{try{localStorage.clear()}catch{}}},hw={AAPL:"Apple Inc.",MSFT:"Microsoft Corp.",GOOGL:"Alphabet Inc.",AMZN:"Amazon.com Inc.",NVDA:"NVIDIA Corp.",TSLA:"Tesla Inc.",META:"Meta Platforms Inc.","BRK.B":"Berkshire Hathaway",V:"Visa Inc.",JNJ:"Johnson & Johnson",WMT:"Walmart Inc.",JPM:"JPMorgan Chase & Co.",PG:"Procter & Gamble Co.",MA:"Mastercard Inc.",LLY:"Eli Lilly and Co.",HD:"Home Depot Inc.",CVX:"Chevron Corp.",MRK:"Merck & Co.",KO:"Coca-Cola Co.",PEP:"PepsiCo Inc.",AVGO:"Broadcom Inc.",COST:"Costco Wholesale Corp.",ORCL:"Oracle Corp.",AMD:"Advanced Micro Devices",NFLX:"Netflix Inc.",INTC:"Intel Corp.",IBM:"IBM Corp.",QCOM:"Qualcomm Inc.",TXN:"Texas Instruments",HON:"Honeywell",UNH:"UnitedHealth Group",SPY:"SPDR S&P 500 ETF",QQQ:"Invesco QQQ Trust",IWM:"iShares Russell 2000",DIA:"SPDR Dow Jones"},sP=n=>{if(!n)return null;const t=n.match(/\b\d{1,3}(?:[.,]\d{3})*[.,]\d{1,8}\b/g),e=n.match(/\b\d{1,3}(?:,\d{3})+\b/g),s=n.match(/\b\d{4,7}\b/g),i=[...t||[],...e||[],...s||[]].map(l=>{const c=l.replace(/,/g,""),h=c.split(".");if(h.length>2){const d=h.pop();return parseFloat(h.join("")+"."+d)}return parseFloat(c)}).filter(l=>l>=2e3&&l<=3e3||l===24||l===1||l===7||l===30||l===15||l===60?!1:l>1e-4&&l<2e7);return i.length===0?null:i.sort((l,c)=>{const h=l>.1&&l<15e4,d=c>.1&&c<15e4;if(h&&!d)return-1;if(!h&&d)return 1;const p=l%1!==0,m=c%1!==0;return p&&!m?-1:!p&&m?1:l-c})[0]},Eyt=n=>{if(!n)return null;const t=n.toUpperCase(),e=["VOL","USD","USDT","UTC","CRYPTO","CRYPTOCURRENCY","PRICE","MARKET","CHANGE","TIME","TOTAL","LOW","HIGH","OPEN","CLOSE","DAILY","WEEKLY"],s=t.split(/[^A-Z0-9]/).filter(l=>l.length>=2);for(const l of Object.keys(kh))if(s.includes(l))return l;const r=t.match(/\b([A-Z0-9]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP|FRAX|DAI)\b/);if(r){const l=r[1];if(kh[l]||hw[l]||l.length>=2&&!e.includes(l))return l}if((t.includes("CRYPTO")||t.includes("O H L"))&&!t.includes("BITCOIN")){const l=sP(n);if(l>4e4&&l<15e4)return"BTC";if(l>1500&&l<1e4)return"ETH"}const i={BITCOIN:"BTC",ETHEREUM:"ETH",SOLANA:"SOL",RIPPLE:"XRP",CARDANO:"ADA",DOGECOIN:"DOGE",AVALANCHE:"AVAX"};for(const[l,c]of Object.entries(i))if(t.includes(l))return c;const o=t.match(/\(([A-Z0-9]{2,6})\)[ -]|^([A-Z0-9]{2,6})\s+\d/);if(o){const l=o[1]||o[2];if(kh[l]||hw[l]||l.length>=2&&!e.includes(l))return l}return null},Iyt=async n=>{const t=kh[n];if(!t)return null;try{const r=(await(await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${t}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`)).json())[t];return{price:r.usd,change24h:r.usd_24h_change,volume:r.usd_24h_vol,source:"CoinGecko"}}catch(e){return console.error("CoinGecko Fetch Error:",e),null}},Nyt=async(n,t=90)=>{const e=kh[n];if(!e)return null;const s=kyt(`${e}_${t}`);if(s)return s;try{const i=await(await fetch(`https://api.coingecko.com/api/v3/coins/${e}/market_chart?vs_currency=usd&days=${t}`)).json(),o=i.prices.map(h=>h[1]),l=i.total_volumes.map(h=>h[1]),c={closes:o,highs:o.map(h=>h*1.002),lows:o.map(h=>h*.998),volumes:l};return $yt(`${e}_${t}`,c),c}catch(r){return console.error("CoinGecko History Error:",r),null}},Ayt=async n=>{const t=n.includes("-")?n.replace("-",""):n;try{const e=`https://query1.finance.yahoo.com/v8/finance/chart/${t}?interval=1d&range=3mo`,s=[`https://corsproxy.io/?${encodeURIComponent(e)}`,`https://api.allorigins.win/raw?url=${encodeURIComponent(e)}`];let r=null;for(const y of s)try{const b=await fetch(y);if(!b.ok)continue;if(r=await b.json(),r?.chart?.result)break}catch{continue}if(!r)throw new Error("All proxies failed");const i=r.chart.result[0],o=i.indicators.quote[0].close.filter(y=>y!==null),l=i.indicators.quote[0].high.filter(y=>y!==null),c=i.indicators.quote[0].low.filter(y=>y!==null),h=i.indicators.quote[0].volume.filter(y=>y!==null),d=i.meta.regularMarketPrice,p=i.meta.previousClose,m=(d-p)/p*100;return{marketStats:{price:d,change24h:m,volume:h[h.length-1],source:"Yahoo Finance"},historicalData:{closes:o,highs:l,lows:c,volumes:h}}}catch(e){return console.warn("Yahoo data fetch failed for",n,e),null}},CA=async n=>{if(!n||n==="VISUAL-SCAN")return null;const t=n.includes("-")?n.replace("-",""):n;try{const e=`https://query1.finance.yahoo.com/v8/finance/chart/${t}?interval=1d&range=1y`,s=[`https://corsproxy.io/?${encodeURIComponent(e)}`,`https://api.allorigins.win/raw?url=${encodeURIComponent(e)}`];let r=null;for(const o of s)try{const l=await fetch(o);if(!l.ok)continue;if(r=await l.json(),r?.chart?.result)break}catch{continue}return r?.chart?.result?.[0]?.indicators?.quote?.[0]?.close?.filter(o=>o!==null)||null}catch{return null}},_yt=n=>{if(!n||n.length<10)return .5;const t=n[n.length-1],e=n.slice(-50).reduce((o,l)=>o+l,0)/Math.min(n.length,50),s=n.slice(-200).reduce((o,l)=>o+l,0)/Math.min(n.length,200);let r=.5;t>e&&(r+=.1),t>s&&(r+=.15),e>s&&(r+=.1),t>n[0]&&(r+=.1);const i=(t-n[n.length-20])/n[n.length-20];return r+=i*.5,Math.max(.1,Math.min(.9,r))},Ryt=(n,t,e,s,r=.95,i=.5,o=.02,l=.5)=>{const h=.15+(o>.04?.05:0),d=.1,p=s.omega+s.alpha+s.gamma+h+d,m=X=>(X-.5)*2,y=m(n),b=s.omega/p,x=r;let w=.5;t==="Bullish"?w=.85:t==="Bearish"&&(w=.15);const S=m(w),T=s.alpha/p,k=e.rsi[e.rsi.length-1];let $=.5;k<30?$=.85:k<40?$=.7:k>70?$=.15:k>60&&($=.3);const E=m($),N=s.gamma/p,_=k<25||k>75?1.3:1,R=m(i),D=h/p,O=m(l),W=1-[{w:b,p:y,c:x,f:1},{w:T,p:S,c:.9,f:1},{w:N,p:E,c:1,f:_},{w:D,p:R,c:1,f:1},{w:.15,p:O,c:1,f:1},{w:d/p,p:m(s.obBias||.5),c:1,f:1}].reduce((X,P)=>{const V=P.w*P.p*P.c*P.f;return X*(1-Math.max(-.99,Math.min(.99,V)))},1-.5);return Math.min(.995,Math.max(.005,W))},Dyt=async(n,t,e,s,r,i,o=.95,l=!1)=>{const c=Array.isArray(e)?e:e.closes||[],h=e.highs||c,d=e.lows||c;e.volumes;let p=t.price||c[c.length-1];const m=c[c.length-1];if(t.price&&m){const Pt=Math.log10(m/t.price);if(Math.abs(Pt)>.6){const Jt=Math.pow(10,Math.round(Pt));console.log(`[ScaleGuardian] Correcting OCR price scale: ${t.price} -> ${t.price*Jt} (Factor: ${Jt})`),p=t.price*Jt}}if(c.length<20)throw new Error("Insufficient historical data for precision analysis");const y=I5(c,14),x=A5(c).histogram,w=e.opens||[],S=_5(c,h,d,w),T=S[0].sentiment,k=R5(h,d,c,14),$=D5(c,h,d);e.volumes&&e.volumes.length>0&&O5(h,d,c,e.volumes);let E=.5;try{i("Aligning Multi-Timeframe Bias (Daily)...");const Pt=await CA(n);Pt?.prices&&(E=M5(Pt.prices))}catch(Pt){console.warn("MTF Alignment failed, using neutral bias:",Pt)}let N=.5,_=null;const R=k[k.length-1]||p*.02,D=pyt(c),O=R/p;if(c.length>=gr)if(l){const Pt=c[c.length-1],Jt=c[c.length-15],$n=(Pt-Jt)/Jt;N=.5+Math.min(.45,Math.max(-.45,$n/(O*5))),i("Rapid Precision Heuristic Applied...")}else{let Pt=null;try{const Jt=calculateROC(c,10),$n=calculateRollingVolatility(c,20),dn={prices:c,rsi:y,macd:x,atr:k,roc:Jt,vol:$n};if(s&&(Pt=await Cyt(s,`lstm_v4_${n}`)),Pt){if(i("Calibrating Cloud Intelligence V4..."),_=xyt(dn),Pt&&c.length>=gr&&_){i("Running V4 Predictive Inference...");const ds={prices:c.slice(-gr),rsi:y.slice(-gr),macd:x.slice(-gr),atr:k.slice(-gr)},me=vyt(Pt,ds,_),an=1/(O*10||1);N=.5+(me-p)/p*an,N=Math.max(.02,Math.min(.98,N))}}else{i("Training Deep LSTM V4 (Parallel Core)...");const ds=calculateROC(c,10),me=calculateRollingVolatility(c,20),an=await yyt({ticker:n,historicalPrices:c,rsi:y,macdHist:x,atr:k,roc:ds,vol:me});if(an){const Un=1/(O*10||1);N=.5+(an.predictedPrice-p)/p*Un,N=Math.max(.02,Math.min(.98,N)),_=an.stats,s&&an.modelArtifacts&&(i("Syncing V4 Brain to Cloud..."),await Syt(s,an.modelArtifacts,`lstm_v4_${n}`,.99))}}}finally{Pt&&wyt(Pt)}}i("Gathering Macro V4 Context...");const A=await CA(n),z=_yt(A?.prices);let q=.5;try{if(n.includes("BTC")||n.includes("ETH")||n.includes("SOL")){let Pt=n.replace("/","").toUpperCase();(Pt==="BTC"||Pt==="ETH"||Pt==="SOL")&&(Pt+="USDT");const Jt=await fetch(`https://api.binance.com/api/v3/depth?symbol=${Pt}&limit=20`);if(Jt.ok){const $n=await Jt.json(),dn=$n.bids.reduce((me,[an,Un])=>me+Number(Un),0),ds=$n.asks.reduce((me,[an,Un])=>me+Number(Un),0);q=dn/(dn+ds),console.log(`[Analysis] Order Book Bias: ${q.toFixed(2)}`)}}}catch(Pt){console.warn("Order Book sync failed:",Pt)}let W=Ryt(N,T,{rsi:y},{...r,obBias:q},o,z,O,E);const X=y[y.length-1]<45&&T==="Bullish",P=y[y.length-1]>55&&T==="Bearish";if(N>.75&&X){const Pt=.05+.1*(N-.75);W=Math.min(.99,W+Pt)}else if(N<.25&&P){const Pt=.05+.1*(.25-N);W=Math.max(.01,W-Pt)}const V=((W>.5?W:1-W)*100).toFixed(1),G=[{name:"Neural Net (V5 LSTM)",type:"Deep Intelligence",w:r.omega,p:N,value:l?"Heuristic":"RMSE-Optimized"},{name:`Primary Pattern: ${S[0].name}`,type:"Geometric",w:r.alpha,p:T==="Bullish"?.8:T==="Bearish"?.2:.5,value:S[0].name},{name:"Technical Alpha",type:"Confluence",w:r.gamma,p:y[y.length-1]<45?.8:y[y.length-1]>55?.2:.5,value:"RSI-ATR Sync"},{name:"Macro Sentiment",type:"Ensemble",w:.15,p:z,value:"10Y-Alpha"},{name:"MTF Alignment",type:"V5 Bias",w:.15,p:E,value:E>.6?"Bullish":E<.4?"Bearish":"Neutral"},{name:"Visual Alignment",type:"Sync",w:.1,p:o,value:`${(o*100).toFixed(0)}%`}];let tt="Neutral";W>.68?tt="Strong Bullish":W>.55?tt="Moderate Bullish":W<.32?tt="Strong Bearish":W<.45&&(tt="Moderate Bearish");const Z=tt.includes("Bullish")||tt==="Neutral"&&W>=.5;tt.includes("Bearish")||tt==="Neutral"&&W<.5;const F=p<1?5:p<100?3:2,B=Z?$.strength.s:$.strength.r,Q=B>3?1.2:B>1?1.5:1.8,lt=Math.max(p*.008,R*Q),pt=tt.includes("Strong")?2.2:1.8,gt=Math.min(1.3,Math.max(.8,parseFloat(V)/60)),vt=Math.min(3,pt*gt);let kt,Ct,Rt;Z?(kt=p-lt,$.support<p&&$.support>kt&&B>1&&(kt=$.support*.997),Ct=p+lt*Math.min(vt,2),Rt=p+lt*vt,$.resistance>p&&$.resistance<Rt*1.1&&$.strength.r>2&&(Rt=$.resistance*.997)):(kt=p+lt,$.resistance>p&&$.resistance<kt&&B>1&&(kt=$.resistance*1.003),Ct=Math.max(p*.1,p-lt*Math.min(vt,2)),Rt=Math.max(p*.05,p-lt*vt),$.support<p&&$.support>Rt*.9&&$.strength.s>2&&(Rt=$.support*1.003));const Gt={entry:p.toFixed(F),sl:kt.toFixed(F),tp1:Ct.toFixed(F),tp2:Rt.toFixed(F),rr:vt.toFixed(1)},re=()=>{y[y.length-1];let Pt=`V5 Institutional analysis of **${n}** identified a **${tt}** structure with **${V}%** mathematical confidence. `;if(S.length>0){const Jt=S[0];Pt+=`The detection of a **${Jt.name}** pattern suggests a dominant ${Jt.sentiment.toLowerCase()} sentiment in the current fractal. `}return N>.7?Pt+="Deep LSTM detects aggressive institutional accumulation. ":N<.3&&(Pt+="Neural inference highlights terminal distribution phases. "),($.strength.s>3||$.strength.r>3)&&(Pt+=`Major ${$.strength.s>$.strength.r?"support":"resistance"} detected at $${$.strength.s>$.strength.r?$.support.toFixed(F):$.resistance.toFixed(F)} with strength ${Math.max($.strength.s,$.strength.r)}/5. `),O>.05&&(Pt+="High implied volatility suggests widened discovery ranges. "),Pt},ge=c.slice(1).map((Pt,Jt)=>(Pt-c[Jt])/c[Jt]),de=myt(ge),pe=hyt(de),ae=dyt(de),Ne=fyt(c),Ce={volatility:(O*100).toFixed(2),volRatio:D.toFixed(2),sharpeRatio:pe.toFixed(2),sortinoRatio:ae.toFixed(2),maxDrawdown:Ne.toFixed(2),calibration:{rmse:(Math.sqrt(Math.pow(1-W,2))*.08).toFixed(4),brier:Math.pow(W-(Z?1:0),2).toFixed(4)}};return{id:Date.now().toString(),date:new Date().toISOString(),p0:r.alpha.toFixed(2),finalProb:Number(W),direction:tt,confidence:V,patterns:S,factors:G,targets:Gt,riskMetrics:Ce,macroTrend:{...A,source:A?.source||"Internal V4 Engine"},overview:re(),ticker:n||"UNKNOWN",version:`V4-RMSE-PRECISION (Iter: ${r.iterations})`,raw_prices:c}},$a="https://diverai.flisoft.agency",Oyt=({ticker:n})=>{const[t,e]=St.useState(null),[s,r]=St.useState(!1);St.useEffect(()=>{n&&i()},[n]);const i=async()=>{r(!0);try{let o=n.replace("/","").toUpperCase();(o==="BTC"||o==="ETH"||o==="SOL"||o==="XRP")&&(o+="USDT");const l=await fetch(`https://api.binance.com/api/v3/depth?symbol=${o}&limit=5`);if(l.ok){const c=await l.json();e(c)}}catch{console.warn("Order book fetch skipped for non-compatible ticker.")}finally{r(!1)}};return s?it.jsx("div",{className:"h-20 bg-slate-900 animate-pulse rounded-xl"}):t?it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3 space-y-2",children:[it.jsxs("div",{className:"flex items-center gap-2 text-[10px] font-bold text-slate-500 uppercase",children:[it.jsx(IG,{className:"w-3 h-3"})," Order Book Depth"]}),it.jsxs("div",{className:"space-y-1",children:[t.asks.slice(0,3).reverse().map(([o,l],c)=>it.jsxs("div",{className:"flex justify-between text-[10px] font-mono",children:[it.jsx("span",{className:"text-rose-500",children:Number(o).toFixed(2)}),it.jsx("span",{className:"text-slate-600",children:Number(l).toFixed(4)})]},`ask-${c}`)),it.jsx("div",{className:"h-px bg-slate-800 my-1"}),t.bids.slice(0,3).map(([o,l],c)=>it.jsxs("div",{className:"flex justify-between text-[10px] font-mono",children:[it.jsx("span",{className:"text-emerald-500",children:Number(o).toFixed(2)}),it.jsx("span",{className:"text-slate-600",children:Number(l).toFixed(4)})]},`bid-${c}`))]})]}):null},Myt=()=>{const{user:n,profile:t,refreshProfile:e,neuralState:s}=E5(),[r,i]=St.useState("idle"),[o,l]=St.useState(null),[c,h]=St.useState(null),[d,p]=St.useState(""),[m,y]=St.useState(""),[b,x]=St.useState(!1),[w,S]=St.useState(""),[T,k]=St.useState("guest"),[$,E]=St.useState(null),[N,_]=St.useState([]),[R,D]=St.useState("analyze"),[O,A]=St.useState(!1);St.useEffect(()=>{z();const Z=async F=>{if(F.type==="AUTH_SYNC"&&F.session){const{access_token:B,refresh_token:Q}=F.session;await ms.auth.setSession({access_token:B,refresh_token:Q}),e()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(Z),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(Z)}},[]);const z=async()=>{try{const Z=await fetch("https://api.ipify.org?format=json");if(!Z.ok)throw new Error("Network response was not ok");const F=await Z.json();E(F.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};St.useEffect(()=>{q()},[n]);const q=async()=>{if(!n){const B=localStorage.getItem("diver_ai_guest_history");_(B?JSON.parse(B):[]);return}const{data:Z,error:F}=await ms.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!F&&Z&&_(Z.map(B=>({...B.data,db_id:B.id,created_at:B.created_at})))},W=async Z=>{if(n){const{data:F}=await ms.from("prediction_history").insert([{user_id:n.id,data:Z}]).select();if(F?.[0]){const B={...Z,db_id:F[0].id,created_at:F[0].created_at};_(Q=>[B,...Q].slice(0,10))}}},X=()=>{},P=()=>{if(!n)return S("Authentication Required: Please log in to access the neural analysis terminal."),k("guest"),x(!0),!1;const Z=new Date().toISOString().split("T")[0];return n.email_confirmed_at?t&&t.subscription_tier!=="pro"&&(t.upload_count||0)>=3&&t.last_upload_date===Z?(S("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),k("free"),x(!0),!1):!0:(S("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),k("verify"),x(!0),!1)},V=async()=>{if(P()){i("scanning"),p("Capturing Visual Stream..."),l(null);try{const Z=await new Promise(gt=>{chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"},vt=>{chrome.runtime.lastError?gt({error:"Connection to extension background lost. Please refresh the page."}):gt(vt)})});if(Z.error)throw new Error(Z.error);const F=Z.dataUrl;h(F),i("analyzing"),await ms.auth.refreshSession();try{p("Deep Scan (Cloud OCR)...");const{data:gt,error:vt}=await ms.functions.invoke("detect_ticker",{body:{image:F}});if(vt)throw vt;const kt=gt?.text||"",Ct=Eyt(kt),Rt=sP(kt);if(console.log("[Sidebar] OCR Detected:",{ticker:Ct,anchorPrice:Rt}),!Ct&&!Rt)throw new Error("Neural Core Rejected: No valid asset or price identified.");p(`Target Locked: ${Ct}. Syncing Data...`)}catch(gt){throw console.warn("[Sidebar] Cloud OCR Failed, using local fallback if possible or failing."),gt}p(`Target Locked: ${ticker}. Syncing Data...`);let B,Q;if(hw[ticker]){const gt=await Ayt(ticker);if(gt)B=gt.marketStats,Q=gt.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else B=await Iyt(ticker),Q=await Nyt(ticker,90);p("Synchronizing Global Intelligence...");const pt=await Dyt(ticker,B,Q,n,s,p,.95,!0);if(n&&t){const gt=new Date().toISOString().split("T")[0],vt=t.last_upload_date!==gt?1:(t.upload_count||0)+1;await ms.from("profiles").update({upload_count:vt,last_upload_date:gt}).eq("id",n.id),e()}else X();await W(pt),l(pt),i("success")}catch(Z){console.error(Z),y(Z.message),i("error")}}},G=()=>{if(!o){console.warn("[Overlay] No analysis result available to draw overlay.");return}chrome.tabs.query({active:!0,currentWindow:!0},Z=>{const F=Z[0];if(!F){console.warn("[Overlay] No active tab found.");return}if(!F.url){console.warn("[Overlay] Unable to determine current page URL.");return}if(!["tradingview.com","yahoo.com","coingecko.com","coinmarketcap.com","binance.com","google.com/finance"].some(lt=>F.url.includes(lt))){console.info(`[Overlay] Skipped - Not on a supported trading page. Current URL: ${F.url}`),alert("Please navigate to a trading chart (e.g., TradingView) to draw the R/R overlay.");return}chrome.tabs.sendMessage(F.id,{action:"DRAW_RR_OVERLAY",targets:o.targets,ticker:o.ticker},lt=>{chrome.runtime.lastError?(console.error("[Overlay] Failed:",chrome.runtime.lastError.message),alert("Overlay failed: Content script not ready. Try refreshing the trading page.")):lt?.success?console.log("[Overlay] Successfully drawn on chart."):console.warn("[Overlay] Message sent, but no confirmation received.")})})},tt=({id:Z,label:F,icon:B})=>it.jsxs("button",{onClick:()=>D(Z),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${R===Z?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[it.jsx(B,{className:"w-3.5 h-3.5"}),F,R===Z&&it.jsx(wa.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return it.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&it.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:it.jsxs("div",{className:"space-y-6 max-w-xs",children:[it.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:it.jsx(rI,{className:"text-rose-500"})}),it.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),it.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),it.jsxs("div",{className:"space-y-3",children:[T==="free"?it.jsx("button",{onClick:()=>window.open(`${$a}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):T==="guest"?it.jsx("button",{onClick:()=>window.open(`${$a}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):it.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),it.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),it.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[it.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[it.jsxs("div",{className:"flex items-center gap-2",children:[it.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:it.jsx(xG,{className:"w-3.5 h-3.5 text-white"})}),it.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",it.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?it.jsxs("div",{className:"flex items-center gap-3",children:[it.jsx("div",{className:"text-right",children:it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:t?.subscription_tier==="pro"?"PRO":"BASIC"})}),it.jsx("button",{onClick:()=>ms.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:it.jsx(_G,{className:"w-4 h-4"})})]}):it.jsx("button",{onClick:()=>window.open(`${$a}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),it.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[it.jsx(tt,{id:"analyze",label:"Analysis",icon:aI}),it.jsx(tt,{id:"history",label:"History",icon:sI}),n&&it.jsx(tt,{id:"referral",label:"Rewards",icon:jG})]})]}),it.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:it.jsxs(FU,{mode:"wait",children:[R==="history"&&it.jsx(wa.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:N.length===0?it.jsxs("div",{className:"text-center py-12 text-slate-600",children:[it.jsx(sI,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),it.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):N.map((Z,F)=>it.jsxs("div",{onClick:()=>{l(Z),i("success"),D("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[it.jsxs("div",{className:"flex items-center gap-3",children:[it.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${Z.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:Z.direction.includes("Bullish")?it.jsx(oI,{className:"w-4 h-4"}):it.jsx(iI,{className:"w-4 h-4"})}),it.jsxs("div",{children:[it.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:Z.ticker}),it.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(Z.created_at).toLocaleDateString()})]})]}),it.jsxs("span",{className:`text-xs font-mono font-bold ${Z.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(Z.finalProb*100).toFixed(0),"%"]})]},Z.db_id||F))},"history"),R==="referral"&&n&&it.jsxs(wa.div,{initial:{opacity:0,x:10},animate:{opacity:1,x:0},className:"space-y-4",children:[it.jsxs("div",{className:"bg-gradient-to-br from-blue-600 to-indigo-700 rounded-2xl p-5 border border-white/10 shadow-xl relative overflow-hidden",children:[it.jsx("div",{className:"absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 mix-blend-overlay"}),it.jsxs("div",{className:"relative z-10 space-y-3",children:[it.jsx("h3",{className:"text-sm font-black uppercase tracking-tight",children:"Earn Pro Status"}),it.jsx("p",{className:"text-[10px] text-blue-100 font-medium leading-relaxed",children:"Refer a friend. You both get 30 days of Pro analysis upon their signup."}),it.jsx("div",{className:"pt-2",children:it.jsxs("div",{className:"flex gap-2",children:[it.jsx("div",{className:"flex-1 bg-slate-950/40 border border-white/10 rounded-lg px-3 py-2 text-[9px] font-mono text-blue-200 truncate",children:t?.referral_code?`${$a}/signup?ref=${t.referral_code}`:"Generating..."}),it.jsx("button",{onClick:()=>{navigator.clipboard.writeText(`${$a}/signup?ref=${t?.referral_code}`),A(!0),setTimeout(()=>A(!1),2e3)},className:"bg-white text-slate-950 p-2 rounded-lg hover:bg-blue-100 transition-colors",children:O?it.jsx(wG,{className:"w-3.5 h-3.5"}):it.jsx(CG,{className:"w-3.5 h-3.5"})})]})})]})]}),it.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[it.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Total Referrals"}),it.jsx("p",{className:"text-xl font-black text-white",children:t?.referral_count||0})]}),it.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Days Granted"}),it.jsx("p",{className:"text-xl font-black text-emerald-400",children:(t?.referral_count||0)*30})]})]}),it.jsxs("button",{onClick:()=>window.open(`${$a}/referral`,"_blank"),className:"w-full py-3 bg-slate-900 border border-slate-800 hover:border-blue-500/50 text-slate-300 hover:text-white text-[10px] font-bold uppercase tracking-widest rounded-xl transition-all flex items-center justify-center gap-2",children:[it.jsx(LG,{className:"w-3.5 h-3.5"})," View Full Dashboard"]})]},"referral"),R==="analyze"&&r==="idle"&&it.jsx(wa.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:n?it.jsxs(it.Fragment,{children:[it.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:it.jsx(MG,{className:"w-8 h-8 text-blue-500"})}),it.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[it.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),it.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]}):it.jsxs(it.Fragment,{children:[it.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:it.jsx(rI,{className:"w-8 h-8 text-rose-500"})}),it.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[it.jsx("h3",{className:"text-lg font-bold text-white",children:"Terminal Locked"}),it.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Neural analysis requires an active operative session. Please login to continue."})]}),it.jsx("button",{onClick:()=>window.open(`${$a}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg transition-all uppercase tracking-widest text-[10px]",children:"Initialize Login"})]})},"idle"),(r==="scanning"||r==="analyzing")&&it.jsxs(wa.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[it.jsxs("div",{className:"relative w-16 h-16",children:[it.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),it.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),it.jsxs("div",{className:"text-center space-y-2",children:[it.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),it.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),r==="success"&&o&&R==="analyze"&&it.jsxs(wa.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[it.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[it.jsxs("div",{children:[it.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:o.ticker}),it.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[it.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${o.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[o.direction.split(" ")[0]," Signal"]}),it.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(o.finalProb*100).toFixed(1),"% Conf."]})]})]}),it.jsx("div",{className:`p-2 rounded-xl ${o.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:o.direction.includes("Bullish")?it.jsx(oI,{className:"w-5 h-5 text-emerald-500"}):it.jsx(iI,{className:"w-5 h-5 text-rose-500"})})]}),it.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${o.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),it.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),it.jsx("p",{className:"text-lg font-mono font-bold text-white",children:o.targets.entry})]}),it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),it.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",o.targets.rr]})]}),it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),it.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:o.targets.tp1})]}),it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),it.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:o.targets.sl})]})]}),it.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[it.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[it.jsx(kG,{className:"w-3 h-3"})," AI Analysis"]}),it.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:o.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),it.jsx(Oyt,{ticker:o.ticker}),it.jsxs("button",{onClick:G,className:"w-full py-3 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded-xl flex items-center justify-center gap-2 text-[10px] font-bold uppercase tracking-widest transition-all",children:[it.jsx(DG,{className:"w-3.5 h-3.5 text-blue-400"})," Draw R/R on Chart"]}),it.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:it.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",o.version.split(" ")[0],"  Data: ",o.macroTrend?.source||"Institutional Feed"]})}),it.jsx("button",{onClick:()=>i("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),r==="error"&&it.jsxs(wa.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[it.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:it.jsx(VG,{className:"w-6 h-6 text-rose-500"})}),it.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),it.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),it.jsx("button",{onClick:()=>i("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),R==="analyze"&&r==="idle"&&it.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:it.jsxs("button",{onClick:V,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[it.jsx(aI,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};DB.createRoot(document.getElementById("root")).render(it.jsx(kB.StrictMode,{children:it.jsx($5,{children:it.jsx(Myt,{})})}));
