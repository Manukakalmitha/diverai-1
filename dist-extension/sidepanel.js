function _G(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=t(r);fetch(r.href,i)}})();function NC(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function AG(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var Z1={exports:{}},hf={};var pR;function RG(){if(pR)return hf;pR=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,r,i){var a=null;if(i!==void 0&&(a=""+i),r.key!==void 0&&(a=""+r.key),"key"in r){i={};for(var o in r)o!=="key"&&(i[o]=r[o])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:a,ref:r!==void 0?r:null,props:i}}return hf.Fragment=e,hf.jsx=t,hf.jsxs=t,hf}var mR;function DG(){return mR||(mR=1,Z1.exports=RG()),Z1.exports}var pe=DG(),Q1={exports:{}},Je={};var gR;function OG(){if(gR)return Je;gR=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function y(P){return P===null||typeof P!="object"?null:(P=m&&P[m]||P["@@iterator"],typeof P=="function"?P:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function v(P,j,te){this.props=P,this.context=j,this.refs=w,this.updater=te||b}v.prototype.isReactComponent={},v.prototype.setState=function(P,j){if(typeof P!="object"&&typeof P!="function"&&P!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,P,j,"setState")},v.prototype.forceUpdate=function(P){this.updater.enqueueForceUpdate(this,P,"forceUpdate")};function C(){}C.prototype=v.prototype;function N(P,j,te){this.props=P,this.context=j,this.refs=w,this.updater=te||b}var k=N.prototype=new C;k.constructor=N,x(k,v.prototype),k.isPureReactComponent=!0;var E=Array.isArray;function A(){}var R={H:null,A:null,T:null,S:null},D=Object.prototype.hasOwnProperty;function L(P,j,te){var le=te.ref;return{$$typeof:n,type:P,key:j,ref:le!==void 0?le:null,props:te}}function F(P,j){return L(P.type,j,P.props)}function _(P){return typeof P=="object"&&P!==null&&P.$$typeof===n}function V(P){var j={"=":"=0",":":"=2"};return"$"+P.replace(/[=:]/g,function(te){return j[te]})}var Q=/\/+/g;function ne(P,j){return typeof P=="object"&&P!==null&&P.key!=null?V(""+P.key):j.toString(36)}function Z(P){switch(P.status){case"fulfilled":return P.value;case"rejected":throw P.reason;default:switch(typeof P.status=="string"?P.then(A,A):(P.status="pending",P.then(function(j){P.status==="pending"&&(P.status="fulfilled",P.value=j)},function(j){P.status==="pending"&&(P.status="rejected",P.reason=j)})),P.status){case"fulfilled":return P.value;case"rejected":throw P.reason}}throw P}function B(P,j,te,le,me){var we=typeof P;(we==="undefined"||we==="boolean")&&(P=null);var Te=!1;if(P===null)Te=!0;else switch(we){case"bigint":case"string":case"number":Te=!0;break;case"object":switch(P.$$typeof){case n:case e:Te=!0;break;case d:return Te=P._init,B(Te(P._payload),j,te,le,me)}}if(Te)return me=me(P),Te=le===""?"."+ne(P,0):le,E(me)?(te="",Te!=null&&(te=Te.replace(Q,"$&/")+"/"),B(me,j,te,"",function(Ae){return Ae})):me!=null&&(_(me)&&(me=F(me,te+(me.key==null||P&&P.key===me.key?"":(""+me.key).replace(Q,"$&/")+"/")+Te)),j.push(me)),1;Te=0;var $e=le===""?".":le+":";if(E(P))for(var be=0;be<P.length;be++)le=P[be],we=$e+ne(le,be),Te+=B(le,j,te,we,me);else if(be=y(P),typeof be=="function")for(P=be.call(P),be=0;!(le=P.next()).done;)le=le.value,we=$e+ne(le,be++),Te+=B(le,j,te,we,me);else if(we==="object"){if(typeof P.then=="function")return B(Z(P),j,te,le,me);throw j=String(P),Error("Objects are not valid as a React child (found: "+(j==="[object Object]"?"object with keys {"+Object.keys(P).join(", ")+"}":j)+"). If you meant to render a collection of children, use an array instead.")}return Te}function U(P,j,te){if(P==null)return P;var le=[],me=0;return B(P,le,"","",function(we){return j.call(te,we,me++)}),le}function K(P){if(P._status===-1){var j=P._result;j=j(),j.then(function(te){(P._status===0||P._status===-1)&&(P._status=1,P._result=te)},function(te){(P._status===0||P._status===-1)&&(P._status=2,P._result=te)}),P._status===-1&&(P._status=0,P._result=j)}if(P._status===1)return P._result.default;throw P._result}var X=typeof reportError=="function"?reportError:function(P){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var j=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof P=="object"&&P!==null&&typeof P.message=="string"?String(P.message):String(P),error:P});if(!window.dispatchEvent(j))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",P);return}console.error(P)},se={map:U,forEach:function(P,j,te){U(P,function(){j.apply(this,arguments)},te)},count:function(P){var j=0;return U(P,function(){j++}),j},toArray:function(P){return U(P,function(j){return j})||[]},only:function(P){if(!_(P))throw Error("React.Children.only expected to receive a single React element child.");return P}};return Je.Activity=p,Je.Children=se,Je.Component=v,Je.Fragment=t,Je.Profiler=r,Je.PureComponent=N,Je.StrictMode=s,Je.Suspense=l,Je.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=R,Je.__COMPILER_RUNTIME={__proto__:null,c:function(P){return R.H.useMemoCache(P)}},Je.cache=function(P){return function(){return P.apply(null,arguments)}},Je.cacheSignal=function(){return null},Je.cloneElement=function(P,j,te){if(P==null)throw Error("The argument must be a React element, but you passed "+P+".");var le=x({},P.props),me=P.key;if(j!=null)for(we in j.key!==void 0&&(me=""+j.key),j)!D.call(j,we)||we==="key"||we==="__self"||we==="__source"||we==="ref"&&j.ref===void 0||(le[we]=j[we]);var we=arguments.length-2;if(we===1)le.children=te;else if(1<we){for(var Te=Array(we),$e=0;$e<we;$e++)Te[$e]=arguments[$e+2];le.children=Te}return L(P.type,me,le)},Je.createContext=function(P){return P={$$typeof:a,_currentValue:P,_currentValue2:P,_threadCount:0,Provider:null,Consumer:null},P.Provider=P,P.Consumer={$$typeof:i,_context:P},P},Je.createElement=function(P,j,te){var le,me={},we=null;if(j!=null)for(le in j.key!==void 0&&(we=""+j.key),j)D.call(j,le)&&le!=="key"&&le!=="__self"&&le!=="__source"&&(me[le]=j[le]);var Te=arguments.length-2;if(Te===1)me.children=te;else if(1<Te){for(var $e=Array(Te),be=0;be<Te;be++)$e[be]=arguments[be+2];me.children=$e}if(P&&P.defaultProps)for(le in Te=P.defaultProps,Te)me[le]===void 0&&(me[le]=Te[le]);return L(P,we,me)},Je.createRef=function(){return{current:null}},Je.forwardRef=function(P){return{$$typeof:o,render:P}},Je.isValidElement=_,Je.lazy=function(P){return{$$typeof:d,_payload:{_status:-1,_result:P},_init:K}},Je.memo=function(P,j){return{$$typeof:h,type:P,compare:j===void 0?null:j}},Je.startTransition=function(P){var j=R.T,te={};R.T=te;try{var le=P(),me=R.S;me!==null&&me(te,le),typeof le=="object"&&le!==null&&typeof le.then=="function"&&le.then(A,X)}catch(we){X(we)}finally{j!==null&&te.types!==null&&(j.types=te.types),R.T=j}},Je.unstable_useCacheRefresh=function(){return R.H.useCacheRefresh()},Je.use=function(P){return R.H.use(P)},Je.useActionState=function(P,j,te){return R.H.useActionState(P,j,te)},Je.useCallback=function(P,j){return R.H.useCallback(P,j)},Je.useContext=function(P){return R.H.useContext(P)},Je.useDebugValue=function(){},Je.useDeferredValue=function(P,j){return R.H.useDeferredValue(P,j)},Je.useEffect=function(P,j){return R.H.useEffect(P,j)},Je.useEffectEvent=function(P){return R.H.useEffectEvent(P)},Je.useId=function(){return R.H.useId()},Je.useImperativeHandle=function(P,j,te){return R.H.useImperativeHandle(P,j,te)},Je.useInsertionEffect=function(P,j){return R.H.useInsertionEffect(P,j)},Je.useLayoutEffect=function(P,j){return R.H.useLayoutEffect(P,j)},Je.useMemo=function(P,j){return R.H.useMemo(P,j)},Je.useOptimistic=function(P,j){return R.H.useOptimistic(P,j)},Je.useReducer=function(P,j,te){return R.H.useReducer(P,j,te)},Je.useRef=function(P){return R.H.useRef(P)},Je.useState=function(P){return R.H.useState(P)},Je.useSyncExternalStore=function(P,j,te){return R.H.useSyncExternalStore(P,j,te)},Je.useTransition=function(){return R.H.useTransition()},Je.version="19.2.3",Je}var yR;function kC(){return yR||(yR=1,Q1.exports=OG()),Q1.exports}var Ce=kC();const LG=NC(Ce);var eS={exports:{}},df={},tS={exports:{}},nS={};var bR;function FG(){return bR||(bR=1,(function(n){function e(B,U){var K=B.length;B.push(U);e:for(;0<K;){var X=K-1>>>1,se=B[X];if(0<r(se,U))B[X]=U,B[K]=se,K=X;else break e}}function t(B){return B.length===0?null:B[0]}function s(B){if(B.length===0)return null;var U=B[0],K=B.pop();if(K!==U){B[0]=K;e:for(var X=0,se=B.length,P=se>>>1;X<P;){var j=2*(X+1)-1,te=B[j],le=j+1,me=B[le];if(0>r(te,K))le<se&&0>r(me,te)?(B[X]=me,B[le]=K,X=le):(B[X]=te,B[j]=K,X=j);else if(le<se&&0>r(me,K))B[X]=me,B[le]=K,X=le;else break e}}return U}function r(B,U){var K=B.sortIndex-U.sortIndex;return K!==0?K:B.id-U.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var a=Date,o=a.now();n.unstable_now=function(){return a.now()-o}}var l=[],h=[],d=1,p=null,m=3,y=!1,b=!1,x=!1,w=!1,v=typeof setTimeout=="function"?setTimeout:null,C=typeof clearTimeout=="function"?clearTimeout:null,N=typeof setImmediate<"u"?setImmediate:null;function k(B){for(var U=t(h);U!==null;){if(U.callback===null)s(h);else if(U.startTime<=B)s(h),U.sortIndex=U.expirationTime,e(l,U);else break;U=t(h)}}function E(B){if(x=!1,k(B),!b)if(t(l)!==null)b=!0,A||(A=!0,V());else{var U=t(h);U!==null&&Z(E,U.startTime-B)}}var A=!1,R=-1,D=5,L=-1;function F(){return w?!0:!(n.unstable_now()-L<D)}function _(){if(w=!1,A){var B=n.unstable_now();L=B;var U=!0;try{e:{b=!1,x&&(x=!1,C(R),R=-1),y=!0;var K=m;try{t:{for(k(B),p=t(l);p!==null&&!(p.expirationTime>B&&F());){var X=p.callback;if(typeof X=="function"){p.callback=null,m=p.priorityLevel;var se=X(p.expirationTime<=B);if(B=n.unstable_now(),typeof se=="function"){p.callback=se,k(B),U=!0;break t}p===t(l)&&s(l),k(B)}else s(l);p=t(l)}if(p!==null)U=!0;else{var P=t(h);P!==null&&Z(E,P.startTime-B),U=!1}}break e}finally{p=null,m=K,y=!1}U=void 0}}finally{U?V():A=!1}}}var V;if(typeof N=="function")V=function(){N(_)};else if(typeof MessageChannel<"u"){var Q=new MessageChannel,ne=Q.port2;Q.port1.onmessage=_,V=function(){ne.postMessage(null)}}else V=function(){v(_,0)};function Z(B,U){R=v(function(){B(n.unstable_now())},U)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(B){B.callback=null},n.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<B?Math.floor(1e3/B):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(B){switch(m){case 1:case 2:case 3:var U=3;break;default:U=m}var K=m;m=U;try{return B()}finally{m=K}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(B,U){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var K=m;m=B;try{return U()}finally{m=K}},n.unstable_scheduleCallback=function(B,U,K){var X=n.unstable_now();switch(typeof K=="object"&&K!==null?(K=K.delay,K=typeof K=="number"&&0<K?X+K:X):K=X,B){case 1:var se=-1;break;case 2:se=250;break;case 5:se=1073741823;break;case 4:se=1e4;break;default:se=5e3}return se=K+se,B={id:d++,callback:U,priorityLevel:B,startTime:K,expirationTime:se,sortIndex:-1},K>X?(B.sortIndex=K,e(h,B),t(l)===null&&B===t(h)&&(x?(C(R),R=-1):x=!0,Z(E,K-X))):(B.sortIndex=se,e(l,B),b||y||(b=!0,A||(A=!0,V()))),B},n.unstable_shouldYield=F,n.unstable_wrapCallback=function(B){var U=m;return function(){var K=m;m=U;try{return B.apply(this,arguments)}finally{m=K}}}})(nS)),nS}var xR;function MG(){return xR||(xR=1,tS.exports=FG()),tS.exports}var sS={exports:{}},ds={};var wR;function zG(){if(wR)return ds;wR=1;var n=kC();function e(l){var h="https://react.dev/errors/"+l;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+l+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(l,h,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:l,containerInfo:h,implementation:d}}var a=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,h){if(l==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return ds.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,ds.createPortal=function(l,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(e(299));return i(l,h,null,d)},ds.flushSync=function(l){var h=a.T,d=s.p;try{if(a.T=null,s.p=2,l)return l()}finally{a.T=h,s.p=d,s.d.f()}},ds.preconnect=function(l,h){typeof l=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(l,h))},ds.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},ds.preinit=function(l,h){if(typeof l=="string"&&h&&typeof h.as=="string"){var d=h.as,p=o(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(l,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(l,{crossOrigin:p,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},ds.preinitModule=function(l,h){if(typeof l=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=o(h.as,h.crossOrigin);s.d.M(l,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(l)},ds.preload=function(l,h){if(typeof l=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,p=o(d,h.crossOrigin);s.d.L(l,d,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},ds.preloadModule=function(l,h){if(typeof l=="string")if(h){var d=o(h.as,h.crossOrigin);s.d.m(l,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(l)},ds.requestFormReset=function(l){s.d.r(l)},ds.unstable_batchedUpdates=function(l,h){return l(h)},ds.useFormState=function(l,h,d){return a.H.useFormState(l,h,d)},ds.useFormStatus=function(){return a.H.useHostTransitionStatus()},ds.version="19.2.3",ds}var vR;function PG(){if(vR)return sS.exports;vR=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),sS.exports=zG(),sS.exports}var SR;function BG(){if(SR)return df;SR=1;var n=MG(),e=kC(),t=PG();function s(u){var c="https://react.dev/errors/"+u;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)c+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+u+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function i(u){var c=u,f=u;if(u.alternate)for(;c.return;)c=c.return;else{u=c;do c=u,(c.flags&4098)!==0&&(f=c.return),u=c.return;while(u)}return c.tag===3?f:null}function a(u){if(u.tag===13){var c=u.memoizedState;if(c===null&&(u=u.alternate,u!==null&&(c=u.memoizedState)),c!==null)return c.dehydrated}return null}function o(u){if(u.tag===31){var c=u.memoizedState;if(c===null&&(u=u.alternate,u!==null&&(c=u.memoizedState)),c!==null)return c.dehydrated}return null}function l(u){if(i(u)!==u)throw Error(s(188))}function h(u){var c=u.alternate;if(!c){if(c=i(u),c===null)throw Error(s(188));return c!==u?null:u}for(var f=u,g=c;;){var S=f.return;if(S===null)break;var T=S.alternate;if(T===null){if(g=S.return,g!==null){f=g;continue}break}if(S.child===T.child){for(T=S.child;T;){if(T===f)return l(S),u;if(T===g)return l(S),c;T=T.sibling}throw Error(s(188))}if(f.return!==g.return)f=S,g=T;else{for(var $=!1,z=S.child;z;){if(z===f){$=!0,f=S,g=T;break}if(z===g){$=!0,g=S,f=T;break}z=z.sibling}if(!$){for(z=T.child;z;){if(z===f){$=!0,f=T,g=S;break}if(z===g){$=!0,g=T,f=S;break}z=z.sibling}if(!$)throw Error(s(189))}}if(f.alternate!==g)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?u:c}function d(u){var c=u.tag;if(c===5||c===26||c===27||c===6)return u;for(u=u.child;u!==null;){if(c=d(u),c!==null)return c;u=u.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),v=Symbol.for("react.profiler"),C=Symbol.for("react.consumer"),N=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),A=Symbol.for("react.suspense_list"),R=Symbol.for("react.memo"),D=Symbol.for("react.lazy"),L=Symbol.for("react.activity"),F=Symbol.for("react.memo_cache_sentinel"),_=Symbol.iterator;function V(u){return u===null||typeof u!="object"?null:(u=_&&u[_]||u["@@iterator"],typeof u=="function"?u:null)}var Q=Symbol.for("react.client.reference");function ne(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===Q?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case x:return"Fragment";case v:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case A:return"SuspenseList";case L:return"Activity"}if(typeof u=="object")switch(u.$$typeof){case b:return"Portal";case N:return u.displayName||"Context";case C:return(u._context.displayName||"Context")+".Consumer";case k:var c=u.render;return u=u.displayName,u||(u=c.displayName||c.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case R:return c=u.displayName||null,c!==null?c:ne(u.type)||"Memo";case D:c=u._payload,u=u._init;try{return ne(u(c))}catch{}}return null}var Z=Array.isArray,B=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,U=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,K={pending:!1,data:null,method:null,action:null},X=[],se=-1;function P(u){return{current:u}}function j(u){0>se||(u.current=X[se],X[se]=null,se--)}function te(u,c){se++,X[se]=u.current,u.current=c}var le=P(null),me=P(null),we=P(null),Te=P(null);function $e(u,c){switch(te(we,c),te(me,u),te(le,null),c.nodeType){case 9:case 11:u=(u=c.documentElement)&&(u=u.namespaceURI)?MA(u):0;break;default:if(u=c.tagName,c=c.namespaceURI)c=MA(c),u=zA(c,u);else switch(u){case"svg":u=1;break;case"math":u=2;break;default:u=0}}j(le),te(le,u)}function be(){j(le),j(me),j(we)}function Ae(u){u.memoizedState!==null&&te(Te,u);var c=le.current,f=zA(c,u.type);c!==f&&(te(me,u),te(le,f))}function ze(u){me.current===u&&(j(le),j(me)),Te.current===u&&(j(Te),of._currentValue=K)}var it,mt;function Ye(u){if(it===void 0)try{throw Error()}catch(f){var c=f.stack.trim().match(/\n( *(at )?)/);it=c&&c[1]||"",mt=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+it+u+mt}var ot=!1;function gt(u,c){if(!u||ot)return"";ot=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(c){var xe=function(){throw Error()};if(Object.defineProperty(xe.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(xe,[])}catch(de){var ce=de}Reflect.construct(u,[],xe)}else{try{xe.call()}catch(de){ce=de}u.call(xe.prototype)}}else{try{throw Error()}catch(de){ce=de}(xe=u())&&typeof xe.catch=="function"&&xe.catch(function(){})}}catch(de){if(de&&ce&&typeof de.stack=="string")return[de.stack,ce.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var S=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");S&&S.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var T=g.DetermineComponentFrameRoot(),$=T[0],z=T[1];if($&&z){var H=$.split(`
`),ue=z.split(`
`);for(S=g=0;g<H.length&&!H[g].includes("DetermineComponentFrameRoot");)g++;for(;S<ue.length&&!ue[S].includes("DetermineComponentFrameRoot");)S++;if(g===H.length||S===ue.length)for(g=H.length-1,S=ue.length-1;1<=g&&0<=S&&H[g]!==ue[S];)S--;for(;1<=g&&0<=S;g--,S--)if(H[g]!==ue[S]){if(g!==1||S!==1)do if(g--,S--,0>S||H[g]!==ue[S]){var ge=`
`+H[g].replace(" at new "," at ");return u.displayName&&ge.includes("<anonymous>")&&(ge=ge.replace("<anonymous>",u.displayName)),ge}while(1<=g&&0<=S);break}}}finally{ot=!1,Error.prepareStackTrace=f}return(f=u?u.displayName||u.name:"")?Ye(f):""}function Pt(u,c){switch(u.tag){case 26:case 27:case 5:return Ye(u.type);case 16:return Ye("Lazy");case 13:return u.child!==c&&c!==null?Ye("Suspense Fallback"):Ye("Suspense");case 19:return Ye("SuspenseList");case 0:case 15:return gt(u.type,!1);case 11:return gt(u.type.render,!1);case 1:return gt(u.type,!0);case 31:return Ye("Activity");default:return""}}function _t(u){try{var c="",f=null;do c+=Pt(u,f),f=u,u=u.return;while(u);return c}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var nr=Object.prototype.hasOwnProperty,nn=n.unstable_scheduleCallback,kr=n.unstable_cancelCallback,Ts=n.unstable_shouldYield,Xi=n.unstable_requestPaint,Vt=n.unstable_now,Yr=n.unstable_getCurrentPriorityLevel,Jr=n.unstable_ImmediatePriority,Zr=n.unstable_UserBlockingPriority,sr=n.unstable_NormalPriority,Yo=n.unstable_LowPriority,Cu=n.unstable_IdlePriority,bd=n.log,Pw=n.unstable_setDisableYieldValue,Ci=null,Cs=null;function Ni(u){if(typeof bd=="function"&&Pw(u),Cs&&typeof Cs.setStrictMode=="function")try{Cs.setStrictMode(Ci,u)}catch{}}var rr=Math.clz32?Math.clz32:gj,pj=Math.log,mj=Math.LN2;function gj(u){return u>>>=0,u===0?32:31-(pj(u)/mj|0)|0}var cg=256,hg=262144,dg=4194304;function Jo(u){var c=u&42;if(c!==0)return c;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return u&261888;case 262144:case 524288:case 1048576:case 2097152:return u&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function fg(u,c,f){var g=u.pendingLanes;if(g===0)return 0;var S=0,T=u.suspendedLanes,$=u.pingedLanes;u=u.warmLanes;var z=g&134217727;return z!==0?(g=z&~T,g!==0?S=Jo(g):($&=z,$!==0?S=Jo($):f||(f=z&~u,f!==0&&(S=Jo(f))))):(z=g&~T,z!==0?S=Jo(z):$!==0?S=Jo($):f||(f=g&~u,f!==0&&(S=Jo(f)))),S===0?0:c!==0&&c!==S&&(c&T)===0&&(T=S&-S,f=c&-c,T>=f||T===32&&(f&4194048)!==0)?c:S}function xd(u,c){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&c)===0}function yj(u,c){switch(u){case 1:case 2:case 4:case 8:case 64:return c+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function bI(){var u=dg;return dg<<=1,(dg&62914560)===0&&(dg=4194304),u}function Bw(u){for(var c=[],f=0;31>f;f++)c.push(u);return c}function wd(u,c){u.pendingLanes|=c,c!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function bj(u,c,f,g,S,T){var $=u.pendingLanes;u.pendingLanes=f,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=f,u.entangledLanes&=f,u.errorRecoveryDisabledLanes&=f,u.shellSuspendCounter=0;var z=u.entanglements,H=u.expirationTimes,ue=u.hiddenUpdates;for(f=$&~f;0<f;){var ge=31-rr(f),xe=1<<ge;z[ge]=0,H[ge]=-1;var ce=ue[ge];if(ce!==null)for(ue[ge]=null,ge=0;ge<ce.length;ge++){var de=ce[ge];de!==null&&(de.lane&=-536870913)}f&=~xe}g!==0&&xI(u,g,0),T!==0&&S===0&&u.tag!==0&&(u.suspendedLanes|=T&~($&~c))}function xI(u,c,f){u.pendingLanes|=c,u.suspendedLanes&=~c;var g=31-rr(c);u.entangledLanes|=c,u.entanglements[g]=u.entanglements[g]|1073741824|f&261930}function wI(u,c){var f=u.entangledLanes|=c;for(u=u.entanglements;f;){var g=31-rr(f),S=1<<g;S&c|u[g]&c&&(u[g]|=c),f&=~S}}function vI(u,c){var f=c&-c;return f=(f&42)!==0?1:Vw(f),(f&(u.suspendedLanes|c))!==0?0:f}function Vw(u){switch(u){case 2:u=1;break;case 8:u=4;break;case 32:u=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:u=128;break;case 268435456:u=134217728;break;default:u=0}return u}function Uw(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function SI(){var u=U.p;return u!==0?u:(u=window.event,u===void 0?32:oR(u.type))}function TI(u,c){var f=U.p;try{return U.p=u,c()}finally{U.p=f}}var Ua=Math.random().toString(36).slice(2),ns="__reactFiber$"+Ua,Fs="__reactProps$"+Ua,Nu="__reactContainer$"+Ua,jw="__reactEvents$"+Ua,xj="__reactListeners$"+Ua,wj="__reactHandles$"+Ua,CI="__reactResources$"+Ua,vd="__reactMarker$"+Ua;function Ww(u){delete u[ns],delete u[Fs],delete u[jw],delete u[xj],delete u[wj]}function ku(u){var c=u[ns];if(c)return c;for(var f=u.parentNode;f;){if(c=f[Nu]||f[ns]){if(f=c.alternate,c.child!==null||f!==null&&f.child!==null)for(u=GA(u);u!==null;){if(f=u[ns])return f;u=GA(u)}return c}u=f,f=u.parentNode}return null}function Eu(u){if(u=u[ns]||u[Nu]){var c=u.tag;if(c===5||c===6||c===13||c===31||c===26||c===27||c===3)return u}return null}function Sd(u){var c=u.tag;if(c===5||c===26||c===27||c===6)return u.stateNode;throw Error(s(33))}function Iu(u){var c=u[CI];return c||(c=u[CI]={hoistableStyles:new Map,hoistableScripts:new Map}),c}function jn(u){u[vd]=!0}var NI=new Set,kI={};function Zo(u,c){$u(u,c),$u(u+"Capture",c)}function $u(u,c){for(kI[u]=c,u=0;u<c.length;u++)NI.add(c[u])}var vj=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),EI={},II={};function Sj(u){return nr.call(II,u)?!0:nr.call(EI,u)?!1:vj.test(u)?II[u]=!0:(EI[u]=!0,!1)}function pg(u,c,f){if(Sj(c))if(f===null)u.removeAttribute(c);else{switch(typeof f){case"undefined":case"function":case"symbol":u.removeAttribute(c);return;case"boolean":var g=c.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){u.removeAttribute(c);return}}u.setAttribute(c,""+f)}}function mg(u,c,f){if(f===null)u.removeAttribute(c);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(c);return}u.setAttribute(c,""+f)}}function Yi(u,c,f,g){if(g===null)u.removeAttribute(f);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(f);return}u.setAttributeNS(c,f,""+g)}}function Er(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function $I(u){var c=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function Tj(u,c,f){var g=Object.getOwnPropertyDescriptor(u.constructor.prototype,c);if(!u.hasOwnProperty(c)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var S=g.get,T=g.set;return Object.defineProperty(u,c,{configurable:!0,get:function(){return S.call(this)},set:function($){f=""+$,T.call(this,$)}}),Object.defineProperty(u,c,{enumerable:g.enumerable}),{getValue:function(){return f},setValue:function($){f=""+$},stopTracking:function(){u._valueTracker=null,delete u[c]}}}}function Gw(u){if(!u._valueTracker){var c=$I(u)?"checked":"value";u._valueTracker=Tj(u,c,""+u[c])}}function _I(u){if(!u)return!1;var c=u._valueTracker;if(!c)return!0;var f=c.getValue(),g="";return u&&(g=$I(u)?u.checked?"true":"false":u.value),u=g,u!==f?(c.setValue(u),!0):!1}function gg(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var Cj=/[\n"\\]/g;function Ir(u){return u.replace(Cj,function(c){return"\\"+c.charCodeAt(0).toString(16)+" "})}function Hw(u,c,f,g,S,T,$,z){u.name="",$!=null&&typeof $!="function"&&typeof $!="symbol"&&typeof $!="boolean"?u.type=$:u.removeAttribute("type"),c!=null?$==="number"?(c===0&&u.value===""||u.value!=c)&&(u.value=""+Er(c)):u.value!==""+Er(c)&&(u.value=""+Er(c)):$!=="submit"&&$!=="reset"||u.removeAttribute("value"),c!=null?qw(u,$,Er(c)):f!=null?qw(u,$,Er(f)):g!=null&&u.removeAttribute("value"),S==null&&T!=null&&(u.defaultChecked=!!T),S!=null&&(u.checked=S&&typeof S!="function"&&typeof S!="symbol"),z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?u.name=""+Er(z):u.removeAttribute("name")}function AI(u,c,f,g,S,T,$,z){if(T!=null&&typeof T!="function"&&typeof T!="symbol"&&typeof T!="boolean"&&(u.type=T),c!=null||f!=null){if(!(T!=="submit"&&T!=="reset"||c!=null)){Gw(u);return}f=f!=null?""+Er(f):"",c=c!=null?""+Er(c):f,z||c===u.value||(u.value=c),u.defaultValue=c}g=g??S,g=typeof g!="function"&&typeof g!="symbol"&&!!g,u.checked=z?u.checked:!!g,u.defaultChecked=!!g,$!=null&&typeof $!="function"&&typeof $!="symbol"&&typeof $!="boolean"&&(u.name=$),Gw(u)}function qw(u,c,f){c==="number"&&gg(u.ownerDocument)===u||u.defaultValue===""+f||(u.defaultValue=""+f)}function _u(u,c,f,g){if(u=u.options,c){c={};for(var S=0;S<f.length;S++)c["$"+f[S]]=!0;for(f=0;f<u.length;f++)S=c.hasOwnProperty("$"+u[f].value),u[f].selected!==S&&(u[f].selected=S),S&&g&&(u[f].defaultSelected=!0)}else{for(f=""+Er(f),c=null,S=0;S<u.length;S++){if(u[S].value===f){u[S].selected=!0,g&&(u[S].defaultSelected=!0);return}c!==null||u[S].disabled||(c=u[S])}c!==null&&(c.selected=!0)}}function RI(u,c,f){if(c!=null&&(c=""+Er(c),c!==u.value&&(u.value=c),f==null)){u.defaultValue!==c&&(u.defaultValue=c);return}u.defaultValue=f!=null?""+Er(f):""}function DI(u,c,f,g){if(c==null){if(g!=null){if(f!=null)throw Error(s(92));if(Z(g)){if(1<g.length)throw Error(s(93));g=g[0]}f=g}f==null&&(f=""),c=f}f=Er(c),u.defaultValue=f,g=u.textContent,g===f&&g!==""&&g!==null&&(u.value=g),Gw(u)}function Au(u,c){if(c){var f=u.firstChild;if(f&&f===u.lastChild&&f.nodeType===3){f.nodeValue=c;return}}u.textContent=c}var Nj=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function OI(u,c,f){var g=c.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?g?u.setProperty(c,""):c==="float"?u.cssFloat="":u[c]="":g?u.setProperty(c,f):typeof f!="number"||f===0||Nj.has(c)?c==="float"?u.cssFloat=f:u[c]=(""+f).trim():u[c]=f+"px"}function LI(u,c,f){if(c!=null&&typeof c!="object")throw Error(s(62));if(u=u.style,f!=null){for(var g in f)!f.hasOwnProperty(g)||c!=null&&c.hasOwnProperty(g)||(g.indexOf("--")===0?u.setProperty(g,""):g==="float"?u.cssFloat="":u[g]="");for(var S in c)g=c[S],c.hasOwnProperty(S)&&f[S]!==g&&OI(u,S,g)}else for(var T in c)c.hasOwnProperty(T)&&OI(u,T,c[T])}function Kw(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var kj=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Ej=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function yg(u){return Ej.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}function Ji(){}var Xw=null;function Yw(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Ru=null,Du=null;function FI(u){var c=Eu(u);if(c&&(u=c.stateNode)){var f=u[Fs]||null;e:switch(u=c.stateNode,c.type){case"input":if(Hw(u,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),c=f.name,f.type==="radio"&&c!=null){for(f=u;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+Ir(""+c)+'"][type="radio"]'),c=0;c<f.length;c++){var g=f[c];if(g!==u&&g.form===u.form){var S=g[Fs]||null;if(!S)throw Error(s(90));Hw(g,S.value,S.defaultValue,S.defaultValue,S.checked,S.defaultChecked,S.type,S.name)}}for(c=0;c<f.length;c++)g=f[c],g.form===u.form&&_I(g)}break e;case"textarea":RI(u,f.value,f.defaultValue);break e;case"select":c=f.value,c!=null&&_u(u,!!f.multiple,c,!1)}}}var Jw=!1;function MI(u,c,f){if(Jw)return u(c,f);Jw=!0;try{var g=u(c);return g}finally{if(Jw=!1,(Ru!==null||Du!==null)&&(ry(),Ru&&(c=Ru,u=Du,Du=Ru=null,FI(c),u)))for(c=0;c<u.length;c++)FI(u[c])}}function Td(u,c){var f=u.stateNode;if(f===null)return null;var g=f[Fs]||null;if(g===null)return null;f=g[c];e:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(u=u.type,g=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!g;break e;default:u=!1}if(u)return null;if(f&&typeof f!="function")throw Error(s(231,c,typeof f));return f}var Zi=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Zw=!1;if(Zi)try{var Cd={};Object.defineProperty(Cd,"passive",{get:function(){Zw=!0}}),window.addEventListener("test",Cd,Cd),window.removeEventListener("test",Cd,Cd)}catch{Zw=!1}var ja=null,Qw=null,bg=null;function zI(){if(bg)return bg;var u,c=Qw,f=c.length,g,S="value"in ja?ja.value:ja.textContent,T=S.length;for(u=0;u<f&&c[u]===S[u];u++);var $=f-u;for(g=1;g<=$&&c[f-g]===S[T-g];g++);return bg=S.slice(u,1<g?1-g:void 0)}function xg(u){var c=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&c===13&&(u=13)):u=c,u===10&&(u=13),32<=u||u===13?u:0}function wg(){return!0}function PI(){return!1}function Ms(u){function c(f,g,S,T,$){this._reactName=f,this._targetInst=S,this.type=g,this.nativeEvent=T,this.target=$,this.currentTarget=null;for(var z in u)u.hasOwnProperty(z)&&(f=u[z],this[z]=f?f(T):T[z]);return this.isDefaultPrevented=(T.defaultPrevented!=null?T.defaultPrevented:T.returnValue===!1)?wg:PI,this.isPropagationStopped=PI,this}return p(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=wg)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=wg)},persist:function(){},isPersistent:wg}),c}var Qo={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},vg=Ms(Qo),Nd=p({},Qo,{view:0,detail:0}),Ij=Ms(Nd),ev,tv,kd,Sg=p({},Nd,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:sv,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==kd&&(kd&&u.type==="mousemove"?(ev=u.screenX-kd.screenX,tv=u.screenY-kd.screenY):tv=ev=0,kd=u),ev)},movementY:function(u){return"movementY"in u?u.movementY:tv}}),BI=Ms(Sg),$j=p({},Sg,{dataTransfer:0}),_j=Ms($j),Aj=p({},Nd,{relatedTarget:0}),nv=Ms(Aj),Rj=p({},Qo,{animationName:0,elapsedTime:0,pseudoElement:0}),Dj=Ms(Rj),Oj=p({},Qo,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),Lj=Ms(Oj),Fj=p({},Qo,{data:0}),VI=Ms(Fj),Mj={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},zj={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Pj={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Bj(u){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(u):(u=Pj[u])?!!c[u]:!1}function sv(){return Bj}var Vj=p({},Nd,{key:function(u){if(u.key){var c=Mj[u.key]||u.key;if(c!=="Unidentified")return c}return u.type==="keypress"?(u=xg(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?zj[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:sv,charCode:function(u){return u.type==="keypress"?xg(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?xg(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),Uj=Ms(Vj),jj=p({},Sg,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),UI=Ms(jj),Wj=p({},Nd,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:sv}),Gj=Ms(Wj),Hj=p({},Qo,{propertyName:0,elapsedTime:0,pseudoElement:0}),qj=Ms(Hj),Kj=p({},Sg,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),Xj=Ms(Kj),Yj=p({},Qo,{newState:0,oldState:0}),Jj=Ms(Yj),Zj=[9,13,27,32],rv=Zi&&"CompositionEvent"in window,Ed=null;Zi&&"documentMode"in document&&(Ed=document.documentMode);var Qj=Zi&&"TextEvent"in window&&!Ed,jI=Zi&&(!rv||Ed&&8<Ed&&11>=Ed),WI=" ",GI=!1;function HI(u,c){switch(u){case"keyup":return Zj.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function qI(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var Ou=!1;function eW(u,c){switch(u){case"compositionend":return qI(c);case"keypress":return c.which!==32?null:(GI=!0,WI);case"textInput":return u=c.data,u===WI&&GI?null:u;default:return null}}function tW(u,c){if(Ou)return u==="compositionend"||!rv&&HI(u,c)?(u=zI(),bg=Qw=ja=null,Ou=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return jI&&c.locale!=="ko"?null:c.data;default:return null}}var nW={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function KI(u){var c=u&&u.nodeName&&u.nodeName.toLowerCase();return c==="input"?!!nW[u.type]:c==="textarea"}function XI(u,c,f,g){Ru?Du?Du.push(g):Du=[g]:Ru=g,c=hy(c,"onChange"),0<c.length&&(f=new vg("onChange","change",null,f,g),u.push({event:f,listeners:c}))}var Id=null,$d=null;function sW(u){AA(u,0)}function Tg(u){var c=Sd(u);if(_I(c))return u}function YI(u,c){if(u==="change")return c}var JI=!1;if(Zi){var iv;if(Zi){var av="oninput"in document;if(!av){var ZI=document.createElement("div");ZI.setAttribute("oninput","return;"),av=typeof ZI.oninput=="function"}iv=av}else iv=!1;JI=iv&&(!document.documentMode||9<document.documentMode)}function QI(){Id&&(Id.detachEvent("onpropertychange",e$),$d=Id=null)}function e$(u){if(u.propertyName==="value"&&Tg($d)){var c=[];XI(c,$d,u,Yw(u)),MI(sW,c)}}function rW(u,c,f){u==="focusin"?(QI(),Id=c,$d=f,Id.attachEvent("onpropertychange",e$)):u==="focusout"&&QI()}function iW(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return Tg($d)}function aW(u,c){if(u==="click")return Tg(c)}function oW(u,c){if(u==="input"||u==="change")return Tg(c)}function lW(u,c){return u===c&&(u!==0||1/u===1/c)||u!==u&&c!==c}var ir=typeof Object.is=="function"?Object.is:lW;function _d(u,c){if(ir(u,c))return!0;if(typeof u!="object"||u===null||typeof c!="object"||c===null)return!1;var f=Object.keys(u),g=Object.keys(c);if(f.length!==g.length)return!1;for(g=0;g<f.length;g++){var S=f[g];if(!nr.call(c,S)||!ir(u[S],c[S]))return!1}return!0}function t$(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function n$(u,c){var f=t$(u);u=0;for(var g;f;){if(f.nodeType===3){if(g=u+f.textContent.length,u<=c&&g>=c)return{node:f,offset:c-u};u=g}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=t$(f)}}function s$(u,c){return u&&c?u===c?!0:u&&u.nodeType===3?!1:c&&c.nodeType===3?s$(u,c.parentNode):"contains"in u?u.contains(c):u.compareDocumentPosition?!!(u.compareDocumentPosition(c)&16):!1:!1}function r$(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var c=gg(u.document);c instanceof u.HTMLIFrameElement;){try{var f=typeof c.contentWindow.location.href=="string"}catch{f=!1}if(f)u=c.contentWindow;else break;c=gg(u.document)}return c}function ov(u){var c=u&&u.nodeName&&u.nodeName.toLowerCase();return c&&(c==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||c==="textarea"||u.contentEditable==="true")}var uW=Zi&&"documentMode"in document&&11>=document.documentMode,Lu=null,lv=null,Ad=null,uv=!1;function i$(u,c,f){var g=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;uv||Lu==null||Lu!==gg(g)||(g=Lu,"selectionStart"in g&&ov(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),Ad&&_d(Ad,g)||(Ad=g,g=hy(lv,"onSelect"),0<g.length&&(c=new vg("onSelect","select",null,c,f),u.push({event:c,listeners:g}),c.target=Lu)))}function el(u,c){var f={};return f[u.toLowerCase()]=c.toLowerCase(),f["Webkit"+u]="webkit"+c,f["Moz"+u]="moz"+c,f}var Fu={animationend:el("Animation","AnimationEnd"),animationiteration:el("Animation","AnimationIteration"),animationstart:el("Animation","AnimationStart"),transitionrun:el("Transition","TransitionRun"),transitionstart:el("Transition","TransitionStart"),transitioncancel:el("Transition","TransitionCancel"),transitionend:el("Transition","TransitionEnd")},cv={},a$={};Zi&&(a$=document.createElement("div").style,"AnimationEvent"in window||(delete Fu.animationend.animation,delete Fu.animationiteration.animation,delete Fu.animationstart.animation),"TransitionEvent"in window||delete Fu.transitionend.transition);function tl(u){if(cv[u])return cv[u];if(!Fu[u])return u;var c=Fu[u],f;for(f in c)if(c.hasOwnProperty(f)&&f in a$)return cv[u]=c[f];return u}var o$=tl("animationend"),l$=tl("animationiteration"),u$=tl("animationstart"),cW=tl("transitionrun"),hW=tl("transitionstart"),dW=tl("transitioncancel"),c$=tl("transitionend"),h$=new Map,hv="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");hv.push("scrollEnd");function Qr(u,c){h$.set(u,c),Zo(c,[u])}var Cg=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var c=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(c))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",u);return}console.error(u)},$r=[],Mu=0,dv=0;function Ng(){for(var u=Mu,c=dv=Mu=0;c<u;){var f=$r[c];$r[c++]=null;var g=$r[c];$r[c++]=null;var S=$r[c];$r[c++]=null;var T=$r[c];if($r[c++]=null,g!==null&&S!==null){var $=g.pending;$===null?S.next=S:(S.next=$.next,$.next=S),g.pending=S}T!==0&&d$(f,S,T)}}function kg(u,c,f,g){$r[Mu++]=u,$r[Mu++]=c,$r[Mu++]=f,$r[Mu++]=g,dv|=g,u.lanes|=g,u=u.alternate,u!==null&&(u.lanes|=g)}function fv(u,c,f,g){return kg(u,c,f,g),Eg(u)}function nl(u,c){return kg(u,null,null,c),Eg(u)}function d$(u,c,f){u.lanes|=f;var g=u.alternate;g!==null&&(g.lanes|=f);for(var S=!1,T=u.return;T!==null;)T.childLanes|=f,g=T.alternate,g!==null&&(g.childLanes|=f),T.tag===22&&(u=T.stateNode,u===null||u._visibility&1||(S=!0)),u=T,T=T.return;return u.tag===3?(T=u.stateNode,S&&c!==null&&(S=31-rr(f),u=T.hiddenUpdates,g=u[S],g===null?u[S]=[c]:g.push(c),c.lane=f|536870912),T):null}function Eg(u){if(50<Qd)throw Qd=0,S1=null,Error(s(185));for(var c=u.return;c!==null;)u=c,c=u.return;return u.tag===3?u.stateNode:null}var zu={};function fW(u,c,f,g){this.tag=u,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ar(u,c,f,g){return new fW(u,c,f,g)}function pv(u){return u=u.prototype,!(!u||!u.isReactComponent)}function Qi(u,c){var f=u.alternate;return f===null?(f=ar(u.tag,c,u.key,u.mode),f.elementType=u.elementType,f.type=u.type,f.stateNode=u.stateNode,f.alternate=u,u.alternate=f):(f.pendingProps=c,f.type=u.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=u.flags&65011712,f.childLanes=u.childLanes,f.lanes=u.lanes,f.child=u.child,f.memoizedProps=u.memoizedProps,f.memoizedState=u.memoizedState,f.updateQueue=u.updateQueue,c=u.dependencies,f.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},f.sibling=u.sibling,f.index=u.index,f.ref=u.ref,f.refCleanup=u.refCleanup,f}function f$(u,c){u.flags&=65011714;var f=u.alternate;return f===null?(u.childLanes=0,u.lanes=c,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=f.childLanes,u.lanes=f.lanes,u.child=f.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=f.memoizedProps,u.memoizedState=f.memoizedState,u.updateQueue=f.updateQueue,u.type=f.type,c=f.dependencies,u.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext}),u}function Ig(u,c,f,g,S,T){var $=0;if(g=u,typeof u=="function")pv(u)&&($=1);else if(typeof u=="string")$=bG(u,f,le.current)?26:u==="html"||u==="head"||u==="body"?27:5;else e:switch(u){case L:return u=ar(31,f,c,S),u.elementType=L,u.lanes=T,u;case x:return sl(f.children,S,T,c);case w:$=8,S|=24;break;case v:return u=ar(12,f,c,S|2),u.elementType=v,u.lanes=T,u;case E:return u=ar(13,f,c,S),u.elementType=E,u.lanes=T,u;case A:return u=ar(19,f,c,S),u.elementType=A,u.lanes=T,u;default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case N:$=10;break e;case C:$=9;break e;case k:$=11;break e;case R:$=14;break e;case D:$=16,g=null;break e}$=29,f=Error(s(130,u===null?"null":typeof u,"")),g=null}return c=ar($,f,c,S),c.elementType=u,c.type=g,c.lanes=T,c}function sl(u,c,f,g){return u=ar(7,u,g,c),u.lanes=f,u}function mv(u,c,f){return u=ar(6,u,null,c),u.lanes=f,u}function p$(u){var c=ar(18,null,null,0);return c.stateNode=u,c}function gv(u,c,f){return c=ar(4,u.children!==null?u.children:[],u.key,c),c.lanes=f,c.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},c}var m$=new WeakMap;function _r(u,c){if(typeof u=="object"&&u!==null){var f=m$.get(u);return f!==void 0?f:(c={value:u,source:c,stack:_t(c)},m$.set(u,c),c)}return{value:u,source:c,stack:_t(c)}}var Pu=[],Bu=0,$g=null,Rd=0,Ar=[],Rr=0,Wa=null,ki=1,Ei="";function ea(u,c){Pu[Bu++]=Rd,Pu[Bu++]=$g,$g=u,Rd=c}function g$(u,c,f){Ar[Rr++]=ki,Ar[Rr++]=Ei,Ar[Rr++]=Wa,Wa=u;var g=ki;u=Ei;var S=32-rr(g)-1;g&=~(1<<S),f+=1;var T=32-rr(c)+S;if(30<T){var $=S-S%5;T=(g&(1<<$)-1).toString(32),g>>=$,S-=$,ki=1<<32-rr(c)+S|f<<S|g,Ei=T+u}else ki=1<<T|f<<S|g,Ei=u}function yv(u){u.return!==null&&(ea(u,1),g$(u,1,0))}function bv(u){for(;u===$g;)$g=Pu[--Bu],Pu[Bu]=null,Rd=Pu[--Bu],Pu[Bu]=null;for(;u===Wa;)Wa=Ar[--Rr],Ar[Rr]=null,Ei=Ar[--Rr],Ar[Rr]=null,ki=Ar[--Rr],Ar[Rr]=null}function y$(u,c){Ar[Rr++]=ki,Ar[Rr++]=Ei,Ar[Rr++]=Wa,ki=c.id,Ei=c.overflow,Wa=u}var ss=null,Ut=null,yt=!1,Ga=null,Dr=!1,xv=Error(s(519));function Ha(u){var c=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Dd(_r(c,u)),xv}function b$(u){var c=u.stateNode,f=u.type,g=u.memoizedProps;switch(c[ns]=u,c[Fs]=g,f){case"dialog":ct("cancel",c),ct("close",c);break;case"iframe":case"object":case"embed":ct("load",c);break;case"video":case"audio":for(f=0;f<tf.length;f++)ct(tf[f],c);break;case"source":ct("error",c);break;case"img":case"image":case"link":ct("error",c),ct("load",c);break;case"details":ct("toggle",c);break;case"input":ct("invalid",c),AI(c,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":ct("invalid",c);break;case"textarea":ct("invalid",c),DI(c,g.value,g.defaultValue,g.children)}f=g.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||c.textContent===""+f||g.suppressHydrationWarning===!0||LA(c.textContent,f)?(g.popover!=null&&(ct("beforetoggle",c),ct("toggle",c)),g.onScroll!=null&&ct("scroll",c),g.onScrollEnd!=null&&ct("scrollend",c),g.onClick!=null&&(c.onclick=Ji),c=!0):c=!1,c||Ha(u,!0)}function x$(u){for(ss=u.return;ss;)switch(ss.tag){case 5:case 31:case 13:Dr=!1;return;case 27:case 3:Dr=!0;return;default:ss=ss.return}}function Vu(u){if(u!==ss)return!1;if(!yt)return x$(u),yt=!0,!1;var c=u.tag,f;if((f=c!==3&&c!==27)&&((f=c===5)&&(f=u.type,f=!(f!=="form"&&f!=="button")||M1(u.type,u.memoizedProps)),f=!f),f&&Ut&&Ha(u),x$(u),c===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Ut=WA(u)}else if(c===31){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Ut=WA(u)}else c===27?(c=Ut,ao(u.type)?(u=U1,U1=null,Ut=u):Ut=c):Ut=ss?Lr(u.stateNode.nextSibling):null;return!0}function rl(){Ut=ss=null,yt=!1}function wv(){var u=Ga;return u!==null&&(Vs===null?Vs=u:Vs.push.apply(Vs,u),Ga=null),u}function Dd(u){Ga===null?Ga=[u]:Ga.push(u)}var vv=P(null),il=null,ta=null;function qa(u,c,f){te(vv,c._currentValue),c._currentValue=f}function na(u){u._currentValue=vv.current,j(vv)}function Sv(u,c,f){for(;u!==null;){var g=u.alternate;if((u.childLanes&c)!==c?(u.childLanes|=c,g!==null&&(g.childLanes|=c)):g!==null&&(g.childLanes&c)!==c&&(g.childLanes|=c),u===f)break;u=u.return}}function Tv(u,c,f,g){var S=u.child;for(S!==null&&(S.return=u);S!==null;){var T=S.dependencies;if(T!==null){var $=S.child;T=T.firstContext;e:for(;T!==null;){var z=T;T=S;for(var H=0;H<c.length;H++)if(z.context===c[H]){T.lanes|=f,z=T.alternate,z!==null&&(z.lanes|=f),Sv(T.return,f,u),g||($=null);break e}T=z.next}}else if(S.tag===18){if($=S.return,$===null)throw Error(s(341));$.lanes|=f,T=$.alternate,T!==null&&(T.lanes|=f),Sv($,f,u),$=null}else $=S.child;if($!==null)$.return=S;else for($=S;$!==null;){if($===u){$=null;break}if(S=$.sibling,S!==null){S.return=$.return,$=S;break}$=$.return}S=$}}function Uu(u,c,f,g){u=null;for(var S=c,T=!1;S!==null;){if(!T){if((S.flags&524288)!==0)T=!0;else if((S.flags&262144)!==0)break}if(S.tag===10){var $=S.alternate;if($===null)throw Error(s(387));if($=$.memoizedProps,$!==null){var z=S.type;ir(S.pendingProps.value,$.value)||(u!==null?u.push(z):u=[z])}}else if(S===Te.current){if($=S.alternate,$===null)throw Error(s(387));$.memoizedState.memoizedState!==S.memoizedState.memoizedState&&(u!==null?u.push(of):u=[of])}S=S.return}u!==null&&Tv(c,u,f,g),c.flags|=262144}function _g(u){for(u=u.firstContext;u!==null;){if(!ir(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function al(u){il=u,ta=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function rs(u){return w$(il,u)}function Ag(u,c){return il===null&&al(u),w$(u,c)}function w$(u,c){var f=c._currentValue;if(c={context:c,memoizedValue:f,next:null},ta===null){if(u===null)throw Error(s(308));ta=c,u.dependencies={lanes:0,firstContext:c},u.flags|=524288}else ta=ta.next=c;return f}var pW=typeof AbortController<"u"?AbortController:function(){var u=[],c=this.signal={aborted:!1,addEventListener:function(f,g){u.push(g)}};this.abort=function(){c.aborted=!0,u.forEach(function(f){return f()})}},mW=n.unstable_scheduleCallback,gW=n.unstable_NormalPriority,wn={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Cv(){return{controller:new pW,data:new Map,refCount:0}}function Od(u){u.refCount--,u.refCount===0&&mW(gW,function(){u.controller.abort()})}var Ld=null,Nv=0,ju=0,Wu=null;function yW(u,c){if(Ld===null){var f=Ld=[];Nv=0,ju=I1(),Wu={status:"pending",value:void 0,then:function(g){f.push(g)}}}return Nv++,c.then(v$,v$),c}function v$(){if(--Nv===0&&Ld!==null){Wu!==null&&(Wu.status="fulfilled");var u=Ld;Ld=null,ju=0,Wu=null;for(var c=0;c<u.length;c++)(0,u[c])()}}function bW(u,c){var f=[],g={status:"pending",value:null,reason:null,then:function(S){f.push(S)}};return u.then(function(){g.status="fulfilled",g.value=c;for(var S=0;S<f.length;S++)(0,f[S])(c)},function(S){for(g.status="rejected",g.reason=S,S=0;S<f.length;S++)(0,f[S])(void 0)}),g}var S$=B.S;B.S=function(u,c){iA=Vt(),typeof c=="object"&&c!==null&&typeof c.then=="function"&&yW(u,c),S$!==null&&S$(u,c)};var ol=P(null);function kv(){var u=ol.current;return u!==null?u:Lt.pooledCache}function Rg(u,c){c===null?te(ol,ol.current):te(ol,c.pool)}function T$(){var u=kv();return u===null?null:{parent:wn._currentValue,pool:u}}var Gu=Error(s(460)),Ev=Error(s(474)),Dg=Error(s(542)),Og={then:function(){}};function C$(u){return u=u.status,u==="fulfilled"||u==="rejected"}function N$(u,c,f){switch(f=u[f],f===void 0?u.push(c):f!==c&&(c.then(Ji,Ji),c=f),c.status){case"fulfilled":return c.value;case"rejected":throw u=c.reason,E$(u),u;default:if(typeof c.status=="string")c.then(Ji,Ji);else{if(u=Lt,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=c,u.status="pending",u.then(function(g){if(c.status==="pending"){var S=c;S.status="fulfilled",S.value=g}},function(g){if(c.status==="pending"){var S=c;S.status="rejected",S.reason=g}})}switch(c.status){case"fulfilled":return c.value;case"rejected":throw u=c.reason,E$(u),u}throw ul=c,Gu}}function ll(u){try{var c=u._init;return c(u._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(ul=f,Gu):f}}var ul=null;function k$(){if(ul===null)throw Error(s(459));var u=ul;return ul=null,u}function E$(u){if(u===Gu||u===Dg)throw Error(s(483))}var Hu=null,Fd=0;function Lg(u){var c=Fd;return Fd+=1,Hu===null&&(Hu=[]),N$(Hu,u,c)}function Md(u,c){c=c.props.ref,u.ref=c!==void 0?c:null}function Fg(u,c){throw c.$$typeof===m?Error(s(525)):(u=Object.prototype.toString.call(c),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":u)))}function I$(u){function c(ie,ee){if(u){var oe=ie.deletions;oe===null?(ie.deletions=[ee],ie.flags|=16):oe.push(ee)}}function f(ie,ee){if(!u)return null;for(;ee!==null;)c(ie,ee),ee=ee.sibling;return null}function g(ie){for(var ee=new Map;ie!==null;)ie.key!==null?ee.set(ie.key,ie):ee.set(ie.index,ie),ie=ie.sibling;return ee}function S(ie,ee){return ie=Qi(ie,ee),ie.index=0,ie.sibling=null,ie}function T(ie,ee,oe){return ie.index=oe,u?(oe=ie.alternate,oe!==null?(oe=oe.index,oe<ee?(ie.flags|=67108866,ee):oe):(ie.flags|=67108866,ee)):(ie.flags|=1048576,ee)}function $(ie){return u&&ie.alternate===null&&(ie.flags|=67108866),ie}function z(ie,ee,oe,ye){return ee===null||ee.tag!==6?(ee=mv(oe,ie.mode,ye),ee.return=ie,ee):(ee=S(ee,oe),ee.return=ie,ee)}function H(ie,ee,oe,ye){var Ue=oe.type;return Ue===x?ge(ie,ee,oe.props.children,ye,oe.key):ee!==null&&(ee.elementType===Ue||typeof Ue=="object"&&Ue!==null&&Ue.$$typeof===D&&ll(Ue)===ee.type)?(ee=S(ee,oe.props),Md(ee,oe),ee.return=ie,ee):(ee=Ig(oe.type,oe.key,oe.props,null,ie.mode,ye),Md(ee,oe),ee.return=ie,ee)}function ue(ie,ee,oe,ye){return ee===null||ee.tag!==4||ee.stateNode.containerInfo!==oe.containerInfo||ee.stateNode.implementation!==oe.implementation?(ee=gv(oe,ie.mode,ye),ee.return=ie,ee):(ee=S(ee,oe.children||[]),ee.return=ie,ee)}function ge(ie,ee,oe,ye,Ue){return ee===null||ee.tag!==7?(ee=sl(oe,ie.mode,ye,Ue),ee.return=ie,ee):(ee=S(ee,oe),ee.return=ie,ee)}function xe(ie,ee,oe){if(typeof ee=="string"&&ee!==""||typeof ee=="number"||typeof ee=="bigint")return ee=mv(""+ee,ie.mode,oe),ee.return=ie,ee;if(typeof ee=="object"&&ee!==null){switch(ee.$$typeof){case y:return oe=Ig(ee.type,ee.key,ee.props,null,ie.mode,oe),Md(oe,ee),oe.return=ie,oe;case b:return ee=gv(ee,ie.mode,oe),ee.return=ie,ee;case D:return ee=ll(ee),xe(ie,ee,oe)}if(Z(ee)||V(ee))return ee=sl(ee,ie.mode,oe,null),ee.return=ie,ee;if(typeof ee.then=="function")return xe(ie,Lg(ee),oe);if(ee.$$typeof===N)return xe(ie,Ag(ie,ee),oe);Fg(ie,ee)}return null}function ce(ie,ee,oe,ye){var Ue=ee!==null?ee.key:null;if(typeof oe=="string"&&oe!==""||typeof oe=="number"||typeof oe=="bigint")return Ue!==null?null:z(ie,ee,""+oe,ye);if(typeof oe=="object"&&oe!==null){switch(oe.$$typeof){case y:return oe.key===Ue?H(ie,ee,oe,ye):null;case b:return oe.key===Ue?ue(ie,ee,oe,ye):null;case D:return oe=ll(oe),ce(ie,ee,oe,ye)}if(Z(oe)||V(oe))return Ue!==null?null:ge(ie,ee,oe,ye,null);if(typeof oe.then=="function")return ce(ie,ee,Lg(oe),ye);if(oe.$$typeof===N)return ce(ie,ee,Ag(ie,oe),ye);Fg(ie,oe)}return null}function de(ie,ee,oe,ye,Ue){if(typeof ye=="string"&&ye!==""||typeof ye=="number"||typeof ye=="bigint")return ie=ie.get(oe)||null,z(ee,ie,""+ye,Ue);if(typeof ye=="object"&&ye!==null){switch(ye.$$typeof){case y:return ie=ie.get(ye.key===null?oe:ye.key)||null,H(ee,ie,ye,Ue);case b:return ie=ie.get(ye.key===null?oe:ye.key)||null,ue(ee,ie,ye,Ue);case D:return ye=ll(ye),de(ie,ee,oe,ye,Ue)}if(Z(ye)||V(ye))return ie=ie.get(oe)||null,ge(ee,ie,ye,Ue,null);if(typeof ye.then=="function")return de(ie,ee,oe,Lg(ye),Ue);if(ye.$$typeof===N)return de(ie,ee,oe,Ag(ee,ye),Ue);Fg(ee,ye)}return null}function De(ie,ee,oe,ye){for(var Ue=null,vt=null,Me=ee,tt=ee=0,pt=null;Me!==null&&tt<oe.length;tt++){Me.index>tt?(pt=Me,Me=null):pt=Me.sibling;var St=ce(ie,Me,oe[tt],ye);if(St===null){Me===null&&(Me=pt);break}u&&Me&&St.alternate===null&&c(ie,Me),ee=T(St,ee,tt),vt===null?Ue=St:vt.sibling=St,vt=St,Me=pt}if(tt===oe.length)return f(ie,Me),yt&&ea(ie,tt),Ue;if(Me===null){for(;tt<oe.length;tt++)Me=xe(ie,oe[tt],ye),Me!==null&&(ee=T(Me,ee,tt),vt===null?Ue=Me:vt.sibling=Me,vt=Me);return yt&&ea(ie,tt),Ue}for(Me=g(Me);tt<oe.length;tt++)pt=de(Me,ie,tt,oe[tt],ye),pt!==null&&(u&&pt.alternate!==null&&Me.delete(pt.key===null?tt:pt.key),ee=T(pt,ee,tt),vt===null?Ue=pt:vt.sibling=pt,vt=pt);return u&&Me.forEach(function(ho){return c(ie,ho)}),yt&&ea(ie,tt),Ue}function je(ie,ee,oe,ye){if(oe==null)throw Error(s(151));for(var Ue=null,vt=null,Me=ee,tt=ee=0,pt=null,St=oe.next();Me!==null&&!St.done;tt++,St=oe.next()){Me.index>tt?(pt=Me,Me=null):pt=Me.sibling;var ho=ce(ie,Me,St.value,ye);if(ho===null){Me===null&&(Me=pt);break}u&&Me&&ho.alternate===null&&c(ie,Me),ee=T(ho,ee,tt),vt===null?Ue=ho:vt.sibling=ho,vt=ho,Me=pt}if(St.done)return f(ie,Me),yt&&ea(ie,tt),Ue;if(Me===null){for(;!St.done;tt++,St=oe.next())St=xe(ie,St.value,ye),St!==null&&(ee=T(St,ee,tt),vt===null?Ue=St:vt.sibling=St,vt=St);return yt&&ea(ie,tt),Ue}for(Me=g(Me);!St.done;tt++,St=oe.next())St=de(Me,ie,tt,St.value,ye),St!==null&&(u&&St.alternate!==null&&Me.delete(St.key===null?tt:St.key),ee=T(St,ee,tt),vt===null?Ue=St:vt.sibling=St,vt=St);return u&&Me.forEach(function($G){return c(ie,$G)}),yt&&ea(ie,tt),Ue}function Dt(ie,ee,oe,ye){if(typeof oe=="object"&&oe!==null&&oe.type===x&&oe.key===null&&(oe=oe.props.children),typeof oe=="object"&&oe!==null){switch(oe.$$typeof){case y:e:{for(var Ue=oe.key;ee!==null;){if(ee.key===Ue){if(Ue=oe.type,Ue===x){if(ee.tag===7){f(ie,ee.sibling),ye=S(ee,oe.props.children),ye.return=ie,ie=ye;break e}}else if(ee.elementType===Ue||typeof Ue=="object"&&Ue!==null&&Ue.$$typeof===D&&ll(Ue)===ee.type){f(ie,ee.sibling),ye=S(ee,oe.props),Md(ye,oe),ye.return=ie,ie=ye;break e}f(ie,ee);break}else c(ie,ee);ee=ee.sibling}oe.type===x?(ye=sl(oe.props.children,ie.mode,ye,oe.key),ye.return=ie,ie=ye):(ye=Ig(oe.type,oe.key,oe.props,null,ie.mode,ye),Md(ye,oe),ye.return=ie,ie=ye)}return $(ie);case b:e:{for(Ue=oe.key;ee!==null;){if(ee.key===Ue)if(ee.tag===4&&ee.stateNode.containerInfo===oe.containerInfo&&ee.stateNode.implementation===oe.implementation){f(ie,ee.sibling),ye=S(ee,oe.children||[]),ye.return=ie,ie=ye;break e}else{f(ie,ee);break}else c(ie,ee);ee=ee.sibling}ye=gv(oe,ie.mode,ye),ye.return=ie,ie=ye}return $(ie);case D:return oe=ll(oe),Dt(ie,ee,oe,ye)}if(Z(oe))return De(ie,ee,oe,ye);if(V(oe)){if(Ue=V(oe),typeof Ue!="function")throw Error(s(150));return oe=Ue.call(oe),je(ie,ee,oe,ye)}if(typeof oe.then=="function")return Dt(ie,ee,Lg(oe),ye);if(oe.$$typeof===N)return Dt(ie,ee,Ag(ie,oe),ye);Fg(ie,oe)}return typeof oe=="string"&&oe!==""||typeof oe=="number"||typeof oe=="bigint"?(oe=""+oe,ee!==null&&ee.tag===6?(f(ie,ee.sibling),ye=S(ee,oe),ye.return=ie,ie=ye):(f(ie,ee),ye=mv(oe,ie.mode,ye),ye.return=ie,ie=ye),$(ie)):f(ie,ee)}return function(ie,ee,oe,ye){try{Fd=0;var Ue=Dt(ie,ee,oe,ye);return Hu=null,Ue}catch(Me){if(Me===Gu||Me===Dg)throw Me;var vt=ar(29,Me,null,ie.mode);return vt.lanes=ye,vt.return=ie,vt}}}var cl=I$(!0),$$=I$(!1),Ka=!1;function Iv(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function $v(u,c){u=u.updateQueue,c.updateQueue===u&&(c.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function Xa(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function Ya(u,c,f){var g=u.updateQueue;if(g===null)return null;if(g=g.shared,(Tt&2)!==0){var S=g.pending;return S===null?c.next=c:(c.next=S.next,S.next=c),g.pending=c,c=Eg(u),d$(u,null,f),c}return kg(u,g,c,f),Eg(u)}function zd(u,c,f){if(c=c.updateQueue,c!==null&&(c=c.shared,(f&4194048)!==0)){var g=c.lanes;g&=u.pendingLanes,f|=g,c.lanes=f,wI(u,f)}}function _v(u,c){var f=u.updateQueue,g=u.alternate;if(g!==null&&(g=g.updateQueue,f===g)){var S=null,T=null;if(f=f.firstBaseUpdate,f!==null){do{var $={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};T===null?S=T=$:T=T.next=$,f=f.next}while(f!==null);T===null?S=T=c:T=T.next=c}else S=T=c;f={baseState:g.baseState,firstBaseUpdate:S,lastBaseUpdate:T,shared:g.shared,callbacks:g.callbacks},u.updateQueue=f;return}u=f.lastBaseUpdate,u===null?f.firstBaseUpdate=c:u.next=c,f.lastBaseUpdate=c}var Av=!1;function Pd(){if(Av){var u=Wu;if(u!==null)throw u}}function Bd(u,c,f,g){Av=!1;var S=u.updateQueue;Ka=!1;var T=S.firstBaseUpdate,$=S.lastBaseUpdate,z=S.shared.pending;if(z!==null){S.shared.pending=null;var H=z,ue=H.next;H.next=null,$===null?T=ue:$.next=ue,$=H;var ge=u.alternate;ge!==null&&(ge=ge.updateQueue,z=ge.lastBaseUpdate,z!==$&&(z===null?ge.firstBaseUpdate=ue:z.next=ue,ge.lastBaseUpdate=H))}if(T!==null){var xe=S.baseState;$=0,ge=ue=H=null,z=T;do{var ce=z.lane&-536870913,de=ce!==z.lane;if(de?(ft&ce)===ce:(g&ce)===ce){ce!==0&&ce===ju&&(Av=!0),ge!==null&&(ge=ge.next={lane:0,tag:z.tag,payload:z.payload,callback:null,next:null});e:{var De=u,je=z;ce=c;var Dt=f;switch(je.tag){case 1:if(De=je.payload,typeof De=="function"){xe=De.call(Dt,xe,ce);break e}xe=De;break e;case 3:De.flags=De.flags&-65537|128;case 0:if(De=je.payload,ce=typeof De=="function"?De.call(Dt,xe,ce):De,ce==null)break e;xe=p({},xe,ce);break e;case 2:Ka=!0}}ce=z.callback,ce!==null&&(u.flags|=64,de&&(u.flags|=8192),de=S.callbacks,de===null?S.callbacks=[ce]:de.push(ce))}else de={lane:ce,tag:z.tag,payload:z.payload,callback:z.callback,next:null},ge===null?(ue=ge=de,H=xe):ge=ge.next=de,$|=ce;if(z=z.next,z===null){if(z=S.shared.pending,z===null)break;de=z,z=de.next,de.next=null,S.lastBaseUpdate=de,S.shared.pending=null}}while(!0);ge===null&&(H=xe),S.baseState=H,S.firstBaseUpdate=ue,S.lastBaseUpdate=ge,T===null&&(S.shared.lanes=0),to|=$,u.lanes=$,u.memoizedState=xe}}function _$(u,c){if(typeof u!="function")throw Error(s(191,u));u.call(c)}function A$(u,c){var f=u.callbacks;if(f!==null)for(u.callbacks=null,u=0;u<f.length;u++)_$(f[u],c)}var qu=P(null),Mg=P(0);function R$(u,c){u=ha,te(Mg,u),te(qu,c),ha=u|c.baseLanes}function Rv(){te(Mg,ha),te(qu,qu.current)}function Dv(){ha=Mg.current,j(qu),j(Mg)}var or=P(null),Or=null;function Ja(u){var c=u.alternate;te(fn,fn.current&1),te(or,u),Or===null&&(c===null||qu.current!==null||c.memoizedState!==null)&&(Or=u)}function Ov(u){te(fn,fn.current),te(or,u),Or===null&&(Or=u)}function D$(u){u.tag===22?(te(fn,fn.current),te(or,u),Or===null&&(Or=u)):Za()}function Za(){te(fn,fn.current),te(or,or.current)}function lr(u){j(or),Or===u&&(Or=null),j(fn)}var fn=P(0);function zg(u){for(var c=u;c!==null;){if(c.tag===13){var f=c.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||B1(f)||V1(f)))return c}else if(c.tag===19&&(c.memoizedProps.revealOrder==="forwards"||c.memoizedProps.revealOrder==="backwards"||c.memoizedProps.revealOrder==="unstable_legacy-backwards"||c.memoizedProps.revealOrder==="together")){if((c.flags&128)!==0)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===u)break;for(;c.sibling===null;){if(c.return===null||c.return===u)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}var sa=0,et=null,At=null,vn=null,Pg=!1,Ku=!1,hl=!1,Bg=0,Vd=0,Xu=null,xW=0;function sn(){throw Error(s(321))}function Lv(u,c){if(c===null)return!1;for(var f=0;f<c.length&&f<u.length;f++)if(!ir(u[f],c[f]))return!1;return!0}function Fv(u,c,f,g,S,T){return sa=T,et=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,B.H=u===null||u.memoizedState===null?g_:Jv,hl=!1,T=f(g,S),hl=!1,Ku&&(T=L$(c,f,g,S)),O$(u),T}function O$(u){B.H=Wd;var c=At!==null&&At.next!==null;if(sa=0,vn=At=et=null,Pg=!1,Vd=0,Xu=null,c)throw Error(s(300));u===null||Sn||(u=u.dependencies,u!==null&&_g(u)&&(Sn=!0))}function L$(u,c,f,g){et=u;var S=0;do{if(Ku&&(Xu=null),Vd=0,Ku=!1,25<=S)throw Error(s(301));if(S+=1,vn=At=null,u.updateQueue!=null){var T=u.updateQueue;T.lastEffect=null,T.events=null,T.stores=null,T.memoCache!=null&&(T.memoCache.index=0)}B.H=y_,T=c(f,g)}while(Ku);return T}function wW(){var u=B.H,c=u.useState()[0];return c=typeof c.then=="function"?Ud(c):c,u=u.useState()[0],(At!==null?At.memoizedState:null)!==u&&(et.flags|=1024),c}function Mv(){var u=Bg!==0;return Bg=0,u}function zv(u,c,f){c.updateQueue=u.updateQueue,c.flags&=-2053,u.lanes&=~f}function Pv(u){if(Pg){for(u=u.memoizedState;u!==null;){var c=u.queue;c!==null&&(c.pending=null),u=u.next}Pg=!1}sa=0,vn=At=et=null,Ku=!1,Vd=Bg=0,Xu=null}function Ns(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return vn===null?et.memoizedState=vn=u:vn=vn.next=u,vn}function pn(){if(At===null){var u=et.alternate;u=u!==null?u.memoizedState:null}else u=At.next;var c=vn===null?et.memoizedState:vn.next;if(c!==null)vn=c,At=u;else{if(u===null)throw et.alternate===null?Error(s(467)):Error(s(310));At=u,u={memoizedState:At.memoizedState,baseState:At.baseState,baseQueue:At.baseQueue,queue:At.queue,next:null},vn===null?et.memoizedState=vn=u:vn=vn.next=u}return vn}function Vg(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Ud(u){var c=Vd;return Vd+=1,Xu===null&&(Xu=[]),u=N$(Xu,u,c),c=et,(vn===null?c.memoizedState:vn.next)===null&&(c=c.alternate,B.H=c===null||c.memoizedState===null?g_:Jv),u}function Ug(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Ud(u);if(u.$$typeof===N)return rs(u)}throw Error(s(438,String(u)))}function Bv(u){var c=null,f=et.updateQueue;if(f!==null&&(c=f.memoCache),c==null){var g=et.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(c={data:g.data.map(function(S){return S.slice()}),index:0})))}if(c==null&&(c={data:[],index:0}),f===null&&(f=Vg(),et.updateQueue=f),f.memoCache=c,f=c.data[c.index],f===void 0)for(f=c.data[c.index]=Array(u),g=0;g<u;g++)f[g]=F;return c.index++,f}function ra(u,c){return typeof c=="function"?c(u):c}function jg(u){var c=pn();return Vv(c,At,u)}function Vv(u,c,f){var g=u.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=f;var S=u.baseQueue,T=g.pending;if(T!==null){if(S!==null){var $=S.next;S.next=T.next,T.next=$}c.baseQueue=S=T,g.pending=null}if(T=u.baseState,S===null)u.memoizedState=T;else{c=S.next;var z=$=null,H=null,ue=c,ge=!1;do{var xe=ue.lane&-536870913;if(xe!==ue.lane?(ft&xe)===xe:(sa&xe)===xe){var ce=ue.revertLane;if(ce===0)H!==null&&(H=H.next={lane:0,revertLane:0,gesture:null,action:ue.action,hasEagerState:ue.hasEagerState,eagerState:ue.eagerState,next:null}),xe===ju&&(ge=!0);else if((sa&ce)===ce){ue=ue.next,ce===ju&&(ge=!0);continue}else xe={lane:0,revertLane:ue.revertLane,gesture:null,action:ue.action,hasEagerState:ue.hasEagerState,eagerState:ue.eagerState,next:null},H===null?(z=H=xe,$=T):H=H.next=xe,et.lanes|=ce,to|=ce;xe=ue.action,hl&&f(T,xe),T=ue.hasEagerState?ue.eagerState:f(T,xe)}else ce={lane:xe,revertLane:ue.revertLane,gesture:ue.gesture,action:ue.action,hasEagerState:ue.hasEagerState,eagerState:ue.eagerState,next:null},H===null?(z=H=ce,$=T):H=H.next=ce,et.lanes|=xe,to|=xe;ue=ue.next}while(ue!==null&&ue!==c);if(H===null?$=T:H.next=z,!ir(T,u.memoizedState)&&(Sn=!0,ge&&(f=Wu,f!==null)))throw f;u.memoizedState=T,u.baseState=$,u.baseQueue=H,g.lastRenderedState=T}return S===null&&(g.lanes=0),[u.memoizedState,g.dispatch]}function Uv(u){var c=pn(),f=c.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=u;var g=f.dispatch,S=f.pending,T=c.memoizedState;if(S!==null){f.pending=null;var $=S=S.next;do T=u(T,$.action),$=$.next;while($!==S);ir(T,c.memoizedState)||(Sn=!0),c.memoizedState=T,c.baseQueue===null&&(c.baseState=T),f.lastRenderedState=T}return[T,g]}function F$(u,c,f){var g=et,S=pn(),T=yt;if(T){if(f===void 0)throw Error(s(407));f=f()}else f=c();var $=!ir((At||S).memoizedState,f);if($&&(S.memoizedState=f,Sn=!0),S=S.queue,Gv(P$.bind(null,g,S,u),[u]),S.getSnapshot!==c||$||vn!==null&&vn.memoizedState.tag&1){if(g.flags|=2048,Yu(9,{destroy:void 0},z$.bind(null,g,S,f,c),null),Lt===null)throw Error(s(349));T||(sa&127)!==0||M$(g,c,f)}return f}function M$(u,c,f){u.flags|=16384,u={getSnapshot:c,value:f},c=et.updateQueue,c===null?(c=Vg(),et.updateQueue=c,c.stores=[u]):(f=c.stores,f===null?c.stores=[u]:f.push(u))}function z$(u,c,f,g){c.value=f,c.getSnapshot=g,B$(c)&&V$(u)}function P$(u,c,f){return f(function(){B$(c)&&V$(u)})}function B$(u){var c=u.getSnapshot;u=u.value;try{var f=c();return!ir(u,f)}catch{return!0}}function V$(u){var c=nl(u,2);c!==null&&Us(c,u,2)}function jv(u){var c=Ns();if(typeof u=="function"){var f=u;if(u=f(),hl){Ni(!0);try{f()}finally{Ni(!1)}}}return c.memoizedState=c.baseState=u,c.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ra,lastRenderedState:u},c}function U$(u,c,f,g){return u.baseState=f,Vv(u,At,typeof g=="function"?g:ra)}function vW(u,c,f,g,S){if(Hg(u))throw Error(s(485));if(u=c.action,u!==null){var T={payload:S,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function($){T.listeners.push($)}};B.T!==null?f(!0):T.isTransition=!1,g(T),f=c.pending,f===null?(T.next=c.pending=T,j$(c,T)):(T.next=f.next,c.pending=f.next=T)}}function j$(u,c){var f=c.action,g=c.payload,S=u.state;if(c.isTransition){var T=B.T,$={};B.T=$;try{var z=f(S,g),H=B.S;H!==null&&H($,z),W$(u,c,z)}catch(ue){Wv(u,c,ue)}finally{T!==null&&$.types!==null&&(T.types=$.types),B.T=T}}else try{T=f(S,g),W$(u,c,T)}catch(ue){Wv(u,c,ue)}}function W$(u,c,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(g){G$(u,c,g)},function(g){return Wv(u,c,g)}):G$(u,c,f)}function G$(u,c,f){c.status="fulfilled",c.value=f,H$(c),u.state=f,c=u.pending,c!==null&&(f=c.next,f===c?u.pending=null:(f=f.next,c.next=f,j$(u,f)))}function Wv(u,c,f){var g=u.pending;if(u.pending=null,g!==null){g=g.next;do c.status="rejected",c.reason=f,H$(c),c=c.next;while(c!==g)}u.action=null}function H$(u){u=u.listeners;for(var c=0;c<u.length;c++)(0,u[c])()}function q$(u,c){return c}function K$(u,c){if(yt){var f=Lt.formState;if(f!==null){e:{var g=et;if(yt){if(Ut){t:{for(var S=Ut,T=Dr;S.nodeType!==8;){if(!T){S=null;break t}if(S=Lr(S.nextSibling),S===null){S=null;break t}}T=S.data,S=T==="F!"||T==="F"?S:null}if(S){Ut=Lr(S.nextSibling),g=S.data==="F!";break e}}Ha(g)}g=!1}g&&(c=f[0])}}return f=Ns(),f.memoizedState=f.baseState=c,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:q$,lastRenderedState:c},f.queue=g,f=f_.bind(null,et,g),g.dispatch=f,g=jv(!1),T=Yv.bind(null,et,!1,g.queue),g=Ns(),S={state:c,dispatch:null,action:u,pending:null},g.queue=S,f=vW.bind(null,et,S,T,f),S.dispatch=f,g.memoizedState=u,[c,f,!1]}function X$(u){var c=pn();return Y$(c,At,u)}function Y$(u,c,f){if(c=Vv(u,c,q$)[0],u=jg(ra)[0],typeof c=="object"&&c!==null&&typeof c.then=="function")try{var g=Ud(c)}catch($){throw $===Gu?Dg:$}else g=c;c=pn();var S=c.queue,T=S.dispatch;return f!==c.memoizedState&&(et.flags|=2048,Yu(9,{destroy:void 0},SW.bind(null,S,f),null)),[g,T,u]}function SW(u,c){u.action=c}function J$(u){var c=pn(),f=At;if(f!==null)return Y$(c,f,u);pn(),c=c.memoizedState,f=pn();var g=f.queue.dispatch;return f.memoizedState=u,[c,g,!1]}function Yu(u,c,f,g){return u={tag:u,create:f,deps:g,inst:c,next:null},c=et.updateQueue,c===null&&(c=Vg(),et.updateQueue=c),f=c.lastEffect,f===null?c.lastEffect=u.next=u:(g=f.next,f.next=u,u.next=g,c.lastEffect=u),u}function Z$(){return pn().memoizedState}function Wg(u,c,f,g){var S=Ns();et.flags|=u,S.memoizedState=Yu(1|c,{destroy:void 0},f,g===void 0?null:g)}function Gg(u,c,f,g){var S=pn();g=g===void 0?null:g;var T=S.memoizedState.inst;At!==null&&g!==null&&Lv(g,At.memoizedState.deps)?S.memoizedState=Yu(c,T,f,g):(et.flags|=u,S.memoizedState=Yu(1|c,T,f,g))}function Q$(u,c){Wg(8390656,8,u,c)}function Gv(u,c){Gg(2048,8,u,c)}function TW(u){et.flags|=4;var c=et.updateQueue;if(c===null)c=Vg(),et.updateQueue=c,c.events=[u];else{var f=c.events;f===null?c.events=[u]:f.push(u)}}function e_(u){var c=pn().memoizedState;return TW({ref:c,nextImpl:u}),function(){if((Tt&2)!==0)throw Error(s(440));return c.impl.apply(void 0,arguments)}}function t_(u,c){return Gg(4,2,u,c)}function n_(u,c){return Gg(4,4,u,c)}function s_(u,c){if(typeof c=="function"){u=u();var f=c(u);return function(){typeof f=="function"?f():c(null)}}if(c!=null)return u=u(),c.current=u,function(){c.current=null}}function r_(u,c,f){f=f!=null?f.concat([u]):null,Gg(4,4,s_.bind(null,c,u),f)}function Hv(){}function i_(u,c){var f=pn();c=c===void 0?null:c;var g=f.memoizedState;return c!==null&&Lv(c,g[1])?g[0]:(f.memoizedState=[u,c],u)}function a_(u,c){var f=pn();c=c===void 0?null:c;var g=f.memoizedState;if(c!==null&&Lv(c,g[1]))return g[0];if(g=u(),hl){Ni(!0);try{u()}finally{Ni(!1)}}return f.memoizedState=[g,c],g}function qv(u,c,f){return f===void 0||(sa&1073741824)!==0&&(ft&261930)===0?u.memoizedState=c:(u.memoizedState=f,u=oA(),et.lanes|=u,to|=u,f)}function o_(u,c,f,g){return ir(f,c)?f:qu.current!==null?(u=qv(u,f,g),ir(u,c)||(Sn=!0),u):(sa&42)===0||(sa&1073741824)!==0&&(ft&261930)===0?(Sn=!0,u.memoizedState=f):(u=oA(),et.lanes|=u,to|=u,c)}function l_(u,c,f,g,S){var T=U.p;U.p=T!==0&&8>T?T:8;var $=B.T,z={};B.T=z,Yv(u,!1,c,f);try{var H=S(),ue=B.S;if(ue!==null&&ue(z,H),H!==null&&typeof H=="object"&&typeof H.then=="function"){var ge=bW(H,g);jd(u,c,ge,hr(u))}else jd(u,c,g,hr(u))}catch(xe){jd(u,c,{then:function(){},status:"rejected",reason:xe},hr())}finally{U.p=T,$!==null&&z.types!==null&&($.types=z.types),B.T=$}}function CW(){}function Kv(u,c,f,g){if(u.tag!==5)throw Error(s(476));var S=u_(u).queue;l_(u,S,c,K,f===null?CW:function(){return c_(u),f(g)})}function u_(u){var c=u.memoizedState;if(c!==null)return c;c={memoizedState:K,baseState:K,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ra,lastRenderedState:K},next:null};var f={};return c.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ra,lastRenderedState:f},next:null},u.memoizedState=c,u=u.alternate,u!==null&&(u.memoizedState=c),c}function c_(u){var c=u_(u);c.next===null&&(c=u.alternate.memoizedState),jd(u,c.next.queue,{},hr())}function Xv(){return rs(of)}function h_(){return pn().memoizedState}function d_(){return pn().memoizedState}function NW(u){for(var c=u.return;c!==null;){switch(c.tag){case 24:case 3:var f=hr();u=Xa(f);var g=Ya(c,u,f);g!==null&&(Us(g,c,f),zd(g,c,f)),c={cache:Cv()},u.payload=c;return}c=c.return}}function kW(u,c,f){var g=hr();f={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},Hg(u)?p_(c,f):(f=fv(u,c,f,g),f!==null&&(Us(f,u,g),m_(f,c,g)))}function f_(u,c,f){var g=hr();jd(u,c,f,g)}function jd(u,c,f,g){var S={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(Hg(u))p_(c,S);else{var T=u.alternate;if(u.lanes===0&&(T===null||T.lanes===0)&&(T=c.lastRenderedReducer,T!==null))try{var $=c.lastRenderedState,z=T($,f);if(S.hasEagerState=!0,S.eagerState=z,ir(z,$))return kg(u,c,S,0),Lt===null&&Ng(),!1}catch{}if(f=fv(u,c,S,g),f!==null)return Us(f,u,g),m_(f,c,g),!0}return!1}function Yv(u,c,f,g){if(g={lane:2,revertLane:I1(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},Hg(u)){if(c)throw Error(s(479))}else c=fv(u,f,g,2),c!==null&&Us(c,u,2)}function Hg(u){var c=u.alternate;return u===et||c!==null&&c===et}function p_(u,c){Ku=Pg=!0;var f=u.pending;f===null?c.next=c:(c.next=f.next,f.next=c),u.pending=c}function m_(u,c,f){if((f&4194048)!==0){var g=c.lanes;g&=u.pendingLanes,f|=g,c.lanes=f,wI(u,f)}}var Wd={readContext:rs,use:Ug,useCallback:sn,useContext:sn,useEffect:sn,useImperativeHandle:sn,useLayoutEffect:sn,useInsertionEffect:sn,useMemo:sn,useReducer:sn,useRef:sn,useState:sn,useDebugValue:sn,useDeferredValue:sn,useTransition:sn,useSyncExternalStore:sn,useId:sn,useHostTransitionStatus:sn,useFormState:sn,useActionState:sn,useOptimistic:sn,useMemoCache:sn,useCacheRefresh:sn};Wd.useEffectEvent=sn;var g_={readContext:rs,use:Ug,useCallback:function(u,c){return Ns().memoizedState=[u,c===void 0?null:c],u},useContext:rs,useEffect:Q$,useImperativeHandle:function(u,c,f){f=f!=null?f.concat([u]):null,Wg(4194308,4,s_.bind(null,c,u),f)},useLayoutEffect:function(u,c){return Wg(4194308,4,u,c)},useInsertionEffect:function(u,c){Wg(4,2,u,c)},useMemo:function(u,c){var f=Ns();c=c===void 0?null:c;var g=u();if(hl){Ni(!0);try{u()}finally{Ni(!1)}}return f.memoizedState=[g,c],g},useReducer:function(u,c,f){var g=Ns();if(f!==void 0){var S=f(c);if(hl){Ni(!0);try{f(c)}finally{Ni(!1)}}}else S=c;return g.memoizedState=g.baseState=S,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:S},g.queue=u,u=u.dispatch=kW.bind(null,et,u),[g.memoizedState,u]},useRef:function(u){var c=Ns();return u={current:u},c.memoizedState=u},useState:function(u){u=jv(u);var c=u.queue,f=f_.bind(null,et,c);return c.dispatch=f,[u.memoizedState,f]},useDebugValue:Hv,useDeferredValue:function(u,c){var f=Ns();return qv(f,u,c)},useTransition:function(){var u=jv(!1);return u=l_.bind(null,et,u.queue,!0,!1),Ns().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,c,f){var g=et,S=Ns();if(yt){if(f===void 0)throw Error(s(407));f=f()}else{if(f=c(),Lt===null)throw Error(s(349));(ft&127)!==0||M$(g,c,f)}S.memoizedState=f;var T={value:f,getSnapshot:c};return S.queue=T,Q$(P$.bind(null,g,T,u),[u]),g.flags|=2048,Yu(9,{destroy:void 0},z$.bind(null,g,T,f,c),null),f},useId:function(){var u=Ns(),c=Lt.identifierPrefix;if(yt){var f=Ei,g=ki;f=(g&~(1<<32-rr(g)-1)).toString(32)+f,c="_"+c+"R_"+f,f=Bg++,0<f&&(c+="H"+f.toString(32)),c+="_"}else f=xW++,c="_"+c+"r_"+f.toString(32)+"_";return u.memoizedState=c},useHostTransitionStatus:Xv,useFormState:K$,useActionState:K$,useOptimistic:function(u){var c=Ns();c.memoizedState=c.baseState=u;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return c.queue=f,c=Yv.bind(null,et,!0,f),f.dispatch=c,[u,c]},useMemoCache:Bv,useCacheRefresh:function(){return Ns().memoizedState=NW.bind(null,et)},useEffectEvent:function(u){var c=Ns(),f={impl:u};return c.memoizedState=f,function(){if((Tt&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},Jv={readContext:rs,use:Ug,useCallback:i_,useContext:rs,useEffect:Gv,useImperativeHandle:r_,useInsertionEffect:t_,useLayoutEffect:n_,useMemo:a_,useReducer:jg,useRef:Z$,useState:function(){return jg(ra)},useDebugValue:Hv,useDeferredValue:function(u,c){var f=pn();return o_(f,At.memoizedState,u,c)},useTransition:function(){var u=jg(ra)[0],c=pn().memoizedState;return[typeof u=="boolean"?u:Ud(u),c]},useSyncExternalStore:F$,useId:h_,useHostTransitionStatus:Xv,useFormState:X$,useActionState:X$,useOptimistic:function(u,c){var f=pn();return U$(f,At,u,c)},useMemoCache:Bv,useCacheRefresh:d_};Jv.useEffectEvent=e_;var y_={readContext:rs,use:Ug,useCallback:i_,useContext:rs,useEffect:Gv,useImperativeHandle:r_,useInsertionEffect:t_,useLayoutEffect:n_,useMemo:a_,useReducer:Uv,useRef:Z$,useState:function(){return Uv(ra)},useDebugValue:Hv,useDeferredValue:function(u,c){var f=pn();return At===null?qv(f,u,c):o_(f,At.memoizedState,u,c)},useTransition:function(){var u=Uv(ra)[0],c=pn().memoizedState;return[typeof u=="boolean"?u:Ud(u),c]},useSyncExternalStore:F$,useId:h_,useHostTransitionStatus:Xv,useFormState:J$,useActionState:J$,useOptimistic:function(u,c){var f=pn();return At!==null?U$(f,At,u,c):(f.baseState=u,[u,f.queue.dispatch])},useMemoCache:Bv,useCacheRefresh:d_};y_.useEffectEvent=e_;function Zv(u,c,f,g){c=u.memoizedState,f=f(g,c),f=f==null?c:p({},c,f),u.memoizedState=f,u.lanes===0&&(u.updateQueue.baseState=f)}var Qv={enqueueSetState:function(u,c,f){u=u._reactInternals;var g=hr(),S=Xa(g);S.payload=c,f!=null&&(S.callback=f),c=Ya(u,S,g),c!==null&&(Us(c,u,g),zd(c,u,g))},enqueueReplaceState:function(u,c,f){u=u._reactInternals;var g=hr(),S=Xa(g);S.tag=1,S.payload=c,f!=null&&(S.callback=f),c=Ya(u,S,g),c!==null&&(Us(c,u,g),zd(c,u,g))},enqueueForceUpdate:function(u,c){u=u._reactInternals;var f=hr(),g=Xa(f);g.tag=2,c!=null&&(g.callback=c),c=Ya(u,g,f),c!==null&&(Us(c,u,f),zd(c,u,f))}};function b_(u,c,f,g,S,T,$){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(g,T,$):c.prototype&&c.prototype.isPureReactComponent?!_d(f,g)||!_d(S,T):!0}function x_(u,c,f,g){u=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(f,g),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(f,g),c.state!==u&&Qv.enqueueReplaceState(c,c.state,null)}function dl(u,c){var f=c;if("ref"in c){f={};for(var g in c)g!=="ref"&&(f[g]=c[g])}if(u=u.defaultProps){f===c&&(f=p({},f));for(var S in u)f[S]===void 0&&(f[S]=u[S])}return f}function w_(u){Cg(u)}function v_(u){console.error(u)}function S_(u){Cg(u)}function qg(u,c){try{var f=u.onUncaughtError;f(c.value,{componentStack:c.stack})}catch(g){setTimeout(function(){throw g})}}function T_(u,c,f){try{var g=u.onCaughtError;g(f.value,{componentStack:f.stack,errorBoundary:c.tag===1?c.stateNode:null})}catch(S){setTimeout(function(){throw S})}}function e1(u,c,f){return f=Xa(f),f.tag=3,f.payload={element:null},f.callback=function(){qg(u,c)},f}function C_(u){return u=Xa(u),u.tag=3,u}function N_(u,c,f,g){var S=f.type.getDerivedStateFromError;if(typeof S=="function"){var T=g.value;u.payload=function(){return S(T)},u.callback=function(){T_(c,f,g)}}var $=f.stateNode;$!==null&&typeof $.componentDidCatch=="function"&&(u.callback=function(){T_(c,f,g),typeof S!="function"&&(no===null?no=new Set([this]):no.add(this));var z=g.stack;this.componentDidCatch(g.value,{componentStack:z!==null?z:""})})}function EW(u,c,f,g,S){if(f.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(c=f.alternate,c!==null&&Uu(c,f,S,!0),f=or.current,f!==null){switch(f.tag){case 31:case 13:return Or===null?iy():f.alternate===null&&rn===0&&(rn=3),f.flags&=-257,f.flags|=65536,f.lanes=S,g===Og?f.flags|=16384:(c=f.updateQueue,c===null?f.updateQueue=new Set([g]):c.add(g),N1(u,g,S)),!1;case 22:return f.flags|=65536,g===Og?f.flags|=16384:(c=f.updateQueue,c===null?(c={transitions:null,markerInstances:null,retryQueue:new Set([g])},f.updateQueue=c):(f=c.retryQueue,f===null?c.retryQueue=new Set([g]):f.add(g)),N1(u,g,S)),!1}throw Error(s(435,f.tag))}return N1(u,g,S),iy(),!1}if(yt)return c=or.current,c!==null?((c.flags&65536)===0&&(c.flags|=256),c.flags|=65536,c.lanes=S,g!==xv&&(u=Error(s(422),{cause:g}),Dd(_r(u,f)))):(g!==xv&&(c=Error(s(423),{cause:g}),Dd(_r(c,f))),u=u.current.alternate,u.flags|=65536,S&=-S,u.lanes|=S,g=_r(g,f),S=e1(u.stateNode,g,S),_v(u,S),rn!==4&&(rn=2)),!1;var T=Error(s(520),{cause:g});if(T=_r(T,f),Zd===null?Zd=[T]:Zd.push(T),rn!==4&&(rn=2),c===null)return!0;g=_r(g,f),f=c;do{switch(f.tag){case 3:return f.flags|=65536,u=S&-S,f.lanes|=u,u=e1(f.stateNode,g,u),_v(f,u),!1;case 1:if(c=f.type,T=f.stateNode,(f.flags&128)===0&&(typeof c.getDerivedStateFromError=="function"||T!==null&&typeof T.componentDidCatch=="function"&&(no===null||!no.has(T))))return f.flags|=65536,S&=-S,f.lanes|=S,S=C_(S),N_(S,u,f,g),_v(f,S),!1}f=f.return}while(f!==null);return!1}var t1=Error(s(461)),Sn=!1;function is(u,c,f,g){c.child=u===null?$$(c,null,f,g):cl(c,u.child,f,g)}function k_(u,c,f,g,S){f=f.render;var T=c.ref;if("ref"in g){var $={};for(var z in g)z!=="ref"&&($[z]=g[z])}else $=g;return al(c),g=Fv(u,c,f,$,T,S),z=Mv(),u!==null&&!Sn?(zv(u,c,S),ia(u,c,S)):(yt&&z&&yv(c),c.flags|=1,is(u,c,g,S),c.child)}function E_(u,c,f,g,S){if(u===null){var T=f.type;return typeof T=="function"&&!pv(T)&&T.defaultProps===void 0&&f.compare===null?(c.tag=15,c.type=T,I_(u,c,T,g,S)):(u=Ig(f.type,null,g,c,c.mode,S),u.ref=c.ref,u.return=c,c.child=u)}if(T=u.child,!u1(u,S)){var $=T.memoizedProps;if(f=f.compare,f=f!==null?f:_d,f($,g)&&u.ref===c.ref)return ia(u,c,S)}return c.flags|=1,u=Qi(T,g),u.ref=c.ref,u.return=c,c.child=u}function I_(u,c,f,g,S){if(u!==null){var T=u.memoizedProps;if(_d(T,g)&&u.ref===c.ref)if(Sn=!1,c.pendingProps=g=T,u1(u,S))(u.flags&131072)!==0&&(Sn=!0);else return c.lanes=u.lanes,ia(u,c,S)}return n1(u,c,f,g,S)}function $_(u,c,f,g){var S=g.children,T=u!==null?u.memoizedState:null;if(u===null&&c.stateNode===null&&(c.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((c.flags&128)!==0){if(T=T!==null?T.baseLanes|f:f,u!==null){for(g=c.child=u.child,S=0;g!==null;)S=S|g.lanes|g.childLanes,g=g.sibling;g=S&~T}else g=0,c.child=null;return __(u,c,T,f,g)}if((f&536870912)!==0)c.memoizedState={baseLanes:0,cachePool:null},u!==null&&Rg(c,T!==null?T.cachePool:null),T!==null?R$(c,T):Rv(),D$(c);else return g=c.lanes=536870912,__(u,c,T!==null?T.baseLanes|f:f,f,g)}else T!==null?(Rg(c,T.cachePool),R$(c,T),Za(),c.memoizedState=null):(u!==null&&Rg(c,null),Rv(),Za());return is(u,c,S,f),c.child}function Gd(u,c){return u!==null&&u.tag===22||c.stateNode!==null||(c.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),c.sibling}function __(u,c,f,g,S){var T=kv();return T=T===null?null:{parent:wn._currentValue,pool:T},c.memoizedState={baseLanes:f,cachePool:T},u!==null&&Rg(c,null),Rv(),D$(c),u!==null&&Uu(u,c,g,!0),c.childLanes=S,null}function Kg(u,c){return c=Yg({mode:c.mode,children:c.children},u.mode),c.ref=u.ref,u.child=c,c.return=u,c}function A_(u,c,f){return cl(c,u.child,null,f),u=Kg(c,c.pendingProps),u.flags|=2,lr(c),c.memoizedState=null,u}function IW(u,c,f){var g=c.pendingProps,S=(c.flags&128)!==0;if(c.flags&=-129,u===null){if(yt){if(g.mode==="hidden")return u=Kg(c,g),c.lanes=536870912,Gd(null,u);if(Ov(c),(u=Ut)?(u=jA(u,Dr),u=u!==null&&u.data==="&"?u:null,u!==null&&(c.memoizedState={dehydrated:u,treeContext:Wa!==null?{id:ki,overflow:Ei}:null,retryLane:536870912,hydrationErrors:null},f=p$(u),f.return=c,c.child=f,ss=c,Ut=null)):u=null,u===null)throw Ha(c);return c.lanes=536870912,null}return Kg(c,g)}var T=u.memoizedState;if(T!==null){var $=T.dehydrated;if(Ov(c),S)if(c.flags&256)c.flags&=-257,c=A_(u,c,f);else if(c.memoizedState!==null)c.child=u.child,c.flags|=128,c=null;else throw Error(s(558));else if(Sn||Uu(u,c,f,!1),S=(f&u.childLanes)!==0,Sn||S){if(g=Lt,g!==null&&($=vI(g,f),$!==0&&$!==T.retryLane))throw T.retryLane=$,nl(u,$),Us(g,u,$),t1;iy(),c=A_(u,c,f)}else u=T.treeContext,Ut=Lr($.nextSibling),ss=c,yt=!0,Ga=null,Dr=!1,u!==null&&y$(c,u),c=Kg(c,g),c.flags|=4096;return c}return u=Qi(u.child,{mode:g.mode,children:g.children}),u.ref=c.ref,c.child=u,u.return=c,u}function Xg(u,c){var f=c.ref;if(f===null)u!==null&&u.ref!==null&&(c.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(u===null||u.ref!==f)&&(c.flags|=4194816)}}function n1(u,c,f,g,S){return al(c),f=Fv(u,c,f,g,void 0,S),g=Mv(),u!==null&&!Sn?(zv(u,c,S),ia(u,c,S)):(yt&&g&&yv(c),c.flags|=1,is(u,c,f,S),c.child)}function R_(u,c,f,g,S,T){return al(c),c.updateQueue=null,f=L$(c,g,f,S),O$(u),g=Mv(),u!==null&&!Sn?(zv(u,c,T),ia(u,c,T)):(yt&&g&&yv(c),c.flags|=1,is(u,c,f,T),c.child)}function D_(u,c,f,g,S){if(al(c),c.stateNode===null){var T=zu,$=f.contextType;typeof $=="object"&&$!==null&&(T=rs($)),T=new f(g,T),c.memoizedState=T.state!==null&&T.state!==void 0?T.state:null,T.updater=Qv,c.stateNode=T,T._reactInternals=c,T=c.stateNode,T.props=g,T.state=c.memoizedState,T.refs={},Iv(c),$=f.contextType,T.context=typeof $=="object"&&$!==null?rs($):zu,T.state=c.memoizedState,$=f.getDerivedStateFromProps,typeof $=="function"&&(Zv(c,f,$,g),T.state=c.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof T.getSnapshotBeforeUpdate=="function"||typeof T.UNSAFE_componentWillMount!="function"&&typeof T.componentWillMount!="function"||($=T.state,typeof T.componentWillMount=="function"&&T.componentWillMount(),typeof T.UNSAFE_componentWillMount=="function"&&T.UNSAFE_componentWillMount(),$!==T.state&&Qv.enqueueReplaceState(T,T.state,null),Bd(c,g,T,S),Pd(),T.state=c.memoizedState),typeof T.componentDidMount=="function"&&(c.flags|=4194308),g=!0}else if(u===null){T=c.stateNode;var z=c.memoizedProps,H=dl(f,z);T.props=H;var ue=T.context,ge=f.contextType;$=zu,typeof ge=="object"&&ge!==null&&($=rs(ge));var xe=f.getDerivedStateFromProps;ge=typeof xe=="function"||typeof T.getSnapshotBeforeUpdate=="function",z=c.pendingProps!==z,ge||typeof T.UNSAFE_componentWillReceiveProps!="function"&&typeof T.componentWillReceiveProps!="function"||(z||ue!==$)&&x_(c,T,g,$),Ka=!1;var ce=c.memoizedState;T.state=ce,Bd(c,g,T,S),Pd(),ue=c.memoizedState,z||ce!==ue||Ka?(typeof xe=="function"&&(Zv(c,f,xe,g),ue=c.memoizedState),(H=Ka||b_(c,f,H,g,ce,ue,$))?(ge||typeof T.UNSAFE_componentWillMount!="function"&&typeof T.componentWillMount!="function"||(typeof T.componentWillMount=="function"&&T.componentWillMount(),typeof T.UNSAFE_componentWillMount=="function"&&T.UNSAFE_componentWillMount()),typeof T.componentDidMount=="function"&&(c.flags|=4194308)):(typeof T.componentDidMount=="function"&&(c.flags|=4194308),c.memoizedProps=g,c.memoizedState=ue),T.props=g,T.state=ue,T.context=$,g=H):(typeof T.componentDidMount=="function"&&(c.flags|=4194308),g=!1)}else{T=c.stateNode,$v(u,c),$=c.memoizedProps,ge=dl(f,$),T.props=ge,xe=c.pendingProps,ce=T.context,ue=f.contextType,H=zu,typeof ue=="object"&&ue!==null&&(H=rs(ue)),z=f.getDerivedStateFromProps,(ue=typeof z=="function"||typeof T.getSnapshotBeforeUpdate=="function")||typeof T.UNSAFE_componentWillReceiveProps!="function"&&typeof T.componentWillReceiveProps!="function"||($!==xe||ce!==H)&&x_(c,T,g,H),Ka=!1,ce=c.memoizedState,T.state=ce,Bd(c,g,T,S),Pd();var de=c.memoizedState;$!==xe||ce!==de||Ka||u!==null&&u.dependencies!==null&&_g(u.dependencies)?(typeof z=="function"&&(Zv(c,f,z,g),de=c.memoizedState),(ge=Ka||b_(c,f,ge,g,ce,de,H)||u!==null&&u.dependencies!==null&&_g(u.dependencies))?(ue||typeof T.UNSAFE_componentWillUpdate!="function"&&typeof T.componentWillUpdate!="function"||(typeof T.componentWillUpdate=="function"&&T.componentWillUpdate(g,de,H),typeof T.UNSAFE_componentWillUpdate=="function"&&T.UNSAFE_componentWillUpdate(g,de,H)),typeof T.componentDidUpdate=="function"&&(c.flags|=4),typeof T.getSnapshotBeforeUpdate=="function"&&(c.flags|=1024)):(typeof T.componentDidUpdate!="function"||$===u.memoizedProps&&ce===u.memoizedState||(c.flags|=4),typeof T.getSnapshotBeforeUpdate!="function"||$===u.memoizedProps&&ce===u.memoizedState||(c.flags|=1024),c.memoizedProps=g,c.memoizedState=de),T.props=g,T.state=de,T.context=H,g=ge):(typeof T.componentDidUpdate!="function"||$===u.memoizedProps&&ce===u.memoizedState||(c.flags|=4),typeof T.getSnapshotBeforeUpdate!="function"||$===u.memoizedProps&&ce===u.memoizedState||(c.flags|=1024),g=!1)}return T=g,Xg(u,c),g=(c.flags&128)!==0,T||g?(T=c.stateNode,f=g&&typeof f.getDerivedStateFromError!="function"?null:T.render(),c.flags|=1,u!==null&&g?(c.child=cl(c,u.child,null,S),c.child=cl(c,null,f,S)):is(u,c,f,S),c.memoizedState=T.state,u=c.child):u=ia(u,c,S),u}function O_(u,c,f,g){return rl(),c.flags|=256,is(u,c,f,g),c.child}var s1={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function r1(u){return{baseLanes:u,cachePool:T$()}}function i1(u,c,f){return u=u!==null?u.childLanes&~f:0,c&&(u|=cr),u}function L_(u,c,f){var g=c.pendingProps,S=!1,T=(c.flags&128)!==0,$;if(($=T)||($=u!==null&&u.memoizedState===null?!1:(fn.current&2)!==0),$&&(S=!0,c.flags&=-129),$=(c.flags&32)!==0,c.flags&=-33,u===null){if(yt){if(S?Ja(c):Za(),(u=Ut)?(u=jA(u,Dr),u=u!==null&&u.data!=="&"?u:null,u!==null&&(c.memoizedState={dehydrated:u,treeContext:Wa!==null?{id:ki,overflow:Ei}:null,retryLane:536870912,hydrationErrors:null},f=p$(u),f.return=c,c.child=f,ss=c,Ut=null)):u=null,u===null)throw Ha(c);return V1(u)?c.lanes=32:c.lanes=536870912,null}var z=g.children;return g=g.fallback,S?(Za(),S=c.mode,z=Yg({mode:"hidden",children:z},S),g=sl(g,S,f,null),z.return=c,g.return=c,z.sibling=g,c.child=z,g=c.child,g.memoizedState=r1(f),g.childLanes=i1(u,$,f),c.memoizedState=s1,Gd(null,g)):(Ja(c),a1(c,z))}var H=u.memoizedState;if(H!==null&&(z=H.dehydrated,z!==null)){if(T)c.flags&256?(Ja(c),c.flags&=-257,c=o1(u,c,f)):c.memoizedState!==null?(Za(),c.child=u.child,c.flags|=128,c=null):(Za(),z=g.fallback,S=c.mode,g=Yg({mode:"visible",children:g.children},S),z=sl(z,S,f,null),z.flags|=2,g.return=c,z.return=c,g.sibling=z,c.child=g,cl(c,u.child,null,f),g=c.child,g.memoizedState=r1(f),g.childLanes=i1(u,$,f),c.memoizedState=s1,c=Gd(null,g));else if(Ja(c),V1(z)){if($=z.nextSibling&&z.nextSibling.dataset,$)var ue=$.dgst;$=ue,g=Error(s(419)),g.stack="",g.digest=$,Dd({value:g,source:null,stack:null}),c=o1(u,c,f)}else if(Sn||Uu(u,c,f,!1),$=(f&u.childLanes)!==0,Sn||$){if($=Lt,$!==null&&(g=vI($,f),g!==0&&g!==H.retryLane))throw H.retryLane=g,nl(u,g),Us($,u,g),t1;B1(z)||iy(),c=o1(u,c,f)}else B1(z)?(c.flags|=192,c.child=u.child,c=null):(u=H.treeContext,Ut=Lr(z.nextSibling),ss=c,yt=!0,Ga=null,Dr=!1,u!==null&&y$(c,u),c=a1(c,g.children),c.flags|=4096);return c}return S?(Za(),z=g.fallback,S=c.mode,H=u.child,ue=H.sibling,g=Qi(H,{mode:"hidden",children:g.children}),g.subtreeFlags=H.subtreeFlags&65011712,ue!==null?z=Qi(ue,z):(z=sl(z,S,f,null),z.flags|=2),z.return=c,g.return=c,g.sibling=z,c.child=g,Gd(null,g),g=c.child,z=u.child.memoizedState,z===null?z=r1(f):(S=z.cachePool,S!==null?(H=wn._currentValue,S=S.parent!==H?{parent:H,pool:H}:S):S=T$(),z={baseLanes:z.baseLanes|f,cachePool:S}),g.memoizedState=z,g.childLanes=i1(u,$,f),c.memoizedState=s1,Gd(u.child,g)):(Ja(c),f=u.child,u=f.sibling,f=Qi(f,{mode:"visible",children:g.children}),f.return=c,f.sibling=null,u!==null&&($=c.deletions,$===null?(c.deletions=[u],c.flags|=16):$.push(u)),c.child=f,c.memoizedState=null,f)}function a1(u,c){return c=Yg({mode:"visible",children:c},u.mode),c.return=u,u.child=c}function Yg(u,c){return u=ar(22,u,null,c),u.lanes=0,u}function o1(u,c,f){return cl(c,u.child,null,f),u=a1(c,c.pendingProps.children),u.flags|=2,c.memoizedState=null,u}function F_(u,c,f){u.lanes|=c;var g=u.alternate;g!==null&&(g.lanes|=c),Sv(u.return,c,f)}function l1(u,c,f,g,S,T){var $=u.memoizedState;$===null?u.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:g,tail:f,tailMode:S,treeForkCount:T}:($.isBackwards=c,$.rendering=null,$.renderingStartTime=0,$.last=g,$.tail=f,$.tailMode=S,$.treeForkCount=T)}function M_(u,c,f){var g=c.pendingProps,S=g.revealOrder,T=g.tail;g=g.children;var $=fn.current,z=($&2)!==0;if(z?($=$&1|2,c.flags|=128):$&=1,te(fn,$),is(u,c,g,f),g=yt?Rd:0,!z&&u!==null&&(u.flags&128)!==0)e:for(u=c.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&F_(u,f,c);else if(u.tag===19)F_(u,f,c);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===c)break e;for(;u.sibling===null;){if(u.return===null||u.return===c)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}switch(S){case"forwards":for(f=c.child,S=null;f!==null;)u=f.alternate,u!==null&&zg(u)===null&&(S=f),f=f.sibling;f=S,f===null?(S=c.child,c.child=null):(S=f.sibling,f.sibling=null),l1(c,!1,S,f,T,g);break;case"backwards":case"unstable_legacy-backwards":for(f=null,S=c.child,c.child=null;S!==null;){if(u=S.alternate,u!==null&&zg(u)===null){c.child=S;break}u=S.sibling,S.sibling=f,f=S,S=u}l1(c,!0,f,null,T,g);break;case"together":l1(c,!1,null,null,void 0,g);break;default:c.memoizedState=null}return c.child}function ia(u,c,f){if(u!==null&&(c.dependencies=u.dependencies),to|=c.lanes,(f&c.childLanes)===0)if(u!==null){if(Uu(u,c,f,!1),(f&c.childLanes)===0)return null}else return null;if(u!==null&&c.child!==u.child)throw Error(s(153));if(c.child!==null){for(u=c.child,f=Qi(u,u.pendingProps),c.child=f,f.return=c;u.sibling!==null;)u=u.sibling,f=f.sibling=Qi(u,u.pendingProps),f.return=c;f.sibling=null}return c.child}function u1(u,c){return(u.lanes&c)!==0?!0:(u=u.dependencies,!!(u!==null&&_g(u)))}function $W(u,c,f){switch(c.tag){case 3:$e(c,c.stateNode.containerInfo),qa(c,wn,u.memoizedState.cache),rl();break;case 27:case 5:Ae(c);break;case 4:$e(c,c.stateNode.containerInfo);break;case 10:qa(c,c.type,c.memoizedProps.value);break;case 31:if(c.memoizedState!==null)return c.flags|=128,Ov(c),null;break;case 13:var g=c.memoizedState;if(g!==null)return g.dehydrated!==null?(Ja(c),c.flags|=128,null):(f&c.child.childLanes)!==0?L_(u,c,f):(Ja(c),u=ia(u,c,f),u!==null?u.sibling:null);Ja(c);break;case 19:var S=(u.flags&128)!==0;if(g=(f&c.childLanes)!==0,g||(Uu(u,c,f,!1),g=(f&c.childLanes)!==0),S){if(g)return M_(u,c,f);c.flags|=128}if(S=c.memoizedState,S!==null&&(S.rendering=null,S.tail=null,S.lastEffect=null),te(fn,fn.current),g)break;return null;case 22:return c.lanes=0,$_(u,c,f,c.pendingProps);case 24:qa(c,wn,u.memoizedState.cache)}return ia(u,c,f)}function z_(u,c,f){if(u!==null)if(u.memoizedProps!==c.pendingProps)Sn=!0;else{if(!u1(u,f)&&(c.flags&128)===0)return Sn=!1,$W(u,c,f);Sn=(u.flags&131072)!==0}else Sn=!1,yt&&(c.flags&1048576)!==0&&g$(c,Rd,c.index);switch(c.lanes=0,c.tag){case 16:e:{var g=c.pendingProps;if(u=ll(c.elementType),c.type=u,typeof u=="function")pv(u)?(g=dl(u,g),c.tag=1,c=D_(null,c,u,g,f)):(c.tag=0,c=n1(null,c,u,g,f));else{if(u!=null){var S=u.$$typeof;if(S===k){c.tag=11,c=k_(null,c,u,g,f);break e}else if(S===R){c.tag=14,c=E_(null,c,u,g,f);break e}}throw c=ne(u)||u,Error(s(306,c,""))}}return c;case 0:return n1(u,c,c.type,c.pendingProps,f);case 1:return g=c.type,S=dl(g,c.pendingProps),D_(u,c,g,S,f);case 3:e:{if($e(c,c.stateNode.containerInfo),u===null)throw Error(s(387));g=c.pendingProps;var T=c.memoizedState;S=T.element,$v(u,c),Bd(c,g,null,f);var $=c.memoizedState;if(g=$.cache,qa(c,wn,g),g!==T.cache&&Tv(c,[wn],f,!0),Pd(),g=$.element,T.isDehydrated)if(T={element:g,isDehydrated:!1,cache:$.cache},c.updateQueue.baseState=T,c.memoizedState=T,c.flags&256){c=O_(u,c,g,f);break e}else if(g!==S){S=_r(Error(s(424)),c),Dd(S),c=O_(u,c,g,f);break e}else for(u=c.stateNode.containerInfo,u.nodeType===9?u=u.body:u=u.nodeName==="HTML"?u.ownerDocument.body:u,Ut=Lr(u.firstChild),ss=c,yt=!0,Ga=null,Dr=!0,f=$$(c,null,g,f),c.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(rl(),g===S){c=ia(u,c,f);break e}is(u,c,g,f)}c=c.child}return c;case 26:return Xg(u,c),u===null?(f=XA(c.type,null,c.pendingProps,null))?c.memoizedState=f:yt||(f=c.type,u=c.pendingProps,g=dy(we.current).createElement(f),g[ns]=c,g[Fs]=u,as(g,f,u),jn(g),c.stateNode=g):c.memoizedState=XA(c.type,u.memoizedProps,c.pendingProps,u.memoizedState),null;case 27:return Ae(c),u===null&&yt&&(g=c.stateNode=HA(c.type,c.pendingProps,we.current),ss=c,Dr=!0,S=Ut,ao(c.type)?(U1=S,Ut=Lr(g.firstChild)):Ut=S),is(u,c,c.pendingProps.children,f),Xg(u,c),u===null&&(c.flags|=4194304),c.child;case 5:return u===null&&yt&&((S=g=Ut)&&(g=iG(g,c.type,c.pendingProps,Dr),g!==null?(c.stateNode=g,ss=c,Ut=Lr(g.firstChild),Dr=!1,S=!0):S=!1),S||Ha(c)),Ae(c),S=c.type,T=c.pendingProps,$=u!==null?u.memoizedProps:null,g=T.children,M1(S,T)?g=null:$!==null&&M1(S,$)&&(c.flags|=32),c.memoizedState!==null&&(S=Fv(u,c,wW,null,null,f),of._currentValue=S),Xg(u,c),is(u,c,g,f),c.child;case 6:return u===null&&yt&&((u=f=Ut)&&(f=aG(f,c.pendingProps,Dr),f!==null?(c.stateNode=f,ss=c,Ut=null,u=!0):u=!1),u||Ha(c)),null;case 13:return L_(u,c,f);case 4:return $e(c,c.stateNode.containerInfo),g=c.pendingProps,u===null?c.child=cl(c,null,g,f):is(u,c,g,f),c.child;case 11:return k_(u,c,c.type,c.pendingProps,f);case 7:return is(u,c,c.pendingProps,f),c.child;case 8:return is(u,c,c.pendingProps.children,f),c.child;case 12:return is(u,c,c.pendingProps.children,f),c.child;case 10:return g=c.pendingProps,qa(c,c.type,g.value),is(u,c,g.children,f),c.child;case 9:return S=c.type._context,g=c.pendingProps.children,al(c),S=rs(S),g=g(S),c.flags|=1,is(u,c,g,f),c.child;case 14:return E_(u,c,c.type,c.pendingProps,f);case 15:return I_(u,c,c.type,c.pendingProps,f);case 19:return M_(u,c,f);case 31:return IW(u,c,f);case 22:return $_(u,c,f,c.pendingProps);case 24:return al(c),g=rs(wn),u===null?(S=kv(),S===null&&(S=Lt,T=Cv(),S.pooledCache=T,T.refCount++,T!==null&&(S.pooledCacheLanes|=f),S=T),c.memoizedState={parent:g,cache:S},Iv(c),qa(c,wn,S)):((u.lanes&f)!==0&&($v(u,c),Bd(c,null,null,f),Pd()),S=u.memoizedState,T=c.memoizedState,S.parent!==g?(S={parent:g,cache:g},c.memoizedState=S,c.lanes===0&&(c.memoizedState=c.updateQueue.baseState=S),qa(c,wn,g)):(g=T.cache,qa(c,wn,g),g!==S.cache&&Tv(c,[wn],f,!0))),is(u,c,c.pendingProps.children,f),c.child;case 29:throw c.pendingProps}throw Error(s(156,c.tag))}function aa(u){u.flags|=4}function c1(u,c,f,g,S){if((c=(u.mode&32)!==0)&&(c=!1),c){if(u.flags|=16777216,(S&335544128)===S)if(u.stateNode.complete)u.flags|=8192;else if(hA())u.flags|=8192;else throw ul=Og,Ev}else u.flags&=-16777217}function P_(u,c){if(c.type!=="stylesheet"||(c.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!eR(c))if(hA())u.flags|=8192;else throw ul=Og,Ev}function Jg(u,c){c!==null&&(u.flags|=4),u.flags&16384&&(c=u.tag!==22?bI():536870912,u.lanes|=c,ec|=c)}function Hd(u,c){if(!yt)switch(u.tailMode){case"hidden":c=u.tail;for(var f=null;c!==null;)c.alternate!==null&&(f=c),c=c.sibling;f===null?u.tail=null:f.sibling=null;break;case"collapsed":f=u.tail;for(var g=null;f!==null;)f.alternate!==null&&(g=f),f=f.sibling;g===null?c||u.tail===null?u.tail=null:u.tail.sibling=null:g.sibling=null}}function jt(u){var c=u.alternate!==null&&u.alternate.child===u.child,f=0,g=0;if(c)for(var S=u.child;S!==null;)f|=S.lanes|S.childLanes,g|=S.subtreeFlags&65011712,g|=S.flags&65011712,S.return=u,S=S.sibling;else for(S=u.child;S!==null;)f|=S.lanes|S.childLanes,g|=S.subtreeFlags,g|=S.flags,S.return=u,S=S.sibling;return u.subtreeFlags|=g,u.childLanes=f,c}function _W(u,c,f){var g=c.pendingProps;switch(bv(c),c.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jt(c),null;case 1:return jt(c),null;case 3:return f=c.stateNode,g=null,u!==null&&(g=u.memoizedState.cache),c.memoizedState.cache!==g&&(c.flags|=2048),na(wn),be(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(u===null||u.child===null)&&(Vu(c)?aa(c):u===null||u.memoizedState.isDehydrated&&(c.flags&256)===0||(c.flags|=1024,wv())),jt(c),null;case 26:var S=c.type,T=c.memoizedState;return u===null?(aa(c),T!==null?(jt(c),P_(c,T)):(jt(c),c1(c,S,null,g,f))):T?T!==u.memoizedState?(aa(c),jt(c),P_(c,T)):(jt(c),c.flags&=-16777217):(u=u.memoizedProps,u!==g&&aa(c),jt(c),c1(c,S,u,g,f)),null;case 27:if(ze(c),f=we.current,S=c.type,u!==null&&c.stateNode!=null)u.memoizedProps!==g&&aa(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return jt(c),null}u=le.current,Vu(c)?b$(c):(u=HA(S,g,f),c.stateNode=u,aa(c))}return jt(c),null;case 5:if(ze(c),S=c.type,u!==null&&c.stateNode!=null)u.memoizedProps!==g&&aa(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return jt(c),null}if(T=le.current,Vu(c))b$(c);else{var $=dy(we.current);switch(T){case 1:T=$.createElementNS("http://www.w3.org/2000/svg",S);break;case 2:T=$.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;default:switch(S){case"svg":T=$.createElementNS("http://www.w3.org/2000/svg",S);break;case"math":T=$.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;case"script":T=$.createElement("div"),T.innerHTML="<script><\/script>",T=T.removeChild(T.firstChild);break;case"select":T=typeof g.is=="string"?$.createElement("select",{is:g.is}):$.createElement("select"),g.multiple?T.multiple=!0:g.size&&(T.size=g.size);break;default:T=typeof g.is=="string"?$.createElement(S,{is:g.is}):$.createElement(S)}}T[ns]=c,T[Fs]=g;e:for($=c.child;$!==null;){if($.tag===5||$.tag===6)T.appendChild($.stateNode);else if($.tag!==4&&$.tag!==27&&$.child!==null){$.child.return=$,$=$.child;continue}if($===c)break e;for(;$.sibling===null;){if($.return===null||$.return===c)break e;$=$.return}$.sibling.return=$.return,$=$.sibling}c.stateNode=T;e:switch(as(T,S,g),S){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break e;case"img":g=!0;break e;default:g=!1}g&&aa(c)}}return jt(c),c1(c,c.type,u===null?null:u.memoizedProps,c.pendingProps,f),null;case 6:if(u&&c.stateNode!=null)u.memoizedProps!==g&&aa(c);else{if(typeof g!="string"&&c.stateNode===null)throw Error(s(166));if(u=we.current,Vu(c)){if(u=c.stateNode,f=c.memoizedProps,g=null,S=ss,S!==null)switch(S.tag){case 27:case 5:g=S.memoizedProps}u[ns]=c,u=!!(u.nodeValue===f||g!==null&&g.suppressHydrationWarning===!0||LA(u.nodeValue,f)),u||Ha(c,!0)}else u=dy(u).createTextNode(g),u[ns]=c,c.stateNode=u}return jt(c),null;case 31:if(f=c.memoizedState,u===null||u.memoizedState!==null){if(g=Vu(c),f!==null){if(u===null){if(!g)throw Error(s(318));if(u=c.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(557));u[ns]=c}else rl(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;jt(c),u=!1}else f=wv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=f),u=!0;if(!u)return c.flags&256?(lr(c),c):(lr(c),null);if((c.flags&128)!==0)throw Error(s(558))}return jt(c),null;case 13:if(g=c.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(S=Vu(c),g!==null&&g.dehydrated!==null){if(u===null){if(!S)throw Error(s(318));if(S=c.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(s(317));S[ns]=c}else rl(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;jt(c),S=!1}else S=wv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=S),S=!0;if(!S)return c.flags&256?(lr(c),c):(lr(c),null)}return lr(c),(c.flags&128)!==0?(c.lanes=f,c):(f=g!==null,u=u!==null&&u.memoizedState!==null,f&&(g=c.child,S=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(S=g.alternate.memoizedState.cachePool.pool),T=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(T=g.memoizedState.cachePool.pool),T!==S&&(g.flags|=2048)),f!==u&&f&&(c.child.flags|=8192),Jg(c,c.updateQueue),jt(c),null);case 4:return be(),u===null&&R1(c.stateNode.containerInfo),jt(c),null;case 10:return na(c.type),jt(c),null;case 19:if(j(fn),g=c.memoizedState,g===null)return jt(c),null;if(S=(c.flags&128)!==0,T=g.rendering,T===null)if(S)Hd(g,!1);else{if(rn!==0||u!==null&&(u.flags&128)!==0)for(u=c.child;u!==null;){if(T=zg(u),T!==null){for(c.flags|=128,Hd(g,!1),u=T.updateQueue,c.updateQueue=u,Jg(c,u),c.subtreeFlags=0,u=f,f=c.child;f!==null;)f$(f,u),f=f.sibling;return te(fn,fn.current&1|2),yt&&ea(c,g.treeForkCount),c.child}u=u.sibling}g.tail!==null&&Vt()>ny&&(c.flags|=128,S=!0,Hd(g,!1),c.lanes=4194304)}else{if(!S)if(u=zg(T),u!==null){if(c.flags|=128,S=!0,u=u.updateQueue,c.updateQueue=u,Jg(c,u),Hd(g,!0),g.tail===null&&g.tailMode==="hidden"&&!T.alternate&&!yt)return jt(c),null}else 2*Vt()-g.renderingStartTime>ny&&f!==536870912&&(c.flags|=128,S=!0,Hd(g,!1),c.lanes=4194304);g.isBackwards?(T.sibling=c.child,c.child=T):(u=g.last,u!==null?u.sibling=T:c.child=T,g.last=T)}return g.tail!==null?(u=g.tail,g.rendering=u,g.tail=u.sibling,g.renderingStartTime=Vt(),u.sibling=null,f=fn.current,te(fn,S?f&1|2:f&1),yt&&ea(c,g.treeForkCount),u):(jt(c),null);case 22:case 23:return lr(c),Dv(),g=c.memoizedState!==null,u!==null?u.memoizedState!==null!==g&&(c.flags|=8192):g&&(c.flags|=8192),g?(f&536870912)!==0&&(c.flags&128)===0&&(jt(c),c.subtreeFlags&6&&(c.flags|=8192)):jt(c),f=c.updateQueue,f!==null&&Jg(c,f.retryQueue),f=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(f=u.memoizedState.cachePool.pool),g=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(g=c.memoizedState.cachePool.pool),g!==f&&(c.flags|=2048),u!==null&&j(ol),null;case 24:return f=null,u!==null&&(f=u.memoizedState.cache),c.memoizedState.cache!==f&&(c.flags|=2048),na(wn),jt(c),null;case 25:return null;case 30:return null}throw Error(s(156,c.tag))}function AW(u,c){switch(bv(c),c.tag){case 1:return u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 3:return na(wn),be(),u=c.flags,(u&65536)!==0&&(u&128)===0?(c.flags=u&-65537|128,c):null;case 26:case 27:case 5:return ze(c),null;case 31:if(c.memoizedState!==null){if(lr(c),c.alternate===null)throw Error(s(340));rl()}return u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 13:if(lr(c),u=c.memoizedState,u!==null&&u.dehydrated!==null){if(c.alternate===null)throw Error(s(340));rl()}return u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 19:return j(fn),null;case 4:return be(),null;case 10:return na(c.type),null;case 22:case 23:return lr(c),Dv(),u!==null&&j(ol),u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 24:return na(wn),null;case 25:return null;default:return null}}function B_(u,c){switch(bv(c),c.tag){case 3:na(wn),be();break;case 26:case 27:case 5:ze(c);break;case 4:be();break;case 31:c.memoizedState!==null&&lr(c);break;case 13:lr(c);break;case 19:j(fn);break;case 10:na(c.type);break;case 22:case 23:lr(c),Dv(),u!==null&&j(ol);break;case 24:na(wn)}}function qd(u,c){try{var f=c.updateQueue,g=f!==null?f.lastEffect:null;if(g!==null){var S=g.next;f=S;do{if((f.tag&u)===u){g=void 0;var T=f.create,$=f.inst;g=T(),$.destroy=g}f=f.next}while(f!==S)}}catch(z){Et(c,c.return,z)}}function Qa(u,c,f){try{var g=c.updateQueue,S=g!==null?g.lastEffect:null;if(S!==null){var T=S.next;g=T;do{if((g.tag&u)===u){var $=g.inst,z=$.destroy;if(z!==void 0){$.destroy=void 0,S=c;var H=f,ue=z;try{ue()}catch(ge){Et(S,H,ge)}}}g=g.next}while(g!==T)}}catch(ge){Et(c,c.return,ge)}}function V_(u){var c=u.updateQueue;if(c!==null){var f=u.stateNode;try{A$(c,f)}catch(g){Et(u,u.return,g)}}}function U_(u,c,f){f.props=dl(u.type,u.memoizedProps),f.state=u.memoizedState;try{f.componentWillUnmount()}catch(g){Et(u,c,g)}}function Kd(u,c){try{var f=u.ref;if(f!==null){switch(u.tag){case 26:case 27:case 5:var g=u.stateNode;break;case 30:g=u.stateNode;break;default:g=u.stateNode}typeof f=="function"?u.refCleanup=f(g):f.current=g}}catch(S){Et(u,c,S)}}function Ii(u,c){var f=u.ref,g=u.refCleanup;if(f!==null)if(typeof g=="function")try{g()}catch(S){Et(u,c,S)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(S){Et(u,c,S)}else f.current=null}function j_(u){var c=u.type,f=u.memoizedProps,g=u.stateNode;try{e:switch(c){case"button":case"input":case"select":case"textarea":f.autoFocus&&g.focus();break e;case"img":f.src?g.src=f.src:f.srcSet&&(g.srcset=f.srcSet)}}catch(S){Et(u,u.return,S)}}function h1(u,c,f){try{var g=u.stateNode;QW(g,u.type,f,c),g[Fs]=c}catch(S){Et(u,u.return,S)}}function W_(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27&&ao(u.type)||u.tag===4}function d1(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||W_(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.tag===27&&ao(u.type)||u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function f1(u,c,f){var g=u.tag;if(g===5||g===6)u=u.stateNode,c?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(u,c):(c=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,c.appendChild(u),f=f._reactRootContainer,f!=null||c.onclick!==null||(c.onclick=Ji));else if(g!==4&&(g===27&&ao(u.type)&&(f=u.stateNode,c=null),u=u.child,u!==null))for(f1(u,c,f),u=u.sibling;u!==null;)f1(u,c,f),u=u.sibling}function Zg(u,c,f){var g=u.tag;if(g===5||g===6)u=u.stateNode,c?f.insertBefore(u,c):f.appendChild(u);else if(g!==4&&(g===27&&ao(u.type)&&(f=u.stateNode),u=u.child,u!==null))for(Zg(u,c,f),u=u.sibling;u!==null;)Zg(u,c,f),u=u.sibling}function G_(u){var c=u.stateNode,f=u.memoizedProps;try{for(var g=u.type,S=c.attributes;S.length;)c.removeAttributeNode(S[0]);as(c,g,f),c[ns]=u,c[Fs]=f}catch(T){Et(u,u.return,T)}}var oa=!1,Tn=!1,p1=!1,H_=typeof WeakSet=="function"?WeakSet:Set,Wn=null;function RW(u,c){if(u=u.containerInfo,L1=xy,u=r$(u),ov(u)){if("selectionStart"in u)var f={start:u.selectionStart,end:u.selectionEnd};else e:{f=(f=u.ownerDocument)&&f.defaultView||window;var g=f.getSelection&&f.getSelection();if(g&&g.rangeCount!==0){f=g.anchorNode;var S=g.anchorOffset,T=g.focusNode;g=g.focusOffset;try{f.nodeType,T.nodeType}catch{f=null;break e}var $=0,z=-1,H=-1,ue=0,ge=0,xe=u,ce=null;t:for(;;){for(var de;xe!==f||S!==0&&xe.nodeType!==3||(z=$+S),xe!==T||g!==0&&xe.nodeType!==3||(H=$+g),xe.nodeType===3&&($+=xe.nodeValue.length),(de=xe.firstChild)!==null;)ce=xe,xe=de;for(;;){if(xe===u)break t;if(ce===f&&++ue===S&&(z=$),ce===T&&++ge===g&&(H=$),(de=xe.nextSibling)!==null)break;xe=ce,ce=xe.parentNode}xe=de}f=z===-1||H===-1?null:{start:z,end:H}}else f=null}f=f||{start:0,end:0}}else f=null;for(F1={focusedElem:u,selectionRange:f},xy=!1,Wn=c;Wn!==null;)if(c=Wn,u=c.child,(c.subtreeFlags&1028)!==0&&u!==null)u.return=c,Wn=u;else for(;Wn!==null;){switch(c=Wn,T=c.alternate,u=c.flags,c.tag){case 0:if((u&4)!==0&&(u=c.updateQueue,u=u!==null?u.events:null,u!==null))for(f=0;f<u.length;f++)S=u[f],S.ref.impl=S.nextImpl;break;case 11:case 15:break;case 1:if((u&1024)!==0&&T!==null){u=void 0,f=c,S=T.memoizedProps,T=T.memoizedState,g=f.stateNode;try{var De=dl(f.type,S);u=g.getSnapshotBeforeUpdate(De,T),g.__reactInternalSnapshotBeforeUpdate=u}catch(je){Et(f,f.return,je)}}break;case 3:if((u&1024)!==0){if(u=c.stateNode.containerInfo,f=u.nodeType,f===9)P1(u);else if(f===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":P1(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=c.sibling,u!==null){u.return=c.return,Wn=u;break}Wn=c.return}}function q_(u,c,f){var g=f.flags;switch(f.tag){case 0:case 11:case 15:ua(u,f),g&4&&qd(5,f);break;case 1:if(ua(u,f),g&4)if(u=f.stateNode,c===null)try{u.componentDidMount()}catch($){Et(f,f.return,$)}else{var S=dl(f.type,c.memoizedProps);c=c.memoizedState;try{u.componentDidUpdate(S,c,u.__reactInternalSnapshotBeforeUpdate)}catch($){Et(f,f.return,$)}}g&64&&V_(f),g&512&&Kd(f,f.return);break;case 3:if(ua(u,f),g&64&&(u=f.updateQueue,u!==null)){if(c=null,f.child!==null)switch(f.child.tag){case 27:case 5:c=f.child.stateNode;break;case 1:c=f.child.stateNode}try{A$(u,c)}catch($){Et(f,f.return,$)}}break;case 27:c===null&&g&4&&G_(f);case 26:case 5:ua(u,f),c===null&&g&4&&j_(f),g&512&&Kd(f,f.return);break;case 12:ua(u,f);break;case 31:ua(u,f),g&4&&Y_(u,f);break;case 13:ua(u,f),g&4&&J_(u,f),g&64&&(u=f.memoizedState,u!==null&&(u=u.dehydrated,u!==null&&(f=VW.bind(null,f),oG(u,f))));break;case 22:if(g=f.memoizedState!==null||oa,!g){c=c!==null&&c.memoizedState!==null||Tn,S=oa;var T=Tn;oa=g,(Tn=c)&&!T?ca(u,f,(f.subtreeFlags&8772)!==0):ua(u,f),oa=S,Tn=T}break;case 30:break;default:ua(u,f)}}function K_(u){var c=u.alternate;c!==null&&(u.alternate=null,K_(c)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(c=u.stateNode,c!==null&&Ww(c)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var Ht=null,zs=!1;function la(u,c,f){for(f=f.child;f!==null;)X_(u,c,f),f=f.sibling}function X_(u,c,f){if(Cs&&typeof Cs.onCommitFiberUnmount=="function")try{Cs.onCommitFiberUnmount(Ci,f)}catch{}switch(f.tag){case 26:Tn||Ii(f,c),la(u,c,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:Tn||Ii(f,c);var g=Ht,S=zs;ao(f.type)&&(Ht=f.stateNode,zs=!1),la(u,c,f),sf(f.stateNode),Ht=g,zs=S;break;case 5:Tn||Ii(f,c);case 6:if(g=Ht,S=zs,Ht=null,la(u,c,f),Ht=g,zs=S,Ht!==null)if(zs)try{(Ht.nodeType===9?Ht.body:Ht.nodeName==="HTML"?Ht.ownerDocument.body:Ht).removeChild(f.stateNode)}catch(T){Et(f,c,T)}else try{Ht.removeChild(f.stateNode)}catch(T){Et(f,c,T)}break;case 18:Ht!==null&&(zs?(u=Ht,VA(u.nodeType===9?u.body:u.nodeName==="HTML"?u.ownerDocument.body:u,f.stateNode),lc(u)):VA(Ht,f.stateNode));break;case 4:g=Ht,S=zs,Ht=f.stateNode.containerInfo,zs=!0,la(u,c,f),Ht=g,zs=S;break;case 0:case 11:case 14:case 15:Qa(2,f,c),Tn||Qa(4,f,c),la(u,c,f);break;case 1:Tn||(Ii(f,c),g=f.stateNode,typeof g.componentWillUnmount=="function"&&U_(f,c,g)),la(u,c,f);break;case 21:la(u,c,f);break;case 22:Tn=(g=Tn)||f.memoizedState!==null,la(u,c,f),Tn=g;break;default:la(u,c,f)}}function Y_(u,c){if(c.memoizedState===null&&(u=c.alternate,u!==null&&(u=u.memoizedState,u!==null))){u=u.dehydrated;try{lc(u)}catch(f){Et(c,c.return,f)}}}function J_(u,c){if(c.memoizedState===null&&(u=c.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{lc(u)}catch(f){Et(c,c.return,f)}}function DW(u){switch(u.tag){case 31:case 13:case 19:var c=u.stateNode;return c===null&&(c=u.stateNode=new H_),c;case 22:return u=u.stateNode,c=u._retryCache,c===null&&(c=u._retryCache=new H_),c;default:throw Error(s(435,u.tag))}}function Qg(u,c){var f=DW(u);c.forEach(function(g){if(!f.has(g)){f.add(g);var S=UW.bind(null,u,g);g.then(S,S)}})}function Ps(u,c){var f=c.deletions;if(f!==null)for(var g=0;g<f.length;g++){var S=f[g],T=u,$=c,z=$;e:for(;z!==null;){switch(z.tag){case 27:if(ao(z.type)){Ht=z.stateNode,zs=!1;break e}break;case 5:Ht=z.stateNode,zs=!1;break e;case 3:case 4:Ht=z.stateNode.containerInfo,zs=!0;break e}z=z.return}if(Ht===null)throw Error(s(160));X_(T,$,S),Ht=null,zs=!1,T=S.alternate,T!==null&&(T.return=null),S.return=null}if(c.subtreeFlags&13886)for(c=c.child;c!==null;)Z_(c,u),c=c.sibling}var ei=null;function Z_(u,c){var f=u.alternate,g=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:Ps(c,u),Bs(u),g&4&&(Qa(3,u,u.return),qd(3,u),Qa(5,u,u.return));break;case 1:Ps(c,u),Bs(u),g&512&&(Tn||f===null||Ii(f,f.return)),g&64&&oa&&(u=u.updateQueue,u!==null&&(g=u.callbacks,g!==null&&(f=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=f===null?g:f.concat(g))));break;case 26:var S=ei;if(Ps(c,u),Bs(u),g&512&&(Tn||f===null||Ii(f,f.return)),g&4){var T=f!==null?f.memoizedState:null;if(g=u.memoizedState,f===null)if(g===null)if(u.stateNode===null){e:{g=u.type,f=u.memoizedProps,S=S.ownerDocument||S;t:switch(g){case"title":T=S.getElementsByTagName("title")[0],(!T||T[vd]||T[ns]||T.namespaceURI==="http://www.w3.org/2000/svg"||T.hasAttribute("itemprop"))&&(T=S.createElement(g),S.head.insertBefore(T,S.querySelector("head > title"))),as(T,g,f),T[ns]=u,jn(T),g=T;break e;case"link":var $=ZA("link","href",S).get(g+(f.href||""));if($){for(var z=0;z<$.length;z++)if(T=$[z],T.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&T.getAttribute("rel")===(f.rel==null?null:f.rel)&&T.getAttribute("title")===(f.title==null?null:f.title)&&T.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){$.splice(z,1);break t}}T=S.createElement(g),as(T,g,f),S.head.appendChild(T);break;case"meta":if($=ZA("meta","content",S).get(g+(f.content||""))){for(z=0;z<$.length;z++)if(T=$[z],T.getAttribute("content")===(f.content==null?null:""+f.content)&&T.getAttribute("name")===(f.name==null?null:f.name)&&T.getAttribute("property")===(f.property==null?null:f.property)&&T.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&T.getAttribute("charset")===(f.charSet==null?null:f.charSet)){$.splice(z,1);break t}}T=S.createElement(g),as(T,g,f),S.head.appendChild(T);break;default:throw Error(s(468,g))}T[ns]=u,jn(T),g=T}u.stateNode=g}else QA(S,u.type,u.stateNode);else u.stateNode=JA(S,g,u.memoizedProps);else T!==g?(T===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):T.count--,g===null?QA(S,u.type,u.stateNode):JA(S,g,u.memoizedProps)):g===null&&u.stateNode!==null&&h1(u,u.memoizedProps,f.memoizedProps)}break;case 27:Ps(c,u),Bs(u),g&512&&(Tn||f===null||Ii(f,f.return)),f!==null&&g&4&&h1(u,u.memoizedProps,f.memoizedProps);break;case 5:if(Ps(c,u),Bs(u),g&512&&(Tn||f===null||Ii(f,f.return)),u.flags&32){S=u.stateNode;try{Au(S,"")}catch(De){Et(u,u.return,De)}}g&4&&u.stateNode!=null&&(S=u.memoizedProps,h1(u,S,f!==null?f.memoizedProps:S)),g&1024&&(p1=!0);break;case 6:if(Ps(c,u),Bs(u),g&4){if(u.stateNode===null)throw Error(s(162));g=u.memoizedProps,f=u.stateNode;try{f.nodeValue=g}catch(De){Et(u,u.return,De)}}break;case 3:if(my=null,S=ei,ei=fy(c.containerInfo),Ps(c,u),ei=S,Bs(u),g&4&&f!==null&&f.memoizedState.isDehydrated)try{lc(c.containerInfo)}catch(De){Et(u,u.return,De)}p1&&(p1=!1,Q_(u));break;case 4:g=ei,ei=fy(u.stateNode.containerInfo),Ps(c,u),Bs(u),ei=g;break;case 12:Ps(c,u),Bs(u);break;case 31:Ps(c,u),Bs(u),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,Qg(u,g)));break;case 13:Ps(c,u),Bs(u),u.child.flags&8192&&u.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(ty=Vt()),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,Qg(u,g)));break;case 22:S=u.memoizedState!==null;var H=f!==null&&f.memoizedState!==null,ue=oa,ge=Tn;if(oa=ue||S,Tn=ge||H,Ps(c,u),Tn=ge,oa=ue,Bs(u),g&8192)e:for(c=u.stateNode,c._visibility=S?c._visibility&-2:c._visibility|1,S&&(f===null||H||oa||Tn||fl(u)),f=null,c=u;;){if(c.tag===5||c.tag===26){if(f===null){H=f=c;try{if(T=H.stateNode,S)$=T.style,typeof $.setProperty=="function"?$.setProperty("display","none","important"):$.display="none";else{z=H.stateNode;var xe=H.memoizedProps.style,ce=xe!=null&&xe.hasOwnProperty("display")?xe.display:null;z.style.display=ce==null||typeof ce=="boolean"?"":(""+ce).trim()}}catch(De){Et(H,H.return,De)}}}else if(c.tag===6){if(f===null){H=c;try{H.stateNode.nodeValue=S?"":H.memoizedProps}catch(De){Et(H,H.return,De)}}}else if(c.tag===18){if(f===null){H=c;try{var de=H.stateNode;S?UA(de,!0):UA(H.stateNode,!1)}catch(De){Et(H,H.return,De)}}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===u)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===u)break e;for(;c.sibling===null;){if(c.return===null||c.return===u)break e;f===c&&(f=null),c=c.return}f===c&&(f=null),c.sibling.return=c.return,c=c.sibling}g&4&&(g=u.updateQueue,g!==null&&(f=g.retryQueue,f!==null&&(g.retryQueue=null,Qg(u,f))));break;case 19:Ps(c,u),Bs(u),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,Qg(u,g)));break;case 30:break;case 21:break;default:Ps(c,u),Bs(u)}}function Bs(u){var c=u.flags;if(c&2){try{for(var f,g=u.return;g!==null;){if(W_(g)){f=g;break}g=g.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var S=f.stateNode,T=d1(u);Zg(u,T,S);break;case 5:var $=f.stateNode;f.flags&32&&(Au($,""),f.flags&=-33);var z=d1(u);Zg(u,z,$);break;case 3:case 4:var H=f.stateNode.containerInfo,ue=d1(u);f1(u,ue,H);break;default:throw Error(s(161))}}catch(ge){Et(u,u.return,ge)}u.flags&=-3}c&4096&&(u.flags&=-4097)}function Q_(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var c=u;Q_(c),c.tag===5&&c.flags&1024&&c.stateNode.reset(),u=u.sibling}}function ua(u,c){if(c.subtreeFlags&8772)for(c=c.child;c!==null;)q_(u,c.alternate,c),c=c.sibling}function fl(u){for(u=u.child;u!==null;){var c=u;switch(c.tag){case 0:case 11:case 14:case 15:Qa(4,c,c.return),fl(c);break;case 1:Ii(c,c.return);var f=c.stateNode;typeof f.componentWillUnmount=="function"&&U_(c,c.return,f),fl(c);break;case 27:sf(c.stateNode);case 26:case 5:Ii(c,c.return),fl(c);break;case 22:c.memoizedState===null&&fl(c);break;case 30:fl(c);break;default:fl(c)}u=u.sibling}}function ca(u,c,f){for(f=f&&(c.subtreeFlags&8772)!==0,c=c.child;c!==null;){var g=c.alternate,S=u,T=c,$=T.flags;switch(T.tag){case 0:case 11:case 15:ca(S,T,f),qd(4,T);break;case 1:if(ca(S,T,f),g=T,S=g.stateNode,typeof S.componentDidMount=="function")try{S.componentDidMount()}catch(ue){Et(g,g.return,ue)}if(g=T,S=g.updateQueue,S!==null){var z=g.stateNode;try{var H=S.shared.hiddenCallbacks;if(H!==null)for(S.shared.hiddenCallbacks=null,S=0;S<H.length;S++)_$(H[S],z)}catch(ue){Et(g,g.return,ue)}}f&&$&64&&V_(T),Kd(T,T.return);break;case 27:G_(T);case 26:case 5:ca(S,T,f),f&&g===null&&$&4&&j_(T),Kd(T,T.return);break;case 12:ca(S,T,f);break;case 31:ca(S,T,f),f&&$&4&&Y_(S,T);break;case 13:ca(S,T,f),f&&$&4&&J_(S,T);break;case 22:T.memoizedState===null&&ca(S,T,f),Kd(T,T.return);break;case 30:break;default:ca(S,T,f)}c=c.sibling}}function m1(u,c){var f=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(f=u.memoizedState.cachePool.pool),u=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(u=c.memoizedState.cachePool.pool),u!==f&&(u!=null&&u.refCount++,f!=null&&Od(f))}function g1(u,c){u=null,c.alternate!==null&&(u=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==u&&(c.refCount++,u!=null&&Od(u))}function ti(u,c,f,g){if(c.subtreeFlags&10256)for(c=c.child;c!==null;)eA(u,c,f,g),c=c.sibling}function eA(u,c,f,g){var S=c.flags;switch(c.tag){case 0:case 11:case 15:ti(u,c,f,g),S&2048&&qd(9,c);break;case 1:ti(u,c,f,g);break;case 3:ti(u,c,f,g),S&2048&&(u=null,c.alternate!==null&&(u=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==u&&(c.refCount++,u!=null&&Od(u)));break;case 12:if(S&2048){ti(u,c,f,g),u=c.stateNode;try{var T=c.memoizedProps,$=T.id,z=T.onPostCommit;typeof z=="function"&&z($,c.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(H){Et(c,c.return,H)}}else ti(u,c,f,g);break;case 31:ti(u,c,f,g);break;case 13:ti(u,c,f,g);break;case 23:break;case 22:T=c.stateNode,$=c.alternate,c.memoizedState!==null?T._visibility&2?ti(u,c,f,g):Xd(u,c):T._visibility&2?ti(u,c,f,g):(T._visibility|=2,Ju(u,c,f,g,(c.subtreeFlags&10256)!==0||!1)),S&2048&&m1($,c);break;case 24:ti(u,c,f,g),S&2048&&g1(c.alternate,c);break;default:ti(u,c,f,g)}}function Ju(u,c,f,g,S){for(S=S&&((c.subtreeFlags&10256)!==0||!1),c=c.child;c!==null;){var T=u,$=c,z=f,H=g,ue=$.flags;switch($.tag){case 0:case 11:case 15:Ju(T,$,z,H,S),qd(8,$);break;case 23:break;case 22:var ge=$.stateNode;$.memoizedState!==null?ge._visibility&2?Ju(T,$,z,H,S):Xd(T,$):(ge._visibility|=2,Ju(T,$,z,H,S)),S&&ue&2048&&m1($.alternate,$);break;case 24:Ju(T,$,z,H,S),S&&ue&2048&&g1($.alternate,$);break;default:Ju(T,$,z,H,S)}c=c.sibling}}function Xd(u,c){if(c.subtreeFlags&10256)for(c=c.child;c!==null;){var f=u,g=c,S=g.flags;switch(g.tag){case 22:Xd(f,g),S&2048&&m1(g.alternate,g);break;case 24:Xd(f,g),S&2048&&g1(g.alternate,g);break;default:Xd(f,g)}c=c.sibling}}var Yd=8192;function Zu(u,c,f){if(u.subtreeFlags&Yd)for(u=u.child;u!==null;)tA(u,c,f),u=u.sibling}function tA(u,c,f){switch(u.tag){case 26:Zu(u,c,f),u.flags&Yd&&u.memoizedState!==null&&xG(f,ei,u.memoizedState,u.memoizedProps);break;case 5:Zu(u,c,f);break;case 3:case 4:var g=ei;ei=fy(u.stateNode.containerInfo),Zu(u,c,f),ei=g;break;case 22:u.memoizedState===null&&(g=u.alternate,g!==null&&g.memoizedState!==null?(g=Yd,Yd=16777216,Zu(u,c,f),Yd=g):Zu(u,c,f));break;default:Zu(u,c,f)}}function nA(u){var c=u.alternate;if(c!==null&&(u=c.child,u!==null)){c.child=null;do c=u.sibling,u.sibling=null,u=c;while(u!==null)}}function Jd(u){var c=u.deletions;if((u.flags&16)!==0){if(c!==null)for(var f=0;f<c.length;f++){var g=c[f];Wn=g,rA(g,u)}nA(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)sA(u),u=u.sibling}function sA(u){switch(u.tag){case 0:case 11:case 15:Jd(u),u.flags&2048&&Qa(9,u,u.return);break;case 3:Jd(u);break;case 12:Jd(u);break;case 22:var c=u.stateNode;u.memoizedState!==null&&c._visibility&2&&(u.return===null||u.return.tag!==13)?(c._visibility&=-3,ey(u)):Jd(u);break;default:Jd(u)}}function ey(u){var c=u.deletions;if((u.flags&16)!==0){if(c!==null)for(var f=0;f<c.length;f++){var g=c[f];Wn=g,rA(g,u)}nA(u)}for(u=u.child;u!==null;){switch(c=u,c.tag){case 0:case 11:case 15:Qa(8,c,c.return),ey(c);break;case 22:f=c.stateNode,f._visibility&2&&(f._visibility&=-3,ey(c));break;default:ey(c)}u=u.sibling}}function rA(u,c){for(;Wn!==null;){var f=Wn;switch(f.tag){case 0:case 11:case 15:Qa(8,f,c);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var g=f.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Od(f.memoizedState.cache)}if(g=f.child,g!==null)g.return=f,Wn=g;else e:for(f=u;Wn!==null;){g=Wn;var S=g.sibling,T=g.return;if(K_(g),g===f){Wn=null;break e}if(S!==null){S.return=T,Wn=S;break e}Wn=T}}}var OW={getCacheForType:function(u){var c=rs(wn),f=c.data.get(u);return f===void 0&&(f=u(),c.data.set(u,f)),f},cacheSignal:function(){return rs(wn).controller.signal}},LW=typeof WeakMap=="function"?WeakMap:Map,Tt=0,Lt=null,ut=null,ft=0,kt=0,ur=null,eo=!1,Qu=!1,y1=!1,ha=0,rn=0,to=0,pl=0,b1=0,cr=0,ec=0,Zd=null,Vs=null,x1=!1,ty=0,iA=0,ny=1/0,sy=null,no=null,Rn=0,so=null,tc=null,da=0,w1=0,v1=null,aA=null,Qd=0,S1=null;function hr(){return(Tt&2)!==0&&ft!==0?ft&-ft:B.T!==null?I1():SI()}function oA(){if(cr===0)if((ft&536870912)===0||yt){var u=hg;hg<<=1,(hg&3932160)===0&&(hg=262144),cr=u}else cr=536870912;return u=or.current,u!==null&&(u.flags|=32),cr}function Us(u,c,f){(u===Lt&&(kt===2||kt===9)||u.cancelPendingCommit!==null)&&(nc(u,0),ro(u,ft,cr,!1)),wd(u,f),((Tt&2)===0||u!==Lt)&&(u===Lt&&((Tt&2)===0&&(pl|=f),rn===4&&ro(u,ft,cr,!1)),$i(u))}function lA(u,c,f){if((Tt&6)!==0)throw Error(s(327));var g=!f&&(c&127)===0&&(c&u.expiredLanes)===0||xd(u,c),S=g?zW(u,c):C1(u,c,!0),T=g;do{if(S===0){Qu&&!g&&ro(u,c,0,!1);break}else{if(f=u.current.alternate,T&&!FW(f)){S=C1(u,c,!1),T=!1;continue}if(S===2){if(T=c,u.errorRecoveryDisabledLanes&T)var $=0;else $=u.pendingLanes&-536870913,$=$!==0?$:$&536870912?536870912:0;if($!==0){c=$;e:{var z=u;S=Zd;var H=z.current.memoizedState.isDehydrated;if(H&&(nc(z,$).flags|=256),$=C1(z,$,!1),$!==2){if(y1&&!H){z.errorRecoveryDisabledLanes|=T,pl|=T,S=4;break e}T=Vs,Vs=S,T!==null&&(Vs===null?Vs=T:Vs.push.apply(Vs,T))}S=$}if(T=!1,S!==2)continue}}if(S===1){nc(u,0),ro(u,c,0,!0);break}e:{switch(g=u,T=S,T){case 0:case 1:throw Error(s(345));case 4:if((c&4194048)!==c)break;case 6:ro(g,c,cr,!eo);break e;case 2:Vs=null;break;case 3:case 5:break;default:throw Error(s(329))}if((c&62914560)===c&&(S=ty+300-Vt(),10<S)){if(ro(g,c,cr,!eo),fg(g,0,!0)!==0)break e;da=c,g.timeoutHandle=PA(uA.bind(null,g,f,Vs,sy,x1,c,cr,pl,ec,eo,T,"Throttled",-0,0),S);break e}uA(g,f,Vs,sy,x1,c,cr,pl,ec,eo,T,null,-0,0)}}break}while(!0);$i(u)}function uA(u,c,f,g,S,T,$,z,H,ue,ge,xe,ce,de){if(u.timeoutHandle=-1,xe=c.subtreeFlags,xe&8192||(xe&16785408)===16785408){xe={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Ji},tA(c,T,xe);var De=(T&62914560)===T?ty-Vt():(T&4194048)===T?iA-Vt():0;if(De=wG(xe,De),De!==null){da=T,u.cancelPendingCommit=De(yA.bind(null,u,c,T,f,g,S,$,z,H,ge,xe,null,ce,de)),ro(u,T,$,!ue);return}}yA(u,c,T,f,g,S,$,z,H)}function FW(u){for(var c=u;;){var f=c.tag;if((f===0||f===11||f===15)&&c.flags&16384&&(f=c.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var g=0;g<f.length;g++){var S=f[g],T=S.getSnapshot;S=S.value;try{if(!ir(T(),S))return!1}catch{return!1}}if(f=c.child,c.subtreeFlags&16384&&f!==null)f.return=c,c=f;else{if(c===u)break;for(;c.sibling===null;){if(c.return===null||c.return===u)return!0;c=c.return}c.sibling.return=c.return,c=c.sibling}}return!0}function ro(u,c,f,g){c&=~b1,c&=~pl,u.suspendedLanes|=c,u.pingedLanes&=~c,g&&(u.warmLanes|=c),g=u.expirationTimes;for(var S=c;0<S;){var T=31-rr(S),$=1<<T;g[T]=-1,S&=~$}f!==0&&xI(u,f,c)}function ry(){return(Tt&6)===0?(ef(0),!1):!0}function T1(){if(ut!==null){if(kt===0)var u=ut.return;else u=ut,ta=il=null,Pv(u),Hu=null,Fd=0,u=ut;for(;u!==null;)B_(u.alternate,u),u=u.return;ut=null}}function nc(u,c){var f=u.timeoutHandle;f!==-1&&(u.timeoutHandle=-1,nG(f)),f=u.cancelPendingCommit,f!==null&&(u.cancelPendingCommit=null,f()),da=0,T1(),Lt=u,ut=f=Qi(u.current,null),ft=c,kt=0,ur=null,eo=!1,Qu=xd(u,c),y1=!1,ec=cr=b1=pl=to=rn=0,Vs=Zd=null,x1=!1,(c&8)!==0&&(c|=c&32);var g=u.entangledLanes;if(g!==0)for(u=u.entanglements,g&=c;0<g;){var S=31-rr(g),T=1<<S;c|=u[S],g&=~T}return ha=c,Ng(),f}function cA(u,c){et=null,B.H=Wd,c===Gu||c===Dg?(c=k$(),kt=3):c===Ev?(c=k$(),kt=4):kt=c===t1?8:c!==null&&typeof c=="object"&&typeof c.then=="function"?6:1,ur=c,ut===null&&(rn=1,qg(u,_r(c,u.current)))}function hA(){var u=or.current;return u===null?!0:(ft&4194048)===ft?Or===null:(ft&62914560)===ft||(ft&536870912)!==0?u===Or:!1}function dA(){var u=B.H;return B.H=Wd,u===null?Wd:u}function fA(){var u=B.A;return B.A=OW,u}function iy(){rn=4,eo||(ft&4194048)!==ft&&or.current!==null||(Qu=!0),(to&134217727)===0&&(pl&134217727)===0||Lt===null||ro(Lt,ft,cr,!1)}function C1(u,c,f){var g=Tt;Tt|=2;var S=dA(),T=fA();(Lt!==u||ft!==c)&&(sy=null,nc(u,c)),c=!1;var $=rn;e:do try{if(kt!==0&&ut!==null){var z=ut,H=ur;switch(kt){case 8:T1(),$=6;break e;case 3:case 2:case 9:case 6:or.current===null&&(c=!0);var ue=kt;if(kt=0,ur=null,sc(u,z,H,ue),f&&Qu){$=0;break e}break;default:ue=kt,kt=0,ur=null,sc(u,z,H,ue)}}MW(),$=rn;break}catch(ge){cA(u,ge)}while(!0);return c&&u.shellSuspendCounter++,ta=il=null,Tt=g,B.H=S,B.A=T,ut===null&&(Lt=null,ft=0,Ng()),$}function MW(){for(;ut!==null;)pA(ut)}function zW(u,c){var f=Tt;Tt|=2;var g=dA(),S=fA();Lt!==u||ft!==c?(sy=null,ny=Vt()+500,nc(u,c)):Qu=xd(u,c);e:do try{if(kt!==0&&ut!==null){c=ut;var T=ur;t:switch(kt){case 1:kt=0,ur=null,sc(u,c,T,1);break;case 2:case 9:if(C$(T)){kt=0,ur=null,mA(c);break}c=function(){kt!==2&&kt!==9||Lt!==u||(kt=7),$i(u)},T.then(c,c);break e;case 3:kt=7;break e;case 4:kt=5;break e;case 7:C$(T)?(kt=0,ur=null,mA(c)):(kt=0,ur=null,sc(u,c,T,7));break;case 5:var $=null;switch(ut.tag){case 26:$=ut.memoizedState;case 5:case 27:var z=ut;if($?eR($):z.stateNode.complete){kt=0,ur=null;var H=z.sibling;if(H!==null)ut=H;else{var ue=z.return;ue!==null?(ut=ue,ay(ue)):ut=null}break t}}kt=0,ur=null,sc(u,c,T,5);break;case 6:kt=0,ur=null,sc(u,c,T,6);break;case 8:T1(),rn=6;break e;default:throw Error(s(462))}}PW();break}catch(ge){cA(u,ge)}while(!0);return ta=il=null,B.H=g,B.A=S,Tt=f,ut!==null?0:(Lt=null,ft=0,Ng(),rn)}function PW(){for(;ut!==null&&!Ts();)pA(ut)}function pA(u){var c=z_(u.alternate,u,ha);u.memoizedProps=u.pendingProps,c===null?ay(u):ut=c}function mA(u){var c=u,f=c.alternate;switch(c.tag){case 15:case 0:c=R_(f,c,c.pendingProps,c.type,void 0,ft);break;case 11:c=R_(f,c,c.pendingProps,c.type.render,c.ref,ft);break;case 5:Pv(c);default:B_(f,c),c=ut=f$(c,ha),c=z_(f,c,ha)}u.memoizedProps=u.pendingProps,c===null?ay(u):ut=c}function sc(u,c,f,g){ta=il=null,Pv(c),Hu=null,Fd=0;var S=c.return;try{if(EW(u,S,c,f,ft)){rn=1,qg(u,_r(f,u.current)),ut=null;return}}catch(T){if(S!==null)throw ut=S,T;rn=1,qg(u,_r(f,u.current)),ut=null;return}c.flags&32768?(yt||g===1?u=!0:Qu||(ft&536870912)!==0?u=!1:(eo=u=!0,(g===2||g===9||g===3||g===6)&&(g=or.current,g!==null&&g.tag===13&&(g.flags|=16384))),gA(c,u)):ay(c)}function ay(u){var c=u;do{if((c.flags&32768)!==0){gA(c,eo);return}u=c.return;var f=_W(c.alternate,c,ha);if(f!==null){ut=f;return}if(c=c.sibling,c!==null){ut=c;return}ut=c=u}while(c!==null);rn===0&&(rn=5)}function gA(u,c){do{var f=AW(u.alternate,u);if(f!==null){f.flags&=32767,ut=f;return}if(f=u.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!c&&(u=u.sibling,u!==null)){ut=u;return}ut=u=f}while(u!==null);rn=6,ut=null}function yA(u,c,f,g,S,T,$,z,H){u.cancelPendingCommit=null;do oy();while(Rn!==0);if((Tt&6)!==0)throw Error(s(327));if(c!==null){if(c===u.current)throw Error(s(177));if(T=c.lanes|c.childLanes,T|=dv,bj(u,f,T,$,z,H),u===Lt&&(ut=Lt=null,ft=0),tc=c,so=u,da=f,w1=T,v1=S,aA=g,(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?(u.callbackNode=null,u.callbackPriority=0,jW(sr,function(){return SA(),null})):(u.callbackNode=null,u.callbackPriority=0),g=(c.flags&13878)!==0,(c.subtreeFlags&13878)!==0||g){g=B.T,B.T=null,S=U.p,U.p=2,$=Tt,Tt|=4;try{RW(u,c,f)}finally{Tt=$,U.p=S,B.T=g}}Rn=1,bA(),xA(),wA()}}function bA(){if(Rn===1){Rn=0;var u=so,c=tc,f=(c.flags&13878)!==0;if((c.subtreeFlags&13878)!==0||f){f=B.T,B.T=null;var g=U.p;U.p=2;var S=Tt;Tt|=4;try{Z_(c,u);var T=F1,$=r$(u.containerInfo),z=T.focusedElem,H=T.selectionRange;if($!==z&&z&&z.ownerDocument&&s$(z.ownerDocument.documentElement,z)){if(H!==null&&ov(z)){var ue=H.start,ge=H.end;if(ge===void 0&&(ge=ue),"selectionStart"in z)z.selectionStart=ue,z.selectionEnd=Math.min(ge,z.value.length);else{var xe=z.ownerDocument||document,ce=xe&&xe.defaultView||window;if(ce.getSelection){var de=ce.getSelection(),De=z.textContent.length,je=Math.min(H.start,De),Dt=H.end===void 0?je:Math.min(H.end,De);!de.extend&&je>Dt&&($=Dt,Dt=je,je=$);var ie=n$(z,je),ee=n$(z,Dt);if(ie&&ee&&(de.rangeCount!==1||de.anchorNode!==ie.node||de.anchorOffset!==ie.offset||de.focusNode!==ee.node||de.focusOffset!==ee.offset)){var oe=xe.createRange();oe.setStart(ie.node,ie.offset),de.removeAllRanges(),je>Dt?(de.addRange(oe),de.extend(ee.node,ee.offset)):(oe.setEnd(ee.node,ee.offset),de.addRange(oe))}}}}for(xe=[],de=z;de=de.parentNode;)de.nodeType===1&&xe.push({element:de,left:de.scrollLeft,top:de.scrollTop});for(typeof z.focus=="function"&&z.focus(),z=0;z<xe.length;z++){var ye=xe[z];ye.element.scrollLeft=ye.left,ye.element.scrollTop=ye.top}}xy=!!L1,F1=L1=null}finally{Tt=S,U.p=g,B.T=f}}u.current=c,Rn=2}}function xA(){if(Rn===2){Rn=0;var u=so,c=tc,f=(c.flags&8772)!==0;if((c.subtreeFlags&8772)!==0||f){f=B.T,B.T=null;var g=U.p;U.p=2;var S=Tt;Tt|=4;try{q_(u,c.alternate,c)}finally{Tt=S,U.p=g,B.T=f}}Rn=3}}function wA(){if(Rn===4||Rn===3){Rn=0,Xi();var u=so,c=tc,f=da,g=aA;(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?Rn=5:(Rn=0,tc=so=null,vA(u,u.pendingLanes));var S=u.pendingLanes;if(S===0&&(no=null),Uw(f),c=c.stateNode,Cs&&typeof Cs.onCommitFiberRoot=="function")try{Cs.onCommitFiberRoot(Ci,c,void 0,(c.current.flags&128)===128)}catch{}if(g!==null){c=B.T,S=U.p,U.p=2,B.T=null;try{for(var T=u.onRecoverableError,$=0;$<g.length;$++){var z=g[$];T(z.value,{componentStack:z.stack})}}finally{B.T=c,U.p=S}}(da&3)!==0&&oy(),$i(u),S=u.pendingLanes,(f&261930)!==0&&(S&42)!==0?u===S1?Qd++:(Qd=0,S1=u):Qd=0,ef(0)}}function vA(u,c){(u.pooledCacheLanes&=c)===0&&(c=u.pooledCache,c!=null&&(u.pooledCache=null,Od(c)))}function oy(){return bA(),xA(),wA(),SA()}function SA(){if(Rn!==5)return!1;var u=so,c=w1;w1=0;var f=Uw(da),g=B.T,S=U.p;try{U.p=32>f?32:f,B.T=null,f=v1,v1=null;var T=so,$=da;if(Rn=0,tc=so=null,da=0,(Tt&6)!==0)throw Error(s(331));var z=Tt;if(Tt|=4,sA(T.current),eA(T,T.current,$,f),Tt=z,ef(0,!1),Cs&&typeof Cs.onPostCommitFiberRoot=="function")try{Cs.onPostCommitFiberRoot(Ci,T)}catch{}return!0}finally{U.p=S,B.T=g,vA(u,c)}}function TA(u,c,f){c=_r(f,c),c=e1(u.stateNode,c,2),u=Ya(u,c,2),u!==null&&(wd(u,2),$i(u))}function Et(u,c,f){if(u.tag===3)TA(u,u,f);else for(;c!==null;){if(c.tag===3){TA(c,u,f);break}else if(c.tag===1){var g=c.stateNode;if(typeof c.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(no===null||!no.has(g))){u=_r(f,u),f=C_(2),g=Ya(c,f,2),g!==null&&(N_(f,g,c,u),wd(g,2),$i(g));break}}c=c.return}}function N1(u,c,f){var g=u.pingCache;if(g===null){g=u.pingCache=new LW;var S=new Set;g.set(c,S)}else S=g.get(c),S===void 0&&(S=new Set,g.set(c,S));S.has(f)||(y1=!0,S.add(f),u=BW.bind(null,u,c,f),c.then(u,u))}function BW(u,c,f){var g=u.pingCache;g!==null&&g.delete(c),u.pingedLanes|=u.suspendedLanes&f,u.warmLanes&=~f,Lt===u&&(ft&f)===f&&(rn===4||rn===3&&(ft&62914560)===ft&&300>Vt()-ty?(Tt&2)===0&&nc(u,0):b1|=f,ec===ft&&(ec=0)),$i(u)}function CA(u,c){c===0&&(c=bI()),u=nl(u,c),u!==null&&(wd(u,c),$i(u))}function VW(u){var c=u.memoizedState,f=0;c!==null&&(f=c.retryLane),CA(u,f)}function UW(u,c){var f=0;switch(u.tag){case 31:case 13:var g=u.stateNode,S=u.memoizedState;S!==null&&(f=S.retryLane);break;case 19:g=u.stateNode;break;case 22:g=u.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(c),CA(u,f)}function jW(u,c){return nn(u,c)}var ly=null,rc=null,k1=!1,uy=!1,E1=!1,io=0;function $i(u){u!==rc&&u.next===null&&(rc===null?ly=rc=u:rc=rc.next=u),uy=!0,k1||(k1=!0,GW())}function ef(u,c){if(!E1&&uy){E1=!0;do for(var f=!1,g=ly;g!==null;){if(u!==0){var S=g.pendingLanes;if(S===0)var T=0;else{var $=g.suspendedLanes,z=g.pingedLanes;T=(1<<31-rr(42|u)+1)-1,T&=S&~($&~z),T=T&201326741?T&201326741|1:T?T|2:0}T!==0&&(f=!0,IA(g,T))}else T=ft,T=fg(g,g===Lt?T:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(T&3)===0||xd(g,T)||(f=!0,IA(g,T));g=g.next}while(f);E1=!1}}function WW(){NA()}function NA(){uy=k1=!1;var u=0;io!==0&&tG()&&(u=io);for(var c=Vt(),f=null,g=ly;g!==null;){var S=g.next,T=kA(g,c);T===0?(g.next=null,f===null?ly=S:f.next=S,S===null&&(rc=f)):(f=g,(u!==0||(T&3)!==0)&&(uy=!0)),g=S}Rn!==0&&Rn!==5||ef(u),io!==0&&(io=0)}function kA(u,c){for(var f=u.suspendedLanes,g=u.pingedLanes,S=u.expirationTimes,T=u.pendingLanes&-62914561;0<T;){var $=31-rr(T),z=1<<$,H=S[$];H===-1?((z&f)===0||(z&g)!==0)&&(S[$]=yj(z,c)):H<=c&&(u.expiredLanes|=z),T&=~z}if(c=Lt,f=ft,f=fg(u,u===c?f:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),g=u.callbackNode,f===0||u===c&&(kt===2||kt===9)||u.cancelPendingCommit!==null)return g!==null&&g!==null&&kr(g),u.callbackNode=null,u.callbackPriority=0;if((f&3)===0||xd(u,f)){if(c=f&-f,c===u.callbackPriority)return c;switch(g!==null&&kr(g),Uw(f)){case 2:case 8:f=Zr;break;case 32:f=sr;break;case 268435456:f=Cu;break;default:f=sr}return g=EA.bind(null,u),f=nn(f,g),u.callbackPriority=c,u.callbackNode=f,c}return g!==null&&g!==null&&kr(g),u.callbackPriority=2,u.callbackNode=null,2}function EA(u,c){if(Rn!==0&&Rn!==5)return u.callbackNode=null,u.callbackPriority=0,null;var f=u.callbackNode;if(oy()&&u.callbackNode!==f)return null;var g=ft;return g=fg(u,u===Lt?g:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),g===0?null:(lA(u,g,c),kA(u,Vt()),u.callbackNode!=null&&u.callbackNode===f?EA.bind(null,u):null)}function IA(u,c){if(oy())return null;lA(u,c,!0)}function GW(){sG(function(){(Tt&6)!==0?nn(Jr,WW):NA()})}function I1(){if(io===0){var u=ju;u===0&&(u=cg,cg<<=1,(cg&261888)===0&&(cg=256)),io=u}return io}function $A(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:yg(""+u)}function _A(u,c){var f=c.ownerDocument.createElement("input");return f.name=c.name,f.value=c.value,u.id&&f.setAttribute("form",u.id),c.parentNode.insertBefore(f,c),u=new FormData(u),f.parentNode.removeChild(f),u}function HW(u,c,f,g,S){if(c==="submit"&&f&&f.stateNode===S){var T=$A((S[Fs]||null).action),$=g.submitter;$&&(c=(c=$[Fs]||null)?$A(c.formAction):$.getAttribute("formAction"),c!==null&&(T=c,$=null));var z=new vg("action","action",null,g,S);u.push({event:z,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(io!==0){var H=$?_A(S,$):new FormData(S);Kv(f,{pending:!0,data:H,method:S.method,action:T},null,H)}}else typeof T=="function"&&(z.preventDefault(),H=$?_A(S,$):new FormData(S),Kv(f,{pending:!0,data:H,method:S.method,action:T},T,H))},currentTarget:S}]})}}for(var $1=0;$1<hv.length;$1++){var _1=hv[$1],qW=_1.toLowerCase(),KW=_1[0].toUpperCase()+_1.slice(1);Qr(qW,"on"+KW)}Qr(o$,"onAnimationEnd"),Qr(l$,"onAnimationIteration"),Qr(u$,"onAnimationStart"),Qr("dblclick","onDoubleClick"),Qr("focusin","onFocus"),Qr("focusout","onBlur"),Qr(cW,"onTransitionRun"),Qr(hW,"onTransitionStart"),Qr(dW,"onTransitionCancel"),Qr(c$,"onTransitionEnd"),$u("onMouseEnter",["mouseout","mouseover"]),$u("onMouseLeave",["mouseout","mouseover"]),$u("onPointerEnter",["pointerout","pointerover"]),$u("onPointerLeave",["pointerout","pointerover"]),Zo("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Zo("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Zo("onBeforeInput",["compositionend","keypress","textInput","paste"]),Zo("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Zo("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Zo("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var tf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),XW=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(tf));function AA(u,c){c=(c&4)!==0;for(var f=0;f<u.length;f++){var g=u[f],S=g.event;g=g.listeners;e:{var T=void 0;if(c)for(var $=g.length-1;0<=$;$--){var z=g[$],H=z.instance,ue=z.currentTarget;if(z=z.listener,H!==T&&S.isPropagationStopped())break e;T=z,S.currentTarget=ue;try{T(S)}catch(ge){Cg(ge)}S.currentTarget=null,T=H}else for($=0;$<g.length;$++){if(z=g[$],H=z.instance,ue=z.currentTarget,z=z.listener,H!==T&&S.isPropagationStopped())break e;T=z,S.currentTarget=ue;try{T(S)}catch(ge){Cg(ge)}S.currentTarget=null,T=H}}}}function ct(u,c){var f=c[jw];f===void 0&&(f=c[jw]=new Set);var g=u+"__bubble";f.has(g)||(RA(c,u,2,!1),f.add(g))}function A1(u,c,f){var g=0;c&&(g|=4),RA(f,u,g,c)}var cy="_reactListening"+Math.random().toString(36).slice(2);function R1(u){if(!u[cy]){u[cy]=!0,NI.forEach(function(f){f!=="selectionchange"&&(XW.has(f)||A1(f,!1,u),A1(f,!0,u))});var c=u.nodeType===9?u:u.ownerDocument;c===null||c[cy]||(c[cy]=!0,A1("selectionchange",!1,c))}}function RA(u,c,f,g){switch(oR(c)){case 2:var S=TG;break;case 8:S=CG;break;default:S=q1}f=S.bind(null,c,f,u),S=void 0,!Zw||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||(S=!0),g?S!==void 0?u.addEventListener(c,f,{capture:!0,passive:S}):u.addEventListener(c,f,!0):S!==void 0?u.addEventListener(c,f,{passive:S}):u.addEventListener(c,f,!1)}function D1(u,c,f,g,S){var T=g;if((c&1)===0&&(c&2)===0&&g!==null)e:for(;;){if(g===null)return;var $=g.tag;if($===3||$===4){var z=g.stateNode.containerInfo;if(z===S)break;if($===4)for($=g.return;$!==null;){var H=$.tag;if((H===3||H===4)&&$.stateNode.containerInfo===S)return;$=$.return}for(;z!==null;){if($=ku(z),$===null)return;if(H=$.tag,H===5||H===6||H===26||H===27){g=T=$;continue e}z=z.parentNode}}g=g.return}MI(function(){var ue=T,ge=Yw(f),xe=[];e:{var ce=h$.get(u);if(ce!==void 0){var de=vg,De=u;switch(u){case"keypress":if(xg(f)===0)break e;case"keydown":case"keyup":de=Uj;break;case"focusin":De="focus",de=nv;break;case"focusout":De="blur",de=nv;break;case"beforeblur":case"afterblur":de=nv;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":de=BI;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":de=_j;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":de=Gj;break;case o$:case l$:case u$:de=Dj;break;case c$:de=qj;break;case"scroll":case"scrollend":de=Ij;break;case"wheel":de=Xj;break;case"copy":case"cut":case"paste":de=Lj;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":de=UI;break;case"toggle":case"beforetoggle":de=Jj}var je=(c&4)!==0,Dt=!je&&(u==="scroll"||u==="scrollend"),ie=je?ce!==null?ce+"Capture":null:ce;je=[];for(var ee=ue,oe;ee!==null;){var ye=ee;if(oe=ye.stateNode,ye=ye.tag,ye!==5&&ye!==26&&ye!==27||oe===null||ie===null||(ye=Td(ee,ie),ye!=null&&je.push(nf(ee,ye,oe))),Dt)break;ee=ee.return}0<je.length&&(ce=new de(ce,De,null,f,ge),xe.push({event:ce,listeners:je}))}}if((c&7)===0){e:{if(ce=u==="mouseover"||u==="pointerover",de=u==="mouseout"||u==="pointerout",ce&&f!==Xw&&(De=f.relatedTarget||f.fromElement)&&(ku(De)||De[Nu]))break e;if((de||ce)&&(ce=ge.window===ge?ge:(ce=ge.ownerDocument)?ce.defaultView||ce.parentWindow:window,de?(De=f.relatedTarget||f.toElement,de=ue,De=De?ku(De):null,De!==null&&(Dt=i(De),je=De.tag,De!==Dt||je!==5&&je!==27&&je!==6)&&(De=null)):(de=null,De=ue),de!==De)){if(je=BI,ye="onMouseLeave",ie="onMouseEnter",ee="mouse",(u==="pointerout"||u==="pointerover")&&(je=UI,ye="onPointerLeave",ie="onPointerEnter",ee="pointer"),Dt=de==null?ce:Sd(de),oe=De==null?ce:Sd(De),ce=new je(ye,ee+"leave",de,f,ge),ce.target=Dt,ce.relatedTarget=oe,ye=null,ku(ge)===ue&&(je=new je(ie,ee+"enter",De,f,ge),je.target=oe,je.relatedTarget=Dt,ye=je),Dt=ye,de&&De)t:{for(je=YW,ie=de,ee=De,oe=0,ye=ie;ye;ye=je(ye))oe++;ye=0;for(var Ue=ee;Ue;Ue=je(Ue))ye++;for(;0<oe-ye;)ie=je(ie),oe--;for(;0<ye-oe;)ee=je(ee),ye--;for(;oe--;){if(ie===ee||ee!==null&&ie===ee.alternate){je=ie;break t}ie=je(ie),ee=je(ee)}je=null}else je=null;de!==null&&DA(xe,ce,de,je,!1),De!==null&&Dt!==null&&DA(xe,Dt,De,je,!0)}}e:{if(ce=ue?Sd(ue):window,de=ce.nodeName&&ce.nodeName.toLowerCase(),de==="select"||de==="input"&&ce.type==="file")var vt=YI;else if(KI(ce))if(JI)vt=oW;else{vt=iW;var Me=rW}else de=ce.nodeName,!de||de.toLowerCase()!=="input"||ce.type!=="checkbox"&&ce.type!=="radio"?ue&&Kw(ue.elementType)&&(vt=YI):vt=aW;if(vt&&(vt=vt(u,ue))){XI(xe,vt,f,ge);break e}Me&&Me(u,ce,ue),u==="focusout"&&ue&&ce.type==="number"&&ue.memoizedProps.value!=null&&qw(ce,"number",ce.value)}switch(Me=ue?Sd(ue):window,u){case"focusin":(KI(Me)||Me.contentEditable==="true")&&(Lu=Me,lv=ue,Ad=null);break;case"focusout":Ad=lv=Lu=null;break;case"mousedown":uv=!0;break;case"contextmenu":case"mouseup":case"dragend":uv=!1,i$(xe,f,ge);break;case"selectionchange":if(uW)break;case"keydown":case"keyup":i$(xe,f,ge)}var tt;if(rv)e:{switch(u){case"compositionstart":var pt="onCompositionStart";break e;case"compositionend":pt="onCompositionEnd";break e;case"compositionupdate":pt="onCompositionUpdate";break e}pt=void 0}else Ou?HI(u,f)&&(pt="onCompositionEnd"):u==="keydown"&&f.keyCode===229&&(pt="onCompositionStart");pt&&(jI&&f.locale!=="ko"&&(Ou||pt!=="onCompositionStart"?pt==="onCompositionEnd"&&Ou&&(tt=zI()):(ja=ge,Qw="value"in ja?ja.value:ja.textContent,Ou=!0)),Me=hy(ue,pt),0<Me.length&&(pt=new VI(pt,u,null,f,ge),xe.push({event:pt,listeners:Me}),tt?pt.data=tt:(tt=qI(f),tt!==null&&(pt.data=tt)))),(tt=Qj?eW(u,f):tW(u,f))&&(pt=hy(ue,"onBeforeInput"),0<pt.length&&(Me=new VI("onBeforeInput","beforeinput",null,f,ge),xe.push({event:Me,listeners:pt}),Me.data=tt)),HW(xe,u,ue,f,ge)}AA(xe,c)})}function nf(u,c,f){return{instance:u,listener:c,currentTarget:f}}function hy(u,c){for(var f=c+"Capture",g=[];u!==null;){var S=u,T=S.stateNode;if(S=S.tag,S!==5&&S!==26&&S!==27||T===null||(S=Td(u,f),S!=null&&g.unshift(nf(u,S,T)),S=Td(u,c),S!=null&&g.push(nf(u,S,T))),u.tag===3)return g;u=u.return}return[]}function YW(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function DA(u,c,f,g,S){for(var T=c._reactName,$=[];f!==null&&f!==g;){var z=f,H=z.alternate,ue=z.stateNode;if(z=z.tag,H!==null&&H===g)break;z!==5&&z!==26&&z!==27||ue===null||(H=ue,S?(ue=Td(f,T),ue!=null&&$.unshift(nf(f,ue,H))):S||(ue=Td(f,T),ue!=null&&$.push(nf(f,ue,H)))),f=f.return}$.length!==0&&u.push({event:c,listeners:$})}var JW=/\r\n?/g,ZW=/\u0000|\uFFFD/g;function OA(u){return(typeof u=="string"?u:""+u).replace(JW,`
`).replace(ZW,"")}function LA(u,c){return c=OA(c),OA(u)===c}function Rt(u,c,f,g,S,T){switch(f){case"children":typeof g=="string"?c==="body"||c==="textarea"&&g===""||Au(u,g):(typeof g=="number"||typeof g=="bigint")&&c!=="body"&&Au(u,""+g);break;case"className":mg(u,"class",g);break;case"tabIndex":mg(u,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":mg(u,f,g);break;case"style":LI(u,g,T);break;case"data":if(c!=="object"){mg(u,"data",g);break}case"src":case"href":if(g===""&&(c!=="a"||f!=="href")){u.removeAttribute(f);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){u.removeAttribute(f);break}g=yg(""+g),u.setAttribute(f,g);break;case"action":case"formAction":if(typeof g=="function"){u.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof T=="function"&&(f==="formAction"?(c!=="input"&&Rt(u,c,"name",S.name,S,null),Rt(u,c,"formEncType",S.formEncType,S,null),Rt(u,c,"formMethod",S.formMethod,S,null),Rt(u,c,"formTarget",S.formTarget,S,null)):(Rt(u,c,"encType",S.encType,S,null),Rt(u,c,"method",S.method,S,null),Rt(u,c,"target",S.target,S,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){u.removeAttribute(f);break}g=yg(""+g),u.setAttribute(f,g);break;case"onClick":g!=null&&(u.onclick=Ji);break;case"onScroll":g!=null&&ct("scroll",u);break;case"onScrollEnd":g!=null&&ct("scrollend",u);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(S.children!=null)throw Error(s(60));u.innerHTML=f}}break;case"multiple":u.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":u.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){u.removeAttribute("xlink:href");break}f=yg(""+g),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(f,""+g):u.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(f,""):u.removeAttribute(f);break;case"capture":case"download":g===!0?u.setAttribute(f,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(f,g):u.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?u.setAttribute(f,g):u.removeAttribute(f);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?u.removeAttribute(f):u.setAttribute(f,g);break;case"popover":ct("beforetoggle",u),ct("toggle",u),pg(u,"popover",g);break;case"xlinkActuate":Yi(u,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":Yi(u,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":Yi(u,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":Yi(u,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":Yi(u,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":Yi(u,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":Yi(u,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":Yi(u,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":Yi(u,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":pg(u,"is",g);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=kj.get(f)||f,pg(u,f,g))}}function O1(u,c,f,g,S,T){switch(f){case"style":LI(u,g,T);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(S.children!=null)throw Error(s(60));u.innerHTML=f}}break;case"children":typeof g=="string"?Au(u,g):(typeof g=="number"||typeof g=="bigint")&&Au(u,""+g);break;case"onScroll":g!=null&&ct("scroll",u);break;case"onScrollEnd":g!=null&&ct("scrollend",u);break;case"onClick":g!=null&&(u.onclick=Ji);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!kI.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(S=f.endsWith("Capture"),c=f.slice(2,S?f.length-7:void 0),T=u[Fs]||null,T=T!=null?T[f]:null,typeof T=="function"&&u.removeEventListener(c,T,S),typeof g=="function")){typeof T!="function"&&T!==null&&(f in u?u[f]=null:u.hasAttribute(f)&&u.removeAttribute(f)),u.addEventListener(c,g,S);break e}f in u?u[f]=g:g===!0?u.setAttribute(f,""):pg(u,f,g)}}}function as(u,c,f){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":ct("error",u),ct("load",u);var g=!1,S=!1,T;for(T in f)if(f.hasOwnProperty(T)){var $=f[T];if($!=null)switch(T){case"src":g=!0;break;case"srcSet":S=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:Rt(u,c,T,$,f,null)}}S&&Rt(u,c,"srcSet",f.srcSet,f,null),g&&Rt(u,c,"src",f.src,f,null);return;case"input":ct("invalid",u);var z=T=$=S=null,H=null,ue=null;for(g in f)if(f.hasOwnProperty(g)){var ge=f[g];if(ge!=null)switch(g){case"name":S=ge;break;case"type":$=ge;break;case"checked":H=ge;break;case"defaultChecked":ue=ge;break;case"value":T=ge;break;case"defaultValue":z=ge;break;case"children":case"dangerouslySetInnerHTML":if(ge!=null)throw Error(s(137,c));break;default:Rt(u,c,g,ge,f,null)}}AI(u,T,z,H,ue,$,S,!1);return;case"select":ct("invalid",u),g=$=T=null;for(S in f)if(f.hasOwnProperty(S)&&(z=f[S],z!=null))switch(S){case"value":T=z;break;case"defaultValue":$=z;break;case"multiple":g=z;default:Rt(u,c,S,z,f,null)}c=T,f=$,u.multiple=!!g,c!=null?_u(u,!!g,c,!1):f!=null&&_u(u,!!g,f,!0);return;case"textarea":ct("invalid",u),T=S=g=null;for($ in f)if(f.hasOwnProperty($)&&(z=f[$],z!=null))switch($){case"value":g=z;break;case"defaultValue":S=z;break;case"children":T=z;break;case"dangerouslySetInnerHTML":if(z!=null)throw Error(s(91));break;default:Rt(u,c,$,z,f,null)}DI(u,g,S,T);return;case"option":for(H in f)f.hasOwnProperty(H)&&(g=f[H],g!=null)&&(H==="selected"?u.selected=g&&typeof g!="function"&&typeof g!="symbol":Rt(u,c,H,g,f,null));return;case"dialog":ct("beforetoggle",u),ct("toggle",u),ct("cancel",u),ct("close",u);break;case"iframe":case"object":ct("load",u);break;case"video":case"audio":for(g=0;g<tf.length;g++)ct(tf[g],u);break;case"image":ct("error",u),ct("load",u);break;case"details":ct("toggle",u);break;case"embed":case"source":case"link":ct("error",u),ct("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(ue in f)if(f.hasOwnProperty(ue)&&(g=f[ue],g!=null))switch(ue){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:Rt(u,c,ue,g,f,null)}return;default:if(Kw(c)){for(ge in f)f.hasOwnProperty(ge)&&(g=f[ge],g!==void 0&&O1(u,c,ge,g,f,void 0));return}}for(z in f)f.hasOwnProperty(z)&&(g=f[z],g!=null&&Rt(u,c,z,g,f,null))}function QW(u,c,f,g){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var S=null,T=null,$=null,z=null,H=null,ue=null,ge=null;for(de in f){var xe=f[de];if(f.hasOwnProperty(de)&&xe!=null)switch(de){case"checked":break;case"value":break;case"defaultValue":H=xe;default:g.hasOwnProperty(de)||Rt(u,c,de,null,g,xe)}}for(var ce in g){var de=g[ce];if(xe=f[ce],g.hasOwnProperty(ce)&&(de!=null||xe!=null))switch(ce){case"type":T=de;break;case"name":S=de;break;case"checked":ue=de;break;case"defaultChecked":ge=de;break;case"value":$=de;break;case"defaultValue":z=de;break;case"children":case"dangerouslySetInnerHTML":if(de!=null)throw Error(s(137,c));break;default:de!==xe&&Rt(u,c,ce,de,g,xe)}}Hw(u,$,z,H,ue,ge,T,S);return;case"select":de=$=z=ce=null;for(T in f)if(H=f[T],f.hasOwnProperty(T)&&H!=null)switch(T){case"value":break;case"multiple":de=H;default:g.hasOwnProperty(T)||Rt(u,c,T,null,g,H)}for(S in g)if(T=g[S],H=f[S],g.hasOwnProperty(S)&&(T!=null||H!=null))switch(S){case"value":ce=T;break;case"defaultValue":z=T;break;case"multiple":$=T;default:T!==H&&Rt(u,c,S,T,g,H)}c=z,f=$,g=de,ce!=null?_u(u,!!f,ce,!1):!!g!=!!f&&(c!=null?_u(u,!!f,c,!0):_u(u,!!f,f?[]:"",!1));return;case"textarea":de=ce=null;for(z in f)if(S=f[z],f.hasOwnProperty(z)&&S!=null&&!g.hasOwnProperty(z))switch(z){case"value":break;case"children":break;default:Rt(u,c,z,null,g,S)}for($ in g)if(S=g[$],T=f[$],g.hasOwnProperty($)&&(S!=null||T!=null))switch($){case"value":ce=S;break;case"defaultValue":de=S;break;case"children":break;case"dangerouslySetInnerHTML":if(S!=null)throw Error(s(91));break;default:S!==T&&Rt(u,c,$,S,g,T)}RI(u,ce,de);return;case"option":for(var De in f)ce=f[De],f.hasOwnProperty(De)&&ce!=null&&!g.hasOwnProperty(De)&&(De==="selected"?u.selected=!1:Rt(u,c,De,null,g,ce));for(H in g)ce=g[H],de=f[H],g.hasOwnProperty(H)&&ce!==de&&(ce!=null||de!=null)&&(H==="selected"?u.selected=ce&&typeof ce!="function"&&typeof ce!="symbol":Rt(u,c,H,ce,g,de));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var je in f)ce=f[je],f.hasOwnProperty(je)&&ce!=null&&!g.hasOwnProperty(je)&&Rt(u,c,je,null,g,ce);for(ue in g)if(ce=g[ue],de=f[ue],g.hasOwnProperty(ue)&&ce!==de&&(ce!=null||de!=null))switch(ue){case"children":case"dangerouslySetInnerHTML":if(ce!=null)throw Error(s(137,c));break;default:Rt(u,c,ue,ce,g,de)}return;default:if(Kw(c)){for(var Dt in f)ce=f[Dt],f.hasOwnProperty(Dt)&&ce!==void 0&&!g.hasOwnProperty(Dt)&&O1(u,c,Dt,void 0,g,ce);for(ge in g)ce=g[ge],de=f[ge],!g.hasOwnProperty(ge)||ce===de||ce===void 0&&de===void 0||O1(u,c,ge,ce,g,de);return}}for(var ie in f)ce=f[ie],f.hasOwnProperty(ie)&&ce!=null&&!g.hasOwnProperty(ie)&&Rt(u,c,ie,null,g,ce);for(xe in g)ce=g[xe],de=f[xe],!g.hasOwnProperty(xe)||ce===de||ce==null&&de==null||Rt(u,c,xe,ce,g,de)}function FA(u){switch(u){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function eG(){if(typeof performance.getEntriesByType=="function"){for(var u=0,c=0,f=performance.getEntriesByType("resource"),g=0;g<f.length;g++){var S=f[g],T=S.transferSize,$=S.initiatorType,z=S.duration;if(T&&z&&FA($)){for($=0,z=S.responseEnd,g+=1;g<f.length;g++){var H=f[g],ue=H.startTime;if(ue>z)break;var ge=H.transferSize,xe=H.initiatorType;ge&&FA(xe)&&(H=H.responseEnd,$+=ge*(H<z?1:(z-ue)/(H-ue)))}if(--g,c+=8*(T+$)/(S.duration/1e3),u++,10<u)break}}if(0<u)return c/u/1e6}return navigator.connection&&(u=navigator.connection.downlink,typeof u=="number")?u:5}var L1=null,F1=null;function dy(u){return u.nodeType===9?u:u.ownerDocument}function MA(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function zA(u,c){if(u===0)switch(c){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&c==="foreignObject"?0:u}function M1(u,c){return u==="textarea"||u==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.children=="bigint"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var z1=null;function tG(){var u=window.event;return u&&u.type==="popstate"?u===z1?!1:(z1=u,!0):(z1=null,!1)}var PA=typeof setTimeout=="function"?setTimeout:void 0,nG=typeof clearTimeout=="function"?clearTimeout:void 0,BA=typeof Promise=="function"?Promise:void 0,sG=typeof queueMicrotask=="function"?queueMicrotask:typeof BA<"u"?function(u){return BA.resolve(null).then(u).catch(rG)}:PA;function rG(u){setTimeout(function(){throw u})}function ao(u){return u==="head"}function VA(u,c){var f=c,g=0;do{var S=f.nextSibling;if(u.removeChild(f),S&&S.nodeType===8)if(f=S.data,f==="/$"||f==="/&"){if(g===0){u.removeChild(S),lc(c);return}g--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")g++;else if(f==="html")sf(u.ownerDocument.documentElement);else if(f==="head"){f=u.ownerDocument.head,sf(f);for(var T=f.firstChild;T;){var $=T.nextSibling,z=T.nodeName;T[vd]||z==="SCRIPT"||z==="STYLE"||z==="LINK"&&T.rel.toLowerCase()==="stylesheet"||f.removeChild(T),T=$}}else f==="body"&&sf(u.ownerDocument.body);f=S}while(f);lc(c)}function UA(u,c){var f=u;u=0;do{var g=f.nextSibling;if(f.nodeType===1?c?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(c?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),g&&g.nodeType===8)if(f=g.data,f==="/$"){if(u===0)break;u--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||u++;f=g}while(f)}function P1(u){var c=u.firstChild;for(c&&c.nodeType===10&&(c=c.nextSibling);c;){var f=c;switch(c=c.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":P1(f),Ww(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}u.removeChild(f)}}function iG(u,c,f,g){for(;u.nodeType===1;){var S=f;if(u.nodeName.toLowerCase()!==c.toLowerCase()){if(!g&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(g){if(!u[vd])switch(c){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(T=u.getAttribute("rel"),T==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(T!==S.rel||u.getAttribute("href")!==(S.href==null||S.href===""?null:S.href)||u.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin)||u.getAttribute("title")!==(S.title==null?null:S.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(T=u.getAttribute("src"),(T!==(S.src==null?null:S.src)||u.getAttribute("type")!==(S.type==null?null:S.type)||u.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin))&&T&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(c==="input"&&u.type==="hidden"){var T=S.name==null?null:""+S.name;if(S.type==="hidden"&&u.getAttribute("name")===T)return u}else return u;if(u=Lr(u.nextSibling),u===null)break}return null}function aG(u,c,f){if(c==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!f||(u=Lr(u.nextSibling),u===null))return null;return u}function jA(u,c){for(;u.nodeType!==8;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!c||(u=Lr(u.nextSibling),u===null))return null;return u}function B1(u){return u.data==="$?"||u.data==="$~"}function V1(u){return u.data==="$!"||u.data==="$?"&&u.ownerDocument.readyState!=="loading"}function oG(u,c){var f=u.ownerDocument;if(u.data==="$~")u._reactRetry=c;else if(u.data!=="$?"||f.readyState!=="loading")c();else{var g=function(){c(),f.removeEventListener("DOMContentLoaded",g)};f.addEventListener("DOMContentLoaded",g),u._reactRetry=g}}function Lr(u){for(;u!=null;u=u.nextSibling){var c=u.nodeType;if(c===1||c===3)break;if(c===8){if(c=u.data,c==="$"||c==="$!"||c==="$?"||c==="$~"||c==="&"||c==="F!"||c==="F")break;if(c==="/$"||c==="/&")return null}}return u}var U1=null;function WA(u){u=u.nextSibling;for(var c=0;u;){if(u.nodeType===8){var f=u.data;if(f==="/$"||f==="/&"){if(c===0)return Lr(u.nextSibling);c--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||c++}u=u.nextSibling}return null}function GA(u){u=u.previousSibling;for(var c=0;u;){if(u.nodeType===8){var f=u.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(c===0)return u;c--}else f!=="/$"&&f!=="/&"||c++}u=u.previousSibling}return null}function HA(u,c,f){switch(c=dy(f),u){case"html":if(u=c.documentElement,!u)throw Error(s(452));return u;case"head":if(u=c.head,!u)throw Error(s(453));return u;case"body":if(u=c.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}function sf(u){for(var c=u.attributes;c.length;)u.removeAttributeNode(c[0]);Ww(u)}var Fr=new Map,qA=new Set;function fy(u){return typeof u.getRootNode=="function"?u.getRootNode():u.nodeType===9?u:u.ownerDocument}var fa=U.d;U.d={f:lG,r:uG,D:cG,C:hG,L:dG,m:fG,X:mG,S:pG,M:gG};function lG(){var u=fa.f(),c=ry();return u||c}function uG(u){var c=Eu(u);c!==null&&c.tag===5&&c.type==="form"?c_(c):fa.r(u)}var ic=typeof document>"u"?null:document;function KA(u,c,f){var g=ic;if(g&&typeof c=="string"&&c){var S=Ir(c);S='link[rel="'+u+'"][href="'+S+'"]',typeof f=="string"&&(S+='[crossorigin="'+f+'"]'),qA.has(S)||(qA.add(S),u={rel:u,crossOrigin:f,href:c},g.querySelector(S)===null&&(c=g.createElement("link"),as(c,"link",u),jn(c),g.head.appendChild(c)))}}function cG(u){fa.D(u),KA("dns-prefetch",u,null)}function hG(u,c){fa.C(u,c),KA("preconnect",u,c)}function dG(u,c,f){fa.L(u,c,f);var g=ic;if(g&&u&&c){var S='link[rel="preload"][as="'+Ir(c)+'"]';c==="image"&&f&&f.imageSrcSet?(S+='[imagesrcset="'+Ir(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(S+='[imagesizes="'+Ir(f.imageSizes)+'"]')):S+='[href="'+Ir(u)+'"]';var T=S;switch(c){case"style":T=ac(u);break;case"script":T=oc(u)}Fr.has(T)||(u=p({rel:"preload",href:c==="image"&&f&&f.imageSrcSet?void 0:u,as:c},f),Fr.set(T,u),g.querySelector(S)!==null||c==="style"&&g.querySelector(rf(T))||c==="script"&&g.querySelector(af(T))||(c=g.createElement("link"),as(c,"link",u),jn(c),g.head.appendChild(c)))}}function fG(u,c){fa.m(u,c);var f=ic;if(f&&u){var g=c&&typeof c.as=="string"?c.as:"script",S='link[rel="modulepreload"][as="'+Ir(g)+'"][href="'+Ir(u)+'"]',T=S;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":T=oc(u)}if(!Fr.has(T)&&(u=p({rel:"modulepreload",href:u},c),Fr.set(T,u),f.querySelector(S)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(af(T)))return}g=f.createElement("link"),as(g,"link",u),jn(g),f.head.appendChild(g)}}}function pG(u,c,f){fa.S(u,c,f);var g=ic;if(g&&u){var S=Iu(g).hoistableStyles,T=ac(u);c=c||"default";var $=S.get(T);if(!$){var z={loading:0,preload:null};if($=g.querySelector(rf(T)))z.loading=5;else{u=p({rel:"stylesheet",href:u,"data-precedence":c},f),(f=Fr.get(T))&&j1(u,f);var H=$=g.createElement("link");jn(H),as(H,"link",u),H._p=new Promise(function(ue,ge){H.onload=ue,H.onerror=ge}),H.addEventListener("load",function(){z.loading|=1}),H.addEventListener("error",function(){z.loading|=2}),z.loading|=4,py($,c,g)}$={type:"stylesheet",instance:$,count:1,state:z},S.set(T,$)}}}function mG(u,c){fa.X(u,c);var f=ic;if(f&&u){var g=Iu(f).hoistableScripts,S=oc(u),T=g.get(S);T||(T=f.querySelector(af(S)),T||(u=p({src:u,async:!0},c),(c=Fr.get(S))&&W1(u,c),T=f.createElement("script"),jn(T),as(T,"link",u),f.head.appendChild(T)),T={type:"script",instance:T,count:1,state:null},g.set(S,T))}}function gG(u,c){fa.M(u,c);var f=ic;if(f&&u){var g=Iu(f).hoistableScripts,S=oc(u),T=g.get(S);T||(T=f.querySelector(af(S)),T||(u=p({src:u,async:!0,type:"module"},c),(c=Fr.get(S))&&W1(u,c),T=f.createElement("script"),jn(T),as(T,"link",u),f.head.appendChild(T)),T={type:"script",instance:T,count:1,state:null},g.set(S,T))}}function XA(u,c,f,g){var S=(S=we.current)?fy(S):null;if(!S)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(c=ac(f.href),f=Iu(S).hoistableStyles,g=f.get(c),g||(g={type:"style",instance:null,count:0,state:null},f.set(c,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){u=ac(f.href);var T=Iu(S).hoistableStyles,$=T.get(u);if($||(S=S.ownerDocument||S,$={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},T.set(u,$),(T=S.querySelector(rf(u)))&&!T._p&&($.instance=T,$.state.loading=5),Fr.has(u)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},Fr.set(u,f),T||yG(S,u,f,$.state))),c&&g===null)throw Error(s(528,""));return $}if(c&&g!==null)throw Error(s(529,""));return null;case"script":return c=f.async,f=f.src,typeof f=="string"&&c&&typeof c!="function"&&typeof c!="symbol"?(c=oc(f),f=Iu(S).hoistableScripts,g=f.get(c),g||(g={type:"script",instance:null,count:0,state:null},f.set(c,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function ac(u){return'href="'+Ir(u)+'"'}function rf(u){return'link[rel="stylesheet"]['+u+"]"}function YA(u){return p({},u,{"data-precedence":u.precedence,precedence:null})}function yG(u,c,f,g){u.querySelector('link[rel="preload"][as="style"]['+c+"]")?g.loading=1:(c=u.createElement("link"),g.preload=c,c.addEventListener("load",function(){return g.loading|=1}),c.addEventListener("error",function(){return g.loading|=2}),as(c,"link",f),jn(c),u.head.appendChild(c))}function oc(u){return'[src="'+Ir(u)+'"]'}function af(u){return"script[async]"+u}function JA(u,c,f){if(c.count++,c.instance===null)switch(c.type){case"style":var g=u.querySelector('style[data-href~="'+Ir(f.href)+'"]');if(g)return c.instance=g,jn(g),g;var S=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return g=(u.ownerDocument||u).createElement("style"),jn(g),as(g,"style",S),py(g,f.precedence,u),c.instance=g;case"stylesheet":S=ac(f.href);var T=u.querySelector(rf(S));if(T)return c.state.loading|=4,c.instance=T,jn(T),T;g=YA(f),(S=Fr.get(S))&&j1(g,S),T=(u.ownerDocument||u).createElement("link"),jn(T);var $=T;return $._p=new Promise(function(z,H){$.onload=z,$.onerror=H}),as(T,"link",g),c.state.loading|=4,py(T,f.precedence,u),c.instance=T;case"script":return T=oc(f.src),(S=u.querySelector(af(T)))?(c.instance=S,jn(S),S):(g=f,(S=Fr.get(T))&&(g=p({},f),W1(g,S)),u=u.ownerDocument||u,S=u.createElement("script"),jn(S),as(S,"link",g),u.head.appendChild(S),c.instance=S);case"void":return null;default:throw Error(s(443,c.type))}else c.type==="stylesheet"&&(c.state.loading&4)===0&&(g=c.instance,c.state.loading|=4,py(g,f.precedence,u));return c.instance}function py(u,c,f){for(var g=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),S=g.length?g[g.length-1]:null,T=S,$=0;$<g.length;$++){var z=g[$];if(z.dataset.precedence===c)T=z;else if(T!==S)break}T?T.parentNode.insertBefore(u,T.nextSibling):(c=f.nodeType===9?f.head:f,c.insertBefore(u,c.firstChild))}function j1(u,c){u.crossOrigin==null&&(u.crossOrigin=c.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=c.referrerPolicy),u.title==null&&(u.title=c.title)}function W1(u,c){u.crossOrigin==null&&(u.crossOrigin=c.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=c.referrerPolicy),u.integrity==null&&(u.integrity=c.integrity)}var my=null;function ZA(u,c,f){if(my===null){var g=new Map,S=my=new Map;S.set(f,g)}else S=my,g=S.get(f),g||(g=new Map,S.set(f,g));if(g.has(u))return g;for(g.set(u,null),f=f.getElementsByTagName(u),S=0;S<f.length;S++){var T=f[S];if(!(T[vd]||T[ns]||u==="link"&&T.getAttribute("rel")==="stylesheet")&&T.namespaceURI!=="http://www.w3.org/2000/svg"){var $=T.getAttribute(c)||"";$=u+$;var z=g.get($);z?z.push(T):g.set($,[T])}}return g}function QA(u,c,f){u=u.ownerDocument||u,u.head.insertBefore(f,c==="title"?u.querySelector("head > title"):null)}function bG(u,c,f){if(f===1||c.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof c.precedence!="string"||typeof c.href!="string"||c.href==="")break;return!0;case"link":if(typeof c.rel!="string"||typeof c.href!="string"||c.href===""||c.onLoad||c.onError)break;return c.rel==="stylesheet"?(u=c.disabled,typeof c.precedence=="string"&&u==null):!0;case"script":if(c.async&&typeof c.async!="function"&&typeof c.async!="symbol"&&!c.onLoad&&!c.onError&&c.src&&typeof c.src=="string")return!0}return!1}function eR(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}function xG(u,c,f,g){if(f.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var S=ac(g.href),T=c.querySelector(rf(S));if(T){c=T._p,c!==null&&typeof c=="object"&&typeof c.then=="function"&&(u.count++,u=gy.bind(u),c.then(u,u)),f.state.loading|=4,f.instance=T,jn(T);return}T=c.ownerDocument||c,g=YA(g),(S=Fr.get(S))&&j1(g,S),T=T.createElement("link"),jn(T);var $=T;$._p=new Promise(function(z,H){$.onload=z,$.onerror=H}),as(T,"link",g),f.instance=T}u.stylesheets===null&&(u.stylesheets=new Map),u.stylesheets.set(f,c),(c=f.state.preload)&&(f.state.loading&3)===0&&(u.count++,f=gy.bind(u),c.addEventListener("load",f),c.addEventListener("error",f))}}var G1=0;function wG(u,c){return u.stylesheets&&u.count===0&&by(u,u.stylesheets),0<u.count||0<u.imgCount?function(f){var g=setTimeout(function(){if(u.stylesheets&&by(u,u.stylesheets),u.unsuspend){var T=u.unsuspend;u.unsuspend=null,T()}},6e4+c);0<u.imgBytes&&G1===0&&(G1=62500*eG());var S=setTimeout(function(){if(u.waitingForImages=!1,u.count===0&&(u.stylesheets&&by(u,u.stylesheets),u.unsuspend)){var T=u.unsuspend;u.unsuspend=null,T()}},(u.imgBytes>G1?50:800)+c);return u.unsuspend=f,function(){u.unsuspend=null,clearTimeout(g),clearTimeout(S)}}:null}function gy(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)by(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var yy=null;function by(u,c){u.stylesheets=null,u.unsuspend!==null&&(u.count++,yy=new Map,c.forEach(vG,u),yy=null,gy.call(u))}function vG(u,c){if(!(c.state.loading&4)){var f=yy.get(u);if(f)var g=f.get(null);else{f=new Map,yy.set(u,f);for(var S=u.querySelectorAll("link[data-precedence],style[data-precedence]"),T=0;T<S.length;T++){var $=S[T];($.nodeName==="LINK"||$.getAttribute("media")!=="not all")&&(f.set($.dataset.precedence,$),g=$)}g&&f.set(null,g)}S=c.instance,$=S.getAttribute("data-precedence"),T=f.get($)||g,T===g&&f.set(null,S),f.set($,S),this.count++,g=gy.bind(this),S.addEventListener("load",g),S.addEventListener("error",g),T?T.parentNode.insertBefore(S,T.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(S,u.firstChild)),c.state.loading|=4}}var of={$$typeof:N,Provider:null,Consumer:null,_currentValue:K,_currentValue2:K,_threadCount:0};function SG(u,c,f,g,S,T,$,z,H){this.tag=1,this.containerInfo=u,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Bw(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Bw(0),this.hiddenUpdates=Bw(null),this.identifierPrefix=g,this.onUncaughtError=S,this.onCaughtError=T,this.onRecoverableError=$,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=H,this.incompleteTransitions=new Map}function tR(u,c,f,g,S,T,$,z,H,ue,ge,xe){return u=new SG(u,c,f,$,H,ue,ge,xe,z),c=1,T===!0&&(c|=24),T=ar(3,null,null,c),u.current=T,T.stateNode=u,c=Cv(),c.refCount++,u.pooledCache=c,c.refCount++,T.memoizedState={element:g,isDehydrated:f,cache:c},Iv(T),u}function nR(u){return u?(u=zu,u):zu}function sR(u,c,f,g,S,T){S=nR(S),g.context===null?g.context=S:g.pendingContext=S,g=Xa(c),g.payload={element:f},T=T===void 0?null:T,T!==null&&(g.callback=T),f=Ya(u,g,c),f!==null&&(Us(f,u,c),zd(f,u,c))}function rR(u,c){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var f=u.retryLane;u.retryLane=f!==0&&f<c?f:c}}function H1(u,c){rR(u,c),(u=u.alternate)&&rR(u,c)}function iR(u){if(u.tag===13||u.tag===31){var c=nl(u,67108864);c!==null&&Us(c,u,67108864),H1(u,67108864)}}function aR(u){if(u.tag===13||u.tag===31){var c=hr();c=Vw(c);var f=nl(u,c);f!==null&&Us(f,u,c),H1(u,c)}}var xy=!0;function TG(u,c,f,g){var S=B.T;B.T=null;var T=U.p;try{U.p=2,q1(u,c,f,g)}finally{U.p=T,B.T=S}}function CG(u,c,f,g){var S=B.T;B.T=null;var T=U.p;try{U.p=8,q1(u,c,f,g)}finally{U.p=T,B.T=S}}function q1(u,c,f,g){if(xy){var S=K1(g);if(S===null)D1(u,c,g,wy,f),lR(u,g);else if(kG(S,u,c,f,g))g.stopPropagation();else if(lR(u,g),c&4&&-1<NG.indexOf(u)){for(;S!==null;){var T=Eu(S);if(T!==null)switch(T.tag){case 3:if(T=T.stateNode,T.current.memoizedState.isDehydrated){var $=Jo(T.pendingLanes);if($!==0){var z=T;for(z.pendingLanes|=2,z.entangledLanes|=2;$;){var H=1<<31-rr($);z.entanglements[1]|=H,$&=~H}$i(T),(Tt&6)===0&&(ny=Vt()+500,ef(0))}}break;case 31:case 13:z=nl(T,2),z!==null&&Us(z,T,2),ry(),H1(T,2)}if(T=K1(g),T===null&&D1(u,c,g,wy,f),T===S)break;S=T}S!==null&&g.stopPropagation()}else D1(u,c,g,null,f)}}function K1(u){return u=Yw(u),X1(u)}var wy=null;function X1(u){if(wy=null,u=ku(u),u!==null){var c=i(u);if(c===null)u=null;else{var f=c.tag;if(f===13){if(u=a(c),u!==null)return u;u=null}else if(f===31){if(u=o(c),u!==null)return u;u=null}else if(f===3){if(c.stateNode.current.memoizedState.isDehydrated)return c.tag===3?c.stateNode.containerInfo:null;u=null}else c!==u&&(u=null)}}return wy=u,null}function oR(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Yr()){case Jr:return 2;case Zr:return 8;case sr:case Yo:return 32;case Cu:return 268435456;default:return 32}default:return 32}}var Y1=!1,oo=null,lo=null,uo=null,lf=new Map,uf=new Map,co=[],NG="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function lR(u,c){switch(u){case"focusin":case"focusout":oo=null;break;case"dragenter":case"dragleave":lo=null;break;case"mouseover":case"mouseout":uo=null;break;case"pointerover":case"pointerout":lf.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":uf.delete(c.pointerId)}}function cf(u,c,f,g,S,T){return u===null||u.nativeEvent!==T?(u={blockedOn:c,domEventName:f,eventSystemFlags:g,nativeEvent:T,targetContainers:[S]},c!==null&&(c=Eu(c),c!==null&&iR(c)),u):(u.eventSystemFlags|=g,c=u.targetContainers,S!==null&&c.indexOf(S)===-1&&c.push(S),u)}function kG(u,c,f,g,S){switch(c){case"focusin":return oo=cf(oo,u,c,f,g,S),!0;case"dragenter":return lo=cf(lo,u,c,f,g,S),!0;case"mouseover":return uo=cf(uo,u,c,f,g,S),!0;case"pointerover":var T=S.pointerId;return lf.set(T,cf(lf.get(T)||null,u,c,f,g,S)),!0;case"gotpointercapture":return T=S.pointerId,uf.set(T,cf(uf.get(T)||null,u,c,f,g,S)),!0}return!1}function uR(u){var c=ku(u.target);if(c!==null){var f=i(c);if(f!==null){if(c=f.tag,c===13){if(c=a(f),c!==null){u.blockedOn=c,TI(u.priority,function(){aR(f)});return}}else if(c===31){if(c=o(f),c!==null){u.blockedOn=c,TI(u.priority,function(){aR(f)});return}}else if(c===3&&f.stateNode.current.memoizedState.isDehydrated){u.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}u.blockedOn=null}function vy(u){if(u.blockedOn!==null)return!1;for(var c=u.targetContainers;0<c.length;){var f=K1(u.nativeEvent);if(f===null){f=u.nativeEvent;var g=new f.constructor(f.type,f);Xw=g,f.target.dispatchEvent(g),Xw=null}else return c=Eu(f),c!==null&&iR(c),u.blockedOn=f,!1;c.shift()}return!0}function cR(u,c,f){vy(u)&&f.delete(c)}function EG(){Y1=!1,oo!==null&&vy(oo)&&(oo=null),lo!==null&&vy(lo)&&(lo=null),uo!==null&&vy(uo)&&(uo=null),lf.forEach(cR),uf.forEach(cR)}function Sy(u,c){u.blockedOn===c&&(u.blockedOn=null,Y1||(Y1=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,EG)))}var Ty=null;function hR(u){Ty!==u&&(Ty=u,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Ty===u&&(Ty=null);for(var c=0;c<u.length;c+=3){var f=u[c],g=u[c+1],S=u[c+2];if(typeof g!="function"){if(X1(g||f)===null)continue;break}var T=Eu(f);T!==null&&(u.splice(c,3),c-=3,Kv(T,{pending:!0,data:S,method:f.method,action:g},g,S))}}))}function lc(u){function c(H){return Sy(H,u)}oo!==null&&Sy(oo,u),lo!==null&&Sy(lo,u),uo!==null&&Sy(uo,u),lf.forEach(c),uf.forEach(c);for(var f=0;f<co.length;f++){var g=co[f];g.blockedOn===u&&(g.blockedOn=null)}for(;0<co.length&&(f=co[0],f.blockedOn===null);)uR(f),f.blockedOn===null&&co.shift();if(f=(u.ownerDocument||u).$$reactFormReplay,f!=null)for(g=0;g<f.length;g+=3){var S=f[g],T=f[g+1],$=S[Fs]||null;if(typeof T=="function")$||hR(f);else if($){var z=null;if(T&&T.hasAttribute("formAction")){if(S=T,$=T[Fs]||null)z=$.formAction;else if(X1(S)!==null)continue}else z=$.action;typeof z=="function"?f[g+1]=z:(f.splice(g,3),g-=3),hR(f)}}}function dR(){function u(T){T.canIntercept&&T.info==="react-transition"&&T.intercept({handler:function(){return new Promise(function($){return S=$})},focusReset:"manual",scroll:"manual"})}function c(){S!==null&&(S(),S=null),g||setTimeout(f,20)}function f(){if(!g&&!navigation.transition){var T=navigation.currentEntry;T&&T.url!=null&&navigation.navigate(T.url,{state:T.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,S=null;return navigation.addEventListener("navigate",u),navigation.addEventListener("navigatesuccess",c),navigation.addEventListener("navigateerror",c),setTimeout(f,100),function(){g=!0,navigation.removeEventListener("navigate",u),navigation.removeEventListener("navigatesuccess",c),navigation.removeEventListener("navigateerror",c),S!==null&&(S(),S=null)}}}function J1(u){this._internalRoot=u}Cy.prototype.render=J1.prototype.render=function(u){var c=this._internalRoot;if(c===null)throw Error(s(409));var f=c.current,g=hr();sR(f,g,u,c,null,null)},Cy.prototype.unmount=J1.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var c=u.containerInfo;sR(u.current,2,null,u,null,null),ry(),c[Nu]=null}};function Cy(u){this._internalRoot=u}Cy.prototype.unstable_scheduleHydration=function(u){if(u){var c=SI();u={blockedOn:null,target:u,priority:c};for(var f=0;f<co.length&&c!==0&&c<co[f].priority;f++);co.splice(f,0,u),f===0&&uR(u)}};var fR=e.version;if(fR!=="19.2.3")throw Error(s(527,fR,"19.2.3"));U.findDOMNode=function(u){var c=u._reactInternals;if(c===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=h(c),u=u!==null?d(u):null,u=u===null?null:u.stateNode,u};var IG={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:B,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Ny=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Ny.isDisabled&&Ny.supportsFiber)try{Ci=Ny.inject(IG),Cs=Ny}catch{}}return df.createRoot=function(u,c){if(!r(u))throw Error(s(299));var f=!1,g="",S=w_,T=v_,$=S_;return c!=null&&(c.unstable_strictMode===!0&&(f=!0),c.identifierPrefix!==void 0&&(g=c.identifierPrefix),c.onUncaughtError!==void 0&&(S=c.onUncaughtError),c.onCaughtError!==void 0&&(T=c.onCaughtError),c.onRecoverableError!==void 0&&($=c.onRecoverableError)),c=tR(u,1,!1,null,null,f,g,null,S,T,$,dR),u[Nu]=c.current,R1(u),new J1(c)},df.hydrateRoot=function(u,c,f){if(!r(u))throw Error(s(299));var g=!1,S="",T=w_,$=v_,z=S_,H=null;return f!=null&&(f.unstable_strictMode===!0&&(g=!0),f.identifierPrefix!==void 0&&(S=f.identifierPrefix),f.onUncaughtError!==void 0&&(T=f.onUncaughtError),f.onCaughtError!==void 0&&($=f.onCaughtError),f.onRecoverableError!==void 0&&(z=f.onRecoverableError),f.formState!==void 0&&(H=f.formState)),c=tR(u,1,!0,c,f??null,g,S,H,T,$,z,dR),c.context=nR(null),f=c.current,g=hr(),g=Vw(g),S=Xa(g),S.callback=null,Ya(f,S,g),f=g,c.current.lanes=f,wd(c,f),$i(c),u[Nu]=c.current,R1(u),new Cy(c)},df.version="19.2.3",df}var TR;function VG(){if(TR)return eS.exports;TR=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),eS.exports=BG(),eS.exports}var UG=VG();const jG=NC(UG),EC=Ce.createContext({});function IC(n){const e=Ce.useRef(null);return e.current===null&&(e.current=n()),e.current}const $C=typeof window<"u",tL=$C?Ce.useLayoutEffect:Ce.useEffect,ob=Ce.createContext(null);function _C(n,e){n.indexOf(e)===-1&&n.push(e)}function AC(n,e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}const Sa=(n,e,t)=>t>e?e:t<n?n:t;let RC=()=>{};const Ta={},nL=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function sL(n){return typeof n=="object"&&n!==null}const rL=n=>/^0[^.\s]+$/u.test(n);function DC(n){let e;return()=>(e===void 0&&(e=n()),e)}const Gr=n=>n,WG=(n,e)=>t=>e(n(t)),yp=(...n)=>n.reduce(WG),Bf=(n,e,t)=>{const s=e-n;return s===0?1:(t-n)/s};class OC{constructor(){this.subscriptions=[]}add(e){return _C(this.subscriptions,e),()=>AC(this.subscriptions,e)}notify(e,t,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](e,t,s);else for(let i=0;i<r;i++){const a=this.subscriptions[i];a&&a(e,t,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const Li=n=>n*1e3,Ur=n=>n/1e3;function iL(n,e){return e?n*(1e3/e):0}const aL=(n,e,t)=>(((1-3*t+3*e)*n+(3*t-6*e))*n+3*e)*n,GG=1e-7,HG=12;function qG(n,e,t,s,r){let i,a,o=0;do a=e+(t-e)/2,i=aL(a,s,r)-n,i>0?t=a:e=a;while(Math.abs(i)>GG&&++o<HG);return a}function bp(n,e,t,s){if(n===e&&t===s)return Gr;const r=i=>qG(i,0,1,n,t);return i=>i===0||i===1?i:aL(r(i),e,s)}const oL=n=>e=>e<=.5?n(2*e)/2:(2-n(2*(1-e)))/2,lL=n=>e=>1-n(1-e),uL=bp(.33,1.53,.69,.99),LC=lL(uL),cL=oL(LC),hL=n=>(n*=2)<1?.5*LC(n):.5*(2-Math.pow(2,-10*(n-1))),FC=n=>1-Math.sin(Math.acos(n)),dL=lL(FC),fL=oL(FC),KG=bp(.42,0,1,1),XG=bp(0,0,.58,1),pL=bp(.42,0,.58,1),YG=n=>Array.isArray(n)&&typeof n[0]!="number",mL=n=>Array.isArray(n)&&typeof n[0]=="number",JG={linear:Gr,easeIn:KG,easeInOut:pL,easeOut:XG,circIn:FC,circInOut:fL,circOut:dL,backIn:LC,backInOut:cL,backOut:uL,anticipate:hL},ZG=n=>typeof n=="string",CR=n=>{if(mL(n)){RC(n.length===4);const[e,t,s,r]=n;return bp(e,t,s,r)}else if(ZG(n))return JG[n];return n},ky=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function QG(n,e){let t=new Set,s=new Set,r=!1,i=!1;const a=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1};function l(d){a.has(d)&&(h.schedule(d),n()),d(o)}const h={schedule:(d,p=!1,m=!1)=>{const b=m&&r?t:s;return p&&a.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),a.delete(d)},process:d=>{if(o=d,r){i=!0;return}r=!0,[t,s]=[s,t],t.forEach(l),t.clear(),r=!1,i&&(i=!1,h.process(d))}};return h}const e5=40;function gL(n,e){let t=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},i=()=>t=!0,a=ky.reduce((N,k)=>(N[k]=QG(i),N),{}),{setup:o,read:l,resolveKeyframes:h,preUpdate:d,update:p,preRender:m,render:y,postRender:b}=a,x=()=>{const N=Ta.useManualTiming?r.timestamp:performance.now();t=!1,Ta.useManualTiming||(r.delta=s?1e3/60:Math.max(Math.min(N-r.timestamp,e5),1)),r.timestamp=N,r.isProcessing=!0,o.process(r),l.process(r),h.process(r),d.process(r),p.process(r),m.process(r),y.process(r),b.process(r),r.isProcessing=!1,t&&e&&(s=!1,n(x))},w=()=>{t=!0,s=!0,r.isProcessing||n(x)};return{schedule:ky.reduce((N,k)=>{const E=a[k];return N[k]=(A,R=!1,D=!1)=>(t||w(),E.schedule(A,R,D)),N},{}),cancel:N=>{for(let k=0;k<ky.length;k++)a[ky[k]].cancel(N)},state:r,steps:a}}const{schedule:Xt,cancel:ko,state:us,steps:rS}=gL(typeof requestAnimationFrame<"u"?requestAnimationFrame:Gr,!0);let Xy;function t5(){Xy=void 0}const Ks={now:()=>(Xy===void 0&&Ks.set(us.isProcessing||Ta.useManualTiming?us.timestamp:performance.now()),Xy),set:n=>{Xy=n,queueMicrotask(t5)}},yL=n=>e=>typeof e=="string"&&e.startsWith(n),bL=yL("--"),n5=yL("var(--"),MC=n=>n5(n)?s5.test(n.split("/*")[0].trim()):!1,s5=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Jc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},Vf={...Jc,transform:n=>Sa(0,1,n)},Ey={...Jc,default:1},Af=n=>Math.round(n*1e5)/1e5,zC=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function r5(n){return n==null}const i5=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,PC=(n,e)=>t=>!!(typeof t=="string"&&i5.test(t)&&t.startsWith(n)||e&&!r5(t)&&Object.prototype.hasOwnProperty.call(t,e)),xL=(n,e,t)=>s=>{if(typeof s!="string")return s;const[r,i,a,o]=s.match(zC);return{[n]:parseFloat(r),[e]:parseFloat(i),[t]:parseFloat(a),alpha:o!==void 0?parseFloat(o):1}},a5=n=>Sa(0,255,n),iS={...Jc,transform:n=>Math.round(a5(n))},Rl={test:PC("rgb","red"),parse:xL("red","green","blue"),transform:({red:n,green:e,blue:t,alpha:s=1})=>"rgba("+iS.transform(n)+", "+iS.transform(e)+", "+iS.transform(t)+", "+Af(Vf.transform(s))+")"};function o5(n){let e="",t="",s="",r="";return n.length>5?(e=n.substring(1,3),t=n.substring(3,5),s=n.substring(5,7),r=n.substring(7,9)):(e=n.substring(1,2),t=n.substring(2,3),s=n.substring(3,4),r=n.substring(4,5),e+=e,t+=t,s+=s,r+=r),{red:parseInt(e,16),green:parseInt(t,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const qS={test:PC("#"),parse:o5,transform:Rl.transform},xp=n=>({test:e=>typeof e=="string"&&e.endsWith(n)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${n}`}),fo=xp("deg"),Fi=xp("%"),qe=xp("px"),l5=xp("vh"),u5=xp("vw"),NR={...Fi,parse:n=>Fi.parse(n)/100,transform:n=>Fi.transform(n*100)},Tc={test:PC("hsl","hue"),parse:xL("hue","saturation","lightness"),transform:({hue:n,saturation:e,lightness:t,alpha:s=1})=>"hsla("+Math.round(n)+", "+Fi.transform(Af(e))+", "+Fi.transform(Af(t))+", "+Af(Vf.transform(s))+")"},Nn={test:n=>Rl.test(n)||qS.test(n)||Tc.test(n),parse:n=>Rl.test(n)?Rl.parse(n):Tc.test(n)?Tc.parse(n):qS.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?Rl.transform(n):Tc.transform(n),getAnimatableNone:n=>{const e=Nn.parse(n);return e.alpha=0,Nn.transform(e)}},c5=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function h5(n){return isNaN(n)&&typeof n=="string"&&(n.match(zC)?.length||0)+(n.match(c5)?.length||0)>0}const wL="number",vL="color",d5="var",f5="var(",kR="${}",p5=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Uf(n){const e=n.toString(),t=[],s={color:[],number:[],var:[]},r=[];let i=0;const o=e.replace(p5,l=>(Nn.test(l)?(s.color.push(i),r.push(vL),t.push(Nn.parse(l))):l.startsWith(f5)?(s.var.push(i),r.push(d5),t.push(l)):(s.number.push(i),r.push(wL),t.push(parseFloat(l))),++i,kR)).split(kR);return{values:t,split:o,indexes:s,types:r}}function SL(n){return Uf(n).values}function TL(n){const{split:e,types:t}=Uf(n),s=e.length;return r=>{let i="";for(let a=0;a<s;a++)if(i+=e[a],r[a]!==void 0){const o=t[a];o===wL?i+=Af(r[a]):o===vL?i+=Nn.transform(r[a]):i+=r[a]}return i}}const m5=n=>typeof n=="number"?0:Nn.test(n)?Nn.getAnimatableNone(n):n;function g5(n){const e=SL(n);return TL(n)(e.map(m5))}const Eo={test:h5,parse:SL,createTransformer:TL,getAnimatableNone:g5};function aS(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function y5({hue:n,saturation:e,lightness:t,alpha:s}){n/=360,e/=100,t/=100;let r=0,i=0,a=0;if(!e)r=i=a=t;else{const o=t<.5?t*(1+e):t+e-t*e,l=2*t-o;r=aS(l,o,n+1/3),i=aS(l,o,n),a=aS(l,o,n-1/3)}return{red:Math.round(r*255),green:Math.round(i*255),blue:Math.round(a*255),alpha:s}}function m0(n,e){return t=>t>0?e:n}const en=(n,e,t)=>n+(e-n)*t,oS=(n,e,t)=>{const s=n*n,r=t*(e*e-s)+s;return r<0?0:Math.sqrt(r)},b5=[qS,Rl,Tc],x5=n=>b5.find(e=>e.test(n));function ER(n){const e=x5(n);if(!e)return!1;let t=e.parse(n);return e===Tc&&(t=y5(t)),t}const IR=(n,e)=>{const t=ER(n),s=ER(e);if(!t||!s)return m0(n,e);const r={...t};return i=>(r.red=oS(t.red,s.red,i),r.green=oS(t.green,s.green,i),r.blue=oS(t.blue,s.blue,i),r.alpha=en(t.alpha,s.alpha,i),Rl.transform(r))},KS=new Set(["none","hidden"]);function w5(n,e){return KS.has(n)?t=>t<=0?n:e:t=>t>=1?e:n}function v5(n,e){return t=>en(n,e,t)}function BC(n){return typeof n=="number"?v5:typeof n=="string"?MC(n)?m0:Nn.test(n)?IR:C5:Array.isArray(n)?CL:typeof n=="object"?Nn.test(n)?IR:S5:m0}function CL(n,e){const t=[...n],s=t.length,r=n.map((i,a)=>BC(i)(i,e[a]));return i=>{for(let a=0;a<s;a++)t[a]=r[a](i);return t}}function S5(n,e){const t={...n,...e},s={};for(const r in t)n[r]!==void 0&&e[r]!==void 0&&(s[r]=BC(n[r])(n[r],e[r]));return r=>{for(const i in s)t[i]=s[i](r);return t}}function T5(n,e){const t=[],s={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const i=e.types[r],a=n.indexes[i][s[i]],o=n.values[a]??0;t[r]=o,s[i]++}return t}const C5=(n,e)=>{const t=Eo.createTransformer(e),s=Uf(n),r=Uf(e);return s.indexes.var.length===r.indexes.var.length&&s.indexes.color.length===r.indexes.color.length&&s.indexes.number.length>=r.indexes.number.length?KS.has(n)&&!r.values.length||KS.has(e)&&!s.values.length?w5(n,e):yp(CL(T5(s,r),r.values),t):m0(n,e)};function NL(n,e,t){return typeof n=="number"&&typeof e=="number"&&typeof t=="number"?en(n,e,t):BC(n)(n,e)}const N5=n=>{const e=({timestamp:t})=>n(t);return{start:(t=!0)=>Xt.update(e,t),stop:()=>ko(e),now:()=>us.isProcessing?us.timestamp:Ks.now()}},kL=(n,e,t=10)=>{let s="";const r=Math.max(Math.round(e/t),2);for(let i=0;i<r;i++)s+=Math.round(n(i/(r-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},g0=2e4;function VC(n){let e=0;const t=50;let s=n.next(e);for(;!s.done&&e<g0;)e+=t,s=n.next(e);return e>=g0?1/0:e}function k5(n,e=100,t){const s=t({...n,keyframes:[0,e]}),r=Math.min(VC(s),g0);return{type:"keyframes",ease:i=>s.next(r*i).value/e,duration:Ur(r)}}const E5=5;function EL(n,e,t){const s=Math.max(e-E5,0);return iL(t-n(s),e-s)}const on={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},lS=.001;function I5({duration:n=on.duration,bounce:e=on.bounce,velocity:t=on.velocity,mass:s=on.mass}){let r,i,a=1-e;a=Sa(on.minDamping,on.maxDamping,a),n=Sa(on.minDuration,on.maxDuration,Ur(n)),a<1?(r=h=>{const d=h*a,p=d*n,m=d-t,y=XS(h,a),b=Math.exp(-p);return lS-m/y*b},i=h=>{const p=h*a*n,m=p*t+t,y=Math.pow(a,2)*Math.pow(h,2)*n,b=Math.exp(-p),x=XS(Math.pow(h,2),a);return(-r(h)+lS>0?-1:1)*((m-y)*b)/x}):(r=h=>{const d=Math.exp(-h*n),p=(h-t)*n+1;return-lS+d*p},i=h=>{const d=Math.exp(-h*n),p=(t-h)*(n*n);return d*p});const o=5/n,l=_5(r,i,o);if(n=Li(n),isNaN(l))return{stiffness:on.stiffness,damping:on.damping,duration:n};{const h=Math.pow(l,2)*s;return{stiffness:h,damping:a*2*Math.sqrt(s*h),duration:n}}}const $5=12;function _5(n,e,t){let s=t;for(let r=1;r<$5;r++)s=s-n(s)/e(s);return s}function XS(n,e){return n*Math.sqrt(1-e*e)}const A5=["duration","bounce"],R5=["stiffness","damping","mass"];function $R(n,e){return e.some(t=>n[t]!==void 0)}function D5(n){let e={velocity:on.velocity,stiffness:on.stiffness,damping:on.damping,mass:on.mass,isResolvedFromDuration:!1,...n};if(!$R(n,R5)&&$R(n,A5))if(n.visualDuration){const t=n.visualDuration,s=2*Math.PI/(t*1.2),r=s*s,i=2*Sa(.05,1,1-(n.bounce||0))*Math.sqrt(r);e={...e,mass:on.mass,stiffness:r,damping:i}}else{const t=I5(n);e={...e,...t,mass:on.mass},e.isResolvedFromDuration=!0}return e}function y0(n=on.visualDuration,e=on.bounce){const t=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:e}:n;let{restSpeed:s,restDelta:r}=t;const i=t.keyframes[0],a=t.keyframes[t.keyframes.length-1],o={done:!1,value:i},{stiffness:l,damping:h,mass:d,duration:p,velocity:m,isResolvedFromDuration:y}=D5({...t,velocity:-Ur(t.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(l*d)),w=a-i,v=Ur(Math.sqrt(l/d)),C=Math.abs(w)<5;s||(s=C?on.restSpeed.granular:on.restSpeed.default),r||(r=C?on.restDelta.granular:on.restDelta.default);let N;if(x<1){const E=XS(v,x);N=A=>{const R=Math.exp(-x*v*A);return a-R*((b+x*v*w)/E*Math.sin(E*A)+w*Math.cos(E*A))}}else if(x===1)N=E=>a-Math.exp(-v*E)*(w+(b+v*w)*E);else{const E=v*Math.sqrt(x*x-1);N=A=>{const R=Math.exp(-x*v*A),D=Math.min(E*A,300);return a-R*((b+x*v*w)*Math.sinh(D)+E*w*Math.cosh(D))/E}}const k={calculatedDuration:y&&p||null,next:E=>{const A=N(E);if(y)o.done=E>=p;else{let R=E===0?b:0;x<1&&(R=E===0?Li(b):EL(N,E,A));const D=Math.abs(R)<=s,L=Math.abs(a-A)<=r;o.done=D&&L}return o.value=o.done?a:A,o},toString:()=>{const E=Math.min(VC(k),g0),A=kL(R=>k.next(E*R).value,E,30);return E+"ms "+A},toTransition:()=>{}};return k}y0.applyToOptions=n=>{const e=k5(n,100,y0);return n.ease=e.ease,n.duration=Li(e.duration),n.type="keyframes",n};function YS({keyframes:n,velocity:e=0,power:t=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:i=500,modifyTarget:a,min:o,max:l,restDelta:h=.5,restSpeed:d}){const p=n[0],m={done:!1,value:p},y=D=>o!==void 0&&D<o||l!==void 0&&D>l,b=D=>o===void 0?l:l===void 0||Math.abs(o-D)<Math.abs(l-D)?o:l;let x=t*e;const w=p+x,v=a===void 0?w:a(w);v!==w&&(x=v-p);const C=D=>-x*Math.exp(-D/s),N=D=>v+C(D),k=D=>{const L=C(D),F=N(D);m.done=Math.abs(L)<=h,m.value=m.done?v:F};let E,A;const R=D=>{y(m.value)&&(E=D,A=y0({keyframes:[m.value,b(m.value)],velocity:EL(N,D,m.value),damping:r,stiffness:i,restDelta:h,restSpeed:d}))};return R(0),{calculatedDuration:null,next:D=>{let L=!1;return!A&&E===void 0&&(L=!0,k(D),R(D)),E!==void 0&&D>=E?A.next(D-E):(!L&&k(D),m)}}}function O5(n,e,t){const s=[],r=t||Ta.mix||NL,i=n.length-1;for(let a=0;a<i;a++){let o=r(n[a],n[a+1]);if(e){const l=Array.isArray(e)?e[a]||Gr:e;o=yp(l,o)}s.push(o)}return s}function L5(n,e,{clamp:t=!0,ease:s,mixer:r}={}){const i=n.length;if(RC(i===e.length),i===1)return()=>e[0];if(i===2&&e[0]===e[1])return()=>e[1];const a=n[0]===n[1];n[0]>n[i-1]&&(n=[...n].reverse(),e=[...e].reverse());const o=O5(e,s,r),l=o.length,h=d=>{if(a&&d<n[0])return e[0];let p=0;if(l>1)for(;p<n.length-2&&!(d<n[p+1]);p++);const m=Bf(n[p],n[p+1],d);return o[p](m)};return t?d=>h(Sa(n[0],n[i-1],d)):h}function F5(n,e){const t=n[n.length-1];for(let s=1;s<=e;s++){const r=Bf(0,e,s);n.push(en(t,1,r))}}function M5(n){const e=[0];return F5(e,n.length-1),e}function z5(n,e){return n.map(t=>t*e)}function P5(n,e){return n.map(()=>e||pL).splice(0,n.length-1)}function Rf({duration:n=300,keyframes:e,times:t,ease:s="easeInOut"}){const r=YG(s)?s.map(CR):CR(s),i={done:!1,value:e[0]},a=z5(t&&t.length===e.length?t:M5(e),n),o=L5(a,e,{ease:Array.isArray(r)?r:P5(e,r)});return{calculatedDuration:n,next:l=>(i.value=o(l),i.done=l>=n,i)}}const B5=n=>n!==null;function UC(n,{repeat:e,repeatType:t="loop"},s,r=1){const i=n.filter(B5),o=r<0||e&&t!=="loop"&&e%2===1?0:i.length-1;return!o||s===void 0?i[o]:s}const V5={decay:YS,inertia:YS,tween:Rf,keyframes:Rf,spring:y0};function IL(n){typeof n.type=="string"&&(n.type=V5[n.type])}class jC{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,t){return this.finished.then(e,t)}}const U5=n=>n/100;class WC extends jC{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:t}=this.options;t&&t.updatedAt!==Ks.now()&&this.tick(Ks.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;IL(e);const{type:t=Rf,repeat:s=0,repeatDelay:r=0,repeatType:i,velocity:a=0}=e;let{keyframes:o}=e;const l=t||Rf;l!==Rf&&typeof o[0]!="number"&&(this.mixKeyframes=yp(U5,NL(o[0],o[1])),o=[0,100]);const h=l({...e,keyframes:o});i==="mirror"&&(this.mirroredGenerator=l({...e,keyframes:[...o].reverse(),velocity:-a})),h.calculatedDuration===null&&(h.calculatedDuration=VC(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+r,this.totalDuration=this.resolvedDuration*(s+1)-r,this.generator=h}updateTime(e){const t=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=t}tick(e,t=!1){const{generator:s,totalDuration:r,mixKeyframes:i,mirroredGenerator:a,resolvedDuration:o,calculatedDuration:l}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:p,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-r/this.speed,this.startTime)),t?this.currentTime=e:this.updateTime(e);const v=this.currentTime-h*(this.playbackSpeed>=0?1:-1),C=this.playbackSpeed>=0?v<0:v>r;this.currentTime=Math.max(v,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=r);let N=this.currentTime,k=s;if(p){const D=Math.min(this.currentTime,r)/o;let L=Math.floor(D),F=D%1;!F&&D>=1&&(F=1),F===1&&L--,L=Math.min(L,p+1),L%2&&(m==="reverse"?(F=1-F,y&&(F-=y/o)):m==="mirror"&&(k=a)),N=Sa(0,1,F)*o}const E=C?{done:!1,value:d[0]}:k.next(N);i&&(E.value=i(E.value));let{done:A}=E;!C&&l!==null&&(A=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const R=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&A);return R&&b!==YS&&(E.value=UC(d,this.options,w,this.speed)),x&&x(E.value),R&&this.finish(),E}then(e,t){return this.finished.then(e,t)}get duration(){return Ur(this.calculatedDuration)}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+Ur(e)}get time(){return Ur(this.currentTime)}set time(e){e=Li(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(Ks.now());const t=this.playbackSpeed!==e;this.playbackSpeed=e,t&&(this.time=Ur(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=N5,startTime:t}=this.options;this.driver||(this.driver=e(r=>this.tick(r))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=t??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Ks.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),e.observe(this)}}function j5(n){for(let e=1;e<n.length;e++)n[e]??(n[e]=n[e-1])}const Dl=n=>n*180/Math.PI,JS=n=>{const e=Dl(Math.atan2(n[1],n[0]));return ZS(e)},W5={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:JS,rotateZ:JS,skewX:n=>Dl(Math.atan(n[1])),skewY:n=>Dl(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},ZS=n=>(n=n%360,n<0&&(n+=360),n),_R=JS,AR=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),RR=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),G5={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:AR,scaleY:RR,scale:n=>(AR(n)+RR(n))/2,rotateX:n=>ZS(Dl(Math.atan2(n[6],n[5]))),rotateY:n=>ZS(Dl(Math.atan2(-n[2],n[0]))),rotateZ:_R,rotate:_R,skewX:n=>Dl(Math.atan(n[4])),skewY:n=>Dl(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function QS(n){return n.includes("scale")?1:0}function eT(n,e){if(!n||n==="none")return QS(e);const t=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,r;if(t)s=G5,r=t;else{const o=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=W5,r=o}if(!r)return QS(e);const i=s[e],a=r[1].split(",").map(q5);return typeof i=="function"?i(a):a[i]}const H5=(n,e)=>{const{transform:t="none"}=getComputedStyle(n);return eT(t,e)};function q5(n){return parseFloat(n.trim())}const Zc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Qc=new Set(Zc),DR=n=>n===Jc||n===qe,K5=new Set(["x","y","z"]),X5=Zc.filter(n=>!K5.has(n));function Y5(n){const e=[];return X5.forEach(t=>{const s=n.getValue(t);s!==void 0&&(e.push([t,s.get()]),s.set(t.startsWith("scale")?1:0))}),e}const Ml={width:({x:n},{paddingLeft:e="0",paddingRight:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),height:({y:n},{paddingTop:e="0",paddingBottom:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),top:(n,{top:e})=>parseFloat(e),left:(n,{left:e})=>parseFloat(e),bottom:({y:n},{top:e})=>parseFloat(e)+(n.max-n.min),right:({x:n},{left:e})=>parseFloat(e)+(n.max-n.min),x:(n,{transform:e})=>eT(e,"x"),y:(n,{transform:e})=>eT(e,"y")};Ml.translateX=Ml.x;Ml.translateY=Ml.y;const zl=new Set;let tT=!1,nT=!1,sT=!1;function $L(){if(nT){const n=Array.from(zl).filter(s=>s.needsMeasurement),e=new Set(n.map(s=>s.element)),t=new Map;e.forEach(s=>{const r=Y5(s);r.length&&(t.set(s,r),s.render())}),n.forEach(s=>s.measureInitialState()),e.forEach(s=>{s.render();const r=t.get(s);r&&r.forEach(([i,a])=>{s.getValue(i)?.set(a)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}nT=!1,tT=!1,zl.forEach(n=>n.complete(sT)),zl.clear()}function _L(){zl.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(nT=!0)})}function J5(){sT=!0,_L(),$L(),sT=!1}class GC{constructor(e,t,s,r,i,a=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...e],this.onComplete=t,this.name=s,this.motionValue=r,this.element=i,this.isAsync=a}scheduleResolve(){this.state="scheduled",this.isAsync?(zl.add(this),tT||(tT=!0,Xt.read(_L),Xt.resolveKeyframes($L))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:t,element:s,motionValue:r}=this;if(e[0]===null){const i=r?.get(),a=e[e.length-1];if(i!==void 0)e[0]=i;else if(s&&t){const o=s.readValue(t,a);o!=null&&(e[0]=o)}e[0]===void 0&&(e[0]=a),r&&i===void 0&&r.set(e[0])}j5(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),zl.delete(this)}cancel(){this.state==="scheduled"&&(zl.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const Z5=n=>n.startsWith("--");function Q5(n,e,t){Z5(e)?n.style.setProperty(e,t):n.style[e]=t}const eH=DC(()=>window.ScrollTimeline!==void 0),tH={};function nH(n,e){const t=DC(n);return()=>tH[e]??t()}const AL=nH(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),wf=([n,e,t,s])=>`cubic-bezier(${n}, ${e}, ${t}, ${s})`,OR={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:wf([0,.65,.55,1]),circOut:wf([.55,0,1,.45]),backIn:wf([.31,.01,.66,-.59]),backOut:wf([.33,1.53,.69,.99])};function RL(n,e){if(n)return typeof n=="function"?AL()?kL(n,e):"ease-out":mL(n)?wf(n):Array.isArray(n)?n.map(t=>RL(t,e)||OR.easeOut):OR[n]}function sH(n,e,t,{delay:s=0,duration:r=300,repeat:i=0,repeatType:a="loop",ease:o="easeOut",times:l}={},h=void 0){const d={[e]:t};l&&(d.offset=l);const p=RL(o,r);Array.isArray(p)&&(d.easing=p);const m={delay:s,duration:r,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:i+1,direction:a==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function DL(n){return typeof n=="function"&&"applyToOptions"in n}function rH({type:n,...e}){return DL(n)&&AL()?n.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class iH extends jC{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:t,name:s,keyframes:r,pseudoElement:i,allowFlatten:a=!1,finalKeyframe:o,onComplete:l}=e;this.isPseudoElement=!!i,this.allowFlatten=a,this.options=e,RC(typeof e.type!="string");const h=rH(e);this.animation=sH(t,s,r,h,i),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!i){const d=UC(r,this.options,o,this.speed);this.updateMotionValue?this.updateMotionValue(d):Q5(t,s,d),this.animation.cancel()}l?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const e=this.animation.effect?.getComputedTiming?.().duration||0;return Ur(Number(e))}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+Ur(e)}get time(){return Ur(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=Li(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:t}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,e&&eH()?(this.animation.timeline=e,Gr):t(this)}}const OL={anticipate:hL,backInOut:cL,circInOut:fL};function aH(n){return n in OL}function oH(n){typeof n.ease=="string"&&aH(n.ease)&&(n.ease=OL[n.ease])}const LR=10;class lH extends iH{constructor(e){oH(e),IL(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:t,onUpdate:s,onComplete:r,element:i,...a}=this.options;if(!t)return;if(e!==void 0){t.set(e);return}const o=new WC({...a,autoplay:!1}),l=Li(this.finishedTime??this.time);t.setWithVelocity(o.sample(l-LR).value,o.sample(l).value,LR),o.stop()}}const FR=(n,e)=>e==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(Eo.test(n)||n==="0")&&!n.startsWith("url("));function uH(n){const e=n[0];if(n.length===1)return!0;for(let t=0;t<n.length;t++)if(n[t]!==e)return!0}function cH(n,e,t,s){const r=n[0];if(r===null)return!1;if(e==="display"||e==="visibility")return!0;const i=n[n.length-1],a=FR(r,e),o=FR(i,e);return!a||!o?!1:uH(n)||(t==="spring"||DL(t))&&s}function rT(n){n.duration=0,n.type="keyframes"}const hH=new Set(["opacity","clipPath","filter","transform"]),dH=DC(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function fH(n){const{motionValue:e,name:t,repeatDelay:s,repeatType:r,damping:i,type:a}=n;if(!(e?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:l,transformTemplate:h}=e.owner.getProps();return dH()&&t&&hH.has(t)&&(t!=="transform"||!h)&&!l&&!s&&r!=="mirror"&&i!==0&&a!=="inertia"}const pH=40;class mH extends jC{constructor({autoplay:e=!0,delay:t=0,type:s="keyframes",repeat:r=0,repeatDelay:i=0,repeatType:a="loop",keyframes:o,name:l,motionValue:h,element:d,...p}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Ks.now();const m={autoplay:e,delay:t,type:s,repeat:r,repeatDelay:i,repeatType:a,name:l,motionValue:h,element:d,...p},y=d?.KeyframeResolver||GC;this.keyframeResolver=new y(o,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),l,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(e,t,s,r){this.keyframeResolver=void 0;const{name:i,type:a,velocity:o,delay:l,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Ks.now(),cH(e,i,a,o)||((Ta.instantAnimations||!l)&&d?.(UC(e,s,t)),e[0]=e[e.length-1],rT(s),s.repeat=0);const m={startTime:r?this.resolvedAt?this.resolvedAt-this.createdAt>pH?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:t,...s,keyframes:e},y=!h&&fH(m)?new lH({...m,element:m.motionValue.owner.current}):new WC(m);y.finished.then(()=>this.notifyFinished()).catch(Gr),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(e,t){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),J5()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const gH=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function yH(n){const e=gH.exec(n);if(!e)return[,];const[,t,s,r]=e;return[`--${t??s}`,r]}function LL(n,e,t=1){const[s,r]=yH(n);if(!s)return;const i=window.getComputedStyle(e).getPropertyValue(s);if(i){const a=i.trim();return nL(a)?parseFloat(a):a}return MC(r)?LL(r,e,t+1):r}function HC(n,e){return n?.[e]??n?.default??n}const FL=new Set(["width","height","top","left","right","bottom",...Zc]),bH={test:n=>n==="auto",parse:n=>n},ML=n=>e=>e.test(n),zL=[Jc,qe,Fi,fo,u5,l5,bH],MR=n=>zL.find(ML(n));function xH(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||rL(n):!0}const wH=new Set(["brightness","contrast","saturate","opacity"]);function vH(n){const[e,t]=n.slice(0,-1).split("(");if(e==="drop-shadow")return n;const[s]=t.match(zC)||[];if(!s)return n;const r=t.replace(s,"");let i=wH.has(e)?1:0;return s!==t&&(i*=100),e+"("+i+r+")"}const SH=/\b([a-z-]*)\(.*?\)/gu,iT={...Eo,getAnimatableNone:n=>{const e=n.match(SH);return e?e.map(vH).join(" "):n}},zR={...Jc,transform:Math.round},TH={rotate:fo,rotateX:fo,rotateY:fo,rotateZ:fo,scale:Ey,scaleX:Ey,scaleY:Ey,scaleZ:Ey,skew:fo,skewX:fo,skewY:fo,distance:qe,translateX:qe,translateY:qe,translateZ:qe,x:qe,y:qe,z:qe,perspective:qe,transformPerspective:qe,opacity:Vf,originX:NR,originY:NR,originZ:qe},qC={borderWidth:qe,borderTopWidth:qe,borderRightWidth:qe,borderBottomWidth:qe,borderLeftWidth:qe,borderRadius:qe,radius:qe,borderTopLeftRadius:qe,borderTopRightRadius:qe,borderBottomRightRadius:qe,borderBottomLeftRadius:qe,width:qe,maxWidth:qe,height:qe,maxHeight:qe,top:qe,right:qe,bottom:qe,left:qe,padding:qe,paddingTop:qe,paddingRight:qe,paddingBottom:qe,paddingLeft:qe,margin:qe,marginTop:qe,marginRight:qe,marginBottom:qe,marginLeft:qe,backgroundPositionX:qe,backgroundPositionY:qe,...TH,zIndex:zR,fillOpacity:Vf,strokeOpacity:Vf,numOctaves:zR},CH={...qC,color:Nn,backgroundColor:Nn,outlineColor:Nn,fill:Nn,stroke:Nn,borderColor:Nn,borderTopColor:Nn,borderRightColor:Nn,borderBottomColor:Nn,borderLeftColor:Nn,filter:iT,WebkitFilter:iT},PL=n=>CH[n];function BL(n,e){let t=PL(n);return t!==iT&&(t=Eo),t.getAnimatableNone?t.getAnimatableNone(e):void 0}const NH=new Set(["auto","none","0"]);function kH(n,e,t){let s=0,r;for(;s<n.length&&!r;){const i=n[s];typeof i=="string"&&!NH.has(i)&&Uf(i).values.length&&(r=n[s]),s++}if(r&&t)for(const i of e)n[i]=BL(t,r)}class EH extends GC{constructor(e,t,s,r,i){super(e,t,s,r,i,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:t,name:s}=this;if(!t||!t.current)return;super.readKeyframes();for(let l=0;l<e.length;l++){let h=e[l];if(typeof h=="string"&&(h=h.trim(),MC(h))){const d=LL(h,t.current);d!==void 0&&(e[l]=d),l===e.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!FL.has(s)||e.length!==2)return;const[r,i]=e,a=MR(r),o=MR(i);if(a!==o)if(DR(a)&&DR(o))for(let l=0;l<e.length;l++){const h=e[l];typeof h=="string"&&(e[l]=parseFloat(h))}else Ml[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:t}=this,s=[];for(let r=0;r<e.length;r++)(e[r]===null||xH(e[r]))&&s.push(r);s.length&&kH(e,s,t)}measureInitialState(){const{element:e,unresolvedKeyframes:t,name:s}=this;if(!e||!e.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=Ml[s](e.measureViewportBox(),window.getComputedStyle(e.current)),t[0]=this.measuredOrigin;const r=t[t.length-1];r!==void 0&&e.getValue(s,r).jump(r,!1)}measureEndState(){const{element:e,name:t,unresolvedKeyframes:s}=this;if(!e||!e.current)return;const r=e.getValue(t);r&&r.jump(this.measuredOrigin,!1);const i=s.length-1,a=s[i];s[i]=Ml[t](e.measureViewportBox(),window.getComputedStyle(e.current)),a!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=a),this.removedTransforms?.length&&this.removedTransforms.forEach(([o,l])=>{e.getValue(o).set(l)}),this.resolveNoneKeyframes()}}function IH(n,e,t){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const r=t?.[n]??s.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}const VL=(n,e)=>e&&typeof n=="number"?e.transform(n):n;function UL(n){return sL(n)&&"offsetHeight"in n}const PR=30,$H=n=>!isNaN(parseFloat(n));class _H{constructor(e,t={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const r=Ks.now();if(this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const i of this.dependents)i.dirty()},this.hasAnimated=!1,this.setCurrent(e),this.owner=t.owner}setCurrent(e){this.current=e,this.updatedAt=Ks.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=$H(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new OC);const s=this.events[e].add(t);return e==="change"?()=>{s(),Xt.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e){this.passiveEffect?this.passiveEffect(e,this.updateAndNotify):this.updateAndNotify(e)}setWithVelocity(e,t,s){this.set(t),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-s}jump(e,t=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,t&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(e){this.dependents||(this.dependents=new Set),this.dependents.add(e)}removeDependent(e){this.dependents&&this.dependents.delete(e)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=Ks.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>PR)return 0;const t=Math.min(this.updatedAt-this.prevUpdatedAt,PR);return iL(parseFloat(this.current)-parseFloat(this.prevFrameValue),t)}start(e){return this.stop(),new Promise(t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Lc(n,e){return new _H(n,e)}const{schedule:KC}=gL(queueMicrotask,!1),ii={x:!1,y:!1};function jL(){return ii.x||ii.y}function AH(n){return n==="x"||n==="y"?ii[n]?null:(ii[n]=!0,()=>{ii[n]=!1}):ii.x||ii.y?null:(ii.x=ii.y=!0,()=>{ii.x=ii.y=!1})}function WL(n,e){const t=IH(n),s=new AbortController,r={passive:!0,...e,signal:s.signal};return[t,r,()=>s.abort()]}function BR(n){return!(n.pointerType==="touch"||jL())}function RH(n,e,t={}){const[s,r,i]=WL(n,t),a=o=>{if(!BR(o))return;const{target:l}=o,h=e(l,o);if(typeof h!="function"||!l)return;const d=p=>{BR(p)&&(h(p),l.removeEventListener("pointerleave",d))};l.addEventListener("pointerleave",d,r)};return s.forEach(o=>{o.addEventListener("pointerenter",a,r)}),i}const GL=(n,e)=>e?n===e?!0:GL(n,e.parentElement):!1,XC=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,DH=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function OH(n){return DH.has(n.tagName)||n.tabIndex!==-1}const Yy=new WeakSet;function VR(n){return e=>{e.key==="Enter"&&n(e)}}function uS(n,e){n.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const LH=(n,e)=>{const t=n.currentTarget;if(!t)return;const s=VR(()=>{if(Yy.has(t))return;uS(t,"down");const r=VR(()=>{uS(t,"up")}),i=()=>uS(t,"cancel");t.addEventListener("keyup",r,e),t.addEventListener("blur",i,e)});t.addEventListener("keydown",s,e),t.addEventListener("blur",()=>t.removeEventListener("keydown",s),e)};function UR(n){return XC(n)&&!jL()}function FH(n,e,t={}){const[s,r,i]=WL(n,t),a=o=>{const l=o.currentTarget;if(!UR(o))return;Yy.add(l);const h=e(l,o),d=(y,b)=>{window.removeEventListener("pointerup",p),window.removeEventListener("pointercancel",m),Yy.has(l)&&Yy.delete(l),UR(y)&&typeof h=="function"&&h(y,{success:b})},p=y=>{d(y,l===window||l===document||t.useGlobalTarget||GL(l,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",p,r),window.addEventListener("pointercancel",m,r)};return s.forEach(o=>{(t.useGlobalTarget?window:o).addEventListener("pointerdown",a,r),UL(o)&&(o.addEventListener("focus",h=>LH(h,r)),!OH(o)&&!o.hasAttribute("tabindex")&&(o.tabIndex=0))}),i}function HL(n){return sL(n)&&"ownerSVGElement"in n}function MH(n){return HL(n)&&n.tagName==="svg"}const ys=n=>!!(n&&n.getVelocity),zH=[...zL,Nn,Eo],PH=n=>zH.find(ML(n)),YC=Ce.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function jR(n,e){if(typeof n=="function")return n(e);n!=null&&(n.current=e)}function BH(...n){return e=>{let t=!1;const s=n.map(r=>{const i=jR(r,e);return!t&&typeof i=="function"&&(t=!0),i});if(t)return()=>{for(let r=0;r<s.length;r++){const i=s[r];typeof i=="function"?i():jR(n[r],null)}}}}function VH(...n){return Ce.useCallback(BH(...n),n)}class UH extends Ce.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const s=t.offsetParent,r=UL(s)&&s.offsetWidth||0,i=this.props.sizeRef.current;i.height=t.offsetHeight||0,i.width=t.offsetWidth||0,i.top=t.offsetTop,i.left=t.offsetLeft,i.right=r-i.width-i.left}return null}componentDidUpdate(){}render(){return this.props.children}}function jH({children:n,isPresent:e,anchorX:t,root:s}){const r=Ce.useId(),i=Ce.useRef(null),a=Ce.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:o}=Ce.useContext(YC),l=VH(i,n?.ref);return Ce.useInsertionEffect(()=>{const{width:h,height:d,top:p,left:m,right:y}=a.current;if(e||!i.current||!h||!d)return;const b=t==="left"?`left: ${m}`:`right: ${y}`;i.current.dataset.motionPopId=r;const x=document.createElement("style");o&&(x.nonce=o);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${p}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[e]),pe.jsx(UH,{isPresent:e,childRef:i,sizeRef:a,children:Ce.cloneElement(n,{ref:l})})}const WH=({children:n,initial:e,isPresent:t,onExitComplete:s,custom:r,presenceAffectsLayout:i,mode:a,anchorX:o,root:l})=>{const h=IC(GH),d=Ce.useId();let p=!0,m=Ce.useMemo(()=>(p=!1,{id:d,initial:e,isPresent:t,custom:r,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[t,h,s]);return i&&p&&(m={...m}),Ce.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[t]),Ce.useEffect(()=>{!t&&!h.size&&s&&s()},[t]),a==="popLayout"&&(n=pe.jsx(jH,{isPresent:t,anchorX:o,root:l,children:n})),pe.jsx(ob.Provider,{value:m,children:n})};function GH(){return new Map}function qL(n=!0){const e=Ce.useContext(ob);if(e===null)return[!0,null];const{isPresent:t,onExitComplete:s,register:r}=e,i=Ce.useId();Ce.useEffect(()=>{if(n)return r(i)},[n]);const a=Ce.useCallback(()=>n&&s&&s(i),[i,s,n]);return!t&&s?[!1,a]:[!0]}const Iy=n=>n.key||"";function WR(n){const e=[];return Ce.Children.forEach(n,t=>{Ce.isValidElement(t)&&e.push(t)}),e}const HH=({children:n,custom:e,initial:t=!0,onExitComplete:s,presenceAffectsLayout:r=!0,mode:i="sync",propagate:a=!1,anchorX:o="left",root:l})=>{const[h,d]=qL(a),p=Ce.useMemo(()=>WR(n),[n]),m=a&&!h?[]:p.map(Iy),y=Ce.useRef(!0),b=Ce.useRef(p),x=IC(()=>new Map),[w,v]=Ce.useState(p),[C,N]=Ce.useState(p);tL(()=>{y.current=!1,b.current=p;for(let A=0;A<C.length;A++){const R=Iy(C[A]);m.includes(R)?x.delete(R):x.get(R)!==!0&&x.set(R,!1)}},[C,m.length,m.join("-")]);const k=[];if(p!==w){let A=[...p];for(let R=0;R<C.length;R++){const D=C[R],L=Iy(D);m.includes(L)||(A.splice(R,0,D),k.push(D))}return i==="wait"&&k.length&&(A=k),N(WR(A)),v(p),null}const{forceRender:E}=Ce.useContext(EC);return pe.jsx(pe.Fragment,{children:C.map(A=>{const R=Iy(A),D=a&&!h?!1:p===C||m.includes(R),L=()=>{if(x.has(R))x.set(R,!0);else return;let F=!0;x.forEach(_=>{_||(F=!1)}),F&&(E?.(),N(b.current),a&&d?.(),s&&s())};return pe.jsx(WH,{isPresent:D,initial:!y.current||t?void 0:!1,custom:e,presenceAffectsLayout:r,mode:i,root:l,onExitComplete:D?void 0:L,anchorX:o,children:A},R)})})},KL=Ce.createContext({strict:!1}),GR={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Fc={};for(const n in GR)Fc[n]={isEnabled:e=>GR[n].some(t=>!!e[t])};function qH(n){for(const e in n)Fc[e]={...Fc[e],...n[e]}}const KH=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function b0(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||KH.has(n)}let XL=n=>!b0(n);function XH(n){typeof n=="function"&&(XL=e=>e.startsWith("on")?!b0(e):n(e))}try{XH(require("@emotion/is-prop-valid").default)}catch{}function YH(n,e,t){const s={};for(const r in n)r==="values"&&typeof n.values=="object"||(XL(r)||t===!0&&b0(r)||!e&&!b0(r)||n.draggable&&r.startsWith("onDrag"))&&(s[r]=n[r]);return s}const lb=Ce.createContext({});function ub(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function jf(n){return typeof n=="string"||Array.isArray(n)}const JC=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],ZC=["initial",...JC];function cb(n){return ub(n.animate)||ZC.some(e=>jf(n[e]))}function YL(n){return!!(cb(n)||n.variants)}function JH(n,e){if(cb(n)){const{initial:t,animate:s}=n;return{initial:t===!1||jf(t)?t:void 0,animate:jf(s)?s:void 0}}return n.inherit!==!1?e:{}}function ZH(n){const{initial:e,animate:t}=JH(n,Ce.useContext(lb));return Ce.useMemo(()=>({initial:e,animate:t}),[HR(e),HR(t)])}function HR(n){return Array.isArray(n)?n.join(" "):n}function qR(n,e){return e.max===e.min?0:n/(e.max-e.min)*100}const ff={correct:(n,e)=>{if(!e.target)return n;if(typeof n=="string")if(qe.test(n))n=parseFloat(n);else return n;const t=qR(n,e.target.x),s=qR(n,e.target.y);return`${t}% ${s}%`}},QH={correct:(n,{treeScale:e,projectionDelta:t})=>{const s=n,r=Eo.parse(n);if(r.length>5)return s;const i=Eo.createTransformer(n),a=typeof r[0]!="number"?1:0,o=t.x.scale*e.x,l=t.y.scale*e.y;r[0+a]/=o,r[1+a]/=l;const h=en(o,l,.5);return typeof r[2+a]=="number"&&(r[2+a]/=h),typeof r[3+a]=="number"&&(r[3+a]/=h),i(r)}},aT={borderRadius:{...ff,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:ff,borderTopRightRadius:ff,borderBottomLeftRadius:ff,borderBottomRightRadius:ff,boxShadow:QH};function JL(n,{layout:e,layoutId:t}){return Qc.has(n)||n.startsWith("origin")||(e||t!==void 0)&&(!!aT[n]||n==="opacity")}const e6={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},t6=Zc.length;function n6(n,e,t){let s="",r=!0;for(let i=0;i<t6;i++){const a=Zc[i],o=n[a];if(o===void 0)continue;let l=!0;if(typeof o=="number"?l=o===(a.startsWith("scale")?1:0):l=parseFloat(o)===0,!l||t){const h=VL(o,qC[a]);if(!l){r=!1;const d=e6[a]||a;s+=`${d}(${h}) `}t&&(e[a]=h)}}return s=s.trim(),t?s=t(e,r?"":s):r&&(s="none"),s}function QC(n,e,t){const{style:s,vars:r,transformOrigin:i}=n;let a=!1,o=!1;for(const l in e){const h=e[l];if(Qc.has(l)){a=!0;continue}else if(bL(l)){r[l]=h;continue}else{const d=VL(h,qC[l]);l.startsWith("origin")?(o=!0,i[l]=d):s[l]=d}}if(e.transform||(a||t?s.transform=n6(e,n.transform,t):s.transform&&(s.transform="none")),o){const{originX:l="50%",originY:h="50%",originZ:d=0}=i;s.transformOrigin=`${l} ${h} ${d}`}}const e2=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function ZL(n,e,t){for(const s in e)!ys(e[s])&&!JL(s,t)&&(n[s]=e[s])}function s6({transformTemplate:n},e){return Ce.useMemo(()=>{const t=e2();return QC(t,e,n),Object.assign({},t.vars,t.style)},[e])}function r6(n,e){const t=n.style||{},s={};return ZL(s,t,n),Object.assign(s,s6(n,e)),s}function i6(n,e){const t={},s=r6(n,e);return n.drag&&n.dragListener!==!1&&(t.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(t.tabIndex=0),t.style=s,t}const a6={offset:"stroke-dashoffset",array:"stroke-dasharray"},o6={offset:"strokeDashoffset",array:"strokeDasharray"};function l6(n,e,t=1,s=0,r=!0){n.pathLength=1;const i=r?a6:o6;n[i.offset]=qe.transform(-s);const a=qe.transform(e),o=qe.transform(t);n[i.array]=`${a} ${o}`}function QL(n,{attrX:e,attrY:t,attrScale:s,pathLength:r,pathSpacing:i=1,pathOffset:a=0,...o},l,h,d){if(QC(n,o,h),l){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:m}=n;p.transform&&(m.transform=p.transform,delete p.transform),(m.transform||p.transformOrigin)&&(m.transformOrigin=p.transformOrigin??"50% 50%",delete p.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete p.transformBox),e!==void 0&&(p.x=e),t!==void 0&&(p.y=t),s!==void 0&&(p.scale=s),r!==void 0&&l6(p,r,i,a,!1)}const eF=()=>({...e2(),attrs:{}}),tF=n=>typeof n=="string"&&n.toLowerCase()==="svg";function u6(n,e,t,s){const r=Ce.useMemo(()=>{const i=eF();return QL(i,e,tF(s),n.transformTemplate,n.style),{...i.attrs,style:{...i.style}}},[e]);if(n.style){const i={};ZL(i,n.style,n),r.style={...i,...r.style}}return r}const c6=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function t2(n){return typeof n!="string"||n.includes("-")?!1:!!(c6.indexOf(n)>-1||/[A-Z]/u.test(n))}function h6(n,e,t,{latestValues:s},r,i=!1){const o=(t2(n)?u6:i6)(e,s,r,n),l=YH(e,typeof n=="string",i),h=n!==Ce.Fragment?{...l,...o,ref:t}:{},{children:d}=e,p=Ce.useMemo(()=>ys(d)?d.get():d,[d]);return Ce.createElement(n,{...h,children:p})}function KR(n){const e=[{},{}];return n?.values.forEach((t,s)=>{e[0][s]=t.get(),e[1][s]=t.getVelocity()}),e}function n2(n,e,t,s){if(typeof e=="function"){const[r,i]=KR(s);e=e(t!==void 0?t:n.custom,r,i)}if(typeof e=="string"&&(e=n.variants&&n.variants[e]),typeof e=="function"){const[r,i]=KR(s);e=e(t!==void 0?t:n.custom,r,i)}return e}function Jy(n){return ys(n)?n.get():n}function d6({scrapeMotionValuesFromProps:n,createRenderState:e},t,s,r){return{latestValues:f6(t,s,r,n),renderState:e()}}function f6(n,e,t,s){const r={},i=s(n,{});for(const m in i)r[m]=Jy(i[m]);let{initial:a,animate:o}=n;const l=cb(n),h=YL(n);e&&h&&!l&&n.inherit!==!1&&(a===void 0&&(a=e.initial),o===void 0&&(o=e.animate));let d=t?t.initial===!1:!1;d=d||a===!1;const p=d?o:a;if(p&&typeof p!="boolean"&&!ub(p)){const m=Array.isArray(p)?p:[p];for(let y=0;y<m.length;y++){const b=n2(n,m[y]);if(b){const{transitionEnd:x,transition:w,...v}=b;for(const C in v){let N=v[C];if(Array.isArray(N)){const k=d?N.length-1:0;N=N[k]}N!==null&&(r[C]=N)}for(const C in x)r[C]=x[C]}}}return r}const nF=n=>(e,t)=>{const s=Ce.useContext(lb),r=Ce.useContext(ob),i=()=>d6(n,e,s,r);return t?i():IC(i)};function s2(n,e,t){const{style:s}=n,r={};for(const i in s)(ys(s[i])||e.style&&ys(e.style[i])||JL(i,n)||t?.getValue(i)?.liveStyle!==void 0)&&(r[i]=s[i]);return r}const p6=nF({scrapeMotionValuesFromProps:s2,createRenderState:e2});function sF(n,e,t){const s=s2(n,e,t);for(const r in n)if(ys(n[r])||ys(e[r])){const i=Zc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;s[i]=n[r]}return s}const m6=nF({scrapeMotionValuesFromProps:sF,createRenderState:eF}),g6=Symbol.for("motionComponentSymbol");function Cc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function y6(n,e,t){return Ce.useCallback(s=>{s&&n.onMount&&n.onMount(s),e&&(s?e.mount(s):e.unmount()),t&&(typeof t=="function"?t(s):Cc(t)&&(t.current=s))},[e])}const r2=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),b6="framerAppearId",rF="data-"+r2(b6),iF=Ce.createContext({});function x6(n,e,t,s,r){const{visualElement:i}=Ce.useContext(lb),a=Ce.useContext(KL),o=Ce.useContext(ob),l=Ce.useContext(YC).reducedMotion,h=Ce.useRef(null);s=s||a.renderer,!h.current&&s&&(h.current=s(n,{visualState:e,parent:i,props:t,presenceContext:o,blockInitialAnimation:o?o.initial===!1:!1,reducedMotionConfig:l}));const d=h.current,p=Ce.useContext(iF);d&&!d.projection&&r&&(d.type==="html"||d.type==="svg")&&w6(h.current,t,r,p);const m=Ce.useRef(!1);Ce.useInsertionEffect(()=>{d&&m.current&&d.update(t,o)});const y=t[rF],b=Ce.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return tL(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),Ce.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function w6(n,e,t,s){const{layoutId:r,layout:i,drag:a,dragConstraints:o,layoutScroll:l,layoutRoot:h,layoutCrossfade:d}=e;n.projection=new t(n.latestValues,e["data-framer-portal-id"]?void 0:aF(n.parent)),n.projection.setOptions({layoutId:r,layout:i,alwaysMeasureLayout:!!a||o&&Cc(o),visualElement:n,animationType:typeof i=="string"?i:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:l,layoutRoot:h})}function aF(n){if(n)return n.options.allowProjection!==!1?n.projection:aF(n.parent)}function cS(n,{forwardMotionProps:e=!1}={},t,s){t&&qH(t);const r=t2(n)?m6:p6;function i(o,l){let h;const d={...Ce.useContext(YC),...o,layoutId:v6(o)},{isStatic:p}=d,m=ZH(o),y=r(o,p);if(!p&&$C){S6();const b=T6(d);h=b.MeasureLayout,m.visualElement=x6(n,y,d,s,b.ProjectionNode)}return pe.jsxs(lb.Provider,{value:m,children:[h&&m.visualElement?pe.jsx(h,{visualElement:m.visualElement,...d}):null,h6(n,o,y6(y,m.visualElement,l),y,p,e)]})}i.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const a=Ce.forwardRef(i);return a[g6]=n,a}function v6({layoutId:n}){const e=Ce.useContext(EC).id;return e&&n!==void 0?e+"-"+n:n}function S6(n,e){Ce.useContext(KL).strict}function T6(n){const{drag:e,layout:t}=Fc;if(!e&&!t)return{};const s={...e,...t};return{MeasureLayout:e?.isEnabled(n)||t?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function C6(n,e){if(typeof Proxy>"u")return cS;const t=new Map,s=(i,a)=>cS(i,a,n,e),r=(i,a)=>s(i,a);return new Proxy(r,{get:(i,a)=>a==="create"?s:(t.has(a)||t.set(a,cS(a,void 0,n,e)),t.get(a))})}function oF({top:n,left:e,right:t,bottom:s}){return{x:{min:e,max:t},y:{min:n,max:s}}}function N6({x:n,y:e}){return{top:e.min,right:n.max,bottom:e.max,left:n.min}}function k6(n,e){if(!e)return n;const t=e({x:n.left,y:n.top}),s=e({x:n.right,y:n.bottom});return{top:t.y,left:t.x,bottom:s.y,right:s.x}}function hS(n){return n===void 0||n===1}function oT({scale:n,scaleX:e,scaleY:t}){return!hS(n)||!hS(e)||!hS(t)}function vl(n){return oT(n)||lF(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function lF(n){return XR(n.x)||XR(n.y)}function XR(n){return n&&n!=="0%"}function x0(n,e,t){const s=n-t,r=e*s;return t+r}function YR(n,e,t,s,r){return r!==void 0&&(n=x0(n,r,s)),x0(n,t,s)+e}function lT(n,e=0,t=1,s,r){n.min=YR(n.min,e,t,s,r),n.max=YR(n.max,e,t,s,r)}function uF(n,{x:e,y:t}){lT(n.x,e.translate,e.scale,e.originPoint),lT(n.y,t.translate,t.scale,t.originPoint)}const JR=.999999999999,ZR=1.0000000000001;function E6(n,e,t,s=!1){const r=t.length;if(!r)return;e.x=e.y=1;let i,a;for(let o=0;o<r;o++){i=t[o],a=i.projectionDelta;const{visualElement:l}=i.options;l&&l.props.style&&l.props.style.display==="contents"||(s&&i.options.layoutScroll&&i.scroll&&i!==i.root&&kc(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),a&&(e.x*=a.x.scale,e.y*=a.y.scale,uF(n,a)),s&&vl(i.latestValues)&&kc(n,i.latestValues))}e.x<ZR&&e.x>JR&&(e.x=1),e.y<ZR&&e.y>JR&&(e.y=1)}function Nc(n,e){n.min=n.min+e,n.max=n.max+e}function QR(n,e,t,s,r=.5){const i=en(n.min,n.max,r);lT(n,e,t,i,s)}function kc(n,e){QR(n.x,e.x,e.scaleX,e.scale,e.originX),QR(n.y,e.y,e.scaleY,e.scale,e.originY)}function cF(n,e){return oF(k6(n.getBoundingClientRect(),e))}function I6(n,e,t){const s=cF(n,t),{scroll:r}=e;return r&&(Nc(s.x,r.offset.x),Nc(s.y,r.offset.y)),s}const eD=()=>({translate:0,scale:1,origin:0,originPoint:0}),Ec=()=>({x:eD(),y:eD()}),tD=()=>({min:0,max:0}),On=()=>({x:tD(),y:tD()}),uT={current:null},hF={current:!1};function $6(){if(hF.current=!0,!!$C)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),e=()=>uT.current=n.matches;n.addEventListener("change",e),e()}else uT.current=!1}const _6=new WeakMap;function A6(n,e,t){for(const s in e){const r=e[s],i=t[s];if(ys(r))n.addValue(s,r);else if(ys(i))n.addValue(s,Lc(r,{owner:n}));else if(i!==r)if(n.hasValue(s)){const a=n.getValue(s);a.liveStyle===!0?a.jump(r):a.hasAnimated||a.set(r)}else{const a=n.getStaticValue(s);n.addValue(s,Lc(a!==void 0?a:r,{owner:n}))}}for(const s in t)e[s]===void 0&&n.removeValue(s);return e}const nD=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class R6{scrapeMotionValuesFromProps(e,t,s){return{}}constructor({parent:e,props:t,presenceContext:s,reducedMotionConfig:r,blockInitialAnimation:i,visualState:a},o={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=GC,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Ks.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,Xt.render(this.render,!1,!0))};const{latestValues:l,renderState:h}=a;this.latestValues=l,this.baseTarget={...l},this.initialValues=t.initial?{...l}:{},this.renderState=h,this.parent=e,this.props=t,this.presenceContext=s,this.depth=e?e.depth+1:0,this.reducedMotionConfig=r,this.options=o,this.blockInitialAnimation=!!i,this.isControllingVariants=cb(t),this.isVariantNode=YL(t),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...p}=this.scrapeMotionValuesFromProps(t,{},this);for(const m in p){const y=p[m];l[m]!==void 0&&ys(y)&&y.set(l[m])}}mount(e){this.current=e,_6.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,s)=>this.bindToMotionValue(s,t)),hF.current||$6(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:uT.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),ko(this.notifyUpdate),ko(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const t=this.features[e];t&&(t.unmount(),t.isMounted=!1)}this.current=null}addChild(e){this.children.add(e),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(e)}removeChild(e){this.children.delete(e),this.enteringChildren&&this.enteringChildren.delete(e)}bindToMotionValue(e,t){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const s=Qc.has(e);s&&this.onBindTransform&&this.onBindTransform();const r=t.on("change",a=>{this.latestValues[e]=a,this.props.onUpdate&&Xt.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,e,t)),this.valueSubscriptions.set(e,()=>{r(),i&&i(),t.owner&&t.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in Fc){const t=Fc[e];if(!t)continue;const{isEnabled:s,Feature:r}=t;if(!this.features[e]&&r&&s(this.props)&&(this.features[e]=new r(this)),this.features[e]){const i=this.features[e];i.isMounted?i.update():(i.mount(),i.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):On()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let s=0;s<nD.length;s++){const r=nD[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const i="on"+r,a=e[i];a&&(this.propEventSubscriptions[r]=this.on(r,a))}this.prevMotionValues=A6(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){const s=this.values.get(e);t!==s&&(s&&this.removeValue(e),this.bindToMotionValue(e,t),this.values.set(e,t),this.latestValues[e]=t.get())}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let s=this.values.get(e);return s===void 0&&t!==void 0&&(s=Lc(t===null?void 0:t,{owner:this}),this.addValue(e,s)),s}readValue(e,t){let s=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return s!=null&&(typeof s=="string"&&(nL(s)||rL(s))?s=parseFloat(s):!PH(s)&&Eo.test(t)&&(s=BL(e,t)),this.setBaseTarget(e,ys(s)?s.get():s)),ys(s)?s.get():s}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){const{initial:t}=this.props;let s;if(typeof t=="string"||typeof t=="object"){const i=n2(this.props,t,this.presenceContext?.custom);i&&(s=i[e])}if(t&&s!==void 0)return s;const r=this.getBaseTargetFromProps(this.props,e);return r!==void 0&&!ys(r)?r:this.initialValues[e]!==void 0&&s===void 0?void 0:this.baseTarget[e]}on(e,t){return this.events[e]||(this.events[e]=new OC),this.events[e].add(t)}notify(e,...t){this.events[e]&&this.events[e].notify(...t)}scheduleRenderMicrotask(){KC.render(this.render)}}class dF extends R6{constructor(){super(...arguments),this.KeyframeResolver=EH}sortInstanceNodePosition(e,t){return e.compareDocumentPosition(t)&2?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,{vars:t,style:s}){delete t[e],delete s[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;ys(e)&&(this.childSubscription=e.on("change",t=>{this.current&&(this.current.textContent=`${t}`)}))}}function fF(n,{style:e,vars:t},s,r){const i=n.style;let a;for(a in e)i[a]=e[a];r?.applyProjectionStyles(i,s);for(a in t)i.setProperty(a,t[a])}function D6(n){return window.getComputedStyle(n)}class O6 extends dF{constructor(){super(...arguments),this.type="html",this.renderInstance=fF}readValueFromInstance(e,t){if(Qc.has(t))return this.projection?.isProjecting?QS(t):H5(e,t);{const s=D6(e),r=(bL(t)?s.getPropertyValue(t):s[t])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(e,{transformPagePoint:t}){return cF(e,t)}build(e,t,s){QC(e,t,s.transformTemplate)}scrapeMotionValuesFromProps(e,t,s){return s2(e,t,s)}}const pF=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function L6(n,e,t,s){fF(n,e,void 0,s);for(const r in e.attrs)n.setAttribute(pF.has(r)?r:r2(r),e.attrs[r])}class F6 extends dF{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=On}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(Qc.has(t)){const s=PL(t);return s&&s.default||0}return t=pF.has(t)?t:r2(t),e.getAttribute(t)}scrapeMotionValuesFromProps(e,t,s){return sF(e,t,s)}build(e,t,s){QL(e,t,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(e,t,s,r){L6(e,t,s,r)}mount(e){this.isSVGTag=tF(e.tagName),super.mount(e)}}const M6=(n,e)=>t2(n)?new F6(e):new O6(e,{allowProjection:n!==Ce.Fragment});function $c(n,e,t){const s=n.getProps();return n2(s,e,t!==void 0?t:s.custom,n)}const cT=n=>Array.isArray(n);function z6(n,e,t){n.hasValue(e)?n.getValue(e).set(t):n.addValue(e,Lc(t))}function P6(n){return cT(n)?n[n.length-1]||0:n}function B6(n,e){const t=$c(n,e);let{transitionEnd:s={},transition:r={},...i}=t||{};i={...i,...s};for(const a in i){const o=P6(i[a]);z6(n,a,o)}}function V6(n){return!!(ys(n)&&n.add)}function hT(n,e){const t=n.getValue("willChange");if(V6(t))return t.add(e);if(!t&&Ta.WillChange){const s=new Ta.WillChange("auto");n.addValue("willChange",s),s.add(e)}}function mF(n){return n.props[rF]}const U6=n=>n!==null;function j6(n,{repeat:e,repeatType:t="loop"},s){const r=n.filter(U6),i=e&&t!=="loop"&&e%2===1?0:r.length-1;return r[i]}const W6={type:"spring",stiffness:500,damping:25,restSpeed:10},G6=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),H6={type:"keyframes",duration:.8},q6={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},K6=(n,{keyframes:e})=>e.length>2?H6:Qc.has(n)?n.startsWith("scale")?G6(e[1]):W6:q6;function X6({when:n,delay:e,delayChildren:t,staggerChildren:s,staggerDirection:r,repeat:i,repeatType:a,repeatDelay:o,from:l,elapsed:h,...d}){return!!Object.keys(d).length}const i2=(n,e,t,s={},r,i)=>a=>{const o=HC(s,n)||{},l=o.delay||s.delay||0;let{elapsed:h=0}=s;h=h-Li(l);const d={keyframes:Array.isArray(t)?t:[null,t],ease:"easeOut",velocity:e.getVelocity(),...o,delay:-h,onUpdate:m=>{e.set(m),o.onUpdate&&o.onUpdate(m)},onComplete:()=>{a(),o.onComplete&&o.onComplete()},name:n,motionValue:e,element:i?void 0:r};X6(o)||Object.assign(d,K6(n,d)),d.duration&&(d.duration=Li(d.duration)),d.repeatDelay&&(d.repeatDelay=Li(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let p=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(rT(d),d.delay===0&&(p=!0)),(Ta.instantAnimations||Ta.skipAnimations)&&(p=!0,rT(d),d.delay=0),d.allowFlatten=!o.type&&!o.ease,p&&!i&&e.get()!==void 0){const m=j6(d.keyframes,o);if(m!==void 0){Xt.update(()=>{d.onUpdate(m),d.onComplete()});return}}return o.isSync?new WC(d):new mH(d)};function Y6({protectedKeys:n,needsAnimating:e},t){const s=n.hasOwnProperty(t)&&e[t]!==!0;return e[t]=!1,s}function gF(n,e,{delay:t=0,transitionOverride:s,type:r}={}){let{transition:i=n.getDefaultTransition(),transitionEnd:a,...o}=e;s&&(i=s);const l=[],h=r&&n.animationState&&n.animationState.getState()[r];for(const d in o){const p=n.getValue(d,n.latestValues[d]??null),m=o[d];if(m===void 0||h&&Y6(h,d))continue;const y={delay:t,...HC(i||{},d)},b=p.get();if(b!==void 0&&!p.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const v=mF(n);if(v){const C=window.MotionHandoffAnimation(v,d,Xt);C!==null&&(y.startTime=C,x=!0)}}hT(n,d),p.start(i2(d,p,m,n.shouldReduceMotion&&FL.has(d)?{type:!1}:y,n,x));const w=p.animation;w&&l.push(w)}return a&&Promise.all(l).then(()=>{Xt.update(()=>{a&&B6(n,a)})}),l}function yF(n,e,t,s=0,r=1){const i=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(e),a=n.size,o=(a-1)*s;return typeof t=="function"?t(i,a):r===1?i*s:o-i*s}function dT(n,e,t={}){const s=$c(n,e,t.type==="exit"?n.presenceContext?.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=s||{};t.transitionOverride&&(r=t.transitionOverride);const i=s?()=>Promise.all(gF(n,s,t)):()=>Promise.resolve(),a=n.variantChildren&&n.variantChildren.size?(l=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:p}=r;return J6(n,e,l,h,d,p,t)}:()=>Promise.resolve(),{when:o}=r;if(o){const[l,h]=o==="beforeChildren"?[i,a]:[a,i];return l().then(()=>h())}else return Promise.all([i(),a(t.delay)])}function J6(n,e,t=0,s=0,r=0,i=1,a){const o=[];for(const l of n.variantChildren)l.notify("AnimationStart",e),o.push(dT(l,e,{...a,delay:t+(typeof s=="function"?0:s)+yF(n.variantChildren,l,s,r,i)}).then(()=>l.notify("AnimationComplete",e)));return Promise.all(o)}function Z6(n,e,t={}){n.notify("AnimationStart",e);let s;if(Array.isArray(e)){const r=e.map(i=>dT(n,i,t));s=Promise.all(r)}else if(typeof e=="string")s=dT(n,e,t);else{const r=typeof e=="function"?$c(n,e,t.custom):e;s=Promise.all(gF(n,r,t))}return s.then(()=>{n.notify("AnimationComplete",e)})}function bF(n,e){if(!Array.isArray(e))return!1;const t=e.length;if(t!==n.length)return!1;for(let s=0;s<t;s++)if(e[s]!==n[s])return!1;return!0}const Q6=ZC.length;function xF(n){if(!n)return;if(!n.isControllingVariants){const t=n.parent?xF(n.parent)||{}:{};return n.props.initial!==void 0&&(t.initial=n.props.initial),t}const e={};for(let t=0;t<Q6;t++){const s=ZC[t],r=n.props[s];(jf(r)||r===!1)&&(e[s]=r)}return e}const eq=[...JC].reverse(),tq=JC.length;function nq(n){return e=>Promise.all(e.map(({animation:t,options:s})=>Z6(n,t,s)))}function sq(n){let e=nq(n),t=sD(),s=!0;const r=l=>(h,d)=>{const p=$c(n,d,l==="exit"?n.presenceContext?.custom:void 0);if(p){const{transition:m,transitionEnd:y,...b}=p;h={...h,...b,...y}}return h};function i(l){e=l(n)}function a(l){const{props:h}=n,d=xF(n.parent)||{},p=[],m=new Set;let y={},b=1/0;for(let w=0;w<tq;w++){const v=eq[w],C=t[v],N=h[v]!==void 0?h[v]:d[v],k=jf(N),E=v===l?C.isActive:null;E===!1&&(b=w);let A=N===d[v]&&N!==h[v]&&k;if(A&&s&&n.manuallyAnimateOnMount&&(A=!1),C.protectedKeys={...y},!C.isActive&&E===null||!N&&!C.prevProp||ub(N)||typeof N=="boolean")continue;const R=rq(C.prevProp,N);let D=R||v===l&&C.isActive&&!A&&k||w>b&&k,L=!1;const F=Array.isArray(N)?N:[N];let _=F.reduce(r(v),{});E===!1&&(_={});const{prevResolvedValues:V={}}=C,Q={...V,..._},ne=U=>{D=!0,m.has(U)&&(L=!0,m.delete(U)),C.needsAnimating[U]=!0;const K=n.getValue(U);K&&(K.liveStyle=!1)};for(const U in Q){const K=_[U],X=V[U];if(y.hasOwnProperty(U))continue;let se=!1;cT(K)&&cT(X)?se=!bF(K,X):se=K!==X,se?K!=null?ne(U):m.add(U):K!==void 0&&m.has(U)?ne(U):C.protectedKeys[U]=!0}C.prevProp=N,C.prevResolvedValues=_,C.isActive&&(y={...y,..._}),s&&n.blockInitialAnimation&&(D=!1);const Z=A&&R;D&&(!Z||L)&&p.push(...F.map(U=>{const K={type:v};if(typeof U=="string"&&s&&!Z&&n.manuallyAnimateOnMount&&n.parent){const{parent:X}=n,se=$c(X,U);if(X.enteringChildren&&se){const{delayChildren:P}=se.transition||{};K.delay=yF(X.enteringChildren,n,P)}}return{animation:U,options:K}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const v=$c(n,Array.isArray(h.initial)?h.initial[0]:h.initial);v&&v.transition&&(w.transition=v.transition)}m.forEach(v=>{const C=n.getBaseTarget(v),N=n.getValue(v);N&&(N.liveStyle=!0),w[v]=C??null}),p.push({animation:w})}let x=!!p.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?e(p):Promise.resolve()}function o(l,h){if(t[l].isActive===h)return Promise.resolve();n.variantChildren?.forEach(p=>p.animationState?.setActive(l,h)),t[l].isActive=h;const d=a(l);for(const p in t)t[p].protectedKeys={};return d}return{animateChanges:a,setActive:o,setAnimateFunction:i,getState:()=>t,reset:()=>{t=sD()}}}function rq(n,e){return typeof e=="string"?e!==n:Array.isArray(e)?!bF(e,n):!1}function ml(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function sD(){return{animate:ml(!0),whileInView:ml(),whileHover:ml(),whileTap:ml(),whileDrag:ml(),whileFocus:ml(),exit:ml()}}class Po{constructor(e){this.isMounted=!1,this.node=e}update(){}}class iq extends Po{constructor(e){super(e),e.animationState||(e.animationState=sq(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();ub(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let aq=0;class oq extends Po{constructor(){super(...arguments),this.id=aq++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===s)return;const r=this.node.animationState.setActive("exit",!e);t&&!e&&r.then(()=>{t(this.id)})}mount(){const{register:e,onExitComplete:t}=this.node.presenceContext||{};t&&t(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const lq={animation:{Feature:iq},exit:{Feature:oq}};function Wf(n,e,t,s={passive:!0}){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t)}function wp(n){return{point:{x:n.pageX,y:n.pageY}}}const uq=n=>e=>XC(e)&&n(e,wp(e));function Df(n,e,t,s){return Wf(n,e,uq(t),s)}const wF=1e-4,cq=1-wF,hq=1+wF,vF=.01,dq=0-vF,fq=0+vF;function Es(n){return n.max-n.min}function pq(n,e,t){return Math.abs(n-e)<=t}function rD(n,e,t,s=.5){n.origin=s,n.originPoint=en(e.min,e.max,n.origin),n.scale=Es(t)/Es(e),n.translate=en(t.min,t.max,n.origin)-n.originPoint,(n.scale>=cq&&n.scale<=hq||isNaN(n.scale))&&(n.scale=1),(n.translate>=dq&&n.translate<=fq||isNaN(n.translate))&&(n.translate=0)}function Of(n,e,t,s){rD(n.x,e.x,t.x,s?s.originX:void 0),rD(n.y,e.y,t.y,s?s.originY:void 0)}function iD(n,e,t){n.min=t.min+e.min,n.max=n.min+Es(e)}function mq(n,e,t){iD(n.x,e.x,t.x),iD(n.y,e.y,t.y)}function aD(n,e,t){n.min=e.min-t.min,n.max=n.min+Es(e)}function w0(n,e,t){aD(n.x,e.x,t.x),aD(n.y,e.y,t.y)}function Pr(n){return[n("x"),n("y")]}const SF=({current:n})=>n?n.ownerDocument.defaultView:null,oD=(n,e)=>Math.abs(n-e);function gq(n,e){const t=oD(n.x,e.x),s=oD(n.y,e.y);return Math.sqrt(t**2+s**2)}class TF{constructor(e,t,{transformPagePoint:s,contextWindow:r=window,dragSnapToOrigin:i=!1,distanceThreshold:a=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=fS(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=gq(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=us;this.history.push({...x,timestamp:w});const{onStart:v,onMove:C}=this.handlers;y||(v&&v(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),C&&C(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=dS(y,this.transformPagePoint),Xt.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const v=fS(m.type==="pointercancel"?this.lastMoveEventInfo:dS(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,v),x&&x(m,v)},!XC(e))return;this.dragSnapToOrigin=i,this.handlers=t,this.transformPagePoint=s,this.distanceThreshold=a,this.contextWindow=r||window;const o=wp(e),l=dS(o,this.transformPagePoint),{point:h}=l,{timestamp:d}=us;this.history=[{...h,timestamp:d}];const{onSessionStart:p}=t;p&&p(e,fS(l,this.history)),this.removeListeners=yp(Df(this.contextWindow,"pointermove",this.handlePointerMove),Df(this.contextWindow,"pointerup",this.handlePointerUp),Df(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),ko(this.updatePoint)}}function dS(n,e){return e?{point:e(n.point)}:n}function lD(n,e){return{x:n.x-e.x,y:n.y-e.y}}function fS({point:n},e){return{point:n,delta:lD(n,CF(e)),offset:lD(n,yq(e)),velocity:bq(e,.1)}}function yq(n){return n[0]}function CF(n){return n[n.length-1]}function bq(n,e){if(n.length<2)return{x:0,y:0};let t=n.length-1,s=null;const r=CF(n);for(;t>=0&&(s=n[t],!(r.timestamp-s.timestamp>Li(e)));)t--;if(!s)return{x:0,y:0};const i=Ur(r.timestamp-s.timestamp);if(i===0)return{x:0,y:0};const a={x:(r.x-s.x)/i,y:(r.y-s.y)/i};return a.x===1/0&&(a.x=0),a.y===1/0&&(a.y=0),a}function xq(n,{min:e,max:t},s){return e!==void 0&&n<e?n=s?en(e,n,s.min):Math.max(n,e):t!==void 0&&n>t&&(n=s?en(t,n,s.max):Math.min(n,t)),n}function uD(n,e,t){return{min:e!==void 0?n.min+e:void 0,max:t!==void 0?n.max+t-(n.max-n.min):void 0}}function wq(n,{top:e,left:t,bottom:s,right:r}){return{x:uD(n.x,t,r),y:uD(n.y,e,s)}}function cD(n,e){let t=e.min-n.min,s=e.max-n.max;return e.max-e.min<n.max-n.min&&([t,s]=[s,t]),{min:t,max:s}}function vq(n,e){return{x:cD(n.x,e.x),y:cD(n.y,e.y)}}function Sq(n,e){let t=.5;const s=Es(n),r=Es(e);return r>s?t=Bf(e.min,e.max-s,n.min):s>r&&(t=Bf(n.min,n.max-r,e.min)),Sa(0,1,t)}function Tq(n,e){const t={};return e.min!==void 0&&(t.min=e.min-n.min),e.max!==void 0&&(t.max=e.max-n.min),t}const fT=.35;function Cq(n=fT){return n===!1?n=0:n===!0&&(n=fT),{x:hD(n,"left","right"),y:hD(n,"top","bottom")}}function hD(n,e,t){return{min:dD(n,e),max:dD(n,t)}}function dD(n,e){return typeof n=="number"?n:n[e]||0}const Nq=new WeakMap;class kq{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=On(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=e}start(e,{snapToCursor:t=!1,distanceThreshold:s}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const i=p=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),t&&this.snapToCursor(wp(p).point)},a=(p,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=AH(y),!this.openDragLock))return;this.latestPointerEvent=p,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Pr(v=>{let C=this.getAxisMotionValue(v).get()||0;if(Fi.test(C)){const{projection:N}=this.visualElement;if(N&&N.layout){const k=N.layout.layoutBox[v];k&&(C=Es(k)*(parseFloat(C)/100))}}this.originPoint[v]=C}),x&&Xt.postRender(()=>x(p,m)),hT(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},o=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:v}=m;if(b&&this.currentDirection===null){this.currentDirection=Eq(v),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,v),this.updateAxis("y",m.point,v),this.visualElement.render(),w&&w(p,m)},l=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m,this.stop(p,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>Pr(p=>this.getAnimationState(p)==="paused"&&this.getAxisMotionValue(p).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new TF(e,{onSessionStart:i,onStart:a,onMove:o,onSessionEnd:l,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:SF(this.visualElement)})}stop(e,t){const s=e||this.latestPointerEvent,r=t||this.latestPanInfo,i=this.isDragging;if(this.cancel(),!i||!r||!s)return;const{velocity:a}=r;this.startAnimation(a);const{onDragEnd:o}=this.getProps();o&&Xt.postRender(()=>o(s,r))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,s){const{drag:r}=this.getProps();if(!s||!$y(e,r,this.currentDirection))return;const i=this.getAxisMotionValue(e);let a=this.originPoint[e]+s[e];this.constraints&&this.constraints[e]&&(a=xq(a,this.constraints[e],this.elastic[e])),i.set(a)}resolveConstraints(){const{dragConstraints:e,dragElastic:t}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;e&&Cc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&s?this.constraints=wq(s.layoutBox,e):this.constraints=!1,this.elastic=Cq(t),r!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&Pr(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=Tq(s.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!Cc(e))return!1;const s=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const i=I6(s,r.root,this.visualElement.getTransformPagePoint());let a=vq(r.layout.layoutBox,i);if(t){const o=t(N6(a));this.hasMutatedConstraints=!!o,o&&(a=oF(o))}return a}startAnimation(e){const{drag:t,dragMomentum:s,dragElastic:r,dragTransition:i,dragSnapToOrigin:a,onDragTransitionEnd:o}=this.getProps(),l=this.constraints||{},h=Pr(d=>{if(!$y(d,t,this.currentDirection))return;let p=l&&l[d]||{};a&&(p={min:0,max:0});const m=r?200:1e6,y=r?40:1e7,b={type:"inertia",velocity:s?e[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...i,...p};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(o)}startAxisValueAnimation(e,t){const s=this.getAxisMotionValue(e);return hT(this.visualElement,e),s.start(i2(e,s,0,t,this.visualElement,!1))}stopAnimation(){Pr(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){Pr(e=>this.getAxisMotionValue(e).animation?.pause())}getAnimationState(e){return this.getAxisMotionValue(e).animation?.state}getAxisMotionValue(e){const t=`_drag${e.toUpperCase()}`,s=this.visualElement.getProps(),r=s[t];return r||this.visualElement.getValue(e,(s.initial?s.initial[e]:void 0)||0)}snapToCursor(e){Pr(t=>{const{drag:s}=this.getProps();if(!$y(t,s,this.currentDirection))return;const{projection:r}=this.visualElement,i=this.getAxisMotionValue(t);if(r&&r.layout){const{min:a,max:o}=r.layout.layoutBox[t];i.set(e[t]-en(a,o,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:s}=this.visualElement;if(!Cc(t)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};Pr(a=>{const o=this.getAxisMotionValue(a);if(o&&this.constraints!==!1){const l=o.get();r[a]=Sq({min:l,max:l},this.constraints[a])}});const{transformTemplate:i}=this.visualElement.getProps();this.visualElement.current.style.transform=i?i({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),Pr(a=>{if(!$y(a,e,null))return;const o=this.getAxisMotionValue(a),{min:l,max:h}=this.constraints[a];o.set(en(l,h,r[a]))})}addListeners(){if(!this.visualElement.current)return;Nq.set(this.visualElement,this);const e=this.visualElement.current,t=Df(e,"pointerdown",l=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(l)}),s=()=>{const{dragConstraints:l}=this.getProps();Cc(l)&&l.current&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,i=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),Xt.read(s);const a=Wf(window,"resize",()=>this.scalePositionWithinConstraints()),o=r.addEventListener("didUpdate",(({delta:l,hasLayoutChanged:h})=>{this.isDragging&&h&&(Pr(d=>{const p=this.getAxisMotionValue(d);p&&(this.originPoint[d]+=l[d].translate,p.set(p.get()+l[d].translate))}),this.visualElement.render())}));return()=>{a(),t(),i(),o&&o()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:i=!1,dragElastic:a=fT,dragMomentum:o=!0}=e;return{...e,drag:t,dragDirectionLock:s,dragPropagation:r,dragConstraints:i,dragElastic:a,dragMomentum:o}}}function $y(n,e,t){return(e===!0||e===n)&&(t===null||t===n)}function Eq(n,e=10){let t=null;return Math.abs(n.y)>e?t="y":Math.abs(n.x)>e&&(t="x"),t}class Iq extends Po{constructor(e){super(e),this.removeGroupControls=Gr,this.removeListeners=Gr,this.controls=new kq(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||Gr}unmount(){this.removeGroupControls(),this.removeListeners()}}const fD=n=>(e,t)=>{n&&Xt.postRender(()=>n(e,t))};class $q extends Po{constructor(){super(...arguments),this.removePointerDownListener=Gr}onPointerDown(e){this.session=new TF(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:SF(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:fD(e),onStart:fD(t),onMove:s,onEnd:(i,a)=>{delete this.session,r&&Xt.postRender(()=>r(i,a))}}}mount(){this.removePointerDownListener=Df(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const Zy={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let pS=!1;class _q extends Ce.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s,layoutId:r}=this.props,{projection:i}=e;i&&(t.group&&t.group.add(i),s&&s.register&&r&&s.register(i),pS&&i.root.didUpdate(),i.addEventListener("animationComplete",()=>{this.safeToRemove()}),i.setOptions({...i.options,onExitComplete:()=>this.safeToRemove()})),Zy.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:s,drag:r,isPresent:i}=this.props,{projection:a}=s;return a&&(a.isPresent=i,pS=!0,r||e.layoutDependency!==t||t===void 0||e.isPresent!==i?a.willUpdate():this.safeToRemove(),e.isPresent!==i&&(i?a.promote():a.relegate()||Xt.postRender(()=>{const o=a.getStack();(!o||!o.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),KC.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s}=this.props,{projection:r}=e;pS=!0,r&&(r.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function NF(n){const[e,t]=qL(),s=Ce.useContext(EC);return pe.jsx(_q,{...n,layoutGroup:s,switchLayoutGroup:Ce.useContext(iF),isPresent:e,safeToRemove:t})}function Aq(n,e,t){const s=ys(n)?n:Lc(n);return s.start(i2("",s,e,t)),s.animation}const Rq=(n,e)=>n.depth-e.depth;class Dq{constructor(){this.children=[],this.isDirty=!1}add(e){_C(this.children,e),this.isDirty=!0}remove(e){AC(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(Rq),this.isDirty=!1,this.children.forEach(e)}}function Oq(n,e){const t=Ks.now(),s=({timestamp:r})=>{const i=r-t;i>=e&&(ko(s),n(i-e))};return Xt.setup(s,!0),()=>ko(s)}const kF=["TopLeft","TopRight","BottomLeft","BottomRight"],Lq=kF.length,pD=n=>typeof n=="string"?parseFloat(n):n,mD=n=>typeof n=="number"||qe.test(n);function Fq(n,e,t,s,r,i){r?(n.opacity=en(0,t.opacity??1,Mq(s)),n.opacityExit=en(e.opacity??1,0,zq(s))):i&&(n.opacity=en(e.opacity??1,t.opacity??1,s));for(let a=0;a<Lq;a++){const o=`border${kF[a]}Radius`;let l=gD(e,o),h=gD(t,o);if(l===void 0&&h===void 0)continue;l||(l=0),h||(h=0),l===0||h===0||mD(l)===mD(h)?(n[o]=Math.max(en(pD(l),pD(h),s),0),(Fi.test(h)||Fi.test(l))&&(n[o]+="%")):n[o]=h}(e.rotate||t.rotate)&&(n.rotate=en(e.rotate||0,t.rotate||0,s))}function gD(n,e){return n[e]!==void 0?n[e]:n.borderRadius}const Mq=EF(0,.5,dL),zq=EF(.5,.95,Gr);function EF(n,e,t){return s=>s<n?0:s>e?1:t(Bf(n,e,s))}function yD(n,e){n.min=e.min,n.max=e.max}function ni(n,e){yD(n.x,e.x),yD(n.y,e.y)}function bD(n,e){n.translate=e.translate,n.scale=e.scale,n.originPoint=e.originPoint,n.origin=e.origin}function xD(n,e,t,s,r){return n-=e,n=x0(n,1/t,s),r!==void 0&&(n=x0(n,1/r,s)),n}function Pq(n,e=0,t=1,s=.5,r,i=n,a=n){if(Fi.test(e)&&(e=parseFloat(e),e=en(a.min,a.max,e/100)-a.min),typeof e!="number")return;let o=en(i.min,i.max,s);n===i&&(o-=e),n.min=xD(n.min,e,t,o,r),n.max=xD(n.max,e,t,o,r)}function wD(n,e,[t,s,r],i,a){Pq(n,e[t],e[s],e[r],e.scale,i,a)}const Bq=["x","scaleX","originX"],Vq=["y","scaleY","originY"];function vD(n,e,t,s){wD(n.x,e,Bq,t?t.x:void 0,s?s.x:void 0),wD(n.y,e,Vq,t?t.y:void 0,s?s.y:void 0)}function SD(n){return n.translate===0&&n.scale===1}function IF(n){return SD(n.x)&&SD(n.y)}function TD(n,e){return n.min===e.min&&n.max===e.max}function Uq(n,e){return TD(n.x,e.x)&&TD(n.y,e.y)}function CD(n,e){return Math.round(n.min)===Math.round(e.min)&&Math.round(n.max)===Math.round(e.max)}function $F(n,e){return CD(n.x,e.x)&&CD(n.y,e.y)}function ND(n){return Es(n.x)/Es(n.y)}function kD(n,e){return n.translate===e.translate&&n.scale===e.scale&&n.originPoint===e.originPoint}class jq{constructor(){this.members=[]}add(e){_C(this.members,e),e.scheduleRender()}remove(e){if(AC(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(e){const t=this.members.findIndex(r=>e===r);if(t===0)return!1;let s;for(let r=t;r>=0;r--){const i=this.members[r];if(i.isPresent!==!1){s=i;break}}return s?(this.promote(s),!0):!1}promote(e,t){const s=this.lead;if(e!==s&&(this.prevLead=s,this.lead=e,e.show(),s)){s.instance&&s.scheduleRender(),e.scheduleRender(),e.resumeFrom=s,t&&(e.resumeFrom.preserveOpacity=!0),s.snapshot&&(e.snapshot=s.snapshot,e.snapshot.latestValues=s.animationValues||s.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:t,resumingFrom:s}=e;t.onExitComplete&&t.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function Wq(n,e,t){let s="";const r=n.x.translate/e.x,i=n.y.translate/e.y,a=t?.z||0;if((r||i||a)&&(s=`translate3d(${r}px, ${i}px, ${a}px) `),(e.x!==1||e.y!==1)&&(s+=`scale(${1/e.x}, ${1/e.y}) `),t){const{transformPerspective:h,rotate:d,rotateX:p,rotateY:m,skewX:y,skewY:b}=t;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),p&&(s+=`rotateX(${p}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const o=n.x.scale*e.x,l=n.y.scale*e.y;return(o!==1||l!==1)&&(s+=`scale(${o}, ${l})`),s||"none"}const mS=["","X","Y","Z"],Gq=1e3;let Hq=0;function gS(n,e,t,s){const{latestValues:r}=e;r[n]&&(t[n]=r[n],e.setStaticValue(n,0),s&&(s[n]=0))}function _F(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:e}=n.options;if(!e)return;const t=mF(e);if(window.MotionHasOptimisedAnimation(t,"transform")){const{layout:r,layoutId:i}=n.options;window.MotionCancelOptimisedAnimation(t,"transform",Xt,!(r||i))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&_F(s)}function AF({attachResizeListener:n,defaultParent:e,measureScroll:t,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(a={},o=e?.()){this.id=Hq++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(Xq),this.nodes.forEach(Qq),this.nodes.forEach(e8),this.nodes.forEach(Yq)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=a,this.root=o?o.root||o:this,this.path=o?[...o.path,o]:[],this.parent=o,this.depth=o?o.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new Dq)}addEventListener(a,o){return this.eventHandlers.has(a)||this.eventHandlers.set(a,new OC),this.eventHandlers.get(a).add(o)}notifyListeners(a,...o){const l=this.eventHandlers.get(a);l&&l.notify(...o)}hasListeners(a){return this.eventHandlers.has(a)}mount(a){if(this.instance)return;this.isSVG=HL(a)&&!MH(a),this.instance=a;const{layoutId:o,layout:l,visualElement:h}=this.options;if(h&&!h.current&&h.mount(a),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(l||o)&&(this.isLayoutDirty=!0),n){let d,p=0;const m=()=>this.root.updateBlockedByResize=!1;Xt.read(()=>{p=window.innerWidth}),n(a,()=>{const y=window.innerWidth;y!==p&&(p=y,this.root.updateBlockedByResize=!0,d&&d(),d=Oq(m,250),Zy.hasAnimatedSinceResize&&(Zy.hasAnimatedSinceResize=!1,this.nodes.forEach($D)))})}o&&this.root.registerSharedNode(o,this),this.options.animate!==!1&&h&&(o||l)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:p,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||i8,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),v=!this.targetLayout||!$F(this.targetLayout,y),C=!p&&m;if(this.options.layoutRoot||this.resumeFrom||C||p&&(v||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const N={...HC(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(N.delay=0,N.type=!1),this.startAnimation(N),this.setAnimationOrigin(d,C)}else p||$D(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const a=this.getStack();a&&a.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),ko(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(t8),this.animationId++)}getTransformTemplate(){const{visualElement:a}=this.options;return a&&a.getProps().transformTemplate}willUpdate(a=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&_F(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const p=this.path[d];p.shouldResetTransform=!0,p.updateScroll("snapshot"),p.options.layoutRoot&&p.willUpdate(!1)}const{layoutId:o,layout:l}=this.options;if(o===void 0&&!l)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),a&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(ED);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(ID);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(Zq),this.nodes.forEach(qq),this.nodes.forEach(Kq)):this.nodes.forEach(ID),this.clearAllSnapshots();const o=Ks.now();us.delta=Sa(0,1e3/60,o-us.timestamp),us.timestamp=o,us.isProcessing=!0,rS.update.process(us),rS.preRender.process(us),rS.render.process(us),us.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,KC.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Jq),this.sharedNodes.forEach(n8)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,Xt.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){Xt.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!Es(this.snapshot.measuredBox.x)&&!Es(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const a=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=On(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:o}=this.options;o&&o.notify("LayoutMeasure",this.layout.layoutBox,a?a.layoutBox:void 0)}updateScroll(a="measure"){let o=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===a&&(o=!1),o&&this.instance){const l=s(this.instance);this.scroll={animationId:this.root.animationId,phase:a,isRoot:l,offset:t(this.instance),wasRoot:this.scroll?this.scroll.isRoot:l}}}resetTransform(){if(!r)return;const a=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,o=this.projectionDelta&&!IF(this.projectionDelta),l=this.getTransformTemplate(),h=l?l(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;a&&this.instance&&(o||vl(this.latestValues)||d)&&(r(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(a=!0){const o=this.measurePageBox();let l=this.removeElementScroll(o);return a&&(l=this.removeTransform(l)),a8(l),{animationId:this.root.animationId,measuredBox:o,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:a}=this.options;if(!a)return On();const o=a.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(o8))){const{scroll:h}=this.root;h&&(Nc(o.x,h.offset.x),Nc(o.y,h.offset.y))}return o}removeElementScroll(a){const o=On();if(ni(o,a),this.scroll?.wasRoot)return o;for(let l=0;l<this.path.length;l++){const h=this.path[l],{scroll:d,options:p}=h;h!==this.root&&d&&p.layoutScroll&&(d.wasRoot&&ni(o,a),Nc(o.x,d.offset.x),Nc(o.y,d.offset.y))}return o}applyTransform(a,o=!1){const l=On();ni(l,a);for(let h=0;h<this.path.length;h++){const d=this.path[h];!o&&d.options.layoutScroll&&d.scroll&&d!==d.root&&kc(l,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),vl(d.latestValues)&&kc(l,d.latestValues)}return vl(this.latestValues)&&kc(l,this.latestValues),l}removeTransform(a){const o=On();ni(o,a);for(let l=0;l<this.path.length;l++){const h=this.path[l];if(!h.instance||!vl(h.latestValues))continue;oT(h.latestValues)&&h.updateSnapshot();const d=On(),p=h.measurePageBox();ni(d,p),vD(o,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return vl(this.latestValues)&&vD(o,this.latestValues),o}setTargetDelta(a){this.targetDelta=a,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(a){this.options={...this.options,...a,crossfade:a.crossfade!==void 0?a.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==us.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(a=!1){const o=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=o.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=o.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=o.isSharedProjectionDirty);const l=!!this.resumingFrom||this!==o;if(!(a||l&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:p}=this.options;if(!this.layout||!(d||p))return;this.resolvedRelativeTargetAt=us.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=On(),this.targetWithTransforms=On()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),mq(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):ni(this.target,this.layout.layoutBox),uF(this.target,this.targetDelta)):ni(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||oT(this.parent.latestValues)||lF(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(a,o,l){this.relativeParent=a,this.linkedParentVersion=a.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=On(),this.relativeTargetOrigin=On(),w0(this.relativeTargetOrigin,o,l),ni(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const a=this.getLead(),o=!!this.resumingFrom||this!==a;let l=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(l=!1),o&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(l=!1),this.resolvedRelativeTargetAt===us.timestamp&&(l=!1),l)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;ni(this.layoutCorrected,this.layout.layoutBox);const p=this.treeScale.x,m=this.treeScale.y;E6(this.layoutCorrected,this.treeScale,this.path,o),a.layout&&!a.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(a.target=a.layout.layoutBox,a.targetWithTransforms=On());const{target:y}=a;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(bD(this.prevProjectionDelta.x,this.projectionDelta.x),bD(this.prevProjectionDelta.y,this.projectionDelta.y)),Of(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==p||this.treeScale.y!==m||!kD(this.projectionDelta.x,this.prevProjectionDelta.x)||!kD(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(a=!0){if(this.options.visualElement?.scheduleRender(),a){const o=this.getStack();o&&o.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=Ec(),this.projectionDelta=Ec(),this.projectionDeltaWithTransform=Ec()}setAnimationOrigin(a,o=!1){const l=this.snapshot,h=l?l.latestValues:{},d={...this.latestValues},p=Ec();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!o;const m=On(),y=l?l.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),v=!w||w.members.length<=1,C=!!(x&&!v&&this.options.crossfade===!0&&!this.path.some(r8));this.animationProgress=0;let N;this.mixTargetDelta=k=>{const E=k/1e3;_D(p.x,a.x,E),_D(p.y,a.y,E),this.setTargetDelta(p),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(w0(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),s8(this.relativeTarget,this.relativeTargetOrigin,m,E),N&&Uq(this.relativeTarget,N)&&(this.isProjectionDirty=!1),N||(N=On()),ni(N,this.relativeTarget)),x&&(this.animationValues=d,Fq(d,h,this.latestValues,E,C,v)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(a){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(ko(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=Xt.update(()=>{Zy.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Lc(0)),this.currentAnimation=Aq(this.motionValue,[0,1e3],{...a,velocity:0,isSync:!0,onUpdate:o=>{this.mixTargetDelta(o),a.onUpdate&&a.onUpdate(o)},onStop:()=>{},onComplete:()=>{a.onComplete&&a.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const a=this.getStack();a&&a.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(Gq),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const a=this.getLead();let{targetWithTransforms:o,target:l,layout:h,latestValues:d}=a;if(!(!o||!l||!h)){if(this!==a&&this.layout&&h&&RF(this.options.animationType,this.layout.layoutBox,h.layoutBox)){l=this.target||On();const p=Es(this.layout.layoutBox.x);l.x.min=a.target.x.min,l.x.max=l.x.min+p;const m=Es(this.layout.layoutBox.y);l.y.min=a.target.y.min,l.y.max=l.y.min+m}ni(o,l),kc(o,d),Of(this.projectionDeltaWithTransform,this.layoutCorrected,o,d)}}registerSharedNode(a,o){this.sharedNodes.has(a)||this.sharedNodes.set(a,new jq),this.sharedNodes.get(a).add(o);const h=o.options.initialPromotionConfig;o.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(o):void 0})}isLead(){const a=this.getStack();return a?a.lead===this:!0}getLead(){const{layoutId:a}=this.options;return a?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:a}=this.options;return a?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:a}=this.options;if(a)return this.root.sharedNodes.get(a)}promote({needsReset:a,transition:o,preserveFollowOpacity:l}={}){const h=this.getStack();h&&h.promote(this,l),a&&(this.projectionDelta=void 0,this.needsReset=!0),o&&this.setOptions({transition:o})}relegate(){const a=this.getStack();return a?a.relegate(this):!1}resetSkewAndRotation(){const{visualElement:a}=this.options;if(!a)return;let o=!1;const{latestValues:l}=a;if((l.z||l.rotate||l.rotateX||l.rotateY||l.rotateZ||l.skewX||l.skewY)&&(o=!0),!o)return;const h={};l.z&&gS("z",a,h,this.animationValues);for(let d=0;d<mS.length;d++)gS(`rotate${mS[d]}`,a,h,this.animationValues),gS(`skew${mS[d]}`,a,h,this.animationValues);a.render();for(const d in h)a.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);a.scheduleRender()}applyProjectionStyles(a,o){if(!this.instance||this.isSVG)return;if(!this.isVisible){a.visibility="hidden";return}const l=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,a.visibility="",a.opacity="",a.pointerEvents=Jy(o?.pointerEvents)||"",a.transform=l?l(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(a.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,a.pointerEvents=Jy(o?.pointerEvents)||""),this.hasProjected&&!vl(this.latestValues)&&(a.transform=l?l({},""):"none",this.hasProjected=!1);return}a.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let p=Wq(this.projectionDeltaWithTransform,this.treeScale,d);l&&(p=l(d,p)),a.transform=p;const{x:m,y}=this.projectionDelta;a.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?a.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:a.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in aT){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:v}=aT[b],C=p==="none"?d[b]:x(d[b],h);if(w){const N=w.length;for(let k=0;k<N;k++)a[w[k]]=C}else v?this.options.visualElement.renderState.vars[b]=C:a[b]=C}this.options.layoutId&&(a.pointerEvents=h===this?Jy(o?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(a=>a.currentAnimation?.stop()),this.root.nodes.forEach(ED),this.root.sharedNodes.clear()}}}function qq(n){n.updateLayout()}function Kq(n){const e=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&e&&n.hasListeners("didUpdate")){const{layoutBox:t,measuredBox:s}=n.layout,{animationType:r}=n.options,i=e.source!==n.layout.source;r==="size"?Pr(d=>{const p=i?e.measuredBox[d]:e.layoutBox[d],m=Es(p);p.min=t[d].min,p.max=p.min+m}):RF(r,e.layoutBox,t)&&Pr(d=>{const p=i?e.measuredBox[d]:e.layoutBox[d],m=Es(t[d]);p.max=p.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const a=Ec();Of(a,t,e.layoutBox);const o=Ec();i?Of(o,n.applyTransform(s,!0),e.measuredBox):Of(o,t,e.layoutBox);const l=!IF(a);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:p,layout:m}=d;if(p&&m){const y=On();w0(y,e.layoutBox,p.layoutBox);const b=On();w0(b,t,m.layoutBox),$F(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:t,snapshot:e,delta:o,layoutDelta:a,hasLayoutChanged:l,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:t}=n.options;t&&t()}n.options.transition=void 0}function Xq(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Yq(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Jq(n){n.clearSnapshot()}function ED(n){n.clearMeasurements()}function ID(n){n.isLayoutDirty=!1}function Zq(n){const{visualElement:e}=n.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),n.resetTransform()}function $D(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function Qq(n){n.resolveTargetDelta()}function e8(n){n.calcProjection()}function t8(n){n.resetSkewAndRotation()}function n8(n){n.removeLeadSnapshot()}function _D(n,e,t){n.translate=en(e.translate,0,t),n.scale=en(e.scale,1,t),n.origin=e.origin,n.originPoint=e.originPoint}function AD(n,e,t,s){n.min=en(e.min,t.min,s),n.max=en(e.max,t.max,s)}function s8(n,e,t,s){AD(n.x,e.x,t.x,s),AD(n.y,e.y,t.y,s)}function r8(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const i8={duration:.45,ease:[.4,0,.1,1]},RD=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),DD=RD("applewebkit/")&&!RD("chrome/")?Math.round:Gr;function OD(n){n.min=DD(n.min),n.max=DD(n.max)}function a8(n){OD(n.x),OD(n.y)}function RF(n,e,t){return n==="position"||n==="preserve-aspect"&&!pq(ND(e),ND(t),.2)}function o8(n){return n!==n.root&&n.scroll?.wasRoot}const l8=AF({attachResizeListener:(n,e)=>Wf(n,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),yS={current:void 0},DF=AF({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!yS.current){const n=new l8({});n.mount(window),n.setOptions({layoutScroll:!0}),yS.current=n}return yS.current},resetTransform:(n,e)=>{n.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),u8={pan:{Feature:$q},drag:{Feature:Iq,ProjectionNode:DF,MeasureLayout:NF}};function LD(n,e,t){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",t==="Start");const r="onHover"+t,i=s[r];i&&Xt.postRender(()=>i(e,wp(e)))}class c8 extends Po{mount(){const{current:e}=this.node;e&&(this.unmount=RH(e,(t,s)=>(LD(this.node,s,"Start"),r=>LD(this.node,r,"End"))))}unmount(){}}class h8 extends Po{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=yp(Wf(this.node.current,"focus",()=>this.onFocus()),Wf(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function FD(n,e,t){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",t==="Start");const r="onTap"+(t==="End"?"":t),i=s[r];i&&Xt.postRender(()=>i(e,wp(e)))}class d8 extends Po{mount(){const{current:e}=this.node;e&&(this.unmount=FH(e,(t,s)=>(FD(this.node,s,"Start"),(r,{success:i})=>FD(this.node,r,i?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const pT=new WeakMap,bS=new WeakMap,f8=n=>{const e=pT.get(n.target);e&&e(n)},p8=n=>{n.forEach(f8)};function m8({root:n,...e}){const t=n||document;bS.has(t)||bS.set(t,{});const s=bS.get(t),r=JSON.stringify(e);return s[r]||(s[r]=new IntersectionObserver(p8,{root:n,...e})),s[r]}function g8(n,e,t){const s=m8(e);return pT.set(n,t),s.observe(n),()=>{pT.delete(n),s.unobserve(n)}}const y8={some:0,all:1};class b8 extends Po{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:s,amount:r="some",once:i}=e,a={root:t?t.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:y8[r]},o=l=>{const{isIntersecting:h}=l;if(this.isInView===h||(this.isInView=h,i&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:p}=this.node.getProps(),m=h?d:p;m&&m(l)};return g8(this.node.current,a,o)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(x8(e,t))&&this.startObserver()}unmount(){}}function x8({viewport:n={}},{viewport:e={}}={}){return t=>n[t]!==e[t]}const w8={inView:{Feature:b8},tap:{Feature:d8},focus:{Feature:h8},hover:{Feature:c8}},v8={layout:{ProjectionNode:DF,MeasureLayout:NF}},S8={...lq,...w8,...u8,...v8},gl=C6(S8,M6);const T8=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),C8=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,s)=>s?s.toUpperCase():t.toLowerCase()),MD=n=>{const e=C8(n);return e.charAt(0).toUpperCase()+e.slice(1)},OF=(...n)=>n.filter((e,t,s)=>!!e&&e.trim()!==""&&s.indexOf(e)===t).join(" ").trim(),N8=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var k8={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const E8=Ce.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:t=2,absoluteStrokeWidth:s,className:r="",children:i,iconNode:a,...o},l)=>Ce.createElement("svg",{ref:l,...k8,width:e,height:e,stroke:n,strokeWidth:s?Number(t)*24/Number(e):t,className:OF("lucide",r),...!i&&!N8(o)&&{"aria-hidden":"true"},...o},[...a.map(([h,d])=>Ce.createElement(h,d)),...Array.isArray(i)?i:[i]]));const er=(n,e)=>{const t=Ce.forwardRef(({className:s,...r},i)=>Ce.createElement(E8,{ref:i,iconNode:e,className:OF(`lucide-${T8(MD(n))}`,`lucide-${n}`,s),...r}));return t.displayName=MD(n),t};const I8=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],$8=er("activity",I8);const _8=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],A8=er("circle-check",_8);const R8=[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]],D8=er("copy",R8);const O8=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],L8=er("cpu",O8);const F8=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],zD=er("history",F8);const M8=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],z8=er("lock",M8);const P8=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],B8=er("log-out",P8);const V8=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],U8=er("search",V8);const j8=[["circle",{cx:"18",cy:"5",r:"3",key:"gq8acd"}],["circle",{cx:"6",cy:"12",r:"3",key:"w7nqdw"}],["circle",{cx:"18",cy:"19",r:"3",key:"1xt0gg"}],["line",{x1:"8.59",x2:"15.42",y1:"13.51",y2:"17.49",key:"47mynk"}],["line",{x1:"15.41",x2:"8.59",y1:"6.51",y2:"10.49",key:"1n3mei"}]],W8=er("share-2",j8);const G8=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],PD=er("trending-down",G8);const H8=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],BD=er("trending-up",H8);const q8=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],K8=er("triangle-alert",q8);const X8=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],Y8=er("trophy",X8);const J8=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],VD=er("zap",J8);function hb(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t}function Z8(n,e,t,s){function r(i){return i instanceof t?i:new t(function(a){a(i)})}return new(t||(t=Promise))(function(i,a){function o(d){try{h(s.next(d))}catch(p){a(p)}}function l(d){try{h(s.throw(d))}catch(p){a(p)}}function h(d){d.done?i(d.value):r(d.value).then(o,l)}h((s=s.apply(n,e||[])).next())})}const Q8=n=>n?(...e)=>n(...e):(...e)=>fetch(...e);class a2 extends Error{constructor(e,t="FunctionsError",s){super(e),this.name=t,this.context=s}}class eK extends a2{constructor(e){super("Failed to send a request to the Edge Function","FunctionsFetchError",e)}}class UD extends a2{constructor(e){super("Relay Error invoking the Edge Function","FunctionsRelayError",e)}}class jD extends a2{constructor(e){super("Edge Function returned a non-2xx status code","FunctionsHttpError",e)}}var mT;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(mT||(mT={}));class tK{constructor(e,{headers:t={},customFetch:s,region:r=mT.Any}={}){this.url=e,this.headers=t,this.region=r,this.fetch=Q8(s)}setAuth(e){this.headers.Authorization=`Bearer ${e}`}invoke(e){return Z8(this,arguments,void 0,function*(t,s={}){var r;let i,a;try{const{headers:o,method:l,body:h,signal:d,timeout:p}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${t}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(o&&!Object.prototype.hasOwnProperty.call(o,"Content-Type")||!o)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;p&&(a=new AbortController,i=setTimeout(()=>a.abort(),p),d?(w=a.signal,d.addEventListener("abort",()=>a.abort())):w=a.signal);const v=yield this.fetch(b.toString(),{method:l||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),o),body:x,signal:w}).catch(E=>{throw new eK(E)}),C=v.headers.get("x-relay-error");if(C&&C==="true")throw new UD(v);if(!v.ok)throw new jD(v);let N=((r=v.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),k;return N==="application/json"?k=yield v.json():N==="application/octet-stream"||N==="application/pdf"?k=yield v.blob():N==="text/event-stream"?k=v:N==="multipart/form-data"?k=yield v.formData():k=yield v.text(),{data:k,error:null,response:v}}catch(o){return{data:null,error:o,response:o instanceof jD||o instanceof UD?o.context:void 0}}finally{i&&clearTimeout(i)}})}}var nK=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},sK=class{constructor(n){var e,t;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(e=n.shouldThrowOnError)!==null&&e!==void 0?e:!1,this.signal=n.signal,this.isMaybeSingle=(t=n.isMaybeSingle)!==null&&t!==void 0?t:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,e){return this.headers=new Headers(this.headers),this.headers.set(n,e),this}then(n,e){var t=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let r=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async i=>{let a=null,o=null,l=null,h=i.status,d=i.statusText;if(i.ok){var p,m;if(t.method!=="HEAD"){var y;const v=await i.text();v===""||(t.headers.get("Accept")==="text/csv"||t.headers.get("Accept")&&(!((y=t.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?o=v:o=JSON.parse(v))}const x=(p=t.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),w=(m=i.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(l=parseInt(w[1])),t.isMaybeSingle&&t.method==="GET"&&Array.isArray(o)&&(o.length>1?(a={code:"PGRST116",details:`Results contain ${o.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},o=null,l=null,h=406,d="Not Acceptable"):o.length===1?o=o[0]:o=null)}else{var b;const x=await i.text();try{a=JSON.parse(x),Array.isArray(a)&&i.status===404&&(o=[],a=null,h=200,d="OK")}catch{i.status===404&&x===""?(h=204,d="No Content"):a={message:x}}if(a&&t.isMaybeSingle&&(!(a==null||(b=a.details)===null||b===void 0)&&b.includes("0 rows"))&&(a=null,h=200,d="OK"),a&&t.shouldThrowOnError)throw new nK(a)}return{error:a,data:o,count:l,status:h,statusText:d}});return this.shouldThrowOnError||(r=r.catch(i=>{var a;let o="";const l=i?.cause;if(l){var h,d,p,m;const b=(h=l?.message)!==null&&h!==void 0?h:"",x=(d=l?.code)!==null&&d!==void 0?d:"";o=`${(p=i?.name)!==null&&p!==void 0?p:"FetchError"}: ${i?.message}`,o+=`

Caused by: ${(m=l?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(o+=` (${x})`),l?.stack&&(o+=`
${l.stack}`)}else{var y;o=(y=i?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(a=i?.name)!==null&&a!==void 0?a:"FetchError"}: ${i?.message}`,details:o,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(n,e)}returns(){return this}overrideTypes(){return this}},rK=class extends sK{select(n){let e=!1;const t=(n??"*").split("").map(s=>/\s/.test(s)&&!e?"":(s==='"'&&(e=!e),s)).join("");return this.url.searchParams.set("select",t),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:e=!0,nullsFirst:t,foreignTable:s,referencedTable:r=s}={}){const i=r?`${r}.order`:"order",a=this.url.searchParams.get(i);return this.url.searchParams.set(i,`${a?`${a},`:""}${n}.${e?"asc":"desc"}${t===void 0?"":t?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:e,referencedTable:t=e}={}){const s=typeof t>"u"?"limit":`${t}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,e,{foreignTable:t,referencedTable:s=t}={}){const r=typeof s>"u"?"offset":`${s}.offset`,i=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(r,`${n}`),this.url.searchParams.set(i,`${e-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:e=!1,settings:t=!1,buffers:s=!1,wal:r=!1,format:i="text"}={}){var a;const o=[n?"analyze":null,e?"verbose":null,t?"settings":null,s?"buffers":null,r?"wal":null].filter(Boolean).join("|"),l=(a=this.headers.get("Accept"))!==null&&a!==void 0?a:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${i}; for="${l}"; options=${o};`),i==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const WD=new RegExp("[,()]");var bc=class extends rK{eq(n,e){return this.url.searchParams.append(n,`eq.${e}`),this}neq(n,e){return this.url.searchParams.append(n,`neq.${e}`),this}gt(n,e){return this.url.searchParams.append(n,`gt.${e}`),this}gte(n,e){return this.url.searchParams.append(n,`gte.${e}`),this}lt(n,e){return this.url.searchParams.append(n,`lt.${e}`),this}lte(n,e){return this.url.searchParams.append(n,`lte.${e}`),this}like(n,e){return this.url.searchParams.append(n,`like.${e}`),this}likeAllOf(n,e){return this.url.searchParams.append(n,`like(all).{${e.join(",")}}`),this}likeAnyOf(n,e){return this.url.searchParams.append(n,`like(any).{${e.join(",")}}`),this}ilike(n,e){return this.url.searchParams.append(n,`ilike.${e}`),this}ilikeAllOf(n,e){return this.url.searchParams.append(n,`ilike(all).{${e.join(",")}}`),this}ilikeAnyOf(n,e){return this.url.searchParams.append(n,`ilike(any).{${e.join(",")}}`),this}regexMatch(n,e){return this.url.searchParams.append(n,`match.${e}`),this}regexIMatch(n,e){return this.url.searchParams.append(n,`imatch.${e}`),this}is(n,e){return this.url.searchParams.append(n,`is.${e}`),this}isDistinct(n,e){return this.url.searchParams.append(n,`isdistinct.${e}`),this}in(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&WD.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${t})`),this}notIn(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&WD.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${t})`),this}contains(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cs.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cs.{${e.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(e)}`),this}containedBy(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cd.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cd.{${e.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(e)}`),this}rangeGt(n,e){return this.url.searchParams.append(n,`sr.${e}`),this}rangeGte(n,e){return this.url.searchParams.append(n,`nxl.${e}`),this}rangeLt(n,e){return this.url.searchParams.append(n,`sl.${e}`),this}rangeLte(n,e){return this.url.searchParams.append(n,`nxr.${e}`),this}rangeAdjacent(n,e){return this.url.searchParams.append(n,`adj.${e}`),this}overlaps(n,e){return typeof e=="string"?this.url.searchParams.append(n,`ov.${e}`):this.url.searchParams.append(n,`ov.{${e.join(",")}}`),this}textSearch(n,e,{config:t,type:s}={}){let r="";s==="plain"?r="pl":s==="phrase"?r="ph":s==="websearch"&&(r="w");const i=t===void 0?"":`(${t})`;return this.url.searchParams.append(n,`${r}fts${i}.${e}`),this}match(n){return Object.entries(n).forEach(([e,t])=>{this.url.searchParams.append(e,`eq.${t}`)}),this}not(n,e,t){return this.url.searchParams.append(n,`not.${e}.${t}`),this}or(n,{foreignTable:e,referencedTable:t=e}={}){const s=t?`${t}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,e,t){return this.url.searchParams.append(n,`${e}.${t}`),this}},iK=class{constructor(n,{headers:e={},schema:t,fetch:s}){this.url=n,this.headers=new Headers(e),this.schema=t,this.fetch=s}select(n,e){const{head:t=!1,count:s}=e??{},r=t?"HEAD":"GET";let i=!1;const a=(n??"*").split("").map(o=>/\s/.test(o)&&!i?"":(o==='"'&&(i=!i),o)).join("");return this.url.searchParams.set("select",a),s&&this.headers.append("Prefer",`count=${s}`),new bc({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:e,defaultToNull:t=!0}={}){var s;const r="POST";if(e&&this.headers.append("Prefer",`count=${e}`),t||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const i=n.reduce((a,o)=>a.concat(Object.keys(o)),[]);if(i.length>0){const a=[...new Set(i)].map(o=>`"${o}"`);this.url.searchParams.set("columns",a.join(","))}}return new bc({method:r,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:e,ignoreDuplicates:t=!1,count:s,defaultToNull:r=!0}={}){var i;const a="POST";if(this.headers.append("Prefer",`resolution=${t?"ignore":"merge"}-duplicates`),e!==void 0&&this.url.searchParams.set("on_conflict",e),s&&this.headers.append("Prefer",`count=${s}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const o=n.reduce((l,h)=>l.concat(Object.keys(h)),[]);if(o.length>0){const l=[...new Set(o)].map(h=>`"${h}"`);this.url.searchParams.set("columns",l.join(","))}}return new bc({method:a,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}update(n,{count:e}={}){var t;const s="PATCH";return e&&this.headers.append("Prefer",`count=${e}`),new bc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}delete({count:n}={}){var e;const t="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new bc({method:t,url:this.url,headers:this.headers,schema:this.schema,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}},aK=class LF{constructor(e,{headers:t={},schema:s,fetch:r}={}){this.url=e,this.headers=new Headers(t),this.schemaName=s,this.fetch=r}from(e){if(!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new iK(new URL(`${this.url}/${e}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(e){return new LF(this.url,{headers:this.headers,schema:e,fetch:this.fetch})}rpc(e,t={},{head:s=!1,get:r=!1,count:i}={}){var a;let o;const l=new URL(`${this.url}/rpc/${e}`);let h;s||r?(o=s?"HEAD":"GET",Object.entries(t).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{l.searchParams.append(p,m)})):(o="POST",h=t);const d=new Headers(this.headers);return i&&d.set("Prefer",`count=${i}`),new bc({method:o,url:l,headers:d,schema:this.schemaName,body:h,fetch:(a=this.fetch)!==null&&a!==void 0?a:fetch})}};class oK{constructor(){}static detectEnvironment(){var e;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((e=navigator.userAgent)===null||e===void 0)&&e.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const t=process.versions;if(t&&t.node){const s=t.node,r=parseInt(s.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const e=this.detectEnvironment();if(e.constructor)return e.constructor;let t=e.error||"WebSocket not supported in this environment.";throw e.workaround&&(t+=`

Suggested solution: ${e.workaround}`),new Error(t)}static createWebSocket(e,t){const s=this.getWebSocketConstructor();return new s(e,t)}static isWebSocketSupported(){try{const e=this.detectEnvironment();return e.type==="native"||e.type==="ws"}catch{return!1}}}const lK="2.89.0",uK=`realtime-js/${lK}`,FF="1.0.0",cK="2.0.0",GD=FF,gT=1e4,hK=1e3,dK=100;var mo;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(mo||(mo={}));var Dn;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(Dn||(Dn={}));var ui;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(ui||(ui={}));var yT;(function(n){n.websocket="websocket"})(yT||(yT={}));var Nl;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(Nl||(Nl={}));class fK{constructor(e){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=e??[]}encode(e,t){if(e.event===this.BROADCAST_EVENT&&!(e.payload instanceof ArrayBuffer)&&typeof e.payload.event=="string")return t(this._binaryEncodeUserBroadcastPush(e));let s=[e.join_ref,e.ref,e.topic,e.event,e.payload];return t(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(e){var t;return this._isArrayBuffer((t=e.payload)===null||t===void 0?void 0:t.payload)?this._encodeBinaryUserBroadcastPush(e):this._encodeJsonUserBroadcastPush(e)}_encodeBinaryUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(e,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:{},a=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(e,this.JSON_ENCODING,a)}_encodeUserBroadcastPush(e,t,s){var r,i;const a=e.topic,o=(r=e.ref)!==null&&r!==void 0?r:"",l=(i=e.join_ref)!==null&&i!==void 0?i:"",h=e.payload.event,d=this.allowedMetadataKeys?this._pick(e.payload,this.allowedMetadataKeys):{},p=Object.keys(d).length===0?"":JSON.stringify(d);if(l.length>255)throw new Error(`joinRef length ${l.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`ref length ${o.length} exceeds maximum of 255`);if(a.length>255)throw new Error(`topic length ${a.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+l.length+o.length+a.length+h.length+p.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,l.length),b.setUint8(x++,o.length),b.setUint8(x++,a.length),b.setUint8(x++,h.length),b.setUint8(x++,p.length),b.setUint8(x++,t),Array.from(l,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(o,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(a,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(h,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(p,v=>b.setUint8(x++,v.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(e,t){if(this._isArrayBuffer(e)){let s=this._binaryDecode(e);return t(s)}if(typeof e=="string"){const s=JSON.parse(e),[r,i,a,o,l]=s;return t({join_ref:r,ref:i,topic:a,event:o,payload:l})}return t({})}_binaryDecode(e){const t=new DataView(e),s=t.getUint8(0),r=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(e,t,r)}_decodeUserBroadcast(e,t,s){const r=t.getUint8(1),i=t.getUint8(2),a=t.getUint8(3),o=t.getUint8(4);let l=this.HEADER_LENGTH+4;const h=s.decode(e.slice(l,l+r));l=l+r;const d=s.decode(e.slice(l,l+i));l=l+i;const p=s.decode(e.slice(l,l+a));l=l+a;const m=e.slice(l,e.byteLength),y=o===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return a>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(e){var t;return e instanceof ArrayBuffer||((t=e?.constructor)===null||t===void 0?void 0:t.name)==="ArrayBuffer"}_pick(e,t){return!e||typeof e!="object"?{}:Object.fromEntries(Object.entries(e).filter(([s])=>t.includes(s)))}}class MF{constructor(e,t){this.callback=e,this.timerCalc=t,this.timer=void 0,this.tries=0,this.callback=e,this.timerCalc=t}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Bt;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Bt||(Bt={}));const HD=(n,e,t={})=>{var s;const r=(s=t.skipTypes)!==null&&s!==void 0?s:[];return e?Object.keys(e).reduce((i,a)=>(i[a]=pK(a,n,e,r),i),{}):{}},pK=(n,e,t,s)=>{const r=e.find(o=>o.name===n),i=r?.type,a=t[n];return i&&!s.includes(i)?zF(i,a):bT(a)},zF=(n,e)=>{if(n.charAt(0)==="_"){const t=n.slice(1,n.length);return bK(e,t)}switch(n){case Bt.bool:return mK(e);case Bt.float4:case Bt.float8:case Bt.int2:case Bt.int4:case Bt.int8:case Bt.numeric:case Bt.oid:return gK(e);case Bt.json:case Bt.jsonb:return yK(e);case Bt.timestamp:return xK(e);case Bt.abstime:case Bt.date:case Bt.daterange:case Bt.int4range:case Bt.int8range:case Bt.money:case Bt.reltime:case Bt.text:case Bt.time:case Bt.timestamptz:case Bt.timetz:case Bt.tsrange:case Bt.tstzrange:return bT(e);default:return bT(e)}},bT=n=>n,mK=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},gK=n=>{if(typeof n=="string"){const e=parseFloat(n);if(!Number.isNaN(e))return e}return n},yK=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},bK=(n,e)=>{if(typeof n!="string")return n;const t=n.length-1,s=n[t];if(n[0]==="{"&&s==="}"){let i;const a=n.slice(1,t);try{i=JSON.parse("["+a+"]")}catch{i=a?a.split(","):[]}return i.map(o=>zF(e,o))}return n},xK=n=>typeof n=="string"?n.replace(" ","T"):n,PF=n=>{const e=new URL(n);return e.protocol=e.protocol.replace(/^ws/i,"http"),e.pathname=e.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),e.pathname===""||e.pathname==="/"?e.pathname="/api/broadcast":e.pathname=e.pathname+"/api/broadcast",e.href};class xS{constructor(e,t,s={},r=gT){this.channel=e,this.event=t,this.payload=s,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(e){this.timeout=e,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(e){this.payload=Object.assign(Object.assign({},this.payload),e)}receive(e,t){var s;return this._hasReceived(e)&&t((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:e,callback:t}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const e=t=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=t,this._matchReceive(t)};this.channel._on(this.refEvent,{},e),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(e,t){this.refEvent&&this.channel._trigger(this.refEvent,{status:e,response:t})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:e,response:t}){this.recHooks.filter(s=>s.status===e).forEach(s=>s.callback(t))}_hasReceived(e){return this.receivedResp&&this.receivedResp.status===e}}var qD;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(qD||(qD={}));class Lf{constructor(e,t){this.channel=e,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=t?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},r=>{const{onJoin:i,onLeave:a,onSync:o}=this.caller;this.joinRef=this.channel._joinRef(),this.state=Lf.syncState(this.state,r,i,a),this.pendingDiffs.forEach(l=>{this.state=Lf.syncDiff(this.state,l,i,a)}),this.pendingDiffs=[],o()}),this.channel._on(s.diff,{},r=>{const{onJoin:i,onLeave:a,onSync:o}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=Lf.syncDiff(this.state,r,i,a),o())}),this.onJoin((r,i,a)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:i,newPresences:a})}),this.onLeave((r,i,a)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:i,leftPresences:a})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(e,t,s,r){const i=this.cloneDeep(e),a=this.transformState(t),o={},l={};return this.map(i,(h,d)=>{a[h]||(l[h]=d)}),this.map(a,(h,d)=>{const p=i[h];if(p){const m=d.map(w=>w.presence_ref),y=p.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=p.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(o[h]=b),x.length>0&&(l[h]=x)}else o[h]=d}),this.syncDiff(i,{joins:o,leaves:l},s,r)}static syncDiff(e,t,s,r){const{joins:i,leaves:a}={joins:this.transformState(t.joins),leaves:this.transformState(t.leaves)};return s||(s=()=>{}),r||(r=()=>{}),this.map(i,(o,l)=>{var h;const d=(h=e[o])!==null&&h!==void 0?h:[];if(e[o]=this.cloneDeep(l),d.length>0){const p=e[o].map(y=>y.presence_ref),m=d.filter(y=>p.indexOf(y.presence_ref)<0);e[o].unshift(...m)}s(o,d,l)}),this.map(a,(o,l)=>{let h=e[o];if(!h)return;const d=l.map(p=>p.presence_ref);h=h.filter(p=>d.indexOf(p.presence_ref)<0),e[o]=h,r(o,h,l),h.length===0&&delete e[o]}),e}static map(e,t){return Object.getOwnPropertyNames(e).map(s=>t(s,e[s]))}static transformState(e){return e=this.cloneDeep(e),Object.getOwnPropertyNames(e).reduce((t,s)=>{const r=e[s];return"metas"in r?t[s]=r.metas.map(i=>(i.presence_ref=i.phx_ref,delete i.phx_ref,delete i.phx_ref_prev,i)):t[s]=r,t},{})}static cloneDeep(e){return JSON.parse(JSON.stringify(e))}onJoin(e){this.caller.onJoin=e}onLeave(e){this.caller.onLeave=e}onSync(e){this.caller.onSync=e}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var KD;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(KD||(KD={}));var Ff;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(Ff||(Ff={}));var pa;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(pa||(pa={}));class Ic{constructor(e,t={config:{}},s){var r,i;if(this.topic=e,this.params=t,this.socket=s,this.bindings={},this.state=Dn.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=e.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},t.config),this.timeout=this.socket.timeout,this.joinPush=new xS(this,ui.join,this.params,this.timeout),this.rejoinTimer=new MF(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Dn.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(a=>a.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=Dn.closed,this.socket._remove(this)}),this._onError(a=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,a),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",a=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,a),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this._on(ui.reply,{},(a,o)=>{this._trigger(this._replyEventName(o),a)}),this.presence=new Lf(this),this.broadcastEndpointURL=PF(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((i=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||i===void 0)&&i.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(e,t=this.timeout){var s,r,i;if(this.socket.isConnected()||this.socket.connect(),this.state==Dn.closed){const{config:{broadcast:a,presence:o,private:l}}=this.params,h=(r=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&r!==void 0?r:[],d=!!this.bindings[Ff.PRESENCE]&&this.bindings[Ff.PRESENCE].length>0||((i=this.params.config.presence)===null||i===void 0?void 0:i.enabled)===!0,p={},m={broadcast:a,presence:Object.assign(Object.assign({},o),{enabled:d}),postgres_changes:h,private:l};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(y=>e?.(pa.CHANNEL_ERROR,y)),this._onClose(()=>e?.(pa.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){e?.(pa.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,v=[];for(let C=0;C<w;C++){const N=x[C],{filter:{event:k,schema:E,table:A,filter:R}}=N,D=y&&y[C];if(D&&D.event===k&&Ic.isFilterValueEqual(D.schema,E)&&Ic.isFilterValueEqual(D.table,A)&&Ic.isFilterValueEqual(D.filter,R))v.push(Object.assign(Object.assign({},N),{id:D.id}));else{this.unsubscribe(),this.state=Dn.errored,e?.(pa.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=v,e&&e(pa.SUBSCRIBED);return}}).receive("error",y=>{this.state=Dn.errored,e?.(pa.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{e?.(pa.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(e,t={}){return await this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)}async untrack(e={}){return await this.send({type:"presence",event:"untrack"},e)}on(e,t,s){return this.state===Dn.joined&&e===Ff.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(e,t,s)}async httpSend(e,t,s={}){var r;if(t==null)return Promise.reject("Payload is required for httpSend()");const i={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(i.Authorization=`Bearer ${this.socket.accessTokenValue}`);const a={method:"POST",headers:i,body:JSON.stringify({messages:[{topic:this.subTopic,event:e,payload:t,private:this.private}]})},o=await this._fetchWithTimeout(this.broadcastEndpointURL,a,(r=s.timeout)!==null&&r!==void 0?r:this.timeout);if(o.status===202)return{success:!0};let l=o.statusText;try{const h=await o.json();l=h.error||h.message||l}catch{}return Promise.reject(new Error(l))}async send(e,t={}){var s,r;if(!this._canPush()&&e.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:i,payload:a}=e,o={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(o.Authorization=`Bearer ${this.socket.accessTokenValue}`);const l={method:"POST",headers:o,body:JSON.stringify({messages:[{topic:this.subTopic,event:i,payload:a,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,l,(s=t.timeout)!==null&&s!==void 0?s:this.timeout);return await((r=h.body)===null||r===void 0?void 0:r.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(i=>{var a,o,l;const h=this._push(e.type,e,t.timeout||this.timeout);e.type==="broadcast"&&!(!((l=(o=(a=this.params)===null||a===void 0?void 0:a.config)===null||o===void 0?void 0:o.broadcast)===null||l===void 0)&&l.ack)&&i("ok"),h.receive("ok",()=>i("ok")),h.receive("error",()=>i("error")),h.receive("timeout",()=>i("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=Dn.leaving;const t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(ui.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(r=>{s=new xS(this,ui.leave,{},e),s.receive("ok",()=>{t(),r("ok")}).receive("timeout",()=>{t(),r("timed out")}).receive("error",()=>{r("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(e=>e.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=Dn.closed,this.bindings={}}async _fetchWithTimeout(e,t,s){const r=new AbortController,i=setTimeout(()=>r.abort(),s),a=await this.socket.fetch(e,Object.assign(Object.assign({},t),{signal:r.signal}));return clearTimeout(i),a}_push(e,t,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new xS(this,e,t,s);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(e){if(e.startTimeout(),this.pushBuffer.push(e),this.pushBuffer.length>dK){const t=this.pushBuffer.shift();t&&(t.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${t.event}`,t.payload))}}_onMessage(e,t,s){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,s){var r,i;const a=e.toLocaleLowerCase(),{close:o,error:l,leave:h,join:d}=ui;if(s&&[o,l,h,d].indexOf(a)>=0&&s!==this._joinRef())return;let m=this._onMessage(a,t,s);if(t&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(a)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===a}).map(y=>y.callback(m,s)):(i=this.bindings[a])===null||i===void 0||i.filter(y=>{var b,x,w,v,C,N;if(["broadcast","presence","postgres_changes"].includes(a))if("id"in y){const k=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return k&&((x=t.ids)===null||x===void 0?void 0:x.includes(k))&&(E==="*"||E?.toLocaleLowerCase()===((w=t.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const k=(C=(v=y?.filter)===null||v===void 0?void 0:v.event)===null||C===void 0?void 0:C.toLocaleLowerCase();return k==="*"||k===((N=t?.event)===null||N===void 0?void 0:N.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===a}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:v,type:C,errors:N}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:v,eventType:C,new:{},old:{},errors:N}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===Dn.closed}_isJoined(){return this.state===Dn.joined}_isJoining(){return this.state===Dn.joining}_isLeaving(){return this.state===Dn.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,s){const r=e.toLocaleLowerCase(),i={type:r,filter:t,callback:s};return this.bindings[r]?this.bindings[r].push(i):this.bindings[r]=[i],this}_off(e,t){const s=e.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(r=>{var i;return!(((i=r.type)===null||i===void 0?void 0:i.toLocaleLowerCase())===s&&Ic.isEqual(r.filter,t))})),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const s in e)if(e[s]!==t[s])return!1;return!0}static isFilterValueEqual(e,t){return(e??void 0)===(t??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(ui.close,{},e)}_onError(e){this._on(ui.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=Dn.joining,this.joinPush.resend(e))}_getPayloadRecords(e){const t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=HD(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=HD(e.columns,e.old_record)),t}}const wS=()=>{},_y={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},wK=[1e3,2e3,5e3,1e4],vK=1e4,SK=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class TK{constructor(e,t){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=gT,this.transport=null,this.heartbeatIntervalMs=_y.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=wS,this.ref=0,this.reconnectTimer=null,this.vsn=GD,this.logger=wS,this.conn=null,this.sendBuffer=[],this.serializer=new fK,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...i)=>r(...i):(...i)=>fetch(...i),!(!((s=t?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=t.params.apikey,this.endPoint=`${e}/${yT.websocket}`,this.httpEndpoint=PF(e),this._initializeOptions(t),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(t?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=oK.createWebSocket(this.endpointURL())}catch(e){this._setConnectionState("disconnected");const t=e.message;throw t.includes("Node.js")?new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${t}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(e,t){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(e?this.conn.close(e,t??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,s){this.logger(e,t,s)}connectionState(){switch(this.conn&&this.conn.readyState){case mo.connecting:return Nl.Connecting;case mo.open:return Nl.Open;case mo.closing:return Nl.Closing;default:return Nl.Closed}}isConnected(){return this.connectionState()===Nl.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(e,t={config:{}}){const s=`realtime:${e}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new Ic(`realtime:${e}`,t,this);return this.channels.push(i),i}}push(e){const{topic:t,event:s,payload:r,ref:i}=e,a=()=>{this.encode(e,o=>{var l;(l=this.conn)===null||l===void 0||l.send(o)})};this.log("push",`${t} ${s} (${i})`,r),this.isConnected()?a():this.sendBuffer.push(a)}async setAuth(e=null){this._authPromise=this._performAuth(e);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var e;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(t){this.log("error","error in heartbeat callback",t)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(t){this.log("error","error in heartbeat callback",t)}this._wasManualDisconnect=!1,(e=this.conn)===null||e===void 0||e.close(hK,"heartbeat timeout"),setTimeout(()=>{var t;this.isConnected()||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout()},_y.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(t){this.log("error","error in heartbeat callback",t)}this._setAuthSafely("heartbeat")}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(s=>s.topic===e&&(s._isJoined()||s._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}_onConnMessage(e){this.decode(e.data,t=>{if(t.topic==="phoenix"&&t.event==="phx_reply")try{this.heartbeatCallback(t.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}t.ref&&t.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:r,payload:i,ref:a}=t,o=a?`(${a})`:"",l=i.status||"";this.log("receive",`${l} ${s} ${r} ${o}`.trim(),i),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(r,i,a)),this._triggerStateCallbacks("message",t)})}_clearTimer(e){var t;e==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):e==="reconnect"&&((t=this.reconnectTimer)===null||t===void 0||t.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e),this.conn.readyState===mo.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===mo.open||this.conn.readyState===mo.connecting)try{this.conn.close()}catch(e){this.log("error","Error closing connection",e)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(e=>e.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(t=>{this.log("error","error waiting for auth on connect",t),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this._terminateWorker()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(e){var t;this._setConnectionState("disconnected"),this.log("transport","close",e),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout(),this._triggerStateCallbacks("close",e)}_onConnError(e){this._setConnectionState("disconnected"),this.log("transport",`${e}`),this._triggerChanError(),this._triggerStateCallbacks("error",e)}_triggerChanError(){this.channels.forEach(e=>e._trigger(ui.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const s=e.match(/\?/)?"&":"?",r=new URLSearchParams(t);return`${e}${s}${r}`}_workerObjectUrl(e){let t;if(e)t=e;else{const s=new Blob([SK],{type:"application/javascript"});t=URL.createObjectURL(s)}return t}_setConnectionState(e,t=!1){this._connectionState=e,e==="connecting"?this._wasManualDisconnect=!1:e==="disconnecting"&&(this._wasManualDisconnect=t)}async _performAuth(e=null){let t,s=!1;if(e)t=e,s=!0;else if(this.accessToken)try{t=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),t=this.accessTokenValue}else t=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(r=>{const i={access_token:t,version:uK};t&&r.updateJoinPayload(i),r.joinedOnce&&r._isJoined()&&r._push(ui.access_token,{access_token:t})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(e="general"){this._isManualToken()||this.setAuth().catch(t=>{this.log("error",`Error setting auth in ${e}`,t)})}_triggerStateCallbacks(e,t){try{this.stateChangeCallbacks[e].forEach(s=>{try{s(t)}catch(r){this.log("error",`error in ${e} callback`,r)}})}catch(s){this.log("error",`error triggering ${e} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new MF(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},_y.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(e){var t,s,r,i,a,o,l,h,d,p,m,y;switch(this.transport=(t=e?.transport)!==null&&t!==void 0?t:null,this.timeout=(s=e?.timeout)!==null&&s!==void 0?s:gT,this.heartbeatIntervalMs=(r=e?.heartbeatIntervalMs)!==null&&r!==void 0?r:_y.HEARTBEAT_INTERVAL,this.worker=(i=e?.worker)!==null&&i!==void 0?i:!1,this.accessToken=(a=e?.accessToken)!==null&&a!==void 0?a:null,this.heartbeatCallback=(o=e?.heartbeatCallback)!==null&&o!==void 0?o:wS,this.vsn=(l=e?.vsn)!==null&&l!==void 0?l:GD,e?.params&&(this.params=e.params),e?.logger&&(this.logger=e.logger),(e?.logLevel||e?.log_level)&&(this.logLevel=e.logLevel||e.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=e?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>wK[b-1]||vK),this.vsn){case FF:this.encode=(d=e?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(p=e?.decode)!==null&&p!==void 0?p:((b,x)=>x(JSON.parse(b)));break;case cK:this.encode=(m=e?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=e?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=e?.workerUrl}}}var Gf=class extends Error{constructor(n,e){super(n),this.name="IcebergError",this.status=e.status,this.icebergType=e.icebergType,this.icebergCode=e.icebergCode,this.details=e.details,this.isCommitStateUnknown=e.icebergType==="CommitStateUnknownException"||[500,502,504].includes(e.status)&&e.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function CK(n,e,t){const s=new URL(e,n);if(t)for(const[r,i]of Object.entries(t))i!==void 0&&s.searchParams.set(r,i);return s.toString()}async function NK(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function kK(n){const e=n.fetchImpl??globalThis.fetch;return{async request({method:t,path:s,query:r,body:i,headers:a}){const o=CK(n.baseUrl,s,r),l=await NK(n.auth),h=await e(o,{method:t,headers:{...i?{"Content-Type":"application/json"}:{},...l,...a},body:i?JSON.stringify(i):void 0}),d=await h.text(),p=(h.headers.get("content-type")||"").includes("application/json"),m=p&&d?JSON.parse(d):d;if(!h.ok){const y=p?m:void 0,b=y?.error;throw new Gf(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function Ay(n){return n.join("")}var EK=class{constructor(n,e=""){this.client=n,this.prefix=e}async listNamespaces(n){const e=n?{parent:Ay(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:e})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,e){const t={namespace:n.namespace,properties:e?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:t})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${Ay(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${Ay(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${Ay(n.namespace)}`}),!0}catch(e){if(e instanceof Gf&&e.status===404)return!1;throw e}}async createNamespaceIfNotExists(n,e){try{return await this.createNamespace(n,e)}catch(t){if(t instanceof Gf&&t.status===409)return;throw t}}};function uc(n){return n.join("")}var IK=class{constructor(n,e="",t){this.client=n,this.prefix=e,this.accessDelegation=t}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${uc(n.namespace)}/tables`})).data.identifiers}async createTable(n,e){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${uc(n.namespace)}/tables`,body:e,headers:t})).data.metadata}async updateTable(n,e){const t=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${uc(n.namespace)}/tables/${n.name}`,body:e});return{"metadata-location":t.data["metadata-location"],metadata:t.data.metadata}}async dropTable(n,e){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${uc(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(e?.purge??!1)}})}async loadTable(n){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${uc(n.namespace)}/tables/${n.name}`,headers:e})).data.metadata}async tableExists(n){const e={};this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${uc(n.namespace)}/tables/${n.name}`,headers:e}),!0}catch(t){if(t instanceof Gf&&t.status===404)return!1;throw t}}async createTableIfNotExists(n,e){try{return await this.createTable(n,e)}catch(t){if(t instanceof Gf&&t.status===409)return await this.loadTable({namespace:n.namespace,name:e.name});throw t}}},$K=class{constructor(n){let e="v1";n.catalogName&&(e+=`/${n.catalogName}`);const t=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=kK({baseUrl:t,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new EK(this.client,e),this.tableOps=new IK(this.client,e,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,e){return this.namespaceOps.createNamespace(n,e)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,e){return this.tableOps.createTable(n,e)}async updateTable(n,e){return this.tableOps.updateTable(n,e)}async dropTable(n,e){await this.tableOps.dropTable(n,e)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,e){return this.namespaceOps.createNamespaceIfNotExists(n,e)}async createTableIfNotExists(n,e){return this.tableOps.createTableIfNotExists(n,e)}},db=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function Qt(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var _K=class extends db{constructor(n,e,t){super(n),this.name="StorageApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},xT=class extends db{constructor(n,e){super(n),this.name="StorageUnknownError",this.originalError=e}};const o2=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),AK=()=>Response,wT=n=>{if(Array.isArray(n))return n.map(t=>wT(t));if(typeof n=="function"||n!==Object(n))return n;const e={};return Object.entries(n).forEach(([t,s])=>{const r=t.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));e[r]=wT(s)}),e},RK=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},DK=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function Hf(n){"@babel/helpers - typeof";return Hf=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Hf(n)}function OK(n,e){if(Hf(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(Hf(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function LK(n){var e=OK(n,"string");return Hf(e)=="symbol"?e:e+""}function FK(n,e,t){return(e=LK(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function XD(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function Ge(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?XD(Object(t),!0).forEach(function(s){FK(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):XD(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const vS=n=>{var e;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(e=n.error)===null||e===void 0?void 0:e.message)||JSON.stringify(n)},MK=async(n,e,t)=>{n instanceof await AK()&&!t?.noResolveJson?n.json().then(s=>{const r=n.status||500,i=s?.statusCode||r+"";e(new _K(vS(s),r,i))}).catch(s=>{e(new xT(vS(s),s))}):e(new xT(vS(n),n))},zK=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"||!s?r:(RK(s)?(r.headers=Ge({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,e?.duplex&&(r.duplex=e.duplex),Ge(Ge({},r),t))};async function vp(n,e,t,s,r,i){return new Promise((a,o)=>{n(t,zK(e,s,r,i)).then(l=>{if(!l.ok)throw l;return s?.noResolveJson?l:l.json()}).then(l=>a(l)).catch(l=>MK(l,o,s))})}async function qf(n,e,t,s){return vp(n,"GET",e,t,s)}async function oi(n,e,t,s,r){return vp(n,"POST",e,s,r,t)}async function vT(n,e,t,s,r){return vp(n,"PUT",e,s,r,t)}async function PK(n,e,t,s){return vp(n,"HEAD",e,Ge(Ge({},t),{},{noResolveJson:!0}),s)}async function l2(n,e,t,s,r){return vp(n,"DELETE",e,s,r,t)}var BK=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e}then(n,e){return this.execute().then(n,e)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Qt(e))return{data:null,error:e};throw e}}};let BF;BF=Symbol.toStringTag;var VK=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e,this[BF]="BlobDownloadBuilder",this.promise=null}asStream(){return new BK(this.downloadFn,this.shouldThrowOnError)}then(n,e){return this.getPromise().then(n,e)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Qt(e))return{data:null,error:e};throw e}}};const UK={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},YD={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var jK=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1,this.url=n,this.headers=e,this.bucketId=t,this.fetch=o2(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,e,t,s){var r=this;try{let i;const a=Ge(Ge({},YD),s);let o=Ge(Ge({},r.headers),n==="POST"&&{"x-upsert":String(a.upsert)});const l=a.metadata;typeof Blob<"u"&&t instanceof Blob?(i=new FormData,i.append("cacheControl",a.cacheControl),l&&i.append("metadata",r.encodeMetadata(l)),i.append("",t)):typeof FormData<"u"&&t instanceof FormData?(i=t,i.has("cacheControl")||i.append("cacheControl",a.cacheControl),l&&!i.has("metadata")&&i.append("metadata",r.encodeMetadata(l))):(i=t,o["cache-control"]=`max-age=${a.cacheControl}`,o["content-type"]=a.contentType,l&&(o["x-metadata"]=r.toBase64(r.encodeMetadata(l))),(typeof ReadableStream<"u"&&i instanceof ReadableStream||i&&typeof i=="object"&&"pipe"in i&&typeof i.pipe=="function")&&!a.duplex&&(a.duplex="half")),s?.headers&&(o=Ge(Ge({},o),s.headers));const h=r._removeEmptyFolders(e),d=r._getFinalPath(h),p=await(n=="PUT"?vT:oi)(r.fetch,`${r.url}/object/${d}`,i,Ge({headers:o},a?.duplex?{duplex:a.duplex}:{}));return{data:{path:h,id:p.Id,fullPath:p.Key},error:null}}catch(i){if(r.shouldThrowOnError)throw i;if(Qt(i))return{data:null,error:i};throw i}}async upload(n,e,t){return this.uploadOrUpdate("POST",n,e,t)}async uploadToSignedUrl(n,e,t,s){var r=this;const i=r._removeEmptyFolders(n),a=r._getFinalPath(i),o=new URL(r.url+`/object/upload/sign/${a}`);o.searchParams.set("token",e);try{let l;const h=Ge({upsert:YD.upsert},s),d=Ge(Ge({},r.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&t instanceof Blob?(l=new FormData,l.append("cacheControl",h.cacheControl),l.append("",t)):typeof FormData<"u"&&t instanceof FormData?(l=t,l.append("cacheControl",h.cacheControl)):(l=t,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:i,fullPath:(await vT(r.fetch,o.toString(),l,{headers:d})).Key},error:null}}catch(l){if(r.shouldThrowOnError)throw l;if(Qt(l))return{data:null,error:l};throw l}}async createSignedUploadUrl(n,e){var t=this;try{let s=t._getFinalPath(n);const r=Ge({},t.headers);e?.upsert&&(r["x-upsert"]="true");const i=await oi(t.fetch,`${t.url}/object/upload/sign/${s}`,{},{headers:r}),a=new URL(t.url+i.url),o=a.searchParams.get("token");if(!o)throw new db("No token returned by API");return{data:{signedUrl:a.toString(),path:n,token:o},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async update(n,e,t){return this.uploadOrUpdate("PUT",n,e,t)}async move(n,e,t){var s=this;try{return{data:await oi(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers}),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async copy(n,e,t){var s=this;try{return{data:{path:(await oi(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async createSignedUrl(n,e,t){var s=this;try{let r=s._getFinalPath(n),i=await oi(s.fetch,`${s.url}/object/sign/${r}`,Ge({expiresIn:e},t?.transform?{transform:t.transform}:{}),{headers:s.headers});const a=t?.download?`&download=${t.download===!0?"":t.download}`:"";return i={signedUrl:encodeURI(`${s.url}${i.signedURL}${a}`)},{data:i,error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async createSignedUrls(n,e,t){var s=this;try{const r=await oi(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:e,paths:n},{headers:s.headers}),i=t?.download?`&download=${t.download===!0?"":t.download}`:"";return{data:r.map(a=>Ge(Ge({},a),{},{signedUrl:a.signedURL?encodeURI(`${s.url}${a.signedURL}${i}`):null})),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}download(n,e){const t=typeof e?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(e?.transform||{}),r=s?`?${s}`:"",i=this._getFinalPath(n),a=()=>qf(this.fetch,`${this.url}/${t}/${i}${r}`,{headers:this.headers,noResolveJson:!0});return new VK(a,this.shouldThrowOnError)}async info(n){var e=this;const t=e._getFinalPath(n);try{return{data:wT(await qf(e.fetch,`${e.url}/object/info/${t}`,{headers:e.headers})),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async exists(n){var e=this;const t=e._getFinalPath(n);try{return await PK(e.fetch,`${e.url}/object/${t}`,{headers:e.headers}),{data:!0,error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Qt(s)&&s instanceof xT){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,e){const t=this._getFinalPath(n),s=[],r=e?.download?`download=${e.download===!0?"":e.download}`:"";r!==""&&s.push(r);const i=typeof e?.transform<"u"?"render/image":"object",a=this.transformOptsToQueryString(e?.transform||{});a!==""&&s.push(a);let o=s.join("&");return o!==""&&(o=`?${o}`),{data:{publicUrl:encodeURI(`${this.url}/${i}/public/${t}${o}`)}}}async remove(n){var e=this;try{return{data:await l2(e.fetch,`${e.url}/object/${e.bucketId}`,{prefixes:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async list(n,e,t){var s=this;try{const r=Ge(Ge(Ge({},UK),e),{},{prefix:n||""});return{data:await oi(s.fetch,`${s.url}/object/list/${s.bucketId}`,r,{headers:s.headers},t),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async listV2(n,e){var t=this;try{const s=Ge({},n);return{data:await oi(t.fetch,`${t.url}/object/list-v2/${t.bucketId}`,s,{headers:t.headers},e),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const e=[];return n.width&&e.push(`width=${n.width}`),n.height&&e.push(`height=${n.height}`),n.resize&&e.push(`resize=${n.resize}`),n.format&&e.push(`format=${n.format}`),n.quality&&e.push(`quality=${n.quality}`),e.join("&")}};const VF="2.89.0",UF={"X-Client-Info":`storage-js/${VF}`};var WK=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1;const r=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=Ge(Ge({},UF),e),this.fetch=o2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var e=this;try{const t=e.listBucketOptionsToQueryString(n);return{data:await qf(e.fetch,`${e.url}/bucket${t}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await qf(e.fetch,`${e.url}/bucket/${n}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async createBucket(n,e={public:!1}){var t=this;try{return{data:await oi(t.fetch,`${t.url}/bucket`,{id:n,name:n,type:e.type,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async updateBucket(n,e){var t=this;try{return{data:await vT(t.fetch,`${t.url}/bucket/${n}`,{id:n,name:n,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async emptyBucket(n){var e=this;try{return{data:await oi(e.fetch,`${e.url}/bucket/${n}/empty`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await l2(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}listBucketOptionsToQueryString(n){const e={};return n&&("limit"in n&&(e.limit=String(n.limit)),"offset"in n&&(e.offset=String(n.offset)),n.search&&(e.search=n.search),n.sortColumn&&(e.sortColumn=n.sortColumn),n.sortOrder&&(e.sortOrder=n.sortOrder)),Object.keys(e).length>0?"?"+new URLSearchParams(e).toString():""}},GK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},UF),e),this.fetch=o2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await oi(e.fetch,`${e.url}/bucket`,{name:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async listBuckets(n){var e=this;try{const t=new URLSearchParams;n?.limit!==void 0&&t.set("limit",n.limit.toString()),n?.offset!==void 0&&t.set("offset",n.offset.toString()),n?.sortColumn&&t.set("sortColumn",n.sortColumn),n?.sortOrder&&t.set("sortOrder",n.sortOrder),n?.search&&t.set("search",n.search);const s=t.toString(),r=s?`${e.url}/bucket?${s}`:`${e.url}/bucket`;return{data:await qf(e.fetch,r,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await l2(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}from(n){var e=this;if(!DK(n))throw new db("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const t=new $K({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>e.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(t,{get(r,i){const a=r[i];return typeof a!="function"?a:async(...o)=>{try{return{data:await a.apply(r,o),error:null}}catch(l){if(s)throw l;return{data:null,error:l}}}}})}};const u2={"X-Client-Info":`storage-js/${VF}`,"Content-Type":"application/json"};var jF=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function pr(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var SS=class extends jF{constructor(n,e,t){super(n),this.name="StorageVectorsApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},HK=class extends jF{constructor(n,e){super(n),this.name="StorageVectorsUnknownError",this.originalError=e}};const c2=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),qK=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},JD=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),KK=async(n,e,t)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!t?.noResolveJson){const s=n.status||500,r=n;if(typeof r.json=="function")r.json().then(i=>{const a=i?.statusCode||i?.code||s+"";e(new SS(JD(i),s,a))}).catch(()=>{const i=s+"";e(new SS(r.statusText||`HTTP ${s} error`,s,i))});else{const i=s+"";e(new SS(r.statusText||`HTTP ${s} error`,s,i))}}else e(new HK(JD(n),n))},XK=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return s?(qK(s)?(r.headers=Ge({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,Ge(Ge({},r),t)):r};async function YK(n,e,t,s,r,i){return new Promise((a,o)=>{n(t,XK(e,s,r,i)).then(l=>{if(!l.ok)throw l;if(s?.noResolveJson)return l;const h=l.headers.get("content-type");return!h||!h.includes("application/json")?{}:l.json()}).then(l=>a(l)).catch(l=>KK(l,o,s))})}async function mr(n,e,t,s,r){return YK(n,"POST",e,s,r,t)}var JK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},u2),e),this.fetch=c2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/CreateIndex`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getIndex(n,e){var t=this;try{return{data:await mr(t.fetch,`${t.url}/GetIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(pr(s))return{data:null,error:s};throw s}}async listIndexes(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/ListIndexes`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteIndex(n,e){var t=this;try{return{data:await mr(t.fetch,`${t.url}/DeleteIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers})||{},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(pr(s))return{data:null,error:s};throw s}}},ZK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},u2),e),this.fetch=c2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var e=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await mr(e.fetch,`${e.url}/PutVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getVectors(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/GetVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async listVectors(n){var e=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await mr(e.fetch,`${e.url}/ListVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async queryVectors(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/QueryVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteVectors(n){var e=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await mr(e.fetch,`${e.url}/DeleteVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}},QK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ge(Ge({},u2),e),this.fetch=c2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/GetVectorBucket`,{vectorBucketName:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async listBuckets(n={}){var e=this;try{return{data:await mr(e.fetch,`${e.url}/ListVectorBuckets`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}},e9=class extends QK{constructor(n,e={}){super(n,e.headers||{},e.fetch)}from(n){return new t9(this.url,this.headers,n,this.fetch)}async createBucket(n){var e=()=>super.createBucket,t=this;return e().call(t,n)}async getBucket(n){var e=()=>super.getBucket,t=this;return e().call(t,n)}async listBuckets(n={}){var e=()=>super.listBuckets,t=this;return e().call(t,n)}async deleteBucket(n){var e=()=>super.deleteBucket,t=this;return e().call(t,n)}},t9=class extends JK{constructor(n,e,t,s){super(n,e,s),this.vectorBucketName=t}async createIndex(n){var e=()=>super.createIndex,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName}))}async listIndexes(n={}){var e=()=>super.listIndexes,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName}))}async getIndex(n){var e=()=>super.getIndex,t=this;return e().call(t,t.vectorBucketName,n)}async deleteIndex(n){var e=()=>super.deleteIndex,t=this;return e().call(t,t.vectorBucketName,n)}index(n){return new n9(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},n9=class extends ZK{constructor(n,e,t,s,r){super(n,e,r),this.vectorBucketName=t,this.indexName=s}async putVectors(n){var e=()=>super.putVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async getVectors(n){var e=()=>super.getVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async listVectors(n={}){var e=()=>super.listVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async queryVectors(n){var e=()=>super.queryVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async deleteVectors(n){var e=()=>super.deleteVectors,t=this;return e().call(t,Ge(Ge({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}},s9=class extends WK{constructor(n,e={},t,s){super(n,e,t,s)}from(n){return new jK(this.url,this.headers,n,this.fetch)}get vectors(){return new e9(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new GK(this.url+"/iceberg",this.headers,this.fetch)}};const WF="2.89.0",xc=30*1e3,ST=3,TS=ST*xc,r9="http://localhost:9999",i9="supabase.auth.token",a9={"X-Client-Info":`gotrue-js/${WF}`},TT="X-Supabase-Api-Version",GF={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},o9=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,l9=600*1e3;class Kf extends Error{constructor(e,t,s){super(e),this.__isAuthError=!0,this.name="AuthError",this.status=t,this.code=s}}function Ve(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class u9 extends Kf{constructor(e,t,s){super(e,t,s),this.name="AuthApiError",this.status=t,this.code=s}}function c9(n){return Ve(n)&&n.name==="AuthApiError"}class kl extends Kf{constructor(e,t){super(e),this.name="AuthUnknownError",this.originalError=t}}class Aa extends Kf{constructor(e,t,s,r){super(e,s,r),this.name=t,this.status=s}}class dr extends Aa{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function h9(n){return Ve(n)&&n.name==="AuthSessionMissingError"}class cc extends Aa{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class Ry extends Aa{constructor(e){super(e,"AuthInvalidCredentialsError",400,void 0)}}class Dy extends Aa{constructor(e,t=null){super(e,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function d9(n){return Ve(n)&&n.name==="AuthImplicitGrantRedirectError"}class ZD extends Aa{constructor(e,t=null){super(e,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class f9 extends Aa{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class CT extends Aa{constructor(e,t){super(e,"AuthRetryableFetchError",t,void 0)}}function CS(n){return Ve(n)&&n.name==="AuthRetryableFetchError"}class QD extends Aa{constructor(e,t,s){super(e,"AuthWeakPasswordError",t,"weak_password"),this.reasons=s}}class NT extends Aa{constructor(e){super(e,"AuthInvalidJwtError",400,"invalid_jwt")}}const v0="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),eO=` 	
\r=`.split(""),p9=(()=>{const n=new Array(128);for(let e=0;e<n.length;e+=1)n[e]=-1;for(let e=0;e<eO.length;e+=1)n[eO[e].charCodeAt(0)]=-2;for(let e=0;e<v0.length;e+=1)n[v0[e].charCodeAt(0)]=e;return n})();function tO(n,e,t){if(n!==null)for(e.queue=e.queue<<8|n,e.queuedBits+=8;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(v0[s]),e.queuedBits-=6}else if(e.queuedBits>0)for(e.queue=e.queue<<6-e.queuedBits,e.queuedBits=6;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(v0[s]),e.queuedBits-=6}}function HF(n,e,t){const s=p9[n];if(s>-1)for(e.queue=e.queue<<6|s,e.queuedBits+=6;e.queuedBits>=8;)t(e.queue>>e.queuedBits-8&255),e.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function nO(n){const e=[],t=a=>{e.push(String.fromCodePoint(a))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=a=>{y9(a,s,t)};for(let a=0;a<n.length;a+=1)HF(n.charCodeAt(a),r,i);return e.join("")}function m9(n,e){if(n<=127){e(n);return}else if(n<=2047){e(192|n>>6),e(128|n&63);return}else if(n<=65535){e(224|n>>12),e(128|n>>6&63),e(128|n&63);return}else if(n<=1114111){e(240|n>>18),e(128|n>>12&63),e(128|n>>6&63),e(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function g9(n,e){for(let t=0;t<n.length;t+=1){let s=n.charCodeAt(t);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(t+1)-56320&65535|r)+65536,t+=1}m9(s,e)}}function y9(n,e,t){if(e.utf8seq===0){if(n<=127){t(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){e.utf8seq=s;break}if(e.utf8seq===2)e.codepoint=n&31;else if(e.utf8seq===3)e.codepoint=n&15;else if(e.utf8seq===4)e.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");e.utf8seq-=1}else if(e.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");e.codepoint=e.codepoint<<6|n&63,e.utf8seq-=1,e.utf8seq===0&&t(e.codepoint)}}function _c(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};for(let r=0;r<n.length;r+=1)HF(n.charCodeAt(r),t,s);return new Uint8Array(e)}function b9(n){const e=[];return g9(n,t=>e.push(t)),new Uint8Array(e)}function Ol(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};return n.forEach(r=>tO(r,t,s)),tO(null,t,s),e.join("")}function x9(n){return Math.round(Date.now()/1e3)+n}function w9(){return Symbol("auth-callback")}const ls=()=>typeof window<"u"&&typeof document<"u",yl={tested:!1,writable:!1},qF=()=>{if(!ls())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(yl.tested)return yl.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),yl.tested=!0,yl.writable=!0}catch{yl.tested=!0,yl.writable=!1}return yl.writable};function v9(n){const e={},t=new URL(n);if(t.hash&&t.hash[0]==="#")try{new URLSearchParams(t.hash.substring(1)).forEach((r,i)=>{e[i]=r})}catch{}return t.searchParams.forEach((s,r)=>{e[r]=s}),e}const KF=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),S9=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",wc=async(n,e,t)=>{await n.setItem(e,JSON.stringify(t))},bl=async(n,e)=>{const t=await n.getItem(e);if(!t)return null;try{return JSON.parse(t)}catch{return t}},os=async(n,e)=>{await n.removeItem(e)};class fb{constructor(){this.promise=new fb.promiseConstructor((e,t)=>{this.resolve=e,this.reject=t})}}fb.promiseConstructor=Promise;function NS(n){const e=n.split(".");if(e.length!==3)throw new NT("Invalid JWT structure");for(let s=0;s<e.length;s++)if(!o9.test(e[s]))throw new NT("JWT not in base64url format");return{header:JSON.parse(nO(e[0])),payload:JSON.parse(nO(e[1])),signature:_c(e[2]),raw:{header:e[0],payload:e[1]}}}async function T9(n){return await new Promise(e=>{setTimeout(()=>e(null),n)})}function C9(n,e){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const a=await n(i);if(!e(i,null,a)){s(a);return}}catch(a){if(!e(i,a)){r(a);return}}})()})}function N9(n){return("0"+n.toString(16)).substr(-2)}function k9(){const e=new Uint32Array(56);if(typeof crypto>"u"){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=t.length;let r="";for(let i=0;i<56;i++)r+=t.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(e),Array.from(e,N9).join("")}async function E9(n){const t=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",t),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function I9(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const t=await E9(n);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function hc(n,e,t=!1){const s=k9();let r=s;t&&(r+="/PASSWORD_RECOVERY"),await wc(n,`${e}-code-verifier`,r);const i=await I9(s);return[i,s===i?"plain":"s256"]}const $9=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function _9(n){const e=n.headers.get(TT);if(!e||!e.match($9))return null;try{return new Date(`${e}T00:00:00.0Z`)}catch{return null}}function A9(n){if(!n)throw new Error("Missing exp claim");const e=Math.floor(Date.now()/1e3);if(n<=e)throw new Error("JWT has expired")}function R9(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const D9=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function dc(n){if(!D9.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function kS(){const n={};return new Proxy(n,{get:(e,t)=>{if(t==="__isUserNotAvailableProxy")return!0;if(typeof t=="symbol"){const s=t.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`)},set:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function O9(n,e){return new Proxy(n,{get:(t,s,r)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const i=s.toString();if(i==="Symbol(Symbol.toPrimitive)"||i==="Symbol(Symbol.toStringTag)"||i==="Symbol(util.inspect.custom)"||i==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(t,s,r)}return!e.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),e.value=!0),Reflect.get(t,s,r)}})}function sO(n){return JSON.parse(JSON.stringify(n))}const Sl=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),L9=[502,503,504];async function rO(n){var e;if(!S9(n))throw new CT(Sl(n),0);if(L9.includes(n.status))throw new CT(Sl(n),n.status);let t;try{t=await n.json()}catch(i){throw new kl(Sl(i),i)}let s;const r=_9(n);if(r&&r.getTime()>=GF["2024-01-01"].timestamp&&typeof t=="object"&&t&&typeof t.code=="string"?s=t.code:typeof t=="object"&&t&&typeof t.error_code=="string"&&(s=t.error_code),s){if(s==="weak_password")throw new QD(Sl(t),n.status,((e=t.weak_password)===null||e===void 0?void 0:e.reasons)||[]);if(s==="session_not_found")throw new dr}else if(typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((i,a)=>i&&typeof a=="string",!0))throw new QD(Sl(t),n.status,t.weak_password.reasons);throw new u9(Sl(t),n.status||500,s)}const F9=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},e?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),t))};async function We(n,e,t,s){var r;const i=Object.assign({},s?.headers);i[TT]||(i[TT]=GF["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const a=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(a.redirect_to=s.redirectTo);const o=Object.keys(a).length?"?"+new URLSearchParams(a).toString():"",l=await M9(n,e,t+o,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(l):{data:Object.assign({},l),error:null}}async function M9(n,e,t,s,r,i){const a=F9(e,s,r,i);let o;try{o=await n(t,Object.assign({},a))}catch(l){throw console.error(l),new CT(Sl(l),0)}if(o.ok||await rO(o),s?.noResolveJson)return o;try{return await o.json()}catch(l){await rO(l)}}function ri(n){var e;let t=null;B9(n)&&(t=Object.assign({},n),n.expires_at||(t.expires_at=x9(n.expires_in)));const s=(e=n.user)!==null&&e!==void 0?e:n;return{data:{session:t,user:s},error:null}}function iO(n){const e=ri(n);return!e.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((t,s)=>t&&typeof s=="string",!0)&&(e.data.weak_password=n.weak_password),e}function yo(n){var e;return{data:{user:(e=n.user)!==null&&e!==void 0?e:n},error:null}}function z9(n){return{data:n,error:null}}function P9(n){const{action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i}=n,a=hb(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),o={action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:i},l=Object.assign({},a);return{data:{properties:o,user:l},error:null}}function aO(n){return n}function B9(n){return n.access_token&&n.refresh_token&&n.expires_in}const ES=["global","local","others"];class V9{constructor({url:e="",headers:t={},fetch:s}){this.url=e,this.headers=t,this.fetch=KF(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(e,t=ES[0]){if(ES.indexOf(t)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${ES.join(", ")}`);try{return await We(this.fetch,"POST",`${this.url}/logout?scope=${t}`,{headers:this.headers,jwt:e,noResolveJson:!0}),{data:null,error:null}}catch(s){if(Ve(s))return{data:null,error:s};throw s}}async inviteUserByEmail(e,t={}){try{return await We(this.fetch,"POST",`${this.url}/invite`,{body:{email:e,data:t.data},headers:this.headers,redirectTo:t.redirectTo,xform:yo})}catch(s){if(Ve(s))return{data:{user:null},error:s};throw s}}async generateLink(e){try{const{options:t}=e,s=hb(e,["options"]),r=Object.assign(Object.assign({},s),t);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await We(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:P9,redirectTo:t?.redirectTo})}catch(t){if(Ve(t))return{data:{properties:null,user:null},error:t};throw t}}async createUser(e){try{return await We(this.fetch,"POST",`${this.url}/admin/users`,{body:e,headers:this.headers,xform:yo})}catch(t){if(Ve(t))return{data:{user:null},error:t};throw t}}async listUsers(e){var t,s,r,i,a,o,l;try{const h={nextPage:null,lastPage:0,total:0},d=await We(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:aO});if(d.error)throw d.error;const p=await d.json(),m=(a=d.headers.get("x-total-count"))!==null&&a!==void 0?a:0,y=(l=(o=d.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&l!==void 0?l:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Ve(h))return{data:{users:[]},error:h};throw h}}async getUserById(e){dc(e);try{return await We(this.fetch,"GET",`${this.url}/admin/users/${e}`,{headers:this.headers,xform:yo})}catch(t){if(Ve(t))return{data:{user:null},error:t};throw t}}async updateUserById(e,t){dc(e);try{return await We(this.fetch,"PUT",`${this.url}/admin/users/${e}`,{body:t,headers:this.headers,xform:yo})}catch(s){if(Ve(s))return{data:{user:null},error:s};throw s}}async deleteUser(e,t=!1){dc(e);try{return await We(this.fetch,"DELETE",`${this.url}/admin/users/${e}`,{headers:this.headers,body:{should_soft_delete:t},xform:yo})}catch(s){if(Ve(s))return{data:{user:null},error:s};throw s}}async _listFactors(e){dc(e.userId);try{const{data:t,error:s}=await We(this.fetch,"GET",`${this.url}/admin/users/${e.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:t,error:s}}catch(t){if(Ve(t))return{data:null,error:t};throw t}}async _deleteFactor(e){dc(e.userId),dc(e.id);try{return{data:await We(this.fetch,"DELETE",`${this.url}/admin/users/${e.userId}/factors/${e.id}`,{headers:this.headers}),error:null}}catch(t){if(Ve(t))return{data:null,error:t};throw t}}async _listOAuthClients(e){var t,s,r,i,a,o,l;try{const h={nextPage:null,lastPage:0,total:0},d=await We(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:aO});if(d.error)throw d.error;const p=await d.json(),m=(a=d.headers.get("x-total-count"))!==null&&a!==void 0?a:0,y=(l=(o=d.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&l!==void 0?l:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Ve(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(e){try{return await We(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:e,headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Ve(t))return{data:null,error:t};throw t}}async _getOAuthClient(e){try{return await We(this.fetch,"GET",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Ve(t))return{data:null,error:t};throw t}}async _updateOAuthClient(e,t){try{return await We(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${e}`,{body:t,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(Ve(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(e){try{return await We(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(t){if(Ve(t))return{data:null,error:t};throw t}}async _regenerateOAuthClientSecret(e){try{return await We(this.fetch,"POST",`${this.url}/admin/oauth/clients/${e}/regenerate_secret`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Ve(t))return{data:null,error:t};throw t}}}function oO(n={}){return{getItem:e=>n[e]||null,setItem:(e,t)=>{n[e]=t},removeItem:e=>{delete n[e]}}}const fc={debug:!!(globalThis&&qF()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class XF extends Error{constructor(e){super(e),this.isAcquireTimeout=!0}}class U9 extends XF{}async function j9(n,e,t){fc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,e);const s=new globalThis.AbortController;return e>0&&setTimeout(()=>{s.abort(),fc.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},e),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,e===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){fc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await t()}finally{fc.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(e===0)throw fc.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new U9(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(fc.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await t()}}))}function W9(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function YF(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function G9(n){return parseInt(n,16)}function H9(n){const e=new TextEncoder().encode(n);return"0x"+Array.from(e,s=>s.toString(16).padStart(2,"0")).join("")}function q9(n){var e;const{chainId:t,domain:s,expirationTime:r,issuedAt:i=new Date,nonce:a,notBefore:o,requestId:l,resources:h,scheme:d,uri:p,version:m}=n;{if(!Number.isInteger(t))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${t}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(a&&a.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${a}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((e=n.statement)===null||e===void 0)&&e.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=YF(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let v=`URI: ${p}
Version: ${m}
Chain ID: ${t}${a?`
Nonce: ${a}`:""}
Issued At: ${i.toISOString()}`;if(r&&(v+=`
Expiration Time: ${r.toISOString()}`),o&&(v+=`
Not Before: ${o.toISOString()}`),l&&(v+=`
Request ID: ${l}`),h){let C=`
Resources:`;for(const N of h){if(!N||typeof N!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${N}`);C+=`
- ${N}`}v+=C}return`${w}
${v}`}class Cn extends Error{constructor({message:e,code:t,cause:s,name:r}){var i;super(e,{cause:s}),this.__isWebAuthnError=!0,this.name=(i=r??(s instanceof Error?s.name:void 0))!==null&&i!==void 0?i:"Unknown Error",this.code=t}}class S0 extends Cn{constructor(e,t){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:t,message:e}),this.name="WebAuthnUnknownError",this.originalError=t}}function K9({error:n,options:e}){var t,s,r;const{publicKey:i}=e;if(!i)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new Cn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((t=i.authenticatorSelection)===null||t===void 0?void 0:t.requireResidentKey)===!0)return new Cn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(e.mediation==="conditional"&&((s=i.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new Cn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((r=i.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new Cn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new Cn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new Cn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return i.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new Cn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new Cn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const a=window.location.hostname;if(JF(a)){if(i.rp.id!==a)return new Cn({message:`The RP ID "${i.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new Cn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new Cn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new Cn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new Cn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function X9({error:n,options:e}){const{publicKey:t}=e;if(!t)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new Cn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new Cn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(JF(s)){if(t.rpId!==s)return new Cn({message:`The RP ID "${t.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new Cn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new Cn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new Cn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class Y9{createNewAbortSignal(){if(this.controller){const t=new Error("Cancelling existing WebAuthn API call for new one");t.name="AbortError",this.controller.abort(t)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}}const J9=new Y9;function Z9(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:e,user:t,excludeCredentials:s}=n,r=hb(n,["challenge","user","excludeCredentials"]),i=_c(e).buffer,a=Object.assign(Object.assign({},t),{id:_c(t.id).buffer}),o=Object.assign(Object.assign({},r),{challenge:i,user:a});if(s&&s.length>0){o.excludeCredentials=new Array(s.length);for(let l=0;l<s.length;l++){const h=s[l];o.excludeCredentials[l]=Object.assign(Object.assign({},h),{id:_c(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return o}function Q9(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:e,allowCredentials:t}=n,s=hb(n,["challenge","allowCredentials"]),r=_c(e).buffer,i=Object.assign(Object.assign({},s),{challenge:r});if(t&&t.length>0){i.allowCredentials=new Array(t.length);for(let a=0;a<t.length;a++){const o=t[a];i.allowCredentials[a]=Object.assign(Object.assign({},o),{id:_c(o.id).buffer,type:o.type||"public-key",transports:o.transports})}}return i}function e7(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n;return{id:n.id,rawId:n.id,response:{attestationObject:Ol(new Uint8Array(n.response.attestationObject)),clientDataJSON:Ol(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function t7(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n,s=n.getClientExtensionResults(),r=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:Ol(new Uint8Array(r.authenticatorData)),clientDataJSON:Ol(new Uint8Array(r.clientDataJSON)),signature:Ol(new Uint8Array(r.signature)),userHandle:r.userHandle?Ol(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function JF(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function lO(){var n,e;return!!(ls()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((e=navigator?.credentials)===null||e===void 0?void 0:e.get)=="function")}async function n7(n){try{const e=await navigator.credentials.create(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new S0("Browser returned unexpected credential type",e)}:{data:null,error:new S0("Empty credential response",e)}}catch(e){return{data:null,error:K9({error:e,options:n})}}}async function s7(n){try{const e=await navigator.credentials.get(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new S0("Browser returned unexpected credential type",e)}:{data:null,error:new S0("Empty credential response",e)}}catch(e){return{data:null,error:X9({error:e,options:n})}}}const r7={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},i7={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function T0(...n){const e=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),t=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),s={};for(const r of n)if(r)for(const i in r){const a=r[i];if(a!==void 0)if(Array.isArray(a))s[i]=a;else if(t(a))s[i]=a;else if(e(a)){const o=s[i];e(o)?s[i]=T0(o,a):s[i]=T0(a)}else s[i]=a}return s}function a7(n,e){return T0(r7,n,e||{})}function o7(n,e){return T0(i7,n,e||{})}class l7{constructor(e){this.client=e,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(e){return this.client.mfa.enroll(Object.assign(Object.assign({},e),{factorType:"webauthn"}))}async _challenge({factorId:e,webauthn:t,friendlyName:s,signal:r},i){try{const{data:a,error:o}=await this.client.mfa.challenge({factorId:e,webauthn:t});if(!a)return{data:null,error:o};const l=r??J9.createNewAbortSignal();if(a.webauthn.type==="create"){const{user:h}=a.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(a.webauthn.type){case"create":{const h=a7(a.webauthn.credential_options.publicKey,i?.create),{data:d,error:p}=await n7({publicKey:h,signal:l});return d?{data:{factorId:e,challengeId:a.id,webauthn:{type:a.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}case"request":{const h=o7(a.webauthn.credential_options.publicKey,i?.request),{data:d,error:p}=await s7(Object.assign(Object.assign({},a.webauthn.credential_options),{publicKey:h,signal:l}));return d?{data:{factorId:e,challengeId:a.id,webauthn:{type:a.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}}}catch(a){return Ve(a)?{data:null,error:a}:{data:null,error:new kl("Unexpected error in challenge",a)}}}async _verify({challengeId:e,factorId:t,webauthn:s}){return this.client.mfa.verify({factorId:t,challengeId:e,webauthn:s})}async _authenticate({factorId:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!t)return{data:null,error:new Kf("rpId is required for WebAuthn authentication")};try{if(!lO())return{data:null,error:new kl("Browser does not support WebAuthn",null)};const{data:a,error:o}=await this.challenge({factorId:e,webauthn:{rpId:t,rpOrigins:s},signal:r},{request:i});if(!a)return{data:null,error:o};const{webauthn:l}=a;return this._verify({factorId:e,challengeId:a.challengeId,webauthn:{type:l.type,rpId:t,rpOrigins:s,credential_response:l.credential_response}})}catch(a){return Ve(a)?{data:null,error:a}:{data:null,error:new kl("Unexpected error in authenticate",a)}}}async _register({friendlyName:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!t)return{data:null,error:new Kf("rpId is required for WebAuthn registration")};try{if(!lO())return{data:null,error:new kl("Browser does not support WebAuthn",null)};const{data:a,error:o}=await this._enroll({friendlyName:e});if(!a)return await this.client.mfa.listFactors().then(d=>{var p;return(p=d.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===e&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:o};const{data:l,error:h}=await this._challenge({factorId:a.id,friendlyName:a.friendly_name,webauthn:{rpId:t,rpOrigins:s},signal:r},{create:i});return l?this._verify({factorId:a.id,challengeId:l.challengeId,webauthn:{rpId:t,rpOrigins:s,type:l.webauthn.type,credential_response:l.webauthn.credential_response}}):{data:null,error:h}}catch(a){return Ve(a)?{data:null,error:a}:{data:null,error:new kl("Unexpected error in register",a)}}}}W9();const u7={url:r9,storageKey:i9,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:a9,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function uO(n,e,t){return await t()}const pc={};class Xf{get jwks(){var e,t;return(t=(e=pc[this.storageKey])===null||e===void 0?void 0:e.jwks)!==null&&t!==void 0?t:{keys:[]}}set jwks(e){pc[this.storageKey]=Object.assign(Object.assign({},pc[this.storageKey]),{jwks:e})}get jwks_cached_at(){var e,t;return(t=(e=pc[this.storageKey])===null||e===void 0?void 0:e.cachedAt)!==null&&t!==void 0?t:Number.MIN_SAFE_INTEGER}set jwks_cached_at(e){pc[this.storageKey]=Object.assign(Object.assign({},pc[this.storageKey]),{cachedAt:e})}constructor(e){var t,s,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const i=Object.assign(Object.assign({},u7),e);if(this.storageKey=i.storageKey,this.instanceID=(t=Xf.nextInstanceID[this.storageKey])!==null&&t!==void 0?t:0,Xf.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!i.debug,typeof i.debug=="function"&&(this.logger=i.debug),this.instanceID>0&&ls()){const a=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(a),this.logDebugMessages&&console.trace(a)}if(this.persistSession=i.persistSession,this.autoRefreshToken=i.autoRefreshToken,this.admin=new V9({url:i.url,headers:i.headers,fetch:i.fetch}),this.url=i.url,this.headers=i.headers,this.fetch=KF(i.fetch),this.lock=i.lock||uO,this.detectSessionInUrl=i.detectSessionInUrl,this.flowType=i.flowType,this.hasCustomAuthorizationHeader=i.hasCustomAuthorizationHeader,this.throwOnError=i.throwOnError,i.lock?this.lock=i.lock:this.persistSession&&ls()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=j9:this.lock=uO,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new l7(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(i.storage?this.storage=i.storage:qF()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=oO(this.memoryStorage)),i.userStorage&&(this.userStorage=i.userStorage)):(this.memoryStorage={},this.storage=oO(this.memoryStorage)),ls()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(a){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",a)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async a=>{this._debug("received broadcast notification from other tab or client",a),await this._notifyAllSubscribers(a.data.event,a.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(e){if(this.throwOnError&&e&&e.error)throw e.error;return e}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${WF}) ${new Date().toISOString()}`}_debug(...e){return this.logDebugMessages&&this.logger(this._logPrefix(),...e),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var e;try{let t={},s="none";if(ls()&&(t=v9(window.location.href),this._isImplicitGrantCallback(t)?s="implicit":await this._isPKCECallback(t)&&(s="pkce")),ls()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(t,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),d9(i)){const l=(e=i.details)===null||e===void 0?void 0:e.code;if(l==="identity_already_exists"||l==="identity_not_found"||l==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:a,redirectType:o}=r;return this._debug("#_initialize()","detected session in URL",a,"redirect type",o),await this._saveSession(a),setTimeout(async()=>{o==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",a):await this._notifyAllSubscribers("SIGNED_IN",a)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(t){return Ve(t)?this._returnResult({error:t}):this._returnResult({error:new kl("Unexpected error during initialization",t)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(e){var t,s,r;try{const i=await We(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(t=e?.options)===null||t===void 0?void 0:t.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=e?.options)===null||r===void 0?void 0:r.captchaToken}},xform:ri}),{data:a,error:o}=i;if(o||!a)return this._returnResult({data:{user:null,session:null},error:o});const l=a.session,h=a.user;return a.session&&(await this._saveSession(a.session),await this._notifyAllSubscribers("SIGNED_IN",l)),this._returnResult({data:{user:h,session:l},error:null})}catch(i){if(Ve(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signUp(e){var t,s,r;try{let i;if("email"in e){const{email:d,password:p,options:m}=e;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await hc(this.storage,this.storageKey)),i=await We(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:p,data:(t=m?.data)!==null&&t!==void 0?t:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:ri})}else if("phone"in e){const{phone:d,password:p,options:m}=e;i=await We(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:p,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:ri})}else throw new Ry("You must provide either an email or phone number and a password");const{data:a,error:o}=i;if(o||!a)return await os(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:o});const l=a.session,h=a.user;return a.session&&(await this._saveSession(a.session),await this._notifyAllSubscribers("SIGNED_IN",l)),this._returnResult({data:{user:h,session:l},error:null})}catch(i){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signInWithPassword(e){try{let t;if("email"in e){const{email:i,password:a,options:o}=e;t=await We(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:a,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:iO})}else if("phone"in e){const{phone:i,password:a,options:o}=e;t=await We(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:a,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:iO})}else throw new Ry("You must provide either an email or phone number and a password");const{data:s,error:r}=t;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!s||!s.session||!s.user){const i=new cc;return this._returnResult({data:{user:null,session:null},error:i})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(t){if(Ve(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOAuth(e){var t,s,r,i;return await this._handleProviderSignIn(e.provider,{redirectTo:(t=e.options)===null||t===void 0?void 0:t.redirectTo,scopes:(s=e.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=e.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=e.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(e){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(e))}async signInWithWeb3(e){const{chain:t}=e;switch(t){case"ethereum":return await this.signInWithEthereum(e);case"solana":return await this.signInWithSolana(e);default:throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`)}}async signInWithEthereum(e){var t,s,r,i,a,o,l,h,d,p,m;let y,b;if("message"in e)y=e.message,b=e.signature;else{const{chain:x,wallet:w,statement:v,options:C}=e;let N;if(ls())if(typeof w=="object")N=w;else{const L=window;if("ethereum"in L&&typeof L.ethereum=="object"&&"request"in L.ethereum&&typeof L.ethereum.request=="function")N=L.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!C?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");N=w}const k=new URL((t=C?.url)!==null&&t!==void 0?t:window.location.href),E=await N.request({method:"eth_requestAccounts"}).then(L=>L).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const A=YF(E[0]);let R=(s=C?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!R){const L=await N.request({method:"eth_chainId"});R=G9(L)}const D={domain:k.host,address:A,statement:v,uri:k.href,version:"1",chainId:R,nonce:(r=C?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(a=(i=C?.signInWithEthereum)===null||i===void 0?void 0:i.issuedAt)!==null&&a!==void 0?a:new Date,expirationTime:(o=C?.signInWithEthereum)===null||o===void 0?void 0:o.expirationTime,notBefore:(l=C?.signInWithEthereum)===null||l===void 0?void 0:l.notBefore,requestId:(h=C?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=C?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=q9(D),b=await N.request({method:"personal_sign",params:[H9(y),A]})}try{const{data:x,error:w}=await We(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((p=e.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=e.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:ri});if(w)throw w;if(!x||!x.session||!x.user){const v=new cc;return this._returnResult({data:{user:null,session:null},error:v})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(Ve(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(e){var t,s,r,i,a,o,l,h,d,p,m,y;let b,x;if("message"in e)b=e.message,x=e.signature;else{const{chain:w,wallet:v,statement:C,options:N}=e;let k;if(ls())if(typeof v=="object")k=v;else{const A=window;if("solana"in A&&typeof A.solana=="object"&&("signIn"in A.solana&&typeof A.solana.signIn=="function"||"signMessage"in A.solana&&typeof A.solana.signMessage=="function"))k=A.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof v!="object"||!N?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=v}const E=new URL((t=N?.url)!==null&&t!==void 0?t:window.location.href);if("signIn"in k&&k.signIn){const A=await k.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},N?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),C?{statement:C}:null));let R;if(Array.isArray(A)&&A[0]&&typeof A[0]=="object")R=A[0];else if(A&&typeof A=="object"&&"signedMessage"in A&&"signature"in A)R=A;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in R&&"signature"in R&&(typeof R.signedMessage=="string"||R.signedMessage instanceof Uint8Array)&&R.signature instanceof Uint8Array)b=typeof R.signedMessage=="string"?R.signedMessage:new TextDecoder().decode(R.signedMessage),x=R.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in k)||typeof k.signMessage!="function"||!("publicKey"in k)||typeof k!="object"||!k.publicKey||!("toBase58"in k.publicKey)||typeof k.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,k.publicKey.toBase58(),...C?["",C,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(r=(s=N?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=N?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${N.signInWithSolana.notBefore}`]:[],...!((a=N?.signInWithSolana)===null||a===void 0)&&a.expirationTime?[`Expiration Time: ${N.signInWithSolana.expirationTime}`]:[],...!((o=N?.signInWithSolana)===null||o===void 0)&&o.chainId?[`Chain ID: ${N.signInWithSolana.chainId}`]:[],...!((l=N?.signInWithSolana)===null||l===void 0)&&l.nonce?[`Nonce: ${N.signInWithSolana.nonce}`]:[],...!((h=N?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${N.signInWithSolana.requestId}`]:[],...!((p=(d=N?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||p===void 0)&&p.length?["Resources",...N.signInWithSolana.resources.map(R=>`- ${R}`)]:[]].join(`
`);const A=await k.signMessage(new TextEncoder().encode(b),"utf8");if(!A||!(A instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=A}}try{const{data:w,error:v}=await We(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:Ol(x)},!((m=e.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=e.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:ri});if(v)throw v;if(!w||!w.session||!w.user){const C=new cc;return this._returnResult({data:{user:null,session:null},error:C})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:v})}catch(w){if(Ve(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(e){const t=await bl(this.storage,`${this.storageKey}-code-verifier`),[s,r]=(t??"").split("/");try{if(!s&&this.flowType==="pkce")throw new f9;const{data:i,error:a}=await We(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:e,code_verifier:s},xform:ri});if(await os(this.storage,`${this.storageKey}-code-verifier`),a)throw a;if(!i||!i.session||!i.user){const o=new cc;return this._returnResult({data:{user:null,session:null,redirectType:null},error:o})}return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",i.session)),this._returnResult({data:Object.assign(Object.assign({},i),{redirectType:r??null}),error:a})}catch(i){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(i))return this._returnResult({data:{user:null,session:null,redirectType:null},error:i});throw i}}async signInWithIdToken(e){try{const{options:t,provider:s,token:r,access_token:i,nonce:a}=e,o=await We(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:r,access_token:i,nonce:a,gotrue_meta_security:{captcha_token:t?.captchaToken}},xform:ri}),{data:l,error:h}=o;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!l||!l.session||!l.user){const d=new cc;return this._returnResult({data:{user:null,session:null},error:d})}return l.session&&(await this._saveSession(l.session),await this._notifyAllSubscribers("SIGNED_IN",l.session)),this._returnResult({data:l,error:h})}catch(t){if(Ve(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOtp(e){var t,s,r,i,a;try{if("email"in e){const{email:o,options:l}=e;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await hc(this.storage,this.storageKey));const{error:p}=await We(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:o,data:(t=l?.data)!==null&&t!==void 0?t:{},create_user:(s=l?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:l?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:l?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in e){const{phone:o,options:l}=e,{data:h,error:d}=await We(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:o,data:(r=l?.data)!==null&&r!==void 0?r:{},create_user:(i=l?.shouldCreateUser)!==null&&i!==void 0?i:!0,gotrue_meta_security:{captcha_token:l?.captchaToken},channel:(a=l?.channel)!==null&&a!==void 0?a:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new Ry("You must provide either an email or phone number.")}catch(o){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(o))return this._returnResult({data:{user:null,session:null},error:o});throw o}}async verifyOtp(e){var t,s;try{let r,i;"options"in e&&(r=(t=e.options)===null||t===void 0?void 0:t.redirectTo,i=(s=e.options)===null||s===void 0?void 0:s.captchaToken);const{data:a,error:o}=await We(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},e),{gotrue_meta_security:{captcha_token:i}}),redirectTo:r,xform:ri});if(o)throw o;if(!a)throw new Error("An error occurred on token verification.");const l=a.session,h=a.user;return l?.access_token&&(await this._saveSession(l),await this._notifyAllSubscribers(e.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",l)),this._returnResult({data:{user:h,session:l},error:null})}catch(r){if(Ve(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(e){var t,s,r,i,a;try{let o=null,l=null;this.flowType==="pkce"&&([o,l]=await hc(this.storage,this.storageKey));const h=await We(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in e?{provider_id:e.providerId}:null),"domain"in e?{domain:e.domain}:null),{redirect_to:(s=(t=e.options)===null||t===void 0?void 0:t.redirectTo)!==null&&s!==void 0?s:void 0}),!((r=e?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:e.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:o,code_challenge_method:l}),headers:this.headers,xform:z9});return!((i=h.data)===null||i===void 0)&&i.url&&ls()&&!(!((a=e.options)===null||a===void 0)&&a.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(o){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(o))return this._returnResult({data:null,error:o});throw o}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;if(s)throw s;if(!t)throw new dr;const{error:r}=await We(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:t.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(e){if(Ve(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async resend(e){try{const t=`${this.url}/resend`;if("email"in e){const{email:s,type:r,options:i}=e,{error:a}=await We(this.fetch,"POST",t,{headers:this.headers,body:{email:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}},redirectTo:i?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:a})}else if("phone"in e){const{phone:s,type:r,options:i}=e,{data:a,error:o}=await We(this.fetch,"POST",t,{headers:this.headers,body:{phone:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:a?.message_id},error:o})}throw new Ry("You must provide either an email or phone number and a type")}catch(t){if(Ve(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async t=>t))}async _acquireLock(e,t){this._debug("#_acquireLock","begin",e);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await s,await t()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,e,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=t();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(e){this._debug("#_useSession","begin");try{const t=await this.__loadSession();return await e(t)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let e=null;const t=await bl(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",t),t!==null&&(this._isValidSession(t)?e=t:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!e)return{data:{session:null},error:null};const s=e.expires_at?e.expires_at*1e3-Date.now()<TS:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",e.expires_at),!s){if(this.userStorage){const a=await bl(this.userStorage,this.storageKey+"-user");a?.user?e.user=a.user:e.user=kS()}if(this.storage.isServer&&e.user&&!e.user.__isUserNotAvailableProxy){const a={value:this.suppressGetSessionWarning};e.user=O9(e.user,a),a.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:e},error:null}}const{data:r,error:i}=await this._callRefreshToken(e.refresh_token);return i?this._returnResult({data:{session:null},error:i}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(e){if(e)return await this._getUser(e);await this.initializePromise;const t=await this._acquireLock(-1,async()=>await this._getUser());return t.data.user&&(this.suppressGetSessionWarning=!0),t}async _getUser(e){try{return e?await We(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:e,xform:yo}):await this._useSession(async t=>{var s,r,i;const{data:a,error:o}=t;if(o)throw o;return!(!((s=a.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new dr}:await We(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(i=(r=a.session)===null||r===void 0?void 0:r.access_token)!==null&&i!==void 0?i:void 0,xform:yo})})}catch(t){if(Ve(t))return h9(t)&&(await this._removeSession(),await os(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:t});throw t}}async updateUser(e,t={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(e,t))}async _updateUser(e,t={}){try{return await this._useSession(async s=>{const{data:r,error:i}=s;if(i)throw i;if(!r.session)throw new dr;const a=r.session;let o=null,l=null;this.flowType==="pkce"&&e.email!=null&&([o,l]=await hc(this.storage,this.storageKey));const{data:h,error:d}=await We(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:t?.emailRedirectTo,body:Object.assign(Object.assign({},e),{code_challenge:o,code_challenge_method:l}),jwt:a.access_token,xform:yo});if(d)throw d;return a.user=h.user,await this._saveSession(a),await this._notifyAllSubscribers("USER_UPDATED",a),this._returnResult({data:{user:a.user},error:null})})}catch(s){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(e))}async _setSession(e){try{if(!e.access_token||!e.refresh_token)throw new dr;const t=Date.now()/1e3;let s=t,r=!0,i=null;const{payload:a}=NS(e.access_token);if(a.exp&&(s=a.exp,r=s<=t),r){const{data:o,error:l}=await this._callRefreshToken(e.refresh_token);if(l)return this._returnResult({data:{user:null,session:null},error:l});if(!o)return{data:{user:null,session:null},error:null};i=o}else{const{data:o,error:l}=await this._getUser(e.access_token);if(l)throw l;i={access_token:e.access_token,refresh_token:e.refresh_token,user:o.user,token_type:"bearer",expires_in:s-t,expires_at:s},await this._saveSession(i),await this._notifyAllSubscribers("SIGNED_IN",i)}return this._returnResult({data:{user:i.user,session:i},error:null})}catch(t){if(Ve(t))return this._returnResult({data:{session:null,user:null},error:t});throw t}}async refreshSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(e))}async _refreshSession(e){try{return await this._useSession(async t=>{var s;if(!e){const{data:a,error:o}=t;if(o)throw o;e=(s=a.session)!==null&&s!==void 0?s:void 0}if(!e?.refresh_token)throw new dr;const{data:r,error:i}=await this._callRefreshToken(e.refresh_token);return i?this._returnResult({data:{user:null,session:null},error:i}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(t){if(Ve(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async _getSessionFromURL(e,t){try{if(!ls())throw new Dy("No browser detected.");if(e.error||e.error_description||e.error_code)throw new Dy(e.error_description||"Error in URL with unspecified error_description",{error:e.error||"unspecified_error",code:e.error_code||"unspecified_code"});switch(t){case"implicit":if(this.flowType==="pkce")throw new ZD("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Dy("Not a valid implicit grant flow url.");break;default:}if(t==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!e.code)throw new ZD("No code detected.");const{data:C,error:N}=await this._exchangeCodeForSession(e.code);if(N)throw N;const k=new URL(window.location.href);return k.searchParams.delete("code"),window.history.replaceState(window.history.state,"",k.toString()),{data:{session:C.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:r,access_token:i,refresh_token:a,expires_in:o,expires_at:l,token_type:h}=e;if(!i||!o||!a||!h)throw new Dy("No session defined in URL");const d=Math.round(Date.now()/1e3),p=parseInt(o);let m=d+p;l&&(m=parseInt(l));const y=m-d;y*1e3<=xc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${p}s`);const b=m-p;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(i);if(w)throw w;const v={provider_token:s,provider_refresh_token:r,access_token:i,expires_in:p,expires_at:m,refresh_token:a,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:v,redirectType:e.type},error:null})}catch(s){if(Ve(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(e){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),e):!!(e.access_token||e.error_description)}async _isPKCECallback(e){const t=await bl(this.storage,`${this.storageKey}-code-verifier`);return!!(e.code&&t)}async signOut(e={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(e))}async _signOut({scope:e}={scope:"global"}){return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({error:i});const a=(s=r.session)===null||s===void 0?void 0:s.access_token;if(a){const{error:o}=await this.admin.signOut(a,e);if(o&&!(c9(o)&&(o.status===404||o.status===401||o.status===403)))return this._returnResult({error:o})}return e!=="others"&&(await this._removeSession(),await os(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(e){const t=w9(),s={id:t,callback:e,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",t),this.stateChangeEmitters.delete(t)}};return this._debug("#onAuthStateChange()","registered callback with id",t),this.stateChangeEmitters.set(t,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(t)})))(),{data:{subscription:s}}}async _emitInitialSession(e){return await this._useSession(async t=>{var s,r;try{const{data:{session:i},error:a}=t;if(a)throw a;await((s=this.stateChangeEmitters.get(e))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",i)),this._debug("INITIAL_SESSION","callback id",e,"session",i)}catch(i){await((r=this.stateChangeEmitters.get(e))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",e,"error",i),console.error(i)}})}async resetPasswordForEmail(e,t={}){let s=null,r=null;this.flowType==="pkce"&&([s,r]=await hc(this.storage,this.storageKey,!0));try{return await We(this.fetch,"POST",`${this.url}/recover`,{body:{email:e,code_challenge:s,code_challenge_method:r,gotrue_meta_security:{captcha_token:t.captchaToken}},headers:this.headers,redirectTo:t.redirectTo})}catch(i){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(i))return this._returnResult({data:null,error:i});throw i}}async getUserIdentities(){var e;try{const{data:t,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(e=t.user.identities)!==null&&e!==void 0?e:[]},error:null})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}}async linkIdentity(e){return"token"in e?this.linkIdentityIdToken(e):this.linkIdentityOAuth(e)}async linkIdentityOAuth(e){var t;try{const{data:s,error:r}=await this._useSession(async i=>{var a,o,l,h,d;const{data:p,error:m}=i;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,e.provider,{redirectTo:(a=e.options)===null||a===void 0?void 0:a.redirectTo,scopes:(o=e.options)===null||o===void 0?void 0:o.scopes,queryParams:(l=e.options)===null||l===void 0?void 0:l.queryParams,skipBrowserRedirect:!0});return await We(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=p.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(r)throw r;return ls()&&!(!((t=e.options)===null||t===void 0)&&t.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:e.provider,url:s?.url},error:null})}catch(s){if(Ve(s))return this._returnResult({data:{provider:e.provider,url:null},error:s});throw s}}async linkIdentityIdToken(e){return await this._useSession(async t=>{var s;try{const{error:r,data:{session:i}}=t;if(r)throw r;const{options:a,provider:o,token:l,access_token:h,nonce:d}=e,p=await We(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=i?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:o,id_token:l,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:a?.captchaToken}},xform:ri}),{data:m,error:y}=p;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new cc}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(r){if(await os(this.storage,`${this.storageKey}-code-verifier`),Ve(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(e){try{return await this._useSession(async t=>{var s,r;const{data:i,error:a}=t;if(a)throw a;return await We(this.fetch,"DELETE",`${this.url}/user/identities/${e.identity_id}`,{headers:this.headers,jwt:(r=(s=i.session)===null||s===void 0?void 0:s.access_token)!==null&&r!==void 0?r:void 0})})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}}async _refreshAccessToken(e){const t=`#_refreshAccessToken(${e.substring(0,5)}...)`;this._debug(t,"begin");try{const s=Date.now();return await C9(async r=>(r>0&&await T9(200*Math.pow(2,r-1)),this._debug(t,"refreshing attempt",r),await We(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:e},headers:this.headers,xform:ri})),(r,i)=>{const a=200*Math.pow(2,r);return i&&CS(i)&&Date.now()+a-s<xc})}catch(s){if(this._debug(t,"error",s),Ve(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(t,"end")}}_isValidSession(e){return typeof e=="object"&&e!==null&&"access_token"in e&&"refresh_token"in e&&"expires_at"in e}async _handleProviderSignIn(e,t){const s=await this._getUrlForProvider(`${this.url}/authorize`,e,{redirectTo:t.redirectTo,scopes:t.scopes,queryParams:t.queryParams});return this._debug("#_handleProviderSignIn()","provider",e,"options",t,"url",s),ls()&&!t.skipBrowserRedirect&&window.location.assign(s),{data:{provider:e,url:s},error:null}}async _recoverAndRefresh(){var e,t;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const r=await bl(this.storage,this.storageKey);if(r&&this.userStorage){let a=await bl(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!a&&(a={user:r.user},await wc(this.userStorage,this.storageKey+"-user",a)),r.user=(e=a?.user)!==null&&e!==void 0?e:kS()}else if(r&&!r.user&&!r.user){const a=await bl(this.storage,this.storageKey+"-user");a&&a?.user?(r.user=a.user,await os(this.storage,this.storageKey+"-user"),await wc(this.storage,this.storageKey,r)):r.user=kS()}if(this._debug(s,"session from storage",r),!this._isValidSession(r)){this._debug(s,"session is not valid"),r!==null&&await this._removeSession();return}const i=((t=r.expires_at)!==null&&t!==void 0?t:1/0)*1e3-Date.now()<TS;if(this._debug(s,`session has${i?"":" not"} expired with margin of ${TS}s`),i){if(this.autoRefreshToken&&r.refresh_token){const{error:a}=await this._callRefreshToken(r.refresh_token);a&&(console.error(a),CS(a)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",a),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:a,error:o}=await this._getUser(r.access_token);!o&&a?.user?(r.user=a.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(a){console.error("Error getting user data:",a),this._debug(s,"error getting user data, skipping SIGNED_IN notification",a)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(s,"error",r),console.error(r);return}finally{this._debug(s,"end")}}async _callRefreshToken(e){var t,s;if(!e)throw new dr;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${e.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new fb;const{data:i,error:a}=await this._refreshAccessToken(e);if(a)throw a;if(!i.session)throw new dr;await this._saveSession(i.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",i.session);const o={data:i.session,error:null};return this.refreshingDeferred.resolve(o),o}catch(i){if(this._debug(r,"error",i),Ve(i)){const a={data:null,error:i};return CS(i)||await this._removeSession(),(t=this.refreshingDeferred)===null||t===void 0||t.resolve(a),a}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(i),i}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(e,t,s=!0){const r=`#_notifyAllSubscribers(${e})`;this._debug(r,"begin",t,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:e,session:t});const i=[],a=Array.from(this.stateChangeEmitters.values()).map(async o=>{try{await o.callback(e,t)}catch(l){i.push(l)}});if(await Promise.all(a),i.length>0){for(let o=0;o<i.length;o+=1)console.error(i[o]);throw i[0]}}finally{this._debug(r,"end")}}async _saveSession(e){this._debug("#_saveSession()",e),this.suppressGetSessionWarning=!0,await os(this.storage,`${this.storageKey}-code-verifier`);const t=Object.assign({},e),s=t.user&&t.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&t.user&&await wc(this.userStorage,this.storageKey+"-user",{user:t.user});const r=Object.assign({},t);delete r.user;const i=sO(r);await wc(this.storage,this.storageKey,i)}else{const r=sO(t);await wc(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await os(this.storage,this.storageKey),await os(this.storage,this.storageKey+"-code-verifier"),await os(this.storage,this.storageKey+"-user"),this.userStorage&&await os(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const e=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{e&&ls()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",e)}catch(t){console.error("removing visibilitychange callback failed",t)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const e=setInterval(()=>this._autoRefreshTokenTick(),xc);this.autoRefreshTicker=e,e&&typeof e=="object"&&typeof e.unref=="function"?e.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(e),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const e=this.autoRefreshTicker;this.autoRefreshTicker=null,e&&clearInterval(e)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const e=Date.now();try{return await this._useSession(async t=>{const{data:{session:s}}=t;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((s.expires_at*1e3-e)/xc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${xc}ms, refresh threshold is ${ST} ticks`),r<=ST&&await this._callRefreshToken(s.refresh_token)})}catch(t){console.error("Auto refresh tick failed with error. This is likely a transient error.",t)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(e){if(e.isAcquireTimeout||e instanceof XF)this._debug("auto refresh token tick lock not available");else throw e}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!ls()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(e){console.error("_handleVisibilityChange",e)}}async _onVisibilityChanged(e){const t=`#_onVisibilityChanged(${e})`;this._debug(t,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),e||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(t,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(e,t,s){const r=[`provider=${encodeURIComponent(t)}`];if(s?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&r.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[i,a]=await hc(this.storage,this.storageKey),o=new URLSearchParams({code_challenge:`${encodeURIComponent(i)}`,code_challenge_method:`${encodeURIComponent(a)}`});r.push(o.toString())}if(s?.queryParams){const i=new URLSearchParams(s.queryParams);r.push(i.toString())}return s?.skipBrowserRedirect&&r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${e}?${r.join("&")}`}async _unenroll(e){try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;return i?this._returnResult({data:null,error:i}):await We(this.fetch,"DELETE",`${this.url}/factors/${e.factorId}`,{headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token})})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}}async _enroll(e){try{return await this._useSession(async t=>{var s,r;const{data:i,error:a}=t;if(a)return this._returnResult({data:null,error:a});const o=Object.assign({friendly_name:e.friendlyName,factor_type:e.factorType},e.factorType==="phone"?{phone:e.phone}:e.factorType==="totp"?{issuer:e.issuer}:{}),{data:l,error:h}=await We(this.fetch,"POST",`${this.url}/factors`,{body:o,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(e.factorType==="totp"&&l.type==="totp"&&(!((r=l?.totp)===null||r===void 0)&&r.qr_code)&&(l.totp.qr_code=`data:image/svg+xml;utf-8,${l.totp.qr_code}`),this._returnResult({data:l,error:null}))})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}}async _verify(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({data:null,error:i});const a=Object.assign({challenge_id:e.challengeId},"webauthn"in e?{webauthn:Object.assign(Object.assign({},e.webauthn),{credential_response:e.webauthn.type==="create"?e7(e.webauthn.credential_response):t7(e.webauthn.credential_response)})}:{code:e.code}),{data:o,error:l}=await We(this.fetch,"POST",`${this.url}/factors/${e.factorId}/verify`,{body:a,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return l?this._returnResult({data:null,error:l}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+o.expires_in},o)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",o),this._returnResult({data:o,error:l}))})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}})}async _challenge(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:i}=t;if(i)return this._returnResult({data:null,error:i});const a=await We(this.fetch,"POST",`${this.url}/factors/${e.factorId}/challenge`,{body:e,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});if(a.error)return a;const{data:o}=a;if(o.type!=="webauthn")return{data:o,error:null};switch(o.webauthn.type){case"create":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:Z9(o.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:Q9(o.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}})}async _challengeAndVerify(e){const{data:t,error:s}=await this._challenge({factorId:e.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:e.factorId,challengeId:t.id,code:e.code})}async _listFactors(){var e;const{data:{user:t},error:s}=await this.getUser();if(s)return{data:null,error:s};const r={all:[],phone:[],totp:[],webauthn:[]};for(const i of(e=t?.factors)!==null&&e!==void 0?e:[])r.all.push(i),i.status==="verified"&&r[i.factor_type].push(i);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var e,t;const{data:{session:s},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:i}=NS(s.access_token);let a=null;i.aal&&(a=i.aal);let o=a;((t=(e=s.user.factors)===null||e===void 0?void 0:e.filter(d=>d.status==="verified"))!==null&&t!==void 0?t:[]).length>0&&(o="aal2");const h=i.amr||[];return{data:{currentLevel:a,nextLevel:o,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?await We(this.fetch,"GET",`${this.url}/oauth/authorizations/${e}`,{headers:this.headers,jwt:s.access_token,xform:i=>({data:i,error:null})}):this._returnResult({data:null,error:new dr})})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}}async _approveAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new dr});const a=await We(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:o=>({data:o,error:null})});return a.data&&a.data.redirect_url&&ls()&&!t?.skipBrowserRedirect&&window.location.assign(a.data.redirect_url),a})}catch(s){if(Ve(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new dr});const a=await We(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:o=>({data:o,error:null})});return a.data&&a.data.redirect_url&&ls()&&!t?.skipBrowserRedirect&&window.location.assign(a.data.redirect_url),a})}catch(s){if(Ve(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;return s?this._returnResult({data:null,error:s}):t?await We(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:t.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new dr})})}catch(e){if(Ve(e))return this._returnResult({data:null,error:e});throw e}}async _revokeOAuthGrant(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?(await We(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:e.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new dr})})}catch(t){if(Ve(t))return this._returnResult({data:null,error:t});throw t}}async fetchJwk(e,t={keys:[]}){let s=t.keys.find(o=>o.kid===e);if(s)return s;const r=Date.now();if(s=this.jwks.keys.find(o=>o.kid===e),s&&this.jwks_cached_at+l9>r)return s;const{data:i,error:a}=await We(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(a)throw a;return!i.keys||i.keys.length===0||(this.jwks=i,this.jwks_cached_at=r,s=i.keys.find(o=>o.kid===e),!s)?null:s}async getClaims(e,t={}){try{let s=e;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:r,payload:i,signature:a,raw:{header:o,payload:l}}=NS(s);t?.allowExpired||A9(i.exp);const h=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,t?.keys?{keys:t.keys}:t?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:i,header:r,signature:a},error:null}}const d=R9(r.alg),p=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,p,a,b9(`${o}.${l}`)))throw new NT("Invalid JWT signature");return{data:{claims:i,header:r,signature:a},error:null}}catch(s){if(Ve(s))return this._returnResult({data:null,error:s});throw s}}}Xf.nextInstanceID={};const c7=Xf,h7="2.89.0";let vf="";typeof Deno<"u"?vf="deno":typeof document<"u"?vf="web":typeof navigator<"u"&&navigator.product==="ReactNative"?vf="react-native":vf="node";const d7={"X-Client-Info":`supabase-js-${vf}/${h7}`},f7={headers:d7},p7={schema:"public"},m7={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},g7={};function Yf(n){"@babel/helpers - typeof";return Yf=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Yf(n)}function y7(n,e){if(Yf(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(Yf(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function b7(n){var e=y7(n,"string");return Yf(e)=="symbol"?e:e+""}function x7(n,e,t){return(e=b7(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function cO(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function an(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?cO(Object(t),!0).forEach(function(s){x7(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):cO(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const w7=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),v7=()=>Headers,S7=(n,e,t)=>{const s=w7(t),r=v7();return async(i,a)=>{var o;const l=(o=await e())!==null&&o!==void 0?o:n;let h=new r(a?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${l}`),s(i,an(an({},a),{},{headers:h}))}};function T7(n){return n.endsWith("/")?n:n+"/"}function C7(n,e){var t,s;const{db:r,auth:i,realtime:a,global:o}=n,{db:l,auth:h,realtime:d,global:p}=e,m={db:an(an({},l),r),auth:an(an({},h),i),realtime:an(an({},d),a),storage:{},global:an(an(an({},p),o),{},{headers:an(an({},(t=p?.headers)!==null&&t!==void 0?t:{}),(s=o?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function N7(n){const e=n?.trim();if(!e)throw new Error("supabaseUrl is required.");if(!e.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(T7(e))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var k7=class extends c7{constructor(n){super(n)}},E7=class{constructor(n,e,t){var s,r;this.supabaseUrl=n,this.supabaseKey=e;const i=N7(n);if(!e)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",i),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",i),this.storageUrl=new URL("storage/v1",i),this.functionsUrl=new URL("functions/v1",i);const a=`sb-${i.hostname.split(".")[0]}-auth-token`,o={db:p7,realtime:g7,auth:an(an({},m7),{},{storageKey:a}),global:f7},l=C7(t??{},o);if(this.storageKey=(s=l.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(r=l.global.headers)!==null&&r!==void 0?r:{},l.accessToken)this.accessToken=l.accessToken,this.auth=new Proxy({},{get:(d,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=l.auth)!==null&&h!==void 0?h:{},this.headers,l.global.fetch)}this.fetch=S7(e,this._getAccessToken.bind(this),l.global.fetch),this.realtime=this._initRealtimeClient(an({headers:this.headers,accessToken:this._getAccessToken.bind(this)},l.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new aK(new URL("rest/v1",i).href,{headers:this.headers,schema:l.db.schema,fetch:this.fetch}),this.storage=new s9(this.storageUrl.href,this.headers,this.fetch,t?.storage),l.accessToken||this._listenForAuthEvents()}get functions(){return new tK(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,e={},t={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,e,t)}channel(n,e={config:{}}){return this.realtime.channel(n,e)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,e,t;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(e=(t=s.session)===null||t===void 0?void 0:t.access_token)!==null&&e!==void 0?e:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,storageKey:i,flowType:a,lock:o,debug:l,throwOnError:h},d,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new k7({url:this.authUrl.href,headers:an(an({},m),d),storageKey:i,autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,flowType:a,lock:o,debug:l,throwOnError:h,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new TK(this.realtimeUrl.href,an(an({},n),{},{params:an(an({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,e)=>{this._handleTokenChanged(n,"CLIENT",e?.access_token)})}_handleTokenChanged(n,e,t){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==t?(this.changedAccessToken=t,this.realtime.setAuth(t)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),e=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const ZF=(n,e,t)=>new E7(n,e,t);function I7(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const e=n.match(/^v(\d+)\./);return e?parseInt(e[1],10)<=18:!1}I7()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const QF={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_SUPABASE_ANON_KEY:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",VITE_SUPABASE_URL:"https://brrjoheinakfhohesogc.supabase.co"},C0=nM;(function(n,e){const t=nM,s=n();for(;;)try{if(parseInt(t(245))/1+-parseInt(t(241))/2*(-parseInt(t(247))/3)+parseInt(t(231))/4+-parseInt(t(238))/5*(-parseInt(t(233))/6)+-parseInt(t(244))/7*(-parseInt(t(234))/8)+parseInt(t(235))/9+-parseInt(t(246))/10===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(N0,770253);function N0(){const n=["update","24920KqRPqq","subscription_tier, stripe_customer_id, stripe_subscription_id, billing_info","select","331594vZjbMk","VITE_SUPABASE_URL","error","2327675yJfSZG","206725BmOrvF","21085680DDIAyT","3ikhHad","VITE_SUPABASE_ANON_KEY","Missing Supabase Environment Variables!","3333780sqcutO","from","312MtLNRX","8YwvcPC","9730449wXTeLg","profiles"];return N0=function(){return n},N0()}const eM=QF[C0(242)],tM=QF[C0(248)];(!eM||!tM)&&console[C0(243)](C0(249));const ma=ZF(eM,tM,{auth:{autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0}});function nM(n,e){return n=n-231,N0()[n]}const $7={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_SUPABASE_ANON_KEY:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",VITE_SUPABASE_URL:"https://brrjoheinakfhohesogc.supabase.co"},Ac=sM;(function(n,e){const t=sM,s=n();for(;;)try{if(parseInt(t(411))/1+-parseInt(t(401))/2*(-parseInt(t(393))/3)+parseInt(t(410))/4+parseInt(t(412))/5*(-parseInt(t(400))/6)+-parseInt(t(389))/7*(-parseInt(t(394))/8)+-parseInt(t(405))/9+-parseInt(t(406))/10*(parseInt(t(398))/11)===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(k0,165080);function sM(n,e){return n=n-387,k0()[n]}function k0(){const n=["error","get","2036142IRaGgZ","6680krPiYi","single","remove","select","347292ziTwdg","201246fiuWvm","44015tgWgeI","local","VITE_SUPABASE_URL","storage","subscription_tier, stripe_customer_id, stripe_subscription_id, billing_info","91YiYdUb","removeItem","Missing Supabase Environment Variables!","setItem","177843VglDoP","58168iiFTxr","set","profiles","getItem","649eTOciE","from","48FIPowo","4InniwS","undefined"];return k0=function(){return n},k0()}const rM=$7[Ac(414)],iM="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A";(!rM||!iM)&&console[Ac(403)](Ac(391));const _7={getItem:n=>{const e=Ac;return typeof chrome!==e(402)&&chrome.storage&&chrome[e(387)][e(413)]?new Promise(t=>{const s=e;chrome[s(387)][s(413)][s(404)]([n],r=>t(r[n]||null))}):localStorage[e(397)](n)},setItem:(n,e)=>{const t=Ac;typeof chrome!==t(402)&&chrome.storage&&chrome[t(387)].local?chrome[t(387)].local[t(395)]({[n]:e}):localStorage[t(392)](n,e)},removeItem:n=>{const e=Ac;typeof chrome!==e(402)&&chrome[e(387)]&&chrome[e(387)].local?chrome[e(387)][e(413)][e(408)]([n]):localStorage[e(390)](n)}},pf=ZF(rM,iM,{auth:{storage:_7,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0}}),aM=Ce.createContext(),A7=({children:n})=>{const[e,t]=Ce.useState(null),[s,r]=Ce.useState(null),[i,a]=Ce.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[o,l]=Ce.useState(!0);Ce.useEffect(()=>{p(),pf.auth.getSession().then(({data:{session:y}})=>{t(y?.user||null),y?.user?h(y.user.id,y.user.email):l(!1)});const{data:{subscription:m}}=pf.auth.onAuthStateChange((y,b)=>{t(b?.user||null),b?.user?h(b.user.id,b.user.email):(r(null),l(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await pf.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:v}=await pf.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();v||(b=w)}r(b)}catch(b){console.error("Profile fetch error:",b)}finally{l(!1)}},d=()=>{e&&h(e.id,e.email)},p=async()=>{try{const{data:m,error:y}=await pf.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&a(m)}catch(m){console.error("Neural state sync error:",m)}};return pe.jsx(aM.Provider,{value:{user:e,profile:s,neuralState:i,loading:o,refreshProfile:d,fetchNeuralState:p,setUser:t,setProfile:r,setNeuralState:a},children:n})},R7=()=>Ce.useContext(aM);(function(n,e){const t=Ra,s=n();for(;;)try{if(parseInt(t(348))/1+-parseInt(t(353))/2*(parseInt(t(355))/3)+-parseInt(t(335))/4+-parseInt(t(357))/5+parseInt(t(331))/6*(parseInt(t(340))/7)+-parseInt(t(345))/8+parseInt(t(332))/9*(parseInt(t(362))/10)===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(E0,315091);function E0(){const n=["type","sort","reduce","slice","9437630VSyZxY","every","Support","Bullish Continuation","Resistance","144nLoWVV","9ZWKDUk","filter","sqrt","1311988TWBlDf","Consolidation","price","Insufficient Data","min","105868Wwvfah","Bearish Continuation","abs","Neutral","Bullish","1084592BVbWMk","fill","max","442488UHxmtv","length","Potential Reversal (Bottom)","isArray","Potential Reversal (Top)","212050LQKvkN","Bearish","12JQzbpp","push","2732325EVGmpk"];return E0=function(){return n},E0()}const kT=(n,e)=>{const t=Ra;if(!n||n[t(349)]<e)return[];const s=[];for(let r=e-1;r<n[t(349)];r++){const i=n[t(361)](r-e+1,r+1).reduce((a,o)=>a+o,0);s[t(356)](i/e)}return s},IS=(n,e)=>{const t=Ra;if(n[t(349)]<e)return[];const s=2/(e+1);let r=[n[0]];for(let i=1;i<n[t(349)];i++)r[t(356)](n[i]*s+r[i-1]*(1-s));return r},oM=(n,e=14)=>{const t=Ra;if(n[t(349)]<e+1)return[];let s=0,r=0;for(let h=1;h<=e;h++){const d=n[h]-n[h-1];d>=0?s+=d:r+=Math[t(342)](d)}let i=s/e,a=r/e;const o=[];let l=a===0?100:i/a;o[t(356)](100-100/(1+l));for(let h=e+1;h<n.length;h++){const d=n[h]-n[h-1];d>=0?(i=(i*(e-1)+d)/e,a=(a*(e-1)+0)/e):(i=(i*(e-1)+0)/e,a=(a*(e-1)+Math[t(342)](d))/e),l=a===0?100:i/a,o[t(356)](100-100/(1+l))}return o},D7=(n,e=20,t=2)=>{const s=Ra;if(n[s(349)]<e)return[];const r=[],i=[],a=kT(n,e);for(let o=0;o<a[s(349)];o++){const l=n[s(361)](o,o+e),h=a[o],d=l.map(y=>Math.pow(y-h,2)),p=d[s(360)]((y,b)=>y+b,0)/e,m=Math[s(334)](p);i[s(356)](h+t*m),r[s(356)](h-t*m)}return{basis:a,upper:i,lower:r}},O7=(n,e=12,t=26,s=9)=>{const r=Ra,i=IS(n,e),a=IS(n,t),o=[],l=Math[r(339)](i[r(349)],a[r(349)]);for(let p=0;p<l;p++)o.push(i[p]-a[p]);const h=IS(o,s),d=[];for(let p=0;p<Math[r(339)](o[r(349)],h.length);p++)d[r(356)](o[p]-h[p]);return{macdLine:o,signalLine:h,histogram:d}};function Ra(n,e){return n=n-327,E0()[n]}const L7=n=>{const e=Ra;if(n[e(349)]<50)return{name:e(338),sentiment:e(343),confidence:0};n[n[e(349)]-1],n[n[e(349)]-2];const t=kT(n[e(361)](-20),10),s=kT(n[e(361)](-50),40),r=t[t[e(349)]-1]>s[s[e(349)]-1],{upper:i,lower:a}=D7(n,20),o=(i[i[e(349)]-1]-a[a[e(349)]-1])/n[n[e(349)]-1],l=o<.05,h=oM(n,14),d=h[h.length-1],p=d<30,m=d>70;let y=[];return l&&y[e(356)]({name:"Volatility Squeeze",sentiment:"Neutral"}),r&&!m&&y[e(356)]({name:e(329),sentiment:e(344)}),!r&&!p&&y[e(356)]({name:e(341),sentiment:e(354)}),r&&m&&y[e(356)]({name:e(352),sentiment:"Bearish"}),!r&&p&&y[e(356)]({name:e(350),sentiment:e(344)}),y.length>0?y[0]:{name:e(336),sentiment:e(343)}},F7=(n,e,t,s=14)=>{const r=Ra;let i=[];const a=Array.isArray(n)&&Array[r(351)](e)&&Array[r(351)](t),o=a||Array[r(351)](n)?n[r(349)]:0;if(o<s+1)return[];for(let p=1;p<o;p++){let m;if(a){const y=n[p],b=e[p],x=t[p-1];m=Math[r(347)](y-b,Math[r(342)](y-x),Math.abs(b-x))}else{const y=n[p],b=n[p-1],x=Math[r(342)](y-b);m=Math.max(x,y*.0075)}i[r(356)](m)}const l=[];let h=i.slice(0,s)[r(360)]((p,m)=>p+m,0)/s;l[r(356)](h);for(let p=s;p<i[r(349)];p++){const m=(l[l.length-1]*(s-1)+i[p])/s;l[r(356)](m)}return[...new Array(o-l[r(349)])[r(346)](l[0]),...l]},M7=(n,e,t)=>{const s=Ra,r=Array[s(351)](n)?n:[];if(r[s(349)]<20)return{support:Math.min(...r),resistance:Math[s(347)](...r),strength:{s:1,r:1}};const i=Array.isArray(e)&&Array[s(351)](t)&&e[s(349)]===r[s(349)],a=[],o=5;for(let m=o;m<r[s(349)]-o;m++)if(i){const y=e[s(361)](m-o,m+o+1),b=e[m];y[s(327)](v=>v<=b)&&a[s(356)]({price:b,type:"Resistance"});const x=t[s(361)](m-o,m+o+1),w=t[m];x[s(327)](v=>v>=w)&&a.push({price:w,type:"Support"})}else{const y=r[s(361)](m-o,m+o+1),b=r[m],x=y[s(327)](v=>v<=b),w=y.every(v=>v>=b);x&&a.push({price:b,type:s(330)}),w&&a[s(356)]({price:b,type:s(328)})}const l=r[r[s(349)]-1],h=(m,y)=>{const b=s,x=a.filter(N=>N[b(358)]===m&&(m===b(328)?N[b(337)]<y:N.price>y));if(x[b(349)]===0)return{price:m===b(328)?Math.min(...r):Math[b(347)](...r),strength:1};const w=x[b(359)]((N,k)=>Math.abs(N[b(337)]-y)-Math[b(342)](k[b(337)]-y)),v=w[0][b(337)],C=a[b(333)](N=>N[b(358)]===m&&Math[b(342)](N.price-v)/v<.005)[b(349)];return{price:v,strength:Math[b(339)](5,C)}},d=h(s(328),l),p=h(s(330),l);return{support:d[s(337)],resistance:p.price,strength:{s:d.strength,r:p.strength}}};const z7=1e-7,P7=1e-4;class h2{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class pb{refCount(e){return js("refCount")}incRef(e){return js("incRef")}timerAvailable(){return!0}time(e){return js("time")}read(e){return js("read")}readSync(e){return js("readSync")}readToGPU(e,t){return js("readToGPU")}numDataIds(){return js("numDataIds")}disposeData(e,t){return js("disposeData")}write(e,t,s){return js("write")}move(e,t,s,r,i){return js("move")}createTensorFromGPUData(e,t,s){return js("createTensorFromGPUData")}memory(){return js("memory")}floatPrecision(){return js("floatPrecision")}epsilon(){return this.floatPrecision()===32?z7:P7}dispose(){return js("dispose")}}function js(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function d2(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,xa(n,e,t)}function B7(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,xa(n,t,s),xa(e,t,s)}function Io(n,e,t){return Math.max(n,Math.min(e,t))}function mb(n){return n%2===0?n:n+1}function xa(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function lM(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function V7(n,e){const t=Math.random();return e*t+(1-t)*n}function U7(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function O(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Jn(n,e,t=""){O(at(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function lu(n){O(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function he(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function j7(n){return n.length===0}function uM(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function at(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Wl(n){return n%1===0}function W7(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function I0(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function G7(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return d2(e),e}function Pl(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function ET(n,e=r=>0,t,s){return new Promise((r,i)=>{let a=0;const o=()=>{if(n()){r();return}a++;const l=e(a);if(t!=null&&a>=t){i();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function f2(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function st(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),O(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),O(n.every(s=>Wl(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Da(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:st(e,n).sort();let a=0;for(let o=0;o<n.length;++o){if(i!=null){if(i[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(i[a]==null||i[a]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),i[a]<=o&&a++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function zn(n,e){return tn(n,e)}function tn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function cM(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function hM(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function p2(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Jf(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function dM(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Di(n){return typeof n=="string"||n instanceof String}function fM(n){return typeof n=="boolean"}function $0(n){return typeof n=="number"}function uu(n){return Array.isArray(n)?uu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":$0(n)?"float32":Di(n)?"string":fM(n)?"bool":"float32"}function $o(n){return!!(n&&n.constructor&&n.call&&n.apply)}function _0(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Be(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function pM(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let a=0;a<i;a++)r[a]=t[n+a]}else{const i=e[0],a=e.slice(1),o=a.reduce((l,h)=>l*h)*(s?2:1);for(let l=0;l<i;l++)r[l]=pM(n+l*o,a,t,s)}return r}function vr(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return pM(0,n,e,t)}function mM(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function gb(n,e){const t=Yn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Yn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function m2(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return vr(n,new Float32Array(t));if(e==="int32")return vr(n,new Int32Array(t));if(e==="bool")return vr(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function tr(n){n.forEach(e=>{O(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function di(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function cu(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Ca(n){return n&&n.then&&typeof n.then=="function"}const hO="tfjsflags";class gM{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=H7,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ca(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);hO in e&&e[hO].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=K7(r,i)})}}function H7(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(q7(e,s[0],s[1]),s.join("="))),e}function q7(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function K7(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ae(){return g2}let g2=null;function X7(n){g2=n}let $S;function yM(){if($S==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");$S=n}return $S}function Y7(){const n=yM();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function y2(n,e){const t=Y7();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const Sp="Abs",eh="Acos",th="Acosh",hu="Add",Tp="AddN",yb="All",bb="Any",Cp="ArgMax",Np="ArgMin",nh="Asin",sh="Asinh",rh="Atan",ih="Atanh",ah="Atan2",kp="AvgPool",xb="AvgPoolGrad",Ep="AvgPool3D",wb="AvgPool3DGrad",Ip="BatchMatMul",$p="BatchToSpaceND",vb="Bincount",_p="BitwiseAnd",bM="BroadcastTo",Sb="BroadcastArgs",oh="Cast",lh="Ceil",uh="ClipByValue",Tb="Complex",Ap="ComplexAbs",Rp="Concat",Dp="Conv2D",Cb="Conv2DBackpropFilter",Op="Conv2DBackpropInput",Lp="Conv3D",Nb="Conv3DBackpropFilterV2",kb="Conv3DBackpropInputV2",ch="Cos",hh="Cosh",Eb="Cumprod",Fp="Cumsum",Ib="CropAndResize",$b="DenseBincount",_b="DepthToSpace",Mp="DepthwiseConv2dNative",Ab="DepthwiseConv2dNativeBackpropFilter",Rb="DepthwiseConv2dNativeBackpropInput",Db="Diag",zp="Dilation2D",A0="Dilation2DBackpropInput",R0="Dilation2DBackpropFilter",Ob="Draw",dh="RealDiv",Lb="Einsum",fh="Elu",Fb="EluGrad",ph="Erf",Pp="Equal",mh="Exp",Bp="ExpandDims",gh="Expm1",Mb="FFT",zb="Fill",Pb="FlipLeftRight",yh="Floor",bh="FloorDiv",Vp="FusedBatchNorm",Up="GatherV2",Bb="GatherNd",jp="Greater",xh="GreaterEqual",wh="Identity",Vb="IFFT",Ub="Imag",vh="IsFinite",Sh="IsInf",Th="IsNan",Wp="LeakyRelu",Gp="Less",Hp="LessEqual",jb="LinSpace",Ch="Log",Nh="Log1p",qp="LogicalAnd",Kp="LogicalNot",Xp="LogicalOr",J7="LogicalXor",xM="LogSoftmax",Z7="LowerBound",Yp="LRN",Wb="LRNGrad",Q7="MatrixBandPart",Jp="Max",kh="Maximum",Zp="MaxPool",Gb="MaxPoolGrad",Qp="MaxPool3D",Hb="MaxPool3DGrad",qb="MaxPoolWithArgmax",em="Mean",tm="Min",Eh="Minimum",nm="MirrorPad",Ih="Mod",Kb="Multinomial",$h="Multiply",sm="Neg",rm="NotEqual",Xb="NonMaxSuppressionV3",Yb="NonMaxSuppressionV4",Jb="NonMaxSuppressionV5",im="OnesLike",am="OneHot",om="Pack",lm="PadV2",eX="Pool",_h="Pow",um="Prelu",cm="Prod",Zb="RaggedGather",Qb="RaggedRange",ex="RaggedTensorToTensor",tx="Range",nx="Real",Ah="Reciprocal",Rh="Relu",hm="Reshape",dm="ResizeNearestNeighbor",sx="ResizeNearestNeighborGrad",fm="ResizeBilinear",rx="ResizeBilinearGrad",Dh="Relu6",pm="Reverse",Oh="Round",Lh="Rsqrt",ix="ScatterNd",ax="TensorScatterUpdate",ox="SearchSorted",mm="Select",Fh="Selu",gm="Slice",Mh="Sin",zh="Sinh",Ph="Sign",Bh="Sigmoid",Vh="Softplus",Uh="Sqrt",ym="Sum",bm="SpaceToBatchND",xm="SplitV",wm="Softmax",lx="SparseFillEmptyRows",ux="SparseReshape",cx="SparseSegmentMean",hx="SparseSegmentSum",dx="SparseToDense",jh="SquaredDifference",fx="Square",vm="StaticRegexReplace",px="StridedSlice",mx="StringNGrams",gx="StringSplit",yx="StringToHashBucketFast",Wh="Sub",Gh="Tan",Hh="Tanh",qh="Tile",bx="TopK",xx="Transform",Bl="Transpose",wx="Unique",Sm="Unpack",Tm="UnsortedSegmentSum",tX="UpperBound",Cm="ZerosLike",Kh="Step",D0="FromPixels",vx="RotateWithOffset",Zf="_FusedMatMul",Qf="FusedConv2D",ep="FusedDepthwiseConv2D";function gr(...n){ae().getBool("IS_TEST")||ae().getBool("PROD")||console.warn(...n)}function nX(...n){ae().getBool("IS_TEST")||ae().getBool("PROD")||console.log(...n)}const Mc=y2("kernelRegistry",()=>new Map),tp=y2("gradRegistry",()=>new Map);function np(n,e){const t=b2(n,e);return Mc.get(t)}function IT(n){return tp.get(n)}function O0(n){const e=Mc.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===n&&t.push(a)}return t}function Sx(n){const{kernelName:e,backendName:t}=n,s=b2(e,t);Mc.has(s)&&gr(`The kernel '${e}' for backend '${t}' is already registered`),Mc.set(s,n)}function wM(n){const{kernelName:e}=n;tp.has(e)&&ae().getBool("DEBUG")&&gr(`Overriding the gradient for '${e}'`),tp.set(e,n)}function sX(n,e){const t=b2(n,e);if(!Mc.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Mc.delete(t)}function rX(n){if(!tp.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);tp.delete(n)}function iX(n,e){O0(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});Sx(r)})}function b2(n,e){return`${e}_${n}`}function vM(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var _S,dO;function aX(){if(dO)return _S;dO=1,_S=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(F,_,V){this.low=F|0,this.high=_|0,this.unsigned=!!V}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(F){return(F&&F.__isLong__)===!0}e.isLong=t;var s={},r={};function i(F,_){var V,Q,ne;return _?(F>>>=0,(ne=0<=F&&F<256)&&(Q=r[F],Q)?Q:(V=o(F,(F|0)<0?-1:0,!0),ne&&(r[F]=V),V)):(F|=0,(ne=-128<=F&&F<128)&&(Q=s[F],Q)?Q:(V=o(F,F<0?-1:0,!1),ne&&(s[F]=V),V))}e.fromInt=i;function a(F,_){if(isNaN(F))return _?C:v;if(_){if(F<0)return C;if(F>=b)return R}else{if(F<=-x)return D;if(F+1>=x)return A}return F<0?a(-F,_).neg():o(F%y|0,F/y|0,_)}e.fromNumber=a;function o(F,_,V){return new e(F,_,V)}e.fromBits=o;var l=Math.pow;function h(F,_,V){if(F.length===0)throw Error("empty string");if(F==="NaN"||F==="Infinity"||F==="+Infinity"||F==="-Infinity")return v;if(typeof _=="number"?(V=_,_=!1):_=!!_,V=V||10,V<2||36<V)throw RangeError("radix");var Q;if((Q=F.indexOf("-"))>0)throw Error("interior hyphen");if(Q===0)return h(F.substring(1),_,V).neg();for(var ne=a(l(V,8)),Z=v,B=0;B<F.length;B+=8){var U=Math.min(8,F.length-B),K=parseInt(F.substring(B,B+U),V);if(U<8){var X=a(l(V,U));Z=Z.mul(X).add(a(K))}else Z=Z.mul(ne),Z=Z.add(a(K))}return Z.unsigned=_,Z}e.fromString=h;function d(F,_){return typeof F=="number"?a(F,_):typeof F=="string"?h(F,_):o(F.low,F.high,typeof _=="boolean"?_:F.unsigned)}e.fromValue=d;var p=65536,m=1<<24,y=p*p,b=y*y,x=b/2,w=i(m),v=i(0);e.ZERO=v;var C=i(0,!0);e.UZERO=C;var N=i(1);e.ONE=N;var k=i(1,!0);e.UONE=k;var E=i(-1);e.NEG_ONE=E;var A=o(-1,2147483647,!1);e.MAX_VALUE=A;var R=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=R;var D=o(0,-2147483648,!1);e.MIN_VALUE=D;var L=e.prototype;return L.toInt=function(){return this.unsigned?this.low>>>0:this.low},L.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},L.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(D)){var V=a(_),Q=this.div(V),ne=Q.mul(V).sub(this);return Q.toString(_)+ne.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var Z=a(l(_,6),this.unsigned),B=this,U="";;){var K=B.div(Z),X=B.sub(K.mul(Z)).toInt()>>>0,se=X.toString(_);if(B=K,B.isZero())return se+U;for(;se.length<6;)se="0"+se;U=""+se+U}},L.getHighBits=function(){return this.high},L.getHighBitsUnsigned=function(){return this.high>>>0},L.getLowBits=function(){return this.low},L.getLowBitsUnsigned=function(){return this.low>>>0},L.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,V=31;V>0&&(_&1<<V)==0;V--);return this.high!=0?V+33:V+1},L.isZero=function(){return this.high===0&&this.low===0},L.eqz=L.isZero,L.isNegative=function(){return!this.unsigned&&this.high<0},L.isPositive=function(){return this.unsigned||this.high>=0},L.isOdd=function(){return(this.low&1)===1},L.isEven=function(){return(this.low&1)===0},L.equals=function(_){return t(_)||(_=d(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},L.eq=L.equals,L.notEquals=function(_){return!this.eq(_)},L.neq=L.notEquals,L.ne=L.notEquals,L.lessThan=function(_){return this.comp(_)<0},L.lt=L.lessThan,L.lessThanOrEqual=function(_){return this.comp(_)<=0},L.lte=L.lessThanOrEqual,L.le=L.lessThanOrEqual,L.greaterThan=function(_){return this.comp(_)>0},L.gt=L.greaterThan,L.greaterThanOrEqual=function(_){return this.comp(_)>=0},L.gte=L.greaterThanOrEqual,L.ge=L.greaterThanOrEqual,L.compare=function(_){if(t(_)||(_=d(_)),this.eq(_))return 0;var V=this.isNegative(),Q=_.isNegative();return V&&!Q?-1:!V&&Q?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},L.comp=L.compare,L.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(N)},L.neg=L.negate,L.add=function(_){t(_)||(_=d(_));var V=this.high>>>16,Q=this.high&65535,ne=this.low>>>16,Z=this.low&65535,B=_.high>>>16,U=_.high&65535,K=_.low>>>16,X=_.low&65535,se=0,P=0,j=0,te=0;return te+=Z+X,j+=te>>>16,te&=65535,j+=ne+K,P+=j>>>16,j&=65535,P+=Q+U,se+=P>>>16,P&=65535,se+=V+B,se&=65535,o(j<<16|te,se<<16|P,this.unsigned)},L.subtract=function(_){return t(_)||(_=d(_)),this.add(_.neg())},L.sub=L.subtract,L.multiply=function(_){if(this.isZero())return v;if(t(_)||(_=d(_)),n){var V=n.mul(this.low,this.high,_.low,_.high);return o(V,n.get_high(),this.unsigned)}if(_.isZero())return v;if(this.eq(D))return _.isOdd()?D:v;if(_.eq(D))return this.isOdd()?D:v;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(w)&&_.lt(w))return a(this.toNumber()*_.toNumber(),this.unsigned);var Q=this.high>>>16,ne=this.high&65535,Z=this.low>>>16,B=this.low&65535,U=_.high>>>16,K=_.high&65535,X=_.low>>>16,se=_.low&65535,P=0,j=0,te=0,le=0;return le+=B*se,te+=le>>>16,le&=65535,te+=Z*se,j+=te>>>16,te&=65535,te+=B*X,j+=te>>>16,te&=65535,j+=ne*se,P+=j>>>16,j&=65535,j+=Z*X,P+=j>>>16,j&=65535,j+=B*K,P+=j>>>16,j&=65535,P+=Q*se+ne*X+Z*K+B*U,P&=65535,o(te<<16|le,P<<16|j,this.unsigned)},L.mul=L.multiply,L.divide=function(_){if(t(_)||(_=d(_)),_.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var V=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,_.low,_.high);return o(V,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?C:v;var Q,ne,Z;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return C;if(_.gt(this.shru(1)))return k;Z=C}else{if(this.eq(D)){if(_.eq(N)||_.eq(E))return D;if(_.eq(D))return N;var B=this.shr(1);return Q=B.div(_).shl(1),Q.eq(v)?_.isNegative()?N:E:(ne=this.sub(_.mul(Q)),Z=Q.add(ne.div(_)),Z)}else if(_.eq(D))return this.unsigned?C:v;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();Z=v}for(ne=this;ne.gte(_);){Q=Math.max(1,Math.floor(ne.toNumber()/_.toNumber()));for(var U=Math.ceil(Math.log(Q)/Math.LN2),K=U<=48?1:l(2,U-48),X=a(Q),se=X.mul(_);se.isNegative()||se.gt(ne);)Q-=K,X=a(Q,this.unsigned),se=X.mul(_);X.isZero()&&(X=N),Z=Z.add(X),ne=ne.sub(se)}return Z},L.div=L.divide,L.modulo=function(_){if(t(_)||(_=d(_)),n){var V=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,_.low,_.high);return o(V,n.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},L.mod=L.modulo,L.rem=L.modulo,L.not=function(){return o(~this.low,~this.high,this.unsigned)},L.and=function(_){return t(_)||(_=d(_)),o(this.low&_.low,this.high&_.high,this.unsigned)},L.or=function(_){return t(_)||(_=d(_)),o(this.low|_.low,this.high|_.high,this.unsigned)},L.xor=function(_){return t(_)||(_=d(_)),o(this.low^_.low,this.high^_.high,this.unsigned)},L.shiftLeft=function(_){return t(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?o(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):o(0,this.low<<_-32,this.unsigned)},L.shl=L.shiftLeft,L.shiftRight=function(_){return t(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?o(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):o(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},L.shr=L.shiftRight,L.shiftRightUnsigned=function(_){if(t(_)&&(_=_.toInt()),_&=63,_===0)return this;var V=this.high;if(_<32){var Q=this.low;return o(Q>>>_|V<<32-_,V>>>_,this.unsigned)}else return _===32?o(V,0,this.unsigned):o(V>>>_-32,0,this.unsigned)},L.shru=L.shiftRightUnsigned,L.shr_u=L.shiftRightUnsigned,L.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},L.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},L.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},L.toBytesLE=function(){var _=this.high,V=this.low;return[V&255,V>>>8&255,V>>>16&255,V>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},L.toBytesBE=function(){var _=this.high,V=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,V>>>24,V>>>16&255,V>>>8&255,V&255]},e.fromBytes=function(_,V,Q){return Q?e.fromBytesLE(_,V):e.fromBytesBE(_,V)},e.fromBytesLE=function(_,V){return new e(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,V)},e.fromBytesBE=function(_,V){return new e(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],V)},_S}var SM=aX();const TM=NC(SM),oX=_G({__proto__:null,default:TM},[SM]);const El=TM||oX;function Nm(n){return El.fromString(n,!0,16)}const CM=Nm("c3a5c85c97cb3127"),Tl=Nm("b492b66fbe98f273"),ps=Nm("9ae16a3b2f90404f");function $T(n){return n.xor(n.shru(47))}function NM(n,e,t){const s=n.slice(e,e+t);return El.fromBytes(Array.from(s),!0,!0)}function Ft(n,e){return NM(n,e,8)}function fO(n,e){return NM(n,e,4)}function Ln(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function So(n,e,t=Nm("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function lX(n,e,t,s,r,i){r=r.add(n),i=Ln(i.add(r).add(s),21);const a=r;return r=r.add(e),r=r.add(t),i=i.add(Ln(r,44)),[r.add(s),i.add(a)]}function Oy(n,e,t,s){return lX(Ft(n,e),Ft(n,e+8),Ft(n,e+16),Ft(n,e+24),t,s)}function uX(n,e=n.length){if(e>=8){const t=ps.add(e*2),s=Ft(n,0).add(ps),r=Ft(n,e-8),i=Ln(r,37).mul(t).add(s),a=Ln(s,25).add(r).mul(t);return So(i,a,t)}if(e>=4){const t=ps.add(e*2),s=fO(n,0);return So(s.shl(3).add(e),fO(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),a=e+(r<<2);return $T(ps.mul(i).xor(CM.mul(a))).mul(ps)}return ps}function cX(n,e=n.length){const t=ps.add(e*2),s=Ft(n,0).mul(Tl),r=Ft(n,8),i=Ft(n,e-8).mul(t),a=Ft(n,e-16).mul(ps);return So(Ln(s.add(r),43).add(Ln(i,30)).add(a),s.add(Ln(r.add(ps),18)).add(i),t)}function hX(n,e=n.length){const t=ps.add(e*2),s=Ft(n,0).mul(ps),r=Ft(n,8),i=Ft(n,e-8).mul(t),a=Ft(n,e-16).mul(ps),o=Ln(s.add(r),43).add(Ln(i,30)).add(a),l=So(o,s.add(Ln(r.add(ps),18)).add(i),t),h=Ft(n,16).mul(t),d=Ft(n,24),p=o.add(Ft(n,e-32)).mul(t),m=l.add(Ft(n,e-24)).mul(t);return So(Ln(h.add(d),43).add(Ln(p,30)).add(m),h.add(Ln(d.add(s),18)).add(p),t)}function kM(n,e=n.length){const t=El.fromNumber(81,!0);if(e<=32)return e<=16?uX(n,e):cX(n,e);if(e<=64)return hX(n,e);let s=t,r=t.mul(Tl).add(113),i=$T(r.mul(ps).add(113)).mul(ps),a=[El.UZERO,El.UZERO],o=[El.UZERO,El.UZERO];s=s.mul(ps).add(Ft(n,0));let l=0;const h=(e-1>>6)*64,d=h+(e-1&63)-63;do s=Ln(s.add(r).add(a[0]).add(Ft(n,l+8)),37).mul(Tl),r=Ln(r.add(a[1]).add(Ft(n,l+48)),42).mul(Tl),s=s.xor(o[1]),r=r.add(a[0]).add(Ft(n,l+40)),i=Ln(i.add(o[0]),33).mul(Tl),a=Oy(n,l,a[1].mul(Tl),s.add(o[0])),o=Oy(n,l+32,i.add(o[1]),r.add(Ft(n,l+16))),[i,s]=[s,i],l+=64;while(l!==h);const p=Tl.add(i.and(255).shl(1));return l=d,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=Ln(s.add(r).add(a[0]).add(Ft(n,l+8)),37).mul(p),r=Ln(r.add(a[1]).add(Ft(n,l+48)),42).mul(p),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add(Ft(n,l+40))),i=Ln(i.add(o[0]),33).mul(p),a=Oy(n,l,a[1].mul(p),s.add(o[0])),o=Oy(n,l+32,i.add(o[1]),r.add(Ft(n,l+16))),[i,s]=[s,i],So(So(a[0],o[0],p).add($T(r).mul(CM)).add(i),So(a[1],o[1],p).add(s),p)}function Oa(n,e){return e==="string"?Mi(n):Bo([n],e)}function dX(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Bo(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ui(n)),ae().getBool("DEBUG")&&cM(n,e),dX(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Gn(){return ae().platform.now()}function EM(n,e){return ae().platform.fetch(n,e)}function Mi(n,e="utf-8"){return e=e||"utf-8",ae().platform.encode(n,e)}function Na(n,e="utf-8"){return e=e||"utf-8",ae().platform.decode(n,e)}function kn(n){return ae().platform.isTypedArray!=null?ae().platform.isTypedArray(n):vM(n)}function Ui(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Ca(n)||n==null||kn(n)&&t)e.push(n);else if(Array.isArray(n)||kn(n))for(let s=0;s<n.length;++s)Ui(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ui(n[r],e,t)}return e}const fX=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:at,arraysEqualWithNull:uM,assert:O,assertNonNegativeIntegerDimensions:tr,assertNonNull:lu,assertShapesMatch:Jn,bytesFromStringArray:dM,bytesPerElement:Jf,checkConversionForErrors:cM,clamp:Io,computeStrides:Be,convertBackendValuesAndArrayBuffer:mM,createScalarValue:Oa,createShuffledIndices:G7,decodeString:Na,distSquared:U7,encodeString:Mi,fetch:EM,fingerPrint64:kM,flatten:Ui,getArrayFromDType:tn,getTypedArrayFromDType:zn,hasEncodingLoss:p2,hexToLong:Nm,indexToLoc:cu,inferDtype:uu,inferFromImplicitShape:f2,isBoolean:fM,isFunction:$o,isInt:Wl,isNumber:$0,isPromise:Ca,isScalarShape:j7,isString:Di,isTypedArray:kn,isValidDtype:hM,locToIndex:di,makeOnesTypedArray:gb,makeZerosNestedTypedArray:m2,makeZerosTypedArray:Yn,nearestDivisor:_0,nearestLargerEven:mb,now:Gn,parseAxisParam:st,randUniform:V7,repeatedTry:ET,rightPad:Pl,shuffle:d2,shuffleCombo:B7,sizeFromShape:he,sizeToSquarishShape:I0,squeezeShape:Da,sum:lM,swap:xa,tanh:W7,toNestedArray:vr,toTypedArray:Bo},Symbol.toStringTag,{value:"Module"}));class pX{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new gX)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let a;const o=Gn();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const h of r)h.dataSync();a=Promise.resolve({kernelMs:Gn()-o})}if(ae().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(p=>{mX(p,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(h=>h.kernelMs),extraInfo:a.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:a}=e;s.forEach(o=>{Promise.all([o.data(),r,a]).then(l=>{this.logger.logKernelProfile(t,o,l[0],l[1],i,l[2])})})}}function mX(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class gX{logKernelProfile(e,t,s,r,i,a){const o=typeof r=="number"?Pl(`${r}ms`,9):r.error,l=Pl(e,25),h=t.rank,d=t.size,p=Pl(t.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const x=b.shape||t.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${l}	%c${o}	%c${h}D ${p}	%c${d}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function yX(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const h=n[l],d=h.inputs;for(const p in d){const m=d[p];let y=!1;for(let b=0;b<e.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const i={};i[t.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const h=n[l],d=h.inputs;for(let p=0;p<h.outputs.length;p++)if(i[h.outputs[p].id]){for(const m in d)i[d[m].id]=!0,a[h.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const h=n[l];if(r[h.id]&&a[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const p=Object.assign({},h);p.inputs=d,p.outputs=h.outputs,o.push(p)}}return o}function bX(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],a=[];if(i.outputs.forEach(l=>{const h=n[l.id];h!=null?a.push(h):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const l in i.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const h=t(()=>o[l]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${h.dtype}'`);const d=i.inputs[l];if(!at(h.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const p=n[d.id];n[d.id]=s(p,h),p.dispose()}}}}const pO=20,mf=3,AS=7;function xX(n,e,t,s){const r=Be(e),i=wX(n,e,t,r),a=e.length,o=Qy(n,e,t,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(h=>"    "+h).join(`
`)),l.join(`
`)}function wX(n,e,t,s){const r=he(e),i=s[s.length-1],a=new Array(i).fill(0),o=e.length,l=t==="complex64"?Tf(n):n;if(o>1)for(let h=0;h<r/i;h++){const d=h*i;for(let p=0;p<i;p++)a[p]=Math.max(a[p],Sf(l[d+p],0,t).length)}return a}function Sf(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(AS))} + ${parseFloat(n[1].toFixed(AS))}j`:Di(n)?s=`'${n}'`:t==="bool"?s=IM(n):s=parseFloat(n.toFixed(AS)).toString(),Pl(s,e)}function IM(n){return n===0?"false":"true"}function Qy(n,e,t,s,r,i=!0){const a=t==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(t==="complex64"){const x=Tf(n);return[Sf(x[0],0,t)]}return t==="bool"?[IM(n[0])]:[n[0].toString()]}if(l===1){if(o>pO){const w=mf*a;let v=Array.from(n.slice(0,w)),C=Array.from(n.slice((o-mf)*a,o*a));return t==="complex64"&&(v=Tf(v),C=Tf(C)),["["+v.map((N,k)=>Sf(N,r[k],t)).join(", ")+", ..., "+C.map((N,k)=>Sf(N,r[o-mf+k],t)).join(", ")+"]"]}return["["+(t==="complex64"?Tf(n):Array.from(n)).map((w,v)=>Sf(w,r[v],t)).join(", ")+"]"]}const h=e.slice(1),d=s.slice(1),p=s[0]*a,m=[];if(o>pO){for(let x=0;x<mf;x++){const w=x*p,v=w+p;m.push(...Qy(n.slice(w,v),h,t,d,r,!1))}m.push("...");for(let x=o-mf;x<o;x++){const w=x*p,v=w+p;m.push(...Qy(n.slice(w,v),h,t,d,r,x===o-1))}}else for(let x=0;x<o;x++){const w=x*p,v=w+p;m.push(...Qy(n.slice(w,v),h,t,d,r,x===o-1))}const y=l===2?",":"";m[0]="["+(o>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<l;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function Tf(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class bn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=he(e),s!=null){const r=s.length;O(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||tn(t,this.size),this.strides=Be(e)}set(e,...t){t.length===0&&(t=[0]),O(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ci().makeTensor(this.values,this.shape,this.dtype)}}let ci=null,vc=null;function vX(n){ci=n}function SX(n){vc=n}class bt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=he(e),this.strides=Be(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return vc.buffer(this.shape,this.dtype,e)}bufferSync(){return vc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return vr(this.shape,e,this.dtype==="complex64")}arraySync(){return vr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ci().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Na(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ci().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ci().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Na(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ci().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ci().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return vc.print(this,e)}clone(){return this.throwIfDisposed(),vc.clone(this)}toString(e=!1){const t=this.dataSync();return xX(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),vc.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),ci().makeVariable(this,e,t,s)}}Object.defineProperty(bt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function fe(){return y2("Tensor",()=>bt)}fe();class sp extends bt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!at(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ci().disposeTensor(this),this.dataId=e.dataId,ci().incRef(this,null)}dispose(){ci().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(sp,Symbol.hasInstance,{value:n=>n instanceof bt&&n.assign!=null&&n.assign instanceof Function});var _T;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(_T||(_T={}));var AT;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(AT||(AT={}));var RT;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(RT||(RT={}));var DT;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(DT||(DT={}));var OT;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(OT||(OT={}));const TX={float32:DT,int32:AT,bool:RT,complex64:OT};function _s(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return TX[n][e]}function Tx(n){return _s(n,"int32")}function $M(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function _M(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Jt(n,e){if(n.dtype===e.dtype)return[n,e];const t=_s(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function AM(n,e){O(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Cx(n,e){return e.some(t=>t.id===n.id)}function ka(n){const e=[];return RM(n,e,new Set),e}function RM(n,e,t){if(n==null)return;if(n instanceof bt){e.push(n);return}if(!CX(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),RM(i,e,t))}}function CX(n){return Array.isArray(n)||typeof n=="object"}const NX=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:AM,getTensorsInContainer:ka,isTensorInList:Cx,makeTypesMatch:Jt},Symbol.toStringTag,{value:"Module"}));function RS(n){return n.kernelName!=null}class mO{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class zc{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new mO}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(gr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new pX(this.backendInstance),!0}setupRegisteredKernels(){O0(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){O0(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof pb)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,gr(`Initialization of backend ${e} failed`),gr(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return gr(`Initialization of backend ${e} failed`),gr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return zc.nextTensorId++}nextVariableId(){return zc.nextVariableId++}clone(e){const t=W.runKernel(wh,{x:e}),s={x:e},r=a=>({x:()=>{const o="float32",l={x:a},h={dtype:o};return W.runKernel(oh,l,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(np(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-i-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const h=RS(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(RS(e)){const{kernelName:b,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const v=np(b,this.backendName);O(v!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),o=()=>{const C=this.backend.numDataIds();l=v.kernelFunc({inputs:x,attrs:w,backend:this.backend});const N=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,C,N);const k=N.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(b,x,k);s=this.saveTensorsForBackwardMode(E)}return k}}else{const{forwardFunc:b}=e,x=w=>{r&&(s=w.map(v=>this.keep(this.clone(v))))};o=()=>{const w=this.backend.numDataIds();l=this.tidy(()=>b(this.backend,x));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,v),v}}const{inputs:d,attrs:p}=e,m=RS(e)?null:e.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(y=this.profiler.profileKernel(h,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),t=y.outputs)}),r&&this.addTapeNode(h,d,t,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=IT(e);if(r!=null){const i=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(O(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(h=>t[h])):o=i.map(h=>t[h]);const l=s.filter((h,d)=>a[d]);return o.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&Di(e[0])&&(i=e.map(l=>Mi(l)));const a=r.write(i,t,s),o=new bt(t,s,a,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const l=this.state.tensorInfo.get(a),h=dM(i);this.state.numBytes+=h-l.bytes,l.bytes=h}return o}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:i}=e,a=new bt(r,i,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new sp(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Jf(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof sp||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Jf(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},l=IT(e);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=h=>(h=h.map((d,p)=>{if(d==null){const m=s[p],y=Yn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],i,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=ka(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(O(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));O(i instanceof bt,()=>"The result y returned by f() must be a tensor.");const a=yX(this.state.activeTape,t,i);if(!r&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[i.id]=s??kX(i.shape),bX(o,a,h=>this.tidy(h),EX);const l=t.map(h=>o[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return O($o(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{O(t.every(o=>o instanceof bt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((o,l)=>{r[l]=o});const i=(o,l)=>(s=e(...t,l),O(s.value instanceof bt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),O($o(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,l)=>{const h=s.gradFunc(o,l),d=Array.isArray(h)?h:[h];O(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),O(d.every(m=>m instanceof bt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,y)=>{p[y]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Gn(),s=await this.backend.time(e);return s.wallMs=Gn()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new mO;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}zc.nextTensorId=0;zc.nextVariableId=0;function kX(n){const e=gb(he(n),"float32");return W.makeTensor(e,n,"float32")}function DM(){const n=yM();if(n._tfengine==null){const e=new gM(n);n._tfengine=new zc(e)}return X7(n._tfengine.ENV),vX(()=>n._tfengine),n._tfengine}const W=DM();function EX(n,e){const t={a:n,b:e};return W.runKernel(hu,t)}function IX(){return typeof navigator<"u"&&navigator!=null}let LT;function $X(n){LT=n}function x2(n){if(LT!==void 0)return LT;if(n||IX()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function w2(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const _X=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:w2,isMobile:x2,mockIsMobile:$X},Symbol.toStringTag,{value:"Module"}));const As=ae();As.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});As.registerFlag("IS_BROWSER",()=>w2());As.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");As.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));As.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));As.registerFlag("PROD",()=>!1);As.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>As.getBool("DEBUG"));As.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);As.registerFlag("IS_TEST",()=>!1);As.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>As.getBool("DEBUG"));As.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);As.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);As.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function ji(n,e){let t=n;if(kn(n))return e==="string"?[]:[n.length];if($M(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(_M(n))return[n.buffer.size/(e==null?4:Jf(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||kn(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ae().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&OM(n,s,[]),s}function OM(n,e,t){if(t=t||[],!Array.isArray(n)&&!kn(n)){O(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}O(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),O(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)OM(n[r],s,t.concat(r))}function gO(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function M(n,e,t,s="numeric"){if(n instanceof fe())return gO(s,n.dtype,e,t),n;let r=uu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),gO(s,r,e,t),n==null||!kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=ji(n,r);!kn(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?Bo(n,r):Ui(n,[],!0);return W.makeTensor(o,i,r)}function rp(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,a)=>M(i,`${e}[${a}]`,t,s))}const v2="__op";function G(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+v2;const r=(...i)=>{W.startScope(t);try{const a=s(...i);return Ca(a)&&console.error("Cannot return a Promise inside of tidy."),W.endScope(a),a}catch(a){throw W.endScope(null),a}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function AX(n,e){const t=M(n,"real","complex"),s=M(e,"imag","complex");Jn(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return W.runKernel(Tb,r)}const Ea=G({complex_:AX});function Vo(n,e,t,s){if(s==null)s=uu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(_M(n)||$M(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return W.backend.createTensorFromGPUData(n,e||t,s)}if(!kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){tr(e);const r=he(e),i=he(t);O(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let a=0;a<t.length;++a){const o=t[a],l=a===t.length-1?o!==he(e.slice(a)):!0;O(t[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!kn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Bo(n,s):Ui(n,[],!0),W.makeTensor(n,e,s)}function Xs(n,e,t){const s=ji(n,t);return Vo(n,e,s,t)}const Gl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class wi{static join(e){return new wi(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>kn(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,i=new ArrayBuffer(r),a=new Uint8Array(i);let o=0;for(let l=s;l<this.shards.length;l++){const h=this.shards[l],p=e+o-h.start,m=o,b=Math.min(t,h.end)-h.start,x=new Uint8Array(h.buffer,p,b-p);if(a.set(x,m),o+=x.length,t<h.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=RX(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function RX(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,i=e(n[r]);if(i===0)return r;i<0?s=r:t=r+1}return-1}function DX(){ae().set("PROD",!0)}function OX(){ae().set("DEBUG",!0)}function LX(){ae().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function FX(n){ae().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function MX(){W.disposeVariables()}function li(){return W}function FT(){return W.memory()}function zX(n){return W.profile(n)}function re(n,e){return W.tidy(n,e)}function Ke(n){ka(n).forEach(t=>t.dispose())}function En(n){return W.keep(n)}function PX(n){return W.time(n)}function BX(n){return W.setBackend(n)}function VX(){return W.ready()}function LM(){return W.backendName}function UX(n){W.removeBackend(n)}function jX(n){return W.findBackend(n)}function WX(n){return W.findBackendFactory(n)}function S2(n,e,t=1){return W.registerBackend(n,e,t)}function T2(){return W.backend}function GX(n,e){ae().setPlatform(n,e)}const _o=4;async function MT(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<r.length;++a){const o=r[a],l=Array.isArray(n)?n[a].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const h={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const d=new Promise(async p=>{const m=await l.bytes(),y=m.reduce((w,v)=>w+v.length,0)+_o*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const v=m[w],C=new Uint8Array(new Uint32Array([v.length]).buffer);b.set(C,x),x+=_o,b.set(v,x),x+=v.length}p(b)});s.push(d)}else s.push(l.data());e!=null&&(h.group=e),t.push(h)}const i=await Promise.all(s);return{data:KX(i),specs:t}}function C2(n,e){const t=new wi(n),s={};let r=0;for(const i of e){const a=HX(i,(o,l)=>t.slice(r+o,r+l));s[i.name]=FM(i,t.slice(r,r+a)),r+=a}return s}function HX(n,e){const t=he(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Gl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=_o+new Uint32Array(e(r,r+_o))[0];return r}else s=Gl[n.dtype];return t*s}async function qX(n,e){const t=he(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Gl[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<t;i++)r+=_o+new Uint32Array(await e(r,r+_o))[0];return r}else s=Gl[n.dtype];return t*s}function FM(n,e){const t=n.name,s=n.dtype,r=n.shape,i=he(r);let a,o=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=Gl[l.dtype],d=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];a[p]=m*l.scale+l.min}}else if(l.dtype==="float16")a=eY()(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);a=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];a[p]=Math.round(m*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*h}else if(s==="string"){const l=he(n.shape);a=[];for(let h=0;h<l;h++){const d=new Uint32Array(e.slice(o,o+_o))[0];o+=_o;const p=new Uint8Array(e.slice(o,o+d));a.push(p),o+=d}}else{const l=Gl[s];if(s==="float32")a=new Float32Array(e);else if(s==="int32")a=new Int32Array(e);else if(s==="bool")a=new Uint8Array(e);else if(s==="complex64"){a=new Float32Array(e);const h=new Float32Array(a.length/2),d=new Float32Array(a.length/2);for(let b=0;b<h.length;b++)h[b]=a[b*2],d[b]=a[b*2+1];const p=Xs(h,r,"float32"),m=Xs(d,r,"float32"),y=Ea(p,m);return p.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=i*l}return Xs(a,r,s)}async function yO(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:i}=await n.read();if(r&&i==null){const o=t-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const a=new Uint8Array(s.length+i.byteLength);a.set(s,0),a.set(new Uint8Array(i),s.length),s=a}return s.buffer}async function MM(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const i of e){const a=await qX(i,async(h,d)=>(r=await yO(s,r,d),r.slice(h,d)));r=await yO(s,r,a);const o=r.slice(0,a);r=r.slice(a);const l=FM(i,o);if(t[i.name]=l,LM()==="webgpu"){const h=T2();"uploadToGPU"in h&&he(l.shape)>=ae().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&h.uploadToGPU(l.dataId)}}return t}function KX(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const N2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function bO(n){return N2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function XX(n){if(N2)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function YX(n){if(N2){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function zM(n){return wi.join(n)}function xO(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function PM(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function k2(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function E2(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),k2(n,t,s)}function km(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:bO(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:bO(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new wi(n.weightData).byteLength}}function L0(n){const e=[];for(const t of n)e.push(...t.weights);return e}function JX(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function ZX(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function QX(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function eY(){const n=JX(),e=ZX(),t=QX();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let a=0;a<s.length;a++){const o=s[a],l=n[t[o>>10]+(o&1023)]+e[o>>10];i[a]=l}return new Float32Array(r)}}class qt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return qt.instance==null&&(qt.instance=new qt),qt.instance}static registerSaveRouter(e){qt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){qt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return qt.getHandlers(e,"save")}static getLoadHandlers(e,t){return qt.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?qt.getInstance().loadRouters:qt.getInstance().saveRouters).forEach(a=>{const o=a(e,s);o!==null&&r.push(o)}),r}}const tY=n=>qt.registerSaveRouter(n),nY=n=>qt.registerLoadRouter(n),BM=n=>qt.getSaveHandlers(n),VM=(n,e)=>qt.getLoadHandlers(n,e);const zT="tensorflowjs",PT=1,Ll="models_store",bo="model_info_store";function UM(){if(!ae().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function BT(n){const e=n.result;e.createObjectStore(Ll,{keyPath:"modelPath"}),e.createObjectStore(bo,{keyPath:"modelPath"})}class Hl{constructor(e){if(this.indexedDB=UM(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(zT,PT);i.onupgradeneeded=()=>BT(i),i.onsuccess=()=>{const a=i.result;if(t==null){const o=a.transaction(Ll,"readonly"),h=o.objectStore(Ll).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(a.close(),r(h.error)),o.oncomplete=()=>a.close()}else{t.weightData=wi.join(t.weightData);const o=km(t),l=a.transaction(bo,"readwrite");let h=l.objectStore(bo),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(m){return r(m)}let p;d.onsuccess=()=>{p=a.transaction(Ll,"readwrite");const m=p.objectStore(Ll);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:o}),y.onerror=b=>{h=l.objectStore(bo);const x=h.delete(this.modelPath);x.onsuccess=()=>(a.close(),r(y.error)),x.onerror=w=>(a.close(),r(y.error))}},d.onerror=m=>(a.close(),r(d.error)),l.oncomplete=()=>{p==null?a.close():p.oncomplete=()=>a.close()}}},i.onerror=a=>r(i.error)})}}Hl.URL_SCHEME="indexeddb://";const jM=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Hl.URL_SCHEME)?sY(n.slice(Hl.URL_SCHEME.length)):null;qt.registerSaveRouter(jM);qt.registerLoadRouter(jM);function sY(n){return new Hl(n)}function rY(n){return n.startsWith(Hl.URL_SCHEME)?n.slice(Hl.URL_SCHEME.length):n}class iY{constructor(){this.indexedDB=UM()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(zT,PT);s.onupgradeneeded=()=>BT(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(bo,"readonly"),o=i.objectStore(bo).getAll();o.onsuccess=()=>{const l={};for(const h of o.result)l[h.modelPath]=h.modelArtifactsInfo;e(l)},o.onerror=l=>(r.close(),t(o.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=rY(e),new Promise((t,s)=>{const r=this.indexedDB.open(zT,PT);r.onupgradeneeded=()=>BT(r),r.onsuccess=()=>{const i=r.result,a=i.transaction(bo,"readwrite"),o=a.objectStore(bo),l=o.get(e);let h;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=o.delete(e),p=()=>{h=i.transaction(Ll,"readwrite");const y=h.objectStore(Ll).delete(e);y.onsuccess=()=>t(l.result.modelArtifactsInfo),y.onerror=b=>s(l.error)};d.onsuccess=p,d.onerror=m=>(p(),i.close(),s(l.error))}},l.onerror=d=>(i.close(),s(l.error)),a.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const wa="/",Sc="tensorflowjs_models",WM="info",aY="model_topology",oY="weight_specs",lY="weight_data",uY="model_metadata";function GM(n){return{info:[Sc,n,WM].join(wa),topology:[Sc,n,aY].join(wa),weightSpecs:[Sc,n,oY].join(wa),weightData:[Sc,n,lY].join(wa),modelMetadata:[Sc,n,uY].join(wa)}}function HM(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function cY(n){const e=n.split(wa);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(wa)}function hY(n){return n.startsWith(ql.URL_SCHEME)?n.slice(ql.URL_SCHEME.length):n}class ql{constructor(e){if(!ae().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=GM(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=km(e),i=wi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,XX(i));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw HM(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const o=JSON.parse(i);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=YX(a),t}}ql.URL_SCHEME="localstorage://";const qM=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ql.URL_SCHEME)?dY(n.slice(ql.URL_SCHEME.length)):null;qt.registerSaveRouter(qM);qt.registerLoadRouter(qM);function dY(n){return new ql(n)}class fY{constructor(){O(ae().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),O(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Sc+wa,s=wa+WM;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const a=cY(i);e[a]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=hY(e);const t=GM(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return HM(t),s}}const Rc="://";class fs{constructor(){this.managers={}}static getInstance(){return fs.instance==null&&(fs.instance=new fs),fs.instance}static registerManager(e,t){O(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Rc)&&(e=e.slice(0,e.indexOf(Rc))),O(e.length>0,()=>"scheme must not be an empty string.");const s=fs.getInstance();O(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=fs.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(fs.getInstance().managers)}}function e0(n){if(n.indexOf(Rc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fs.getSchemes().join(",")}`);return{scheme:n.split(Rc)[0],path:n.split(Rc)[1]}}async function KM(n,e,t=!1){O(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=qt.getLoadHandlers(n);O(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),O(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],i=qt.getSaveHandlers(e);O(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),O(i.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=i[0],o=e0(n).scheme,l=e0(n).path,h=o===e0(n).scheme,d=await r.load();t&&h&&await fs.getManager(o).removeModel(l);const p=await a.save(d);return t&&!h&&await fs.getManager(o).removeModel(l),p.modelArtifactsInfo}async function pY(){const n=fs.getSchemes(),e={};for(const t of n){const s=await fs.getManager(t).listModels();for(const r in s){const i=t+Rc+r;e[i]=s[r]}}return e}async function mY(n){const e=e0(n);return fs.getManager(e.scheme).removeModel(e.path)}async function gY(n,e){return KM(n,e,!1)}async function yY(n,e){return KM(n,e,!0)}class bY{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ae().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return vM(e)}}if(ae().get("IS_BROWSER")){ae().setPlatform("browser",new bY);try{fs.registerManager(ql.URL_SCHEME,new fY)}catch{}try{fs.registerManager(Hl.URL_SCHEME,new iY)}catch{}}const xY={importFetch:()=>require("node-fetch")};let DS;class wY{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ae().global.fetch!=null?ae().global.fetch(e,t):(DS==null&&(DS=xY.importFetch()),DS(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ae().get("IS_NODE")&&!ae().get("IS_BROWSER")&&ae().setPlatform("node",new wY);function Qe(n,e="float32",t){return e=e||"float32",tr(n),new bn(n,e,t)}function vY(n,e){const t=M(n,"x","cast");if(!hM(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return W.runKernel(oh,s,r)}const Ne=G({cast_:vY});function SY(n){const t={x:M(n,"x","clone","string_or_numeric")};return W.runKernel(wh,t)}const zi=G({clone_:SY});function I2(n,e=!1){console.log(n.toString(e))}DM();const TY={buffer:Qe,cast:Ne,clone:zi,print:I2};SX(TY);function CY(n,e){let t=M(n,"a","add"),s=M(e,"b","add");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(hu,r)}const ve=G({add_:CY});function NY(n,e){let t=M(n,"a","floorDiv"),s=M(e,"b","floorDiv");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(bh,r)}const Nx=G({floorDiv_:NY});function kY(n,e){let t=M(n,"a","div"),s=M(e,"b","div");if([t,s]=Jt(t,s),t.dtype==="int32"&&s.dtype==="int32")return Nx(t,s);const r={a:t,b:s},i={};return W.runKernel(dh,r,i)}const Le=G({div_:kY});function EY(n,e){let t=M(n,"a","mul"),s=M(e,"b","mul");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel($h,r)}const q=G({mul_:EY});function IY(n){const e=M(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return W.runKernel(Ap,t)}else{const t={x:e};return W.runKernel(Sp,t)}}const mn=G({abs_:IY});function $Y(n){const t={x:M(n,"x","acos")};return W.runKernel(eh,t)}const $2=G({acos_:$Y});function _Y(n){const t={x:M(n,"x","acosh")};return W.runKernel(th,t)}const _2=G({acosh_:_Y});function AY(n){O(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),O(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>M(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!at(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return W.runKernel(Tp,s)}const XM=G({addN_:AY});function RY(n,e=null,t=!1){const r={x:M(n,"x","all","bool")},i={axis:e,keepDims:t};return W.runKernel(yb,r,i)}const kx=G({all_:RY});function DY(n,e=null,t=!1){const r={x:M(n,"x","any","bool")},i={axis:e,keepDims:t};return W.runKernel(bb,r,i)}const ip=G({any_:DY});function OY(n,e=0){const s={x:M(n,"x","argMax")},r={axis:e};return W.runKernel(Cp,s,r)}const Kl=G({argMax_:OY});function LY(n,e=0){const s={x:M(n,"x","argMin")},r={axis:e};return W.runKernel(Np,s,r)}const A2=G({argMin_:LY});function FY(n){const t={x:M(n,"x","asin")};return W.runKernel(nh,t)}const R2=G({asin_:FY});function MY(n){const t={x:M(n,"x","asinh")};return W.runKernel(sh,t)}const D2=G({asinh_:MY});function zY(n){const t={x:M(n,"x","atan")};return W.runKernel(rh,t)}const O2=G({atan_:zY});function PY(n,e){let t=M(n,"a","atan2"),s=M(e,"b","atan2");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(ah,r)}const L2=G({atan2_:PY});function BY(n){const t={x:M(n,"x","atanh")};return W.runKernel(ih,t)}const F2=G({atanh_:BY});function Em(n,e,t,s,r="NHWC",i){const a=n[3],o=[...e,a],l=Fa(r);return Vn(n,o,t,i,s,null,null,l)}function qr(n,e,t,s,r,i,a="channelsLast"){const[o,l]=ap(e);let h;if(a==="channelsLast")h=[o,l,n[3],n[3]];else if(a==="channelsFirst")h=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Vn(n,h,t,s,r,i,!1,a)}function La(n,e,t,s,r,i,a="NDHWC"){const[o,l,h]=VT(e);let d,p;if(a==="NDHWC")p="channelsLast",d=[o,l,h,n[4],n[4]];else if(a==="NCDHW")p="channelsFirst",d=[o,l,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Uo(n,d,t,s,r,!1,p,i)}function Vn(n,e,t,s,r,i,a=!1,o="channelsLast"){let[l,h,d,p]=[-1,-1,-1,-1];if(o==="channelsLast")[l,h,d,p]=n;else if(o==="channelsFirst")[l,p,h,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,y,,b]=e,[x,w]=ap(t),[v,C]=ap(s),N=Dc(m,v),k=Dc(y,C),{padInfo:E,outHeight:A,outWidth:R}=jY(r,h,d,x,w,N,k,i,o),D=a?b*p:b;let L;return o==="channelsFirst"?L=[l,D,A,R]:o==="channelsLast"&&(L=[l,A,R,D]),{batchSize:l,dataFormat:o,inHeight:h,inWidth:d,inChannels:p,outHeight:A,outWidth:R,outChannels:D,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:N,effectiveFilterWidth:k,dilationHeight:v,dilationWidth:C,inShape:n,outShape:L,filterShape:e}}function Uo(n,e,t,s,r,i=!1,a="channelsLast",o){let[l,h,d,p,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,h,d,p,m]=n;else if(a==="channelsFirst")[l,m,h,d,p]=n;else throw new Error(`Unknown dataFormat ${a}`);const[y,b,x,,w]=e,[v,C,N]=VT(t),[k,E,A]=VT(s),R=Dc(y,k),D=Dc(b,E),L=Dc(x,A),{padInfo:F,outDepth:_,outHeight:V,outWidth:Q}=WY(r,h,d,p,v,C,N,R,D,L,o),ne=i?w*m:w;let Z;return a==="channelsFirst"?Z=[l,ne,_,V,Q]:a==="channelsLast"&&(Z=[l,_,V,Q,ne]),{batchSize:l,dataFormat:a,inDepth:h,inHeight:d,inWidth:p,inChannels:m,outDepth:_,outHeight:V,outWidth:Q,outChannels:ne,padInfo:F,strideDepth:v,strideHeight:C,strideWidth:N,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:R,effectiveFilterHeight:D,effectiveFilterWidth:L,dilationDepth:k,dilationHeight:E,dilationWidth:A,inShape:n,outShape:Z,filterShape:e}}function VY(n,e,t,s,r){s==null&&(s=M2(n,e,t));const i=n[0],a=n[1],o=op((i-e+2*s)/t+1,r),l=op((a-e+2*s)/t+1,r);return[o,l]}function UY(n,e,t,s,r,i){r==null&&(r=M2(n,e[0],s[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*r>=e[o]&&(a[o]=op((n[o]-e[o]+2*r)/s[o]+1,i));return a}function M2(n,e,t,s=1){const r=Dc(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function ap(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function VT(n){return typeof n=="number"?[n,n,n]:n}function Dc(n,e){return e<=1?n:n+(n-1)*(e-1)}function jY(n,e,t,s,r,i,a,o,l){let h,d,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=VY([e,t],i,s,n,o);d=y[0],p=y[1]}else if(n==="same"){d=Math.ceil(e/s),p=Math.ceil(t/r);const m=Math.max(0,(d-1)*s+i-e),y=Math.max(0,(p-1)*r+a-t),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),v=y-w;h={top:b,bottom:x,left:w,right:v,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-i+1)/s),p=Math.ceil((t-a+1)/r);else if(typeof n=="object"){const m=l==="channelsLast"?n[1][0]:n[2][0],y=l==="channelsLast"?n[1][1]:n[2][1],b=l==="channelsLast"?n[2][0]:n[3][0],x=l==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=op((e-i+m+y)/s+1,o),p=op((t-a+b+x)/r+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:p}}function WY(n,e,t,s,r,i,a,o,l,h,d){let p,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=UY([e,t,s,1],[o,l,h],1,[r,i,a],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(e/r),y=Math.ceil(t/i),b=Math.ceil(s/a);const x=(m-1)*r+o-e,w=(y-1)*i+l-t,v=(b-1)*a+h-s,C=Math.floor(x/2),N=x-C,k=Math.floor(w/2),E=w-k,A=Math.floor(v/2),R=v-A;p={top:k,bottom:E,left:A,right:R,front:C,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:y,outWidth:b}}function op(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ao(n){const[e,t,s]=ap(n);return e===1&&t===1&&s===1}function Zn(n,e){return Ao(n)||Ao(e)}function Xl(n){return ap(n).every(e=>e>0)}function Fa(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ws(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")O(Wl(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{O(Wl(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function GY(n,e){const s={x:M(n,"x","reshape","string_or_numeric")},r={shape:e};return W.runKernel(hm,s,r)}const Y=G({reshape_:GY});function HY(n,e,t,s,r){const i=M(n,"x","avgPool","float32"),a=1;O(Zn(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=i,l=!1;i.rank===3&&(l=!0,o=Y(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ws("avgPool",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let p=W.runKernel(kp,h,d);return p=Ne(p,i.dtype),l?Y(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Im=G({avgPool_:HY});function qY(n,e,t,s,r,i="NDHWC"){const a=M(n,"x","avgPool3d","float32");let o=a,l=!1;a.rank===4&&(l=!0,o=Y(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),O(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),O(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ws("avgPool3d",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let p=W.runKernel(Ep,h,d);return p=Ne(p,o.dtype),l?Y(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const z2=G({avgPool3d_:qY});function KY(n,e=0){O(n.length>=1,()=>"Pass at least one tensor to concat");const t=rp(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return zi(t[0]);const s=t,r={axis:e};return W.runKernel(Rp,s,r)}const ln=G({concat_:KY});function XY(n,e,t=!1,s=!1){let r=M(n,"a","matMul"),i=M(e,"b","matMul");[r,i]=Jt(r,i);const a={a:r,b:i},o={transposeA:t,transposeB:s};return W.runKernel(Ip,a,o)}const nt=G({matMul_:XY});function YY(n){const t={x:M(n,"x","sigmoid","float32")};return W.runKernel(Bh,t)}const fi=G({sigmoid_:YY});function JY(n,e,t){const s=M(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return W.runKernel(gm,r,i)}const ht=G({slice_:JY});function ZY(n){const t={x:M(n,"x","tanh","float32")};return W.runKernel(Hh,t)}const Ro=G({tanh_:ZY});function QY(n,e,t,s,r,i){const a=M(n,"forgetBias","basicLSTMCell"),o=M(e,"lstmKernel","basicLSTMCell"),l=M(t,"lstmBias","basicLSTMCell"),h=M(s,"data","basicLSTMCell"),d=M(r,"c","basicLSTMCell"),p=M(i,"h","basicLSTMCell"),m=ln([h,p],1),y=nt(m,o),b=ve(y,l),x=b.shape[0],w=b.shape[1]/4,v=[x,w],C=ht(b,[0,0],v),N=ht(b,[0,w],v),k=ht(b,[0,w*2],v),E=ht(b,[0,w*3],v),A=ve(q(fi(C),Ro(N)),q(d,fi(ve(a,k)))),R=q(Ro(A),fi(E));return[A,R]}const YM=G({basicLSTMCell_:QY});function eJ(n,e,t){const s=M(n,"x","batchToSpaceND"),r=e.reduce((o,l)=>o*l);O(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),O(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),O(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},a={blockShape:e,crops:t};return W.runKernel($p,i,a)}const $m=G({batchToSpaceND_:eJ});function tJ(n){let e;return n.rank===0||n.rank===1?e=Y(n,[1,1,1,n.size]):n.rank===2?e=Y(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=Y(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function nJ(n,e,t,s,r,i){i==null&&(i=.001);const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;s!=null&&(d=M(s,"offset","batchNorm")),O(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:tJ(a),scale:h,offset:d,mean:o,variance:l},y={varianceEpsilon:i},b=W.runKernel(Vp,m,y);return Y(b,a.shape)}const Xh=G({batchNorm_:nJ});function sJ(n,e,t,s,r,i){const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),O(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),O(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),O(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),h!=null&&O(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&O(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),Xh(a,o,l,d,h,i)}const P2=G({batchNorm2d_:sJ});function rJ(n,e,t,s,r,i){const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),O(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),O(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),O(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),h!=null&&O(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&O(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),Xh(a,o,l,d,h,i)}const B2=G({batchNorm3d_:rJ});function iJ(n,e,t,s,r,i){const a=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),O(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),O(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),O(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),h!=null&&O(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&O(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),Xh(a,o,l,d,h,i)}const V2=G({batchNorm4d_:iJ});function aJ(n,e,t){const s=M(n,"x","bincount"),r=M(e,"weights","bincount");O(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},a={size:t};return W.runKernel(vb,i,a)}const U2=G({bincount_:aJ});function oJ(n,e){const t=M(n,"x","bitwiseAnd"),s=M(e,"y","bitwiseAnd");if(!at(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return W.runKernel(_p,r)}const JM=G({bitwiseAnd_:oJ});function lJ(n,e){const t=M(n,"s0","broadcastArgs","int32"),s=M(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return W.runKernel(Sb,r)}const ZM=G({broadcastArgs_:lJ});function uJ(n,e){let t=M(n,"broadcastTo","x");const s=t.shape;if(tr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=Y(t,h)}const r=t.shape,i=Array.from(e);for(let h=e.length-1;h>=0;h--)if(r[h]===e[h])i[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return zi(t);const o={x:t},l={reps:i};return W.runKernel(qh,o,l)}const Vl=G({broadcastTo_:uJ});function cJ(n){const t={x:M(n,"x","ceil","float32")};return W.runKernel(lh,t)}const j2=G({ceil_:cJ});function du(n,e,t){tr(n),t=t||uu(e);const s={shape:n,value:e,dtype:t};return W.runKernel(zb,{},s)}function hJ(n,e,t){const s=M(n,"x","clipByValue");if(O(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return du(s.shape,e,s.dtype);const r={x:s},i={clipValueMin:e,clipValueMax:t};return W.runKernel(uh,r,i)}const Rs=G({clipByValue_:hJ});function dJ(n){return ln(n,0)}const W2=G({concat1d_:dJ});function fJ(n,e){return ln(n,e)}const G2=G({concat2d_:fJ});function pJ(n,e){return ln(n,e)}const H2=G({concat3d_:pJ});function mJ(n,e){return ln(n,e)}const q2=G({concat4d_:mJ});function gJ(n,e,t,s,r="NHWC",i=[1,1],a){const o=M(n,"x","conv2d","float32"),l=M(e,"filter","conv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=Y(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),O(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ws("conv2d",s,a);const p=r==="NHWC"?h.shape[3]:h.shape[1];O(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),O(Zn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),O(Xl(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),O(Xl(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:l},y={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},b=W.runKernel(Dp,m,y);return d?Y(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Ia=G({conv2d_:gJ});function yJ(n,e,t,s,r="NWC",i=1,a){const o=M(n,"x","conv1d"),l=M(e,"filter","conv1d");let h=o,d=!1;o.rank===2&&(d=!0,h=Y(o,[1,o.shape[0],o.shape[1]])),O(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),O(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ws("conv1d",s,a),O(h.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${l.shape[1]}.`),O(Zn(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),O(Xl(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),O(Xl(t),()=>"Error in conv1D: Stride should be larger than 0."),O(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=Y(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=Y(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=Ia(m,p,[1,t],s,"NHWC",[1,i],a);return d?Y(w,[w.shape[2],w.shape[3]]):Y(w,[w.shape[0],w.shape[2],w.shape[3]])}const Ex=G({conv1d_:yJ});function bJ(n,e,t,s,r,i="NHWC",a){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,l=e,h=!1;e.rank===3&&(h=!0,l=Y(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),O(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),O(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),O(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=i==="NHWC"?o[3]:o[1],p=i==="NHWC"?l.shape[3]:l.shape[1];O(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),O(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),ws("conv2dDerInput",r,a);const m={dy:l,filter:t},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o},b=W.runKernel(Op,m,y);return h?Y(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const K2=G({conv2DBackpropInput_:bJ});function xJ(n,e,t,s,r,i){const a=M(n,"x","conv2dTranspose"),o=M(e,"filter","conv2dTranspose");return K2(t,a,o,s,r,"NHWC",i)}const Ix=G({conv2dTranspose_:xJ});function wJ(n,e,t,s,r="NDHWC",i=[1,1,1]){const a=M(n,"x","conv3d"),o=M(e,"filter","conv3d");let l=a,h=!1;a.rank===4&&(h=!0,l=Y(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),O(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),O(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),O(Zn(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),O(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),O(Xl(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),O(Xl(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:l,filter:o},p={strides:t,pad:s,dataFormat:r,dilations:i},m=W.runKernel(Lp,d,p);return h?Y(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const X2=G({conv3d_:wJ});function vJ(n,e,t,s,r){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,a=e,o=!1;e.rank===4&&(o=!0,a=Y(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],h=a.shape[4];O(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),O(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),O(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),O(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),O(h===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[4]}.`);const d={dy:a,filter:t},p={pad:r,strides:s,inputShape:i},m=W.runKernel(kb,d,p);return o?Y(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const QM=G({conv3DBackpropInput_:vJ});function SJ(n,e,t,s,r){const i=M(n,"x","conv3dTranspose"),a=M(e,"filter","conv3dTranspose");return QM(t,i,a,s,r)}const Y2=G({conv3dTranspose_:SJ});function TJ(n){const t={x:M(n,"x","cos","float32")};return W.runKernel(ch,t)}const _m=G({cos_:TJ});function CJ(n){const t={x:M(n,"x","cosh","float32")};return W.runKernel(hh,t)}const $x=G({cosh_:CJ});function NJ(n,e=0,t=!1,s=!1){const i={x:M(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:s};return W.runKernel(Eb,i,a)}const lp=G({cumprod_:NJ});function kJ(n,e=0,t=!1,s=!1){const i={x:M(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:s};return W.runKernel(Fp,i,a)}const _x=G({cumsum_:kJ});function EJ(n,e,t,s=!1){const r=M(n,"x","denseBincount"),i=M(e,"weights","denseBincount");O(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),O(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const a={x:r,weights:i},o={size:t,binaryOutput:s};return W.runKernel($b,a,o)}const F0=G({denseBincount_:EJ});function IJ(n,e,t="NHWC"){const s=M(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];O(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),O(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),O(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),O(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:e,dataFormat:t};return W.runKernel(_b,o,l)}const J2=G({depthToSpace_:IJ});function $J(n,e,t,s,r="NHWC",i=[1,1],a){const o=M(n,"x","depthwiseConv2d","float32"),l=M(e,"filter","depthwiseConv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=Y(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),O(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const p=r==="NHWC"?h.shape[3]:h.shape[1];O(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),ws("depthwiseConv2d",s,a);const m={x:h,filter:l},y={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},b=W.runKernel(Mp,m,y);return d?Y(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Yh=G({depthwiseConv2d_:$J});function _J(n){const t={x:M(n,"x","diag")};return W.runKernel(Db,t)}const ez=G({diag_:_J});function AJ(n,e,t,s,r=[1,1],i="NHWC"){const a=M(n,"x","dilation2d"),o=M(e,"filter","dilation2d");O(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),O(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),O(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=a,h=!1;a.rank===3&&(l=Y(a,[1,a.shape[0],a.shape[1],a.shape[2]]),h=!0),O(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const d={x:l,filter:o},p={strides:t,pad:s,dilations:r},m=W.runKernel(zp,d,p);return h?Y(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Z2=G({dilation2d_:AJ});function Yl(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,a=n[i]||1;(e[e.length-1-r]||1)>1&&a===1&&s.unshift(i)}return s}function xn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,a=e[i];(r==null||r===1&&a>1)&&t.unshift(i)}return t}function Xe(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let i=n[n.length-r-1];i==null&&(i=1);let a=e[e.length-r-1];if(a==null&&(a=1),i===1)s[t-r-1]=a;else if(a===1)s[t-r-1]=i;else if(i!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else s[t-r-1]=i}return s}const RJ=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Xe,getBroadcastDims:Yl,getReductionAxes:xn},Symbol.toStringTag,{value:"Module"}));function DJ(n,e){let t=M(n,"a","equal","string_or_numeric"),s=M(e,"b","equal","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Pp,r)}const Ys=G({equal_:DJ});function OJ(n,e,t){const s=M(e,"a","where"),r=M(t,"b","where"),i=M(n,"condition","where","bool"),a=Xe(Xe(i.shape,s.shape),r.shape),o=Vl(i,a),l=Vl(s,a),h=Vl(r,a),d={condition:o,t:l,e:h};return W.runKernel(mm,d)}const Mn=G({where_:OJ});function LJ(n){const t={x:M(n,"x","zerosLike")};return W.runKernel(Cm,t)}const dt=G({zerosLike_:LJ});function FJ(n,e){let t=M(n,"a","div"),s=M(e,"b","div");[t,s]=Jt(t,s);const r=Le(t,s),i=dt(r),a=Ys(s,i);return Mn(a,i,r)}const Q2=G({divNoNan_:FJ});function MJ(n,e){const t=M(n,"t1","dot"),s=M(e,"t2","dot");O((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],i=s.rank===1?s.size:s.shape[0];if(O(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),t.rank===1&&s.rank===1){const a=Y(t,[1,-1]),o=Y(s,[-1,1]),l=nt(a,o);return Y(l,[])}else if(t.rank===1&&s.rank===2){const a=Y(t,[1,-1]),o=Y(s,[s.shape[0],s.shape[1]]),l=nt(a,o);return Y(l,[l.size])}else if(t.rank===2&&s.rank===1){const a=Y(s,[-1,1]),o=nt(t,a);return Y(o,[o.size])}else{const a=Y(s,[s.shape[0],s.shape[1]]);return nt(t,a)}}const eN=G({dot_:MJ});function zJ(n,...e){const t=e.map((r,i)=>M(r,`tensors${i}`,"einsum")),s={equation:n};return W.runKernel(Lb,t,s)}const Il=G({einsum_:zJ});function PJ(n){const t={x:M(n,"x","elu","float32")};return W.runKernel(fh,t)}const Jh=G({elu_:PJ});function BJ(n,e){const t=M(n,"x","ensureShape","string_or_numeric");if(!uM(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const tz=G({ensureShape_:BJ});function VJ(n){let e=M(n,"x","erf");O(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ne(e,"float32"));const t={x:e};return W.runKernel(ph,t)}const Ax=G({erf_:VJ});function tN(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function nz(n,e,t){const s=n.length+e.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?r.push(n[i++]):r.push(e[a++]);return r}function Un(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function un(n,e){const t=e.map(s=>1);return nz(n,t,e)}function Qn(n,e,t){O(tN(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Zt(n,e){if(tN(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function jo(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function cn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function UJ(n,e=null,t=!1){const r={x:M(n,"x","max")},i={reductionIndices:e,keepDims:t};return W.runKernel(Jp,r,i)}const Sr=G({max_:UJ});function jJ(n,e=null,t=!1){const r={x:M(n,"x","min")},i={axis:e,keepDims:t};return W.runKernel(tm,r,i)}const Pc=G({min_:jJ});function WJ(n,e){let t=M(n,"base","pow"),s=M(e,"exp","pow");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(_h,r)}const Wi=G({pow_:WJ});function Pe(n,e){if((kn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&kn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Vo(n,[],[],e)}function GJ(n){const t={x:M(n,"x","sqrt","float32")};return W.runKernel(Uh,t)}const Pn=G({sqrt_:GJ});function HJ(n){const e=M(n,"x","square"),t={};return W.runKernel("Square",{x:e},t)}const It=G({square_:HJ});function qJ(n,e=null,t=!1){let s=M(n,"x","sum");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return W.runKernel(ym,r,i)}const Re=G({sum_:qJ});function KJ(n,e="euclidean",t=null,s=!1){n=M(n,"x","norm");const r=sz(n,e,t);let i=r.shape;if(s){const a=st(t,n.shape);i=un(r.shape,a)}return Y(r,i)}function sz(n,e,t=null){if(n.rank===0)return mn(n);if(n.rank!==1&&t===null)return sz(Y(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Re(mn(n),t);if(e===1/0)return Sr(mn(n),t);if(e===-1/0)return Pc(mn(n),t);if(e==="euclidean"||e===2)return Pn(Re(Wi(mn(n),Pe(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Sr(Re(mn(n),t[0]),t[1]-1);if(e===1/0)return Sr(Re(mn(n),t[1]),t[0]);if(e===-1/0)return Pc(Re(mn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Pn(Re(It(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Zh=G({norm_:KJ});function XJ(n,e=null,t=!1){return Zh(n,"euclidean",e,t)}const nN=G({euclideanNorm_:XJ});function YJ(n){const t={x:M(n,"x","exp")};return W.runKernel(mh,t)}const Ds=G({exp_:YJ});function JJ(n,e=0){const t=M(n,"x","expandDims","string_or_numeric");O(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return W.runKernel(Bp,s,r)}const Hn=G({expandDims_:JJ});function ZJ(n){const t={x:M(n,"x","expm1")};return W.runKernel(gh,t)}const sN=G({expm1_:ZJ});function QJ(n,e){const t=M(n,"x","tile","string_or_numeric");O(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return W.runKernel(qh,s,r)}const br=G({tile_:QJ});function eZ(n,e,t,s="float32"){e==null&&(e=n);const r=Qe([n,e],s),i=n<=e?n:e;for(let o=0;o<i;++o)r.set(1,o,o);const a=Y(r.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return br(Hn(a,0),[t[0],1,1]);if(t.length===2)return br(Hn(Hn(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return br(Hn(Hn(Hn(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Rx=G({eye_:eZ});function tZ(n){const t={x:M(n,"x","floor","float32")};return W.runKernel(yh,t)}const Qh=G({floor_:tZ});function nZ(n,e,t=0,s=0){const r=M(n,"x","gather"),i=M(e,"indices","gather","int32"),a={x:r,indices:i},o={axis:t,batchDims:s};return W.runKernel(Up,a,o)}const ed=G({gather_:nZ});function sZ(n,e){let t=M(n,"a","greater","string_or_numeric"),s=M(e,"b","greater","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(jp,r)}const vs=G({greater_:sZ});function rZ(n,e){let t=M(n,"a","greaterEqual","string_or_numeric"),s=M(e,"b","greaterEqual","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(xh,r)}const Ma=G({greaterEqual_:rZ});function iZ(n){const t={input:M(n,"input","imag")};return W.runKernel(Ub,t)}const Am=G({imag_:iZ});function aZ(n){const t={x:M(n,"x","isFinite")};return W.runKernel(vh,t)}const rN=G({isFinite_:aZ});function oZ(n){const t={x:M(n,"x","isInf")};return W.runKernel(Sh,t)}const iN=G({isInf_:oZ});function lZ(n){const t={x:M(n,"x","isNaN")};return W.runKernel(Th,t)}const aN=G({isNaN_:lZ});function uZ(n,e=.2){const s={x:M(n,"x","leakyRelu")},r={alpha:e};return W.runKernel(Wp,s,r)}const Rm=G({leakyRelu_:uZ});function cZ(n,e){let t=M(n,"a","less","string_or_numeric"),s=M(e,"b","less","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Gp,r)}const Bc=G({less_:cZ});function hZ(n,e){let t=M(n,"a","lessEqual","string_or_numeric"),s=M(e,"b","lessEqual","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Hp,r)}const Wo=G({lessEqual_:hZ});function rz(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return W.runKernel(jb,{},s)}function dZ(n,e=5,t=1,s=1,r=.5){const i=M(n,"x","localResponseNormalization");O(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),O(Wl(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;i.rank===3&&(o=!0,a=Y(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:a},h={depthRadius:e,bias:t,alpha:s,beta:r},d=W.runKernel(Yp,l,h);return o?Y(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const oN=G({localResponseNormalization_:dZ});function fZ(n){const t={x:M(n,"x","log","float32")};return W.runKernel(Ch,t)}const Js=G({log_:fZ});function pZ(n){const t={x:M(n,"x","log1p")};return W.runKernel(Nh,t)}const Dm=G({log1p_:pZ});function mZ(n){return O($o(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=M(e,"x","tf.grad","string_or_numeric"),r=t!=null?M(t,"dy","tf.grad"):null;return W.tidy(()=>{const{value:i,grads:a}=W.gradients(()=>n(s),[s],r);return r!=null&&Jn(i.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Dx(a),a[0]})}}function gZ(n){return O($o(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{O(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=rp(e,"args","tf.grads","string_or_numeric"),r=t!=null?M(t,"dy","tf.grads"):null;return W.tidy(()=>{const{value:i,grads:a}=W.gradients(()=>n(...s),s,r);return r!=null&&Jn(i.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Dx(a),a})}}function yZ(n){return O($o(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{O(e instanceof bt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),O(t==null||t instanceof bt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=W.gradients(()=>n(e),[e],t);return Dx(s),{grad:s[0],value:r}}}function bZ(n){return O($o(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{O(Array.isArray(e)&&e.every(r=>r instanceof bt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),O(t==null||t instanceof bt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=W.gradients(()=>n(...e),e,t);return t!=null&&Jn(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Dx(s.grads),s}}function iz(n,e){O($o(n),()=>"The f passed in variableGrads(f) must be a function"),O(e==null||Array.isArray(e)&&e.every(h=>h instanceof sp),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const h in W.registeredVariables)e.push(W.registeredVariables[h])}const s=t?e.filter(h=>!h.trainable):null,r=e.length;e=e.filter(h=>h.trainable),O(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:a,grads:o}=W.gradients(n,e,null,i);O(o.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),O(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((h,d)=>{o[d]!=null&&(l[h.name]=o[d])}),s?.forEach(h=>l[h.name]=null),{value:a,grads:l}}function Gi(n){return W.customGrad(n)}function Dx(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function xZ(n){const t={x:M(n,"x","neg")};return W.runKernel(sm,t)}const Mt=G({neg_:xZ});function wZ(n){const t={x:M(n,"x","softplus")};return W.runKernel(Vh,t)}const fu=G({softplus_:wZ});function vZ(n){const e=M(n,"x","logSigmoid");return Gi(s=>({value:Mt(fu(Mt(s))),gradFunc:a=>q(a,fi(Mt(s)))}))(e)}const lN=G({logSigmoid_:vZ});function SZ(n,e){let t=M(n,"a","sub"),s=M(e,"b","sub");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(Wh,r)}const _e=G({sub_:SZ});function TZ(n,e=-1){const t=M(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Gi((r,i)=>{const o=Sr(r,e,!0),l=_e(r,o),h=_e(Ne(l,"float32"),Js(Re(Ds(l),e,!0)));return i([h]),{value:h,gradFunc:(p,m)=>{const[y]=m,b=!0,x=Ds(y);return _e(p,q(Re(p,e,b),x))}}})(t)}const Ox=G({logSoftmax_:TZ});function CZ(n,e=null,t=!1){const s=M(n,"x","logSumExp"),r=st(e,s.shape),i=Sr(s,r,!0),a=_e(s,i),o=Ds(a),l=Re(o,r),h=Js(l),d=ve(Y(i,h.shape),h);if(t){const p=un(d.shape,r);return Y(d,p)}return d}const Om=G({logSumExp_:CZ});function NZ(n,e){const t=M(n,"a","logicalAnd","bool"),s=M(e,"b","logicalAnd","bool");Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(qp,r)}const Hr=G({logicalAnd_:NZ});function kZ(n){const t={x:M(n,"x","logicalNot","bool")};return W.runKernel(Kp,t)}const Lm=G({logicalNot_:kZ});function EZ(n,e){const t=M(n,"a","logicalOr","bool"),s=M(e,"b","logicalOr","bool");Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Xp,r)}const Lx=G({logicalOr_:EZ});function IZ(n,e){const t=M(n,"a","logicalXor","bool"),s=M(e,"b","logicalXor","bool");return Xe(t.shape,s.shape),Hr(Lx(n,e),Lm(Hr(n,e)))}const uN=G({logicalXor_:IZ});const Ly=2147483648;function $Z(n,e,t="left"){const s=M(n,"sortedSequence","searchSorted"),r=M(e,"values","searchSorted"),i=s.shape[s.shape.length-1],a=r.shape[r.shape.length-1],o=Y(s,[-1,i]),l=Y(r,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(he(l.shape)>=Ly)throw new Error(`values tensor size must less than ${Ly}`);if(o.shape[1]>=Ly)throw new Error(`trailing dim_size must less than ${Ly} for int32 output type, was ${o.shape[1]}`);const h={sortedSequence:o,values:l},d={side:t};return W.runKernel(ox,h,d)}const Fx=G({searchSorted_:$Z});function az(n,e){return Fx(n,e,"left")}function _Z(n,e,t,s,r){const i=M(n,"x","maxPool"),a=1;let o=i,l=!1;i.rank===3&&(l=!0,o=Y(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),O(Zn(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ws("maxPool",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r},p=W.runKernel(Zp,h,d);return l?Y(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Fm=G({maxPool_:_Z});function AZ(n,e=[1,1,1],t,s,r,i="NDHWC"){const a=M(n,"x","maxPool3d");let o=a,l=!1;a.rank===4&&(l=!0,o=Y(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),O(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ws("maxPool3d",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},p=W.runKernel(Qp,h,d);return l?Y(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const cN=G({maxPool3d_:AZ});function RZ(n,e,t,s,r=!1){const a={x:M(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=W.runKernel(qb,a,o);return{result:l[0],indexes:l[1]}}const oz=G({maxPoolWithArgmax_:RZ});function DZ(n,e){let t=M(n,"a","maximum"),s=M(e,"b","maximum");[t,s]=Jt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(kh,r)}const qi=G({maximum_:DZ});function OZ(n,e=null,t=!1){const r={x:M(n,"x","mean")},i={axis:e,keepDims:t};return W.runKernel(em,r,i)}const Kt=G({mean_:OZ});function gn(n,e="float32"){if(tr(n),e==="complex64"){const s=gn(n,"float32"),r=gn(n,"float32");return Ea(s,r)}const t=Yn(he(n),e);return W.makeTensor(t,n,e)}function Is(n,e="float32"){if(tr(n),e==="complex64"){const s=Is(n,"float32"),r=gn(n,"float32");return Ea(s,r)}const t=gb(he(n),e);return W.makeTensor(t,n,e)}function lz(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=M(n,"x","meshgrid",n instanceof bt?n.dtype:"float32");if(e===void 0)return[s];let r=M(e,"y","meshgrid",e instanceof bt?e.dtype:"float32");const i=he(s.shape),a=he(r.shape);return t==="xy"?(s=Y(s,[1,-1]),r=Y(r,[-1,1]),[nt(Is([a,1],s.dtype),s),nt(r,Is([1,i],r.dtype))]):(s=Y(s,[-1,1]),r=Y(r,[1,-1]),[nt(s,Is([1,a],s.dtype)),nt(Is([i,1],r.dtype),r)])}function LZ(n,e){let t=M(n,"a","minimum"),s=M(e,"b","minimum");[t,s]=Jt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Eh,r)}const Do=G({minimum_:LZ});function FZ(n,e,t){O(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=M(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)O(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),O(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},a={x:s};return W.runKernel(nm,a,i)}const hN=G({mirrorPad_:FZ});function MZ(n,e){let t=M(n,"a","mod"),s=M(e,"b","mod");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(Ih,r)}const dN=G({mod_:MZ});function zZ(n,e=null,t=!1){n=M(n,"x","moments");const s=st(e,n.shape),r=Kt(n,s,t);let i=r.shape;t||(i=un(r.shape,s));const a=It(_e(Ne(n,"float32"),Y(r,i))),o=Kt(a,s,t);return{mean:r,variance:o}}const Mm=G({moments_:zZ});function PZ(n,e,t,s){const r=M(e,"data","multiRNNCell"),i=rp(t,"c","multiRNNCell"),a=rp(s,"h","multiRNNCell");let o=r;const l=[];for(let p=0;p<n.length;p++){const m=n[p](o,i[p],a[p]);l.push(m[0]),l.push(m[1]),o=m[1]}const h=[],d=[];for(let p=0;p<l.length;p+=2)h.push(l[p]),d.push(l[p+1]);return[h,d]}const uz=G({multiRNNCell_:PZ});function BZ(n,e,t,s=!1){const r=M(n,"logits","multinomial"),i=r.size,a=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const l={logits:a===1?Y(r,[1,-1]):r},h={numSamples:e,seed:t,normalized:s},d=W.runKernel(Kb,l,h);return a===1?Y(d,[d.size]):d}const cz=G({multinomial_:BZ});function VZ(n,e){let t=M(n,"a","notEqual","string_or_numeric"),s=M(e,"b","notEqual","string_or_numeric");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(rm,r)}const Jl=G({notEqual_:VZ});function UZ(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:M(n,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:t,offValue:s};return W.runKernel(am,a,o)}const Vc=G({oneHot_:UZ});function jZ(n){const t={x:M(n,"x","onesLike")};return W.runKernel(im,t)}const Zs=G({onesLike_:jZ});function WZ(n,e){const t=M(n,"v1","outerProduct"),s=M(e,"v2","outerProduct");O(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=Y(t,[-1,1]),i=Y(s,[1,-1]);return nt(r,i)}const hz=G({outerProduct_:WZ});function GZ(n,e,t=0){const s=M(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return W.runKernel(lm,i,r)}const za=G({pad_:GZ});function HZ(n,e,t=0){return O(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),za(n,[e],t)}const dz=G({pad1d_:HZ});function qZ(n,e,t=0){return O(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),za(n,e,t)}const fz=G({pad2d_:qZ});function KZ(n,e,t=0){return O(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),za(n,e,t)}const pz=G({pad3d_:KZ});function XZ(n,e,t=0){return O(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),za(n,e,t)}const mz=G({pad4d_:XZ});function YZ(n,e,t){const s=M(n,"x","spaceToBatchND");O(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),O(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),O(s.shape.reduce((a,o,l)=>l>0&&l<=e.length?a&&(o+t[l-1][0]+t[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return W.runKernel(bm,r,i)}const zm=G({spaceToBatchND_:YZ});function JZ(n,e,t,s,r,i,a){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const o=M(n,"x","maxPool");let l=o,h=!1;o.rank===3&&(h=!0,l=Y(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(Zn(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=qr(l.shape,e,i,r,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=QZ([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const y=p[0]===1&&p[1]===1,[b,x]=ZZ([d.inHeight,d.inWidth],p,m),w=y?s:"valid",v=y?l:zm(l,p,b),N=(t==="avg"?()=>Im(v,e,i,w,a):()=>Fm(v,e,i,w,a))(),k=y?N:$m(N,p,x);return h?Y(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function ZZ(n,e,t){const s=t.map(d=>d[0]),r=t.map(d=>d[1]),i=n.concat(s,r),a=e.map((d,p)=>(d-i[p]%d)%d),o=r.map((d,p)=>d+a[p]),l=e.map((d,p)=>[s[p],o[p]]),h=e.map((d,p)=>[0,a[p]]);return[l,h]}function QZ(n,e){const s=n.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),r=s.map(a=>Math.floor(a/2)),i=s.map((a,o)=>a-r[o]);return s.map((a,o)=>[r[o],i[o]])}const fN=G({pool_:JZ});function eQ(n,e){const t=M(n,"x","prelu"),s=M(e,"alpha","prelu"),r={x:t,alpha:s};return W.runKernel(um,r)}const Pm=G({prelu_:eQ});function tQ(n,e=null,t=!1){let s=M(n,"x","prod");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return W.runKernel(cm,r,i)}const pN=G({prod_:tQ});function nQ(n,e,t,s){const r=n.map((d,p)=>M(d,`tensors${p}`,"raggedGather","int32")),i=M(e,"paramsDenseValues","raggedGather"),a=M(t,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:i,indices:a},l={outputRaggedRank:s},h=W.runKernel(Zb,o,l);return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}const gz=G({raggedGather_:nQ});function sQ(n,e,t){const s=M(n,"starts","raggedRange"),r=M(e,"limits","raggedRange",s.dtype),i=M(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:r,deltas:i},o=W.runKernel(Qb,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const yz=G({raggedRange_:sQ});function rQ(n,e,t,s,r){const i=M(n,"shape","raggedTensorToTensor","int32"),a=M(e,"values","raggedTensorToTensor"),o=M(t,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((p,m)=>M(p,`tensors${m}`,"raggedTensorToTensor","int32")),h={shape:i,values:a,defaultValue:o,rowPartitionTensors:l},d={rowPartitionTypes:r};return W.runKernel(ex,h,d)}const bz=G({raggedTensorToTensor_:rQ});function iQ(n,e,t){tr(n);const s=he(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<s;i++)r[i]=e();return W.makeTensor(r,n,t)}const xz=G({rand_:iQ});var t0={exports:{}},aQ=t0.exports,wO;function oQ(){return wO||(wO=1,(function(n){(function(e,t,s){function r(l){var h=this,d=o();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(l),h.s0<0&&(h.s0+=1),h.s1-=d(l),h.s1<0&&(h.s1+=1),h.s2-=d(l),h.s2<0&&(h.s2+=1),d=null}function i(l,h){return h.c=l.c,h.s0=l.s0,h.s1=l.s1,h.s2=l.s2,h}function a(l,h){var d=new r(l),p=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,d),m.state=function(){return i(d,{})}),m}function o(){var l=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){l+=d.charCodeAt(p);var m=.02519603282416938*l;l=m>>>0,m-=l,m*=l,l=m>>>0,m-=l,l+=m*4294967296}return(l>>>0)*23283064365386963e-26};return h}t&&t.exports?t.exports=a:this.alea=a})(aQ,n)})(t0)),t0.exports}var n0={exports:{}},lQ=n0.exports,vO;function uQ(){return vO||(vO=1,(function(n){(function(e,t,s){function r(o){var l=this,h="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var p=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^p^p>>>8},o===(o|0)?l.x=o:h+=o;for(var d=0;d<h.length+64;d++)l.x^=h.charCodeAt(d)|0,l.next()}function i(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function a(o,l){var h=new r(o),d=l&&l.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xor128=a})(lQ,n)})(n0)),n0.exports}var s0={exports:{}},cQ=s0.exports,SO;function hQ(){return SO||(SO=1,(function(n){(function(e,t,s){function r(o){var l=this,h="";l.next=function(){var p=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(p^p<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:h+=o;for(var d=0;d<h.length+64;d++)l.x^=h.charCodeAt(d)|0,d==h.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function a(o,l){var h=new r(o),d=l&&l.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xorwow=a})(cQ,n)})(s0)),s0.exports}var r0={exports:{}},dQ=r0.exports,TO;function fQ(){return TO||(TO=1,(function(n){(function(e,t,s){function r(o){var l=this;l.next=function(){var d=l.x,p=l.i,m,y;return m=d[p],m^=m>>>7,y=m^m<<24,m=d[p+1&7],y^=m^m>>>10,m=d[p+3&7],y^=m^m>>>3,m=d[p+4&7],y^=m^m<<7,m=d[p+7&7],m=m^m<<13,y^=m^m<<9,d[p]=y,l.i=p+1&7,y};function h(d,p){var m,y=[];if(p===(p|0))y[0]=p;else for(p=""+p,m=0;m<p.length;++m)y[m&7]=y[m&7]<<15^p.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(l,o)}function i(o,l){return l.x=o.x.slice(),l.i=o.i,l}function a(o,l){o==null&&(o=+new Date);var h=new r(o),d=l&&l.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.x&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xorshift7=a})(dQ,n)})(r0)),r0.exports}var i0={exports:{}},pQ=i0.exports,CO;function mQ(){return CO||(CO=1,(function(n){(function(e,t,s){function r(o){var l=this;l.next=function(){var d=l.w,p=l.X,m=l.i,y,b;return l.w=d=d+1640531527|0,b=p[m+34&127],y=p[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=p[m]=b^y,l.i=m,b+(d^d>>>16)|0};function h(d,p){var m,y,b,x,w,v=[],C=128;for(p===(p|0)?(y=p,p=null):(p=p+"\0",y=0,C=Math.max(C,p.length)),b=0,x=-32;x<C;++x)p&&(y^=p.charCodeAt((x+32)%p.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=v[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(v[(p&&p.length||0)&127]=-1),b=127,x=512;x>0;--x)y=v[b+34&127],m=v[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,v[b]=y^m;d.w=w,d.X=v,d.i=b}h(l,o)}function i(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function a(o,l){o==null&&(o=+new Date);var h=new r(o),d=l&&l.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.X&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.xor4096=a})(pQ,n)})(i0)),i0.exports}var a0={exports:{}},gQ=a0.exports,NO;function yQ(){return NO||(NO=1,(function(n){(function(e,t,s){function r(o){var l=this,h="";l.next=function(){var p=l.b,m=l.c,y=l.d,b=l.a;return p=p<<25^p>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-p|0,l.b=p=p<<20^p>>>12^m,l.c=m=m-y|0,l.d=y<<16^m>>>16^b,l.a=b-p|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):h+=o;for(var d=0;d<h.length+20;d++)l.b^=h.charCodeAt(d)|0,l.next()}function i(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function a(o,l){var h=new r(o),d=l&&l.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}t&&t.exports?t.exports=a:this.tychei=a})(gQ,n)})(a0)),a0.exports}var o0={exports:{}};const bQ={},xQ=Object.freeze(Object.defineProperty({__proto__:null,default:bQ},Symbol.toStringTag,{value:"Module"})),wQ=AG(xQ);var vQ=o0.exports,kO;function SQ(){return kO||(kO=1,(function(n){(function(e,t,s){var r=256,i=6,a=52,o="random",l=s.pow(r,i),h=s.pow(2,a),d=h*2,p=r-1,m;function y(k,E,A){var R=[];E=E==!0?{entropy:!0}:E||{};var D=v(w(E.entropy?[k,N(t)]:k??C(),3),R),L=new b(R),F=function(){for(var _=L.g(i),V=l,Q=0;_<h;)_=(_+Q)*r,V*=r,Q=L.g(1);for(;_>=d;)_/=2,V/=2,Q>>>=1;return(_+Q)/V};return F.int32=function(){return L.g(4)|0},F.quick=function(){return L.g(4)/4294967296},F.double=F,v(N(L.S),t),(E.pass||A||function(_,V,Q,ne){return ne&&(ne.S&&x(ne,L),_.state=function(){return x(L,{})}),Q?(s[o]=_,V):_})(F,D,"global"in E?E.global:this==s,E.state)}function b(k){var E,A=k.length,R=this,D=0,L=R.i=R.j=0,F=R.S=[];for(A||(k=[A++]);D<r;)F[D]=D++;for(D=0;D<r;D++)F[D]=F[L=p&L+k[D%A]+(E=F[D])],F[L]=E;(R.g=function(_){for(var V,Q=0,ne=R.i,Z=R.j,B=R.S;_--;)V=B[ne=p&ne+1],Q=Q*r+B[p&(B[ne]=B[Z=p&Z+V])+(B[Z]=V)];return R.i=ne,R.j=Z,Q})(r)}function x(k,E){return E.i=k.i,E.j=k.j,E.S=k.S.slice(),E}function w(k,E){var A=[],R=typeof k,D;if(E&&R=="object")for(D in k)try{A.push(w(k[D],E-1))}catch{}return A.length?A:R=="string"?k:k+"\0"}function v(k,E){for(var A=k+"",R,D=0;D<A.length;)E[p&D]=p&(R^=E[p&D]*19)+A.charCodeAt(D++);return N(E)}function C(){try{var k;return m&&(k=m.randomBytes)?k=k(r):(k=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(k)),N(k)}catch{var E=e.navigator,A=E&&E.plugins;return[+new Date,e,A,e.screen,N(t)]}}function N(k){return String.fromCharCode.apply(0,k)}if(v(s.random(),t),n.exports){n.exports=y;try{m=wQ}catch{}}else s["seed"+o]=y})(typeof self<"u"?self:vQ,[],Math)})(o0)),o0.exports}var OS,EO;function TQ(){if(EO)return OS;EO=1;var n=oQ(),e=uQ(),t=hQ(),s=fQ(),r=mQ(),i=yQ(),a=SQ();return a.alea=n,a.xor128=e,a.xorwow=t,a.xorshift7=s,a.xor4096=r,a.tychei=i,OS=a,OS}var td=TQ();const CQ=.001,wz=.1;function NQ(n,e,t){return t==null&&(t=mN()),UT(n,e,(s,r)=>gN(s,r,t))}function mN(){return W.backend.floatPrecision()===32?CQ:wz}function UT(n,e,t){let s=!0;if((kn(n)||kn(e))&&(s=!1),kn(n)&&kn(e)&&(s=!0),s){const a=n.constructor.name,o=e.constructor.name;if(a!==o)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${o}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=ji(n),o=ji(e);if(!at(a,o))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${o}]`)}const r=kn(n)?n:Ui(n),i=kn(e)?e:Ui(e);if(r.length!==i.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${i.length}.
Actual:   ${r}.
Expected: ${i}.`);for(let a=0;a<i.length;++a){const o=r[a],l=i[a];if(!t(o,l))throw new Error(`Arrays differ: actual[${a}] = ${o}, expected[${a}] = ${l}.
Actual:   ${r}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function kQ(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function EQ(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Di(n)||Di(n[0])||Di(e)||Di(e[0])?UT(n,t,(s,r)=>s==r):UT(n,e,(s,r)=>gN(s,r,0))}function IQ(n,e,t){if(t==null&&(t=mN()),!gN(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function gN(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function $Q(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function _Q(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function vz(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?vz(t):n[e]=Mi(t)}return n}function AQ(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function RQ(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const DQ=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:wz,createVideoElement:AQ,encodeStrings:vz,expectArrayBuffersEqual:_Q,expectArraysClose:NQ,expectArraysEqual:EQ,expectNumbersClose:IQ,expectPromiseToFail:kQ,expectValuesInRange:$Q,play:RQ,testEpsilon:mN},Symbol.toStringTag,{value:"Module"}));class yN{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=i||Math.random();this.random=td.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,a;do r=2*this.random()-1,i=2*this.random()-1,a=r*r+i*i;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class OQ{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const i=r||Math.random();this.randu=td.alea(i.toString()),this.randn=new yN(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,i,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),i=this.randu(),i<t||Math.log(i)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class LQ{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=td.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function FQ(n,e,t=1,s="float32",r){if(tr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const i=new OQ(e,t,s,r),a=Qe(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Sz=G({randomGamma_:FQ});function MQ(n,e=0,t=1,s,r){if(tr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new yN(e,t,s,!1,r),a=Qe(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Mx=G({randomNormal_:MQ});function zQ(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Mx(n,0,1,e,t)}const Tz=G({randomStandardNormal_:zQ});function PQ(n,e=0,t=1,s="float32",r){tr(n);const i=Qe(n,s),a=new LQ(e,t,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Go=G({randomUniform_:PQ});function BQ(n,e,t,s){return Go(n,e,t,"int32",s)}const Cz=G({randomUniformInt_:BQ});function Zl(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return W.runKernel(tx,{},r)}function VQ(n){const t={input:M(n,"input","real")};return W.runKernel(nx,t)}const Uc=G({real_:VQ});function UQ(n){const t={x:M(n,"x","reciprocal")};return W.runKernel(Ah,t)}const bN=G({reciprocal_:UQ});function jQ(n){const t={x:M(n,"x","relu")};return W.runKernel(Rh,t)}const vi=G({relu_:jQ});function WQ(n){const t={x:M(n,"x","relu6")};return W.runKernel(Dh,t)}const zx=G({relu6_:WQ});function GQ(n,e){const s={x:M(n,"x","reverse")},r={dims:e};return W.runKernel(pm,s,r)}const Tr=G({reverse_:GQ});function HQ(n){const e=M(n,"x","reverse");return O(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Tr(e,0)}const Nz=G({reverse1d_:HQ});function qQ(n,e){const t=M(n,"x","reverse");return O(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Tr(t,e)}const kz=G({reverse2d_:qQ});function KQ(n,e){const t=M(n,"x","reverse");return O(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Tr(t,e)}const Ez=G({reverse3d_:KQ});function XQ(n,e){const t=M(n,"x","reverse");return O(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Tr(t,e)}const Iz=G({reverse4d_:XQ});function YQ(n){const t={x:M(n,"x","round")};return W.runKernel(Oh,t)}const Px=G({round_:YQ});function JQ(n){const t={x:M(n,"x","rsqrt","float32")};return W.runKernel(Lh,t)}const Bx=G({rsqrt_:JQ});function ZQ(n){const t={x:M(n,"x","selu")};return W.runKernel(Fh,t)}const Vx=G({selu_:ZQ});function QQ(n,e,t,s,r,i=[1,1],a="NHWC"){const o=M(n,"x","separableConv2d"),l=M(e,"depthwiseFilter","separableConv2d"),h=M(t,"pointwiseFilter","separableConv2d");let d=o,p=!1;if(o.rank===3&&(p=!0,d=Y(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");O(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),O(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),O(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),O(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),O(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=l.shape[2],y=l.shape[3];O(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=Yh(d,l,s,r,a,i),w=Ia(b,h,1,"valid",a);return p?Y(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const Ux=G({separableConv2d_:QQ});async function eee(n,e){const t=M(n,"x","setdiff1d"),s=M(e,"y","setdiff1d");O(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),O(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),O(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),a=new Set(i);let o=0;for(let d=0;d<r.length;d++)a.has(r[d])||o++;const l=new bn([o],t.dtype),h=new bn([o],"int32");for(let d=0,p=0;d<r.length;d++)a.has(r[d])||(l.values[p]=r[d],h.values[p]=d,p++);return[l.toTensor(),h.toTensor()]}const $z=eee;function tee(n){const t={x:M(n,"x","sign")};return W.runKernel(Ph,t)}const xN=G({sign_:tee});function nee(n){const t={x:M(n,"x","sin","float32")};return W.runKernel(Mh,t)}const jx=G({sin_:nee});function see(n){const t={x:M(n,"x","sinh")};return W.runKernel(zh,t)}const Wx=G({sinh_:see});function ree(n,e,t){const s=M(n,"x","slice1d");return O(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),ht(s,[e],[t])}const Bm=G({slice1d_:ree});function iee(n,e,t){const s=M(n,"x","slice2d");return O(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),ht(s,e,t)}const Gx=G({slice2d_:iee});function aee(n,e,t){const s=M(n,"x","slice3d");return O(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),ht(s,e,t)}const Vm=G({slice3d_:aee});function oee(n,e,t){const s=M(n,"x","slice4d");return O(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),ht(s,e,t)}const jc=G({slice4d_:oee});function lee(n,e=-1){const t=M(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return W.runKernel(wm,s,r)}const Um=G({softmax_:lee});function uee(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Mb,e)}const jm=G({fft_:uee});function cee(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Vb,e)}const Wc=G({ifft_:cee});function hee(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=Y(n,[t,e]);s=Wc(r)}else{const r=[t,2*(e-1)],i=Y(Uc(n),[t,e]),a=Y(Am(n),[t,e]),o=Tr(ht(i,[0,1],[t,e-2]),1),l=q(Tr(ht(a,[0,1],[t,e-2]),1),Pe(-1)),h=ln([i,o],1),d=ln([a,l],1),p=Y(Ea(h,d),[r[0],r[1]]);s=Wc(p)}if(s=Uc(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=Y(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const Hx=G({irfft_:hee});function dee(n,e,t=0){const r={x:M(n,"x","split")},i={numOrSizeSplits:e,axis:t};return W.runKernel(xm,r,i)}const $s=G({split_:dee});function fee(n,e){O(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=e,r=ht(n,b,x),t=e}else if(e!=null&&e>t){const b=n.shape.map(x=>x);b[n.shape.length-1]=e-t,r=ln([n,gn(b)],n.shape.length-1),t=e}else r=n;const i=dt(r),a=Y(Ea(r,i),[s,t]),o=jm(a),l=Math.floor(t/2)+1,h=Uc(o),d=Am(o),p=$s(h,[l,t-l],h.shape.length-1),m=$s(d,[l,t-l],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=l,Y(Ea(p[0],m[0]),y)}const Wm=G({rfft_:fee});function pee(n,e){let t=M(n,"a","squaredDifference"),s=M(e,"b","squaredDifference");[t,s]=Jt(t,s),Xe(t.shape,s.shape);const r={a:t,b:s},i={};return W.runKernel(jh,r,i)}const qx=G({squaredDifference_:pee});function mee(n,e){const t=M(n,"x","squeeze","string_or_numeric");return Y(t,Da(t.shape,e).newShape)}const Ho=G({squeeze_:mee});function gee(n,e=0){const t=rp(n,"tensors","stack","string_or_numeric");O(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&O(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return W.runKernel(om,s,r)}const bs=G({stack_:gee});function yee(n,e=0){const s={x:M(n,"x","step")},r={alpha:e};return W.runKernel(Kh,s,r)}const pu=G({step_:yee});function bee(n,e,t,s,r=0,i=0,a=0,o=0,l=0){const d={x:M(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return W.runKernel(px,d,p)}const wN=G({stridedSlice_:bee});function xee(n){const t={x:M(n,"x","tan","float32")};return W.runKernel(Gh,t)}const vN=G({tan_:xee});function Xn(n,e){lu(n);const t=ji(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Vo(n,null,t,e)}function To(n,e,t){if(lu(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=ji(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Vo(n,e,s,t)}function SN(n,e,t){if(lu(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=ji(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Vo(n,e,s,t)}function _z(n,e,t){if(lu(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ji(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Vo(n,e,s,t)}function Az(n,e,t){if(lu(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ji(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Vo(n,e,s,t)}function Rz(n,e,t){if(lu(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ji(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Vo(n,e,s,t)}function TN(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let a=0;a<r;++a)if(t.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-r;++a)if(t.shape[a+r]!==n[a+s])throw new Error(i+` updates.shape[${a+r}] (${t.shape[a+r]}) != shape[${a+r}] (${n[a+r]})`)}function Kx(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}TN(t,e,n)}function qo(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let a=1;for(let p=r;p<i;++p)a*=t[p];const o=r<1?1:r,l=he(e.shape)/o,h=[...Be(t.slice(0,r)),1],d=he(t);return{sliceRank:r,numUpdates:l,sliceSize:a,strides:h,outputSize:d}}const wee=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:qo,validateInput:Kx,validateUpdateShape:TN},Symbol.toStringTag,{value:"Module"}));function vee(n,e,t){const s=M(n,"tensor","tensorScatterupdate"),r=M(e,"indices","tensorScatterupdate","int32"),i=M(t,"updates","tensorScatterupdate");if(Kx(i,r,s.shape),s.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${i.dtype}.`);const a={tensor:s,indices:r,updates:i},o={};return W.runKernel(ax,a,o)}const Dz=G({tensorScatterUpdate_:vee});function See(n,e=1,t=!0){const s=M(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},a={k:e,sorted:t},[o,l]=W.runKernel(bx,i,a);return{values:o,indices:l}}const CN=G({topk_:See});function Tee(n,e=0,t=1,s,r){if(tr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new yN(e,t,s,!0,r),a=Qe(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Xx=G({truncatedNormal_:Tee});function Cee(n,e=0){const t=M(n,"x","unique","string_or_numeric");O(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,a]=W.runKernel(wx,s,r);return{values:i,indices:a}}const NN=G({unique_:Cee});function Nee(n,e,t){const s=M(n,"x","unsortedSegmentSum"),r=M(e,"segmentIds","unsortedSegmentSum","int32");O(Wl(t),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},a={numSegments:t};return W.runKernel(Tm,i,a)}const Yx=G({unsortedSegmentSum_:Nee});function kee(n,e=0){const t=M(n,"x","unstack","string_or_numeric");O(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return W.runKernel(Sm,s,r)}const Cr=G({unstack_:kee});function Oz(n,e){return Fx(n,e,"right")}function kN(n,e=!0,t,s){return W.makeVariable(n,e,t,s)}function Jx(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=Qe(n,"int32"),r=Qe([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const a=s.indexToLoc(t[i]),o=i*n.length;r.values.set(a,o)}return r.toTensor()}async function Eee(n){const e=M(n,"condition","whereAsync","bool"),t=await e.data(),s=Jx(e.shape,t);return n!==e&&e.dispose(),s}const EN=Eee;async function Iee(n,e,t){const s=M(n,"tensor","boolMask"),r=M(e,"mask","boolMask","bool"),i=t??0,a=r.rank,o=s.shape;O(a>0,()=>"mask cannot be scalar"),Jn(o.slice(i,i+a),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=i;x<i+a;x++)l*=o[x];const h=o.slice(0,i).concat([l],o.slice(i+a)),d=Y(s,h),p=Y(r,[-1]),m=await EN(p),y=Ho(m,[1]),b=ed(d,y,i);return n!==s&&s.dispose(),e!==r&&r.dispose(),y.dispose(),d.dispose(),p.dispose(),m.dispose(),b}const Lz=Iee;function $ee(n,e,t){const s=M(n,"x","transpose");if(e==null&&(e=s.shape.map((a,o)=>o).reverse()),O(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{O(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:e};return s.dtype==="complex64"?re(()=>{let a=Uc(s),o=Am(s);return a=W.runKernel(Bl,{x:a},i),o=W.runKernel(Bl,{x:o},i),t&&(o=Mt(o)),Ea(a,o)}):W.runKernel(Bl,r,i)}const lt=G({transpose_:$ee});function _ee(n,e,t,s,r=!0){const i=M(n,"v","movingAverage"),a=M(e,"x","movingAverage"),o=M(t,"decay","movingAverage");AM(i,a),O(at(i.shape,a.shape),()=>"Shape mismatch in v and x");const l=Pe(1),h=_e(l,o);let d=q(_e(a,i),h);if(r){O(s!=null,()=>"When using zeroDebias: true, step is required.");const p=M(s,"step","movingAverage");d=Le(d,_e(l,Wi(o,p)))}return ve(i,d)}const Fz=G({movingAverage_:_ee});function Aee(n,e,t){tr(t);const s=M(n,"indices","scatterND","int32"),r=M(e,"updates","scatterND");Kx(r,s,t);const i={indices:s,updates:r},a={shape:t};return W.runKernel(ix,i,a)}const Mz=G({scatterND_:Aee});function Ree(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Dee(n,e,t,s=0){tr(t);const r=M(n,"sparseIndices","sparseToDense","int32"),i=M(e,"sparseValues","sparseToDense","string_or_numeric"),a=M(s,"defaultValue","sparseToDense",i.dtype);Ree(r,i,t,a);const o={sparseIndices:r,sparseValues:i,defaultValue:a},l={outputShape:t};return W.runKernel(dx,o,l)}const zz=G({sparseToDense_:Dee});function Oee(n,e){const t=M(e,"indices","gatherND","int32"),r={params:M(n,"x","gatherND","string_or_numeric"),indices:t};return W.runKernel(Bb,r)}const Pz=G({gatherND_:Oee});function Lee(n,e){if(e==null)return n.shape.slice();if(at(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function Fee(n,e,t,s){const r=M(n,"x","dropout");if(O(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),O(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof bt?r.clone():r;const i=Lee(r,t),a=1-e,o=Le(Qh(ve(Go(i,0,1,"float32",s),a)),a);return q(r,o)}const IN=G({dropout_:Fee});function $N(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Zx(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const a=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(a)}return Xn(r,"float32")}async function Mee(n,e,t=1){const s=M(n,"predictions","inTopK"),r=M(e,"targets","inTopK");O(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),O(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Jn(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=s.shape[s.shape.length-1];O(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const a=await s.data(),o=await r.data(),[l,h]=[a.length/i,i],d=zn("bool",l);for(let p=0;p<l;p++){const m=p*h,y=a.subarray(m,m+h),b=[];for(let x=0;x<y.length;x++)b.push({value:y[x],index:x});b.sort((x,w)=>w.value-x.value),d[p]=0;for(let x=0;x<t;x++)if(b[x].index===o[p]){d[p]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Xs(d,r.shape,"bool")}const Bz=Mee;function zee(n,e,t,s,r,i="NHWC",a){let o=n;n.rank===3&&(o=Y(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=Y(e,[1,e.shape[0],e.shape[1],e.shape[2]])),O(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),O(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),O(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const h=i==="NHWC"?o.shape[3]:o.shape[1],d=i==="NHWC"?l.shape[3]:l.shape[1];O(h===t[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${t[2]}.`),O(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),ws("conv2dDerFilter",r,a);const p={x:o,dy:l},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:t};return W.runKernel(Cb,p,m)}const _N=G({conv2DBackpropFilter_:zee});function Qx(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return q(n,pu(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ew(n,e){let t=e;const s=xn(n.shape,e.shape);return s.length>0&&(t=Re(t,s)),Y(t,n.shape)}function tw(n,e,t,s){if(e==="linear")return n;if(e==="relu")return vi(n);if(e==="elu")return Jh(n);if(e==="relu6")return zx(n);if(e==="prelu")return Pm(n,t);if(e==="leakyrelu")return Rm(n,s);if(e==="sigmoid")return fi(n);throw new Error(`Unknown fused activation ${e}.`)}const nw=(n,e)=>!(n>0)||e==="linear";function Pee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(l=l||"linear",nw(W.state.gradientDepth,l)===!1){O(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let A=Ia(n,e,t,s,r,i,a);return o!=null&&(A=ve(A,o)),tw(A,l,h,d)}const p=M(n,"x","conv2d","float32"),m=M(e,"filter","conv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=Y(p,[1,p.shape[0],p.shape[1],p.shape[2]])),O(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),O(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),ws("fused conv2d",s,a);const x=r==="NHWC"?y.shape[3]:y.shape[1];O(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),O(Zn(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const w=Vn(y.shape,m.shape,t,i,s,a);let v;o!=null&&(v=M(o,"bias","fused conv2d"),[v]=Jt(v,p),r==="NHWC"?Xe(w.outShape,v.shape):(O(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),O(v.shape.length===0||v.shape[0]===w.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let C;if(h!=null){const A=h.shape;if(O(A.length<=1||A.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`),A.length===1)O(A[0]===1||A[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${w.outChannels}).`);else if(A.length===3)try{Xe(A,w.outShape)}catch{const D=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(D)}C=M(h,"prelu weights","fused conv2d")}const N=(A,R)=>{O(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[D,L,F,_]=R,V=Qx(A,F,l);O(Ao(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Q=K2(L.shape,V,D,t,s),ne=_N(L,V,D.shape,t,s),Z=[Q,ne];if(_!=null){const B=ew(_,V);Z.push(B)}return Z},k={x:y,filter:m,bias:v,preluActivationWeights:C},E={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:d};return o==null?Gi((R,D,L)=>{let F=W.runKernel(Qf,k,E);return L([D,R,F]),b&&(F=Y(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:N}})(y,m):Gi((R,D,L,F)=>{let _=W.runKernel(Qf,k,E);return F([D,R,_,L]),b&&(_=Y(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:N}})(y,m,v)}const Vz=G({fusedConv2d_:Pee});function Bee(n,e,t,s,r,i=[1,1],a){let o=n;n.rank===3&&(o=Y(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=Y(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={x:o,dy:l},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:t};return W.runKernel(Ab,h,d)}const Uz=G({depthwiseConv2dNativeBackpropFilter_:Bee});function Vee(n,e,t,s,r,i=[1,1],a){let o=e,l=!1;e.rank===3&&(l=!0,o=Y(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:o,filter:t},d={strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:n},p=W.runKernel(Rb,h,d);return l?Y(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const jz=G({depthwiseConv2dNativeBackpropInput_:Vee});function Uee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(nw(W.state.gradientDepth,l)===!1){let E=Yh(n,e,t,s,r,i,a);return o!=null&&(E=ve(E,o)),tw(E,l,h,d)}const p=M(n,"x","depthwiseConv2d","float32"),m=M(e,"filter","depthwiseConv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=Y(p,[1,p.shape[0],p.shape[1],p.shape[2]])),O(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),O(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),O(y.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),i==null&&(i=[1,1]),O(Zn(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ws("fused depthwiseConv2d",s,a);const x=Vn(y.shape,m.shape,t,i,s,a,!0);let w;o!=null&&(w=M(o,"bias","fused conv2d"),[w]=Jt(w,p),Xe(x.outShape,w.shape));let v;h!=null&&(v=M(h,"prelu weights","fused depthwiseConv2d"));const C=(E,A)=>{O(Ao(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[R,D,L,F]=A,_=Qx(E,L,l),V=jz(D.shape,_,R,t,s,i,a),Q=Uz(D,_,R.shape,t,s,i,a);if(F!=null){const ne=ew(w,_);return[V,Q,ne]}return[V,Q]},N={x:y,filter:m,bias:w,preluActivationWeights:v},k={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:d};return o==null?Gi((A,R,D)=>{let L=W.runKernel(ep,N,k);return D([R,A,L]),b&&(L=Y(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(y,m):Gi((A,R,D,L)=>{let F=W.runKernel(ep,N,k);return L([R,A,F,D]),b&&(F=Y(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:C}})(y,m,w)}const jee=G({fusedDepthwiseConv2d_:Uee});function Wee({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(nw(W.state.gradientDepth,i)===!1){let _=nt(n,e,t,s);return r!=null&&(_=ve(_,r)),tw(_,i,a,o)}let l=M(n,"a","fused matMul"),h=M(e,"b","fused matMul");[l,h]=Jt(l,h);const d=t?l.shape[l.rank-2]:l.shape[l.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=t?l.shape[l.rank-1]:l.shape[l.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=l.shape.slice(0,-2),x=h.shape.slice(0,-2),w=he(b),v=he(x);O(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${l.shape} and ${h.shape} and transposeA=${t} and transposeB=${s} must match.`);const N=Xe(l.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),k=t?Y(l,[w,d,m]):Y(l,[w,m,d]),E=s?Y(h,[v,y,p]):Y(h,[v,p,y]);let A;r!=null&&(A=M(r,"bias","fused matMul"),[A]=Jt(A,l),Xe(N,A.shape));let R;a!=null&&(R=M(a,"prelu weights","fused matMul"));const D=(_,V)=>{const[Q,ne,Z,B]=V,U=Qx(Y(_,Z.shape),Z,i);let K,X;if(!t&&!s?(K=nt(U,ne,!1,!0),X=nt(Q,U,!0,!1)):!t&&s?(K=nt(U,ne,!1,!1),X=nt(U,Q,!0,!1)):t&&!s?(K=nt(ne,U,!1,!0),X=nt(Q,U,!1,!1)):(K=nt(ne,U,!0,!0),X=nt(U,Q,!0,!0)),r!=null){const se=ew(B,U);return[K,X,se]}else return[K,X]},L={a:k,b:E,bias:A,preluActivationWeights:R},F={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:o};return r==null?Gi((V,Q,ne)=>{const Z=W.runKernel(Zf,L,F);return ne([V,Q,Z]),{value:Y(Z,N),gradFunc:D}})(k,E):Gi((V,Q,ne,Z)=>{const B=W.runKernel(Zf,L,F);return Z([V,Q,B,ne]),{value:Y(B,N),gradFunc:D}})(k,E,A)}const jT=G({fusedMatMul_:Wee});const Wz=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Vz,depthwiseConv2d:jee,matMul:jT},Symbol.toStringTag,{value:"Module"}));function Gee(n){return Zx(n,.54,.46)}const Hee=G({hammingWindow_:Gee});function qee(n){return Zx(n,.5,.5)}const Gz=G({hannWindow_:qee});function Kee(n,e,t,s=!1,r=0){let i=0;const a=[];for(;i+e<=n.size;)a.push(ht(n,i,e)),i+=t;if(s)for(;i<n.size;){const o=i+e-n.size,l=ln([ht(n,i,e-o),du([o],r)]);a.push(l),i+=t}return a.length===0?To([],[0,e]):Y(ln(a),[a.length,e])}const Hz=G({frame_:Kee});function Xee(n,e,t,s,r=Gz){s==null&&(s=$N(e));const i=Hz(n,e,t),a=q(i,r(e));return Wm(a,s)}const Yee=G({stft_:Xee});function Jee(n,e,t,s,r="bilinear",i=0){const a=M(n,"image","cropAndResize"),o=M(e,"boxes","cropAndResize","float32"),l=M(t,"boxInd","cropAndResize","int32"),h=o.shape[0];O(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),O(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${o.shape}.`),O(l.rank===1&&l.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${o.shape}.`),O(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),O(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),O(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:a,boxes:o,boxInd:l},p={method:r,extrapolationValue:i,cropSize:s};return W.runKernel(Ib,d,p)}const Zee=G({cropAndResize_:Jee});function Qee(n){const e=M(n,"image","flipLeftRight","float32");O(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return W.runKernel(Pb,t,{})}const ete=G({flipLeftRight_:Qee});function tte(n){const e=M(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),O(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,br(e,r)}const nte=G({grayscaleToRGB_:tte});function ste(n){const e=M(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),O(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,i=Ne(e,"float32"),a=Xn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Il("ij,j->i",i,a);break;case 3:o=Il("ijk,k->ij",i,a);break;case 4:o=Il("ijkl,l->ijk",i,a);break;case 5:o=Il("ijklm,m->ijkl",i,a);break;case 6:o=Il("ijklmn,n->ijklm",i,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Hn(o,-1),Ne(o,r)}const rte=G({rgbToGrayscale_:ste});function ite(n,e,t=0,s=.5){const r=M(n,"image","rotateWithOffset","float32");O(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},a={radians:e,fillValue:t,center:s};return W.runKernel(vx,i,a)}const ate=G({rotateWithOffset_:ite});function nd(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const a=n.shape[0];return t=Math.min(t,a),O(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),O(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),O(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),O(e.rank===1,()=>"scores must be a 1D tensor"),O(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),O(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function ote(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=M(n,"boxes","nonMaxSuppression","float32"),a=M(e,"scores","nonMaxSuppression","float32"),o=nd(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return W.runKernel(Xb,{boxes:i,scores:a},l)}const lte=G({nonMaxSuppression_:ote});function ute(n,e,t){const s=cte(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function cte(n,e,t){return dte(n,e,t||hte)}function hte(n,e){return n>e?1:n<e?-1:0}function dte(n,e,t){let s=0,r=n.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=t(e,n[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}function sw(n,e,t,s,r){return AN(n,e,t,s,r,0)}function rw(n,e,t,s,r,i){return AN(n,e,t,s,r,0,!1,i,!0)}function iw(n,e,t,s,r,i){return AN(n,e,t,s,r,i,!0)}function AN(n,e,t,s,r,i,a=!1,o=!1,l=!1){const h=[];for(let w=0;w<e.length;w++)e[w]>r&&h.push({score:e[w],boxIndex:w,suppressBeginIndex:0});h.sort(IO);const d=i>0?-.5/i:0,p=[],m=[];for(;p.length<t&&h.length>0;){const w=h.pop(),{score:v,boxIndex:C,suppressBeginIndex:N}=w;if(v<r)break;let k=!1;for(let E=p.length-1;E>=N;--E){const A=fte(n,C,p[E]);if(A>=s){k=!0;break}if(w.score=w.score*pte(s,d,A),w.score<=r)break}w.suppressBeginIndex=p.length,k||(w.score===v?(p.push(C),m.push(w.score)):w.score>r&&ute(h,w,IO))}const y=p.length,b=t-y;o&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:p};return a&&(x.selectedScores=m),l&&(x.validOutputs=y),x}function fte(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(o-i)*(l-a),b=(p-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(i,h),w=Math.max(a,d),v=Math.min(o,p),C=Math.min(l,m),N=Math.max(v-x,0)*Math.max(C-w,0);return N/(y+b-N)}function pte(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function IO(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function mte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=M(n,"boxes","nonMaxSuppressionAsync"),a=M(e,"scores","nonMaxSuppressionAsync"),o=nd(i,a,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l=await Promise.all([i.data(),a.data()]),h=l[0],d=l[1],{selectedIndices:p}=sw(h,d,t,s,r);return i!==n&&i.dispose(),a!==e&&a.dispose(),Xn(p,"int32")}const gte=mte;function yte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=M(n,"boxes","nonMaxSuppression"),o=M(e,"scores","nonMaxSuppression"),l=nd(a,o,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const h={boxes:a,scores:o},d={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},p=W.runKernel(Jb,h,d);return{selectedIndices:p[0],selectedScores:p[1]}}const bte=G({nonMaxSuppressionWithScore_:yte});async function xte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const a=M(n,"boxes","nonMaxSuppressionAsync"),o=M(e,"scores","nonMaxSuppressionAsync"),l=nd(a,o,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const h=await Promise.all([a.data(),o.data()]),d=h[0],p=h[1],{selectedIndices:m,selectedScores:y}=iw(d,p,t,s,r,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Xn(m,"int32"),selectedScores:Xn(y)}}const wte=xte;function vte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=M(n,"boxes","nonMaxSuppression"),o=M(e,"scores","nonMaxSuppression"),l=nd(a,o,t,s,r,null),h=l.maxOutputSize,d=l.iouThreshold,p=l.scoreThreshold,m={boxes:a,scores:o},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:i},b=W.runKernel(Yb,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const Ste=G({nonMaxSuppressionPadded_:vte});async function Tte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const a=M(n,"boxes","nonMaxSuppressionAsync"),o=M(e,"scores","nonMaxSuppressionAsync"),l=nd(a,o,t,s,r,null),h=l.maxOutputSize,d=l.iouThreshold,p=l.scoreThreshold,[m,y]=await Promise.all([a.data(),o.data()]),{selectedIndices:b,validOutputs:x}=rw(m,y,h,d,p,i);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Xn(b,"int32"),validOutputs:Pe(x,"int32")}}const Cte=Tte;function Nte(n,e,t=!1,s=!1){const r=M(n,"images","resizeBilinear");O(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),O(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=Y(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},h=W.runKernel(fm,o,l);return a?Y(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const qz=G({resizeBilinear_:Nte});function kte(n,e,t=!1,s=!1){const r=M(n,"images","resizeNearestNeighbor");O(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),O(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),O(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,a=!1;r.rank===3&&(a=!0,i=Y(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},h=W.runKernel(dm,o,l);return a?Y(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Kz=G({resizeNearestNeighbor_:kte});function Ete(n,e="binary",t=!1,s=.5){const r=M(n,"image","threshold"),i=.2989,a=.587,o=.114,l=r.shape[0]*r.shape[1];let h=q(Xn([s]),255),d,p,m,y;if(O(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),O(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),O(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),O(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,p,m]=$s(r,[1,1,1],-1);const w=q(d,i),v=q(p,a),C=q(m,o);y=ve(ve(w,v),C)}else y=n;if(e==="otsu"){const w=U2(Ne(Px(y),"int32"),Xs([]),256);h=Ite(w,l)}const b=t?Wo(y,h):vs(y,h);return Ne(q(b,255),"int32")}function Ite(n,e){let t=Xn([-1]),s=Xn([0]),r=Xn([0]),i,a,o,l,h,d;for(let p=0;p<n.size-1;p++){i=ht(n,0,p+1),a=ht(n,p+1),h=Le(Re(i),e),d=Le(Re(a),e);const m=Re(q(i,Zl(0,i.size)));o=Le(m,Re(i));const y=du(a.shape,i.size),b=ve(Zl(0,a.size),y),x=q(a,b);l=Le(Re(x),Re(a));const w=_e(o,l),v=_e(o,l),C=q(h,d);r=q(q(C,w),v);const N=vs(r,s);s=Mn(N,r,s),t=Mn(N,Xn([p]),t)}return t}const $te=G({threshold_:Ete});function _te(n,e,t="nearest",s="constant",r=0,i){const a=M(n,"image","transform","float32"),o=M(e,"transforms","transform","float32");O(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),O(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),O(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:a,transforms:o},h={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return W.runKernel(xx,l,h)}const Ate=G({transform_:_te});function Rte(n,e,t){const s=M(n,"a","bandPart");O(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,a]=s.shape.slice(-2);let o,l;typeof e=="number"?(O(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),O(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),o=M(e<0?i:e,"numLower","bandPart")):(O(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Mn(Bc(e,0),i,Do(e,i))),typeof t=="number"?(O(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),O(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),l=M(t<0?a:t,"numUpper","bandPart")):(O(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Mn(Bc(t,0),a,Do(t,a)));const h=Y(Zl(0,i,1,"int32"),[-1,1]),d=Zl(0,a,1,"int32"),p=_e(h,d),m=Hr(Wo(p,o),Ma(p,Mt(l))),y=gn([i,a],s.dtype);return Y(bs(Cr(Y(s,[-1,i,a])).map(b=>Mn(m,b,y))),r)}const Dte=G({bandPart_:Rte});function Ote(n){let e;if(Array.isArray(n)){e=!1,O(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)O(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=$s(n,n.shape[0],0).map(r=>Ho(r,[0]));O(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(W.tidy(()=>{let i=s[r];if(r>0)for(let a=0;a<r;++a){const o=q(Re(q(t[a],i)),t[a]);i=_e(i,o)}return Le(i,Zh(i,"euclidean"))}));return e?bs(t,0):t}const Lte=G({gramSchmidt_:Ote});function Fte(n,e=!1){if(O(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return $O(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,h)=>l*h),s=Cr(Y(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[h,d]=$O(l,e);r.push(h),i.push(d)});const a=Y(bs(r,0),n.shape),o=Y(bs(i,0),n.shape);return[a,o]}}function $O(n,e=!1){return W.tidy(()=>{O(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=Rx(t),i=zi(n);const a=To([[1]],[1,1]);let o=zi(a);const l=t>=s?s:t;for(let h=0;h<l;++h){const d=i,p=o,m=r;[o,i,r]=W.tidy(()=>{const y=ht(i,[h,h],[t-h,1]),b=Zh(y),x=ht(i,[h,h],[1,1]),w=Mn(vs(x,0),To([[-1]]),To([[1]])),v=_e(x,q(w,b)),C=Le(y,v);C.shape[0]===1?o=zi(a):o=ln([a,ht(C,[1,0],[C.shape[0]-1,C.shape[1]])],0);const N=Mt(Le(nt(w,v),b)),k=ht(i,[h,0],[t-h,s]),E=q(N,o),A=lt(o);if(h===0)i=_e(k,nt(E,nt(A,k)));else{const L=_e(k,nt(E,nt(A,k)));i=ln([ht(i,[0,0],[h,s]),L],0)}const R=lt(E),D=ht(r,[0,h],[t,r.shape[1]-h]);if(h===0)r=_e(D,nt(nt(D,o),R));else{const L=_e(D,nt(nt(D,o),R));r=ln([ht(r,[0,0],[t,h]),L],1)}return[o,i,r]}),Ke([d,p,m])}return!e&&t>s&&(r=ht(r,[0,0],[t,s]),i=ht(i,[0,0],[s,s])),[r,i]})}const Mte=G({qr_:Fte});var ms;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ms||(ms={}));function zte(n,e,t=ms.SUM_BY_NONZERO_WEIGHTS){const s=M(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=M(e,"weights","computeWeightedLoss"));const i=r==null?s:q(s,r);if(t===ms.NONE)return i;if(t===ms.SUM)return Re(i);if(t===ms.MEAN){if(r==null)return Kt(i);{const a=s.size/r.size,o=Le(Re(i),Re(r));return a>1?Le(o,Pe(a)):o}}if(t===ms.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Le(Re(i),Pe(s.size));{const a=q(r,Is(s.shape)),o=Ne(Re(Jl(a,Pe(0))),"float32");return Le(Re(i),o)}}throw Error(`Unknown reduction: ${t}`)}const Pa=G({computeWeightedLoss_:zte});function Pte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){const r=M(n,"labels","absoluteDifference"),i=M(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=M(t,"weights","absoluteDifference")),Jn(r.shape,i.shape,"Error in absoluteDifference: ");const o=mn(_e(r,i));return Pa(o,a,s)}const Bte=G({absoluteDifference_:Pte});function Vte(n,e,t,s,r=ms.SUM_BY_NONZERO_WEIGHTS){const i=M(n,"labels","cosineDistance"),a=M(e,"predictions","cosineDistance");let o=null;s!=null&&(o=M(s,"weights","cosineDistance")),Jn(i.shape,a.shape,"Error in cosineDistance: ");const l=Pe(1),h=_e(l,Re(q(i,a),t,!0));return Pa(h,o,r)}const Ute=G({cosineDistance_:Vte});function jte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){let r=M(n,"labels","hingeLoss");const i=M(e,"predictions","hingeLoss");let a=null;t!=null&&(a=M(t,"weights","hingeLoss")),Jn(r.shape,i.shape,"Error in hingeLoss: ");const o=Pe(1);r=_e(q(Pe(2),r),o);const l=vi(_e(o,q(r,i)));return Pa(l,a,s)}const Wte=G({hingeLoss_:jte});function Gte(n,e,t,s=1,r=ms.SUM_BY_NONZERO_WEIGHTS){const i=M(n,"labels","huberLoss"),a=M(e,"predictions","huberLoss");let o=null;t!=null&&(o=M(t,"weights","huberLoss")),Jn(i.shape,a.shape,"Error in huberLoss: ");const l=Pe(s),h=mn(_e(a,i)),d=Do(h,l),p=_e(h,d),m=ve(q(Pe(.5),It(d)),q(l,p));return Pa(m,o,r)}const Hte=G({huberLoss_:Gte});function qte(n,e,t,s=1e-7,r=ms.SUM_BY_NONZERO_WEIGHTS){const i=M(n,"labels","logLoss"),a=M(e,"predictions","logLoss");let o=null;t!=null&&(o=M(t,"weights","logLoss")),Jn(i.shape,a.shape,"Error in logLoss: ");const l=Pe(1),h=Pe(s),d=Mt(q(i,Js(ve(a,h)))),p=q(_e(l,i),Js(ve(_e(l,a),h))),m=_e(d,p);return Pa(m,o,r)}const Kte=G({logLoss_:qte});function Xte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){const r=M(n,"labels","meanSquaredError"),i=M(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=M(t,"weights","meanSquaredError")),Jn(r.shape,i.shape,"Error in meanSquaredError: ");const o=qx(r,i);return Pa(o,a,s)}const Yte=G({meanSquaredError_:Xte});function Jte(n,e){const t=M(n,"labels","sigmoidCrossEntropyWithLogits"),s=M(e,"logits","sigmoidCrossEntropyWithLogits");Jn(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=vi(s),i=q(s,t),a=Dm(Ds(Mt(mn(s))));return ve(_e(r,i),a)}function Zte(n,e,t,s=0,r=ms.SUM_BY_NONZERO_WEIGHTS){let i=M(n,"multiClassLabels","sigmoidCrossEntropy");const a=M(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=M(t,"weights","sigmoidCrossEntropy")),Jn(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const h=Pe(s),d=Pe(1),p=Pe(.5);i=ve(q(i,_e(d,h)),q(p,h))}const l=Jte(i,a);return Pa(l,o,r)}const Qte=G({sigmoidCrossEntropy_:Zte});function ene(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Gi((r,i,a)=>{const l=Om(i,[t],!0),h=_e(Ne(i,"float32"),l);a([r,h]);const d=Mt(q(h,r));return{value:Re(d,[t]),gradFunc:(y,b)=>{const[x,w]=b,v=un(y.shape,[t]);return[q(Y(y,v),_e(Ne(x,"float32"),Ds(w))),q(Y(y,v),_e(Ds(w),Ne(x,"float32")))]}}})(n,e)}function tne(n,e,t,s=0,r=ms.SUM_BY_NONZERO_WEIGHTS){let i=M(n,"onehotLabels","softmaxCrossEntropy");const a=M(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=M(t,"weights","softmaxCrossEntropy")),Jn(i.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const h=Pe(s),d=Pe(1),p=Pe(i.shape[1]);i=ve(q(i,_e(d,h)),Le(h,p))}const l=ene(i,a);return Pa(l,o,r)}const nne=G({softmaxCrossEntropy_:tne});function sne(n,e,t,s){const r=M(n,"indices","sparseFillEmptyRows","int32"),i=M(e,"values","sparseFillEmptyRows"),a=M(t,"denseShape","sparseFillEmptyRows","int32"),o=M(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:r,values:i,denseShape:a,defaultValue:o},h=W.runKernel(lx,l);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}const rne=G({sparseFillEmptyRows_:sne});function ine(n,e,t){const s=M(n,"inputIndices","sparseReshape","int32"),r=M(e,"inputShape","sparseReshape","int32"),i=M(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:s,inputShape:r,newShape:i},o=W.runKernel(ux,a);return{outputIndices:o[0],outputShape:o[1]}}const ane=G({sparseReshape_:ine});function one(n,e,t){const s=M(n,"data","sparseSegmentMean"),r=M(e,"indices","sparseSegmentMean","int32"),i=M(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return W.runKernel(cx,a)}const lne=G({sparseSegmentMean_:one});function une(n,e,t){const s=M(n,"data","sparseSegmentSum"),r=M(e,"indices","sparseSegmentSum","int32"),i=M(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const a={data:s,indices:r,segmentIds:i};return W.runKernel(hx,a)}const cne=G({sparseSegmentSum_:une});function hne(n,e,t,s,r,i,a,o){const l=M(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const h=M(e,"dataSplits","stringNGrams");if(h.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:a,preserveShortSequences:o},p={data:l,dataSplits:h},m=W.runKernel(mx,p,d);return{nGrams:m[0],nGramsSplits:m[1]}}const dne=G({stringNGrams_:hne});function fne(n,e,t=!0){const s=M(n,"input","stringSplit","string"),r=M(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},a={input:s,delimiter:r},o=W.runKernel(gx,a,i);return{indices:o[0],values:o[1],shape:o[2]}}const pne=G({stringSplit_:fne});function mne(n,e){const t=M(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return W.runKernel(yx,r,s)}const gne=G({stringToHashBucketFast_:mne});function yne(n,e,t,s=!0){const r=M(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:s};return W.runKernel(vm,{x:r},i)}const bne=G({staticRegexReplace_:yne});const Xz={fft:jm,ifft:Wc,rfft:Wm,irfft:Hx},Yz={hammingWindow:Hee,hannWindow:Gz,frame:Hz,stft:Yee},jr={flipLeftRight:ete,grayscaleToRGB:nte,resizeNearestNeighbor:Kz,resizeBilinear:qz,rgbToGrayscale:rte,rotateWithOffset:ate,cropAndResize:Zee,nonMaxSuppression:lte,nonMaxSuppressionAsync:gte,nonMaxSuppressionWithScore:bte,nonMaxSuppressionWithScoreAsync:wte,nonMaxSuppressionPadded:Ste,nonMaxSuppressionPaddedAsync:Cte,threshold:$te,transform:Ate},RN={bandPart:Dte,gramSchmidt:Lte,qr:Mte},Jz={absoluteDifference:Bte,computeWeightedLoss:Pa,cosineDistance:Ute,hingeLoss:Wte,huberLoss:Hte,logLoss:Kte,meanSquaredError:Yte,sigmoidCrossEntropy:Qte,softmaxCrossEntropy:nne},Zz={sparseFillEmptyRows:rne,sparseReshape:ane,sparseSegmentMean:lne,sparseSegmentSum:cne},Qz={stringNGrams:dne,stringSplit:pne,stringToHashBucketFast:gne,staticRegexReplace:bne};const xne=new Map,WT=new Map;class mu{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yr{constructor(){this.classNameMap={}}static getMap(){return yr.instance==null&&(yr.instance=new yr),yr.instance}static register(e){yr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Se(n,e,t){O(n.className!=null,()=>"Class being registered does not have the static className property defined."),O(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),O(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return yr.register(n),xne.set(r,n),WT.set(n,r),n}function wne(n){return WT.has(n)?WT.get(n):n.className}const vne=Object.freeze(Object.defineProperty({__proto__:null,Serializable:mu,SerializationMap:yr,getRegisteredName:wne,registerClass:Se},Symbol.toStringTag,{value:"Module"}));class Ba extends mu{minimize(e,t=!1,s){const{value:r,grads:i}=this.computeGradients(e,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:i[o.name]}));this.applyGradients(a)}else this.applyGradients(i);return Ke(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return iz(e,t)}dispose(){this.iterations_!=null&&Ke(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Pe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ba,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class DN extends Ba{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:re(()=>dt(i).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:re(()=>dt(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;re(()=>{const d=ve(q(l,this.rho),q(It(o),1-this.rho)),p=q(Le(Pn(ve(h,this.epsilon)),Pn(ve(l,this.epsilon))),o),m=ve(q(h,this.rho),q(It(p),1-this.rho));l.assign(d),h.assign(m);const y=ve(q(p,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ke(this.accumulatedGrads.map(e=>e.variable)),Ke(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class ON extends Ba{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:re(()=>du(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const o=this.accumulatedGrads[r].variable;re(()=>{const l=ve(o,It(a));o.assign(l);const h=ve(q(Le(a,Pn(ve(l,W.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ke(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class LN extends Ba{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],re(()=>{this.accBeta1=Pe(t).variable(),this.accBeta2=Pe(s).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);re(()=>{const s=_e(1,this.accBeta1),r=_e(1,this.accBeta2);t.forEach((i,a)=>{const o=W.registeredVariables[i],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:re(()=>dt(o).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:re(()=>dt(o).variable(l))});const h=Array.isArray(e)?e[a].tensor:e[i];if(h==null)return;const d=this.accumulatedFirstMoment[a].variable,p=this.accumulatedSecondMoment[a].variable,m=ve(q(d,this.beta1),q(h,1-this.beta1)),y=ve(q(p,this.beta2),q(It(h),1-this.beta2)),b=Le(m,s),x=Le(y,r);d.assign(m),p.assign(y);const w=ve(q(Le(b,ve(Pn(x),this.epsilon)),-this.learningRate),o);o.assign(w)}),this.accBeta1.assign(q(this.accBeta1,this.beta1)),this.accBeta2.assign(q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ke(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ke(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),re(()=>{this.accBeta1.assign(Wi(this.beta1,this.iterations_+1)),this.accBeta2.assign(Wi(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class FN extends Ba{static get className(){return"Adamax"}constructor(e,t,s,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],re(()=>{this.iteration=Pe(0).variable(),this.accBeta1=Pe(t).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);re(()=>{const s=_e(1,this.accBeta1),r=Le(-this.learningRate,ve(q(this.iteration,this.decay),1));t.forEach((i,a)=>{const o=W.registeredVariables[i],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:dt(o).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:dt(o).variable(l)});const h=Array.isArray(e)?e[a].tensor:e[i];if(h==null)return;const d=this.accumulatedFirstMoment[a].variable,p=this.accumulatedWeightedInfNorm[a].variable,m=ve(q(d,this.beta1),q(h,1-this.beta1)),y=q(p,this.beta2),b=mn(h),x=qi(y,b);d.assign(m),p.assign(x);const w=ve(q(Le(r,s),Le(m,ve(x,this.epsilon))),o);o.assign(w)}),this.iteration.assign(ve(this.iteration,1)),this.accBeta1.assign(q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ke(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ke(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class aw extends Ba{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=W.registeredVariables[s];re(()=>{const o=ve(q(this.c,i),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=En(Pe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class MN extends aw{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Pe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:re(()=>dt(i).variable(!1))});const a=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&re(()=>{let l;const h=ve(q(this.m,a),o);this.useNesterov?l=ve(q(this.c,ve(o,q(h,this.m))),i):l=ve(q(this.c,h),i),a.assign(h),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ke(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class zN extends Ba{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=W.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const i=W.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:re(()=>dt(i).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:re(()=>dt(i).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:re(()=>dt(i).variable(a))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;re(()=>{const d=ve(q(l,this.decay),q(It(o),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,m=ve(q(p,this.decay),q(o,1-this.decay)),y=Le(q(o,this.learningRate),Pn(_e(d,ve(It(m),this.epsilon)))),b=ve(q(h,this.momentum),y);l.assign(d),p.assign(m),h.assign(b);const x=_e(i,b);i.assign(x)}else{const p=ve(q(l,this.decay),q(It(o),1-this.decay)),m=ve(q(h,this.momentum),Le(q(o,this.learningRate),Pn(ve(p,this.epsilon))));l.assign(p),h.assign(m);const y=_e(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ke(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ke(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ke(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Sne=[DN,ON,LN,FN,MN,zN,aw];function Tne(){for(const n of Sne)Se(n)}const Cne="model",Nne=".json",kne=".weights.bin";function _O(n){return new Promise(e=>setTimeout(e)).then(n)}class Ql{constructor(e){if(!ae().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ql.URL_SCHEME)&&(e=e.slice(Ql.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Cne),this.modelJsonFileName=e+Nne,this.weightDataFileName=e+kne}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=wi.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=PM(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await _O(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await _O(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:km(e)}}}}Ql.URL_SCHEME="downloads://";class Ene{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const i=JSON.parse(r.target.result),a=i.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const l=E2(i,h=>this.loadWeights(h));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),i=s.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(i).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((s,r)=>{const i=new FileReader;i.onload=a=>{const o=a.target.result;s(o)},i.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(i=>xO(i.name)),r={};for(const i of e)i.paths.forEach(a=>{const o=xO(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[a]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const Ine=n=>ae().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ql.URL_SCHEME)?$ne(n.slice(Ql.URL_SCHEME.length)):null;qt.registerSaveRouter(Ine);function $ne(n="model"){return new Ql(n)}function _ne(n){return new Ene(n)}function AO(n,e,t,s){a(n),t=t??0,s=s??1,o(t,s);let r=0;const i=l=>(l.then(h=>{const d=t+ ++r/n.length*(s-t);return e(d),h}),l);function a(l){O(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,h){O(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),O(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),O(h>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${h}`)}return Promise.all(n.map(i))}async function eP(n,e){e==null&&(e={});const t=e.fetchFunc==null?ae().platform.fetch:e.fetchFunc,s=n.map(p=>t(p,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await AO(s,e.onProgress,0,.5)).map(p=>p.arrayBuffer());return e.onProgress==null?await Promise.all(o):await AO(o,e.onProgress,.5,1)}function Ane(n,e){var t;const s=e.fetchFunc==null?ae().platform.fetch:e.fetchFunc;let r=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var o;r<n.length;){i||(i=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:h}=await i.read();if(l){r++,i=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/n.length);continue}a.enqueue(h);return}a.close()}})}async function tP(n,e="",t,s){return nP(a=>eP(a,{requestInit:s}))(n,e,t)}function nP(n){return async(e,t="",s)=>{const r=e.map(()=>!1),i={},a=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((y,b)=>{let x=0;y.weights.forEach(w=>{const v="quantization"in w?w.quantization.dtype:w.dtype,C=Gl[v]*he(w.shape),N=()=>{r[b]=!0,i[b]==null&&(i[b]=[]),i[b].push({manifestEntry:w,groupOffset:x,sizeBytes:C})};s!=null?s.forEach((k,E)=>{k===w.name&&(N(),a[E]=!0)}):N(),o.push(w.name),x+=C})}),!a.every(y=>y)){const y=s.filter((b,x)=>!a[x]);throw new Error(`Could not find weights in manifest with names: ${y.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((y,b,x)=>(b&&y.push(x),y),[]),h=[];l.forEach(y=>{e[y].paths.forEach(b=>{const x=t+(t.endsWith("/")?"":"/")+b;h.push(x)})});const d=await n(h),p={};let m=0;return l.forEach(y=>{const b=e[y].paths.length,x=new wi(d.slice(m,m+b));i[y].forEach(v=>{const C=x.slice(v.groupOffset,v.groupOffset+v.sizeBytes),N=C2(C,[v.manifestEntry]);for(const k in N)p[k]=N[k]}),m+=b}),p}}const Rne="application/octet-stream",Dne="application/json";class PN{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(O(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ae().platform.fetch,O(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&O(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=PM(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Dne}),"model.json"),e.weightData!=null){const a=wi.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:Rne}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:km(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return E2(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=L0(e.weightsManifest),r=()=>Ane(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=One(t),i=this.weightPathPrefix||s,a=[],o=[];for(const l of e)for(const h of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(h)):a.push(i+h+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){const t=await this.getWeightUrls(e),s=L0(e),r=await eP(t,this.loadOptions);return[s,r]}}PN.URL_SCHEME_REGEX=/^https?:\/\//;function One(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function GT(n){return n.match(PN.URL_SCHEME_REGEX)!=null}const sP=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>GT(s)):t=GT(n),t)return BN(n,e)}return null};qt.registerSaveRouter(sP);qt.registerLoadRouter(sP);function BN(n,e){return new PN(n,e)}function rP(n,e){return BN(n,e)}class LS{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class iP{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Lne{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Fne(n,e,t,s){const r=arguments;return new Lne(M0(...r))}function M0(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new LS(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new LS({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new LS({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function Mne(n){return new iP(n)}function zne(n){return new iP(n)}const ow=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:wi,browserFiles:_ne,browserHTTPRequest:rP,concatenateArrayBuffers:zM,copyModel:gY,decodeWeights:C2,decodeWeightsStream:MM,encodeWeights:MT,fromMemory:Fne,fromMemorySync:M0,getLoadHandlers:VM,getModelArtifactsForJSON:E2,getModelArtifactsForJSONSync:k2,getModelArtifactsInfoForJSON:km,getSaveHandlers:BM,getWeightSpecs:L0,http:BN,isHTTPScheme:GT,listModels:pY,loadWeights:tP,moveModel:yY,registerLoadRouter:nY,registerSaveRouter:tY,removeModel:mY,weightsLoaderFactory:nP,withSaveHandler:Mne,withSaveHandlerSync:zne},Symbol.toStringTag,{value:"Module"}));function Pne(n,e,t){const s=M(n,"labels","confusionMatrix"),r=M(e,"predictions","confusionMatrix");O(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),O(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),O(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),O(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),O(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const i=Vc(Ne(s,"int32"),t),a=Vc(Ne(r,"int32"),t),o=lt(i),l=nt(o,a);return Ne(l,"int32")}const Bne=G({confusionMatrix_:Pne});const Vne=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Bne},Symbol.toStringTag,{value:"Module"}));let xl,RO=!1;function aP(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,i=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(np(D0,W.backendName)!=null){const b={pixels:n},x={numChannels:e};return W.runKernel(D0,b,x)}const[h,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let p;if(a)p=n.getContext("2d").getImageData(0,0,h,d).data;else if(s||t)p=n.data;else if(i||r||o){if(xl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")xl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else xl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});xl.canvas.width=h,xl.canvas.height=d,xl.drawImage(n,0,0,h,d),p=xl.getImageData(0,0,h,d).data}let m;if(e===4)m=new Int32Array(p);else{const b=h*d;m=new Int32Array(b*e);for(let x=0;x<b;x++)for(let w=0;w<e;++w)m[x*e+w]=p[x*4+w]}return SN(m,[d,h,e],"int32")}function Une(n){return n!=null&&n.data instanceof Uint8Array}function jne(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Wne(n){return n!=null&&n.width!==0&&n.height!==0}function Gne(n){return jne()&&!(n instanceof ImageBitmap)&&Wne(n)&&!Une(n)}async function Hne(n,e=3){let t=null;if(ae().getBool("WRAP_TO_IMAGEBITMAP")&&Gne(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return aP(t,e)}function oP(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function qne(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function Kne(n,e){let t=M(n,"img","toPixels");if(!(n instanceof bt)){const h=t;t=Ne(h,"int32"),h.dispose()}oP(t);const[s,r]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],a=await t.data(),o=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let h=0;h<s*r;++h){const d=[0,0,0,255];for(let m=0;m<i;m++){const y=a[h*i+m];if(t.dtype==="float32"){if(y<0||y>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${y}.`)}else if(t.dtype==="int32"&&(y<0||y>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${y}.`);i===1?(d[0]=y*o,d[1]=y*o,d[2]=y*o):d[m]=y*o}const p=h*4;l[p+0]=Math.round(d[0]),l[p+1]=Math.round(d[1]),l[p+2]=Math.round(d[2]),l[p+3]=Math.round(d[3])}if(e!=null){RO||np(Ob,W.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),RO=!0),e.width=r,e.height=s;const h=e.getContext("2d"),d=new ImageData(l,r,s);h.putImageData(d,0,0)}return t!==n&&t.dispose(),l}function Xne(n,e,t){let s=M(n,"img","draw");if(!(n instanceof bt)){const a=s;s=Ne(a,"int32"),a.dispose()}oP(s),qne(t?.imageOptions);const r={image:s},i={canvas:e,options:t};W.runKernel(Ob,r,i)}const lP=G({fromPixels_:aP}),Yne=Object.freeze(Object.defineProperty({__proto__:null,draw:Xne,fromPixels:lP,fromPixelsAsync:Hne,toPixels:Kne},Symbol.toStringTag,{value:"Module"}));function lw(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(he(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let a=1;for(let p=0;p<r.length-1;++p)a*=r[p];const o=n.shape,l=r.slice();l.pop();let h=1;for(let p=i;p<t;++p)h*=o[p],l.push(o[p]);const d=[...Be(n.shape).map(p=>p/h),1].slice(0,i);return[l,a,h,d]}const Jne=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:lw},Symbol.toStringTag,{value:"Module"}));const HT=-2,Zne=-1;function VN(n,e,t){const s=n.shape.length;O(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),O(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)O(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Qne(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function UN(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function uP(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function cP(n,e,t){return t<=n?t:t-(e-1)}function hP(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function ese(n,e,t,s,r,i,a,o,l){const h=n.length;let d=new Array(h),p=new Array(h),m=new Array(h);if(e.length&&t>0){const y=e[0],b=t+1;d=dP(a,y,b,s,n),p=fP(o,y,b,r,n),m=uP(i,y,b,n)}else for(let y=0;y<h;y++)d[y]=mP(a,s,i,n,y,l),p[y]=gP(o,r,i,n,y,l),m[y]=pP(i,y,l);return{begin:d,end:p,strides:m}}function dP(n,e,t,s,r){const i=[...r],a=hP(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const l=cP(e,t,o);let h=s[l];n&1<<l&&(h=0),i[o]=h}return i}function fP(n,e,t,s,r){const i=[...r],a=hP(t,e);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const l=cP(e,t,o);let h=s[l];n&1<<l&&(h=Number.MAX_SAFE_INTEGER),i[o]=h}for(let o=0;o<i.length;o++){const l=r[o];i[o]<0&&(i[o]+=l),i[o]=Io(0,i[o],r[o])}return i}function pP(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function mP(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=Io(0,a,l-1),a}function gP(n,e,t,s,r,i){let a=e[r];const o=t[r]||1;(n&1<<r||i&1<<r||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),o>0?a=Io(0,a,l):a=Io(-1,a,l-1),a}function jN(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function WN(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function uw(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(a=>{O(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((a,o)=>a>=0?a:(O(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,i]}function GN(n,e,t,s,r,i,a,o,l){let h;if(s==null?(h=new Array(e.length),h.fill(1)):h=s,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:h.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let N=0;N<p.dims;N++)d&&(1<<N&o)!==0&&p.numAddAxisAfterEllipsis++,1<<N&a&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};tse(p,m);let y=!0,b=!0,x=!0;const w=[],v=[];for(let N=0;N<n.length;++N){if(m.strides[N]===0)throw Error(`strides[${N}] must be non-zero`);const k=!!(m.shrinkAxisMask&1<<N),E=n[N];if(E===-1){w.push(k?1:-1);continue}const A=[m.beginMask&1<<N,m.endMask&1<<N],R=[m.strides[N]>0?0:-1,m.strides[N]>0?E:E-1];if(k&&m.strides[N]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[N]===1;const D=!!(m.beginMask&1<<N&&m.endMask&1<<N);if(m.beginValid&&m.endValid){if(k){const V=m.begin[N]<0?E+m.begin[N]:m.begin[N];if(m.begin[N]=V,m.end[N]=m.begin[N]+1,V<0||V>=E)throw Error(`slice index ${m.begin[N]} of dimension ${N} out of bounds.`)}else m.begin[N]=DO(m.begin[N],0,m.strides[N],E,A,R),m.end[N]=DO(m.end[N],1,m.strides[N],E,A,R);const _=m.strides[N]===1&&m.begin[N]===0&&m.end[N]===E;y=y&&_,b=b&&(N===0&&m.strides[N]===1||_)}else y=y&&m.strides[N]===1&&D,b=b&&(N===0&&m.strides[N]===1||D);let L,F=!1;if(m.beginValid&&m.endValid?(L=m.end[N]-m.begin[N],F=!0):k?(L=1,F=!0):D&&E>=0&&(m.strides[N]<0?L=-E:L=E,F=!0),F){let _;L===0||L<0!=m.strides[N]<0?_=0:_=Math.trunc(L/m.strides[N])+(L%m.strides[N]!==0?1:0),w.push(_)}else w.push(-1)}for(let N=0;N<m.finalShapeGatherIndices.length;++N){const k=m.finalShapeGatherIndices[N];k>=0?v.push(w[k]):k===HT&&v.push(1)}return{finalShapeSparse:v.filter((N,k)=>m.finalShapeGatherIndices[k]!==HT),finalShape:v,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function tse(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(HT),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(Zne),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function DO(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const a=n<0?s+n:n;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const yP=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:VN,computeFlatOffset:WN,computeOutShape:UN,getNormalizedAxes:ese,isSliceContinous:jN,maskToAxes:Qne,parseSliceParams:uw,sliceInfo:GN,startForAxis:mP,startIndicesWithElidedDims:dP,stopForAxis:gP,stopIndicesWithElidedDims:fP,stridesForAxis:pP,stridesWithElidedDims:uP},Symbol.toStringTag,{value:"Module"}));const bP="4.22.0";class xP{static sgd(e){return new aw(e)}static momentum(e,t,s=!1){return new MN(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,i=!1){return new zN(e,t,s,r,i)}static adam(e=.001,t=.9,s=.999,r=null){return new LN(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new DN(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,i=0){return new FN(e,t,s,r,i)}static adagrad(e,t=.1){return new ON(e,t)}}const Cl=xP;const nse=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function HN(){return new Promise(n=>nse(()=>n()))}function qN(n,e){const t=n[0].length;n.forEach((r,i)=>{O(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),O(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let a=0;a<t;a++)O(a===e||r[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Pi(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var hi;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(hi||(hi={}));function wP(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const i=t[r],a=s[s.length-t.length+r],o=s[a];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${o}`)}else s[a]=i}return s}function vP(n){const e={FIRST_DIM_SIZE:hi.FIRST_DIM_SIZE,VALUE_ROWIDS:hi.VALUE_ROWIDS,ROW_LENGTHS:hi.ROW_LENGTHS,ROW_SPLITS:hi.ROW_SPLITS,ROW_LIMITS:hi.ROW_LIMITS,ROW_STARTS:hi.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function SP(n){return n.length===0?0:n[0]===hi.FIRST_DIM_SIZE?n.length-1:n.length}function TP(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const i=n[r],a=e[r+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${a}`)}}const KN=30;function cw(n){return n<=KN?n:_0(n,Math.floor(Math.sqrt(n)))}function XN(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function Gm(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let a=0;a<i;++a)r=r.concat([n[a+1]/e[a],e[a]]);r=r.concat(n.slice(i+1))}return r}function Hm(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?i.push(a):r.push(a);s.push(...r),s.push(0),s.push(...i)}return s}function qm(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function YN(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function JN(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const hw=1.7580993408473768,dw=1.0507009873554805;const ZN=.3275911,QN=.254829592,ek=-.284496736,tk=1.421413741,nk=-1.453152027,sk=1.061405429;function $a(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function CP(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function NP(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function kP(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function rk(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function EP(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function IP(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function $P(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const FS="->",sse=/->/g,OO=",",LO="...";function ik(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(sse,"").length)/FS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${FS}").`);const[s,r]=n.split(FS);O(s.indexOf(LO)===-1,()=>`The ellipsis notation ("${LO}") is not supported yet.`);const i=s.split(OO),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);o.indexOf(y)===-1&&o.push(y)}for(let m=0;m<s.length;++m){const y=s[m];o.indexOf(y)===-1&&y!==OO&&o.push(y)}const l=new Array(i.length);for(let m=0;m<a;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);l[m]=[];for(let y=0;y<i[m].length;++y)l[m].push(o.indexOf(i[m][y]))}const h=o.length,d=r.length,p=[];for(let m=d;m<h;++m)p.push(m);return{allDims:o,summedDims:p,idDims:l}}function ak(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function ok(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let a=0;a<e[r].length;++a)s[e[r][a]]===void 0?s[e[r][a]]=i[a]:O(s[e[r][a]]===i[a],()=>`Expected dimension ${s[e[r][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function lk(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<t.length;++a){const o=t[a],l=rse(e,o);for(const h of l)i.indexOf(h)===-1&&(s[a].push(h),i.push(h))}return{path:t,steps:s}}function uk(n){return n.every((e,t)=>e===t)}function rse(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function ck(n,e,t=0){let s=[];if(typeof e=="number")O(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);O(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((o,l)=>l>0?o+l:o);e[i]=n.shape[t]-a}O(n.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function _P(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function AP(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function RP(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function DP(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function OP(n,e){return`size ${n} must be non-negative, not ${e}`}function LP(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function FP(n,e){const t=he(n),s=he(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function MP(n,e){const t=he(n),s=he(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function qT(){return"segment ids must be >= 0"}function zP(){return"segment ids are not increasing"}function PP(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function BP(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function VP(n,e){let t=!1,s;for(n<=KN?(s=n,t=!0):s=_0(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=_0(n,s+1);return s}function UP(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function hk(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let p=0;p<s;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const a=n.shape[t],o=[];let l=1,h=1,d=1;for(let p=0;p<s;++p)o.push(n.shape[p]),l*=n.shape[p];for(let p=s;p<t;p++)o.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<r;p++)o.push(e.shape[p]);for(let p=t+1;p<i;p++)o.push(n.shape[p]),d*=n.shape[p];return{batchSize:l,sliceSize:d,outerSize:h,dimSize:a,outputShape:o}}const ise=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:hk,computeOutShape:UP,segOpComputeOptimalWindowSize:VP},Symbol.toStringTag,{value:"Module"}));function _a(n){try{return n.map(e=>Na(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function jP(n){return n.map(e=>Mi(e))}const WP=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:QN,ERF_A2:ek,ERF_A3:tk,ERF_A4:nk,ERF_A5:sk,ERF_P:ZN,PARALLELIZE_THRESHOLD:KN,get RowPartitionType(){return hi},SELU_SCALE:dw,SELU_SCALEALPHA:hw,applyActivation:tw,assertAndGetBroadcastShape:Xe,assertAxesAreInnerMostDims:Qn,assertParamsConsistent:qN,assignToTypedArray:EP,axesAreInnerMostDims:tN,calculateShapes:qo,checkEinsumDimSizes:ok,checkPadOnDimRoundingMode:ws,combineLocations:nz,combineRaggedTensorToTensorShapes:wP,complexWithEvenIndex:NP,complexWithOddIndex:kP,computeConv2DInfo:Vn,computeConv3DInfo:Uo,computeDefaultPad:M2,computeDilation2DInfo:Em,computeOptimalWindowSize:cw,computeOutAndReduceShapes:Un,computeOutShape:Pi,computePool2DInfo:qr,computePool3DInfo:La,convertConv2DDataFormat:Fa,decodeEinsumEquation:ik,eitherStridesOrDilationsAreOne:Zn,expandShapeToKeepDim:un,exponent:$P,exponents:IP,fromStringArrayToUint8:jP,fromUint8ToStringArray:_a,getAxesPermutation:Zt,getBroadcastDims:Yl,getComplexWithIndex:rk,getEinsumComputePath:lk,getEinsumPermutation:ak,getFusedBiasGradient:ew,getFusedDyActivation:Qx,getImageCenter:XN,getInnerMostAxes:cn,getPermuted:Hm,getRaggedRank:SP,getReductionAxes:xn,getReshaped:Gm,getReshapedPermuted:qm,getRowPartitionTypesHelper:vP,getSliceBeginCoords:YN,getSliceSize:JN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:_P,getSparseFillEmptyRowsNegativeIndexErrorMessage:AP,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:RP,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:LP,getSparseReshapeInputOutputMismatchErrorMessage:MP,getSparseReshapeInputOutputMultipleErrorMessage:FP,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:DP,getSparseReshapeNegativeOutputDimErrorMessage:OP,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:BP,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:qT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:zP,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:PP,getUndoAxesPermutation:jo,isIdentityPermutation:uk,log:nX,mergeRealAndImagArrays:$a,prepareAndValidate:lw,prepareSplitSize:ck,segment_util:ise,shouldFuse:nw,slice_util:yP,splitRealAndImagArrays:CP,stridesOrDilationsArePositive:Xl,tupleValuesAreOne:Ao,upcastType:_s,validateDefaultValueShape:TP,validateInput:Kx,validateUpdateShape:TN,warn:gr},Symbol.toStringTag,{value:"Module"}));const ase=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:sw,nonMaxSuppressionV4Impl:rw,nonMaxSuppressionV5Impl:iw,whereImpl:Jx},Symbol.toStringTag,{value:"Module"}));Tne();const GP={kernelName:Sp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,pu(Ne(t,"float32"),-1))}}};const ose={kernelName:eh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=It(Ne(t,"float32")),r=Pn(_e(Pe(1),s));return Mt(Le(n,r))}}}};const lse={kernelName:th,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pn(_e(It(Ne(t,"float32")),1));return Le(n,s)}}}};const use={kernelName:hu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{let o=n;const l=xn(t.shape,r);return l.length>0&&(o=Re(o,l)),Y(o,t.shape)},b:()=>{let o=n;const l=xn(s.shape,r);return l.length>0&&(o=Re(o,l)),Y(o,s.shape)}}}};const cse={kernelName:Tp,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const hse={kernelName:Cp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>dt(t)}}};const dse={kernelName:Np,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>dt(t)}}};const fse={kernelName:nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Pn(_e(Pe(1),It(Ne(t,"float32")))))}}};const pse={kernelName:sh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pn(ve(Pe(1),It(Ne(t,"float32"))));return Le(n,s)}}}};const mse={kernelName:ah,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=ve(It(t),It(s));let l=q(n,Le(s,o));const h=xn(t.shape,r);return h.length>0&&(l=Re(l,h)),Y(l,t.shape)},b:()=>{const o=ve(It(t),It(s));let l=Mt(q(n,Le(t,o)));const h=xn(s.shape,r);return h.length>0&&(l=Re(l,h)),Y(l,s.shape)}}}};const gse={kernelName:rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,ve(It(Ne(t,"float32")),1))}}};const yse={kernelName:ih,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,_e(Pe(1),It(Ne(t,"float32"))))}}};function bse(n,e,t,s,r,i){const a=M(n,"dy","avgPool3dGrad"),o=M(e,"input","avgPool3dGrad");let l=a,h=o,d=!1;o.rank===4&&(d=!0,l=Y(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=Y(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),O(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),ws("avgPool3dGrad",r,i);const p={dy:l,input:h},m={filterSize:t,strides:s,pad:r,dimRoundingMode:i},y=W.runKernel(wb,p,m);return d?Y(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const xse=G({avgPool3dGrad_:bse});const wse={kernelName:Ep,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=t;return{x:()=>xse(n,s,r,i,a,o)}}};function vse(n,e,t,s,r){const i=M(n,"dy","avgPoolGrad"),a=M(e,"input","avgPoolGrad");O(a.rank===i.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`);let o=a,l=i,h=!1;a.rank===3&&(h=!0,o=Y(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=Y(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),O(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const d={dy:l,input:o},p={filterSize:t,strides:s,pad:r},m=W.runKernel(xb,d,p);return h?Y(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Sse=G({avgPoolGrad_:vse});const Tse={kernelName:kp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:i,pad:a}=t;return{x:()=>Sse(n,s,r,i,a)}}};const Cse={kernelName:Ip,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:i,transposeB:a}=t;return!i&&!a?{a:()=>nt(n,r,!1,!0),b:()=>nt(s,n,!0,!1)}:!i&&a?{a:()=>nt(n,r,!1,!1),b:()=>nt(n,s,!0,!1)}:i&&!a?{a:()=>nt(r,n,!1,!0),b:()=>nt(s,n,!1,!1)}:{a:()=>nt(r,n,!0,!0),b:()=>nt(n,s,!0,!0)}}};const Nse={kernelName:$p,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>zm(n,s,r)}}};const kse={kernelName:bM,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,i=s.shape,a=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])a[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>Re(n,o,!0)}}};const Ese={kernelName:oh,gradFunc:n=>({x:()=>n.clone()})};const Ise={kernelName:lh,gradFunc:n=>({x:()=>dt(n)})};const $se={kernelName:uh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:i}=t;return{x:()=>Mn(Hr(Ma(s,r),Wo(s,i)),n,dt(n))}}};const _se={kernelName:Ap,inputsToSave:["x"],gradFunc:GP.gradFunc};const Ase={kernelName:Rp,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,i=st(r,e[0].shape)[0],a=s.map(l=>l[i]);return $s(n,a,i).map(l=>()=>l)}};const Rse={kernelName:Dp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:i,strides:a,pad:o,dataFormat:l}=t;return O(Ao(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>K2(s.shape,n,r,a,o,l),filter:()=>_N(s,n,r.shape,a,o,l)}}};const Dse={kernelName:Op,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=t;return{dy:()=>Ia(n,r,i,a,o,1,l),filter:()=>_N(n,s,r.shape,i,a,o,l)}}};function Ose(n,e,t,s,r){let i=n;n.rank===4&&(i=Y(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=Y(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),O(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),O(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),O(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),O(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),O(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:i,dy:a},l={strides:s,pad:r,filterShape:t};return W.runKernel(Nb,o,l)}const Lse=G({conv3DBackpropFilter_:Ose});const Fse={kernelName:Lp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i}=t;O(Ao(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>QM(a.shape,n,o,r,i),filter:()=>Lse(a,n,o.shape,r,i)}}};const Mse={kernelName:ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(Mt(jx(Ne(t,"float32"))),n)}}};const zse={kernelName:hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(Wx(Ne(t,"float32")),n)}}};const Pse={kernelName:Fp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:i,reverse:a}=t;return{x:()=>{const o=Zt([r],s.rank);let l=_x(n,r,i,!a);return o!=null&&(l=lt(l,o)),l}}}};const Bse={kernelName:Mp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=t,o=s??[1,1];O(Ao(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,h]=e;return O(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),O(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),O(l.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),O(Zn(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),ws("depthwiseConv2d",i,a),{x:()=>jz(l.shape,n,h,r,i,o,a),filter:()=>Uz(l,n,h.shape,r,i,o,a)}}};const Vse={kernelName:zp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,i={x:s,filter:r,dy:n},a={x:s,filter:r,dy:n};return{x:()=>W.runKernel(A0,i,t),filter:()=>W.runKernel(R0,a,t)}}};const Use={kernelName:fh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>W.runKernel(Fb,s)}}};const jse={kernelName:ph,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=q(Ds(Mt(It(t))),2/Math.sqrt(Math.PI));return{x:()=>q(n,s)}}};const Wse={kernelName:mh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,t)}}};const Gse={kernelName:Bp,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>Y(n,t.shape)}}};const Hse={kernelName:gh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,Ds(t))}}};const qse={kernelName:yh,gradFunc:n=>({x:()=>dt(n)})};const Kse={kernelName:bh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=Le(n,Ne(s,"float32")),l=xn(t.shape,r);return l.length>0?Y(Re(o,l),t.shape):o},b:()=>{let o=q(n,Ne(t,"float32"));const l=xn(s.shape,r);l.length>0&&(o=Y(Re(o,l),s.shape));const h=It(s);return Mt(Le(o,Ne(h,"float32")))}}}};const Xse={kernelName:Vp,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,i,a,o]=e,l=o??Pe(1),h=xn(i.shape,r.shape),d=[];if(i.rank===1){for(let k=0;k<r.shape.length-1;++k)d.push(r.shape[k]);d.push(1)}const p=_e(r,i),m=q(n,l),y=Bx(ve(a,Pe(s))),b=q(q(q(y,y),y),Pe(-.5));return{x:()=>i.rank===1?Y(q(q(n,br(Y(y,[1,1,1,i.shape[0]]),d)),l),r.shape):Y(q(q(n,y),l),r.shape),mean:()=>{let k=q(q(y,Pe(-1)),m);return i.rank===1&&(k=Re(k,h)),Y(k,i.shape)},variance:()=>{let k=q(q(b,p),m);return i.rank===1&&(k=Re(k,h)),Y(k,i.shape)},scale:()=>{const k=q(p,y);let E=q(n,k);return i.rank===1&&(E=Re(E,h)),Y(E,i.shape)},offset:()=>{let k=n;return i.rank===1&&(k=Re(k,h)),Y(k,i.shape)}}}};const Yse={kernelName:Up,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:i,batchDims:a}=t,o=st(i,s.shape)[0],l=(h,d,p)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,o),x=b.length,w=m.slice(i,m.length).slice(1),v=w.length,C=FO(0,x),N=FO(x+1,x+1+v),k=MO([b,[y],w]),E=Y(p,k),A=Y(d,[y]),R=MO([[x],C,N]),D=lt(E,R);let L=Yx(D,A,h.shape[o]);const F=jo(R);return L=lt(L,F),L};if(a===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>bs(d.map((y,b)=>l(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function FO(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function MO(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const Jse={kernelName:xh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>dt(t),b:()=>dt(s)}}};const Zse={kernelName:wh,gradFunc:n=>({x:()=>Ne(n,"float32")})};const Qse={kernelName:vh,gradFunc:n=>({x:()=>dt(n)})};const ere={kernelName:Sh,gradFunc:n=>({x:()=>dt(n)})};const tre={kernelName:Th,gradFunc:n=>({x:()=>dt(n)})};const nre={kernelName:Wp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,i=vs(s,0);return{x:()=>Mn(i,n,q(n,r))}}};const sre={kernelName:Nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,ve(t,1))}}};const rre={kernelName:Ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Ne(t,"float32"))}}};const ire={kernelName:xM,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const a=Ds(s);return _e(n,q(Re(n,r,!0),a))}}}};function are(n,e,t,s=5,r=1,i=1,a=.5){const o={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:i,beta:a};return W.runKernel(Wb,o,l)}const ore=G({localResponseNormalizationBackprop_:are});const lre={kernelName:Yp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:i,bias:a,alpha:o,beta:l}=t;return{x:()=>ore(s,r,n,i,a,o,l)}}};function HP(n,e,t,s){return e.rank<t.rank&&(e=Y(e,un(e.shape,s))),n.rank<t.rank&&(n=Y(n,un(n.shape,s))),{x:()=>q(n,Ne(Ys(t,e),n.dtype))}}const zO={kernelName:Jp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,i=e[0],a=e[1],o=st(r,i.shape),l=HP(n,a,i,o);return{x:()=>l.x()}}};const ure={kernelName:kh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>q(n,Ne(Ma(t,s),"float32")),b:()=>q(n,Ne(Bc(t,s),"float32"))}}};function cre(n,e,t,s,r,i,a){const o=M(n,"dy","maxPool3dGrad"),l=M(e,"input","maxPool3dGrad"),h=M(t,"output","maxPool3dGrad");let d=o,p=l,m=h,y=!1;l.rank===4&&(y=!0,d=Y(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=Y(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=Y(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),O(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),O(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),O(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),ws("maxPool3dGrad",i,a);const b={dy:d,input:p,output:m},x={filterSize:s,strides:r,pad:i,dimRoundingMode:a},w=W.runKernel(Hb,b,x);return y?Y(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const hre=G({maxPool3dGrad_:cre});const dre={kernelName:Qp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=t;return{x:()=>hre(n,s,r,i,a,o,l)}}};function fre(n,e,t,s,r,i,a){const o=M(n,"dy","maxPoolGrad"),l=M(e,"input","maxPoolGrad"),h=M(t,"output","maxPoolGrad");O(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),O(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),O(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ws("maxPoolGrad",i,a);const d={dy:o,input:l,output:h},p={filterSize:s,strides:r,pad:i,dimRoundingMode:a};return W.runKernel(Gb,d,p)}const pre=G({maxPoolGrad_:fre});const mre={kernelName:Zp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:i,strides:a,pad:o}=t;return{x:()=>pre(n,s,r,i,a,o)}}};const gre={kernelName:em,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,i=st(r,s.shape),o=Un(s.shape,i)[1],l=he(o);return{x:()=>{const d=s.shape.slice();i.forEach(y=>{d[y]=1});const p=Y(n,d);return Le(q(p,Is(s.shape,"float32")),l)}}}};const yre={kernelName:tm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[i,a]=e,o=st(r,i.shape),l=HP(n,a,i,o);return{x:()=>l.x()}}};const bre={kernelName:Eh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>q(n,Ne(Wo(t,s),"float32")),b:()=>q(n,Ne(vs(t,s),"float32"))}}};const xre={kernelName:nm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>ht(n,i,s.shape)}}};const wre={kernelName:Ih,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=xn(t.shape,r);return o.length>0?Y(Re(n,o),t.shape):n},b:()=>{const o=q(n,Mt(Qh(Le(t,s)))),l=xn(s.shape,r);return l.length>0?Y(Re(o,l),s.shape):o}}}};const vre={kernelName:$h,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=q(n,Ne(s,"float32")),l=xn(t.shape,r);return l.length>0?Y(Re(o,l),t.shape):o},b:()=>{const o=q(n,Ne(t,"float32")),l=xn(s.shape,r);return l.length>0?Y(Re(o,l),s.shape):o}}}};const Sre={kernelName:sm,gradFunc:n=>({x:()=>Mt(n)})};const Tre={kernelName:am,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>gn(t.shape,"float32")}}};const Cre={kernelName:im,gradFunc:n=>({x:()=>dt(n)})};const Nre={kernelName:om,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Cr(n,s).map(i=>()=>i)}};const PO={kernelName:lm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,i=r.map(a=>a[0]);return{x:()=>ht(n,i,s.shape)}}};const kre={kernelName:_h,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,i=t,a=s,o=Xe(i.shape,a.shape);return{a:()=>{const d=Ne(a,"float32");let p=q(n,q(d,Wi(i,_e(d,Pe(1)))));const m=xn(i.shape,o);return m.length>0&&(p=Re(p,m)),Y(p,i.shape)},b:()=>{const d=vs(i,0),p=Mn(d,Js(i),dt(i));let m=q(n,q(r,p));const y=xn(a.shape,o);return y.length>0&&(m=Re(m,y)),Y(m,a.shape)}}}};const Ere={kernelName:um,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=vs(t,0);return{x:()=>Mn(r,n,q(n,s)),alpha:()=>{let i=Mn(r,dt(n),q(n,t));const a=xn(s.shape,n.shape);return a.length>0&&(i=Re(i,a)),Y(i,s.shape)}}}};function Ire(n,e,t){const s=n.shape.slice();s[t]=1;const r=Y(e,s),i=lp(n,t,!0,!1),a=lp(n,t,!0,!0),o=q(i,a);return q(r,o)}function $re(n,e,t){const s=n.shape.length,r=s-t.length,i=Zt(t,s);let a=n;i!=null&&(a=lt(n,i));const o=a.shape.slice(),h=o.splice(s-t.length,t.length).reduce((m,y)=>m*y,1);o.push(h);const d=a.reshape(o);let p=Ire(d,e,r);if(p=p.reshape(a.shape),i!=null){const m=jo(i);p=lt(p,m)}return p}const _re={kernelName:cm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let i=[];return r==null?i=s.shape.map((a,o)=>o):typeof r=="number"?i=[r]:i=r,{x:()=>$re(s,n,i)}}};const Are={kernelName:dh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{const o=Le(n,Ne(s,"float32")),l=xn(t.shape,r);return l.length>0?Y(Re(o,l),t.shape):o},b:()=>{let o=q(n,Ne(t,"float32"));const l=xn(s.shape,r);l.length>0&&(o=Y(Re(o,l),s.shape));const h=It(s);return Mt(Le(o,Ne(h,"float32")))}}}};const Rre={kernelName:Ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,Mt(It(t)))}}};const Dre={kernelName:Dh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=q(Wo(t,6),pu(t));return{x:()=>q(n,Ne(s,"float32"))}}};const Ore={kernelName:Rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,Ne(pu(t),"float32"))}}};const Lre={kernelName:hm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,t.shape)}}};const Fre={kernelName:fm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(rx,r,t)}}};const Mre={kernelName:dm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(sx,r,t)}}};const zre={kernelName:pm,gradFunc:(n,e,t)=>{const{dims:s}=t,r=st(s,n.shape);return{x:()=>Tr(n,r)}}};const Pre={kernelName:Oh,gradFunc:n=>({x:()=>dt(n)})};const Bre={kernelName:Lh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Mt(Le(n,q(Wi(t,1.5),2)))}}};const Vre={kernelName:mm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ne(dt(t),"float32"),t:()=>q(n,Ne(t,n.dtype)),e:()=>q(n,Ne(Lm(t),n.dtype))}}};const Ure={kernelName:Fh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=vs(t,Pe(0)),r=Pe(hw),i=Pe(dw),a=q(n,i),o=q(q(n,r),Ds(Ne(t,"float32")));return Mn(s,a,o)}}}};const jre={kernelName:Bh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,q(t,_e(Pe(1),t)))}}};const Wre={kernelName:Ph,gradFunc:n=>({x:()=>dt(n)})};const Gre={kernelName:Mh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(_m(Ne(t,"float32")),n)}}};const Hre={kernelName:zh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q($x(Ne(t,"float32")),n)}}};const qre={kernelName:gm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:i}=t,a=s.shape,[o,l]=uw(s,r,i),h=[];for(let d=0;d<n.rank;d++)h.push([o[d],a[d]-o[d]-l[d]]);return{x:()=>za(n,h)}}};const Kre={kernelName:wm,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,i=!0,a=q(n,s);return{logits:()=>_e(a,q(Re(a,[r],i),s))}}};const Xre={kernelName:Vh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,fi(t))}}};const BO={kernelName:bm,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>$m(n,s,r)}}};const VO={kernelName:xm,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>ln(n,s)}}};const Yre={kernelName:Uh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,q(Pn(Ne(t,"float32")),2))}}};const Jre={kernelName:fx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(n,q(Ne(t,"float32"),2))}}};const Zre={kernelName:jh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Pe(2);return{a:()=>q(n,q(r,_e(t,s))),b:()=>q(n,q(r,_e(s,t)))}}};const Qre={kernelName:Kh,gradFunc:n=>({x:()=>dt(n)})};const eie={kernelName:Wh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Xe(t.shape,s.shape);return{a:()=>{let o=n;const l=xn(t.shape,r);return l.length>0&&(o=Re(o,l)),Y(o,t.shape)},b:()=>{let o=n;const l=xn(s.shape,r);return l.length>0&&(o=Re(o,l)),Y(Mt(o),s.shape)}}}};const tie={kernelName:ym,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:i}=t;st(i,s.shape).forEach(h=>{r[h]=1});const o=Y(n,r),l=q(o,Is(s.shape,"float32"));return{x:()=>l}}};const nie={kernelName:Gh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Le(n,It(_m(t)))}}};const sie={kernelName:Hh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>q(_e(Pe(1),It(t)),n)}}};const rie={kernelName:qh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let a=dt(s);if(s.rank===1)for(let o=0;o<r[0];++o)a=ve(a,ht(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)a=ve(a,ht(n,[o*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let h=0;h<r[2];++h)a=ve(a,ht(n,[o*s.shape[0],l*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let h=0;h<r[2];++h)for(let d=0;d<r[3];++d)a=ve(a,ht(n,[o*s.shape[0],l*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return a}}}};const iie={kernelName:Bl,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,i=jo(r);return{x:()=>lt(n,i)}}};const aie={kernelName:Sm,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>bs(n,r)}}};const oie={kernelName:Tm,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>lie(n,t)}}};function lie(n,e){const t=qi(e,dt(e)),s=ed(n,t);let r=Ma(e,Pe(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=Hn(r,o+1);r=Hr(r,Is(s.shape,"bool"));const a=dt(s);return Mn(r,s,a)}const uie={kernelName:Cm,gradFunc:n=>({x:()=>dt(n)})};const cie=[GP,ose,lse,use,cse,hse,dse,fse,pse,mse,gse,yse,wse,Tse,Cse,Nse,kse,Ese,Ise,$se,_se,Ase,Dse,Rse,Fse,Mse,zse,Pse,Bse,Vse,Are,Use,jse,Wse,Gse,Hse,Kse,qse,Xse,Yse,Jse,Zse,Qse,ere,tre,nre,sre,rre,ire,lre,zO,zO,ure,dre,mre,gre,yre,bre,xre,wre,vre,Sre,Tre,Cre,Nre,PO,PO,kre,Ere,_re,Rre,Dre,Ore,Lre,Fre,Mre,zre,Pre,Bre,Vre,Ure,jre,Wre,Gre,Hre,qre,Kre,Xre,BO,BO,VO,VO,Yre,Zre,Jre,Qre,eie,tie,nie,sie,rie,iie,aie,oie,uie];for(const n of cie)wM(n);fe().prototype.abs=function(){return this.throwIfDisposed(),mn(this)};fe().prototype.acos=function(){return this.throwIfDisposed(),$2(this)};fe().prototype.acosh=function(){return this.throwIfDisposed(),_2(this)};fe().prototype.add=function(n){return this.throwIfDisposed(),ve(this,n)};fe().prototype.all=function(n,e){return this.throwIfDisposed(),kx(this,n,e)};fe().prototype.any=function(n,e){return this.throwIfDisposed(),ip(this,n,e)};fe().prototype.argMax=function(n){return this.throwIfDisposed(),Kl(this,n)};fe().prototype.argMin=function(n){return this.throwIfDisposed(),A2(this,n)};fe().prototype.asScalar=function(){return this.throwIfDisposed(),O(this.size===1,()=>"The array must have only 1 element."),Y(this,[])};fe().prototype.asType=function(n){return this.throwIfDisposed(),Ne(this,n)};fe().prototype.as1D=function(){return this.throwIfDisposed(),Y(this,[this.size])};fe().prototype.as2D=function(n,e){return this.throwIfDisposed(),Y(this,[n,e])};fe().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),Y(this,[n,e,t])};fe().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),Y(this,[n,e,t,s])};fe().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),Y(this,[n,e,t,s,r])};fe().prototype.asin=function(){return this.throwIfDisposed(),R2(this)};fe().prototype.asinh=function(){return this.throwIfDisposed(),D2(this)};fe().prototype.atan=function(){return this.throwIfDisposed(),O2(this)};fe().prototype.atan2=function(n){return this.throwIfDisposed(),L2(this,n)};fe().prototype.atanh=function(){return this.throwIfDisposed(),F2(this)};fe().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),Im(this,n,e,t,s)};fe().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),$m(this,n,e)};fe().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Xh(this,n,e,t,s,r)};fe().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Vl(this,n)};fe().prototype.cast=function(n){return this.throwIfDisposed(),Ne(this,n)};fe().prototype.ceil=function(){return this.throwIfDisposed(),j2(this)};fe().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Rs(this,n,e)};fe().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof bt&&(n=[n]),ln([this,...n],e)};fe().prototype.conv1d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Ex(this,n,e,t,s,r,i)};fe().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),Ix(this,n,e,t,s,r)};fe().prototype.conv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Ia(this,n,e,t,s,r,i)};fe().prototype.cos=function(){return this.throwIfDisposed(),_m(this)};fe().prototype.cosh=function(){return this.throwIfDisposed(),$x(this)};fe().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),lp(this,n,e,t)};fe().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),_x(this,n,e,t)};fe().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),J2(this,n,e)};fe().prototype.depthwiseConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Yh(this,n,e,t,s,r,i)};fe().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),Z2(this,n,e,t,s,r)};fe().prototype.divNoNan=function(n){return this.throwIfDisposed(),Q2(this,n)};fe().prototype.div=function(n){return this.throwIfDisposed(),Le(this,n)};fe().prototype.dot=function(n){return this.throwIfDisposed(),eN(this,n)};fe().prototype.elu=function(){return this.throwIfDisposed(),Jh(this)};fe().prototype.equal=function(n){return this.throwIfDisposed(),Ys(this,n)};fe().prototype.erf=function(){return this.throwIfDisposed(),Ax(this)};fe().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),nN(this,n,e)};fe().prototype.exp=function(){return this.throwIfDisposed(),Ds(this)};fe().prototype.expandDims=function(n){return this.throwIfDisposed(),Hn(this,n)};fe().prototype.expm1=function(){return this.throwIfDisposed(),sN(this)};fe().prototype.fft=function(){return this.throwIfDisposed(),jm(this)};fe().prototype.flatten=function(){return this.throwIfDisposed(),Y(this,[this.size])};fe().prototype.floor=function(){return this.throwIfDisposed(),Qh(this)};fe().prototype.floorDiv=function(n){return this.throwIfDisposed(),Nx(this,n)};fe().prototype.gather=function(n,e,t){return this.throwIfDisposed(),ed(this,n,e,t)};fe().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ma(this,n)};fe().prototype.greater=function(n){return this.throwIfDisposed(),vs(this,n)};fe().prototype.ifft=function(){return this.throwIfDisposed(),Wc(this)};fe().prototype.irfft=function(){return this.throwIfDisposed(),Hx(this)};fe().prototype.isFinite=function(){return this.throwIfDisposed(),rN(this)};fe().prototype.isInf=function(){return this.throwIfDisposed(),iN(this)};fe().prototype.isNaN=function(){return this.throwIfDisposed(),aN(this)};fe().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Rm(this,n)};fe().prototype.lessEqual=function(n){return this.throwIfDisposed(),Wo(this,n)};fe().prototype.less=function(n){return this.throwIfDisposed(),Bc(this,n)};fe().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),oN(this,n,e,t,s)};fe().prototype.logSigmoid=function(){return this.throwIfDisposed(),lN(this)};fe().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Ox(this,n)};fe().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Om(this,n,e)};fe().prototype.log=function(){return this.throwIfDisposed(),Js(this)};fe().prototype.log1p=function(){return this.throwIfDisposed(),Dm(this)};fe().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Hr(this,n)};fe().prototype.logicalNot=function(){return this.throwIfDisposed(),Lm(this)};fe().prototype.logicalOr=function(n){return this.throwIfDisposed(),Lx(this,n)};fe().prototype.logicalXor=function(n){return this.throwIfDisposed(),uN(this,n)};fe().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),nt(this,n,e,t)};fe().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),Fm(this,n,e,t,s)};fe().prototype.max=function(n,e){return this.throwIfDisposed(),Sr(this,n,e)};fe().prototype.maximum=function(n){return this.throwIfDisposed(),qi(this,n)};fe().prototype.mean=function(n,e){return this.throwIfDisposed(),Kt(this,n,e)};fe().prototype.min=function(n,e){return this.throwIfDisposed(),Pc(this,n,e)};fe().prototype.minimum=function(n){return this.throwIfDisposed(),Do(this,n)};fe().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),hN(this,n,e)};fe().prototype.mod=function(n){return this.throwIfDisposed(),dN(this,n)};fe().prototype.mul=function(n){return this.throwIfDisposed(),q(this,n)};fe().prototype.neg=function(){return this.throwIfDisposed(),Mt(this)};fe().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Zh(this,n,e,t)};fe().prototype.notEqual=function(n){return this.throwIfDisposed(),Jl(this,n)};fe().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Vc(this,n,e,t)};fe().prototype.onesLike=function(){return this.throwIfDisposed(),Zs(this)};fe().prototype.pad=function(n,e){return this.throwIfDisposed(),za(this,n,e)};fe().prototype.pool=function(n,e,t,s,r,i){return this.throwIfDisposed(),fN(this,n,e,t,s,r,i)};fe().prototype.pow=function(n){return this.throwIfDisposed(),Wi(this,n)};fe().prototype.prelu=function(n){return this.throwIfDisposed(),Pm(this,n)};fe().prototype.prod=function(n,e){return this.throwIfDisposed(),pN(this,n,e)};fe().prototype.reciprocal=function(){return this.throwIfDisposed(),bN(this)};fe().prototype.relu=function(){return this.throwIfDisposed(),vi(this)};fe().prototype.relu6=function(){return this.throwIfDisposed(),zx(this)};fe().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Y(this,n.shape)};fe().prototype.reshape=function(n){return this.throwIfDisposed(),Y(this,n)};fe().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),qz(this,n,e,t)};fe().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Kz(this,n,e,t)};fe().prototype.reverse=function(n){return this.throwIfDisposed(),Tr(this,n)};fe().prototype.rfft=function(){return this.throwIfDisposed(),Wm(this)};fe().prototype.round=function(){return this.throwIfDisposed(),Px(this)};fe().prototype.rsqrt=function(){return this.throwIfDisposed(),Bx(this)};fe().prototype.selu=function(){return this.throwIfDisposed(),Vx(this)};fe().prototype.separableConv2d=function(n,e,t,s,r,i){return this.throwIfDisposed(),Ux(this,n,e,t,s,r,i)};fe().prototype.sigmoid=function(){return this.throwIfDisposed(),fi(this)};fe().prototype.sign=function(){return this.throwIfDisposed(),xN(this)};fe().prototype.sin=function(){return this.throwIfDisposed(),jx(this)};fe().prototype.sinh=function(){return this.throwIfDisposed(),Wx(this)};fe().prototype.slice=function(n,e){return this.throwIfDisposed(),ht(this,n,e)};fe().prototype.softmax=function(n){return this.throwIfDisposed(),Um(this,n)};fe().prototype.softplus=function(){return this.throwIfDisposed(),fu(this)};fe().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),zm(this,n,e)};fe().prototype.split=function(n,e){return this.throwIfDisposed(),$s(this,n,e)};fe().prototype.sqrt=function(){return this.throwIfDisposed(),Pn(this)};fe().prototype.square=function(){return this.throwIfDisposed(),It(this)};fe().prototype.squaredDifference=function(n){return this.throwIfDisposed(),qx(this,n)};fe().prototype.squeeze=function(n){return this.throwIfDisposed(),Ho(this,n)};fe().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof bt?[this,n]:[this,...n];return bs(t,e)};fe().prototype.step=function(n){return this.throwIfDisposed(),pu(this,n)};fe().prototype.stridedSlice=function(n,e,t,s,r,i,a,o){return this.throwIfDisposed(),wN(this,n,e,t,s,r,i,a,o)};fe().prototype.sub=function(n){return this.throwIfDisposed(),_e(this,n)};fe().prototype.sum=function(n,e){return this.throwIfDisposed(),Re(this,n,e)};fe().prototype.tan=function(){return this.throwIfDisposed(),vN(this)};fe().prototype.tanh=function(){return this.throwIfDisposed(),Ro(this)};fe().prototype.tile=function(n){return this.throwIfDisposed(),br(this,n)};fe().prototype.toBool=function(){return this.throwIfDisposed(),Ne(this,"bool")};fe().prototype.toFloat=function(){return this.throwIfDisposed(),Ne(this,"float32")};fe().prototype.toInt=function(){return this.throwIfDisposed(),Ne(this,"int32")};fe().prototype.topk=function(n,e){return this.throwIfDisposed(),CN(this,n,e)};fe().prototype.transpose=function(n){return this.throwIfDisposed(),lt(this,n)};fe().prototype.unique=function(n){return this.throwIfDisposed(),NN(this,n)};fe().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Yx(this,n,e)};fe().prototype.unstack=function(n){return this.throwIfDisposed(),Cr(this,n)};fe().prototype.where=function(n,e){return this.throwIfDisposed(),Mn(n,this,e)};fe().prototype.zerosLike=function(){return this.throwIfDisposed(),dt(this)};class _i extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_i.prototype)}}class Wr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Wr.prototype)}}class J extends Error{constructor(e){super(e),Object.setPrototypeOf(this,J.prototype)}}class Ze extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ze.prototype)}}class dk extends Error{constructor(e){super(e),Object.setPrototypeOf(this,dk.prototype)}}class qP{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function eu(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function Ai(n,e){if(!n)throw new dk(e)}function UO(n,e){let t=0;for(const s of n)s===e&&t++;return t}function ks(n){return n.length===1?n[0]:n}function Ct(n){return Array.isArray(n)?n:[n]}function ga(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function $l(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Mr={};function fk(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function KT(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>KT(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:KT(s))}}}function Km(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const i=n;let a;if(i in t)a=t[i];else if(i in Mr)a=Mr[i];else if(a=e[i],a==null)throw new J(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const i=n;if(i.className==null||i.config==null)throw new J(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const a=i.className;let o,l;if(a in t?[o,l]=t[a]:a in Mr?[o,l]=Mr.className:a in e&&([o,l]=e[a]),o==null)throw new J(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const h={};for(const y of Object.keys(Mr))h[y]=Mr[y];for(const y of Object.keys(t))h[y]=t[y];const d=i.config;d.customObjects=h;const p=Object.assign({},Mr);for(const y of Object.keys(t))Mr[y]=t[y];KT(i.config);const m=l(o,i.config,t,r);return Mr=Object.assign({},p),m}else{const h=Object.assign({},Mr);for(const p of Object.keys(t))Mr[p]=t[p];const d=new o(i.config);return Mr=Object.assign({},h),d}}}function hie(n,e){return n<e?-1:n>e?1:0}function Fy(n,e){return-1*hie(n,e)}function Co(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function die(n){if(n==null)throw new J(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function gu(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new J(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function pk(n,e,t=0,s=1/0){return Ai(t>=0),Ai(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Fn(n,e){Array.isArray(n)?(O(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Fn(t,`element ${s+1} of ${e}`))):O(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${KP(n)}.`)}function KP(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>KP(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function fie(n,e,t){let s=t!=null?t():Gn(),r;return(...a)=>{const o=t!=null?t():Gn();return o-s<e||(s=o,r=n(...a)),r}}function XP(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let pie=0;function YP(){return pie++}const My={};function fw(n=""){return n in My||(My[n]=0),My[n]+=1,n+My[n].toString()}const mie=["channelsFirst","channelsLast"],gie=["nearest","bilinear"],yie=["valid","same","causal"],bie=["max","avg"],xie=["sum","mul","concat","ave"];const mc=new Map;function hn(n){gu(mie,"DataFormat",n)}function wie(n){gu(gie,"InterpolationFormat",n)}function Nr(n){gu(yie,"PaddingMode",n)}function JP(n){gu(bie,"PoolMode",n)}const Mf=[],jO="/";function Ul(n,e){Mf.push(n);try{const t=e();return Mf.pop(),t}catch(t){throw Mf.pop(),t}}function vie(){return Mf.length===0?"":Mf.join(jO)+jO}function ZP(n){if(!eB(n))throw new Error("Not a valid tensor name: '"+n+"'");return vie()+n}function QP(n){if(!eB(n))throw new Error("Not a valid tensor name: '"+n+"'");mc.has(n)||mc.set(n,0);const e=mc.get(n);if(mc.set(n,mc.get(n)+1),e>0){const t=`${n}_${e}`;return mc.set(t,1),t}else return n}const Sie=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function eB(n){return!!n.match(Sie)}function Tie(n){return n===parseInt(n.toString(),10)}function No(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Gc(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Oo(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function gi(n,e){if(e<n)throw new J(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let MS;function In(){return MS==null&&(MS=T2().epsilon()),MS}function yi(){return"channelsLast"}function Bi(n,e){return Ne(n,e)}function Xm(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),Y(n,t)}function Cie(n,e){return re(()=>{if(n.shape.length!==2)throw new J(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Xm(n,1);return XT(t,[1,e,1])})}function Nie(n){const e=[No(n.shape)];return Y(n,e)}function kie(n){if(n.rank<=1)throw new J(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],No(n.shape,1)];return Y(n,e)}function jl(n,e,t){return re(()=>{switch(n.rank){case 1:return Bm(n,e,t);case 2:return Gx(n,[e,0],[t,n.shape[1]]);case 3:return Vm(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return jc(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ht(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ht(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new J(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function zS(n,e,t){return re(()=>{switch(n.rank){case 1:return Bm(n,e,t);case 2:return Gx(n,[0,e],[n.shape[0],t]);case 3:return Vm(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return jc(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new J(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function zy(n,e,t,s){return re(()=>{switch(n.rank){case 1:return Bm(n,e,t);case 2:switch(s){case 1:return jl(n,e,t);case 2:return zS(n,e,t);default:throw new J(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return jl(n,e,t);case 2:return Vm(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return zS(n,e,t);default:throw new J(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return jl(n,e,t);case 2:return jc(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return jc(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return zS(n,e,t);default:throw new J(`The axis is not within the rank of the tensor ${s}`)}default:throw new J(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function mk(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),ln(n,e)}function WO(n,e){switch(n.rank){case 1:return W2([n,e]);case 2:return G2([n,e],0);case 3:return H2([n,e],0);case 4:return q2([n,e],0);default:throw new J(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function XT(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new J(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return br(n,e)}function pw(n,e=0,t=1,s,r){return Mx(n,e,t,s,r)}function Vi(n,e,t,s){if(n.rank<2||e.rank<2)throw new Ze(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(r!==i)throw new Ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return jT({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?YT(n.rank,s,yi()):null,activation:t});{const r=n.shape.slice(),i=r.pop();n=Y(n,[-1,i]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),h=[...a,o],d=Array.from({length:e.rank},(b,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=Y(lt(e,d),[l,-1]);const p=[...r,...h];return Y(jT({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?YT(n.rank,s,yi()):null,activation:t}),p)}}function tB(n,e,t){return re(()=>(Array.isArray(e)?e=Xn(e,"int32"):e=Ne(e,"int32"),ed(n,e,t)))}function Ym(n){return q(n,n)}function YT(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new J(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?Y(e,[1,s[0],1,1,1]):Y(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?Y(e,[1,1,1,1,s[0]]):Y(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?Y(e,[1,s[0],1,1]):Y(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?Y(e,[1,1,1,s[0]]):Y(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?Y(e,[1,s[0],1]):Y(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?Y(e,[1,1,s[0]]):Y(e,[1].concat(s))}else if(n<3)return e;throw new J(`Unsupported input rank by biasAdd: ${e.rank}`)}function Si(n,e,t){return re(()=>(t==null&&(t=yi()),hn(t),ve(n,YT(n.rank,e,t))))}function Eie(n,e=1){if(e!==1)throw new Ze(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Jh(n)}function Iie(n){return re(()=>Le(n,ve(mn(n),1)))}function nB(n,e,t,s){return re(()=>IN(n,e,t,s))}function $ie(n){return re(()=>{const e=ve(.5,q(.2,n));return Rs(e,0,1)})}function Jm(n,e,t=!1){return t?n():e()}const _ie=["fanIn","fanOut","fanAvg"],Aie=["normal","uniform","truncatedNormal"];function Rie(n){gu(_ie,"FanMode",n)}function Die(n){gu(Aie,"Distribution",n)}class Kr extends mu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class gk extends Kr{apply(e,t){return gn(e,t)}}gk.className="Zeros";Se(gk);class mw extends Kr{apply(e,t){return Is(e,t)}}mw.className="Ones";Se(mw);class yk extends Kr{constructor(e){if(super(),typeof e!="object")throw new J(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new J(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return re(()=>q(Pe(this.value),Is(e,t)))}getConfig(){return{value:this.value}}}yk.className="Constant";Se(yk);class bk extends Kr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Go(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}bk.className="RandomUniform";Se(bk);class xk extends Kr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`randomNormal does not support dType ${t}.`);return pw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}xk.className="RandomNormal";Se(xk);class wk extends Kr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`truncatedNormal does not support dType ${t}.`);return Xx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}wk.className="TruncatedNormal";Se(wk);class vk extends Kr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return re(()=>{if(e.length!==2||e[0]!==e[1])throw new J("Identity matrix initializer can only be used for 2D square matrices.");return q(this.gain,Rx(e[0]))})}getConfig(){return{gain:this.gain}}}vk.className="Identity";Se(vk);function Oie(n,e="channelsLast"){let t,s;if(hn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=No(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=No(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=No(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Os extends Kr{constructor(e){if(super(),e.scale<0)throw new J(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Rie(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Die(this.distribution),this.seed=e.seed}apply(e,t){const s=Oie(e),r=s[0],i=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ze(`${this.getClassName()} does not support dType ${t}.`);return Xx(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Go(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Os.className="VarianceScaling";Se(Os);class gw extends Os{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}gw.className="GlorotUniform";Se(gw);class yw extends Os{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}yw.className="GlorotNormal";Se(yw);class bw extends Os{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}bw.className="HeNormal";Se(bw);class xw extends Os{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}xw.className="HeUniform";Se(xw);class ww extends Os{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}ww.className="LeCunNormal";Se(ww);class vw extends Os{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}vw.className="LeCunUniform";Se(vw);class Sk extends Kr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return re(()=>{if(e.length<2)throw new Ze("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=he(e.slice(0,-1)),r=e[e.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const a=[Math.max(r,s),Math.min(r,s)],o=pw(a,0,1,t,this.seed),l=RN.qr(o,!1);let h=l[0];const p=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return h=q(h,p.sign()),s<r&&(h=h.transpose()),q(Pe(this.gain),h.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Sk.className="Orthogonal";Se(Sk);const GO={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function HO(n,e={}){return Km(n,yr.getMap().classNameMap,e,"initializer")}function Yt(n){return fk(n)}function Wt(n){if(typeof n=="string"){const e=n in GO?GO[n]:n;if(e==="GlorotNormal")return new yw;if(e==="GlorotUniform")return new gw;if(e==="HeNormal")return new bw;if(e==="HeUniform")return new xw;if(e==="LeCunNormal")return new ww;if(e==="LeCunUniform")return new vw;{const t={};return t.className=e,t.config={},HO(t)}}else return n instanceof Kr?n:HO(n)}function JT(n){return Array.isArray(n)&&Array.isArray(n[0])}function z0(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function He(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new J(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function wt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new J(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function P0(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const qO="Variable";class sB{constructor(e,t="float32",s=qO,r=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=YP(),s=s??qO,this.originalName=ZP(s),this.name=QP(this.originalName),this.trainable_=r,this.constraint=i,this.val=kN(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Lie(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Lie(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function ZT(n){return n.map(e=>e.read())}function Tk(n){n.forEach(e=>{e[0].write(e[1])})}class yn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class bi{constructor(e,t,s,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=YP(),a!=null&&(this.originalName=ZP(a),this.name=QP(this.originalName)),this.rank=t.length}}let Fie=0;class Sw{constructor(e,t){this.callArgs=t,this.id=Fie++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Mie=0;class rt extends mu{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Mie++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=ga(s)+"_"+fw(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),s=[i].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Wr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new J(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ks(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ks(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new _i(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new _i(`Layer ${this.name} is not connected, no input to return.`);return ks(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new _i(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new _i(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ks(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ct(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Ct(this.inputSpec);if(t.length!==s.length)throw new J(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const i=t[r],a=s[r];if(a==null)continue;const o=i.rank;if(a.ndim!=null&&o!==a.ndim)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&i.dtype!==a.dtype)throw new J(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${i.dtype}.`);if(a.axes){const l=i.shape;for(const h in a.axes){const d=Number(h),p=a.axes[h],m=d>=0?l[d]:l[l.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${l}.`)}}if(a.shape!=null)for(let l=0;l<a.shape.length;++l){const h=a.shape[l],d=i.shape[l];if(h!=null&&d!=null&&h!==d)throw new J(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Ct(e),r=Bie(e),i=Vie(e);if(r===i)throw new J("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ul(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of Ct(e))a.push(o.shape);this.build(ks(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const o=Ct(a),l=[];for(let h of o)s.indexOf(h)!==-1&&(h=h.clone()),l.push(h);if(a=ks(l),this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=zie(e),o=this.computeOutputShape(a);let l;const h=Pie(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((d,p)=>new bi(h,d,this,Ct(e),t,this.name,p)):l=new bi(h,o,this,Ct(e),t,this.name),this.addInboundNode(e,l,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new _i(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new _i(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Wr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return P0(this.weights)}build(e){this.built=!0}getWeights(e=!1){return ZT(e?this.trainableWeights:this.weights)}setWeights(e){re(()=>{const t=this.weights;if(t.length!==e.length)throw new J(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=ZT(t);for(let i=0;i<r.length;++i){const a=r[i],o=t[i],l=e[i];if(!at(a.shape,l.shape))throw new J(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}Tk(s)})}addWeight(e,t,s,r,i,a,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new J(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():Wt("zeros"));const h=r.apply(t,s),d=new sB(h,s,e,a,o);return h.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),a==null&&(a=!0),a?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ct(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),i=Ct(t),a=Ct(r);if(i.length!==a.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let o=0;o<i.length;o++)i[o].kerasMask=a[o]}addInboundNode(e,t,s,r,i,a,o=null){const l=Ct(e);t=Ct(t),s=Ct(s),r=Ct(r),i=z0(i),a=z0(a);const h=[],d=[],p=[];for(const m of l)h.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new Sw({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:p,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:a},o);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function zie(n){n=Ct(n);const e=[];for(const t of n)e.push(t.shape);return ks(e)}function Pie(n){return"float32"}function rB(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const a=s.inputTensors[i],o=s.inboundLayers[i],l=s.nodeIndices[i],h=rB(a,o,l);for(const d of h)r.indexOf(d)===-1&&r.push(d)}return r}}}function Bie(n){let e=!0;for(const t of Ct(n))if(!(t instanceof bi)){e=!1;break}return e}function Vie(n){let e=!0;for(const t of Ct(n))if(t instanceof bi){e=!1;break}return e}class sd extends rt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:fw("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new J("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new J("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new J("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new bi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Sw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new J(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}sd.className="InputLayer";Se(sd);function iB(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new J("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new sd({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function Uie(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ne(e,n.dtype)}catch{throw new J(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class xo{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof xo)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Uie(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new J(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof bi){if(this.id2Value[e.id]==null)throw new J(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new J(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof bi){if(this.id2Value[e.id]==null)throw new J(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new J(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Ke(this.id2Mask)}}const B0=new qP,V0=new qP;function jie(n){B0?.setMaxEntries(n),V0?.setMaxEntries(n)}function Cf(n,e,t,s){const r=t==null?!1:t.training,i=Array.isArray(n),a=i?n:[n],o=a.map(b=>b.name),l=[],h=e.names();for(const b of o)h.indexOf(b)!==-1?l.push(e.getValue(b)):l.push(null);const d=o.join(",")+"|"+e.names().sort().join(",");let p=B0.get(d),m;if(p==null){const b=Wie(a,e);p=b.sorted,m=b.recipientCounts,B0.put(d,p),V0.put(d,m)}m={},r||Object.assign(m,V0.get(d));const y=new xo(e);for(let b=0;b<p.length;++b){const x=p[b],w=x.sourceLayer;if(w instanceof sd)continue;const v=[],C=[],N=[];let k=!1;for(const L of x.inputs){const F=y.getValue(L),_=y.getMask(L);v.push(F),C.push(_),_!=null&&(k=!0),r||(m[L.name]--,m[L.name]===0&&!e.hasKey(L)&&o.indexOf(L.name)===-1&&!F.isDisposed&&L.sourceLayer.stateful!==!0&&N.push(F))}k&&(t=t||{},t.mask=C[0]);const E=Ct(w.apply(v,t));let A=null;w.supportsMasking&&(A=w.computeMask(v,C));const R=Hie(x),D=Array.isArray(R)?R:[R];for(let L=0;L<D.length;++L){y.hasKey(D[L])||y.add(D[L],E[L],Array.isArray(A)?A[0]:A);const F=o.indexOf(D[L].name);F!==-1&&(l[F]=E[L])}r||Ke(N)}return y.disposeMasks(),i?l:l[0]}function Wie(n,e){O(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=KO(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:a,recipientMap:o}=KO(i,e);for(const l of a)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(h=>s[l].add(h))}}return{sorted:t,recipientCounts:Gie(s)}}function Gie(n){const e={};for(const t in n)e[t]=n[t].size;return e}function KO(n,e){const t=new Set,s=[],r={};for(const o of e.names())t.add(o);const i=[],a=[];for(i.push(n);i.length>0;){const o=i[i.length-1];if(t.has(o.name)){i.pop();continue}const l=a[a.length-1]===i.length-1;if(o.inputs.length===0||l)i.pop(),s.push(o),t.add(o.name),l&&a.pop();else{a.push(i.length-1);for(const h of o.inputs)r[h.name]==null&&(r[h.name]=new Set),r[h.name].add(o.name),!t.has(h.name)&&i.push(h)}}return{sorted:s,recipientMap:r}}function Hie(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const qie=ae();qie.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,jie);function Ck(n,e){return re(()=>Pn(Re(q(n,n),e,!0)))}class Zm extends mu{getConfig(){return{}}}class Nk extends Zm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return re(()=>{const t=Ck(e,this.axis),s=Rs(t,0,this.maxValue);return q(e,Le(s,ve(In(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Nk.className="MaxNorm";Se(Nk);class kk extends Zm{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return re(()=>Le(e,ve(In(),Ck(e,this.axis))))}getConfig(){return{axis:this.axis}}}kk.className="UnitNorm";Se(kk);class Ek extends Zm{apply(e){return vi(e)}}Ek.className="NonNeg";Se(Ek);class Ik extends Zm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return re(()=>{const t=Ck(e,this.axis),s=ve(q(this.rate,Rs(t,this.minValue,this.maxValue)),q(1-this.rate,t));return q(e,Le(s,ve(In(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Ik.className="MinMaxNorm";Se(Ik);const XO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function $n(n){return fk(n)}function YO(n,e={}){return Km(n,yr.getMap().classNameMap,e,"constraint")}function _n(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in XO?XO[n]:n,config:{}};return YO(t)}else return n instanceof Zm?n:YO(n)}function Kie(n){return new Nk(n)}function Xie(n){return new kk(n)}function Yie(){return new Ek}function Jie(n){return new Ik(n)}const Zie=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Kie,minMaxNorm:Jie,nonNeg:Yie,unitNorm:Xie},Symbol.toStringTag,{value:"Module"}));function Qie(){return new gk}function eae(){return new mw}function tae(n){return new yk(n)}function nae(n){return new bk(n)}function sae(n){return new xk(n)}function rae(n){return new wk(n)}function iae(n){return new vk(n)}function aae(n){return new Os(n)}function oae(n){return new gw(n)}function lae(n){return new yw(n)}function uae(n){return new bw(n)}function cae(n){return new xw(n)}function hae(n){return new ww(n)}function dae(n){return new vw(n)}function fae(n){return new Sk(n)}const pae=Object.freeze(Object.defineProperty({__proto__:null,constant:tae,glorotNormal:lae,glorotUniform:oae,heNormal:uae,heUniform:cae,identity:iae,leCunNormal:hae,leCunUniform:dae,ones:eae,orthogonal:fae,randomNormal:sae,randomUniform:nae,truncatedNormal:rae,varianceScaling:aae,zeros:Qie},Symbol.toStringTag,{value:"Module"}));async function po(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const a=i;e.push(a.data()),t.push(r),s.push(a)}}if(e.length>0){const r=await Promise.all(e);for(let i=0;i<r.length;++i)n[t[i]]=r[i][0];Ke(s)}}function aB(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var JO;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(JO||(JO={}));const mae=125;class Hc{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class oB{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class gae extends Hc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const i=t[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;const o=re(()=>ve(this.totals[r],q(i,s)));this.totals[r]=o,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:re(()=>{const r=q(Le(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),En(t[s])}))}}class lB extends Hc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const i in this.history){const a=this.history[i];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const l=a[o];e.push(l.data()),t.push(i),s.push(o)}}const r=await Promise.all(e);for(let i=0;i<r.length;++i)this.history[t[i]][s[i]].dispose(),this.history[t[i]][s[i]]=r[i][0]}}class uB extends Hc{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||HN,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=mae),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");$0(this.yieldEvery)&&(this.maybeWait=fie(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await po(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await po(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await po(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await po(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await po(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):$0(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await po(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await po(e),await this.trainEnd(e))}}function cB(n,e){return n==null&&(n={}),n instanceof Hc?[n]:Array.isArray(n)&&n[0]instanceof Hc?n:Ct(n).map(s=>new uB(s,e))}class fr{constructor(){}static registerCallbackConstructor(e,t){O(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),fr.checkForDuplicate(t),fr.constructors[e]==null&&(fr.constructors[e]=[]),fr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in fr.constructors)fr.constructors[+t].forEach(r=>{if(r===e)throw new J("Duplicate callback constructor.")})}static clear(){fr.constructors={}}static createCallbacks(e){const t=[];for(const s in fr.constructors){const r=+s;e>=r&&t.push(...fr.constructors[r])}return t.map(s=>new s)}}fr.constructors={};function hB(n,e,t,s,r,i,a,o,l){const h=new lB,d=[new gae,...fr.createCallbacks(e)];n!=null&&d.push(...n),d.push(h);const p=new oB(d);return p.setParams({epochs:t,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:p,history:h}}function pi(n,e={},t=!1){return Km(n,yr.getMap().classNameMap,e,"layer",t)}function U0(n,e){return re(()=>{n.dtype!=="float32"&&(n=Ne(n,"float32"));const t=Re(Ym(n),e,!0),s=du(t.shape,In()),r=Pn(qi(t,s));return Le(n,r)})}function yu(n,e){return re(()=>Kt(Ym(_e(e,n)),-1))}function Tw(n,e){return re(()=>Kt(mn(_e(e,n)),-1))}function rd(n,e){return re(()=>{const t=_e(n,e),s=Rs(mn(n),In(),Number.MAX_VALUE),r=mn(Le(t,s));return q(100,Kt(r,-1))})}function yae(n,e){return re(()=>{const t=Rs(e,In(),Number.MAX_VALUE),s=Js(ve(1,t)),r=Rs(n,In(),Number.MAX_VALUE),i=Js(ve(1,r));return Kt(Ym(_e(s,i)),-1)})}function bae(n,e){return re(()=>{const t=qi(0,_e(1,q(n,e)));return Kt(Ym(t),-1)})}function xae(n,e){return re(()=>{const t=qi(0,_e(1,q(n,e)));return Kt(t,-1)})}function wae(n,e){return re(()=>{const t=Re(q(n,e),-1),s=Sr(q(_e(1,n),e),-1);return qi(0,ve(1,_e(s,t)))})}function vae(n,e){return re(()=>{const t=Math.log(2),s=_e(e,n),r=_e(ve(s,fu(q(-2,s))),t);return Kt(r,-1)})}function up(n,e,t=!1){return re(()=>{if(t)e=Um(e);else{const s=Re(e,e.shape.length-1,!0);e=Le(e,s)}return e=Rs(e,In(),1-In()),Mt(Re(q(Ne(n,"float32"),Js(e)),e.shape.length-1))})}function j0(n,e,t=!1){return re(()=>{const s=Ne(Qh(Nie(n)),"int32");e=Rs(e,In(),1-In());const r=e.shape,i=Y(Vc(s,r[r.length-1]),r);return up(i,e,t)})}function Sae(n,e){if(!at(n.shape,e.shape))throw new J(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return re(()=>{const t=vi(e),s=Mt(mn(e));return ve(_e(t,q(e,n)),Dm(Ds(s)))})}function Cw(n,e){return re(()=>{let t;return t=Rs(e,In(),1-In()),t=Js(Le(t,_e(1,t))),Kt(Sae(n,t),-1)})}function Tae(n,e){return re(()=>{const t=Rs(n,In(),1),s=Rs(e,In(),1);return Re(q(n,Js(Le(t,s))),-1)})}function Cae(n,e){return re(()=>{const t=Js(ve(In(),e));return Kt(_e(e,q(n,t)),-1)})}function $k(n,e){return re(()=>{const t=U0(n,-1),s=U0(e,-1),r=q(t,s);return Mt(Re(r,-1))})}const W0={meanSquaredError:yu,meanAbsoluteError:Tw,meanAbsolutePercentageError:rd,meanSquaredLogarithmicError:yae,squaredHinge:bae,hinge:xae,categoricalHinge:wae,logcosh:vae,categoricalCrossentropy:up,sparseCategoricalCrossentropy:j0,binaryCrossentropy:Cw,kullbackLeiblerDivergence:Tae,poisson:Cae,cosineProximity:$k};function PS(n){if(typeof n=="string"){if(n in W0)return W0[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new J(e)}else return n}function _k(n,e){return re(()=>{const t=q(.5,Zs(e)),s=Bi(vs(e,t),n.dtype);return Kt(Ys(n,s),-1)})}function Ak(n,e){return re(()=>Bi(Ys(Kl(n,-1),Kl(e,-1)),"float32"))}function dB(n,e){return re(()=>Ne(Re(Hr(Ys(n,1),Ys(e,1))),"float32"))}function Nae(n,e){return re(()=>Ne(Re(Hr(Ys(n,1),Ys(e,0))),"float32"))}function kae(n,e){return re(()=>Ne(Re(Hr(Ys(n,0),Ys(e,1))),"float32"))}function fB(n,e){return re(()=>{const t=dB(n,e),s=kae(n,e),r=ve(t,s);return Ne(Mn(vs(r,0),Le(t,r),0),"float32")})}function Eae(n,e){return re(()=>{const t=dB(n,e),s=Nae(n,e),r=ve(t,s);return Ne(Mn(vs(r,0),Le(t,r),0),"float32")})}function pB(n,e){return Cw(n,e)}function mB(n,e){return n.rank===e.rank&&(n=Ho(n,[n.rank-1])),e=Kl(e,-1),e.dtype!==n.dtype&&(e=Ne(e,n.dtype)),Ne(Ys(n,e),"float32")}function Iae(n,e){return re(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return Pe(1).sub(t.div(s))})}const $ae=yu,_ae=yu,Aae=Tw,Rae=Tw,Dae=rd,Oae=rd,Rk=up,Lae=$k,gB=j0,G0={binaryAccuracy:_k,categoricalAccuracy:Ak,precision:fB,categoricalCrossentropy:Rk,sparseCategoricalCrossentropy:gB,mse:$ae,MSE:_ae,mae:Aae,MAE:Rae,mape:Dae,MAPE:Oae,cosine:Lae};function Fae(n){if(typeof n=="string"&&n in G0)return G0[n];if(typeof n!="string"&&n!=null)return n;throw new J(`Unknown metric ${n}`)}function Py(n){if(Ai(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(W0))if(W0[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(G0))if(G0[t]===n){e=t;break}return e!==void 0?e:n.name}}function Mae(n){const e={Adagrad:()=>Cl.adagrad(.01),Adadelta:()=>Cl.adadelta(1,.95,In()),Adam:()=>Cl.adam(.001,.9,.999,In()),Adamax:()=>Cl.adamax(.002,.9,.999,In(),0),RMSProp:()=>Cl.rmsprop(.001,.9,0,In()),SGD:()=>Cl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new J(`Unknown Optimizer ${n}`)}const ZO=1*1024*1024;function QO(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!QT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>ZO&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${ZO}.`)}}function QT(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!QT(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!QT(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function zae(n,e,t,s=console.log){const r=Bae(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let a;if(!r){i.push("Receives inputs"),a=[];for(const d in n.nodesByDepth)a.push(...n.nodesByDepth[d])}s("_".repeat(e)),H0(i,t,s),s("=".repeat(e));const o=n.layers;for(let d=0;d<o.length;++d)r?Vae(o[d],t,s):Uae(o[d],t,a,s),s((d===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Pae(n),h=P0(n.nonTrainableWeights);s(`Total params: ${l+h}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${h}`),s("_".repeat(e))}function Pae(n){let e;return n.collectedTrainableWeights!=null?e=P0(n.collectedTrainableWeights):e=P0(n.trainableWeights),e}function Bae(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let i=!1;for(const a of r.inboundNodes)if(s.indexOf(a)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function H0(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function Vae(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,a=n.getClassName(),o=[`${i} (${a})`,r,s,n.countParams().toString()];H0(o,e,t)}function Uae(n,e,t,s){let r,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=[];for(const p of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const y=p.inboundLayers[m].name,b=p.nodeIndices[m],x=p.tensorIndices[m];a.push(`${y}[${b}][${x}]`)}const o=n.name,l=n.getClassName(),h=a.length===0?"":a[0],d=[`${o} (${l})`,i,r,n.countParams().toString(),h];H0(d,e,s);for(let p=1;p<a.length;++p)H0(["","","","",a[p]],e,s)}function yB(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function cp(n,e){if(n===null)return null;if(typeof n=="string")return $l(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];yB(e,r,i)?t.push(i):t.push(cp(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const i=$l(s);t[i]=cp(r,i)}}return t}}function eC(n,e){if(n==null)return null;if(typeof n=="string")return ga(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];yB(e,r,i)?t.push(i):t.push(eC(i,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],i=ga(s);(s==="name"||s==="className")&&typeof r=="string"?t[i]=r:t[i]=eC(r,s)}return t}}const Nw="4.22.0";const jae=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class ai extends rt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const C=this.getClassName().toLowerCase();this.name=fw(C)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Co(this.inputs).length!==this.inputs.length)throw new J(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(C=>C.name)}`);Co(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(C=>C.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const C of this.outputs){const N=C.sourceLayer,k=C.nodeIndex,E=C.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(E)}for(const C of this.inputs){const N=C.sourceLayer,k=C.nodeIndex,E=C.tensorIndex;Ai(k===0,"input layer has >1 nodes"),Ai(E===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let C=0;C<this.inputLayers.length;C++){const N=this.inputLayers[C];if(!(N instanceof sd))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${C} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(const C of this.outputLayers)this.outputNames.push(C.name);this.internalInputShapes=this.inputs.map(C=>C.shape),this.internalOutputShapes=this.outputs.map(C=>C.shape);const t={},s={},r={},i={},a={},o=[],l=(C,N,k,E,A,R)=>{(E==null||A==null||R==null)&&(E=C.sourceLayer,A=C.nodeIndex,R=C.tensorIndex);const D=E.inboundNodes[A];if(k.indexOf(D)!==-1)throw new Wr(`The tensor ${C.name} at layer "${E.name}" is part of a cycle.`);if(N.indexOf(D)!==-1)return;this.containerNodes.add(ai.nodeKey(E,A)),E.id in a||(a[E.id]=Object.keys(a).length),k.indexOf(D)===-1&&k.push(D);const L=D.inboundLayers.length;for(let F=0;F<L;F++){const _=D.inputTensors[F],V=D.inboundLayers[F],Q=D.nodeIndices[F],ne=D.tensorIndices[F];l(_,N,k,V,Q,ne)}for(N.push(D);k.indexOf(D)>=0;)k.splice(k.indexOf(D),1);o.push(D)},h=[],d=[];for(const C of this.outputs)l(C,h,d);const p=o.slice().reverse();for(const C of p){s[C.id]=C,C.id in t||(t[C.id]=0);let N=t[C.id];const k=r[C.outboundLayer.id]==null?0:r[C.outboundLayer.id];N=Math.max(N,k),r[C.outboundLayer.id]=N,i[C.outboundLayer.id]=C.outboundLayer,t[C.id]=N;for(let E=0;E<C.inboundLayers.length;E++){const A=C.inboundLayers[E],R=C.nodeIndices[E],D=A.inboundNodes[R],L=t[D.id]==null?0:t[D.id];t[D.id]=Math.max(N+1,L),s[D.id]=D}}const m={};for(const C in t){const N=t[C];N in m||(m[N]=[]),m[N].push(s[C])}const y={};for(const C in r){const N=r[C];N in y||(y[N]=[]),y[N].push(i[C])}let b=Object.keys(y).map(C=>parseInt(C,10)).sort(Fy);this.layers=[];for(const C of b){const N=y[C];N.sort((k,E)=>{const A=a[k.id],R=a[E.id];return A<R?-1:A>R?1:0});for(const k of N)k instanceof ai&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=y,b=Object.keys(m).map(C=>parseInt(C,10)).sort(Fy);const x=this.inputs.slice(),w=[];for(const C of b)for(const N of m[C]){const k=N.outboundLayer;if(k!=null){for(const E of N.inputTensors)if(x.indexOf(E)===-1)throw new Wr(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${k.name}". The following previous layers were accessed without issue: ${w}`);for(const E of N.outputTensors)x.push(E);w.push(k.name)}}this.nodesByDepth=m;const v=this.layers.map(C=>C.name);for(const C of v){const N=v.filter(k=>k===C).length;if(N!==1)throw new Wr(`The name "${C}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new Sw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(C=>null),outputMasks:this.outputs.map(C=>null),inputShapes:this.inputs.map(C=>C.shape),outputShapes:this.outputs.map(C=>C.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new J("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const i=jae(e);i&&this.parseWeights(e);for(const o of this.layers)for(const[l,h]of o.weights.entries()){const d=i?`${h.name.split("/").slice(0,-1).join("/")+"/"}${l}`:h.originalName;if(s[d]!=null)throw new J(`Duplicate weight name: ${d}`);s[d]=h,r++}const a=[];for(const o in e){let l=o;if(s[o]==null){const h=o.split("/");l=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[l]!=null)a.push([s[l],e[o]]);else if(t)throw new J(`Provided weight data has no target variable: ${o}`);delete s[l]}if(t){const o=[];for(const l in s)o.push(l);if(o.length>0)throw new J(`${o.length} of ${r} weights are not set: ${o}`)}Tk(a)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!r.includes(a)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Nw}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=eC(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return re(()=>{e=Ct(e);const s=new xo;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Cf(this.outputs,s,t)})}computeMask(e,t){return re(()=>{e=Ct(e);let s;return t==null?s=eu(null,e.length):s=Ct(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=z0(e);if(t.length!==this.inputLayers.length)throw new J(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const l=this.inputLayers[o],h=t[o],d=l.name+"_0_0";s[d]=h}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Fy);if(r.length>1)for(const o of r){const l=this.nodesByDepth[o];for(const h of l){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const p=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],v=h.nodeIndices[x],C=h.tensorIndices[x],N=`${w.name}_${v}_${C}`,k=s[N];p.push(k)}const m=d.computeOutputShape(ks(p)),y=z0(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const i=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],h=this.outputLayersNodeIndices[o],d=this.outputLayersTensorIndices[o],p=`${l.name}_${h}_${d}`;a.push(p)}for(let o=0;o<a.length;o++){const l=a[o];Ai(l in s),i.push(s[l])}return ks(i)}runInternalGraph(e,t){t==null&&(t=eu(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const h=this.inputs[l],d=e[l],p=t[l];s[h.id]=[d,p]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Fy);for(const l of r){const h=this.nodesByDepth[l];for(const d of h){const p=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,v,C,N;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[k,E]=b[0];x.mask==null&&(x.mask=E),C=Ct(p.call(k,x)),N=Ct(p.computeMask(k,E)),w=[k],v=[E]}else w=b.map(k=>k[0]),v=b.map(k=>k[1]),x.mask==null&&(x.mask=v),C=Ct(p.call(w,x)),N=Ct(p.computeMask(w,v));if(p.activityRegularizer)throw new Ze("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<y.length;++k){const E=y[k],A=C[k],R=N[k];s[E.id]=[A,R]}}}}const i=[],a=[],o=[];for(const l of this.outputs){Ai(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[h,d]=s[l.id];o.push(h.shape),i.push(h),a.push(d)}return[i,a,o]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof ai?1:0;for(let i=0;i<r.inboundNodes.length;i++){const a=ai.nodeKey(r,i);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new J("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new J(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new J(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return re(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=ai.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const o=a.getClassName(),l=a.getConfig(),h=[];for(let p=0;p<a.inboundNodes.length;p++){const m=a.inboundNodes[p],y=ai.nodeKey(a,p);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const v=m.inboundLayers[w],C=m.nodeIndices[w],N=m.tensorIndices[w],k=ai.nodeKey(v,C);let E=t[k];E==null&&(E=0),x.push([v.name,E,N,b])}h.push(x)}}}const d={};d.name=a.name,d.className=o,d.config=l,d.inboundNodes=h,s.push(d)}e.layers=s;const r=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],l=this.inputLayersNodeIndices[a],h=ai.nodeKey(o,l);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const p=this.inputLayersTensorIndices[a];r.push([o.name,d,p])}e.inputLayers=r;const i=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],l=this.outputLayersNodeIndices[a],h=ai.nodeKey(o,l);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const p=this.outputLayersTensorIndices[a];i.push([o.name,d,p])}return e.outputLayers=i,e}static fromConfig(e,t,s={},r=!1){const i={},a={};function o(w,v){w.name in a?a[w.name].push(v):a[w.name]=[v]}function l(w,v){const C=[];let N;for(const k of v){const E=k[0],A=k[1],R=k[2];if(N=k[3]==null?{}:k[3],!(E in i)){o(w,v);return}const D=i[E];if(D.inboundNodes.length<=A){o(w,v);return}const L=D.inboundNodes[A];C.push(L.outputTensors[R])}C.length>0&&w.apply(ks(C),N)}function h(w){const v=w.name,C=pi(w,t.customObjects!=null?t.customObjects:{});C.setFastWeightInitDuringBuild(r),i[v]=C,w.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new J(`Corrupted configuration, expected array for nodeData: ${k}`);o(C,k)})}const d=t.name,p=t.layers;for(const w of p)h(w);for(;!die(a);)for(const w of p){const v=i[w.name];if(v.name in a){const C=a[v.name];delete a[v.name];for(const N of C)l(v,N)}}const m=[],y=[],b=t.inputLayers;for(const w of b){const v=w[0],C=w[1],N=w[2];Ai(v in i);const E=i[v].inboundNodes[C].outputTensors;m.push(E[N])}const x=t.outputLayers;for(const w of x){const v=w[0],C=w[1],N=w[2];Ai(v in i);const E=i[v].inboundNodes[C].outputTensors;y.push(E[N])}return new e({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new J("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){re(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function Wae(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function bB(n,e){return Wae(n,e,"classWeight")}async function xB(n,e,t,s){if(t!=null){const r=re(()=>{if(n.shape.length===1)return zi(n);if(n.shape.length===2){if(n.shape[1]>1)return Kl(n,1);if(n.shape[1]===1)return Y(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Ke(r);const a=[];return i.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),Xn(a,"float32")}else return null}function Gae(n,e){return q(n,e)}const Hae=32;function wB(n,e){let t,s;const r=e;t=r.xs,s=r.ys,O(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=e3("input",n.inputNames,t),a=e3("output",n.outputNames,s),o=i[0].shape[0];O(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),O(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)O(i[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)O(a[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:i,ys:a}}function e3(n,e,t){if(t instanceof bt)return[t];if(Array.isArray(t))return O(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new J(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function qae(n){if(n.length===3)throw new Ze("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Kae(n,e,t){const s=t.batchesPerEpoch!=null;if(O(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),O(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),O(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let i,a;if(r)if(t3(t.validationData))O(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const w=qae(t.validationData);i=w.xs,a=w.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let h;r?h=l.slice().concat(l.map(w=>"val_"+w)):h=l.slice();const d=cB(t.callbacks,t.yieldEvery),p=t.verbose==null?1:t.verbose,{callbackList:m,history:y}=hB(d,p,t.epochs,null,null,Xae(e,t),null,r,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=t.initialEpoch==null?0:t.initialEpoch,x=await e.iterator();for(;b<t.epochs;){const w={};await m.onEpochBegin(b);let v=0,C=0;for(s||(x=await e.iterator());!s||v<t.batchesPerEpoch;){const N=await x.next();if(s&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){const{xs:k,ys:E}=wB(n,N.value),A={};A.batch=C,A.size=k[0].shape[0],await m.onBatchBegin(C,A);const R=[];if(t.classWeight!=null){const F=bB(t.classWeight,n.outputNames);for(let _=0;_<F.length;++_)R.push(await xB(E[_],null,F[_]))}const D=k.concat(E).concat(R),L=o(D);Ke(D);for(let F=0;F<l.length;++F){const _=l[F],V=L[F];A[_]=V,En(V)}await m.onBatchEnd(C,A),aB(A),C++,v++}if(s?v>=t.batchesPerEpoch:N.done){if(r){let k;t3(t.validationData)?k=Ct(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):k=Ct(n.evaluate(i,a,{batchSize:t.validationBatchSize==null?Hae:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=k[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Xae(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function t3(n){return typeof n.iterator=="function"}function Yae(n){return typeof n.next=="function"}async function Jae(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let i=[];if(t.verbose>0)throw new Ze("Verbose mode is not implemented yet.");O(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=Yae(e)?e:await e.iterator();let o=0,l=0;for(;!s||l<t.batches;){const h=await a.next();if(i=re(()=>{if(h.value){const{xs:d,ys:p}=wB(n,h.value),m=d.concat(p),y=re(()=>r(m));if(Ke(m),l===0)for(let x=0;x<y.length;++x)i.push(Pe(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],v=i[x];i[x]=re(()=>ve(i[x],q(b,w))),l>0&&Ke(v)}Ke(y),o+=b,++l}return i}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<i.length;++h){const d=i[h];i[h]=Le(i[h],o),Ke(d)}return ks(i)}function BS(n){O(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function gf(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>jl(s,e,t-e)):jl(n,e,t-e)}function tC(n,e){return re(()=>n==null?null:Array.isArray(n)?n.map(t=>tC(t,e)):tB(n,e.dtype==="int32"?e:Ne(e,"int32")))}function VS(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function vB(n){const e=[];n instanceof bt&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Xm(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function si(n,e){if(n==null)return;const t=[];if(e instanceof bt)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const i=e[r];t.push(i.id)}const s=[];if(n instanceof bt)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];t.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function Zae(n){return n instanceof bt}function nC(n){return Array.isArray(n)}function n3(n){return!Zae(n)&&!nC(n)}function s3(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(nC(n)&&n.length>0)a=!0;else if(n3(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new J(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let i;if(n3(n)){n=n,i=[];for(const a of e){if(n[a]==null)throw new J(`No data provided for "${a}". Need data for each key in: ${e}`);i.push(n[a])}}else if(nC(n)){if(n=n,n.length!==e.length)throw new J(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new J(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=vB(i),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new J(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const h=o.shape[l],d=t[a][l];if(d!=null&&d>=0&&h!==d)throw new J(`${r} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return i}function Qae(n,e,t){const s=Co(n.map(i=>i.shape[0]));s.sort();const r=Co(e.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new J(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new J(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!at(s,r))throw new J(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function eoe(n,e,t){const s=[yu,Cw,up];for(let r=0;r<n.length;++r){const i=n[r],a=e[r],o=t[r];if(a!=null){if(a===up&&i.shape[i.shape.length-1]===1)throw new J(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const l=i.shape.slice(1),h=o.slice(1);for(let d=0;d<l.length;++d){const p=l[d],m=h[d];if(m!=null&&p!==m)throw new J(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function r3(n,e,t,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new J(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new J(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=i[a];if(o.shape.length!==t[a].length)throw new J(`Error when checking ${r}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const h=o.shape[l],d=t[a][l];if(d!=null&&d!==h)throw new J(`Error when checking ${r}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function toe(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let i=t.hasOwnProperty(r)?t[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const noe="layers-model";class va extends ai{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new J("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");zae(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Mae(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ba))throw new J("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new J(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(PS(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new J(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>PS(o))}else{const a=PS(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ul("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const r=toe(e.metrics,this.outputNames),i=(a,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,a])};Ul("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=r[a];(h=>{let p,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[a];w[w.length-1]===1||this.lossFunctions[a]===Cw?["accuracy","acc"].indexOf(b)!==-1?m=_k:["crossentropy","ce"].indexOf(b)!==-1&&(m=pB):this.lossFunctions[a]===j0?["accuracy","acc"].indexOf(b)!==-1?m=mB:["crossentropy","ce"].indexOf(b)!==-1&&(m=gB):["accuracy","acc"].indexOf(b)!==-1?m=Ak:["crossentropy","ce"].indexOf(b)!==-1&&(m=Rk);let v;["accuracy","acc"].indexOf(b)!==-1?v="acc":["crossentropy","ce"].indexOf(b)!==-1&&(v="ce"),y=m,p=""+v}else y=Fae(b),p=""+Py(b);let x;Ul(p,()=>{x=y}),i(a,p,x)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;BS(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const o=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,h=this.testLoop(l,o,r,s.verbose,s.steps);return ks(h)}finally{si(a[0],e),si(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Jae(this,e,t)}checkNumSamples(e,t,s,r="steps"){let i;if(s!=null){if(i=null,t!=null)throw new J(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new J(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new J("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],i=this.retrieveSymbolicTensors(r),a=new xo;if(e instanceof bt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new J(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(const l of this.inputs){const h=e[l.name];if(h==null)throw new J(`No value is provided for the model's input ${l.name}`);a.add(l,h)}const o=Cf(i,a);return s?o:o[0]}retrieveSymbolicTensors(e){const t=eu(null,e.length);let s=e.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],a=i.map(o=>o.name);for(let o=0;o<e.length;++o){const l=a.indexOf(e[o]);if(l!==-1&&(t[o]=i[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((i,a)=>{i==null&&r.push(e[a])}),new J(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return re(()=>{const r=this.checkNumSamples(e);if(s)throw new Ze("Verbose predictLoop() is not implemented yet.");const i=VS(r,t),a=this.outputs.map(o=>[]);for(let o=0;o<i.length;++o)re(()=>{const h=i[o][0],d=i[o][1],p=gf(e,h,d),m=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)m.push({key:this.inputs[b],value:p[b]});else m.push({key:this.inputs[0],value:p});const y=new xo(m);return Cf(this.outputs,y)}).forEach((h,d)=>a[d].push(h));return ks(a.map(o=>ln(o,0)))})}predict(e,t={}){const s=vB(e);r3(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return BS(r),this.predictLoop(s,r)}finally{si(s,e)}}predictOnBatch(e){r3(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new Wr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===j0?i.push(o.slice(0,o.length-1).concat([1])):i.push(o)}if(e=s3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=s3(t,this.feedOutputNames,i,!1,"target"),Qae(e,t),eoe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new J(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,i=!0,a){const[o,l]=this.standardizeUserDataXY(e,t,i,a);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(r!=null){const d=bB(r,this.outputNames);h=[];for(let p=0;p<d.length;++p)h.push(await xB(l[p],null,d[p]))}return[o,l,h]}testLoop(e,t,s,r=0,i){return re(()=>{const a=this.checkNumSamples(t,s,i,"steps"),o=[];if(r>0)throw new Ze("Verbose mode is not implemented yet.");if(i!=null)throw new Ze("steps mode in testLoop() is not implemented yet");{const l=VS(a,s),h=Xn(gi(0,a));for(let d=0;d<l.length;++d){const p=l[d][0],m=l[d][1],y=jl(h,p,m-p),b=tC(t,y),x=e(b);if(d===0)for(let w=0;w<x.length;++w)o.push(Pe(0));for(let w=0;w<x.length;++w){const v=x[w];o[w]=ve(o[w],q(m-p,v))}}for(let d=0;d<o.length;++d)o[d]=Le(o[d],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let i=r;if(UO(e,r)>1){const a=UO(e.slice(0,s),r);i+=`_${a}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const m=new xo(p),y=Cf(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let v=w(r[x],y[x]);i[x]!=null&&(v=Gae(v,i[x]));const C=Kt(v);t.push(C),x===0?b=v:b=ve(b,v)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=t[x];else{const v=this.metricsTensors[x][0],C=this.metricsTensors[x][1];w=Kt(v(r[C],y[C]))}En(w),a.push(w)}return b=Kt(b),this.calculateLosses().forEach(x=>{b=ve(b,x)}),b},l=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(o,!0,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>re(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let h=0;h<this.inputs.length;++h)a.push({key:this.inputs[h],value:r[h]});const o=new xo(a),l=Cf(this.outputs,o);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],p=Kt(d(i[h],l[h]));h===0?s=p:s=ve(s,p),t.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],p=this.metricsTensors[h][1],m=Kt(d(i[p],l[p]));t.push(m)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,a,o,l,h,d,p,m;try{const y=s.batchSize==null?32:s.batchSize;BS(y);const x=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,y);r=x[0],i=x[1],m=x[2];let w=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)l=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Ze("validationData including sample weights is not supported yet."):new J(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const F=await this.standardizeUserData(l,h,null,null,!0,y);d=F[0],p=F[1],v=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const L=Math.floor(r[0].shape[0]*(1-s.validationSplit)),F=r[0].shape[0];d=gf(r,L,F),a=r,r=gf(r,0,L),p=gf(i,L,F),o=i,i=gf(i,0,L),v=d.concat(p)}else s.validationSteps!=null&&(w=!0);const C=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const N=this.makeTrainFunction(),k=this.getDedupedMetricsNames();let E,A;w?(this.makeTestFunction(),E=this.testFunction,A=k.slice().concat(k.map(L=>"val_"+L))):(E=null,v=[],A=k.slice());const R=cB(s.callbacks,s.yieldEvery);return await this.fitLoop(N,C,k,y,s.epochs,s.verbose,R,E,v,s.shuffle,A,s.initialEpoch,null,null)}finally{this.isTraining=!1,si(r,e),si(i,t),si(a,e),si(o,t),si(d,l),si(p,h),m!=null&&Ke(m)}}async fitLoop(e,t,s,r,i,a,o,l,h,d,p,m,y,b){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(l!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new J("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(t,r,y,"steps_per_epoch");let v;w!=null&&(v=gi(0,w)),a==null&&(a=1);const{callbackList:C,history:N}=hB(o,a,i,m,w,y,r,x,p);C.setModel(this),this.history=N,await C.onTrainBegin(),this.stopTraining_=!1;for(let k=m;k<i;++k){await C.onEpochBegin(k);const E={};if(y!=null)throw new Ze("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Ze("batch shuffling is not implemneted yet");d&&d2(v);const A=Xn(v),R=VS(w,r);for(let D=0;D<R.length;++D){const L={};if(await C.onBatchBegin(D,L),re(()=>{const F=R[D][0],_=R[D][1],V=jl(A,F,_-F);L.batch=D,L.size=_-F;const Q=tC(t,V),ne=e(Q);for(let Z=0;Z<s.length;++Z){const B=s[Z],U=ne[Z];L[B]=U,En(U)}if(D===R.length-1&&x){const Z=this.testLoop(l,h,r);for(let B=0;B<s.length;++B){const U=s[B],K=Z[B];En(K),E["val_"+U]=K}}}),await C.onBatchEnd(D,L),aB(L),this.stopTraining_)break}A.dispose()}if(await C.onEpochEnd(k,E),this.stopTraining_)break}return await C.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Kae(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],i=s[1],o=this.makeTrainFunction()(r.concat(i)),l=[];for(const h of o){const d=await h.data();l.push(d[0])}return Ke(o),si(s[0],e),si(s[1],t),ks(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<r.length;++a)s&&!r[a].trainable||t.push({name:r[a].originalName,tensor:i[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=FT().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-FT().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ga(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ga(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=ga(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ga(Py(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ga(Py(e)));{const e={};for(const t in this.metrics)e[t]=ga(Py(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=cp(e.optimizer_config),s=pi(t);let r;if(typeof e.loss=="string")r=$l(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>$l(a));else if(e.loss!=null){r={};for(const a in e.loss)r[a]=$l(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>$l(a));else if(e.metrics!=null){i={};for(const a in e.metrics)i[a]=$l(e.metrics[a])}this.compile({loss:r,metrics:i,optimizer:s})}async save(e,t){if(typeof e=="string"){const h=BM(e);if(h.length===0)throw new J(`Cannot find any save handlers for URL '${e}'`);if(h.length>1)throw new J(`Found more than one (${h.length}) save handlers for URL '${e}'`);e=h[0]}if(e.save==null)throw new J("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await MT(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:noe,generatedBy:`TensorFlow.js tfjs-layers v${Nw}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:p}=await MT(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=zM([s.data,d])}return this.userDefinedMetadata!=null&&(QO(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){QO(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}va.className="Model";Se(va);class SB extends va{}SB.className="Functional";Se(SB);async function soe(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=cp(t),r=pi(s,e);if(n.weightsManifest!=null){const i=await tP(n.weightsManifest,n.pathPrefix,r.weights.map(o=>o.originalName)),a={};for(const o of r.weights)a[o.originalName]=i[o.originalName];r.loadWeights(a),Ke(i)}return r}async function roe(n,e){if(e==null&&(e={}),typeof n=="string"){const t=VM(n,e);if(t.length===0)t.push(rP(n,e));else if(t.length>1)throw new J(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return ioe(n,void 0,e)}async function ioe(n,e,t){if(t==null&&(t={}),n.load==null)throw new J("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=t.strict==null?!0:t.strict,a=s.weightData!=null&&s.weightSpecs!=null&&i,o=pi(cp(r),e,a),l=s.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),s.userDefinedMetadata!=null&&o.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new J("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=aoe(s.weightData,s.weightSpecs);o.loadWeights(h,i),o.optimizer!=null&&d.length>0&&await o.optimizer.setWeights(d),Ke(h),Ke(d.map(p=>p.tensor))}return o}function aoe(n,e){const t=C2(n,e),s={},r=[];return e.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:t[i.name]}):s[i.name]=t[i.name]}),{modelWeights:s,optimizerWeights:r}}class tu extends va{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:fw("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new J(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof tu||e instanceof va;let s;if(t){if(s=e,s.outputs.length!==1)throw new J("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new J("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new J("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=iB({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new J(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new J("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=rB(this.outputs[0])}this.inboundNodes=[],new Sw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:eu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(wt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new va({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let i,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new J("Legacy serialization format not supported yet.");i=t}else O(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof tu))throw new Ze(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of i){const d=pi(l,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(e){if(this.model==null)throw new J("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new J("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}tu.className="Sequential";Se(tu);function ooe(n){return new va(n)}function loe(n){return new tu(n)}function TB(n){return iB(n)}function uoe(n,e){fr.registerCallbackConstructor(n,e)}let cs=class extends mu{getConfig(){return{}}};class CB extends cs{apply(e,t=1){return Eie(e,t)}}CB.className="elu";Se(CB);class NB extends cs{apply(e){return Vx(e)}}NB.className="selu";Se(NB);class kB extends cs{apply(e){return vi(e)}}kB.className="relu";Se(kB);class EB extends cs{apply(e){return re(()=>Do(6,vi(e)))}}EB.className="relu6";Se(EB);class IB extends cs{apply(e){return e}}IB.className="linear";Se(IB);class $B extends cs{apply(e){return fi(e)}}$B.className="sigmoid";Se($B);class _B extends cs{apply(e){return $ie(e)}}_B.className="hardSigmoid";Se(_B);class AB extends cs{apply(e){return fu(e)}}AB.className="softplus";Se(AB);class RB extends cs{apply(e){return Iie(e)}}RB.className="softsign";Se(RB);class DB extends cs{apply(e){return Ro(e)}}DB.className="tanh";Se(DB);let Dk=class extends cs{apply(e,t=-1){return Um(e,t)}};Dk.className="softmax";Se(Dk);class OB extends cs{apply(e,t=-1){return Ox(e,t)}}OB.className="logSoftmax";Se(OB);class LB extends cs{apply(e){return re(()=>re(()=>{const t=Math.sqrt(2),s=q(.5,ve(1,Ax(Le(e,t))));return q(e,s)}))}}LB.className="gelu";Se(LB);class FB extends cs{apply(e){return re(()=>q(.5,q(e,ve(1,Ro(q(Pn(Le(2,Math.PI)),ve(e,q(.044715,Wi(e,3)))))))))}}FB.className="gelu_new";Se(FB);class MB extends cs{apply(e){return re(()=>q(e,Ro(fu(e))))}}MB.className="mish";Se(MB);class zB extends cs{apply(e,t=1){return re(()=>q(fi(q(e,t)),e))}}zB.className="swish";Se(zB);function Lo(n){return n.getClassName()}function US(n,e={}){return Km(n,yr.getMap().classNameMap,e,"activation")}function Fo(n){if(n==null){const e={};return e.className="linear",e.config={},US(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},US(e)}else return n instanceof cs?n:US(n)}function Ok(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class PB extends mu{}class Qm extends PB{constructor(e){super(),Ok(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return re(()=>{let t=gn([1]);return this.hasL1&&(t=ve(t,Re(q(this.l1,mn(e))))),this.hasL2&&(t=ve(t,Re(q(this.l2,Ym(e))))),Y(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Qm.className="L1L2";Se(Qm);function coe(n){return Ok(n),new Qm({l1:n!=null?n.l1:null,l2:0})}function hoe(n){return Ok(n),new Qm({l2:n!=null?n.l2:null,l1:0})}const i3={l1l2:"L1L2"};function Ot(n){return fk(n)}function a3(n,e={}){return Km(n,yr.getMap().classNameMap,e,"regularizer")}function Gt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in i3?i3[n]:n,config:{}};return a3(t)}else return n instanceof PB?n:a3(n)}class Lk extends rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=He(e);let s=vi(e);return this.maxValue!=null&&(s=Rs(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Lk.className="ReLU";Se(Lk);class Fk extends rt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=He(e);return Rm(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Fk.className="LeakyReLU";Se(Fk);class Mk extends rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Wt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Gt(e.alphaRegularizer),this.alphaConstraint=_n(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new J(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=wt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new yn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=He(e),Pm(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Yt(this.alphaInitializer),alphaRegularizer:Ot(this.alphaRegularizer),alphaConstraint:$n(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Mk.className="PReLU";Se(Mk);let zk=class extends rt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=He(e);return Jh(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};zk.className="ELU";Se(zk);class Pk extends rt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=He(e);return q(s,Ne(vs(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Pk.className="ThresholdedReLU";Se(Pk);class Bk extends rt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Dk().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return re(()=>{let s=He(e);const r=t.mask;if(r!=null){const i=q(_e(Is(s.shape),Ne(r,s.dtype)),Pe(-1e9));s=ve(s,i)}return this.axis instanceof Array?this.axis.length>1?Ds(_e(s,Om(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Bk.className="Softmax";Se(Bk);function Oc(n,e,t){if(typeof n=="number")return eu(n,e);if(n.length!==e)throw new J(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!Tie(r))throw new J(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function mi(n,e,t,s,r=1){if(n==null)return n;const i=e+(e-1)*(r-1);let a;return t==="same"?a=n:a=n-i+1,Math.floor((a+s-1)/s)}function Ri(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Oo([t-e,0]);else if(s==="same")n=n*e;else throw new J(`Unsupport padding mode: ${s}.`);return n}function Vk(n,e){return re(()=>(hn(e),e==="channelsFirst"?lt(n,[0,2,3,1]):n))}function BB(n,e){return re(()=>(hn(e),e==="channelsFirst"?lt(n,[0,2,3,4,1]):n))}function doe(n,e,t,s=1,r="valid",i,a=1){return re(()=>{if(i==null&&(i=yi()),hn(i),n.shape.length!==3)throw new J(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new J(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new J(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(i==="channelsFirst"&&(n=lt(n,[0,2,1])),r==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Ex(n,e,s,r==="same"?"same":"valid","NWC",a);return t!=null&&(o=Si(o,t)),o})}function o3(n,e,t,s=[1,1],r="valid",i,a,o=null){return re(()=>{if(i==null&&(i=yi()),hn(i),n.rank!==3&&n.rank!==4)throw new J(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new J(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=Vk(n,i);if(r==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Vz({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),i==="channelsFirst"&&(l=lt(l,[0,3,1,2])),l})}function foe(n,e,t,s=[1,1,1],r="valid",i,a){return re(()=>{if(i==null&&(i=yi()),hn(i),n.rank!==4&&n.rank!==5)throw new J(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new J(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=BB(n,i);if(r==="causal")throw new Ze("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=X2(o,e,s,r==="same"?"same":"valid","NDHWC",a),t!=null&&(o=Si(o,t)),i==="channelsFirst"&&(o=lt(o,[0,4,1,2,3])),o})}class kw extends rt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",kw.verifyArgs(t),this.rank=e,Fn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Oc(t.kernelSize,e,"kernelSize"),this.strides=Oc(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Nr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,hn(this.dataFormat),this.activation=Fo(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=_n(t.biasConstraint),this.biasRegularizer=Gt(t.biasRegularizer),this.activityRegularizer=Gt(t.activityRegularizer),this.dilationRate=Oc(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new J(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new J(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new J(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Ai("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!pk(e.kernelSize,"number",1,3))throw new J(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Lo(this.activation),useBias:this.useBias,biasInitializer:Yt(this.biasInitializer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),biasConstraint:$n(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class id extends kw{constructor(e,t){super(e,t),this.kernel=null,id.verifyArgs(t),this.filters=t.filters,Fn(this.filters,"filters"),this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=_n(t.kernelConstraint),this.kernelRegularizer=Gt(t.kernelRegularizer)}build(e){e=wt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new J(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return re(()=>{e=He(e);let s;const r=this.bias==null?null:this.bias.read(),i=XP(this.activation.getClassName());if(i!=null&&this.rank===2)s=o3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=doe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=o3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=foe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ze("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=wt(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<s.length;++i){const a=mi(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(a)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Yt(this.kernelInitializer),kernelRegularizer:Ot(this.kernelRegularizer),kernelConstraint:$n(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new J(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ad extends id{constructor(e){super(2,e),ad.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!pk(e.kernelSize,"number",1,2))throw new J(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ad.className="Conv2D";Se(ad);class od extends id{constructor(e){super(3,e),od.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new J(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}od.className="Conv3D";Se(od);class Uk extends ad{constructor(e){if(super(e),this.inputSpec=[new yn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new J(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wt(e),e.length!==4)throw new J("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new J("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return re(()=>{let s=He(e);if(s.shape.length!==4)throw new J(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const l=r[a],h=r[o],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=Ri(l,m,d,this.padding),x=Ri(h,y,p,this.padding),w=[i,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=lt(s,[0,2,3,1]));let v=Ix(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=lt(v,[0,3,1,2])),this.bias!=null&&(v=Si(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=wt(e);const t=e.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],h=this.strides[1];return t[s]=this.filters,t[r]=Ri(t[r],l,a,this.padding),t[i]=Ri(t[i],h,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Uk.className="Conv2DTranspose";Se(Uk);class jk extends od{constructor(e){if(super(e),this.inputSpec=[new yn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new J(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wt(e),e.length!==5)throw new J("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new J("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return re(()=>{let s=He(e);if(s.shape.length!==5)throw new J(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let a,o,l;this.dataFormat==="channelsFirst"?(l=2,a=3,o=4):(l=1,a=2,o=3);const h=r[l],d=r[a],p=r[o],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],v=this.strides[2],C=Ri(h,x,m,this.padding),N=Ri(d,w,y,this.padding),k=Ri(p,v,b,this.padding),E=[i,C,N,k,this.filters];this.dataFormat!=="channelsLast"&&(s=lt(s,[0,2,3,4,1]));let A=Y2(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=lt(A,[0,4,1,2,3])),this.bias!==null&&(A=Si(A,this.bias.read(),this.dataFormat)),this.activation!==null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=wt(e);const t=e.slice();let s,r,i,a;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,a=4):(s=4,r=1,i=2,a=3);const o=this.kernelSize[0],l=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return t[s]=this.filters,t[r]=Ri(t[r],d,o,this.padding),t[i]=Ri(t[i],p,l,this.padding),t[a]=Ri(t[a],m,h,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}jk.className="Conv3DTranspose";Se(jk);class VB extends id{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new J("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new J("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new J(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Gt(t.depthwiseRegularizer),this.depthwiseConstraint=_n(t.depthwiseConstraint),this.pointwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Gt(t.pointwiseRegularizer),this.pointwiseConstraint=_n(t.pointwiseConstraint)}build(e){if(e=wt(e),e.length<this.rank+2)throw new J(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new J(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let o=0;o<this.rank;++o)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new yn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return re(()=>{e=He(e);let s;if(this.rank===1)throw new Ze("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=lt(e,[0,2,3,1])),s=Ux(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Si(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=lt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Yt(this.depthwiseInitializer),e.pointwiseInitializer=Yt(this.pointwiseInitializer),e.depthwiseRegularizer=Ot(this.depthwiseRegularizer),e.pointwiseRegularizer=Ot(this.pointwiseRegularizer),e.depthwiseConstraint=$n(this.depthwiseConstraint),e.pointwiseConstraint=$n(this.pointwiseConstraint),e}}VB.className="SeparableConv";class Wk extends VB{constructor(e){super(2,e)}}Wk.className="SeparableConv2D";Se(Wk);class eg extends id{constructor(e){super(1,e),eg.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!pk(e.kernelSize,"number",1,1))throw new J(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}eg.className="Conv1D";Se(eg);class Gk extends rt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return re(()=>{if(e=He(e),this.dataFormat==="channelsLast"){const s=zy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return zy(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=zy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return zy(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Gk.className="Cropping2D";Se(Gk);class Hk extends rt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,wie(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return re(()=>{let s=He(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=lt(s,[0,2,3,1]);const i=this.size[0]*r[2],a=this.size[1]*r[3],o=this.interpolation==="nearest"?jr.resizeNearestNeighbor(s,[i,a]):jr.resizeBilinear(s,[i,a]);return lt(o,[0,3,1,2])}else{const i=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?jr.resizeNearestNeighbor(s,[i,a]):jr.resizeBilinear(s,[i,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Hk.className="UpSampling2D";Se(Hk);function poe(n,e,t=[1,1],s="valid",r,i){return re(()=>{r==null&&(r=yi()),hn(r);let a=Vk(n,r);if(n.rank!==4)throw new J(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new J(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Yh(a,e,t,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(a=lt(a,[0,3,1,2])),a})}class qk extends kw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Wt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=_n(e.depthwiseConstraint),this.depthwiseRegularizer=Gt(e.depthwiseRegularizer)}build(e){if(e=wt(e),e.length<4)throw new J(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new J(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return re(()=>{e=He(e);let s=poe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Si(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=wt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=mi(t,this.kernelSize[0],this.padding,this.strides[0]),a=mi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,i,a]:[e[0],i,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Yt(this.depthwiseInitializer),e.depthwiseRegularizer=Ot(this.depthwiseRegularizer),e.depthwiseConstraint=$n(this.depthwiseRegularizer),e}}qk.className="DepthwiseConv2D";Se(qk);function UB(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new J("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function jB(n,e,t,s=!1,r,i,a=!1,o=!1){return re(()=>{const l=e.shape.length;if(l<3)throw new J(`Input should be at least 3D, but is ${l}D.`);const h=[1,0].concat(gi(2,l));e=lt(e,h),a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ne(Ne(r,"bool"),"float32"),r.rank===l-1&&(r=Hn(r,-1)),r=lt(r,h)),s&&(e=Tr(e,0),r!=null&&(r=Tr(r,0)));const d=[];let p,m=t;const y=e.shape[0],b=Cr(e);let x;r!=null&&(x=Cr(r));for(let v=0;v<y;++v){const C=b[v],N=re(()=>n(C,m));if(r==null)p=N[0],m=N[1];else{const k=re(()=>{const E=x[v],A=_e(Zs(E),E),R=ve(q(N[0],E),q(m[0],A)),D=m.map((L,F)=>ve(q(N[1][F],E),q(L,A)));return{output:R,newStates:D}});p=k.output,m=k.newStates}o&&d.push(p)}let w;return o&&(w=bs(d,1)),[p,w,m]})}class Ti extends rt{constructor(e){super(e);let t;if(e.cell==null)throw new J("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new $w({cells:e.cell}):t=e.cell,t.stateSize==null)throw new J("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new yn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return gi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){JT(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const i=[];for(const a of t)i.push([e[0],a]);return[r].concat(i)}else return r}computeMask(e,t){return re(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ze("Constants support is not implemented in RNN yet.");JT(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new yn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!at(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new J(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new yn({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){re(()=>{if(!this.stateful)throw new _i("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new J("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gn([s,r])):this.states_=[gn([s,this.cell.stateSize])];else if(e==null)Ke(this.states_),this.keptStates!=null&&(Ke(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gn([s,r])):this.states_[0]=gn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new J(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Ke(this.states_);for(let r=0;r<this.states_.length;++r){const i=e[r],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,a];if(!at(i.shape,o))throw new J(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>En(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=UB(e,s,r,this.numConstants);e=i.inputs,s=i.initialState,r=i.constants;let a=[],o=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new yn({shape:h.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof bi){const h=[e].concat(a),d=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return re(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let i=t==null?null:t.initialState;e=He(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new J(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},h=jB((b,x)=>{const w=this.cell.call([b].concat(x),o);return[w[0],w.slice(1)]},e,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],p=h[1],m=h[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?p:d;return this.returnState?[y].concat(m):y})}getInitialState(e){return re(()=>{let t=gn(e.shape);return t=Re(t,[1,2]),t=Xm(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?XT(t,[1,s]):t):this.cell.stateSize>1?[XT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Ti.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,i=pi(r,s);return new e(Object.assign(t,{cell:i}))}}Ti.className="RNN";Se(Ti);class tg extends rt{}class Ew extends tg{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Fn(this.units,"units"),this.activation=Fo(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Oo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Oo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return re(()=>{if(e=e,e.length!==2)throw new J(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?i=Vi(q(e,a),this.kernel.read()):i=Vi(e,this.kernel.read()),this.bias!=null&&(i=Si(i,this.bias.read())),o!=null&&(s=q(s,o));let l=ve(i,Vi(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Lo(this.activation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),recurrentConstraint:$n(this.recurrentConstraint),biasConstraint:$n(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Ew.className="SimpleRNNCell";Se(Ew);class Kk extends Ti{constructor(e){e.cell=new Ew(e),super(e)}call(e,t){return re(()=>{this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}}Kk.className="SimpleRNN";Se(Kk);class Iw extends tg{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new J("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Fn(this.units,"units"),this.activation=Fo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Oo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Oo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return re(()=>{if(e=e,e.length!==2)throw new J(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,h;0<this.dropout&&this.dropout<1&&(e=q(e,i[0]));let d=Vi(e,this.kernel.read());this.useBias&&(d=Si(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=q(r,a[0]));const p=this.recurrentKernel.read(),[m,y]=$s(p,[2*this.units,this.units],p.rank-1),b=Vi(r,m),[x,w,v]=$s(d,3,d.rank-1),[C,N]=$s(b,2,b.rank-1);o=this.recurrentActivation.apply(ve(x,C)),l=this.recurrentActivation.apply(ve(w,N));const k=Vi(q(l,r),y);h=this.activation.apply(ve(v,k));const E=ve(q(o,r),q(ve(1,Mt(o)),h));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Lo(this.activation),recurrentActivation:Lo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),recurrentConstraint:$n(this.recurrentConstraint),biasConstraint:$n(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Iw.className="GRUCell";Se(Iw);class Xk extends Ti{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Iw(e),super(e)}call(e,t){return re(()=>{this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Xk.className="GRU";Se(Xk);class ng extends tg{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Fn(this.units,"units"),this.activation=Fo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Fo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Oo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Oo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=wt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;r=new(t=class extends Kr{apply(l,h){const d=i.apply([a]),p=new mw().apply([a]),m=i.apply([a*2]);return WO(WO(d,p),m)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return re(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new J(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let l,h,d,p;0<this.dropout&&this.dropout<1&&(e=q(e,a[0]));let m=Vi(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=q(r,o[0])),m=ve(m,Vi(r,this.recurrentKernel.read())),this.useBias&&(m=Si(m,this.bias.read()));const[y,b,x,w]=$s(m,4,m.rank-1);l=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=ve(q(h,i),q(l,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const v=q(p,this.activation.apply(d));return[v,v,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Lo(this.activation),recurrentActivation:Lo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),recurrentConstraint:$n(this.recurrentConstraint),biasConstraint:$n(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}ng.className="LSTMCell";Se(ng);class Yk extends Ti{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ng(e),super(e)}call(e,t){return re(()=>{this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Yk.className="LSTM";Se(Yk);class $w extends tg{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return re(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let a;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=r[o],o===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,t),i.push(a.slice(1))}s=[];for(const o of i.slice().reverse())s.push(...o);return[a[0]].concat(s)})}build(e){JT(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Ul(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const i of t.cells)r.push(pi(i,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return ZT(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,i=e.splice(r);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],i[a]])}Tk(t)}}$w.className="StackedRNNCells";Se($w);function Mo(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:i}=n,a=()=>i!=null?i(e(),t):nB(e(),t),o=()=>Jm(a,e,s);return!r||r<=1?En(o().clone()):Array(r).fill(void 0).map(o).map(h=>En(h.clone()))}var moe=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class WB extends Ti{constructor(e){if(e.unroll)throw new Ze("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ze("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new yn({ndim:5})]}call(e,t){return re(()=>{if(this.cell.dropoutMask!=null&&(Ke(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ke(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new J("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return re(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],a=gn(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){re(()=>{if(!this.stateful)throw new _i("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new J("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gn(i)):this.states_=[gn(i)];else if(e==null)Ke(this.states_),this.keptStates!=null&&(Ke(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gn(i)):this.states_[0]=gn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new J(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ke(this.states_);for(let o=0;o<this.states_.length;++o){const l=e[o],h=i;if(!at(l.shape,h))throw new J(`State ${o} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>En(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:i,strides:a,dilationRate:o}=this.cell,l=t==="channelsFirst",h=e[l?3:2],d=e[l?4:3],p=mi(h,r[0],i,a[0],o[0]),m=mi(d,r[1],i,a[1],o[1]);return[...e.slice(0,2),...l?[s,p,m]:[p,m,s]]}}WB.className="ConvRNN2D";class _w extends ng{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:i,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Fn(this.filters,"filters"),this.kernelSize=Oc(s,2,"kernelSize"),this.kernelSize.forEach(l=>Fn(l,"kernelSize")),this.strides=Oc(r||1,2,"strides"),this.strides.forEach(l=>Fn(l,"strides")),this.padding=i||"valid",Nr(this.padding),this.dataFormat=a||"channelsLast",hn(this.dataFormat),this.dilationRate=Oc(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>Fn(l,"dilationRate"))}build(e){var t;e=wt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new J(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],i=4,a=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;l=new(t=class extends Kr{apply(m,y){const b=h.apply([d]),x=Is([d]),w=h.apply([d*2]);return mk([b,x,w])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return re(()=>{if(e.length!==3)throw new J(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],i=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,h=(se,P,j)=>!P||!P[j]?se:q(P[j],se);let d=h(r,l,0),p=h(r,l,1),m=h(r,l,2),y=h(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(i),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(i,b,0),w=h(i,b,1),v=h(i,b,2),C=h(i,b,3);const N=3,[k,E,A,R]=$s(this.kernel.read(),o,N),[D,L,F,_]=this.useBias?$s(this.bias.read(),o):[null,null,null,null];d=this.inputConv(d,k,D,this.padding),p=this.inputConv(p,E,L,this.padding),m=this.inputConv(m,A,F,this.padding),y=this.inputConv(y,R,_,this.padding);const[V,Q,ne,Z]=$s(this.recurrentKernel.read(),o,N);x=this.recurrentConv(x,V),w=this.recurrentConv(w,Q),v=this.recurrentConv(v,ne),C=this.recurrentConv(C,Z);const B=this.recurrentActivation.apply(ve(d,x)),U=this.recurrentActivation.apply(ve(p,w)),K=ve(q(U,a),q(B,this.activation.apply(ve(m,v)))),X=q(this.recurrentActivation.apply(ve(y,C)),this.activation.apply(K));return[X,X,K]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=moe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const i=Ia(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Si(i,s,this.dataFormat):i}recurrentConv(e,t){return Ia(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}_w.className="ConvLSTM2DCell";Se(_w);class Jk extends WB{constructor(e){const t=new _w(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Jk.className="ConvLSTM2D";Se(Jk);class Aw extends rt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,i=this.getNoiseShape(s);return Jm(()=>nB(s,this.rate,i,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Aw.className="Dropout";Se(Aw);class Zk extends Aw{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Zk.className="SpatialDropout1D";Se(Zk);class Qk extends rt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Fn(this.units,"units"),this.activation=Fo(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=_n(e.kernelConstraint),this.biasConstraint=_n(e.biasConstraint),this.kernelRegularizer=Gt(e.kernelRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.activityRegularizer=Gt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=wt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=wt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e),r=XP(this.activation.getClassName());let i;return r!=null?i=Vi(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=Vi(s,this.kernel.read()),this.bias!=null&&(i=Si(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:Lo(this.activation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:$n(this.kernelConstraint),biasConstraint:$n(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Qk.className="Dense";Se(Qk);class eE extends rt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=wt(e);for(const t of e.slice(1))if(t==null)throw new J(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],No(e,1)]}call(e,t){return re(()=>{this.invokeCallHook(e,t);let s=He(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=lt(s,r)}return kie(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}eE.className="Flatten";Se(eE);class tE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Fo(e.activation)}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e);return this.activation.apply(s)})}getConfig(){const e={activation:Lo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}tE.className="Activation";Se(tE);class nE extends rt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return re(()=>(e=He(e),Cie(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}nE.className="RepeatVector";Se(nE);class sE extends rt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let i=1,a=null;for(let l=0;l<r.length;++l){const h=r[l];if(this.isUnknown(h))if(a===null)a=l;else throw new J("Can only specifiy one unknown dimension.");else i*=h}const o=No(e);if(a!==null){if(i===0||o%i!==0)throw new J(s);r[a]=o/i}else if(o!==i)throw new J(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Y(s,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}sE.className="Reshape";Se(sE);class rE extends rt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=gi(1,e.dims.length+1);if(!at(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new yn({ndim:this.dims.length+1})]}computeOutputShape(e){e=wt(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return lt(He(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}rE.className="Permute";Se(rE);class iE extends rt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=He(e);return ip(Jl(s,this.maskValue),-1)}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e),a=ip(Jl(s,this.maskValue),-1,!0);return q(s,Ne(a,s.dtype))})}}iE.className="Masking";Se(iE);class aE extends rt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ct(e.inputLength))}this.inputDim=e.inputDim,Fn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Fn(this.outputDim,"outputDim"),this.embeddingsInitializer=Wt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Gt(e.embeddingsRegularizer),this.activityRegularizer=Gt(e.activityRegularizer),this.embeddingsConstraint=_n(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return re(()=>this.maskZero?(e=He(e),Jl(e,dt(e))):null)}computeOutputShape(e){if(e=wt(e),this.inputLength==null)return[...e,this.outputDim];const t=Ct(this.inputLength);if(t.length!==e.length-1)throw new J(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const i=t[r],a=e[r+1];if(i!=null&&a!=null&&i!==a)throw new J(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return re(()=>{this.invokeCallHook(e,t);let s=He(e);s.dtype!=="int32"&&(s=Bi(s,"int32"));const r=tB(this.embeddings.read(),Y(s,[s.size]));return Y(r,wt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Yt(this.embeddingsInitializer),embeddingsRegularizer:Ot(this.embeddingsRegularizer),activityRegularizer:Ot(this.activityRegularizer),embeddingsConstraint:$n(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}aE.className="Embedding";Se(aE);class bu extends rt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ze}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const i=e[e.length-t.length+r],a=t[r];if(i==null||a==null||i<0||a<0)s.push(null);else if(i===1)s.push(a);else if(a===1)s.push(i);else{if(i!==a)throw new J("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(i)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[wt(e)]),e=e,e.length<2)throw new J(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Co(t),t.length>1)throw new J(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const a=e[i]==null?null:e[i].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const r=e.map(i=>i.length);e.indexOf(null)===-1&&Co(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return re(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Oo(r);for(let a of e){const o=a.rank;for(let l=0;l<i-o;++l)a=Xm(a,1);s.push(a)}return this.mergeFunction(s)}else{let i=!1;for(const l of e){const h=l.rank;if(h==null){const d=l.shape,p=d[0],m=d.slice(1).concat([p]);let y=Y(l,[p].concat(No(d.slice(1))));y=lt(y,[1,0]),y=Y(y,m),s.push(y),i=!0}else if(h>1){const d=gi(1,h).concat([0]);s.push(lt(l,d)),i=!0}else s.push(l)}let a=this.mergeFunction(s);const o=a.rank;if(i){if(o==null){const l=a.shape,h=l.length,d=l[h-1],p=[d].concat(l.slice(0,l.length-1));a=Y(lt(Y(a,[-1,d]),[1,0]),p)}else if(o>1){const l=[o-1].concat(gi(0,o-1));a=lt(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const i=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Co(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return re(()=>{if(t==null)return null;if(!Array.isArray(t))throw new J("`mask` should be an Array");if(!Array.isArray(e))throw new J("`inputs` should be an Array");if(t.length!==e.length)throw new J(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Hn(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=Hr(s,t[r]);return s})}}class oE extends bu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ve(t,e[s]);return t})}}oE.className="Add";Se(oE);class lE extends bu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=q(t,e[s]);return t})}}lE.className="Multiply";Se(lE);class uE extends bu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ve(t,e[s]);return q(1/e.length,t)})}}uE.className="Average";Se(uE);class cE extends bu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=qi(t,e[s]);return t})}}cE.className="Maximum";Se(cE);class hE extends bu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Do(t,e[s]);return t})}}hE.className="Minimum";Se(hE);class dE extends bu{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new J("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const i=e[r].slice();i.splice(this.axis,1);let a=!1;for(const o of s)if(at(o,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new J("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return re(()=>mk(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new J("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of t.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new J("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new J("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new J(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return re(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(Ne(Zs(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Hn(t[a],-1)):r.push(t[a]);const i=ln(r,this.axis);return kx(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}dE.className="Concatenate";Se(dE);function yf(n,e){for(;n<0;)n+=e;return n}function goe(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Ze("batchDot is not implemented for tensors of 4D or higher rank yet");if(O(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),O(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Ze("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const i=t;return re(()=>{let a;if(s>r){a=s-r;const l=[];for(let h=0;h<a;++h)l.push(1);e=Y(e,e.shape.concat(l))}else if(r>s){a=r-s;const l=[];for(let h=0;h<a;++h)l.push(1);n=Y(n,n.shape.concat(l))}else a=0;let o;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?o=Re(q(n,e),i[0]):o=Re(q(lt(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,h=i[1]===e.shape.length-1;o=nt(n,e,l,h)}if(a>0){let l;s>r?l=s+r-3:l=s-1;const h=[];for(let d=l;d<l+a;++d)h.push(d);o=Ho(o,h)}return o.shape.length===1&&(o=Hn(o,1)),o})}class fE extends bu{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new J(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new J(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,a)=>yf(i,e[a].shape.length)):r=[yf(this.axes,t.shape.length),yf(this.axes,s.shape.length)],this.normalize&&(t=U0(t,r[0]),s=U0(s,r[1])),goe(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[yf(this.axes,e.length),yf(this.axes,t.length)],s}computeOutputShape(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=t.concat(s);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}fE.className="Dot";Se(fE);class pE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e);return Jm(()=>ve(pw(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}pE.className="GaussianNoise";Se(pE);class mE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=He(e);return this.rate>0&&this.rate<1?Jm(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return q(s,pw(s.shape,1,i))},()=>s,t.training||!1):s})}}mE.className="GaussianDropout";Se(mE);class gE extends rt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||He(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return re(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Jm(()=>{const i=He(e),o=-1.6732632423543772*1.0507009873554805;let l=Ma(Go(s),this.rate);l=Bi(l,"float32");const h=((1-this.rate)*(1+this.rate*o**2))**-.5,d=-h*o*this.rate,p=ve(q(i,l),q(ve(l,-1),o));return ve(q(p,h),d)},()=>He(e),t.training||!1)}return e})}}gE.className="AlphaDropout";Se(gE);function hp(n,e,t,s,r,i=.001){let a;if(n.rank===2)a=P2(n,e,t,s,r,i);else if(n.rank===3)a=B2(n,e,t,s,r,i);else if(n.rank===4)a=V2(n,e,t,s,r,i);else throw new Ze(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function yoe(n,e,t,s,r=.001){return re(()=>{const i=Mm(n,s),a=i.mean,o=i.variance;return[hp(n,a,o,t,e,r),a,o]})}function boe(n,e,t,s,r=.001){return re(()=>{const i=Mm(n,s),a=i.mean,o=i.variance,l=[];for(const b of gi(0,n.rank))s.indexOf(b)!==-1?l.push(1):l.push(n.shape[b]);const h=Y(a,l),d=Y(o,l),p=e==null?null:Y(e,l),m=t==null?null:Y(t,l);return[hp(n,h,d,m,p,r),a,o]})}function xoe(n,e,t,s,r=.001){return at(s.slice().sort(),gi(0,n.rank-1))?yoe(n,e,t,s,r):boe(n,e,t,s,r)}class yE extends rt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Wt(e.betaInitializer||"zeros"),this.gammaInitializer=Wt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Wt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Wt(e.movingVarianceInitializer||"ones"),this.betaConstraint=_n(e.betaConstraint),this.gammaConstraint=_n(e.gammaConstraint),this.betaRegularizer=Gt(e.betaRegularizer),this.gammaRegularizer=Gt(e.gammaRegularizer)}build(e){e=wt(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new J(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new yn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return re(()=>{const s=t.training==null?!1:t.training,r=He(e),i=r.shape,a=i.length,o=gi(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const h=eu(1,a);h[l]=i[l];const d=o.slice();d.sort();const p=!at(d,gi(0,a).slice(0,a-1)),m=()=>{if(p){const C=Y(this.movingMean.read(),h),N=Y(this.movingVariance.read(),h),k=this.center?Y(this.beta.read(),h):null,E=this.scale?Y(this.gamma.read(),h):null;return hp(r,C,N,k,E,this.epsilon)}else return hp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=xoe(r,this.gamma.read(),this.beta.read(),o,this.epsilon),w=(C,N,k)=>{re(()=>{const E=1-k,A=C.read(),R=q(_e(A,N),E);C.write(_e(A,R))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yt(this.betaInitializer),gammaInitializer:Yt(this.gammaInitializer),movingMeanInitializer:Yt(this.movingMeanInitializer),movingVarianceInitializer:Yt(this.movingVarianceInitializer),betaRegularizer:Ot(this.betaRegularizer),gammaRegularizer:Ot(this.gammaRegularizer),betaConstraint:$n(this.betaConstraint),gammaConstraint:$n(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}yE.className="BatchNormalization";Se(yE);class bE extends rt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Wt(e.betaInitializer||"zeros"),this.gammaInitializer=Wt(e.gammaInitializer||"ones"),this.betaRegularizer=Gt(e.betaRegularizer),this.gammaRegularizer=Gt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=wt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Co(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>e[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=He(e),r=s.shape,i=r.length;return re(()=>{let{mean:o,variance:l}=Mm(s,this.axis,!0);const h=eu(1,i);for(const x of this.axis)h[x]=r[x];const d=x=>x!=null&&x.shape.length!==i?Y(x,h):x;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<i;++x)this.axis.indexOf(x)!==-1?(y.push(r[x]),b.push(1)):(y.push(1),b.push(r[x]));return o=br(o,y),l=br(l,y),p!=null&&(p=br(p,b)),m!=null&&(m=br(m,b)),hp(s,o,l,m,p,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yt(this.betaInitializer),gammaInitializer:Yt(this.gammaInitializer),betaRegularizer:Ot(this.betaRegularizer),gammaRegularizer:Ot(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}bE.className="LayerNormalization";Se(bE);function woe(n,e,t){return re(()=>{if(n.rank!==4)throw new J(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new J("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=yi()),t!=="channelsLast"&&t!=="channelsFirst")throw new J(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],za(n,s)})}class xE extends rt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?yi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new J(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new J(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new J(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){e=wt(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return re(()=>woe(He(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}xE.className="ZeroPadding2D";Se(xE);function Rw(n,e,t,s,r,i){return re(()=>{hn(r),JP(i),Nr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=yi()),i==null&&(i="max"),n=Vk(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=Fm(n,e,t,o):a=Im(n,e,t,o),r==="channelsFirst"&&(a=lt(a,[0,3,1,2])),a})}function GB(n,e,t,s,r,i){return re(()=>{hn(r),JP(i),Nr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=yi()),i==null&&(i="max"),n=BB(n,r);let a;const o=s==="same"?"same":"valid";return i==="max"?a=cN(n,e,t,o):a=z2(n,e,t,o),r==="channelsFirst"&&(a=lt(a,[0,4,1,2,3])),a})}class HB extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new J(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Fn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new J(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Fn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Nr(this.padding),this.inputSpec=[new yn({ndim:3})]}computeOutputShape(e){e=wt(e);const t=mi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return re(()=>{this.invokeCallHook(e,t),e=Xm(He(e),2);const s=this.poolingFunction(He(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ho(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class wE extends HB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Rw(e,t,s,r,i,"max")}}wE.className="MaxPooling1D";Se(wE);class vE extends HB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Rw(e,t,s,r,i,"avg")}}vE.className="AveragePooling1D";Se(vE);class qB extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new J(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Fn(this.poolSize,"poolSize"),Fn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),Nr(this.padding),this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){e=wt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=mi(t,this.poolSize[0],this.padding,this.strides[0]),s=mi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return re(()=>(this.invokeCallHook(e,t),this.poolingFunction(He(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class SE extends qB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Rw(e,t,s,r,i,"max")}}SE.className="MaxPooling2D";Se(SE);class TE extends qB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),Rw(e,t,s,r,i,"avg")}}TE.className="AveragePooling2D";Se(TE);class KB extends rt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new J(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Fn(this.poolSize,"poolSize"),Fn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),Nr(this.padding),this.inputSpec=[new yn({ndim:5})]}computeOutputShape(e){e=wt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=mi(t,this.poolSize[0],this.padding,this.strides[0]),s=mi(s,this.poolSize[1],this.padding,this.strides[1]),r=mi(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return re(()=>(this.invokeCallHook(e,t),this.poolingFunction(He(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class CE extends KB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),GB(e,t,s,r,i,"max")}}CE.className="MaxPooling3D";Se(CE);class NE extends KB{constructor(e){super(e)}poolingFunction(e,t,s,r,i){return hn(i),Nr(r),GB(e,t,s,r,i,"avg")}}NE.className="AveragePooling3D";Se(NE);class XB extends rt{constructor(e){super(e),this.inputSpec=[new yn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ze}}class kE extends XB{constructor(e){super(e||{})}call(e,t){return re(()=>{const s=He(e);return Kt(s,1)})}}kE.className="GlobalAveragePooling1D";Se(kE);class EE extends XB{constructor(e){super(e||{})}call(e,t){return re(()=>{const s=He(e);return Sr(s,1)})}}EE.className="GlobalMaxPooling1D";Se(EE);class YB extends rt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ze}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class IE extends YB{call(e,t){return re(()=>{const s=He(e);return this.dataFormat==="channelsLast"?Kt(s,[1,2]):Kt(s,[2,3])})}}IE.className="GlobalAveragePooling2D";Se(IE);class $E extends YB{call(e,t){return re(()=>{const s=He(e);return this.dataFormat==="channelsLast"?Sr(s,[1,2]):Sr(s,[2,3])})}}$E.className="GlobalMaxPooling2D";Se($E);class JB extends rt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,i=pi(r,s);delete t.layer;const a={layer:i};return Object.assign(a,t),new e(a)}}class _E extends JB{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=wt(e),e.length<3)throw new J(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=wt(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return re(()=>(e=He(e),jB((a,o)=>[He(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}_E.className="TimeDistributed";Se(_E);function voe(n){gu(xie,"BidirectionalMergeMode",n)}const Soe="concat";class AE extends JB{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=pi(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=pi(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Soe:e.mergeMode,voe(this.mergeMode),e.weights)throw new Ze("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,i;return this.returnState&&(i=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):ks(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const i=UB(e,s,r,this.numConstants);if(e=i.inputs,s=i.initialState,r=i.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const a=[],o=[];if(s!=null){const h=s.length;if(h%2>0)throw new J("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const d=s.map(p=>new yn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),o.push(...d)}if(r!=null)throw new Ze("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof bi;for(const h of a)if(h instanceof bi!==l)throw new J("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const h=[e].concat(a),d=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=p,m}else return super.apply(e,t)}call(e,t){return re(()=>{const s=t.initialState;let r,i;if(s==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),h=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:h}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Tr(i,1));let o;return this.mergeMode==="concat"?o=mk([r,i]):this.mergeMode==="sum"?o=ve(r,i):this.mergeMode==="ave"?o=q(.5,ve(r,i)):this.mergeMode==="mul"?o=q(r,i):this.mergeMode==null&&(o=[r,i]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ul(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ul(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=pi(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ze("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}AE.className="Bidirectional";Se(AE);class RE extends rt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return re(()=>(e=He(e),e.dtype!=="float32"&&(e=Bi(e,"float32")),ve(q(e,this.scale),this.offset)))}}RE.className="Rescaling";Se(RE);const{resizeBilinear:Toe,cropAndResize:Coe}=jr;class DE extends rt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,i,a,o,l){return re(()=>{let h,d=!1;const p=t/a,m=s/o,y=(r+t)/a,b=(i+s)/o,x=[p,m,y,b],w=[];e.rank===3?(d=!0,h=bs([e])):h=e;for(let E=0;E<h.shape[0];E++)w.push(x);const v=Xs(w,[w.length,4]),C=Zl(0,w.length,1,"int32"),k=Coe(h,v,C,[r,i],"nearest");return Bi(d?He(Cr(k)):k,l)})}upsize(e,t,s,r){return re(()=>{const i=Toe(e,[t,s]);return Bi(i,r)})}call(e,t){return re(()=>{const s=He(e),r=s.dtype,i=s.shape,a=i[i.length-3],o=i[i.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let h=0;return o!==this.width&&(h=Math.floor((o-this.width)/2),h===0&&(h=1)),l>=0&&h>=0?this.centerCrop(s,l,h,this.height,this.width,a,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wt(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}DE.className="CenterCrop";Se(DE);function Noe(n,e,t,s){let r=He(n);if(r.dtype!=="int32"&&(r=Bi(r,"int32")),e==="int")return r;const i=r.shape;if(r.rank===0&&(r=Hn(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Hn(r,-1)),r.rank>2)throw new J(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(e),o=r;let l;if(typeof s<"u"&&e==="count"?l=F0(o,s,t,a):l=F0(o,[],t,a),e!=="tfIdf")return l;if(s)return q(l,s);throw new J("When outputMode is 'tfIdf', weights must be provided.")}class OE extends rt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=wt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return re(()=>{e=He(e),e.dtype!=="int32"&&(e=Bi(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new J(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=He(t.countWeights)}const r=Sr(e),i=Pc(e),a=vs(this.numTokens,r).bufferSync().get(0),o=Ma(i,0).bufferSync().get(0);if(!(a&&o))throw new J(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Noe(e,this.outputMode,this.numTokens,s)})}}OE.className="CategoryEncoding";Se(OE);const koe=["bilinear","nearest"],l3=new Set(koe);class LE extends rt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(l3.has(e.interpolation))this.interpolation=e.interpolation;else throw new J(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=wt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return re(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return jr.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return jr.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...l3]} are supported`)})}}LE.className="Resizing";Se(LE);class ZB{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}ZB.className="RandomSeed";class QB extends rt{constructor(e){super(e),this.randomGenerator=new ZB(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}QB.className="BaseRandomLayer";const Eoe=["bilinear","nearest"],u3=new Set(Eoe);class FE extends QB{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new J(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new J(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new J(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(u3.has(s))this.interpolation=s;else throw new J(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return re(()=>{const s=He(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Go([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return jr.resizeBilinear(e,a);case"nearest":return jr.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...u3]} are supported`)}})}}FE.className="RandomWidth";Se(FE);function Ioe(n){return new sd(n)}function $oe(n){return new zk(n)}function _oe(n){return new Lk(n)}function Aoe(n){return new Fk(n)}function Roe(n){return new Mk(n)}function Doe(n){return new Bk(n)}function Ooe(n){return new Pk(n)}function Loe(n){return new eg(n)}function Foe(n){return new ad(n)}function Moe(n){return new Uk(n)}function zoe(n){return new od(n)}function Poe(n){return new jk(n)}function Boe(n){return new Wk(n)}function Voe(n){return new Gk(n)}function Uoe(n){return new Hk(n)}function joe(n){return new qk(n)}function Woe(n){return new tE(n)}function Goe(n){return new Qk(n)}function Hoe(n){return new Aw(n)}function qoe(n){return new Zk(n)}function Koe(n){return new eE(n)}function Xoe(n){return new nE(n)}function Yoe(n){return new sE(n)}function Joe(n){return new rE(n)}function Zoe(n){return new aE(n)}function Qoe(n){return new oE(n)}function ele(n){return new uE(n)}function tle(n){return new dE(n)}function nle(n){return new cE(n)}function sle(n){return new hE(n)}function rle(n){return new lE(n)}function ile(n){return new fE(n)}function ale(n){return new yE(n)}function ole(n){return new bE(n)}function lle(n){return new xE(n)}function ME(n){return new vE(n)}function ule(n){return ME(n)}function cle(n){return ME(n)}function zE(n){return new TE(n)}function hle(n){return zE(n)}function dle(n){return zE(n)}function PE(n){return new NE(n)}function fle(n){return PE(n)}function ple(n){return PE(n)}function mle(n){return new kE(n)}function gle(n){return new IE(n)}function eV(n){return new EE(n)}function tV(n){return new $E(n)}function nV(n){return new wE(n)}function sV(n){return new SE(n)}function yle(n){return new CE(n)}function ble(n){return new Xk(n)}function xle(n){return new Iw(n)}function wle(n){return new Yk(n)}function vle(n){return new ng(n)}function Sle(n){return new Kk(n)}function Tle(n){return new Ew(n)}function Cle(n){return new Jk(n)}function Nle(n){return new _w(n)}function kle(n){return new Ti(n)}function Ele(n){return new $w(n)}function Ile(n){return new AE(n)}function $le(n){return new _E(n)}const _le=eV,Ale=tV,Rle=nV,Dle=sV;function Ole(n){return new pE(n)}function Lle(n){return new mE(n)}function Fle(n){return new gE(n)}function Mle(n){return new iE(n)}function zle(n){return new RE(n)}function Ple(n){return new DE(n)}function Ble(n){return new LE(n)}function Vle(n){return new OE(n)}function Ule(n){return new FE(n)}const jle=Object.freeze(Object.defineProperty({__proto__:null,Layer:rt,RNN:Ti,RNNCell:tg,activation:Woe,add:Qoe,alphaDropout:Fle,average:ele,averagePooling1d:ME,averagePooling2d:zE,averagePooling3d:PE,avgPool1d:ule,avgPool2d:hle,avgPool3d:fle,avgPooling1d:cle,avgPooling2d:dle,avgPooling3d:ple,batchNormalization:ale,bidirectional:Ile,categoryEncoding:Vle,centerCrop:Ple,concatenate:tle,conv1d:Loe,conv2d:Foe,conv2dTranspose:Moe,conv3d:zoe,conv3dTranspose:Poe,convLstm2d:Cle,convLstm2dCell:Nle,cropping2D:Voe,dense:Goe,depthwiseConv2d:joe,dot:ile,dropout:Hoe,elu:$oe,embedding:Zoe,flatten:Koe,gaussianDropout:Lle,gaussianNoise:Ole,globalAveragePooling1d:mle,globalAveragePooling2d:gle,globalMaxPool1d:_le,globalMaxPool2d:Ale,globalMaxPooling1d:eV,globalMaxPooling2d:tV,gru:ble,gruCell:xle,input:TB,inputLayer:Ioe,layerNormalization:ole,leakyReLU:Aoe,lstm:wle,lstmCell:vle,masking:Mle,maxPool1d:Rle,maxPool2d:Dle,maxPooling1d:nV,maxPooling2d:sV,maxPooling3d:yle,maximum:nle,minimum:sle,multiply:rle,permute:Joe,prelu:Roe,randomWidth:Ule,reLU:_oe,repeatVector:Xoe,rescaling:zle,reshape:Yoe,resizing:Ble,rnn:kle,separableConv2d:Boe,simpleRNN:Sle,simpleRNNCell:Tle,softmax:Doe,spatialDropout1d:qoe,stackedRNNCells:Ele,thresholdedReLU:Ooe,timeDistributed:$le,upSampling2d:Uoe,zeroPadding2d:lle},Symbol.toStringTag,{value:"Module"}));function Wle(n,e){return _k(n,e)}function Gle(n,e){return pB(n,e)}function Hle(n,e){return mB(n,e)}function qle(n,e){return Ak(n,e)}function Kle(n,e){return Rk(n,e)}function Xle(n,e){return fB(n,e)}function Yle(n,e){return Eae(n,e)}function Jle(n,e){return $k(n,e)}function Zle(n,e){return Tw(n,e)}function Qle(n,e){return rd(n,e)}function eue(n,e){return rd(n,e)}function tue(n,e){return rd(n,e)}function nue(n,e){return yu(n,e)}function sue(n,e){return yu(n,e)}function rue(n,e){return yu(n,e)}function iue(n,e){return Iae(n,e)}const aue=Object.freeze(Object.defineProperty({__proto__:null,MAPE:eue,MSE:sue,binaryAccuracy:Wle,binaryCrossentropy:Gle,categoricalAccuracy:qle,categoricalCrossentropy:Kle,cosineProximity:Jle,mape:tue,meanAbsoluteError:Zle,meanAbsolutePercentageError:Qle,meanSquaredError:nue,mse:rue,precision:Xle,r2Score:iue,recall:Yle,sparseCategoricalAccuracy:Hle},Symbol.toStringTag,{value:"Module"}));const oue=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:soe},Symbol.toStringTag,{value:"Module"}));function lue(n){return new Qm(n)}function uue(n){return coe(n)}function cue(n){return hoe(n)}const hue=Object.freeze(Object.defineProperty({__proto__:null,l1:uue,l1l2:lue,l2:cue},Symbol.toStringTag,{value:"Module"}));class rV extends Hc{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof va))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function By(n,e){return n<e}function c3(n,e){return n>e}class iV extends rV{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Ze("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=By:this.mode==="max"?this.monitorFunc=c3:this.monitor.indexOf("acc")!==-1?this.monitorFunc=c3:this.monitorFunc=By,this.monitorFunc===By&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===By?1/0:-1/0}async onEpochEnd(e,t){await po(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function due(n){return new iV(n)}const fue={earlyStopping:due};const pue=ae();pue.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ws;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ws||(Ws={}));var h3;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(h3||(h3={}));const BE={};function mue(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};BE[n]=t}function aV(n){return BE[n]}function gue(n){delete BE[n]}function I(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd,h=o<0?e.inputNames.length+o:o;if(i.type==="tensor")return qn(e.inputNames[h],t,s,r);if(i.type==="tensors"){const m=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((b,x)=>{var w;return((w=m[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(b=>qn(b,t,s,r))}const d=qn(e.inputNames[h],t,s,r),p=d.dataSync();return i.type==="number"?p[0]:vr(d.shape,p)}const a=e.attrParams[n];return a&&a.value}function qn(n,e,t,s){const[r,i]=Hs(n,t);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[q0(r,o)]);return a!==void 0?e[q0(r,a)][i]:void 0}function d3(n,e,t){return e[q0(n,t.currentContextId)]}function ya(n,e){const[t,s,r]=Hs(n,e);return[q0(t,e&&e.currentContextId),s,r]}function q0(n,e){return e?`${n}-${e}`:n}function Hs(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const i=s[0],a=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[i,o,a]}return t&&e.parseNodeNameCache.set(n,r),r}function l0(n,e,t){let s=I("pad",n,e,t);if(s==="explicit"){s=I("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function ba(n){return n.kept?n:zi(n)}const yue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bue=Object.freeze(Object.defineProperty({__proto__:null,json:yue},Symbol.toStringTag,{value:"Module"}));const xue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wue=Object.freeze(Object.defineProperty({__proto__:null,json:xue},Symbol.toStringTag,{value:"Module"}));const vue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Sue=Object.freeze(Object.defineProperty({__proto__:null,json:vue},Symbol.toStringTag,{value:"Module"}));const Tue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Cue=Object.freeze(Object.defineProperty({__proto__:null,json:Tue},Symbol.toStringTag,{value:"Module"}));const Nue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],kue=Object.freeze(Object.defineProperty({__proto__:null,json:Nue},Symbol.toStringTag,{value:"Module"}));const Eue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Iue=Object.freeze(Object.defineProperty({__proto__:null,json:Eue},Symbol.toStringTag,{value:"Module"}));const $ue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_ue=Object.freeze(Object.defineProperty({__proto__:null,json:$ue},Symbol.toStringTag,{value:"Module"}));const Aue=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Rue=Object.freeze(Object.defineProperty({__proto__:null,json:Aue},Symbol.toStringTag,{value:"Module"}));const Due=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Oue=Object.freeze(Object.defineProperty({__proto__:null,json:Due},Symbol.toStringTag,{value:"Module"}));const Lue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Fue=Object.freeze(Object.defineProperty({__proto__:null,json:Lue},Symbol.toStringTag,{value:"Module"}));const Mue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],zue=Object.freeze(Object.defineProperty({__proto__:null,json:Mue},Symbol.toStringTag,{value:"Module"}));const Pue=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Bue=Object.freeze(Object.defineProperty({__proto__:null,json:Pue},Symbol.toStringTag,{value:"Module"}));const Vue=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Uue=Object.freeze(Object.defineProperty({__proto__:null,json:Vue},Symbol.toStringTag,{value:"Module"}));const jue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Wue=Object.freeze(Object.defineProperty({__proto__:null,json:jue},Symbol.toStringTag,{value:"Module"}));const Gue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Hue=Object.freeze(Object.defineProperty({__proto__:null,json:Gue},Symbol.toStringTag,{value:"Module"}));const que=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Kue=Object.freeze(Object.defineProperty({__proto__:null,json:que},Symbol.toStringTag,{value:"Module"}));const Xue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Yue=Object.freeze(Object.defineProperty({__proto__:null,json:Xue},Symbol.toStringTag,{value:"Module"}));const Jue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Zue=Object.freeze(Object.defineProperty({__proto__:null,json:Jue},Symbol.toStringTag,{value:"Module"}));const Que=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],ece=Object.freeze(Object.defineProperty({__proto__:null,json:Que},Symbol.toStringTag,{value:"Module"}));class f3{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[bue,wue,Sue,Cue,kue,Iue,_ue,Rue,Oue,Fue,zue,Bue,Uue,Wue,Hue,Kue,Yue,Zue,ece],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],a=[],o=s.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?r.push(x[w.name]):w.op==="Const"?i.push(x[w.name]):(w.input==null||w.input.length===0)&&a.push(x[w.name]),x),{});let l=[];const h=[];let d={},p={};t!=null&&(d=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));const m=Object.keys(o);m.forEach(x=>{const w=o[x];w.inputNames.forEach((v,C)=>{const[N,,k]=ya(v),E=o[N];if(E.outputs!=null){const A=E.outputs.indexOf(k);if(A!==-1){const R=`${N}:${A}`;w.inputNames[C]=R}}w.inputs.push(E),E.children.push(w)})}),Object.keys(p).length===0?m.forEach(x=>{const w=o[x];w.children.length===0&&h.push(w)}):Object.keys(p).forEach(x=>{const[w]=ya(x),v=o[w];v!=null&&(v.signatureKey=p[x],h.push(v))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{const[w]=ya(x),v=o[w];v&&(v.signatureKey=d[x],l.push(v))}):l=r;let y={};e.library!=null&&e.library.function!=null&&(y=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const b={nodes:o,inputs:l,outputs:h,weights:i,placeholders:r,signature:t,functions:y};return a.length>0&&(b.initNodes=a),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=aV(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const a=i.type;let o;switch(i.type){case"string":o=sC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=sC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=cC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=cC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=iC(e.attr,i.tfName,i.defaultValue||0),o===void 0&&i.tfDeprecatedName&&(o=iC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=uC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=uC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=rC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=rC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=dC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=dC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=lC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=lC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=hC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=hC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=aC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=aC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=oC(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=oC(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=p3(e.attr,i.tfName,i.defaultValue),o===void 0&&i.tfDeprecatedName&&(o=p3(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:o,type:a},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&r.push(p[m.name]),p),{}));const a=[],o=[];e.signature.inputArg.forEach(p=>{const[m]=ya(p.name),y={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:VE(p.type),type:"dtype"}},children:[]};y.signatureKey=p.name,a.push(y),i[m]=y}),Object.keys(i).forEach(p=>{const m=i[p];m.inputNames.forEach((y,b)=>{const[x,,w]=ya(y),v=i[x];if(v.outputs!=null){const C=v.outputs.indexOf(w);if(C!==-1){const N=`${x}:${C}`;m.inputNames[b]=N}}m.inputs.push(v),v.children.push(m)})});const h=e.ret;e.signature.outputArg.forEach(p=>{const[m,y]=ya(h[p.name]),b=i[m];b!=null&&(b.defaultOutput=y,o.push(b))});const d=this.mapArgsToSignature(e);return{nodes:i,inputs:a,outputs:o,weights:r,placeholders:s,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function tce(n){const e=ae().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function oV(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):tce(n);return e?t:t.toLowerCase()}function sC(n,e,t,s=!1){const r=n[e];return r!=null?oV(r.s,s):t}function rC(n,e,t){const s=n[e];return s?s.b:t}function iC(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function VE(n){switch(typeof n=="string"&&(n=Ws[n]),n){case Ws.DT_FLOAT:case Ws.DT_HALF:return"float32";case Ws.DT_INT32:case Ws.DT_INT64:case Ws.DT_INT8:case Ws.DT_UINT8:return"int32";case Ws.DT_BOOL:return"bool";case Ws.DT_DOUBLE:return"float32";case Ws.DT_STRING:return"string";case Ws.DT_COMPLEX64:case Ws.DT_COMPLEX128:return"complex64";default:return null}}function p3(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function aC(n,e,t){const s=n[e];return s&&s.type?VE(s.type):t}function oC(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>VE(r)):t}function lV(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function lC(n,e,t){const s=n[e];return s&&s.shape?lV(s.shape):t}function uC(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function cC(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>oV(i,s)):t}function hC(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>lV(r)):t}function dC(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class nce{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return qn(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return qn(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return iC(this.node.rawAttrs,e,t);if(s.s!=null)return sC(this.node.rawAttrs,e,t);if(s.b!=null)return rC(this.node.rawAttrs,e,t);if(s.shape!=null)return lC(this.node.rawAttrs,e,t);if(s.type!=null)return aC(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return uC(this.node.rawAttrs,e,t);if(s.list.s!=null)return cC(this.node.rawAttrs,e,t);if(s.list.shape!=null)return hC(this.node.rawAttrs,e,t);if(s.list.b!=null)return dC(this.node.rawAttrs,e,t);if(s.list.type!=null)return oC(this.node.rawAttrs,e,t)}return t}}const es=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:v2,abs:mn,acos:$2,acosh:_2,add:ve,addN:XM,all:kx,any:ip,argMax:Kl,argMin:A2,asin:R2,asinh:D2,atan:O2,atan2:L2,atanh:F2,avgPool:Im,avgPool3d:z2,basicLSTMCell:YM,batchNorm:Xh,batchNorm2d:P2,batchNorm3d:B2,batchNorm4d:V2,batchToSpaceND:$m,bincount:U2,bitwiseAnd:JM,booleanMaskAsync:Lz,broadcastArgs:ZM,broadcastTo:Vl,buffer:Qe,cast:Ne,ceil:j2,clipByValue:Rs,clone:zi,complex:Ea,concat:ln,concat1d:W2,concat2d:G2,concat3d:H2,concat4d:q2,conv1d:Ex,conv2d:Ia,conv2dTranspose:Ix,conv3d:X2,conv3dTranspose:Y2,cos:_m,cosh:$x,cosineWindow:Zx,cumprod:lp,cumsum:_x,denseBincount:F0,depthToSpace:J2,depthwiseConv2d:Yh,diag:ez,dilation2d:Z2,div:Le,divNoNan:Q2,dot:eN,dropout:IN,einsum:Il,elu:Jh,enclosingPowerOfTwo:$N,ensureShape:tz,equal:Ys,erf:Ax,euclideanNorm:nN,exp:Ds,expandDims:Hn,expm1:sN,eye:Rx,fft:jm,fill:du,floor:Qh,floorDiv:Nx,fused:Wz,gather:ed,gatherND:Pz,greater:vs,greaterEqual:Ma,ifft:Wc,imag:Am,image:jr,inTopKAsync:Bz,irfft:Hx,isFinite:rN,isInf:iN,isNaN:aN,leakyRelu:Rm,less:Bc,lessEqual:Wo,linalg:RN,linspace:rz,localResponseNormalization:oN,log:Js,log1p:Dm,logSigmoid:lN,logSoftmax:Ox,logSumExp:Om,logicalAnd:Hr,logicalNot:Lm,logicalOr:Lx,logicalXor:uN,losses:Jz,lowerBound:az,matMul:nt,max:Sr,maxPool:Fm,maxPool3d:cN,maxPoolWithArgmax:oz,maximum:qi,mean:Kt,meshgrid:lz,min:Pc,minimum:Do,mirrorPad:hN,mod:dN,moments:Mm,movingAverage:Fz,mul:q,multiRNNCell:uz,multinomial:cz,neg:Mt,norm:Zh,notEqual:Jl,oneHot:Vc,ones:Is,onesLike:Zs,op:G,outerProduct:hz,pad:za,pad1d:dz,pad2d:fz,pad3d:pz,pad4d:mz,pool:fN,pow:Wi,prelu:Pm,print:I2,prod:pN,raggedGather:gz,raggedRange:yz,raggedTensorToTensor:bz,rand:xz,randomGamma:Sz,randomNormal:Mx,randomStandardNormal:Tz,randomUniform:Go,randomUniformInt:Cz,range:Zl,real:Uc,reciprocal:bN,relu:vi,relu6:zx,reshape:Y,reverse:Tr,reverse1d:Nz,reverse2d:kz,reverse3d:Ez,reverse4d:Iz,rfft:Wm,round:Px,rsqrt:Bx,scalar:Pe,scatterND:Mz,searchSorted:Fx,selu:Vx,separableConv2d:Ux,setdiff1dAsync:$z,sigmoid:fi,sign:xN,signal:Yz,sin:jx,sinh:Wx,slice:ht,slice1d:Bm,slice2d:Gx,slice3d:Vm,slice4d:jc,softmax:Um,softplus:fu,spaceToBatchND:zm,sparse:Zz,sparseToDense:zz,spectral:Xz,split:$s,sqrt:Pn,square:It,squaredDifference:qx,squeeze:Ho,stack:bs,step:pu,stridedSlice:wN,string:Qz,sub:_e,sum:Re,tan:vN,tanh:Ro,tensor:Xs,tensor1d:Xn,tensor2d:To,tensor3d:SN,tensor4d:_z,tensor5d:Az,tensor6d:Rz,tensorScatterUpdate:Dz,tile:br,topk:CN,transpose:lt,truncatedNormal:Xx,unique:NN,unsortedSegmentSum:Yx,unstack:Cr,upperBound:Oz,variable:kN,where:Mn,whereAsync:EN,zeros:gn,zerosLike:dt},Symbol.toStringTag,{value:"Module"}));const sce=(n,e,t,s=es)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(I("a",n,e,t),I("b",n,e,t))];case"AddN":return[s.addN(I("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(I("a",n,e,t),I("b",n,e,t))];case"Mul":return[s.mul(I("a",n,e,t),I("b",n,e,t))];case"RealDiv":case"Div":return[s.div(I("a",n,e,t),I("b",n,e,t))];case"DivNoNan":return[s.divNoNan(I("a",n,e,t),I("b",n,e,t))];case"FloorDiv":return[s.floorDiv(I("a",n,e,t),I("b",n,e,t))];case"Sub":return[s.sub(I("a",n,e,t),I("b",n,e,t))];case"Minimum":return[s.minimum(I("a",n,e,t),I("b",n,e,t))];case"Maximum":return[s.maximum(I("a",n,e,t),I("b",n,e,t))];case"Pow":return[s.pow(I("a",n,e,t),I("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(I("a",n,e,t),I("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const rce=(n,e,t,s=es)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(I("x",n,e,t))];case"Acos":return[s.acos(I("x",n,e,t))];case"Acosh":return[s.acosh(I("x",n,e,t))];case"Asin":return[s.asin(I("x",n,e,t))];case"Asinh":return[s.asinh(I("x",n,e,t))];case"Atan":return[s.atan(I("x",n,e,t))];case"Atan2":return[s.atan2(I("x",n,e,t),I("y",n,e,t))];case"Atanh":return[s.atanh(I("x",n,e,t))];case"Ceil":return[s.ceil(I("x",n,e,t))];case"Complex":return[s.complex(I("real",n,e,t),I("imag",n,e,t))];case"Cos":return[s.cos(I("x",n,e,t))];case"Cosh":return[s.cosh(I("x",n,e,t))];case"Elu":return[s.elu(I("x",n,e,t))];case"Erf":return[s.erf(I("x",n,e,t))];case"Exp":return[s.exp(I("x",n,e,t))];case"Expm1":return[s.expm1(I("x",n,e,t))];case"Floor":return[s.floor(I("x",n,e,t))];case"Log":return[s.log(I("x",n,e,t))];case"Log1p":return[s.log1p(I("x",n,e,t))];case"Imag":return[s.imag(I("x",n,e,t))];case"Neg":return[s.neg(I("x",n,e,t))];case"Reciprocal":return[s.reciprocal(I("x",n,e,t))];case"Real":return[s.real(I("x",n,e,t))];case"Relu":return[s.relu(I("x",n,e,t))];case"Round":return[s.round(I("x",n,e,t))];case"Selu":return[s.selu(I("x",n,e,t))];case"Sigmoid":return[s.sigmoid(I("x",n,e,t))];case"Sin":return[s.sin(I("x",n,e,t))];case"Sign":return[s.sign(I("x",n,e,t))];case"Sinh":return[s.sinh(I("x",n,e,t))];case"Softplus":return[s.softplus(I("x",n,e,t))];case"Sqrt":return[s.sqrt(I("x",n,e,t))];case"Square":return[s.square(I("x",n,e,t))];case"Tanh":return[s.tanh(I("x",n,e,t))];case"Tan":return[s.tan(I("x",n,e,t))];case"ClipByValue":return[s.clipByValue(I("x",n,e,t),I("clipValueMin",n,e,t),I("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(I("x",n,e,t))];case"Rsqrt":return[s.rsqrt(qn(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(I("x",n,e,t),I("alpha",n,e,t))];case"Prelu":return[s.prelu(I("x",n,e,t),I("alpha",n,e,t))];case"IsNan":return[s.isNaN(qn(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(qn(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(qn(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Br(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){O(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];O(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function m3(n){return!(typeof n=="number"||n.some(e=>e<0))}function bf(n,e,t){let s=fC(n,t);const r=!m3(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=fC(i.shape,s)}),!m3(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function fC(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}class ice{constructor(e,t,s,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Pe(0),En(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Br(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,En(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Xs([],[0].concat(this.elementShape));const s=this.readMany(e);return Br(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),bs(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Xs([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Br(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ln(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Cr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,a=[];re(()=>{t=Y(t,[1,s,i]);for(let l=0;l<e.length;++l){const d=[0,l===0?0:r[l-1],0],p=[1,e[l],i];a[l]=Y(ht(t,d,p),this.elementShape)}return a});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,a)}}class nu{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);Br(t,i.shape,"TensorList shape mismatch: "),En(i)}),this.idTensor=Pe(0),this.maxNumElements=r,En(this.idTensor)}copy(){return new nu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Br(e,this.elementShape,"TensorList shape mismatch: ");const r=bf(this.elementShape,this.tensors,e);return re(()=>{const i=this.tensors.map(a=>Y(a,r));return bs(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=bf(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Br(r.shape,e,"TensorList shape mismatch: "),Y(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Br(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");En(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new nu([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Br(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=bf(this.elementShape,this.tensors,t);return Y(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Br(this.elementShape,t.shape,"TensorList shape mismatch: "),En(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Br(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=bf(this.elementShape,this.tensors,s);return e.length===0?Xs([],[0].concat(r)):re(()=>{const i=e.map(a=>Y(this.tensors[a],r));return bs(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Br(this.elementShape,t,"TensorList shape mismatch: ");const s=bf(this.elementShape,this.tensors,t);return this.size()===0?Xs([],[0].concat(s)):re(()=>{const r=this.tensors.map(i=>Y(i,s));return ln(r,0)})}}function ace(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Br(r,e,"TensorList shape mismatch: ");const i=Cr(n);return new nu(i,e,s)}function oce(n,e,t,s){return new nu([],n,e,s)}function lce(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new nu([],t,n.dtype,s),a=Cr(n,0);return e.forEach((o,l)=>{i.setItem(o,a[l])}),i}function uce(n,e,t){let s=0;const r=e.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),a=fC(i,t),o=s===0?0:n.size/s,l=re(()=>{const d=[];n=Y(n,[1,s,o]);for(let p=0;p<e.length;++p){const y=[0,p===0?0:r[p-1],0],b=[1,e[p],o];d[p]=Y(ht(n,y,b),a)}return n.dispose(),d}),h=new nu([],t,n.dtype,e.length);for(let d=0;d<l.length;d++)h.setItem(d,l[d]);return h}const cce=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=I("thenBranch",n,e,t),r=I("elseBranch",n,e,t),i=I("cond",n,e,t),a=I("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=I("body",n,e,t),r=I("cond",n,e,t),i=I("args",n,e,t),a=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),o=i.map(d=>d.id);let l=await a[0].data();a.forEach(d=>{!d.kept&&o.indexOf(d.id)===-1&&d.dispose()});let h=i;for(;l[0];){const d=h;h=await t.functionMap[s].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);const p=h.map(y=>y.id);d.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&p.indexOf(y.id)===-1&&y.dispose()});const m=await t.functionMap[r].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);l=await m[0].data(),m.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&p.indexOf(y.id)===-1&&y.dispose()})}return h}case"LoopCond":{const s=I("pred",n,e,t);return[ba(s)]}case"Switch":{const s=I("pred",n,e,t);let r=I("data",n,e,t);return r.kept||(r=ba(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>qn(r,e,t)!==void 0);if(s){const r=qn(s,e,t);return[ba(r)]}return}case"Enter":{const s=I("frameName",n,e,t),r=I("tensor",n,e,t);return t.enterFrame(s),[ba(r)]}case"Exit":{const s=I("tensor",n,e,t);return t.exitFrame(),[ba(s)]}case"NextIteration":{const s=I("tensor",n,e,t);return t.nextIteration(),[ba(s)]}case"TensorArrayV3":{const s=I("size",n,e,t),r=I("dtype",n,e,t),i=I("elementShape",n,e,t),a=I("dynamicSize",n,e,t),o=I("clearAfterRead",n,e,t),l=I("identicalElementShapes",n,e,t),h=I("name",n,e,t),d=new ice(h,r,s,i,l,a,o);return t.addTensorArray(d),[d.idTensor,Pe(1)]}case"TensorArrayWriteV3":{const s=I("tensorArrayId",n,e,t),r=I("index",n,e,t),i=I("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(r,i),[a.idTensor]}case"TensorArrayReadV3":{const s=I("tensorArrayId",n,e,t),r=I("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=I("tensorArrayId",n,e,t),r=I("indices",n,e,t),i=I("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=I("tensorArrayId",n,e,t),r=I("indices",n,e,t),i=I("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(r,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=I("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=I("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=I("tensorArrayId",n,e,t),r=I("tensor",n,e,t),i=I("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(i,r),[a.idTensor]}case"TensorArraySizeV3":{const s=I("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Pe(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=I("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=I("tensorListId",n,e,t),r=I("index",n,e,t),i=I("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(r,i),[a.idTensor]}case"TensorListGetItem":{const s=I("tensorListId",n,e,t),r=I("index",n,e,t),i=I("elementShape",n,e,t),a=I("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=I("indices",n,e,t),r=I("tensor",n,e,t),i=I("elementShape",n,e,t),a=I("numElements",n,e,t),o=lce(r,s,i,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=I("elementShape",n,e,t),r=I("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const a=I(i,n,e,t),o=n.op==="TensorListReserve"?-1:a,l=oce(s,r,a,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=I("tensorListId",n,e,t),r=I("indices",n,e,t),i=I("elementShape",n,e,t),a=I("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,a,i)]}case"TensorListStack":{const s=I("tensorListId",n,e,t),r=I("elementShape",n,e,t),i=I("elementDType",n,e,t),a=I("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,a)]}case"TensorListFromTensor":{const s=I("tensor",n,e,t),r=I("elementShape",n,e,t),i=I("elementDType",n,e,t),a=ace(s,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=I("tensorListId",n,e,t),r=t.getTensorList(s.id),i=I("dtype",n,e,t),a=I("elementShape",n,e,t);return[r.concat(i,a)]}case"TensorListPushBack":{const s=I("tensorListId",n,e,t),r=I("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=I("tensorListId",n,e,t),r=I("elementShape",n,e,t),i=I("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=I("tensor",n,e,t),r=I("elementShape",n,e,t),i=I("lengths",n,e,t),a=uce(s,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=I("tensorListId",n,e,t),r=t.getTensorList(s.id);return[Pe(r.size(),"int32")]}case"TensorListResize":{const s=I("tensorListId",n,e,t),r=I("size",n,e,t),a=t.getTensorList(s.id).resize(r);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function g3(n,e,t){const[s,r]=I("fusedOps",n,e,t),i=s==="biasadd",a=!i,o=r==="prelu",l=s==="fusedbatchnorm",h=I("numArgs",n,e,t);if(i){if(o&&h!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&h!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=I("strides",n,e,t),p=l0(n,e,t),m=I("dataFormat",n,e,t).toUpperCase(),y=I("dilations",n,e,t);let[b,x]=I("args",n,e,t);a&&(x=b,b=void 0);const w=I("leakyreluAlpha",n,e,t);return{stride:d,pad:p,dataFormat:m,dilations:y,biasArg:b,preluArg:x,activationFunc:r,leakyreluAlpha:w}}const hce=(n,e,t,s=es)=>{switch(n.op){case"Conv1D":{const r=I("stride",n,e,t),i=I("pad",n,e,t),a=I("dataFormat",n,e,t).toUpperCase(),o=I("dilation",n,e,t);return[s.conv1d(I("x",n,e,t),I("filter",n,e,t),r,i,a,o)]}case"Conv2D":{const r=I("strides",n,e,t),i=l0(n,e,t),a=I("dataFormat",n,e,t).toUpperCase(),o=I("dilations",n,e,t);return[s.conv2d(I("x",n,e,t),I("filter",n,e,t),[r[1],r[2]],i,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:l,preluArg:h,activationFunc:d,leakyreluAlpha:p}=g3(n,e,t);return[s.fused.conv2d({x:I("x",n,e,t),filter:I("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:h,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:i,dataFormat:a,dilations:o,biasArg:l,preluArg:h,activationFunc:d,leakyreluAlpha:p}=g3(n,e,t);return[s.fused.depthwiseConv2d({x:I("x",n,e,t),filter:I("filter",n,e,t),strides:[r[1],r[2]],pad:i,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:h,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=I("outputShape",n,e,t),i=I("strides",n,e,t),a=l0(n,e,t);return[s.conv2dTranspose(I("x",n,e,t),I("filter",n,e,t),r,[i[1],i[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=I("strides",n,e,t),i=l0(n,e,t),a=I("dilations",n,e,t),o=I("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(I("input",n,e,t),I("filter",n,e,t),[r[1],r[2]],i,o,[a[1],a[2]])]}case"Conv3D":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("dataFormat",n,e,t).toUpperCase(),o=I("dilations",n,e,t);return[s.conv3d(I("x",n,e,t),I("filter",n,e,t),[r[1],r[2],r[3]],i,a,[o[1],o[2],o[3]])]}case"AvgPool":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("kernelSize",n,e,t);return[s.avgPool(I("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPool":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("kernelSize",n,e,t);return[s.maxPool(I("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i)]}case"MaxPoolWithArgmax":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("kernelSize",n,e,t),o=I("includeBatchInIndex",n,e,t),{result:l,indexes:h}=s.maxPoolWithArgmax(I("x",n,e,t),[a[1],a[2]],[r[1],r[2]],i,o);return[l,h]}case"AvgPool3D":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("kernelSize",n,e,t);return[s.avgPool3d(I("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"MaxPool3D":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("kernelSize",n,e,t);return[s.maxPool3d(I("x",n,e,t),[a[1],a[2],a[3]],[r[1],r[2],r[3]],i)]}case"Dilation2D":{const r=I("strides",n,e,t),i=I("pad",n,e,t),a=I("dilations",n,e,t),o=r[1],l=r[2],h=a[1],d=a[2];return[s.dilation2d(I("x",n,e,t),I("filter",n,e,t),[o,l],i,[h,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const dce=(n,e,t,s=es)=>{switch(n.op){case"Fill":{const r=I("shape",n,e,t),i=I("dtype",n,e,t),a=I("value",n,e,t);return[s.fill(r,a,i)]}case"LinSpace":{const r=I("start",n,e,t),i=I("stop",n,e,t),a=I("num",n,e,t);return[s.linspace(r,i,a)]}case"Multinomial":{const r=I("logits",n,e,t),i=I("numSamples",n,e,t),a=I("seed",n,e,t);return[s.multinomial(r,i,a)]}case"OneHot":{const r=I("indices",n,e,t),i=I("depth",n,e,t),a=I("onValue",n,e,t),o=I("offValue",n,e,t),l=I("dtype",n,e,t);return[s.oneHot(r,i,a,o,l)]}case"Ones":return[s.ones(I("shape",n,e,t),I("dtype",n,e,t))];case"OnesLike":return[s.onesLike(I("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(I("shape",n,e,t),I("dtype",n,e,t),I("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(I("shape",n,e,t),I("minval",n,e,t),I("maxval",n,e,t),I("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt(I("shape",n,e,t),I("minval",n,e,t),I("maxval",n,e,t),I("seed",n,e,t))];case"Range":{const r=I("start",n,e,t),i=I("stop",n,e,t),a=I("step",n,e,t);return[s.range(r,i,a,I("dtype",n,e,t))]}case"TruncatedNormal":{const r=I("shape",n,e,t),i=I("mean",n,e,t),a=I("stdDev",n,e,t),o=I("seed",n,e,t);return[s.truncatedNormal(r,i,a,I("dtype",n,e,t),o)]}case"Zeros":return[s.zeros(I("shape",n,e,t),I("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(I("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function jS(n,e,t){const s=I("boxes",n,e,t),r=I("scores",n,e,t),i=I("maxOutputSize",n,e,t),a=I("iouThreshold",n,e,t),o=I("scoreThreshold",n,e,t),l=I("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}}const fce=async(n,e,t,s,r=es)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:h,softNmsSigma:d}=jS(n,e,t),p=await r.image.nonMaxSuppressionWithScoreAsync(i,a,o,l,h,d);return[p.selectedIndices,p.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:h}=jS(n,e,t),d=I("padToMaxOutputSize",n,e,t),p=await r.image.nonMaxSuppressionPaddedAsync(i,a,o,l,h,d);return[p.selectedIndices,p.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:h}=jS(n,e,t);return[await r.image.nonMaxSuppressionAsync(i,a,o,l,h)]}case"Where":{const i=r.cast(I("condition",n,e,t),"bool"),a=[await r.whereAsync(i)];return i.dispose(),a}case"ListDiff":return r.setdiff1dAsync(I("x",n,e,t),I("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const pce=(n,e,t,s=es)=>{switch(n.op){case"LowerBound":{const r=I("sortedSequence",n,e,t),i=I("values",n,e,t);return[s.lowerBound(r,i)]}case"TopKV2":{const r=I("x",n,e,t),i=I("k",n,e,t),a=I("sorted",n,e,t),o=s.topk(r,i,a);return[o.values,o.indices]}case"UpperBound":{const r=I("sortedSequence",n,e,t),i=I("values",n,e,t);return[s.upperBound(r,i)]}case"Unique":{const r=I("x",n,e,t),i=s.unique(r);return[i.values,i.indices]}case"UniqueV2":{const r=I("x",n,e,t),i=I("axis",n,e,t),a=s.unique(r,i);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const mce=(n,e,t,s=es)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=I("default",n,e,t);return[qn(n.name,e,t)||r];case"Placeholder":return[qn(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=I("x",n,e,t);return[ba(d)]}case"IdentityN":return I("x",n,e,t).map(d=>ba(d));case"Snapshot":const i=I("x",n,e,t);return[ba(i)];case"Shape":return[s.tensor1d(I("x",n,e,t).shape,"int32")];case"ShapeN":return I("x",n,e,t).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar(I("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(I("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=I("x",n,e,t),o=I("data",n,e,t),l=I("message",n,e,t),h=I("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,h));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class gce{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Pe(0),this.tensorMap=new Map,En(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Pe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),re(()=>{const r=Cr(t),i=s.length,a=r.length;O(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){const l=s[o],h=r[o];En(h),this.tensorMap.set(l,h)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return re(()=>{const r=[];for(let i=0;i<s.length;i++){const a=s[i],o=this.findWithDefault(a,t);r.push(o)}return bs(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const yce=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const i=I("keyDType",n,e,t),a=I("valueDType",n,e,t),o=new gce(i,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=I("tableHandle",n,e,t,s),i=I("keys",n,e,t),a=I("values",n,e,t);return[await s.getHashTableById(r.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const r=I("tableHandle",n,e,t,s),i=I("keys",n,e,t),a=I("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=I("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const bce=(n,e,t,s=es)=>{switch(n.op){case"ResizeBilinear":{const r=I("images",n,e,t),i=I("size",n,e,t),a=I("alignCorners",n,e,t),o=I("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[i[0],i[1]],a,o)]}case"ResizeNearestNeighbor":{const r=I("images",n,e,t),i=I("size",n,e,t),a=I("alignCorners",n,e,t),o=I("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[i[0],i[1]],a,o)]}case"CropAndResize":{const r=I("image",n,e,t),i=I("boxes",n,e,t),a=I("boxInd",n,e,t),o=I("cropSize",n,e,t),l=I("method",n,e,t),h=I("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,i,a,o,l,h)]}case"ImageProjectiveTransformV3":{const r=I("images",n,e,t),i=I("transforms",n,e,t),a=I("outputShape",n,e,t),o=I("fillValue",n,e,t),l=I("interpolation",n,e,t),h=I("fillMode",n,e,t);return[s.image.transform(r,i,l.toLowerCase(),h.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const xce=(n,e,t,s=es)=>{switch(n.op){case"Equal":return[s.equal(I("a",n,e,t),I("b",n,e,t))];case"NotEqual":return[s.notEqual(I("a",n,e,t),I("b",n,e,t))];case"Greater":return[s.greater(I("a",n,e,t),I("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(I("a",n,e,t),I("b",n,e,t))];case"Less":return[s.less(I("a",n,e,t),I("b",n,e,t))];case"LessEqual":return[s.lessEqual(I("a",n,e,t),I("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(I("a",n,e,t),I("b",n,e,t))];case"LogicalNot":return[s.logicalNot(I("a",n,e,t))];case"LogicalOr":return[s.logicalOr(I("a",n,e,t),I("b",n,e,t))];case"Select":case"SelectV2":return[s.where(I("condition",n,e,t),I("a",n,e,t),I("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(I("a",n,e,t),I("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const wce=(n,e,t,s=es)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(I("a",n,e,t),I("b",n,e,t),I("transposeA",n,e,t),I("transposeB",n,e,t))];case"Einsum":return[s.einsum(I("equation",n,e,t),...I("tensors",n,e,t))];case"Transpose":return[s.transpose(I("x",n,e,t),I("perm",n,e,t))];case"_FusedMatMul":const[r,i]=I("fusedOps",n,e,t),a=r==="biasadd",o=i==="prelu",l=I("numArgs",n,e,t),h=I("leakyreluAlpha",n,e,t);if(a){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,p]=I("args",n,e,t);return[s.fused.matMul({a:I("a",n,e,t),b:I("b",n,e,t),transposeA:I("transposeA",n,e,t),transposeB:I("transposeB",n,e,t),bias:d,activation:i,preluActivationWeights:p,leakyreluAlpha:h})];case"MatrixBandPart":return[s.linalg.bandPart(I("a",n,e,t),I("numLower",n,e,t),I("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const vce=(n,e,t,s=es)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(I("x",n,e,t),I("axis",n,e,t),I("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(I("x",n,e,t),I("mean",n,e,t),I("variance",n,e,t),I("offset",n,e,t),I("scale",n,e,t),I("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(I("x",n,e,t),I("mean",n,e,t),I("variance",n,e,t),I("offset",n,e,t),I("scale",n,e,t),I("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(I("x",n,e,t),I("radius",n,e,t),I("bias",n,e,t),I("alpha",n,e,t),I("beta",n,e,t))];case"Softmax":return[s.softmax(I("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(I("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Sce=(n,e,t,s=es)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:i}=s.raggedGather(I("paramsNestedSplits",n,e,t),I("paramsDenseValues",n,e,t),I("indices",n,e,t),I("outputRaggedRank",n,e,t));return r.concat(i)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:i}=s.raggedRange(I("starts",n,e,t),I("limits",n,e,t),I("splits",n,e,t));return[r,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(I("shape",n,e,t),I("values",n,e,t),I("defaultValue",n,e,t),I("rowPartitionTensors",n,e,t),I("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Tce=(n,e,t,s=es)=>{switch(n.op){case"Max":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.max(I("x",n,e,t),o,l)]}case"Mean":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.mean(I("x",n,e,t),o,l)]}case"Min":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.min(I("x",n,e,t),o,l)]}case"Sum":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.sum(I("x",n,e,t),o,l)]}case"All":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.all(I("x",n,e,t),o,l)]}case"Any":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.any(I("x",n,e,t),o,l)]}case"ArgMax":{const o=I("axis",n,e,t);return[s.argMax(I("x",n,e,t),o)]}case"ArgMin":{const o=I("axis",n,e,t);return[s.argMin(I("x",n,e,t),o)]}case"Prod":{const o=I("axis",n,e,t),l=I("keepDims",n,e,t);return[s.prod(I("x",n,e,t),o,l)]}case"Cumprod":{const o=I("axis",n,e,t),l=I("exclusive",n,e,t),h=I("reverse",n,e,t);return[s.cumprod(I("x",n,e,t),o,l,h)]}case"Cumsum":{const o=I("axis",n,e,t),l=I("exclusive",n,e,t),h=I("reverse",n,e,t);return[s.cumsum(I("x",n,e,t),o,l,h)]}case"Bincount":const r=I("x",n,e,t),i=I("weights",n,e,t),a=I("size",n,e,t);return[s.bincount(r,i,a)];case"DenseBincount":{const o=I("x",n,e,t),l=I("weights",n,e,t),h=I("size",n,e,t),d=I("binaryOutput",n,e,t);return[s.denseBincount(o,l,h,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Cce=(n,e,t,s=es)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=I("n",n,e,t),i=I("axis",n,e,t);let a=I("tensors",n,e,t);return a=a.slice(0,r),[s.concat(a,i)]}case"Gather":{const r=I("x",n,e,t),i=I("indices",n,e,t);return[s.gather(r,s.cast(i,"int32"),0)]}case"GatherV2":{const r=I("axis",n,e,t),i=I("batchDims",n,e,t),a=I("x",n,e,t),o=I("indices",n,e,t);return[s.gather(a,s.cast(o,"int32"),r,i)]}case"Reverse":{const r=I("dims",n,e,t),i=[];for(let o=0;o<r.length;o++)r[o]&&i.push(o);const a=I("x",n,e,t);return[s.reverse(a,i)]}case"ReverseV2":{const r=I("axis",n,e,t),i=I("x",n,e,t);return[s.reverse(i,r)]}case"Slice":{const r=I("begin",n,e,t),i=I("size",n,e,t);return[s.slice(I("x",n,e,t),r,i)]}case"StridedSlice":{const r=I("begin",n,e,t),i=I("end",n,e,t),a=I("strides",n,e,t),o=I("beginMask",n,e,t),l=I("endMask",n,e,t),h=I("ellipsisMask",n,e,t),d=I("newAxisMask",n,e,t),p=I("shrinkAxisMask",n,e,t),m=I("x",n,e,t);return[s.stridedSlice(m,r,i,a,o,l,h,d,p)]}case"Pack":return re(()=>{const r=I("axis",n,e,t),i=I("tensors",n,e,t),a=i[0].shape,o=s.squeeze(i[0]).shape,l=i.map(h=>{const d=at(h.shape,a);if(!d&&!at(s.squeeze(h).shape,o))throw new Error("the input tensors shape does not match");return d?h:s.reshape(h,a)});return[s.stack(l,r)]});case"Unpack":{const r=I("axis",n,e,t),i=I("tensor",n,e,t);return s.unstack(i,r)}case"Tile":{const r=I("reps",n,e,t);return[s.tile(I("x",n,e,t),r)]}case"Split":case"SplitV":{const r=I("axis",n,e,t),i=I("numOrSizeSplits",n,e,t),a=I("x",n,e,t);return s.split(a,i,r)}case"ScatterNd":{const r=I("indices",n,e,t),i=I("values",n,e,t),a=I("shape",n,e,t);return[s.scatterND(r,i,a)]}case"GatherNd":{const r=I("x",n,e,t),i=I("indices",n,e,t);return[s.gatherND(r,i)]}case"SparseToDense":{const r=I("sparseIndices",n,e,t),i=I("outputShape",n,e,t),a=I("sparseValues",n,e,t),o=I("defaultValue",n,e,t);return[s.sparseToDense(r,a,i,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}case"TensorScatterUpdate":{const r=I("indices",n,e,t),i=I("values",n,e,t),a=I("tensor",n,e,t);return[s.tensorScatterUpdate(a,r,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Nce=(n,e,t,s=es)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:i,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(I("indices",n,e,t),I("values",n,e,t),I("denseShape",n,e,t),I("defaultValue",n,e,t));return[r,i,a,o]}case"SparseReshape":{const{outputIndices:r,outputShape:i}=s.sparse.sparseReshape(I("inputIndices",n,e,t),I("inputShape",n,e,t),I("newShape",n,e,t));return[r,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(I("data",n,e,t),I("indices",n,e,t),I("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(I("data",n,e,t),I("indices",n,e,t),I("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const kce=(n,e,t,s=es)=>{switch(n.op){case"FFT":return[s.fft(I("x",n,e,t))];case"IFFT":return[s.ifft(I("x",n,e,t))];case"RFFT":return[s.rfft(I("x",n,e,t))];case"IRFFT":return[s.irfft(I("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Ece=(n,e,t,s=es)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(I("input",n,e,t),I("pattern",n,e,t),I("rewrite",n,e,t),I("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:i}=s.string.stringNGrams(I("data",n,e,t),I("dataSplits",n,e,t),I("separator",n,e,t),I("nGramWidths",n,e,t),I("leftPad",n,e,t),I("rightPad",n,e,t),I("padWidth",n,e,t),I("preserveShortSequences",n,e,t));return[r,i]}case"StringSplit":{const{indices:r,values:i,shape:a}=s.string.stringSplit(I("input",n,e,t),I("delimiter",n,e,t),I("skipEmpty",n,e,t));return[r,i,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(I("input",n,e,t),I("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Ice=(n,e,t,s=es)=>{switch(n.op){case"Cast":return[s.cast(I("x",n,e,t),I("dtype",n,e,t))];case"ExpandDims":{const r=I("axis",n,e,t);return[s.expandDims(I("x",n,e,t),r)]}case"Squeeze":{const r=I("axis",n,e,t);return[s.squeeze(I("x",n,e,t),r)]}case"Reshape":return[s.reshape(I("x",n,e,t),I("shape",n,e,t))];case"EnsureShape":return[s.ensureShape(I("x",n,e,t),I("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(I("x",n,e,t),I("padding",n,e,t),I("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(I("x",n,e,t),I("padding",n,e,t),I("constantValue",n,e,t))];case"SpaceToBatchND":{const r=I("blockShape",n,e,t),i=I("paddings",n,e,t);return[s.spaceToBatchND(I("x",n,e,t),r,i)]}case"BatchToSpaceND":{const r=I("blockShape",n,e,t),i=I("crops",n,e,t);return[s.batchToSpaceND(I("x",n,e,t),r,i)]}case"DepthToSpace":{const r=I("blockSize",n,e,t),i=I("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(I("x",n,e,t),r,i)]}case"BroadcastTo":return[s.broadcastTo(I("x",n,e,t),I("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(I("s0",n,e,t),I("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function y3(n,e,t,s,r=re){const i=((a,o,l)=>{switch(a.category){case"arithmetic":return r(()=>sce(a,o,l));case"basic_math":return r(()=>rce(a,o,l));case"control":return cce(a,o,l);case"convolution":return r(()=>hce(a,o,l));case"creation":return r(()=>dce(a,o,l));case"dynamic":return fce(a,o,l);case"evaluation":return r(()=>pce(a,o,l));case"image":return r(()=>bce(a,o,l));case"graph":return r(()=>mce(a,o,l));case"logical":return r(()=>xce(a,o,l));case"matrices":return r(()=>wce(a,o,l));case"normalization":return r(()=>vce(a,o,l));case"ragged":return r(()=>Sce(a,o,l));case"reduction":return r(()=>Tce(a,o,l));case"slice_join":return r(()=>Cce(a,o,l));case"sparse":return r(()=>Nce(a,o,l));case"spectral":return r(()=>kce(a,o,l));case"string":return r(()=>Ece(a,o,l));case"transformation":return r(()=>Ice(a,o,l));case"hash_table":return yce(a,o,l,s);case"custom":const h=aV(a.op);if(h&&h.customExecutor)return h.customExecutor(new nce(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Ca(i)?i.then(a=>[].concat(a)):[].concat(i)}class b3{constructor(e={},t={},s={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function x3(n,e,t,s){const r=new Set,i=[];let a=null,o=null;const l=new Set,h=new Set(Object.keys(n).map(m=>Hs(m)[0]));s=s||[];const d=new Set(s.map(m=>Hs(m.name)[0])),p=[...e];for(;p.length>0;){const m=p.pop();if((_l(m)||Fce(m)||Mce(m))&&a==null&&(a=m,o=a.children.map(y=>y.name).filter(y=>r.has(y))),r.add(m.name),t[m.name]==null&&!h.has(m.name)&&!d.has(m.name)){if(m.inputs.length===0){i.push(m.name);continue}m.inputs.forEach(y=>{l.has(y.name)||(l.add(y.name),p.push(y))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:a,syncInputs:o}}function $ce(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(w=>Hs(w)[0]).map(w=>n.nodes[w]),i=n.initNodes||[],a=w=>t.has(typeof w=="string"?w:w.name);function o(w){return[...new Map(w.map(v=>[v.name,v])).values()]}const l=o([...r,...n.weights,...i]).filter(a),h=o([...l,...Object.values(n.nodes)]).filter(a),d=new Map(h.map(w=>[w.name,w])),p={};for(const w of h){p[w.name]=p[w.name]||0;for(const v of w.children)a(v)||(p[v.name]=Number.POSITIVE_INFINITY),p[v.name]=(p[v.name]||0)+1}const m=Object.entries(p).filter(([,w])=>w===0).map(([w])=>w),y=[...m];for(;m.length>0;){const w=m.pop(),v=d.get(w);for(const C of v.children.filter(a))--p[C.name]===0&&(y.push(C.name),m.push(C.name))}const b=y.map(w=>d.get(w)),x=_ce(b,l);return Ace(x,l),x}function _ce(n,e){const t=new Map(n.map(a=>[a.name,a])),s=e.map(a=>a.name),r=new Set(s);for(;s.length>0;){const a=s.pop(),o=t.get(a);for(const l of o.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(a=>r.has(a.name))}class Vy extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Ace(n,e){const t=new Map(n.map((o,l)=>[o.name,l])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),i=new Set(n.map(o=>o.name)),a=o=>i.has(typeof o=="string"?o:o.name);for(const o of n){for(const l of o.children.filter(a)){if(!t.has(l.name))throw new Vy(`Child ${l.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(l.name))throw new Vy(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(const l of o.inputs){if(!t.has(l.name))throw new Vy(`Input ${l.name} of node ${o.name} is unreachable.`);if(t.get(l.name)>t.get(o.name))throw new Vy(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function Rce(n){const e=new Map(n.map((o,l)=>[o.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((o,l)=>_l(o)?t:l),r=o=>{const l=s[e.get(o.name)];return l??-1},i=n.map((o,l)=>o.children.map(r).reduce((h,d)=>Math.max(h,d),s[l])),a=new Map;for(let o=0;o<n.length;++o){const l=i[o];if(l===t)continue;const h=n[o],d=n[l];a.has(d.name)||a.set(d.name,[]),a.get(d.name).push(h)}return a}const Dce=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Oce=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Lce=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function _l(n){return Dce.has(n.op)}function Fce(n){return Oce.has(n.op)}function Mce(n){return Lce.has(n.op)}class K0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new K0(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=x3(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:a}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const h=t.map(p=>p.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=$ce(this.graph,s),l=Rce(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return En(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(m=>this.graph.nodes[Hs(m)[0]]),i=t.map(m=>Hs(m)[0]),a=new Set(i);let o=i.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(r,o);let h=this.compiledMap.get(l);h==null&&(h=this.compile(e,o),this.compiledMap.set(l,h));try{this.keepIntermediateTensors=ae().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const d={},p={};return re(()=>{const m=new b3(this.weightMap,d,p,this.functionExecutorMap,this.parseNodeNameCache),y=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(v=>{const[C,N]=Hs(v,m),k=[];k[N]=e[v],y[C]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[C]=this.cloneTensorList(k))});const b=this.getFrozenTensorIds(y),{orderedNodes:x,nodeLiveUntilMap:w}=h;for(const v of x){if(y[v.name])continue;const C=y3(v,y,m,this._resourceManager);if(Ca(C))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);y[v.name]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(C)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,y,m,b,a,w.get(v.name))}return this.parent==null&&m.dispose(b),t.map(v=>qn(v,y,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,a,o){if(!(_l(t)||a.has(e))){for(const l of s[e])l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length);for(const l of t.inputs){if(_l(l))continue;const h=d3(l.name,s,r);if(h!=null)for(const d of h){if(!d||d.kept||i.has(d.id))continue;const p=o[d.id];p===1?(d.dispose(),delete o[d.id]):p!=null&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,i,a){function o(l){return _l(l)||i.has(l.name)}if(!(_l(e)||a==null))for(const l of a){if(o(l))continue;const h=d3(l.name,t,s);for(const d of h)!d||d.kept||r.has(d.id)||d.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ae().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const a=new b3(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,s),l=t.map(m=>qn(m,o,a)),h=l.map(m=>m.id),d=Object.keys(e).map(m=>e[m].id),p=new Set([...h,...d,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(y=>{y&&!y.isDisposed&&!p.has(y.id)&&y.dispose()})}),this.parent==null&&a.dispose(p),l}async executeFunctionAsync(e,t,s){const r=e.reduce((i,a,o)=>(i[this.inputs[o].name]=a,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),a=i.map(k=>this.graph.nodes[Hs(k)[0]]),o=s.map(k=>Hs(k)[0]),l=new Set(o);let h=o.map(k=>this.graph.nodes[k]);h.length===0&&(h=this._outputs);const{usedNodes:d,missingInputs:p,dynamicNode:m,syncInputs:y}=x3(e,h,this.weightMap,this._initNodes),b=[...a,...this.graph.weights,...this._initNodes||[]].map(k=>({node:k,contexts:t.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(k=>{const[E,A]=Hs(k),R=[];R[A]=e[k],x[E]=R});const w={},v=this.getFrozenTensorIds(x),C={};for(;b.length>0;){const k=this.processStack(a,b,t,x,C,v,l,w,d);await Promise.all(k)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=h.filter(k=>!_l(k)&&!qn(k.name,x,t)).map(k=>k.name);if(N.length>0){let k="";throw m!=null&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${y}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${i}]. Consider providing the following inputs: [${p}]. ${k}`)}return x}processStack(e,t,s,r,i,a,o,l,h){const d=[];for(;t.length>0;){const p=t.pop();s.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&I("isConstant",p.node,r,s)&&([m]=ya(p.node.name,s)),r[p.node.name]==null){const y=y3(p.node,r,s,this._resourceManager);m||([m]=ya(p.node.name,s));const b=s.currentContext;Ca(y)?d.push(y.then(x=>(r[m]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(x)),s.currentContext=b,this.checkTensorForDisposal(m,p.node,r,s,a,o,l),this.processChildNodes(p.node,t,s,r,i,h),x))):(r[m]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(y)),this.checkTensorForDisposal(m,p.node,r,s,a,o,l),this.processChildNodes(p.node,t,s,r,i,h))}else this.processChildNodes(p.node,t,s,r,i,h)}return d}processChildNodes(e,t,s,r,i,a){e.children.forEach(o=>{const[l]=ya(o.name,s);i[l]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(h=>!!qn(h,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(h=>!!qn(h,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Hs(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const a=i.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((l,h)=>a[h]===-1||a[h]===l);O(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&O(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const i in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];a!=null?r[a.name]=e[i]:r[i]=e[i]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Hs(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const i=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Hs(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class zce{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Pce="?tfjs-format=file",Bce="model.json";class UE{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=ow){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new zce}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ca(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await MM(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new K0(f3.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=f3.Instance.transformGraph(e.modelInitializer);this.initializer=new K0(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof bt?[e]:e,s={};return t.forEach((r,i)=>s[this.structuredOutputKeys[i]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof bt)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const a in i){const o=i[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((i,a)=>{var o,l,h;const d=(h=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[a])===null||h===void 0?void 0:h.resourceId;return d!=null?i[a]=this.resourceIdToCapturedInput[d]:i[a]=e[r++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const i=s[r],a=t[i];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ke(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Vce(n,e={},t=ow){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=jce(n));const s=new UE(n,e,t);return await s.load(),s}function Uce(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,r]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const i=L0(s.weightsManifest),a=k2(s,i,r);e=M0(a)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=M0(n);else throw new Error("Unknown model format");const t=new UE(e);return t.load(),t}function jce(n){return n.endsWith("/")||(n=n+"/"),`${n}${Bce}${Pce}`}const uV="4.22.0";function Wce(n,e){return X0(n,e)}function X0(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(qc(n)){const i=Array.isArray(n)?[]:{};s.add(n);for(const a in n){const o=n[a],l=X0(o,e,t,s);i[a]=l}return s.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function Gce(n,e=hV){return cV(n,e)}function cV(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(qc(s)){const i=Array.isArray(s)?[]:{};t.add(s);for(const a in s){const o=n.map(h=>h[a]),l=cV(o,e,t);i[a]=l}return t.delete(s),i}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function hV(n){return n===null?null:qc(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function dV(n,e){const t=new Map;X0(n,e,t);for(const r of Array.from(t.keys())){const i=t.get(r);if(Ca(i)){const a=await i;t.set(r,a)}}return X0(n,e,t)}function qc(n){let e=!1;if(ae().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof bt)&&!(n instanceof Promise)&&!e)}function Hce(n){return n==null||qce(n)||Array.isArray(n)||typeof n=="object"&&n instanceof bt||kn(n)}function qce(n){return n===null||typeof n!="object"&&typeof n!="function"}function Kce(n){return Wce(n,Xce)}function Xce(n){return n instanceof bt?{value:n.clone(),recurse:!1}:qc(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class fV{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}class Dw extends fV{constructor(){super(Dw.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let r=0;r<s;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Dw.INITIAL_CAPACITY=32;function pV(n){return new Zce(n)}function jE(n){return new Qce(n)}function Yce(n,e){return new mV(n,e)}function Jce(n,e=wo.FAIL){return new lhe(n,e)}class Bn{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new ahe(this,e)}filter(e){return new rhe(this,e)}map(e){return new ihe(this,e)}mapAsync(e){return new w3(this,e)}serialMapAsync(e){return new w3(this,e).serial()}flatmap(e){return new ohe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new she(this,e,t)}columnMajorBatch(e,t=!0,s=hV){return this.rowMajorBatch(e,t).map(i=>Gce(i,s))}concatenate(e,t){return new mV(pV([this,e]),t)}take(e){return e<0||e==null?this:new nhe(this,e)}skip(e){return e<0||e==null?this:new the(this,e)}prefetch(e){return new gV(this,e)}shuffle(e,t){return new uhe(this,e,t)}serial(){return new ehe(this)}}class Zce extends Bn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Kce(e),done:!1}}}class Qce extends Bn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class ehe extends Bn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class the extends Bn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Ke(e.value)}return this.upstream.next()}}class nhe extends Bn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class she extends Bn{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class rhe extends Bn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ke(e.value)}}}class ihe extends Bn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=ka(e.value),s=this.transform(e.value),r=ka(s);for(const i of t)Cx(i,r)||i.dispose();return{value:s,done:!1}}}class ahe extends Bn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class w3 extends Bn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=ka(e.value),s=await this.transform(e.value),r=ka(s);for(const i of t)Cx(i,r)||i.dispose();return{value:s,done:!1}}}class WE extends Bn{constructor(){super(),this.outputQueue=new Dw,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ohe extends WE{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=ka(e.value),s=this.transform(e.value),r=ka(s);this.outputQueue.pushAll(s);for(const i of t)Cx(i,r)||i.dispose();return!0}}class mV extends Bn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var wo;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(wo||(wo={}));class lhe extends Bn{constructor(e,t=wo.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function r(a){return a instanceof Bn?{value:a.next().then(l=>(t++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const i=await dV(this.iterators,r);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case wo.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case wo.SHORTEST:return{value:null,done:!0};case wo.LONGEST:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class gV extends Bn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new fV(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class uhe extends gV{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=td.alea(s||Gn().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}class ld{constructor(){this.size=null}batch(e,t=!0){const s=this;O(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Gs(async()=>(await s.iterator()).columnMajorBatch(e,t,dhe),r)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,Gs(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,Gs(async()=>(await t.iterator()).filter(r=>re(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Gs(async()=>(await t.iterator()).map(s=>re(()=>e(s))),this.size)}mapAsync(e){const t=this;return Gs(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Gs(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,Gs(async()=>{const r=jE(async()=>({value:await t.iterator(),done:!1}));return Yce(r.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,Gs(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,i=td.alea(t||Gn().toString());return Gs(async()=>{let a=i.int32();return s&&(a+=i.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,Gs(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}ld.MAX_BUFFER_SIZE=1e4;function Gs(n,e=null){return new class extends ld{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function che(n){return Gs(async()=>pV(n),n.length)}function hhe(n){if(!qc(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return Gs(async()=>{const t=await dV(n,s=>{if(s instanceof ld)return{value:s.iterator(),recurse:!1};if(qc(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Jce(t,wo.SHORTEST)},e)}function dhe(n){if(n===null)return null;const e=n[0];return Hce(e)?{value:fhe(n),recurse:!1}:{value:null,recurse:!0}}function fhe(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof bt?bs(n):Xs(n)}class yV extends ld{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}const Uy='"',xf=Symbol("out"),v3=Symbol("field"),jy=Symbol("quote"),WS=Symbol("quoteafterquote"),S3=Symbol("quoteinquote");class bV extends ld{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&O(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,i)=>(r[i]=r[i]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(O(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new yV(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(O(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let i=0;i<this.fullColumnNames.length;i++){const a=this.fullColumnNames[i],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){const l=t[i];let h=null;if(l==="")if(o&&o.default!==void 0)h=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);h=void 0}else{const d=Number(l);if(isNaN(d))o&&o.dtype==="bool"?h=this.getBoolean(l):h=l;else if(!o||!o.dtype)h=d;else switch(o.dtype){case"float32":h=d;break;case"int32":h=Math.floor(d);break;case"bool":h=this.getBoolean(l);break;default:h=d}}o&&o.isLabel?r[a]=h:s[a]=h}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const i=e.length;let a=xf;for(let o=0;o<i;o++)switch(a){case xf:switch(e.charAt(o)){case Uy:r=o+1,a=jy;break;case this.delimiter:if(r=o+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=xf;break;default:a=v3,r=o;break}break;case v3:e.charAt(o)===this.delimiter&&(s.push(e.substring(r,o)),a=xf,r=o+1);break;case jy:e.charAt(o)===Uy&&(a=WS);break;case WS:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(r,o-1)),a=xf,r=o+1;break;case Uy:a=jy;break;default:a=S3;break}break;case S3:e.charAt(o)===Uy&&(a=jy);break}if(a===WS?s.push(e.substring(r,i-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class GE extends Bn{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ae().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new GE(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(i),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,i)=>s.set(r,i*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(he(t));return s.set(e,s.length-e.length),Xs(s,t)}}class HE extends Bn{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Xn([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,i=(1-s)/2,a=(1-r)/2,o=i+s,l=r+a;this.cropBox=To([a,i,l,o],[1,4])}else this.cropBox=To([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ae().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new HE(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&O(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=lP(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return re(()=>{const t=Hn(Ne(e,"float32"),0);let s;s=jr.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return Y(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class xV{}class wV extends Bn{split(e){return new phe(this,e)}}class phe extends wV{constructor(e,t){super(),this.upstream=e,this.impl=new mhe(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class mhe extends WE{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}class ghe extends Bn{decodeUTF8(){return new yhe(this)}}class yhe extends wV{constructor(e){super(),this.upstream=e,this.impl=new bhe(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class bhe extends WE{constructor(e){if(super(),this.upstream=e,ae().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return ae().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}class vV extends ghe{constructor(e,t={}){super(),this.file=e,this.options=t,O(e instanceof Uint8Array||(ae().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const i=new FileReader;i.onload=o=>{let l=i.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(l)},i.onabort=o=>s(new Error("Aborted")),i.onerror=o=>s(new Error(o.type));const a=this.file.slice(this.offset,r);i.readAsArrayBuffer(a)}this.offset=r}),done:!1}}}async function xhe(n,e={},t){let s,r;typeof n=="string"?s=n:(s=n.url,r=whe(n));const i=await EM(s,r);if(i.ok){const a=new Uint8Array(await i.arrayBuffer());return new vV(a,e)}else throw new Error(i.statusText)}const whe=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function SV(n){return typeof n=="string"&&n.slice(0,7)==="file://"}class TV extends xV{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(SV(this.input)&&ae().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new vV(this.input,this.options)}}class CV extends xV{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return SV(this.url)?new TV(this.url,this.fileOptions).iterator():xhe(this.url,this.fileOptions)}}function vhe(n,e={}){return new bV(new CV(n),e)}function She(n){const e=jE(n);return Gs(async()=>e)}function The(n){return Gs(async()=>{const e=await n();return jE(()=>e.next())})}async function Che(n,e){return HE.create(n,e)}async function Nhe(n){return GE.create(n)}const NV="4.22.0";const khe=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:bV,Dataset:ld,FileDataSource:TV,TextLineDataset:yV,URLDataSource:CV,array:che,csv:vhe,func:She,generator:The,microphone:Nhe,version_data:NV,webcam:Che,zip:hhe},Symbol.toStringTag,{value:"Module"}));function Oe(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const Ehe=Jx;class sg extends pb{nextDataId(){return sg.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new h2(this,li())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ae().get("IS_NODE")&&gr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Di(s[0])){const i=s.map(a=>Mi(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return $a(r,i)}return mM(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Na(r));return Qe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,t)}makeOutput(e,t,s){return li().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Gn();return e(),{kernelMs:Gn()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Oe([e],"where");const t=this.readSync(e.dataId);return Ehe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}sg.nextDataId=0;function kV(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const Ihe=n=>{const{x:e}=n.inputs,t=n.backend;Oe(e,"abs");let s=new Float32Array(he(e.shape));const r=t.data.get(e.dataId).values;return s=kV(r),t.makeOutput(s,e.shape,e.dtype)},$he={kernelName:Sp,backendName:"cpu",kernelFunc:Ihe};function dn(n){return(e,t,s,r,i)=>{const a=Xe(e,t),o=a.length,l=Be(a),h=he(a),d=zn(i,h),p=e.length,m=t.length,y=Be(e),b=Be(t),x=Yl(e,a),w=Yl(t,a);if(x.length+w.length===0)for(let v=0;v<d.length;++v)d[v]=n(s[v%s.length],r[v%r.length]);else for(let v=0;v<d.length;++v){const C=cu(v,o,l),N=C.slice(-p);x.forEach(R=>N[R]=0);const k=di(N,p,y),E=C.slice(-m);w.forEach(R=>E[R]=0);const A=di(E,m,b);d[v]=n(s[k],r[A])}return[d,a]}}function qs(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(o.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",i),imag:t.makeTensorInfo(r.shape,"float32",a)},o}const _he={kernelName:Tb,backendName:"cpu",kernelFunc:qs};function Y0(n,e,t="float32"){if(t==="complex64"){const r=Y0(n,e,"float32"),i=Y0(n,e,"float32");return qs({inputs:{real:r,imag:i},backend:n})}const s=Yn(he(e),t);return n.makeTensorInfo(e,t,s)}function Hi(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Ahe={kernelName:wh,backendName:"cpu",kernelFunc:Hi};function su(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Rhe={kernelName:nx,backendName:"cpu",kernelFunc:su};function EV(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Bo([0],t),[i,a]=dn((o,l)=>o!==l?1:0)(e,[],n,r,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function zo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Hi({inputs:{x:r},backend:t});const d=Y0(t,r.shape,r.dtype),p=zo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=qs({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){const d=su({inputs:{input:r},backend:t}),p=zo({inputs:{x:d},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(d),p}if(!p2(r.dtype,i)){const d=Hi({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:i}}const a=t.data.get(r.dataId).values,[o,l,h]=EV(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,l,h)}const Dhe={kernelName:oh,backendName:"cpu",kernelFunc:zo};function An(n,e,t,s){return t==null?({inputs:r,backend:i})=>{const{a,b:o}=r,l=i;Oe([a,o],n);const h=l.data.get(a.dataId).values,d=l.data.get(o.dataId).values,p=a.dtype==="string"?_a(h):h,m=a.dtype==="string"?_a(d):d,y=s||a.dtype,[b,x]=e(a.shape,o.shape,p,m,y);return l.makeTensorInfo(x,y,b)}:({inputs:r,backend:i})=>{const{a,b:o}=r,l=i;if(a.dtype==="complex64"||o.dtype==="complex64"){const h=zo({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(h.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=l.data.get(p.dataId).values,b=l.data.get(m.dataId).values,x=zo({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),w=l.data.get(x.dataId),v=w.complexTensorInfos.real,C=w.complexTensorInfos.imag,N=l.data.get(v.dataId).values,k=l.data.get(C.dataId).values,[E,A,R]=t(a.shape,o.shape,y,b,N,k),D=l.makeTensorInfo(R,"float32",E),L=l.makeTensorInfo(R,"float32",A),F=qs({inputs:{real:D,imag:L},backend:l});return l.disposeIntermediateTensorInfo(h),l.disposeIntermediateTensorInfo(x),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(L),F}else{const h=l.data.get(a.dataId).values,d=l.data.get(o.dataId).values,p=s||a.dtype,[m,y]=e(a.shape,o.shape,h,d,p);return l.makeTensorInfo(y,p,m)}}}function qE(n){return(e,t,s,r,i,a)=>{const o=Xe(e,t),l=he(o),h=o.length,d=Be(o),p=zn("float32",l),m=zn("float32",l),y=Yl(e,o),b=Yl(t,o),x=$a(s,r),w=$a(i,a),v=e.length,C=Be(e),N=t.length,k=Be(t);if(y.length+b.length===0)for(let E=0;E<p.length;E++){const A=E%x.length,R=E%w.length,D=n(x[A*2],x[A*2+1],w[R*2],w[R*2+1]);p[E]=D.real,m[E]=D.imag}else for(let E=0;E<p.length;E++){const A=cu(E,h,d),R=A.slice(-v);y.forEach(V=>R[V]=0);const D=di(R,v,C),L=A.slice(-N);b.forEach(V=>L[V]=0);const F=di(L,N,k),_=n(x[D*2],x[D*2+1],w[F*2],w[F*2+1]);p[E]=_.real,m[E]=_.imag}return[p,m,o]}}const IV=dn(((n,e)=>n+e)),Ohe=qE(((n,e,t,s)=>({real:n+t,imag:e+s}))),Kc=An(hu,IV,Ohe),Lhe={kernelName:hu,backendName:"cpu",kernelFunc:Kc};function KE(n,e,t,s,r){const i=he(s),a=Yn(r,t);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?a[l]+=e[o]:a[l]+=1)}return a}function $V(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],a=Qe([r,t],e.dtype);for(let o=0;o<r;o++)for(let l=0;l<i;l++){const h=n.get(o,l);if(h<0)throw new Error("Input x must be non-negative!");h>=t||(s?a.set(1,o,h):e.size>0?a.set(a.get(o,h)+e.get(o,l),o,h):a.set(a.get(o,h)+1,o,h))}return a}const _V=dn(((n,e)=>n&e)),Fhe=An(_p,_V),Mhe={kernelName:_p,backendName:"cpu",kernelFunc:Fhe};function Ki(n){return(e,t,s)=>{const r=tn(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}function Nt(n,e,t){const s=Ki(e);return Ko(n,s,t)}function Ko(n,e,t){return({inputs:s,attrs:r,backend:i})=>{const{x:a}=s;Oe(a,n);const o=i,l=o.data.get(a.dataId).values;let h;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");h=_a(l)}else h=l;const d=t||a.dtype,p=e(h,d,r);return o.makeTensorInfo(a.shape,d,p)}}const AV=Ki(n=>Math.ceil(n)),zhe=Ko(lh,AV),Phe={kernelName:lh,backendName:"cpu",kernelFunc:zhe};function RV(n,e,t,s){const r=tn(t,he(e));if(s&&t!=="string"){let i=0;n.forEach(a=>{const o=he(a.shape);r.set(a.vals,i),i+=o})}else{let i=0;n.forEach(a=>{const o=t==="string"?_a(a.vals):a.vals;let l=0;for(let h=0;h<a.shape[0];++h){const d=h*e[1]+i;for(let p=0;p<a.shape[1];++p)r[d+p]=o[l++]}i+=a.shape[1]})}return r}const DV=dn((n,e)=>n===e?1:0),OV=An(Pp,DV,null,"bool"),Bhe={kernelName:Pp,backendName:"cpu",kernelFunc:OV};const LV=Ki(n=>Math.exp(n)),FV=Ko(mh,LV,"float32"),Vhe={kernelName:mh,backendName:"cpu",kernelFunc:FV};const MV=Ki(n=>Math.expm1(n)),Uhe=Ko(gh,MV),jhe={kernelName:gh,backendName:"cpu",kernelFunc:Uhe};const zV=Ki(n=>Math.floor(n)),Whe=Ko(yh,zV),Ghe={kernelName:yh,backendName:"cpu",kernelFunc:Whe};const PV=dn((n,e)=>Math.floor(n/e)),Hhe=An(bh,PV,null,"int32"),qhe={kernelName:bh,backendName:"cpu",kernelFunc:Hhe};function BV(n,e,t,s,r,i,a,o,l){const h=Qe([s,i],t);for(let d=0;d<s;d++){const p=[];let m=0;for(let y=0;y<r;y++){const b=n[d*r+y];m+=b*a[y],p.push(b)}if(m<0||m>=l/i)throw new Error(`Invalid indices: ${p} does not index into ${o}`);for(let y=0;y<i;y++)h.values[d*i+y]=e.get(...e.indexToLoc(m*i+y))}return h}function VV(n,e,t){const s=Qe(t,n.dtype);for(let r=0;r<s.size;++r){const a=s.indexToLoc(r).slice(),o=a[0],l=a[2],h=e.locToIndex([o,l]);a[2]=e.values[h];const d=n.locToIndex(a);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const UV=dn((n,e)=>n>e?1:0),Khe=An(jp,UV,null,"bool"),Xhe={kernelName:jp,backendName:"cpu",kernelFunc:Khe};const jV=dn((n,e)=>n>=e?1:0),Yhe=An(xh,jV,null,"bool"),Jhe={kernelName:xh,backendName:"cpu",kernelFunc:Yhe};const WV=dn((n,e)=>n<e?1:0),Zhe=An(Gp,WV,null,"bool"),Qhe={kernelName:Gp,backendName:"cpu",kernelFunc:Zhe};const GV=dn((n,e)=>n<=e?1:0),ede=An(Hp,GV,null,"bool"),tde={kernelName:Hp,backendName:"cpu",kernelFunc:ede};function HV(n,e,t){const s=(e-n)/(t-1),r=Yn(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const qV=Ki(n=>Math.log(n)),nde=Ko(Ch,qV),sde={kernelName:Ch,backendName:"cpu",kernelFunc:nde};function KV(n,e,t,s){const r=zn(s,he(t));for(let i=0;i<r.length;++i){const a=i*e;let o=n[a];for(let l=0;l<e;++l){const h=n[a+l];(Number.isNaN(h)||h>o)&&(o=h)}r[i]=o}return r}const XV=dn(((n,e)=>Math.max(n,e))),rde=An(kh,XV),ide={kernelName:kh,backendName:"cpu",kernelFunc:rde};const YV=dn(((n,e)=>Math.min(n,e))),ade=An(Eh,YV),ode={kernelName:Eh,backendName:"cpu",kernelFunc:ade};const XE=dn(((n,e)=>n*e)),lde=qE(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),Ow=An($h,XE,lde),ude={kernelName:$h,backendName:"cpu",kernelFunc:Ow};function JV(n,e,t){const s=Oa(-1,t);return XE([],e,s,n,t)}function cde(n){const{inputs:e,backend:t}=n,{x:s}=e;Oe(s,"neg");const r=t.data.get(s.dataId).values,[i,a]=JV(r,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,i)}const hde={kernelName:sm,backendName:"cpu",kernelFunc:cde};const ZV=dn(((n,e)=>n!==e?1:0)),dde=An(rm,ZV,null,"bool"),fde={kernelName:rm,backendName:"cpu",kernelFunc:dde};function YE(n,e,t,s,r){const i=e.length,a=he(e),o=Be(e),l=Be(r),h=zn(t,he(r));for(let d=0;d<a;++d){const p=cu(d,i,o),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[s[b]];const y=di(m,i,l);h[y]=n[d]}return h}function Ls(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:i}=t;Oe(r,"transpose");const a=r.shape.length,o=new Array(a);for(let p=0;p<o.length;p++)o[p]=r.shape[i[p]];const l=s.data.get(r.dataId).values,h=YE(l,r.shape,r.dtype,i,o);return{dataId:s.write(h,o,r.dtype),shape:o,dtype:r.dtype}}const pde={kernelName:Bl,backendName:"cpu",kernelFunc:Ls};function QV(n,e,t,s){const[r,i]=Un(n,s),a=_s(e,"int32"),o=Yn(he(r),a),l=he(i);for(let h=0;h<o.length;++h){const d=h*l;let p=1;for(let m=0;m<l;++m)p*=t[d+m];o[h]=p}return{outVals:o,outShape:r,outDtype:a}}function mde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Oe(r,"prod");const o=r.shape.length,l=st(i,r.shape),h=Zt(l,o);let d=l,p=r;const m=[];h!=null&&(p=Ls({inputs:{x:r},backend:t,attrs:{perm:h}}),m.push(p),d=cn(d.length,o));const y=t.data.get(p.dataId).values,{outVals:b,outShape:x,outDtype:w}=QV(p.shape,p.dtype,y,d);let v=x;return a&&(v=un(x,l)),m.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(v,w,b)}const gde={kernelName:cm,backendName:"cpu",kernelFunc:mde};function yde(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const i=cu(r,e.length,Be(e)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${t})`)}})}function bde(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function xde(n,e,t,s){const r=[];let i=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);bde(t,s);let l=1;for(let h=0;h<e.length-1;++h){l*=e[h];const d=e[h+1];for(let p=1;p<l+1;++p)o[h].push(p*d)}for(let h=0;h<n.length;++h){let d=n[h],p=n[h]+1;for(let m=0;m<t.length;++m){const y=t[m],b=m+e.length-1;if(b>=0){const x=o[b],w=x[x.length-1]-y[d];for(let v=d;v<p;++v)o[b].push(y[v+1]+w)}d=y[d],p=y[p]}p!==d&&(r.push([d,p]),i+=p-d)}return{outSplits:o,valueSlices:r,numValues:i}}function wde(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=tn("int32",s);e.push(r),n[t].forEach((i,a)=>r[a]=i)}return e}function T3(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function vde(n,e,t,s,r,i){const a=T3(e,2)[1],o=T3(i,2)[1];let l=0;for(const h of t)for(let d=h[0];d<h[1];++d){for(let p=0;p<s;++p)r[l*o+p]=n[d*a+p];++l}}function Sde(n,e,t,s,r){const i=e.slice();i[0]=r;const a=tn(t,he(i)),o=n.length,l=o===0?0:o/e[0];return vde(n,e,s,l,a,i),[a,i]}function e4(n,e,t,s,r,i,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(yde(i,a,l),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:p,numValues:m}=xde(i,a,n,h),y=wde(d),b=Sde(t,s,r,p,m);return[y,b[0],b[1]]}const C3=2147483647;function t4(n,e,t,s,r,i,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=r.length===0,h=a.length===0,d=[];o||d.push(e[0]),l||d.push(r[0]),h||d.push(a[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=tn("int32",p+1);m[0]=0;for(let w=0;w<p;++w){const v=o?n[0]:n[w],C=l?s[0]:s[w],N=h?i[0]:i[w];if(N===0)throw new Error("Requires delta != 0");let k;if(N>0&&C<v||N<0&&C>v)k=0;else if(k=Math.ceil(Math.abs((C-v)/N)),k>C3)throw new Error(`Requires ((limit - start) / delta) <= ${C3}`);m[w+1]=m[w]+k}const y=m[p],b=tn(t,y);let x=0;for(let w=0;w<p;++w){const v=m[w+1]-m[w];let C=o?n[0]:n[w];const N=h?i[0]:i[w];for(let k=0;k<v;++k)b[x++]=C,C+=N}return[m,b]}var zr=hi;class J0{constructor(e,t,s,r,i,a,o,l,h,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=vP(d),this.raggedRank=SP(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===zr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===zr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case zr.VALUE_ROWIDS:return J0.getMaxWidthValueRowID(t);case zr.ROW_SPLITS:return J0.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${zr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const i=e[r+1]-e[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],i=0;for(let a=1;a<t;++a){const o=e[a];o!==r&&(r=o,i=Math.max(a-s,i),s=a)}return Math.max(t-s,i)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return k3(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;TP(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=wP(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),i=[];let a=0;for(let o=0;o<r;++o,a+=t)i.push(a);for(let o=r;o<e;++o)i.push(-1);return O(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,s,r){const i=e.length,a=[];for(let o=0;o<i-1;++o){const l=e[o+1]-e[o];let h=Math.min(r,l),d=t[o];d===-1&&(h=0);for(let p=0;p<h;++p)a.push(d),d+=s;for(let p=0;p<l-h;++p)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,r){const i=e.length,a=[];if(i===0)return[];let o=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let h=t[l];a.push(h);for(let d=1;d<i;++d){const p=e[d];if(p===l)h>=0&&(++o,o<r?h+=s:h=-1);else{if(o=0,l=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);h=t[p]}a.push(h)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,r){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case zr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,s,r);case zr.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,s,r);default:throw new Error(`Unsupported partition type: ${zr[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case zr.FIRST_DIM_SIZE:return e[0];case zr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${zr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const i=k3(s,!1),a=tn(this.valuesDType,he(i));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)l=this.calculateOutputIndex(h-1,l,r[h],s[h]);this.setOutput(this.raggedRank,l,a,i)}return[i,a]}setOutput(e,t,s,r){if(s.length===0)return;const i=this.values,a=s;let o=r.slice();o=o.slice(e+1);const l=he(o),h=t.length;let d=this.defaultValue;if(d.length!==l&&d.length!==1){const b=this.defaultValueShape;re(()=>{const x=Y(d,b);d=Vl(x,o).dataSync()})}let p=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?t[b]:-1;if(x===y){++y;continue}if(m<y){const w=i.subarray(p*l),v=a.subarray(m*l),C=(y-m)*l;N3(v,w,C)}if(b>=h){const w=s.length;x=Math.floor(w/l)}if(x>y)if(this.defaultValue.length===1)a.subarray(y*l,x*l).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=a.slice(y*l);N3(w,d,l),++y}x<0?(p=b+1,m=y):(p=b,m=y,y=m+1)}}}function N3(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function k3(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function n4(n,e,t,s,r,i,a,o,l,h){return new J0(n,e,t,s,r,i,a,o,l,h).compute()}function s4(n,e,t,s){const r=n===e,i=n<e&&t<0,a=e<n&&t>1;if(r||i||a)return Yn(0,s);const o=Math.abs(Math.ceil((e-n)/t)),l=Yn(o,s);e<n&&t===1&&(t=-1),l[0]=n;for(let h=1;h<l.length;h++)l[h]=l[h-1]+t;return l}const r4=Ki(n=>1/Math.sqrt(n)),Tde=Ko(Lh,r4),Cde={kernelName:Lh,backendName:"cpu",kernelFunc:Tde};function Fl(n,e,t,s,r,i,a,o,l,h){const d=[s/r,r],p=n.values,m=e.values;if(s===0)return Qe(t,e.dtype);const y=l instanceof bn?l:Qe(d,e.dtype);typeof l=="string"||typeof l=="number"?y.values.fill(l):typeof l=="boolean"&&y.values.fill(+l);for(let b=0;b<i;b++){const x=[];let w=0;for(let v=0;v<a;v++){const C=p[b*a+v];x.push(C),w+=C*o[v]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let v=0;v<r;v++)h?y.values[w*r+v]+=m[b*r+v]:y.values[w*r+v]=e.rank===0?m[0]:m[b*r+v]}return y}const Nde=Ki(n=>1/(1+Math.exp(-n))),i4=Nt(Bh,n=>1/(1+Math.exp(-n))),kde={kernelName:Bh,backendName:"cpu",kernelFunc:i4};function a4(n,e,t,s,r){const i=jN(s,e,t),a=he(t),o=Be(s);if(i){const p=WN(e,o);return r==="string"?n.slice(p,p+a):n.subarray(p,p+a)}const l=r==="string"?_a(n):n,h=Qe(s,r,l),d=Qe(t,r);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),y=m.map((b,x)=>b+e[x]);d.set(h.get(...y),...m)}return r==="string"?jP(d.values):d.values}function ru(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s;Oe(r,"slice");const[o,l]=uw(r,i,a);VN(r,o,l);const h=t.data.get(r.dataId).values,d=a4(h,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const Ede={kernelName:gm,backendName:"cpu",kernelFunc:ru};function o4(n,e,t,s,r,i,a){const o=e[0],l=i[0],h=new Array(l),d=new Array(o),p=e[1];if(l===0){if(o!==0)throw new Error(_P(o));const w=tn(t,0),v=tn(r,0);return[w,[0,p],v,h,d]}let m=!0,y=0;const b=new Array(l).fill(0);for(let w=0;w<o;++w){const v=n[w*p];if(v<0)throw new Error(AP(w,v));if(v>=l)throw new Error(RP(w,v,l));++b[v],m=m&&v>=y,y=v}let x=!0;for(let w=0;w<l;++w){const v=b[w]===0;h[w]=v,x=x&&!v,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,v=s;for(let C=0;C<o;++C)d[C]=C;return[w,[o,p],v,h,d]}else{const w=b[l-1],v=tn(t,w*p),C=tn(r,w),N=new Array(l).fill(0);for(let k=0;k<o;++k){const E=n[k*p],A=N[E],R=(E===0?0:b[E-1])+A;N[E]++;for(let D=0;D<p;++D)v[R*p+D]=n[k*p+D];C[R]=s[k],d[k]=R}for(let k=0;k<l;++k)if(N[k]===0){const A=k===0?0:b[k-1];v[A*p+0]=k;for(let R=1;R<p;++R)v[A*p+R]=0;C[A]=a}return[v,[w,p],C,h,d]}}function l4(n,e,t,s,r){const i=he(s),a=e[0],o=r.length,l=[];let h=1,d=-1;for(let w=0;w<o;++w){const v=r[w];if(v===-1){if(d!==-1)throw new Error(DP(d,w));d=w,l.push(1)}else{if(v<0)throw new Error(OP(w,v));h*=v,l.push(v)}}if(d!==-1){if(h<=0)throw new Error(LP());const w=Math.trunc(i/h);if(h*w!==i)throw new Error(FP(s,l));l[d]=w}if(he(l)!==i)throw new Error(MP(s,l));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(o>0){b[o-1]=1;for(let w=o-2;w>=0;--w)b[w]=b[w+1]*l[w+1]}const x=tn(t,a*o);for(let w=0;w<a;++w){let v=0;for(let C=0;C<m;++C)v+=n[w*m+C]*y[C];for(let C=0;C<o;++C)x[w*o+C]=Math.trunc(v/b[C]),v%=b[C]}return[x,[a,o],l]}function JE(n,e,t,s,r,i=!1,a=0){const o=s.length,l=[e[0],n.length/e[0]],h=l[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(qT());const m=e.slice();m[0]=p;const y=m.reduce((N,k)=>N*k,1),b=tn(t,y);if(o===0)return p>0&&b.fill(a),[b,m];if(p<=0)throw new Error(qT());let x=0,w=1,v=0,C=r[x];for(;;){let N=0;if(w<o){if(N=r[w],C===N){++w;continue}if(C>=N)throw new Error(zP())}if(C<0||C>=p)throw new Error(PP(C,p));C>v&&b.fill(a,v*h,C*h);for(let k=x;k<w;++k){const E=s[k];if(E<0||E>=l[0])throw new Error(BP(k,s[k],l[0]));for(let A=0;A<h;A++)b[C*h+A]+=n[E*h+A]}if(i)for(let k=0;k<h;k++)b[C*h+k]/=w-x;if(x=w,++w,v=C+1,C=N,w>o)break}return v<p&&b.fill(a,v*h,p*h),[b,m]}const Ide=Ki(n=>Math.sqrt(n)),$de=Nt(Uh,n=>Math.sqrt(n)),_de={kernelName:Uh,backendName:"cpu",kernelFunc:$de};const u4=dn(((n,e)=>{const t=n-e;return t*t})),Ade=An(jh,u4),Rde={kernelName:jh,backendName:"cpu",kernelFunc:Ade};const c4=Ki((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),Dde=Ko(vm,c4),Ode={kernelName:vm,backendName:"cpu",kernelFunc:Dde};function h4(n,e,t,s){const r=Qe(n,e.dtype);for(let i=0;i<r.size;i++){const a=r.indexToLoc(i),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*t[l]+s[l];r.set(e.get(...o),...a)}return r}class Lde{constructor(e,t,s,r,i,a){this.separator=Mi(e),this.nGramWidths=t,this.leftPad=Mi(s),this.rightPad=Mi(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,a){for(let o=0;o<i;++o){const l=this.getPadWidth(a),h=Math.max(0,l-o),d=Math.max(0,l-(i-(o+1))),p=a-(h+d),m=t+(h>0?0:o-l);let y=0;y+=h*this.leftPad.length;for(let C=0;C<p;++C)y+=e[m+C].length;y+=d*this.rightPad.length;const b=h+d+p-1;y+=b*this.separator.length,s[r+o]=new Uint8Array(y);const x=s[r+o];let w=0;const v=C=>C.forEach(N=>x[w++]=N);for(let C=0;C<h;++C)v(this.leftPad),v(this.separator);for(let C=0;C<p-1;++C)v(e[m+C]),v(this.separator);if(p>0){v(e[m+p-1]);for(let C=0;C<d;++C)v(this.separator),v(this.rightPad)}else{for(let C=0;C<d-1;++C)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let h=1;h<r;++h){let d=t[h]>=l;if(d=d&&t[h]<=s,!d)throw new Error(`Invalid split value ${t[h]}, must be in [${l}, ${s}]`);l=t[h]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,a=tn("int32",r);if(s===0||r===0){const l=new Array(s);for(let h=0;h<=i;++h)a[h]=0;return[l,a]}a[0]=0;for(let l=1;l<=i;++l){const h=t[l]-t[l-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&d===0&&(d=1),a[l]=a[l-1]+d}const o=new Array(a[i]);for(let l=0;l<i;++l){const h=t[l];let d=a[l];if(this.nGramWidths.forEach(p=>{const m=t[l+1]-t[l],y=this.getNumNGrams(m,p);this.createNGrams(e,h,o,d,y,p),d+=y}),this.preserveShort&&d===a[l]){const p=t[l+1]-t[l];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(e,h,o,d,1,m)}}return[o,a]}}function d4(n,e,t,s,r,i,a,o){return new Lde(t,s,r,i,a,o).compute(n,e)}function Fde(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let a=n.indexOf(i);for(;a!==-1;){const o=n.subarray(0,a);(!t||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const a=n.subarray(r,i);(!t||a.length!==0)&&s.push(a),r=i+1}}function f4(n,e,t){const s=n.length,r=[];let i=0,a=0;const o=new Array(s);for(let m=0;m<s;++m){const y=r.length;Fde(n[m],e,t,r);const b=r.length-y;o[m]=b,i+=b,a=Math.max(a,b)}const l=tn("int32",i*2),h=new Array(i),d=[s,a];let p=0;for(let m=0;m<s;++m)for(let y=0;y<o[m];++y)l[p*2]=m,l[p*2+1]=y,h[p]=r[p],++p;return[l,h,d]}function p4(n,e){const t=tn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=kM(n[s]).modulo(e).getLowBitsUnsigned();return t}const m4=dn(((n,e)=>n-e)),Mde=qE(((n,e,t,s)=>({real:n-t,imag:e-s}))),ZE=An(Wh,m4,Mde),zde={kernelName:Wh,backendName:"cpu",kernelFunc:ZE};function g4(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=Qe(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=i[l]%n.shape[l];const o=n.locToIndex(a);s.values[r]=n.values[o]}return s}const Nf=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function y4(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,l=e-t+1,h=Math.log(o),d=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*d*(o-d)/o)*Math.sign(l-o/2),m=Math.max(t,Math.floor(e-l*d/o+p)),y=Math.min(s,Math.floor(e+(o-l)*d/o+p));y4(n,e,m,y)}const r=n[e];let i=t,a=s;for(xa(n,t,e),Nf(n[s],r)>0&&xa(n,t,s);i<a;){for(xa(n,i,a),i++,a--;Nf(n[i],r)<0;)i=i+1;for(;Nf(n[a],r)>0;)a=a-1}Nf(n[t],r)===0?xa(n,t,a):(a=a+1,xa(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function b4(n,e,t,s,r){const i=e[e.length-1],[a,o]=[n.length/i,i],l=zn(t,a*s),h=zn("int32",a*s);for(let p=0;p<a;p++){const m=p*o,y=n.subarray(m,m+o);let b=new Array(y.length);y.forEach((C,N)=>b[N]={value:C,index:N}),s<b.length&&(y4(b,s),b=b.slice(0,s)),r&&b.sort(Nf);const x=p*s,w=l.subarray(x,x+s),v=h.subarray(x,x+s);for(let C=0;C<s;C++)w[C]=b[C].value,v[C]=b[C].index}const d=e.slice();return d[d.length-1]=s,[Qe(d,t,l),Qe(d,"int32",h)]}function x4(n,e,t,s){const r=st(e,t)[0],i=[1,t[0],1];for(let b=0;b<r;b++)i[0]*=t[b];i[1]=t[r];for(let b=r+1;b<t.length;b++)i[2]*=t[b];const a=new Map,o=new Int32Array(t[r]),l=new bn(i,s,n),h=[],d=i[0]===1&&i[2]===1;for(let b=0;b<t[r];b++){let x;if(d)x=n[b].toString();else{const v=[];for(let C=0;C<i[0];C++)for(let N=0;N<i[2];N++)v.push(l.get(C,b,N));x=v.join(",")}const w=a.get(x);if(w!=null)o[b]=w;else{const v=a.size;a.set(x,v),o[b]=v,h.push(b)}}const p=i.slice();p[1]=a.size;const m=new bn(p,s);h.forEach((b,x)=>{for(let w=0;w<i[0];w++)for(let v=0;v<i[2];v++)m.set(l.get(w,b,v),w,x,v)});const y=t.slice();return y[r]=p[1],{outputValues:m.values,outputShape:y,indices:o}}const w4=Object.freeze(Object.defineProperty({__proto__:null,addImpl:IV,bincountImpl:KE,bincountReduceImpl:$V,bitwiseAndImpl:_V,castImpl:EV,ceilImpl:AV,concatImpl:RV,equalImpl:DV,expImpl:LV,expm1Impl:MV,floorDivImpl:PV,floorImpl:zV,gatherNdImpl:BV,gatherV2Impl:VV,greaterEqualImpl:jV,greaterImpl:UV,lessEqualImpl:GV,lessImpl:WV,linSpaceImpl:HV,logImpl:qV,maxImpl:KV,maximumImpl:XV,minimumImpl:YV,multiplyImpl:XE,negImpl:JV,notEqualImpl:ZV,prodImpl:QV,raggedGatherImpl:e4,raggedRangeImpl:t4,raggedTensorToTensorImpl:n4,rangeImpl:s4,rsqrtImpl:r4,scatterImpl:Fl,sigmoidImpl:Nde,simpleAbsImpl:kV,sliceImpl:a4,sparseFillEmptyRowsImpl:o4,sparseReshapeImpl:l4,sparseSegmentReductionImpl:JE,sqrtImpl:Ide,squaredDifferenceImpl:u4,staticRegexReplaceImpl:c4,stridedSliceImpl:h4,stringNGramsImpl:d4,stringSplitImpl:f4,stringToHashBucketFastImpl:p4,subImpl:m4,tileImpl:g4,topKImpl:b4,transposeImpl:YE,uniqueImpl:x4},Symbol.toStringTag,{value:"Module"}));const v4="4.22.0";S2("cpu",()=>new sg,1);const S4=Nt(fh,n=>n>=0?n:Math.exp(n)-1),Pde={kernelName:fh,backendName:"cpu",kernelFunc:S4};function T4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s;Oe([r],"leakyRelu");const a=he(r.shape),o=t.data.get(r.dataId).values,l=zn("float32",a);for(let h=0;h<o.length;h++)l[h]=o[h]<0?i*o[h]:o[h];return t.makeTensorInfo(r.shape,"float32",l)}const Bde={kernelName:Wp,backendName:"cpu",kernelFunc:T4};const Vde=dn((n,e)=>n<0?e*n:n);function C4(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;Oe([s,r],"prelu");const i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,[o,l]=Vde(s.shape,r.shape,i,a,"float32");return t.makeTensorInfo(l,"float32",o)}const Ude={kernelName:um,backendName:"cpu",kernelFunc:C4};const N4=Nt(Rh,n=>Math.max(0,n)),jde={kernelName:Rh,backendName:"cpu",kernelFunc:N4};const k4=Nt(Dh,n=>Math.min(Math.max(0,n),6)),Wde={kernelName:Dh,backendName:"cpu",kernelFunc:k4};function Z0(n,e,t,s,r){if(t==="linear")return Hi({inputs:{x:e},backend:n});if(t==="relu")return N4({inputs:{x:e},backend:n});if(t==="elu")return S4({inputs:{x:e},backend:n});if(t==="relu6")return k4({inputs:{x:e},backend:n});if(t==="prelu")return C4({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return T4({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return i4({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function zt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=he(r.shape),o=f2(i,a),l=he(o);O(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const h=t.data.get(r.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;d.shape=o,p.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const Gde={kernelName:hm,backendName:"cpu",kernelFunc:zt};function E4(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;Oe([r,i],"matMul");const l=r.shape.length,h=i.shape.length,d=a?r.shape[l-2]:r.shape[l-1],p=o?i.shape[h-1]:i.shape[h-2],m=a?r.shape[l-1]:r.shape[l-2],y=o?i.shape[h-2]:i.shape[h-1],b=r.shape.slice(0,-2),x=i.shape.slice(0,-2),w=he(b),v=he(x),N=Xe(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,y]);O(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const k=a?[w,d,m]:[w,m,d],E=o?[v,y,p]:[v,p,y],A=zt({inputs:{x:r},backend:t,attrs:{shape:k}}),R=zt({inputs:{x:i},backend:t,attrs:{shape:E}}),D=a?A.shape[1]:A.shape[2],L=a?A.shape[2]:A.shape[1],F=o?R.shape[1]:R.shape[2],_=Math.max(w,v),V=t.data.get(A.dataId).values,Q=t.data.get(R.dataId).values,ne=Be(A.shape),Z=Be(R.shape),[B,U,K]=a?[ne[0],1,ne[1]]:[ne[0],ne[1],1],[X,se,P]=o?[1,Z[1],Z[0]]:[Z[1],1,Z[0]],j=L*F,te=Qe([_,L,F],A.dtype),le=te.values,me=t.blockSize;for(let we=0;we<_;we++){const Te=we%w,$e=we%v;for(let be=0;be<L;be+=me){const Ae=Math.min(be+me,L);for(let ze=0;ze<F;ze+=me){const it=Math.min(ze+me,F);for(let mt=0;mt<D;mt+=me){const Ye=Math.min(mt+me,D);for(let ot=be;ot<Ae;ot++)for(let gt=ze;gt<it;gt++){let Pt=0;for(let _t=mt;_t<Ye;_t++){const nr=V[Te*B+ot*U+_t*K],nn=Q[_t*X+gt*se+$e*P];Pt+=nr*nn}le[we*j+(ot*F+gt)]+=Pt}}}}}return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(N,te.dtype,te.values)}const Hde={kernelName:Ip,backendName:"cpu",kernelFunc:E4};function qde(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:h,activation:d,leakyreluAlpha:p}=s;let m,y,b;const x=[];m=E4({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:h},backend:t}),a&&(y=Kc({inputs:{a:m,b:a},backend:t}),x.push(m),m=y),d&&(b=Z0(t,m,d,o,p),x.push(m),m=b);for(const v of x)t.disposeIntermediateTensorInfo(v);return m}const Kde={kernelName:Zf,backendName:"cpu",kernelFunc:qde};const Xde=Nt(eh,n=>Math.acos(n)),Yde={kernelName:eh,backendName:"cpu",kernelFunc:Xde};const Jde=Nt(th,n=>Math.acosh(n)),Zde={kernelName:th,backendName:"cpu",kernelFunc:Jde};function Qde(n){const{inputs:e,backend:t}=n,s=e;Oe(e,"addN");const r=s.map(o=>t.data.get(o.dataId).values),i=Qe(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const l=r[o];for(let h=0;h<a.length;h++)a[h]+=l[h]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const efe={kernelName:Tp,backendName:"cpu",kernelFunc:Qde};function tfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Oe(r,"all");const o=st(i,r.shape);let l=o;const h=Zt(l,r.shape.length);let d=r;h!=null&&(d=Ls({inputs:{x:r},backend:t,attrs:{perm:h}}),l=cn(l.length,r.shape.length)),Qn("all",l,d.shape.length);const[p,m]=Un(d.shape,l),y=he(m),b=Yn(he(p),d.dtype),x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const C=v*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];N=N&&E}b[v]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(a){const v=un(p,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(w),C}return w}const nfe={kernelName:yb,backendName:"cpu",kernelFunc:tfe};function sfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Oe(r,"any");const o=st(i,r.shape);let l=o;const h=Zt(l,r.shape.length);let d=r;h!=null&&(d=Ls({inputs:{x:r},backend:t,attrs:{perm:h}}),l=cn(l.length,r.shape.length)),Qn("any",l,d.shape.length);const[p,m]=Un(d.shape,l),y=he(m),b=Yn(he(p),d.dtype),x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const C=v*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];N=N||E}b[v]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(a){const v=un(p,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(w),C}return w}const rfe={kernelName:bb,backendName:"cpu",kernelFunc:sfe};function ife(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Oe(r,"argMax");let a=st(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const h=[];o!=null&&(l=Ls({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),a=cn(a.length,l.shape.length)),a=[a[0]],Qn("argMax",a,l.shape.length);const[d,p]=Un(l.shape,a),m=he(d),y=Yn(m,"int32"),b=he(p),x=t.data.get(l.dataId).values;for(let w=0;w<y.length;++w){const v=w*b;let C=x[v],N=0;for(let k=0;k<b;++k){const E=x[v+k];E>C&&(C=E,N=k)}y[w]=N}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const afe={kernelName:Cp,backendName:"cpu",kernelFunc:ife};function ofe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;Oe(r,"argMin");let a=st(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const h=[];o!=null&&(l=Ls({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),a=cn(a.length,l.shape.length)),a=[a[0]],Qn("argMin",a,l.shape.length);const[d,p]=Un(l.shape,a),m=he(d),y=Yn(m,"int32"),b=he(p),x=t.data.get(l.dataId).values;for(let w=0;w<y.length;++w){const v=w*b;let C=x[v],N=0;for(let k=0;k<b;++k){const E=x[v+k];E<C&&(C=E,N=k)}y[w]=N}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const lfe={kernelName:Np,backendName:"cpu",kernelFunc:ofe};const ufe=Nt(nh,n=>Math.asin(n)),cfe={kernelName:nh,backendName:"cpu",kernelFunc:ufe};const hfe=Nt(sh,n=>Math.asinh(n)),dfe={kernelName:sh,backendName:"cpu",kernelFunc:hfe};const ffe=Nt(rh,n=>Math.atan(n)),pfe={kernelName:rh,backendName:"cpu",kernelFunc:ffe};const mfe=dn((n,e)=>Math.atan2(n,e)),gfe=An(ah,mfe),yfe={kernelName:ah,backendName:"cpu",kernelFunc:gfe};const bfe=Nt(ih,n=>Math.atanh(n)),xfe={kernelName:ih,backendName:"cpu",kernelFunc:bfe};function QE(n,e,t,s,r,i){const a=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Qe(r.outShape,t),w=x.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],C=r.outShape[2]*r.outShape[3],N=r.outShape[3];for(let k=0;k<r.batchSize;++k){const E=k*v,A=k*s[0];for(let R=0;R<r.inChannels;++R)for(let D=0;D<r.outHeight;++D){const L=D*a-m,F=Math.max(0,L),_=Math.min(r.inHeight,d+L),V=E+D*C;for(let Q=0;Q<r.outWidth;++Q){const ne=Q*o-y,Z=Math.max(0,ne),B=Math.min(r.inWidth,p+ne);let U=b,K=0,X=0;for(let P=F;P<_;P+=l){const j=A+P*s[1];for(let te=Z;te<B;te+=h){const le=j+te*s[2],me=n[le+R];i==="max"&&me>U?U=me:i==="avg"&&(K+=me,X++)}if(isNaN(U))break}const se=V+Q*N+R;w[se]=i==="avg"?K/X:U}}}return x}function I4(n,e,t,s,r=!1,i=!1){const a=Qe(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=Qe(e,t,n);for(let w=0;w<s.batchSize;++w)for(let v=0;v<s.inChannels;++v)for(let C=0;C<s.outHeight;++C){const N=C*o-y;let k=N;for(;k<0;)k+=h;const E=Math.min(s.inHeight,p+N);for(let A=0;A<s.outWidth;++A){const R=A*l-b;let D=R;for(;D<0;)D+=d;const L=Math.min(s.inWidth,m+R);let F=Number.NEGATIVE_INFINITY,_=-1;for(let V=k;V<E;V+=h){const Q=V-N;for(let ne=D;ne<L;ne+=d){const Z=ne-R,B=x.get(w,V,ne,v);B>F&&(F=B,r?_=i?((w*s.inHeight+V)*s.inWidth+ne)*s.inChannels+v:(V*s.inWidth+ne)*s.inChannels+v:_=Q*m+Z)}}a.set(_,w,C,A,v)}}return a}function $4(n,e,t,s,r,i){const a=r.strideDepth,o=r.strideHeight,l=r.strideWidth,h=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,v=r.padInfo.left,C=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=Qe(r.outShape,t),k=N.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],A=r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[3]*r.outShape[4],D=r.outShape[4];for(let L=0;L<r.batchSize;++L){const F=L*E,_=L*s[0];for(let V=0;V<r.inChannels;++V)for(let Q=0;Q<r.outDepth;++Q){const ne=Q*a-x;let Z=ne;for(;Z<0;)Z+=h;const B=Math.min(r.inDepth,m+ne),U=F+Q*A;for(let K=0;K<r.outHeight;++K){const X=K*o-w;let se=X;for(;se<0;)se+=d;const P=Math.min(r.inHeight,y+X),j=U+K*R;for(let te=0;te<r.outWidth;++te){const le=te*l-v;let me=le;for(;me<0;)me+=p;const we=Math.min(r.inWidth,b+le),Te=j+te*D;let $e=C,be=0,Ae=0;for(let it=Z;it<B;it+=h){const mt=_+it*s[1];for(let Ye=se;Ye<P;Ye+=d){const ot=mt+Ye*s[2];for(let gt=me;gt<we;gt+=p){const Pt=ot+gt*s[3],_t=n[Pt+V];if(i==="max"&&_t>$e?$e=_t:i==="avg"&&(be+=_t,Ae++),isNaN($e))break}if(isNaN($e))break}if(isNaN($e))break}const ze=Te+V;k[ze]=i==="avg"?be/Math.max(Ae,1):$e}}}}return N}function wfe(n,e){const t=Qe(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let w=0;w<e.inChannels;++w)for(let v=0;v<e.outDepth;++v){const C=v*s-m;let N=C;for(;N<0;)N+=a;const k=Math.min(e.inDepth,h+C);for(let E=0;E<e.outHeight;++E){const A=E*r-y;let R=A;for(;R<0;)R+=o;const D=Math.min(e.inHeight,d+A);for(let L=0;L<e.outWidth;++L){const F=L*i-b;let _=F;for(;_<0;)_+=l;const V=Math.min(e.inWidth,p+F);let Q=Number.NEGATIVE_INFINITY,ne=-1;for(let Z=N;Z<k;Z+=a){const B=Z-C;for(let U=R;U<D;U+=o){const K=U-A;for(let X=_;X<V;X+=l){const se=X-F,P=n.get(x,Z,U,X,w);P>=Q&&(Q=P,ne=B*d*p+K*d+se)}}}t.set(ne,x,v,E,L,w)}}}return t}function vfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Oe(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(a,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=qr(r.shape,i,a,h,o,l);let p;if(d.filterWidth===1&&d.filterHeight===1&&at(d.inShape,d.outShape))p=Hi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=Be(r.shape),b=QE(m,r.shape,r.dtype,y,d,"avg");p=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const Sfe={kernelName:kp,backendName:"cpu",kernelFunc:vfe};function Tfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:h}=s;Oe(r,"avgPool3d");const d=La(r.shape,i,a,1,o,l,h),p=t.data.get(r.dataId).values,m=$4(p,r.shape,r.dtype,Be(r.shape),d,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const Cfe={kernelName:Ep,backendName:"cpu",kernelFunc:Tfe};function Nfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:h}=s;Oe([r,i],"avgPool3DGrad");const d=La(i.shape,a,o,1,l,h),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,v=d.dilationDepth,C=d.dilationHeight,N=d.dilationWidth,k=d.effectiveFilterDepth,E=d.effectiveFilterHeight,A=d.effectiveFilterWidth,R=k-1-d.padInfo.front,D=A-1-d.padInfo.left,L=E-1-d.padInfo.top,F=Qe(i.shape,"float32"),_=1/(b*x*w),V=t.bufferSync(r);for(let Q=0;Q<d.batchSize;++Q)for(let ne=0;ne<d.inChannels;++ne)for(let Z=0;Z<d.inDepth;++Z)for(let B=0;B<d.inHeight;++B)for(let U=0;U<d.inWidth;++U){const K=Z-R,X=B-L,se=U-D;let P=0;for(let j=0;j<k;j+=v){const te=(K+j)/p;if(!(te<0||te>=d.outDepth||Math.floor(te)!==te))for(let le=0;le<E;le+=C){const me=(X+le)/m;if(!(me<0||me>=d.outHeight||Math.floor(me)!==me))for(let we=0;we<A;we+=N){const Te=(se+we)/y;if(Te<0||Te>=d.outWidth||Math.floor(Te)!==Te)continue;const $e=V.get(Q,te,me,Te,ne);P+=$e}}}F.set(P*_,Q,Z,B,U,ne)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const kfe={kernelName:wb,backendName:"cpu",kernelFunc:Nfe};function Efe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;Oe([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:h}=s,d=qr(a.shape,o,l,1,h),p=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,v=d.effectiveFilterHeight,C=d.effectiveFilterWidth,N=C-1-d.padInfo.left,k=v-1-d.padInfo.top,E=Qe(a.shape,"float32"),A=1/(y*b),R=t.data.get(r.dataId).values,D=Qe(r.shape,"float32",R);for(let L=0;L<d.batchSize;++L)for(let F=0;F<d.inChannels;++F)for(let _=0;_<d.inHeight;++_)for(let V=0;V<d.inWidth;++V){const Q=_-k,ne=V-N;let Z=0;for(let B=0;B<v;B+=x){const U=(Q+B)/p;if(!(U<0||U>=d.outHeight||Math.floor(U)!==U))for(let K=0;K<C;K+=w){const X=(ne+K)/m;if(X<0||X>=d.outWidth||Math.floor(X)!==X)continue;const se=D.get(L,U,X,F);Z+=se}}E.set(Z*A,L,_,V,F)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Ife={kernelName:xb,backendName:"cpu",kernelFunc:Efe};function $fe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:i,offset:a,mean:o,variance:l}=e;O(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Oe([r,o,l,i,a],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=t.data.get(r.dataId).values,p=t.data.get(o.dataId).values,m=t.data.get(l.dataId).values,y=i?t.data.get(i.dataId).values:new Float32Array([1]),b=a?t.data.get(a.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,v=y.length,C=m.length,N=p.length;let k=0,E=0,A=0,R=0;for(let D=0;D<d.length;++D)x[D]=b[k++]+(d[D]-p[E++])*y[A++]/Math.sqrt(m[R++]+h),k>=w&&(k=0),E>=N&&(E=0),A>=v&&(A=0),R>=C&&(R=0);return t.makeTensorInfo(r.shape,r.dtype,x)}const _fe={kernelName:Vp,backendName:"cpu",kernelFunc:$fe};function Afe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;Oe([r],"batchToSpaceND");const o=i.reduce((v,C)=>v*C),l=Gm(r.shape,i,o),h=Hm(l.length,i.length),d=qm(r.shape,i,o),p=YN(a,i.length),m=JN(d,a,i.length),y=zt({inputs:{x:r},backend:t,attrs:{shape:l}}),b=Ls({inputs:{x:y},backend:t,attrs:{perm:h}}),x=zt({inputs:{x:b},backend:t,attrs:{shape:d}}),w=ru({inputs:{x},backend:t,attrs:{begin:p,size:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const Rfe={kernelName:$p,backendName:"cpu",kernelFunc:Afe};function Dfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,h=KE(o,l,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,h)}const Ofe={kernelName:vb,backendName:"cpu",kernelFunc:Dfe};function Lfe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values,o=Xe(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Ffe={kernelName:Sb,backendName:"cpu",kernelFunc:Lfe};const Mfe=Nt(uh,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),zfe={kernelName:uh,backendName:"cpu",kernelFunc:Mfe};const Pfe=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(he(e.shape)),r=t.data.get(e.dataId),i=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values;for(let h=0;h<o.length;h++){const d=o[h],p=l[h];s[h]=Math.hypot(d,p)}return t.makeOutput(s,e.shape,"float32")},Bfe={kernelName:Ap,backendName:"cpu",kernelFunc:Pfe};function Xc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,i=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,i)}const Vfe={kernelName:Ub,backendName:"cpu",kernelFunc:Xc};function Yc(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=st(r,e[0].shape)[0],a=e.map(x=>x.shape);qN(a,i);let o=Pi(e.map(x=>x.shape),i);if(he(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(x=>he(x.shape)>0);if(l.length===1)return Hi({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const x=l.map(k=>su({inputs:{input:k},backend:t})),w=l.map(k=>Xc({inputs:{input:k},backend:t})),v=Yc({inputs:x,backend:t,attrs:{axis:i}}),C=Yc({inputs:w,backend:t,attrs:{axis:i}}),N=qs({inputs:{real:v,imag:C},backend:t});return x.forEach(k=>t.disposeIntermediateTensorInfo(k)),w.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(C),N}const h=l.map(x=>{const v=[-1,he(x.shape.slice(i))];return zt({inputs:{x},backend:t,attrs:{shape:v}})}),d=h.map(x=>({vals:t.data.get(x.dataId).values,shape:x.shape}));o=Pi(h.map(x=>x.shape),1);const p=h[0].shape[0]===1,m=RV(d,o,e[0].dtype,p),y=Pi(l.map(x=>x.shape),i),b=t.makeTensorInfo(y,e[0].dtype,m);return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const Ufe={kernelName:Rp,backendName:"cpu",kernelFunc:Yc};function _4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:h,dimRoundingMode:d}=s;Oe([r,i],"conv2d");const p=Fa(l),m=Vn(r.shape,i.shape,a,h,o,d,!1,p),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,v=m.padInfo.left,C=m.padInfo.top,N=m.dataFormat==="channelsLast",k=new bn(m.outShape,r.dtype),E=Be(r.shape),A=Be(i.shape),R=E[0],D=N?E[1]:E[2],L=N?E[2]:1,F=N?1:E[1],_=k.strides[0],V=N?k.strides[1]:k.strides[2],Q=N?k.strides[2]:1,ne=N?1:k.strides[1],Z=t.data.get(r.dataId).values,B=t.data.get(i.dataId).values,U=k.values;for(let K=0;K<m.batchSize;++K){const X=K*R,se=K*_;for(let P=0;P<m.outHeight;++P){const j=se+P*V,te=P*m.strideHeight-C;for(let le=0;le<y;++le){const me=te+le*x;if(me<0||me>=m.inHeight)continue;const we=le*A[0],Te=X+me*D;for(let $e=0;$e<m.outWidth;++$e){const be=j+$e*Q,Ae=$e*m.strideWidth-v;for(let ze=0;ze<b;++ze){const it=Ae+ze*w;if(it<0||it>=m.inWidth)continue;const mt=we+ze*A[1],Ye=Te+it*L;let ot=mt;for(let gt=0;gt<m.inChannels;++gt){const Pt=Z[Ye+gt*F];for(let _t=0;_t<m.outChannels;++_t)U[be+_t*ne]+=Pt*B[ot+_t];ot+=m.outChannels}}}}}}return t.makeTensorInfo(k.shape,k.dtype,U)}const jfe={kernelName:Dp,backendName:"cpu",kernelFunc:_4};function Wfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:h,filterShape:d}=s;Oe([r,i],"conv2dBackpropFilter");const p=Fa(l),m=Vn(r.shape,d,a,1,o,h,!1,p),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,v=m.dataFormat==="channelsLast",C=new bn(m.filterShape,"float32"),N=m.padInfo.left,k=m.padInfo.top,E=t.data.get(r.dataId).values,A=t.data.get(i.dataId).values,R=new bn(r.shape,r.dtype,E),D=new bn(i.shape,i.dtype,A);for(let L=0;L<x;++L){const F=Math.max(0,Math.ceil((k-L)/y)),_=Math.min(m.outHeight,(m.inHeight+k-L)/y);for(let V=0;V<w;++V){const Q=Math.max(0,Math.ceil((N-V)/b)),ne=Math.min(m.outWidth,(m.inWidth+N-V)/b);for(let Z=0;Z<m.inChannels;++Z)for(let B=0;B<m.outChannels;++B){let U=0;for(let K=0;K<m.batchSize;++K)for(let X=F;X<_;++X){const se=L+X*y-k;for(let P=Q;P<ne;++P){const j=V+P*b-N;v?U+=R.get(K,se,j,Z)*D.get(K,X,P,B):U+=R.get(K,Z,se,j)*D.get(K,B,X,P)}}C.set(U,L,V,Z,B)}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Gfe={kernelName:Cb,backendName:"cpu",kernelFunc:Wfe};function Hfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:h,dimRoundingMode:d}=s;Oe([r,i],"conv2dBackpropInput");const p=Be(i.shape),m=Be(r.shape);let y=Fa(h);const b=Vn(a,i.shape,o,1,l,d,!1,y),x=new bn(b.inShape,"float32"),w=x.values,v=t.data.get(r.dataId).values,C=t.data.get(i.dataId).values,[N,k,E]=p,{batchSize:A,filterHeight:R,filterWidth:D,inChannels:L,inHeight:F,inWidth:_,outChannels:V,outHeight:Q,outWidth:ne,strideHeight:Z,strideWidth:B}=b;y=b.dataFormat;const U=R-1-b.padInfo.top,K=D-1-b.padInfo.left,X=y==="channelsLast",se=x.strides[0],P=X?x.strides[1]:x.strides[2],j=X?x.strides[2]:1,te=X?1:x.strides[1],le=m[0],me=X?m[1]:m[2],we=X?m[2]:1,Te=X?1:m[1];for(let $e=0;$e<A;++$e)for(let be=0;be<L;++be)for(let Ae=0;Ae<F;++Ae){const ze=Ae-U,it=Math.max(0,Math.ceil(ze/Z)),mt=Math.min(Q,(R+ze)/Z);for(let Ye=0;Ye<_;++Ye){const ot=Ye-K,gt=Math.max(0,Math.ceil(ot/B)),Pt=Math.min(ne,(D+ot)/B);let _t=0;for(let nn=it;nn<mt;++nn){const kr=nn*Z-ze;for(let Ts=gt;Ts<Pt;++Ts){const Xi=Ts*B-ot,Vt=le*$e+me*nn+we*Ts,Yr=N*(R-1-kr)+k*(D-1-Xi)+E*be;for(let Jr=0;Jr<V;++Jr){const Zr=v[Vt+Te*Jr],sr=C[Yr+Jr];_t+=Zr*sr}}}const nr=se*$e+P*Ae+j*Ye+te*be;w[nr]=_t}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const qfe={kernelName:Op,backendName:"cpu",kernelFunc:Hfe};function Kfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s;Oe([r,i],"conv3d");const h=Uo(r.shape,i.shape,a,l,o),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,v=w.front,C=w.left,N=w.top,k=new bn(h.outShape,r.dtype),E=t.data.get(r.dataId).values,A=t.data.get(i.dataId).values,R=k.values,D=Be(r.shape),L=Be(i.shape);for(let F=0;F<h.batchSize;++F){const _=F*D[0],V=F*k.strides[0];for(let Q=0;Q<h.outDepth;++Q){const ne=V+Q*k.strides[1],Z=Q*h.strideDepth-v;for(let B=0;B<d;++B){const U=Z+B*y;if(U<0||U>=h.inDepth)continue;const K=B*L[0],X=_+U*D[1];for(let se=0;se<h.outHeight;++se){const P=ne+se*k.strides[2],j=se*h.strideHeight-N;for(let te=0;te<p;++te){const le=j+te*b;if(le<0||le>=h.inHeight)continue;const me=K+te*L[1],we=X+le*D[2];for(let Te=0;Te<h.outWidth;++Te){const $e=P+Te*h.outChannels,be=Te*h.strideWidth-C;for(let Ae=0;Ae<m;++Ae){const ze=be+Ae*x;if(ze<0||ze>=h.inWidth)continue;const it=me+Ae*L[2],mt=we+ze*h.inChannels;let Ye=it;for(let ot=0;ot<h.inChannels;++ot){const gt=E[mt+ot];for(let Pt=0;Pt<h.outChannels;++Pt)R[$e+Pt]+=gt*A[Ye+Pt];Ye+=h.outChannels}}}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const Xfe={kernelName:Lp,backendName:"cpu",kernelFunc:Kfe};function Yfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s;Oe([r,i],"conv3dBackpropFilterV2");const h=Be(r.shape),d=Be(i.shape),p=Uo(r.shape,l,a,1,o),m=p.strideDepth,y=p.strideHeight,b=p.strideWidth,x=p.filterDepth,w=p.filterHeight,v=p.filterWidth,C=new bn(p.filterShape,"float32"),N=C.values,[k,E,A,R]=C.strides,D=t.data.get(i.dataId).values,[L,F,_,V]=d,Q=t.data.get(r.dataId).values,[ne,Z,B,U]=h,K=p.padInfo.front,X=p.padInfo.left,se=p.padInfo.top;for(let P=0;P<x;++P){const j=Math.max(0,Math.ceil((K-P)/m)),te=Math.min(p.outDepth,(p.inDepth+K-P)/m),le=P*k;for(let me=0;me<w;++me){const we=Math.max(0,Math.ceil((se-me)/y)),Te=Math.min(p.outHeight,(p.inHeight+se-me)/y),$e=me*E+le;for(let be=0;be<v;++be){const Ae=Math.max(0,Math.ceil((X-be)/b)),ze=Math.min(p.outWidth,(p.inWidth+X-be)/b),it=be*A+$e;for(let mt=0;mt<p.inChannels;++mt){const Ye=mt*R+it;for(let ot=0;ot<p.outChannels;++ot){let gt=0;for(let Pt=0;Pt<p.batchSize;++Pt){const _t=Pt*ne,nr=Pt*L;for(let nn=j;nn<te;++nn){const Ts=(P+nn*m-K)*Z+_t,Xi=nn*F+nr;for(let Vt=we;Vt<Te;++Vt){const Jr=(me+Vt*y-se)*B+Ts,Zr=Vt*_+Xi;for(let sr=Ae;sr<ze;++sr){const Cu=(be+sr*b-X)*U+Jr,bd=sr*V+Zr;gt+=Q[Cu+mt]*D[bd+ot]}}}}N[Ye+ot]=gt}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Jfe={kernelName:Nb,backendName:"cpu",kernelFunc:Yfe};function Zfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s;Oe([r],"conv3dBackpropInputV2");const h=Be(r.shape),d=Be(i.shape),p=Uo(l,i.shape,o,1,a),m=new bn(p.inShape,"float32"),y=m.values,[b,x,w,v]=m.strides,C=t.data.get(r.dataId).values,[N,k,E,A]=h,R=t.data.get(i.dataId).values,[D,L,F,_]=d,{batchSize:V,filterDepth:Q,filterHeight:ne,filterWidth:Z,inChannels:B,inDepth:U,inHeight:K,inWidth:X,outChannels:se,outDepth:P,outHeight:j,outWidth:te,strideDepth:le,strideHeight:me,strideWidth:we}=p,Te=Q-1-p.padInfo.front,$e=ne-1-p.padInfo.top,be=Z-1-p.padInfo.left;for(let Ae=0;Ae<V;++Ae)for(let ze=0;ze<B;++ze)for(let it=0;it<U;++it){const mt=it-Te,Ye=Math.max(0,Math.ceil(mt/le)),ot=Math.min(P,(Q+mt)/le);for(let gt=0;gt<K;++gt){const Pt=gt-$e,_t=Math.max(0,Math.ceil(Pt/me)),nr=Math.min(j,(ne+Pt)/me);for(let nn=0;nn<X;++nn){const kr=nn-be,Ts=Math.max(0,Math.ceil(kr/we)),Xi=Math.min(te,(Z+kr)/we);let Vt=0;for(let Yr=Ye;Yr<ot;++Yr){const Jr=Yr*le-mt;for(let Zr=_t;Zr<nr;++Zr){const sr=Zr*me-Pt;for(let Yo=Ts;Yo<Xi;++Yo){const Cu=Yo*we-kr,bd=N*Ae+k*Yr+E*Zr+A*Yo,Pw=D*(Q-1-Jr)+L*(ne-1-sr)+F*(Z-1-Cu)+_*ze;for(let Ci=0;Ci<se;++Ci){const Cs=C[bd+Ci],Ni=R[Pw+Ci];Vt+=Cs*Ni}}}}y[b*Ae+x*it+w*gt+v*nn+ze]=Vt}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const Qfe={kernelName:kb,backendName:"cpu",kernelFunc:Zfe};const epe=Nt(ch,n=>Math.cos(n)),tpe={kernelName:ch,backendName:"cpu",kernelFunc:epe};const npe=Nt(hh,n=>Math.cosh(n)),spe={kernelName:hh,backendName:"cpu",kernelFunc:npe};function rpe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:h}=s,[d,p,m,y]=r.shape,b=i.shape[0],[x,w]=o,v=Qe([b,x,w,y],"float32"),C=t.data.get(i.dataId).values,N=t.data.get(a.dataId).values,k=t.data.get(r.dataId).values,E=Be(r.shape),A=Be(v.shape);for(let R=0;R<b;R++){const D=R*4,L=C[D],F=C[D+1],_=C[D+2],V=C[D+3],Q=N[R];if(Q>=d)continue;const ne=x>1?(_-L)*(p-1)/(x-1):0,Z=w>1?(V-F)*(m-1)/(w-1):0;for(let B=0;B<x;B++){const U=x>1?L*(p-1)+B*ne:.5*(L+_)*(p-1);if(U<0||U>p-1){for(let K=0;K<w;K++)for(let X=0;X<y;X++){const se=X+K*A[2]+B*A[1]+R*A[0];v.values[se]=h}continue}if(l==="bilinear"){const K=Math.floor(U),X=Math.ceil(U),se=U-K;for(let P=0;P<w;P++){const j=w>1?F*(m-1)+P*Z:.5*(F+V)*(m-1);if(j<0||j>m-1){for(let we=0;we<y;we++){const Te=we+P*A[2]+B*A[1]+R*A[0];v.values[Te]=h}continue}const te=Math.floor(j),le=Math.ceil(j),me=j-te;for(let we=0;we<y;we++){let Te=we+te*E[2]+K*E[1]+Q*E[0];const $e=k[Te];Te=we+le*E[2]+K*E[1]+Q*E[0];const be=k[Te];Te=we+te*E[2]+X*E[1]+Q*E[0];const Ae=k[Te];Te=we+le*E[2]+X*E[1]+Q*E[0];const ze=k[Te],it=$e+(be-$e)*me,mt=Ae+(ze-Ae)*me;Te=we+P*A[2]+B*A[1]+R*A[0],v.values[Te]=it+(mt-it)*se}}}else for(let K=0;K<w;++K){const X=w>1?F*(m-1)+K*Z:.5*(F+V)*(m-1);if(X<0||X>m-1){for(let j=0;j<y;j++){const te=j+K*A[2]+B*A[1]+R*A[0];v.values[te]=h}continue}const se=Math.round(X),P=Math.round(U);for(let j=0;j<y;j++){const te=j+se*E[2]+P*E[1]+Q*E[0],le=j+K*A[2]+B*A[1]+R*A[0];v.values[le]=k[te]}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const ipe={kernelName:Ib,backendName:"cpu",kernelFunc:rpe};function ape(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;Oe(r,"cumprod");const l=Zt([i],r.shape.length);let h=r;l!=null&&(h=Ls({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=cn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=_s(h.dtype,"int32"),m=gb(he(h.shape),p),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=o?(v,C)=>v+b-C-1:(v,C)=>v+C;for(let v=0;v<y.length;v+=b)for(let C=0;C<b;C++){const N=x(v,C);if(C===0)m[N]=a?1:y[N];else{const k=x(v,C-1);m[N]=a?y[k]*m[k]:y[N]*m[k]}}const w=t.makeTensorInfo(h.shape,p,m);if(l!=null){const v=jo(l),C=Ls({inputs:{x:w},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),C}return w}const ope={kernelName:Eb,backendName:"cpu",kernelFunc:ape};function lpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;Oe(r,"cumsum");const l=Zt([i],r.shape.length);let h=r;l!=null&&(h=Ls({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=cn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=_s(h.dtype,"int32"),m=Yn(he(h.shape),p),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=o?(v,C)=>v+b-C-1:(v,C)=>v+C;for(let v=0;v<y.length;v+=b)for(let C=0;C<b;C++){const N=x(v,C);if(C===0)m[N]=a?0:y[N];else{const k=x(v,C-1);m[N]=a?y[k]+m[k]:y[N]+m[k]}}const w=t.makeTensorInfo(h.shape,p,m);if(l!=null){const v=jo(l),C=Ls({inputs:{x:w},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),C}return w}const upe={kernelName:Fp,backendName:"cpu",kernelFunc:lpe};function cpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=KE(l,h,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const l=t.bufferSync(r),h=t.bufferSync(i),d=$V(l,h,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const hpe={kernelName:$b,backendName:"cpu",kernelFunc:cpe};function dpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s;O(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=r.shape[0],l=r.shape[1],h=r.shape[2],d=r.shape[3],p=l*i,m=h*i,y=d/(i*i),b=t.data.get(r.dataId).values,x=new Float32Array(o*p*m*y);let w=0;for(let v=0;v<o;++v)for(let C=0;C<p;++C){const N=Math.floor(C/i),k=C%i;for(let E=0;E<m;++E){const A=Math.floor(E/i),R=E%i,D=(k*i+R)*y;for(let L=0;L<y;++L){const _=L+D+d*(A+h*(N+l*v));x[w++]=b[_]}}}return t.makeTensorInfo([o,p,m,y],r.dtype,x)}const fpe={kernelName:_b,backendName:"cpu",kernelFunc:dpe};function A4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:h}=s;Oe([r,i],"depthwiseConv2DNative");const d=Be(r.shape),p=Be(i.shape);let m=l;m==null&&(m=[1,1]),O(Zn(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);const y=Vn(r.shape,i.shape,a,m,o,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:v,padInfo:C}=y,N=C.left,k=C.top,E=y.outChannels/y.inChannels,A=new bn(y.outShape,r.dtype),R=t.data.get(r.dataId).values,D=t.data.get(i.dataId).values,L=A.values;for(let F=0;F<y.batchSize;++F){const _=F*d[0],V=F*A.strides[0];for(let Q=0;Q<y.outHeight;++Q){const ne=V+Q*A.strides[1],Z=Q*y.strideHeight-k;for(let B=0;B<b;++B){const U=Z+B*w;if(U<0||U>=y.inHeight)continue;const K=B*p[0],X=_+U*d[1];for(let se=0;se<y.outWidth;++se){const P=ne+se*A.strides[2],j=se*y.strideWidth-N;for(let te=0;te<x;++te){const le=j+te*v;if(le<0||le>=y.inWidth)continue;const me=K+te*p[1],we=X+le*y.inChannels;let Te=P,$e=me;for(let be=0;be<y.inChannels;++be){const Ae=R[we+be];for(let ze=0;ze<E;++ze)L[Te+ze]+=Ae*D[$e+ze];Te+=E,$e+=E}}}}}}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const ppe={kernelName:Mp,backendName:"cpu",kernelFunc:A4};function mpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:h,filterShape:d}=s;Oe([r,i],"depthwiseConv2dNativeBackpropFilter");const p=Vn(r.shape,d,a,o,l,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=p,w=new bn(p.filterShape,"float32"),v=p.padInfo.left,C=p.padInfo.top,N=p.outChannels/p.inChannels,k=t.data.get(r.dataId).values,E=new bn(r.shape,r.dtype,k),A=t.data.get(i.dataId).values,R=new bn(i.shape,i.dtype,A);for(let D=0;D<b;++D){const L=Math.max(0,Math.ceil((C-D)/m)),F=Math.min(p.outHeight,(p.inHeight+C-D)/m);for(let _=0;_<x;++_){const V=Math.max(0,Math.ceil((v-_)/y)),Q=Math.min(p.outWidth,(p.inWidth+v-_)/y);for(let ne=0;ne<p.outChannels;++ne){const Z=Math.trunc(ne/N),B=ne%N;let U=0;for(let K=0;K<p.batchSize;++K)for(let X=L;X<F;++X){const se=D+X*m-C;for(let P=V;P<Q;++P){const j=_+P*y-v;U+=E.get(K,se,j,Z)*R.get(K,X,P,ne)}}w.set(U,D,_,Z,B)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const gpe={kernelName:Ab,backendName:"cpu",kernelFunc:mpe};function ype(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:h,inputShape:d}=s;Oe([r,i],"depthwiseConv2DNativeBackpropInput");const p=Be(r.shape),m=Be(i.shape),y=Vn(d,i.shape,a,o,l,h,!0),b=new bn(y.inShape,"float32"),x=b.values,[w,v,C]=b.strides,N=t.data.get(r.dataId).values,[k,E,A]=p,R=t.data.get(i.dataId).values,[D,L,F]=m,{batchSize:_,filterHeight:V,filterWidth:Q,inChannels:ne,inHeight:Z,inWidth:B,outChannels:U,outHeight:K,outWidth:X,strideHeight:se,strideWidth:P}=y,j=V-1-y.padInfo.top,te=Q-1-y.padInfo.left,le=U/ne;for(let me=0;me<_;++me)for(let we=0;we<ne;++we)for(let Te=0;Te<Z;++Te){const $e=Te-j,be=Math.max(0,Math.ceil($e/se)),Ae=Math.min(K,(V+$e)/se);for(let ze=0;ze<B;++ze){const it=ze-te,mt=Math.max(0,Math.ceil(it/P)),Ye=Math.min(X,(Q+it)/P);let ot=0;for(let gt=be;gt<Ae;++gt){const Pt=gt*se-$e;for(let _t=mt;_t<Ye;++_t){const nr=_t*P-it,nn=k*me+E*gt+A*_t,kr=D*(V-1-Pt)+L*(Q-1-nr)+F*we;for(let Ts=0;Ts<le;++Ts){const Xi=we*le+Ts,Vt=N[nn+Xi],Yr=R[kr+Ts];ot+=Vt*Yr}}}x[w*me+v*Te+C*ze+we]=ot}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const bpe={kernelName:Rb,backendName:"cpu",kernelFunc:ype};function xpe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=he(s.shape),i=t.data.get(s.dataId).values,a=Qe([r,r],s.dtype),o=a.values;for(let h=0;h<i.length;h++)o[h*r+h]=i[h];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,a.dtype,a.values)}const wpe={kernelName:Db,backendName:"cpu",kernelFunc:xpe};const vpe={kernelName:zp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:i,pad:a,dilations:o}=t,l=e,h=l.data.get(s.dataId).values,d=s.shape.length,p=l.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:v,outWidth:C,padInfo:N,strideHeight:k,strideWidth:E,filterHeight:A,filterWidth:R,dilationHeight:D,dilationWidth:L,outShape:F}=Em(s.shape,r.shape,i,a,"NHWC",o),_=he(F),V=F.length,Q=tn(s.dtype,_);for(let Z=0;Z<y;++Z)for(let B=0;B<v;++B){const U=B*k-N.top;for(let K=0;K<C;++K){const X=K*E-N.left;for(let se=0;se<w;++se){let P=Number.MIN_SAFE_INTEGER;for(let te=0;te<A;++te){const le=U+te*D;if(le>=0&&le<b)for(let me=0;me<R;++me){const we=X+me*L;if(we>=0&&we<x){const Te=di([Z,le,we,se],d,Be(s.shape)),$e=di([te,me,se],m,Be(r.shape)),be=h[Te]+p[$e];be>P&&(P=be)}}}const j=di([Z,B,K,se],V,Be(F));Q[j]=P}}}return{dataId:l.write(Bo(Q,s.dtype),F,s.dtype),shape:F,dtype:s.dtype}}};const Spe={kernelName:R0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:l}=t,h=e,d=vr(s.shape,h.data.get(s.dataId).values),p=vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:v,padInfo:C,strideHeight:N,strideWidth:k,filterHeight:E,filterWidth:A,dilationHeight:R,dilationWidth:D,outShape:L}=Em(s.shape,r.shape,a,o,"NHWC",l);O(i.rank===L.length,()=>`Error in ${R0}, dy must have the same rank as output ${L.length}, but got ${i.rank}`);const F=vr(L,h.data.get(i.dataId).values),_=m2(r.shape,r.dtype);for(let Q=0;Q<m;++Q)for(let ne=0;ne<w;++ne){const Z=ne*N-C.top;for(let B=0;B<v;++B){const U=B*k-C.left;for(let K=0;K<x;++K){let X=Number.MIN_SAFE_INTEGER,se=0,P=0;for(let j=0;j<E;++j){const te=Z+j*R;if(te>=0&&te<y)for(let le=0;le<A;++le){const me=U+le*D;if(me>=0&&me<b){const we=d[Q][te][me][K]+p[j][le][K];we>X&&(X=we,se=j,P=le)}}}_[se][P][K]+=F[Q][ne][B][K]}}}return{dataId:h.write(Bo(_,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const Tpe={kernelName:A0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:i}=n,{strides:a,pad:o,dilations:l}=t,h=e,d=vr(s.shape,h.data.get(s.dataId).values),p=vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:v,padInfo:C,strideHeight:N,strideWidth:k,filterHeight:E,filterWidth:A,dilationHeight:R,dilationWidth:D,outShape:L}=Em(s.shape,r.shape,a,o,"NHWC",l);O(i.rank===L.length,()=>`Error in ${A0}, dy must have the same rank as output ${L.length}, but got ${i.rank}`);const F=vr(L,h.data.get(i.dataId).values),_=m2(s.shape,s.dtype);for(let Q=0;Q<m;++Q)for(let ne=0;ne<w;++ne){const Z=ne*N-C.top;for(let B=0;B<v;++B){const U=B*k-C.left;for(let K=0;K<x;++K){let X=Number.MIN_SAFE_INTEGER,se=Z<0?0:Z,P=U<0?0:U;for(let j=0;j<E;++j){const te=Z+j*R;if(te>=0&&te<y)for(let le=0;le<A;++le){const me=U+le*D;if(me>=0&&me<b){const we=d[Q][te][me][K]+p[j][le][K];we>X&&(X=we,se=te,P=me)}}}_[Q][se][P][K]+=F[Q][ne][B][K]}}}return{dataId:h.write(Bo(_,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Cpe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:i,options:a}=s,{contextOptions:o,imageOptions:l}=a||{},h=l?.alpha||1,d=o?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const p=i.getContext(d,o?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],x=t.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(y*m*4);for(let N=0;N<m*y;++N){const k=[0,0,0,255*h];for(let A=0;A<b;A++){const R=x[N*b+A];if(r.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(r.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);b===1?(k[0]=R*w,k[1]=R*w,k[2]=R*w):k[A]=R*w}const E=N*4;v[E+0]=Math.round(k[0]),v[E+1]=Math.round(k[1]),v[E+2]=Math.round(k[2]),v[E+3]=Math.round(k[3])}i.width=y,i.height=m;const C=new ImageData(v,y,m);return p.putImageData(C,0,0),r}const Npe={kernelName:Ob,backendName:"cpu",kernelFunc:Cpe};function rg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Oe(r,"sum");let o;r.dtype==="bool"?o=zo({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):o=Hi({inputs:{x:r},backend:t});const l=o.shape.length,h=st(i,o.shape),d=Zt(h,l);let p=h,m=o;d!=null&&(m=Ls({inputs:{x:o},backend:t,attrs:{perm:d}}),p=cn(p.length,l)),Qn("sum",p,m.shape.length);const[y,b]=Un(m.shape,p),x=_s(m.dtype,"int32");let w=Y0(t,y,x);const v=he(b),C=t.data.get(w.dataId).values,N=t.data.get(m.dataId).values;for(let k=0;k<C.length;++k){const E=k*v;let A=0;for(let R=0;R<v;++R)A+=N[E+R];C[k]=A}if(a){const k=un(w.shape,h),E=w;w=zt({inputs:{x:w},backend:t,attrs:{shape:k}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(o),d!=null&&t.disposeIntermediateTensorInfo(m),w}const kpe={kernelName:ym,backendName:"cpu",kernelFunc:rg};function Epe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=ik(r,i.length);ok(a.length,l,i);const{path:h,steps:d}=lk(o,l),p=d.length;let m=null,y=a.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:v,expandDims:C}=ak(y,l[w]);let N;uk(v)?N=i[w]:(N=Ls({inputs:{x:i[w]},backend:t,attrs:{perm:v}}),b.push(N));const k=N.shape.slice();for(let E=0;E<C.length;++E)k.splice(C[E],0,1);at(N.shape,k)||(N=zt({inputs:{x:N},backend:t,attrs:{shape:k}}),b.push(N)),m===null?m=N:(m=Ow({inputs:{a:N,b:m},backend:t}),b.push(m))}x<p-1&&(h[x]>=0&&(m=rg({inputs:{x:m},backend:t,attrs:{axis:h[x]-(a.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const Ipe={kernelName:Lb,backendName:"cpu",kernelFunc:Epe};function $pe(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;Oe([s,r],"eluGrad");const i=new Float32Array(he(r.shape)),a=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const h=a[l];h>=0?i[l]=o[l]:i[l]=o[l]*(h+1)}return t.makeTensorInfo(r.shape,"float32",i)}const _pe={kernelName:Fb,backendName:"cpu",kernelFunc:$pe};const Ape=ZN,Rpe=QN,Dpe=ek,Ope=tk,Lpe=nk,Fpe=sk,Mpe=Nt(ph,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Ape*t);return e*(1-((((Fpe*s+Lpe)*s+Ope)*s+Dpe)*s+Rpe)*s*Math.exp(-t*t))}),zpe={kernelName:ph,backendName:"cpu",kernelFunc:Mpe};function Q0(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:i}=s,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(O(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),zt({inputs:{x:r},backend:t,attrs:{shape:o}})}const Ppe={kernelName:Bp,backendName:"cpu",kernelFunc:Q0};const Bpe=dn((n,e)=>n/e),eI=An(dh,Bpe),pC={kernelName:dh,backendName:"cpu",kernelFunc:eI};function R4(n,e,t){const s=n.shape,r=s[0],i=s[1],a=t.data.get(n.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,h=[r,i],d=he(h),p=zn("float32",d),m=zn("float32",d);for(let w=0;w<r;w++){const v=ru({inputs:{x:o},backend:t,attrs:{begin:[w,0],size:[1,i]}}),C=ru({inputs:{x:l},backend:t,attrs:{begin:[w,0],size:[1,i]}}),N=qs({inputs:{real:v,imag:C},backend:t}),{real:k,imag:E}=Vpe(N,e,t),A=$a(k,E);for(let R=0;R<i;R++){const D=rk(A,R);p[w*i+R]=D.real,m[w*i+R]=D.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(N)}const y=t.makeTensorInfo(h,"float32",p),b=t.makeTensorInfo(h,"float32",m),x=qs({inputs:{real:y,imag:b},backend:t});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}function Vpe(n,e,t){const s=he(n.shape),r=t.data.get(n.dataId),i=t.data.get(r.complexTensorInfos.real.dataId).values,a=t.data.get(r.complexTensorInfos.imag.dataId).values;if(Upe(s)){const o=mC(i,a,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const h=t.makeTensorInfo(l,"float32",o.real),d=t.makeTensorInfo(l,"float32",o.imag),p=t.makeTensorInfo([],"float32",Oa(s,"float32")),m=Hi({inputs:{x:p},backend:t}),y=pC.kernelFunc({inputs:{a:h,b:p},backend:t}),b=pC.kernelFunc({inputs:{a:d,b:m},backend:t}),x=t.data.get(y.dataId).values,w=t.data.get(b.dataId).values;return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return o}else{const o=$a(i,a),l=jpe(o,s,e);return CP(l)}}function Upe(n){return(n&n-1)===0}function mC(n,e,t,s,r){if(t===1)return{real:n,imag:e};const i=$a(n,e),a=t/2,o=NP(i),l=o.real,h=o.imag,d=[l.length],p=r.makeTensorInfo(d,"float32",l),m=r.makeTensorInfo(d,"float32",h),y=qs({inputs:{real:p,imag:m},backend:r}),b=kP(i),x=b.real,w=b.imag,v=[x.length],C=r.makeTensorInfo(v,"float32",x),N=r.makeTensorInfo(v,"float32",w),k=qs({inputs:{real:C,imag:N},backend:r}),E=mC(l,h,a,s,r),A=E.real,R=E.imag,D=[A.length],L=r.makeTensorInfo(D,"float32",A),F=r.makeTensorInfo(D,"float32",R),_=qs({inputs:{real:L,imag:F},backend:r}),V=mC(x,w,a,s,r),Q=V.real,ne=V.imag,Z=[Q.length],B=r.makeTensorInfo(Z,"float32",Q),U=r.makeTensorInfo(Z,"float32",ne),K=qs({inputs:{real:B,imag:U},backend:r}),X=IP(t,s),se=[X.real.length],P=r.makeTensorInfo(se,"float32",X.real),j=r.makeTensorInfo(se,"float32",X.imag),te=qs({inputs:{real:P,imag:j},backend:r}),le=Ow({inputs:{a:te,b:K},backend:r}),me=Kc({inputs:{a:_,b:le},backend:r}),we=ZE({inputs:{a:_,b:le},backend:r}),Te=su({inputs:{input:me},backend:r}),$e=su({inputs:{input:we},backend:r}),be=Xc({inputs:{input:me},backend:r}),Ae=Xc({inputs:{input:we},backend:r}),ze=Yc({inputs:[Te,$e],backend:r,attrs:{axis:0}}),it=Yc({inputs:[be,Ae],backend:r,attrs:{axis:0}}),mt=r.data.get(ze.dataId).values,Ye=r.data.get(it.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(be),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(Ae),r.disposeIntermediateTensorInfo(ze),r.disposeIntermediateTensorInfo(it),{real:mt,imag:Ye}}function jpe(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let i=0,a=0;for(let o=0;o<e;o++){const l=$P(r*o,e,t),h=rk(n,o);i+=h.real*l.real-h.imag*l.imag,a+=h.real*l.imag+h.imag*l.real}t&&(i/=e,a/=e),EP(s,i,a,r)}return s}function Wpe(n){const{inputs:e,backend:t}=n,{input:s}=e,r=he(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=zt({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),l=R4(o,!1,t),h=zt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),h}const Gpe={kernelName:Mb,backendName:"cpu",kernelFunc:Wpe};function tI(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:i}=t,a=i||uu(r),o=tn(a,he(s));return qpe(o,r,a),e.makeTensorInfo(s,a,o)}const Hpe={kernelName:zb,backendName:"cpu",kernelFunc:tI};function qpe(n,e,t){n.fill(e)}const Kpe={kernelName:Pb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,i=zn(s.dtype,he(s.shape)),[a,o,l,h]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<a;m++){const y=m*l*o*h;for(let b=0;b<o;b++){const x=b*(l*h);for(let w=0;w<l;w++){const v=w*h;for(let C=0;C<h;C++){const N=Math.round(l-w-1),k=y+x+v+C;let E=d[k];if(N>=0&&N<l){const A=N*h,R=y+x+A+C;E=d[R]}i[k]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Xpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=_4({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(a){const w=x;if(d==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const v=zt({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});x=Kc({inputs:{a:x,b:v},backend:t}),t.disposeIntermediateTensorInfo(v)}else x=Kc({inputs:{a:x,b:a},backend:t});t.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const v=zt({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});x=Z0(t,x,y,v,b),t.disposeIntermediateTensorInfo(v)}else x=Z0(t,x,y,o,b);t.disposeIntermediateTensorInfo(w)}return x}const Ype={kernelName:Qf,backendName:"cpu",kernelFunc:Xpe};function Jpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=A4({inputs:{x:r,filter:i},backend:t,attrs:{strides:l,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(a){const w=x;x=Kc({inputs:{a:x,b:a},backend:t}),t.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=Z0(t,x,y,o,b),t.disposeIntermediateTensorInfo(w)}return x}const Zpe={kernelName:ep,backendName:"cpu",kernelFunc:Jpe};function Qpe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=he(s.shape),a=r.shape,o=a[a.length-1],[l,h,d,p]=lw(s,r);if(h===0)return t.makeTensorInfo(l,s.dtype,[]);const m=t.data.get(r.dataId).values,y=t.bufferSync(s),b=BV(m,y,s.dtype,h,o,d,p,s.shape,i);return t.makeTensorInfo(l,s.dtype,b.values)}const eme={kernelName:Bb,backendName:"cpu",kernelFunc:Qpe};function tme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s;Oe([r,i],"gatherV2");const l=st(a,r.shape)[0],h=t.data.get(i.dataId).values,d=r.shape[l];for(let k=0;k<h.length;++k){const E=h[k];O(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=o;o==null&&(p=0);const m=he(i.shape),y=hk(r,i,l,p),b=zt({inputs:{x:r},backend:t,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=zt({inputs:{x:i},backend:t,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],v=t.bufferSync(x),C=t.bufferSync(b),N=VV(C,v,w);return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.makeTensorInfo(y.outputShape,N.dtype,N.values)}const nme={kernelName:Up,backendName:"cpu",kernelFunc:tme};function sme(n){const{inputs:e,backend:t}=n,{input:s}=e,r=he(s.shape),i=s.shape[s.shape.length-1],a=r/i,o=zt({inputs:{x:s},backend:t,attrs:{shape:[a,i]}}),l=R4(o,!0,t),h=zt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),h}const rme={kernelName:Vb,backendName:"cpu",kernelFunc:sme};const ime=Nt(vh,n=>Number.isFinite(n)?1:0,"bool"),ame={kernelName:vh,backendName:"cpu",kernelFunc:ime};const ome=Nt(Sh,n=>Math.abs(n)===1/0?1:0,"bool"),lme={kernelName:Sh,backendName:"cpu",kernelFunc:ome};const ume=Nt(Th,n=>Number.isNaN(n)?1:0,"bool"),cme={kernelName:Th,backendName:"cpu",kernelFunc:ume};function hme(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=HV(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const dme={kernelName:jb,backendName:"cpu",kernelFunc:hme};const fme=Nt(Nh,n=>Math.log1p(n)),pme={kernelName:Nh,backendName:"cpu",kernelFunc:fme};const mme=dn((n,e)=>n&&e),gme=An(qp,mme,null,"bool"),yme={kernelName:qp,backendName:"cpu",kernelFunc:gme};const bme=Nt(Kp,n=>n?0:1,"bool"),xme={kernelName:Kp,backendName:"cpu",kernelFunc:bme};const wme=dn((n,e)=>n||e),vme=An(Xp,wme,null,"bool"),Sme={kernelName:Xp,backendName:"cpu",kernelFunc:vme};function Tme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s;Oe(r,"LRN");const h=r.shape[3],d=h-1,p=t.data.get(r.dataId).values,m=he(r.shape),y=new Float32Array(m);function b(x){const w=x%h;let v=x-w+Math.max(0,w-i);const C=x-w+Math.min(w+i,d);let N=0;for(;v<=C;v++){const k=p[v];N+=k*k}return N}for(let x=0;x<m;x++){const w=b(x),v=p[x]*Math.pow(a+o*w,-l);y[x]=v}return t.makeTensorInfo(r.shape,r.dtype,y)}const Cme={kernelName:Yp,backendName:"cpu",kernelFunc:Tme};function Nme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:h,beta:d}=s;Oe(a,"LRNGrad");const p=he(a.shape),m=a.shape[3],y=t.data.get(a.dataId).values,b=t.data.get(r.dataId).values,x=t.data.get(i.dataId).values,w=new Float32Array(p),v=p;for(let C=0;C<v;C++){const N=C%m,k=C-N+Math.max(0,N-o),E=C-N+Math.min(m,N+o+1);let A=0;for(let R=k;R<E;R++)A+=Math.pow(b[R],2);A=h*A+l;for(let R=k;R<E;R++){let D=-2*h*d*b[R]*x[C]/A;C===R&&(D+=Math.pow(A,-d)),D*=y[C],w[R]+=D}}return t.makeTensorInfo(a.shape,r.dtype,w)}const kme={kernelName:Wb,backendName:"cpu",kernelFunc:Nme};function D4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=t;let l=r.shape;const h=l.length,d=st(i,l);let p=d;const m=Zt(p,h);let y=o.data.get(r.dataId).values;if(m!=null){const k=new Array(h);for(let E=0;E<k.length;E++)k[E]=l[m[E]];y=YE(y,l,r.dtype,m,k),p=cn(p.length,h),l=k}Oe(r,"max"),Qn("max",p,h);const[b,x]=Un(l,p),w=he(x),v=KV(y,w,b,r.dtype),C=o.write(v,b,r.dtype);let N=b;return a&&(N=un(b,d)),{dataId:C,shape:N,dtype:r.dtype}}const Eme={kernelName:Jp,backendName:"cpu",kernelFunc:D4};function Ime(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Oe(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(a,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=qr(r.shape,i,a,h,o,l);let p;if(d.filterWidth===1&&d.filterHeight===1&&at(d.inShape,d.outShape))p=Hi({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=Be(r.shape),b=QE(m,r.shape,r.dtype,y,d,"max");p=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const $me={kernelName:Zp,backendName:"cpu",kernelFunc:Ime};function _me(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:h}=s;Oe(r,"maxPool3d");const d=La(r.shape,i,a,1,o,l,h),p=t.data.get(r.dataId).values,m=$4(p,r.shape,r.dtype,Be(r.shape),d,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const Ame={kernelName:Qp,backendName:"cpu",kernelFunc:_me};function Rme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:h}=s;Oe([r,i],"maxPool3DGrad");const d=La(i.shape,a,o,1,l,h),p=t.bufferSync(i),m=wfe(p,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,v=d.dilationHeight,C=d.dilationWidth,N=d.effectiveFilterDepth,k=d.effectiveFilterHeight,E=d.effectiveFilterWidth,A=N-1-d.padInfo.front,R=E-1-d.padInfo.left,D=k-1-d.padInfo.top,L=Qe(i.shape,"float32"),F=t.bufferSync(r);for(let _=0;_<d.batchSize;++_)for(let V=0;V<d.inChannels;++V)for(let Q=0;Q<d.inDepth;++Q)for(let ne=0;ne<d.inHeight;++ne)for(let Z=0;Z<d.inWidth;++Z){const B=Q-A,U=ne-D,K=Z-R;let X=0;for(let se=0;se<N;se+=w){const P=(B+se)/y;if(!(P<0||P>=d.outDepth||Math.floor(P)!==P))for(let j=0;j<k;j+=v){const te=(U+j)/b;if(!(te<0||te>=d.outHeight||Math.floor(te)!==te))for(let le=0;le<E;le+=C){const me=(K+le)/x;if(me<0||me>=d.outWidth||Math.floor(me)!==me)continue;const we=N*k*E-1-m.get(_,P,te,me,V),Te=se*k*E+j*E+le,$e=we===Te?1:0;if($e===0)continue;const be=F.get(_,P,te,me,V);X+=be*$e}}}L.set(X,_,Q,ne,Z,V)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}const Dme={kernelName:Hb,backendName:"cpu",kernelFunc:Rme};function Ome(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;Oe([i,a],"maxPoolGrad");const{filterSize:l,strides:h,pad:d,dimRoundingMode:p}=s,m=qr(o.shape,l,h,1,d,p),y=t.data.get(o.dataId).values,b=Qe(m.outShape,o.dtype,I4(y,o.shape,o.dtype,m).values),x=m.strideHeight,w=m.strideWidth,v=m.dilationHeight,C=m.dilationWidth,N=m.effectiveFilterHeight,k=m.effectiveFilterWidth,E=k-1-m.padInfo.left,A=N-1-m.padInfo.top,R=Qe(o.shape,"float32"),D=t.data.get(r.dataId).values,L=Qe(r.shape,"float32",D);for(let F=0;F<m.batchSize;++F)for(let _=0;_<m.inChannels;++_)for(let V=0;V<m.inHeight;++V)for(let Q=0;Q<m.inWidth;++Q){const ne=V-A,Z=Q-E;let B=0;for(let U=0;U<N;U+=v){const K=(ne+U)/x;if(!(K<0||K>=m.outHeight||Math.floor(K)!==K))for(let X=0;X<k;X+=C){const se=(Z+X)/w;if(se<0||se>=m.outWidth||Math.floor(se)!==se)continue;const P=N*k-1-b.get(F,K,se,_),j=U*k+X,te=P===j?1:0;if(te===0)continue;const le=L.get(F,K,se,_);B+=le*te}}R.set(B,F,V,Q,_)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const Lme={kernelName:Gb,backendName:"cpu",kernelFunc:Ome};function Fme(n,e,t,s,r){const i=Be(e),a=QE(n,e,t,i,r,"max"),o=I4(n,e,t,r,!0,s);return[a.values,o.values]}const Mme={kernelName:qb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,l=t;Oe(s,"MaxPoolWithArgmax");const h=l.data.get(s.dataId).values,d=qr(s.shape,r,i,[1,1],a),[p,m]=Fme(h,s.shape,s.dtype,o,d),y=l.write(p,d.outShape,s.dtype),b=l.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function zme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=st(i,r.shape),h=Un(r.shape,o)[1],d=he(h),p=[],m=t.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const y=zo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});p.push(y);const b=eI({inputs:{a:y,b:m},backend:t});p.push(b);const x=rg({inputs:{x:b},backend:t,attrs:{axis:i,keepDims:a}});return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const Pme={kernelName:em,backendName:"cpu",kernelFunc:zme};function Bme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;Oe(r,"min");const o=st(i,r.shape);let l=o;const h=Zt(l,r.shape.length);let d=r;h!=null&&(d=Ls({inputs:{x:r},backend:t,attrs:{perm:h}}),l=cn(l.length,r.shape.length)),Qn("min",l,d.shape.length);const[p,m]=Un(d.shape,l),y=he(m),b=Yn(he(p),d.dtype),x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const C=v*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];(Number.isNaN(E)||E<N)&&(N=E)}b[v]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(p,d.dtype,b);if(a){const v=un(p,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(w),C}return w}const Vme={kernelName:tm,backendName:"cpu",kernelFunc:Bme};function Ume(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,mode:a}=s;Oe(r,"mirrorPad");const o=i.map((N,k)=>N[0]+r.shape[k]+N[1]),l=i.map(N=>N[0]),h=i.map((N,k)=>N[0]+r.shape[k]),d=a==="reflect"?0:1,p=t.data.get(r.dataId).values,m=r.shape.length,y=Be(r.shape),b=he(o),x=o.length,w=Be(o),v=zn(r.dtype,b);for(let N=0;N<b;N++){let k=cu(N,x,w);for(let A=0;A<x;A++)k[A]<l[A]?k[A]=l[A]*2-k[A]-d:k[A]>=h[A]&&(k[A]=(h[A]-1)*2-k[A]+d);k=k.map((A,R)=>A-l[R]);const E=di(k,m,y);v[N]=p[E]}return{dataId:t.write(v,o,r.dtype),shape:o,dtype:r.dtype}}const jme={kernelName:nm,backendName:"cpu",kernelFunc:Ume};const Wme=dn(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),Gme=An(Ih,Wme),Hme={kernelName:Ih,backendName:"cpu",kernelFunc:Gme};function O4(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=r.shape.length;let o=i;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=st([o],r.shape),h=D4({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),d=un(h.shape,l),p=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),m=ZE({inputs:{a:r,b:p},backend:t}),y=FV({inputs:{x:m},backend:t}),b=rg({inputs:{x:y},backend:t,attrs:{axis:l,keepDims:!1}}),x=zt({inputs:{x:b},backend:t,attrs:{shape:d}}),w=eI({inputs:{a:y,b:x},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const qme={kernelName:wm,backendName:"cpu",kernelFunc:O4};function Kme(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s;Oe(r,"multinomial");const l=o?r:O4({inputs:{logits:r},backend:t,attrs:{dim:-1}}),h=l.shape[0],d=l.shape[1],p=t.data.get(l.dataId).values,m=[h,i],y=Yn(he(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=p[x];for(let N=1;N<w.length;++N)w[N]=w[N-1]+p[x+N];const v=td.alea(a.toString()),C=b*i;for(let N=0;N<i;++N){const k=v();y[C+N]=w.length;for(let E=0;E<w.length;E++)if(k<w[E]){y[C+N]=E;break}}}return o||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(m,"int32",y)}const Xme={kernelName:Kb,backendName:"cpu",kernelFunc:Kme};const Yme=sw;function Jme(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;Oe(r,"NonMaxSuppression");const h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,{selectedIndices:p}=Yme(h,d,a,o,l);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Zme={kernelName:Xb,backendName:"cpu",kernelFunc:Jme};const Qme=rw;function ege(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:h}=s;Oe(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,{selectedIndices:m,validOutputs:y}=Qme(d,p,a,o,l,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const tge={kernelName:Yb,backendName:"cpu",kernelFunc:ege};const nge=iw;function sge(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:h}=s;Oe(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,p=t.data.get(i.dataId).values,m=a,y=o,b=l,x=h,{selectedIndices:w,selectedScores:v}=nge(d,p,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const rge={kernelName:Jb,backendName:"cpu",kernelFunc:sge};function ige(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:l}=s;Oe(r,"oneHot");const h=he(r.shape),d=new Float32Array(h*a);d.fill(l);const p=t.data.get(r.dataId).values;for(let m=0;m<h;++m)p[m]>=0&&p[m]<a&&(d[m*a+p[m]]=o);return t.makeTensorInfo([...r.shape,a],i,d)}const age={kernelName:am,backendName:"cpu",kernelFunc:ige};function eb(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=su({inputs:{input:s},backend:t}),i=eb({inputs:{x:r},backend:t}),a=Xc({inputs:{input:s},backend:t}),o=eb({inputs:{x:a},backend:t}),l=qs({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return tI({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const oge={kernelName:Cm,backendName:"cpu",kernelFunc:eb};function L4(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=su({inputs:{input:s},backend:t}),i=L4({inputs:{x:r},backend:t}),a=Xc({inputs:{input:s},backend:t}),o=eb({inputs:{x:a},backend:t}),l=qs({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return tI({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const lge={kernelName:im,backendName:"cpu",kernelFunc:L4};function F4(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return Q0({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{Jn(i,d.shape,"All tensors passed to stack must have matching shapes"),O(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const p=Q0({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),h=Yc({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const uge={kernelName:om,backendName:"cpu",kernelFunc:F4};function cge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;Oe(r,"pad");const o=i.map((C,N)=>C[0]+r.shape[N]+C[1]),l=i.map(C=>C[0]),h=t.data.get(r.dataId).values,d=he(r.shape),p=r.shape.length,m=Be(r.shape),y=he(o),b=o.length,x=Be(o),w=zn(r.dtype,y);a!==0&&w.fill(a);for(let C=0;C<d;C++){const k=cu(C,p,m).map((A,R)=>A+l[R]),E=di(k,b,x);w[E]=h[C]}return{dataId:t.write(w,o,r.dtype),shape:o,dtype:r.dtype}}const M4={kernelName:lm,backendName:"cpu",kernelFunc:cge};const hge=dn((n,e)=>Math.pow(n,e)),dge=An(_h,hge),fge={kernelName:_h,backendName:"cpu",kernelFunc:dge};function pge(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,l=r.map(v=>t.data.get(v.dataId).values),h=r.map(v=>v.shape),d=t.data.get(i.dataId).values,p=t.data.get(a.dataId).values,[m,y,b]=e4(l,h,d,i.shape,i.dtype,p,a.shape),x=m.map(v=>t.makeTensorInfo([v.length],"int32",v)),w=t.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const mge={kernelName:Zb,backendName:"cpu",kernelFunc:pge};function gge(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[h,d]=t4(a,s.shape,s.dtype,o,r.shape,l,i.shape),p=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const yge={kernelName:Qb,backendName:"cpu",kernelFunc:gge};function bge(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,h=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,p=t.data.get(a.dataId).values,m=o.map(w=>t.data.get(w.dataId).values),y=o.map(w=>w.shape),[b,x]=n4(h,r.shape,d,i.shape,i.dtype,p,a.shape,m,y,l);return t.makeTensorInfo(b,i.dtype,x)}const xge={kernelName:ex,backendName:"cpu",kernelFunc:bge};function wge(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:i,step:a}=t,o=s4(s,r,a,i);return e.makeTensorInfo([o.length],i,o)}const vge={kernelName:tx,backendName:"cpu",kernelFunc:wge};const Sge=Nt(Ah,n=>1/n),Tge={kernelName:Ah,backendName:"cpu",kernelFunc:Sge};function Cge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;Oe(r,"resizeBilinear");const l=Be(r.shape),[h,d]=o,[p,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(he([p,h,d,b])),v=[i&&h>1?m-1:m,i&&d>1?y-1:y],C=[i&&h>1?h-1:h,i&&d>1?d-1:d];let N=0;const k=v[0]/C[0],E=v[1]/C[1];for(let A=0;A<p;A++)for(let R=0;R<h;R++){let D;a?D=k*(R+.5)-.5:D=k*R;const L=Math.max(0,Math.floor(D)),F=D-L,_=Math.min(m-1,Math.ceil(D)),V=A*l[0]+L*l[1],Q=A*l[0]+_*l[1];for(let ne=0;ne<d;ne++){let Z;a?Z=E*(ne+.5)-.5:Z=E*ne;const B=Math.max(0,Math.floor(Z)),U=Z-B,K=Math.min(y-1,Math.ceil(Z)),X=V+B*l[2],se=Q+B*l[2],P=V+K*l[2],j=Q+K*l[2];for(let te=0;te<b;te++){const le=x[X+te],me=x[se+te],we=x[P+te],Te=x[j+te],$e=le+(we-le)*U,be=me+(Te-me)*U,Ae=$e+(be-$e)*F;w[N++]=Ae}}}return t.makeTensorInfo([p,h,d,b],"float32",w)}const Nge={kernelName:fm,backendName:"cpu",kernelFunc:Cge};function kge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;Oe([i,r],"resizeBilinearGrad");const o=Be(r.shape),[l,h,d,p]=r.shape,[,m,y]=i.shape,b=new Float32Array(l*h*d*p),x=[a&&m>1?h-1:h,a&&y>1?d-1:d],w=[a&&m>1?m-1:m,a&&y>1?y-1:y],v=x[0]/w[0],C=x[1]/w[1],N=t.data.get(i.dataId).values;let k=0;for(let E=0;E<l;E++){const A=E*o[0];for(let R=0;R<m;R++){const D=R*v,L=Math.floor(D),F=Math.min(Math.ceil(D),h-1),_=A+L*o[1],V=A+F*o[1],Q=D-L,ne=1-Q;for(let Z=0;Z<y;Z++){const B=Z*C,U=Math.floor(B),K=Math.min(Math.ceil(B),d-1),X=B-U,se=1-X,P=_+U*o[2],j=_+K*o[2],te=V+U*o[2],le=V+K*o[2],me=ne*se,we=ne*X,Te=Q*se,$e=Q*X;for(let be=0;be<p;be++){const Ae=N[k++];b[P+be]+=Ae*me,b[j+be]+=Ae*we,b[te+be]+=Ae*Te,b[le+be]+=Ae*$e}}}}return t.makeTensorInfo([l,d,h,p],"float32",b)}const Ege={kernelName:rx,backendName:"cpu",kernelFunc:kge};function Ige(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s;Oe(r,"resizeNearestNeighbor");const l=Be(r.shape),[h,d]=o,[p,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(p*h*d*b),v=[i&&h>1?m-1:m,i&&d>1?y-1:y],C=[i&&h>1?h-1:h,i&&d>1?d-1:d],N=v[0]/C[0],k=v[1]/C[1];let E=0;for(let A=0;A<p;A++){const R=A*l[0];for(let D=0;D<h;D++){const L=a?N*(D+.5):N*D;let F=Math.min(m-1,i?Math.round(L):Math.floor(L));a&&(F=Math.max(0,F));const _=R+F*l[1];for(let V=0;V<d;V++){const Q=a?k*(V+.5):k*V;let ne=Math.min(y-1,i?Math.round(Q):Math.floor(Q));a&&(ne=Math.max(0,ne));const Z=_+ne*l[2];for(let B=0;B<b;B++){const U=x[Z+B];w[E++]=U}}}}return t.makeTensorInfo([p,h,d,b],r.dtype,w)}const $ge={kernelName:dm,backendName:"cpu",kernelFunc:Ige};function _ge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s;Oe([i,r],"resizeNearestNeighborGrad");const o=Be(r.shape),l=Be(i.shape),[h,d,p,m]=r.shape,[,y,b]=i.shape,x=new Float32Array(h*d*p*m),w=t.data.get(i.dataId).values,v=[a&&y>1?d-1:d,a&&b>1?p-1:p],C=[a&&y>1?y-1:y,a&&b>1?b-1:b],N=v[0]/C[0],k=v[1]/C[1],E=1/N,A=1/k,R=Math.ceil(E)*2+2,D=Math.ceil(A)*2+2;for(let L=0;L<h;L++){const F=L*o[0];for(let _=0;_<d;_++){const V=F+_*o[1],Q=Math.floor(_*E),ne=Math.floor(Q-R/2);for(let Z=0;Z<p;Z++){const B=V+Z*o[2],U=Math.floor(Z*A),K=Math.floor(U-D/2);for(let X=0;X<m;X++){let se=0;for(let P=0;P<R;P++){const j=P+ne;if(j<0||j>=y)continue;const te=F+j*l[1],le=j*N,me=Math.min(d-1,a?Math.round(le):Math.floor(le));if(_===me)for(let we=0;we<D;we++){const Te=we+K;if(Te<0||Te>=b)continue;const $e=te+Te*l[2],be=Te*k,Ae=Math.min(p-1,a?Math.round(be):Math.floor(be));Z===Ae&&(se+=w[$e+X])}}x[B+X]=se}}}}return t.makeTensorInfo(r.shape,r.dtype,x)}const Age={kernelName:sx,backendName:"cpu",kernelFunc:_ge};function Rge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s;Oe(r,"reverse");const a=r.shape.length,o=st(i,r.shape);if(a===0)return Hi({inputs:{x:r},backend:t});const l=new bn(r.shape,r.dtype),h=t.bufferSync(r);for(let d=0;d<l.size;d++){const p=l.indexToLoc(d),m=p.slice();o.forEach(y=>m[y]=r.shape[y]-1-m[y]),l.set(h.get(...m),...p)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Dge={kernelName:pm,backendName:"cpu",kernelFunc:Rge};const Oge={kernelName:vx,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,l=zn(s.dtype,he(s.shape)),[h,d,p,m]=s.shape,[y,b]=XN(a,d,p),x=255,w=Math.sin(r),v=Math.cos(r),C=o.data.get(s.dataId).values;for(let k=0;k<h;k++){const E=k*p*d*m;for(let A=0;A<d;A++){const R=A*(p*m);for(let D=0;D<p;D++){const L=D*m;for(let F=0;F<m;F++){const _=[h,A,D,F],V=_[2],Q=_[1];let ne=(V-y)*v-(Q-b)*w,Z=(V-y)*w+(Q-b)*v;ne=Math.round(ne+y),Z=Math.round(Z+b);let B=i;if(typeof i!="number"&&(F===3?B=x:B=i[F]),ne>=0&&ne<p&&Z>=0&&Z<d){const K=Z*(p*m),X=ne*m,se=E+K+X+F;B=C[se]}const U=E+R+L+F;l[U]=B}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const Lge=Nt(Oh,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Fge={kernelName:Oh,backendName:"cpu",kernelFunc:Lge};function Mge(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:h,strides:d,outputSize:p}=qo(i,r,a),m=!0,y=t.bufferSync(r),b=t.bufferSync(i),x=Fl(y,b,a,p,h,l,o,d,0,m);return t.makeTensorInfo(a,x.dtype,x.values)}const zge={kernelName:ix,backendName:"cpu",kernelFunc:Mge};function Pge(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function Bge(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function Vge(n,e,t,s,r,i){const a=tn("int32",t*r);for(let o=0;o<t;++o){const l=n.slice(o*s,(o+1)*s),h=o*r;for(let d=0;d<r;++d)a[h+d]=i==="left"?Pge(l,e[d+h]):Bge(l,e[d+h])}return a}function Uge(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,h=Vge(o,l,r.shape[0],r.shape[1],i.shape[1],a);return t.makeTensorInfo(i.shape,"int32",h)}const jge={kernelName:ox,backendName:"cpu",kernelFunc:Uge};function Wge(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e;Oe([s,r,i],"select");const a=s.shape.length,o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=_s(r.dtype,i.dtype),p=Yn(he(r.shape),d);let m=0;const y=a===0||a>1||r.shape.length===1?1:he(r.shape.slice(1));for(let b=0;b<o.length;b++)for(let x=0;x<y;x++)o[b]===1?p[m++]=l[b]:p[m++]=h[b];return t.makeTensorInfo(r.shape,d,p)}const Gge={kernelName:mm,backendName:"cpu",kernelFunc:Wge};const Hge=hw,qge=dw,Kge=Nt(Fh,n=>n>=0?qge*n:Hge*(Math.exp(n)-1)),Xge={kernelName:Fh,backendName:"cpu",kernelFunc:Kge};const Yge=Nt(Ph,n=>n<0?-1:n>0?1:0),Jge={kernelName:Ph,backendName:"cpu",kernelFunc:Yge};const Zge=Nt(Mh,n=>Math.sin(n)),Qge={kernelName:Mh,backendName:"cpu",kernelFunc:Zge};const eye=Nt(zh,n=>Math.sinh(n)),tye={kernelName:zh,backendName:"cpu",kernelFunc:eye};const nye=11920928955078125e-23,E3=Math.log(nye)+2,sye=Nt(Vh,n=>{const e=n>-E3,t=n<E3,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),rye={kernelName:Vh,backendName:"cpu",kernelFunc:sye};function iye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;Oe([r],"spaceToBatchND");const o=he(i),l=[[0,0]];l.push(...a);for(let A=1+i.length;A<r.shape.length;++A)l.push([0,0]);const h=M4.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),d=Gm(h.shape,i,o,!1),p=Hm(d.length,i.length,!1),m=qm(h.shape,i,o,!1),x=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),C=Ls({inputs:{x},backend:t,attrs:{perm:p}}),E=zt({inputs:{x:C},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(C),E}const aye={kernelName:bm,backendName:"cpu",kernelFunc:iye};function oye(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values[0],[p,m,y,b,x]=o4(o,s.shape,s.dtype,l,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const lye={kernelName:lx,backendName:"cpu",kernelFunc:oye};function uye(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.data.get(r.dataId).values),o=t.data.get(s.dataId).values,l=Array.from(t.data.get(i.dataId).values),[h,d,p]=l4(o,s.shape,s.dtype,a,l);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const cye={kernelName:ux,backendName:"cpu",kernelFunc:uye};function hye(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[h,d]=JE(a,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(d,s.dtype,h)}const dye={kernelName:cx,backendName:"cpu",kernelFunc:hye};function fye(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,[h,d]=JE(a,s.shape,s.dtype,o,l);return t.makeTensorInfo(d,s.dtype,h)}const pye={kernelName:hx,backendName:"cpu",kernelFunc:fye};function mye(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=qo(i,r,o),y=!1,b=t.bufferSync(r);let x;switch(i.dtype){case"bool":{const w=t.bufferSync(i),v=!!t.data.get(a.dataId).values[0];x=Fl(b,w,o,m,d,h,l,p,v,y);break}case"float32":{const w=t.bufferSync(i),v=t.data.get(a.dataId).values[0];x=Fl(b,w,o,m,d,h,l,p,v,y);break}case"int32":{const w=t.bufferSync(i),v=t.data.get(a.dataId).values[0];x=Fl(b,w,o,m,d,h,l,p,v,y);break}case"string":{const w=t.bufferSync(i),v=Na(t.data.get(a.dataId).values[0]);x=Fl(b,w,o,m,d,h,l,p,v,y);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(o,x.dtype,x.values)}const gye={kernelName:dx,backendName:"cpu",kernelFunc:mye};function yye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=st(a,r.shape)[0],l=ck(r,i,o),h=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(p=>{const m=[...d];m[o]=p;const y=ru({inputs:{x:r},backend:t,attrs:{begin:h,size:m}});return h[o]+=p,y})}const bye={kernelName:xm,backendName:"cpu",kernelFunc:yye};const xye={kernelName:fx,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Oe(t,"square");const r=s.data.get(t.dataId).values,i=new Float32Array(r.length);for(let o=0;o<r.length;++o){const l=r[o];i[o]=l*l}return{dataId:s.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const wye=Nt(Kh,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),vye={kernelName:Kh,backendName:"cpu",kernelFunc:wye};function Sye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;Oe(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:v,begin:C,end:N,strides:k}=GN(r.shape,i,a,o,l,h,d,p,m);let E;if(x)E=zt({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const A=UN(C,N,k),R=ru({inputs:{x:r},backend:t,attrs:{begin:C,size:A}});E=zt({inputs:{x:R},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(R)}else{const A=t.bufferSync(r),R=h4(y,A,k,C);E=t.makeTensorInfo(b,R.dtype,R.values)}return E}const Tye={kernelName:px,backendName:"cpu",kernelFunc:Sye};function Cye(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:h}=s,{data:d,dataSplits:p}=e,m=t.data.get(d.dataId).values,y=t.data.get(p.dataId).values,[b,x]=d4(m,y,r,i,a,o,l,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(p.shape,"int32",x)]}const Nye={kernelName:mx,backendName:"cpu",kernelFunc:Cye};function kye(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(i.dataId).values,l=t.data.get(a.dataId).values[0],[h,d,p]=f4(o,l,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const Eye={kernelName:gx,backendName:"cpu",kernelFunc:kye};function Iye(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(i.dataId).values,o=p4(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const $ye={kernelName:yx,backendName:"cpu",kernelFunc:Iye};const _ye=Nt(Gh,n=>Math.tan(n)),Aye={kernelName:Gh,backendName:"cpu",kernelFunc:_ye};const Rye=Nt(Hh,n=>Math.tanh(n)),Dye={kernelName:Hh,backendName:"cpu",kernelFunc:Rye};function Oye(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:i}=e,{sliceRank:a,numUpdates:o,sliceSize:l,strides:h,outputSize:d}=qo(i,r,s.shape),p=!1,m=t.bufferSync(r),y=t.bufferSync(i),b=t.bufferSync(s),x=Fl(m,y,s.shape,d,l,o,a,h,b,p);return t.makeTensorInfo(s.shape,x.dtype,x.values)}const Lye={kernelName:ax,backendName:"cpu",kernelFunc:Oye};function Fye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;Oe(r,"tile");const a=g4(t.bufferSync(r),i);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const Mye={kernelName:qh,backendName:"cpu",kernelFunc:Fye};function zye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s;Oe(r,"topk");const o=t.data.get(r.dataId).values,[l,h]=b4(o,r.shape,r.dtype,i,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(h.shape,h.dtype,h.values)]}const Pye={kernelName:bx,backendName:"cpu",kernelFunc:zye};function Bye(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:h}=t,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],v=Be(r.shape),C=v[0],N=v[1],k=v[2],E=Be(w),A=E[0],R=E[1],D=E[2],L=zn(r.dtype,he(w));L.fill(l);const F=s.data.get(r.dataId).values,_=s.data.get(i.dataId).values;for(let Q=0;Q<d;++Q){const ne=i.shape[0]===1?_:_.subarray(Q*8,Q*8+8);for(let Z=0;Z<b;++Z)for(let B=0;B<x;++B)for(let U=0;U<y;++U){let K;const X=ne[6]*B+ne[7]*Z+1;if(X===0)continue;const se=(ne[0]*B+ne[1]*Z+ne[2])/X,P=(ne[3]*B+ne[4]*Z+ne[5])/X,j=I3(se,m,o),te=I3(P,p,o);switch(a){case"nearest":K=Hye(F,p,m,C,N,k,Q,te,j,U,l);break;case"bilinear":K=qye(F,p,m,C,N,k,Q,te,j,U,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const le=Q*A+Z*R+B*D+U;L[le]=K}return s.makeTensorInfo(w,r.dtype,L)}return{dataId:s.write(L,w,r.dtype),shape:r.shape,dtype:r.dtype}}const Vye={kernelName:xx,backendName:"cpu",kernelFunc:Bye};function I3(n,e,t){switch(t){case"reflect":return Uye(n,e);case"wrap":return jye(n,e);case"nearest":return Gye(n,e);default:return Wye(n)}}function Uye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Io(0,t,e-1)}function jye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Io(0,t,e-1)}function Wye(n,e){return n}function Gye(n,e){return Io(0,n,e-1)}function kf(n,e,t,s,r,i,a,o,l,h,d){const p=a*s+o*r+l*i+h;return 0<=o&&o<e&&0<=l&&l<t?n[p]:d}function Hye(n,e,t,s,r,i,a,o,l,h,d){const p=Math.round(o),m=Math.round(l);return kf(n,e,t,s,r,i,a,p,m,h,d)}function qye(n,e,t,s,r,i,a,o,l,h,d){const p=Math.floor(o),m=Math.floor(l),y=p+1,b=m+1,x=(b-l)*kf(n,e,t,s,r,i,a,p,m,h,d)+(l-m)*kf(n,e,t,s,r,i,a,p,b,h,d),w=(b-l)*kf(n,e,t,s,r,i,a,y,m,h,d)+(l-m)*kf(n,e,t,s,r,i,a,y,b,h,d);return(y-o)*x+(o-p)*w}function Kye(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;Oe(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:h}=x4(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const Xye={kernelName:wx,backendName:"cpu",kernelFunc:Kye};function Yye(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],l=new Array(a-1);let h=0;for(let y=0;y<a;y++)y!==i&&(l[h++]=r.shape[y]);const d=new Array(a).fill(0),p=r.shape.slice();p[i]=1;const m=new Array(o);for(let y=0;y<m.length;y++){d[i]=y;const b=ru({inputs:{x:r},backend:t,attrs:{begin:d,size:p}});m[y]=zt({inputs:{x:b},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(b)}return m}const Jye={kernelName:Sm,backendName:"cpu",kernelFunc:Yye};function Zye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s;Oe(r,"unsortedSegmentSum");const o=r.shape.length,l=i.shape.length,h=[],d=[],p=o-l;let m=i;for(let b=0;b<p;++b){const x=Q0({inputs:{input:m},backend:t,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<a;++b){const x=Oa(b,"int32"),w=t.makeTensorInfo([],"int32",x),v=OV({inputs:{a:w,b:m},backend:t}),C=zo({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),N=Ow({inputs:{a:C,b:r},backend:t}),k=rg({inputs:{x:N},backend:t,attrs:{axis:0,keepDims:!1}});h.push(k),d.push(w),d.push(v),d.push(C),d.push(N),d.push(k)}const y=F4({inputs:h,backend:t,attrs:{axis:0}});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const Qye={kernelName:Tm,backendName:"cpu",kernelFunc:Zye};const e0e=[Kde,$he,Yde,Zde,Lhe,efe,nfe,rfe,afe,lfe,cfe,dfe,pfe,yfe,xfe,Sfe,Cfe,kfe,Ife,Hde,_fe,Rfe,Ofe,Mhe,Ffe,Dhe,Phe,zfe,_he,Bfe,Ufe,jfe,Gfe,qfe,Xfe,Jfe,Qfe,tpe,spe,ipe,ope,upe,hpe,fpe,ppe,gpe,bpe,wpe,vpe,Spe,Tpe,Npe,Ipe,Pde,_pe,Bhe,zpe,Vhe,Ppe,jhe,Gpe,Hpe,Kpe,Ghe,qhe,Ype,Zpe,eme,nme,Xhe,Jhe,Ahe,rme,Vfe,ame,lme,cme,Bde,Qhe,tde,dme,sde,pme,yme,xme,Sme,Cme,kme,Eme,ide,$me,Ame,Dme,Lme,Mme,Pme,Vme,ode,jme,Hme,Xme,ude,hde,Zme,tge,rge,fde,age,lge,uge,M4,fge,Ude,gde,mge,yge,xge,vge,Rhe,pC,Tge,jde,Wde,Gde,Nge,Ege,$ge,Age,Dge,Oge,Fge,Cde,zge,jge,Gge,Xge,kde,Jge,Qge,tye,Ede,qme,rye,aye,lye,cye,dye,pye,gye,bye,_de,xye,Rde,Ode,vye,Tye,Nye,Eye,$ye,zde,kpe,Aye,Dye,Lye,Mye,Pye,Vye,pde,Xye,Jye,Qye,oge];for(const n of e0e)Sx(n);const Al={},Wy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function z4(n,e){Al[n]=e}function xi(n,e){if(!(n in Al)||e!=null){const s=n0e(n,e);if(s!==null)Al[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Al[n];return t==null||t.isContextLost()?(delete Al[n],xi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Al[n])}function t0e(n){if(!ae().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function n0e(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??t0e(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Al[n]},!1),ae().getBool("SOFTWARE_WEBGL_ENABLED")&&(Wy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Wy)||t.getContext("experimental-webgl",Wy):t.getContext("webgl2",Wy)}var dp;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(dp||(dp={}));var xr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(xr||(xr={}));var Kn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Kn||(Kn={}));function ig(n,e){return[e,n]}function s0e(n,e){return n*e}function Gy(n){const e=he(n),t=Math.ceil(e/4);return I0(t)}function ud(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function r0e(n,e){const[t,s]=ud(n,e);return t*s*4}function nI(n,e){const t=n;let s,r,i,a,o,l,h,d,p,m;return ae().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,a=t.RGBA32F,o=t.RED,h=4,d=1,p=t.HALF_FLOAT,m=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,a=t.RGBA,o=n.RGBA,h=4,d=4,p=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function Ie(n,e){const t=e();return ae().getBool("DEBUG")&&i0e(n),t}function i0e(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+B4(n,e))}const a0e=596e-10,o0e=65504;function P4(n){return!!(ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||a0e<Math.abs(n)&&Math.abs(n)<o0e)}function B4(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Ef(n,e){return Va(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function V4(n,e){const t=Va(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ie(n,()=>n.shaderSource(t,e)),Ie(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function U4(n,e){const t=Va(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ie(n,()=>n.shaderSource(t,e)),Ie(n,()=>n.compileShader(t)),ae().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw sI(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const l0e=/ERROR: [0-9]+:([0-9]+):/g;function sI(n,e){const t=l0e.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,a=r.map((p,m)=>Pl((m+1).toString(),i)+p);let o=0;for(let p=0;p<a.length;p++)o=Math.max(a[p].length,o);const l=a.slice(0,s-1),h=a.slice(s-1,s),d=a.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Pl(h[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function j4(n){return Va(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function W4(n,e){if(Ie(n,()=>n.linkProgram(e)),!ae().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function u0(n,e){if(Ie(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function G4(n,e){const t=Va(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Ie(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function H4(n,e){const t=Va(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ie(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Ie(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function u0e(){return ae().getNumber("WEBGL_VERSION")===2?1:4}function q4(n){return Va(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function K4(n,e){const t=ae().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function X4(n){return Va(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function gC(n,e,t,s,r,i,a){const o=n.getAttribLocation(e,t);return o===-1?!1:(Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Ie(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,i,a)),Ie(n,()=>n.enableVertexAttribArray(o)),!0)}function Y4(n,e,t){tU(n,t),Ie(n,()=>n.activeTexture(n.TEXTURE0+t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function c0e(n,e){tU(n,e),Ie(n,()=>n.activeTexture(n.TEXTURE0+e)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function J4(n,e,t){return Va(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function Z4(n,e,t){return n.getUniformLocation(e,t)}function Q4(n,e,t,s){Ie(n,()=>Y4(n,e,s)),Ie(n,()=>n.uniform1i(t,s))}function h0e(n){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Ie(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),Ie(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function c0(n,e,t){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Ie(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function yC(n,e){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Ie(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function If(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+eU(n,e))}function eU(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Va(n,e,t){const s=Ie(n,()=>e());if(s==null)throw new Error(t);return s}function tU(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function iu(n,e=2){return he(n.slice(0,n.length-e))}function au(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function $f(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[iu(n),...au(n)]),e}function nU(n,e=!1){let t=ae().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ae().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ae().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,l)=>l>=n.length-2?mb(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Da(n).newShape);let r=he(n),i=null;n.length<=1&&r<=t?i=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const a=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||a)if(e){const o=iu(n);let l=2,h=2;n.length&&([l,h]=au(n)),r=o*(l/2)*(h/2),i=I0(r).map(d=>d*2)}else i=I0(r);return i}function Hy(n){return n%2===0}function fp(n,e){if(n=n.slice(-2),e=e.slice(-2),at(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Hy(t)&&Hy(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Hy(n[0])&&Hy(e[0])}let h0,d0;function sU(n){if(h0==null){const e=xi(n);h0=e.getParameter(e.MAX_TEXTURE_SIZE)}return h0}function d0e(){h0=null}function f0e(){d0=null}function rU(n){if(d0==null){const e=xi(n);d0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,d0)}function iU(n){if(n===0)return 0;let e;const t=xi(n);return wr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:wr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function wr(n,e){return n.getExtension(e)!=null}function bC(n){try{if(xi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function aU(n){if(n===0)return!1;const e=xi(n);if(n===1){if(!wr(e,"OES_texture_float"))return!1}else if(!wr(e,"EXT_color_buffer_float"))return!1;return xC(e)}function oU(n){if(n===0)return!1;const e=xi(n);if(n===1){if(!wr(e,"OES_texture_float")||!wr(e,"WEBGL_color_buffer_float"))return!1}else{if(wr(e,"EXT_color_buffer_float"))return xC(e);const s="EXT_color_buffer_half_float";if(wr(e,s)){const r=e.getExtension(s);return p0e(e,r)}return!1}return xC(e)}function xC(n){const e=nI(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),a}function p0e(n,e){const t=nI(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function lU(n){return n!==2?!1:xi(n).fenceSync!=null}function cd(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const m0e=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:cd,bindCanvasToFramebuffer:h0e,bindColorTextureToFramebuffer:c0,bindTextureToProgramUniformSampler:Q4,bindTextureUnit:Y4,bindVertexBufferToProgramAttribute:gC,callAndCheck:Ie,canBeRepresented:P4,createFragmentShader:U4,createFramebuffer:X4,createProgram:j4,createStaticIndexBuffer:H4,createStaticVertexBuffer:G4,createTexture:q4,createVertexShader:V4,getBatchDim:iu,getExtensionOrThrow:Ef,getFramebufferErrorMessage:eU,getMaxTexturesInShader:rU,getNumChannels:u0e,getProgramUniformLocation:Z4,getProgramUniformLocationOrThrow:J4,getRowsCols:au,getShapeAs3D:$f,getTextureShapeFromLogicalShape:nU,getWebGLDisjointQueryTimerVersion:iU,getWebGLErrorMessage:B4,getWebGLMaxTextureSize:sU,hasExtension:wr,isCapableOfRenderingToFloatTexture:aU,isDownloadFloatTextureEnabled:oU,isReshapeFree:fp,isWebGLFenceEnabled:lU,isWebGLVersionEnabled:bC,linkProgram:W4,logShaderSourceAndInfoLog:sI,resetMaxTextureSize:d0e,resetMaxTexturesInShader:f0e,unbindColorTextureFromFramebuffer:yC,unbindTextureUnit:c0e,validateFramebuffer:If,validateProgram:u0,validateTextureSize:K4},Symbol.toStringTag,{value:"Module"}));const Fe=ae();Fe.registerFlag("HAS_WEBGL",()=>Fe.getNumber("WEBGL_VERSION")>0);Fe.registerFlag("WEBGL_VERSION",()=>bC(2)?2:bC(1)?1:0);Fe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Fe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Fe.get("WEBGL_VERSION")===2);Fe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Fe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Fe.registerFlag("WEBGL_PACK",()=>Fe.getBool("HAS_WEBGL"));Fe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_CLIP",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_REDUCE",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_CONV_IM2COL",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Fe.getBool("WEBGL_PACK"));Fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>sU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>rU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Fe.getNumber("WEBGL_VERSION");return n===0?0:iU(n)});Fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!x2());Fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>aU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Fe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>oU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>lU(Fe.getNumber("WEBGL_VERSION")));Fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Fe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Fe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>x2()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Fe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Fe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Fe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Fe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Fe.registerFlag("WEBGL_EXP_CONV",()=>!1);Fe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Fe.getBool("IS_TEST"));Fe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Fe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Fe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Fe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ss(){let n,e,t,s,r,i,a,o,l,h;return ae().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o=ae().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:h}}function xu(n,e,t="index"){const s=Be(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / ${r}`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${a}; ${o};`}).join("")}function Lw(n,e,t="index"){const s=Be(e);return s.map((r,i)=>{const a=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,o=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${a}; ${o};`}).join("")}function g0e(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function y0e(n,e,t="index"){const s=n.map((i,a)=>a),r=g0e(s,e);return r.map((i,a)=>{const o=`int ${n[a]} = ${t} / ${r[a]}`,l=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r[a]}`:`index -= ${n[a]} * ${r[a]}`;return`${o}; ${l};`}).join("")}function rI(n){const e=Be(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function iI(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const uU=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:cU}=WP;function b0e(n,e,t){const s=[];if(n.forEach(y=>{const b=he(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),t.enableShapeUniforms){const{uniformShape:x}=aI(t.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>x0e(y,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=Ss(),l=S0e(o);let h,d,p=N0e(o);return e.isPacked?(h=w0e(e.logicalShape,a,t.enableShapeUniforms),d=C0e(o)):(h=v0e(e.logicalShape,a,t.enableShapeUniforms),d=T0e(o)),t.packedInputs&&(p+=$0e),[p,l,d,r,h,i,t.userCode].join(`
`)}function hd(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return V0e(n,e);case 1:return j0e(n,e);case 2:return G0e(n,e);case 3:return q0e(n,e);case 4:return X0e(n,e);case 5:return Y0e(n);case 6:return J0e(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function hU(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return B0e(n);case 1:return U0e(n,e);case 2:return W0e(n,e);case 3:return H0e(n,e);default:return K0e(n,e)}}function x0e(n,e,t=!1,s){let r="";t?r+=hU(n,s):r+=hd(n,s);const i=n.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(t?r+=Z0e(n,e):r+=Q0e(n,e)),r}function w0e(n,e,t){switch(n.length){case 0:return dU();case 1:return _0e(n,e,t);case 2:return z0e(n,e,t);case 3:return R0e(n,e,t);default:return O0e(n,e,t)}}function v0e(n,e,t){switch(n.length){case 0:return dU();case 1:return A0e(n,e,t);case 2:return P0e(n,e,t);case 3:return D0e(n,e,t);case 4:return L0e(n,e,t);case 5:return F0e(n,e);case 6:return M0e(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function S0e(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function T0e(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function C0e(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function N0e(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${k0e}
    ${E0e}
    ${I0e}
  `}const k0e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,E0e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,I0e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$0e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function dU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function _0e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function A0e(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function R0e(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function D0e(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Lw(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=xu(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function O0e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let a=i,o="",l="b, r, c";for(let h=2;h<n.length-1;h++)a*=n[n.length-h-1],o=`
      int b${h} = index / ${a};
      index -= b${h} * ${a};
    `+o,l=`b${h}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function L0e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Lw(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=xu(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function F0e(n,e){const t=xu(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function M0e(n,e){const t=xu(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function z0e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(at(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function P0e(n,e,t){return at(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function wu(n){return`offset${n}`}function B0e(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ss();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function V0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=wu(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function U0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Ss();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function j0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${dd(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],a=r[1];if(a===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=wu(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function W0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=i[0],o=i[1],l=Ss();if(i!=null&&at(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function G0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&at(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=Da(t),l=a;if(l.length<t.length){const m=fd(n,l),y=["row","col"];return`
      ${hd(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${pd(y,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${dd(n)}
      }
    `;const h=i[0],d=i[1],p=wu(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function H0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const m=t.slice(1),y=[1,2],b=fd(n,m),x=["b","row","col"];return`
        ${hU(b,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${pd(x,y)});
        }
      `}const o=Ss();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=a[0],h=a[1],d=Math.ceil(t[2]/2),p=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${h}, ${p}, ${d}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function q0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],a=t[2],{newShape:o,keptDims:l}=Da(t),h=o;if(h.length<t.length){const x=fd(n,h),w=["row","col","depth"];return`
        ${hd(x,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${pd(w,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${dd(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===a&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=wu(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function K0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ss();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,a=i.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],h=l[0],d=l[1],p=Math.ceil(i[a-1]/2);let m=p*Math.ceil(i[a-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<a-1;x++)y=`int b${x}, `+y,m*=i[a-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${t}, uv);
    }
  `}function X0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],a=t[2]*i,o=t[1]*a,{newShape:l,keptDims:h}=Da(t);if(l.length<t.length){const C=fd(n,l),N=["row","col","depth","depth2"];return`
      ${hd(C,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${pd(N,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${i}, 1)));
        ${dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===o&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=wu(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function Y0e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,a=e[2]*i,o=e[1]*a,{newShape:l,keptDims:h}=Da(e);if(l.length<e.length){const x=fd(n,l),w=["row","col","depth","depth2","depth3"];return`
      ${hd(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${pd(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${i}, ${r})) +
          depth3;
        ${dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===o&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=wu(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${i} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${t}, uv);
    }
  `}function J0e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Da(e);if(r.length<e.length){const w=fd(n,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${hd(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${pd(v,i)});
      }
    `}const a=e[5],o=e[4]*a,l=e[3]*o,h=e[2]*l,d=e[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${dd(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${l}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(b===a&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=wu(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${l} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${t}, uv);
    }
  `}function dd(n){const e=n.name,t=he(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Z0e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=cU(n.shapeInfo.logicalShape,e.logicalShape),l=$t(a),h=a-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":a<2&&o.length>=1?d="coords = 0;":d=o.map(C=>`coords.${p[C+h]} = 0;`).join(`
`);let m="";a<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((C,N)=>`coords.${p[N+h]}`).join(", ");let y="return outputValue;";const x=he(n.shapeInfo.logicalShape)===1,v=he(e.logicalShape)===1;if(i===1&&!x&&!v)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!v)a===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(o.length){const C=i-2,N=i-1;o.indexOf(C)>-1&&o.indexOf(N)>-1?y="return vec4(outputValue.x);":o.indexOf(C)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(N)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function Q0e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&n.shapeInfo.flatOffset==null&&at(a,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const h=$t(l),d=cU(n.shapeInfo.logicalShape,e.logicalShape),p=l-o;let m;const y=["x","y","z","w","u","v"];o===0?m="":l<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+p]} = 0;`).join(`
`);let b="";return l<2&&o>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+p]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function $t(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function aI(n,e,t){const{newShape:s,keptDims:r}=Da(e),i=e.length,a=n&&i===3&&e[0]===1,o=a?e.slice(1):s,l=!n&&i>1&&!at(e,t)&&s.length<i||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:r}}function fd(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function pd(n,e){return e.map(t=>n[t]).join(", ")}function ebe(n,e,t,s){const r=t.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=b0e(r,a,e),l=U4(n.gl,o),h=n.createProgram(l);return ae().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:h,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:h,inShapeInfos:i,outShapeInfo:a},fU(n,e,h)))}function fU(n,e,t){const s=[],r=[];let i,a,o,l=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ae().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const p of e.variableNames){const m={name:p,uniform:n.getUniformLocation(t,p,d),offset:n.getUniformLocation(t,`offset${p}`,d)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${p}Shape`,d),m.texShape=n.getUniformLocation(t,`${p}TexShape`,d)),s.push(m)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),o=n.getUniformLocation(t,"outShapeStrides",d),a=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const p of e.customUniforms)r.push(n.getUniformLocation(t,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:a}}function $3(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],a=i.shape;if(!at(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(t.isUniform&&i.isUniform)return;const o=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!at(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function tbe(n,e,t,s,r){e.program.enableShapeUniforms||($3(e.inShapeInfos,t),$3([e.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):n.setOutputMatrixTexture(i.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ae().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const h=t[l],{uniform:d,offset:p,shape:m,texShape:y}=e.variablesLocations[l];if(m){const{uniformShape:b}=aI(e.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(he(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,l)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=Be(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const h=e.program.customUniforms[l],d=e.customUniformLocations[l],p=r[l];if(h.type==="float")n.gl.uniform1fv(d,p);else if(h.type==="vec2")n.gl.uniform2fv(d,p);else if(h.type==="vec3")n.gl.uniform3fv(d,p);else if(h.type==="vec4")n.gl.uniform4fv(d,p);else if(h.type==="int")n.gl.uniform1iv(d,p);else if(h.type==="ivec2")n.gl.uniform2iv(d,p);else if(h.type==="ivec3")n.gl.uniform3iv(d,p);else if(h.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function nbe(n,e,t){let s="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:p}=aI(n.packedInputs,a.shape,l);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Be(d);b=`${E[0]===l[1]}_${E[E.length-1]===l[1]}`}const x=a.shape.length,w=d.length===2&&at(a.shape,l),v=he(a.shape)===1,C=Yl(a.shape,t.shape),N=!n.packedInputs&&x===t.shape.length&&at(l,t.texData.texShape),k=n.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${x}_${N}_${h?p:""}_${d.length}_${v}_${C}_${w}_${m}_${y}_${b}_${k}_${o}`}else{const l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${o}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${ae().getNumber("WEBGL_VERSION")}`,i}function hs(n){return ae().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class sbe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=dp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Lw(["r","c","d"],e):xu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class rbe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=dp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Lw(["r","c","d"],e):xu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class ibe{constructor(e){this.variableNames=["A"],this.outTexUsage=xr.DOWNLOAD;const t=Ss();this.outputShape=e,this.userCode=`
      ${uU}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class abe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=xr.DOWNLOAD;const t=Ss();this.outputShape=e,this.userCode=`
      ${uU}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const obe={R:0,G:1,B:2,A:3};class _3{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const l=s[o];a+=`
          if(offset == ${o}) {
            result = values[${obe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?iI():rI(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class lbe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const l=a*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?iI():rI(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function pU(n){const e=Ss(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return V4(n,t)}function mU(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return G4(n,e)}function gU(n){const e=new Uint16Array([0,1,2,2,1,3]);return H4(n,e)}function ag(n,e,t,s,r,i){K4(e,t);const a=q4(n),o=n.TEXTURE_2D;return Ie(n,()=>n.bindTexture(o,a)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),ae().getNumber("WEBGL_VERSION")===1?Ie(n,()=>n.texImage2D(o,0,s,e,t,0,r,i,null)):Ie(n,()=>n.texStorage2D(o,1,s,e,t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function oI(n){return n.internalFormatFloat}function yU(n,e,t,s){const[r,i]=ig(e,t);return ag(n,r,i,oI(s),s.textureFormatFloat,n.FLOAT)}function lI(n){return n.internalFormatHalfFloat}function bU(n,e,t,s){const[r,i]=ig(e,t);return ag(n,r,i,lI(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function uI(n){return n.downloadTextureFormat}function xU(n,e,t,s){const[r,i]=ig(e,t);return ag(n,r,i,uI(s),n.RGBA,n.UNSIGNED_BYTE)}function cI(n){return n.internalFormatPackedFloat}function wU(n,e,t,s){const[r,i]=ud(e,t);return ag(n,r,i,cI(s),n.RGBA,n.FLOAT)}function hI(n){return n.internalFormatPackedHalfFloat}function vU(n,e,t,s){const[r,i]=ud(e,t);return ag(n,r,i,hI(s),n.RGBA,s.textureTypeHalfFloat)}function SU(n,e,t){return Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),gC(n,e,"clipSpacePos",t,3,20,0)&&gC(n,e,"uv",t,2,20,12)}function TU(n,e,t,s,r,i){Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,o,l;r instanceof Uint8Array?(a=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(t*s*4),o=n.FLOAT,l=i.internalFormatPackedFloat),a.set(r),ae().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,a)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,o,a)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function CU(n,e,t){Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ae().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ae().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function NU(n,e,t,s){const r=n.createBuffer();Ie(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=4*4*e*t;return Ie(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Ie(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Ie(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function kU(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function EU(n,e,t,s){const[r,i]=ig(e,t),a=4,o=new Uint8Array(s0e(e*t,a));return Ie(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function IU(n,e,t,s,r,i,a,o){const l=n,h=new Float32Array(r0e(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,h),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),h}function $U(n,e,t){const s=new Float32Array(e*t*4);return Ie(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const ube=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:SU,createBufferFromOutputTexture:NU,createFloat16MatrixTexture:bU,createFloat16PackedMatrixTexture:vU,createFloat32MatrixTexture:yU,createIndexBuffer:gU,createPackedMatrixTexture:wU,createUnsignedBytesMatrixTexture:xU,createVertexBuffer:mU,createVertexShader:pU,downloadByteEncodedFloatMatrixFromOutputTexture:EU,downloadFloat32MatrixFromBuffer:kU,downloadMatrixFromPackedOutputTexture:$U,downloadPackedMatrixFromBuffer:IU,getInternalFormatForFloat16MatrixTexture:lI,getInternalFormatForFloat16PackedMatrixTexture:hI,getInternalFormatForFloat32MatrixTexture:oI,getInternalFormatForPackedMatrixTexture:cI,getInternalFormatForUnsignedBytesMatrixTexture:uI,uploadDenseMatrixToTexture:TU,uploadPixelDataToTexture:CU},Symbol.toStringTag,{value:"Module"}));class f0{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ae().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,z4(t,e)):this.gl=xi(t),e=this.gl,ae().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Ie(i,()=>i.createVertexArray()),this.bindVertexArray=a=>Ie(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>Ie(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>Ie(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ie(e,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>Ie(e,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Ie(e,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>Ie(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ae().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Ef(this.gl,i),wr(this.gl,a))this.textureHalfFloatExtension=Ef(this.gl,a);else if(ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),wr(this.gl,r))this.colorBufferHalfFloatExtension=Ef(this.gl,r);else if(ae().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",wr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(wr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=mU(this.gl),this.indexBuffer=gU(this.gl),this.framebuffer=X4(this.gl),this.textureConfig=nI(this.gl,this.textureHalfFloatExtension)}get debug(){return ae().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ie(e,()=>e.finish()),Ie(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ie(e,()=>e.deleteFramebuffer(this.framebuffer)),Ie(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ie(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ie(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),yU(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),bU(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),xU(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),CU(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),TU(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),vU(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),wU(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(yC(this.gl,this.framebuffer),this.outputTexture=null),Ie(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>EU(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,a){return IU(this.gl,e,t,s,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return kU(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=NU(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ae().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=r.clientWaitSync(i,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=i}else ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>$U(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=pU(t));const s=j4(t);Ie(t,()=>t.attachShader(s,this.vertexShader)),Ie(t,()=>t.attachShader(s,e)),W4(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&u0(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Ie(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),SU(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ie(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&u0(this.gl,this.program),Ie(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?J4(this.gl,e,t):Z4(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ie(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Q4(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=ud(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&u0(this.gl,this.program),If(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ie(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ie(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ef(this.gl,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await ET(()=>this.disposed||this.isQueryAvailable(e,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=cbe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ae().platform&&(s=ae().platform.setTimeoutCustom.bind(ae().platform)),ET(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),c0(this.gl,e,this.framebuffer),this.debug&&If(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(c0(this.gl,this.outputTexture,this.framebuffer),this.debug&&If(this.gl)):yC(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;c0(r,e,this.framebuffer),this.debug&&If(r),this.outputTexture=e,Ie(r,()=>r.viewport(0,0,t,s)),Ie(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),Ie(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function cbe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:hbe,bincountImpl:_U,bincountReduceImpl:dbe,bitwiseAndImpl:fbe,castImpl:pbe,ceilImpl:mbe,concatImpl:gbe,equalImpl:ybe,expImpl:bbe,expm1Impl:xbe,floorImpl:wbe,gatherNdImpl:vbe,gatherV2Impl:Sbe,greaterImpl:Tbe,greaterEqualImpl:Cbe,lessImpl:Nbe,lessEqualImpl:kbe,linSpaceImpl:Ebe,logImpl:Ibe,maxImpl:$be,maximumImpl:_be,minimumImpl:Abe,multiplyImpl:Rbe,negImpl:Dbe,notEqualImpl:Obe,prodImpl:Lbe,raggedGatherImpl:Fbe,raggedRangeImpl:Mbe,raggedTensorToTensorImpl:zbe,rangeImpl:Pbe,rsqrtImpl:Bbe,scatterImpl:Vbe,sigmoidImpl:Ube,simpleAbsImpl:AU,sliceImpl:jbe,sparseFillEmptyRowsImpl:Wbe,sparseReshapeImpl:Gbe,sparseSegmentReductionImpl:RU,sqrtImpl:Hbe,staticRegexReplaceImpl:qbe,stridedSliceImpl:Kbe,stringNGramsImpl:Xbe,stringSplitImpl:Ybe,stringToHashBucketFastImpl:Jbe,subImpl:Zbe,tileImpl:Qbe,topKImpl:exe,transposeImpl:dI,uniqueImpl:txe}=w4;function DU(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function gs(n,e){return e===1?[n]:DU(n,e)}function nxe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class sxe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=hs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=gs("rc",this.rank),s=$t(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${e[e.length-1-a]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class OU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${rxe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?iI():rI(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function rxe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?y0e(["r","c","d"],"inputShape"):xu(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class ixe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=R3(t,s),i=D3(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=A3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let o;return r===Kn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Kn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Kn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Kn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Kn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=R3(s,r),a=D3(t,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);const o=A3(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ae().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const h=this.usedTextures[a],d=h&&h.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function axe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function A3(n,e,t,s,r){const i=oxe(e,s);let a;if(r){const[l,h]=ud(n[0],n[1]);a=l*h}else{const[l,h]=ig(n[0],n[1]);a=l*h}const o=axe(t,i);return a*o}function oxe(n,e){switch(n){case Kn.PACKED_2X2_FLOAT32:return cI(e);case Kn.PACKED_2X2_FLOAT16:return hI(e);case Kn.UNPACKED_FLOAT32:return oI(e);case Kn.UNPACKED_FLOAT16:return lI(e);case Kn.PACKED_4X1_UNSIGNED_BYTE:return uI(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function lxe(n){return ae().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Kn.PACKED_2X2_FLOAT32:Kn.UNPACKED_FLOAT32:n?Kn.PACKED_2X2_FLOAT16:Kn.UNPACKED_FLOAT16}function R3(n,e){if(n===xr.UPLOAD)return Kn.PACKED_2X2_FLOAT32;if(n===xr.RENDER||n==null)return lxe(e);if(n===xr.DOWNLOAD||n===xr.PIXELS)return Kn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function D3(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class Oi{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Xr="if (isnan(x)) return x;",uxe="return x;",O3="return abs(x);",cxe="return (x >= 0.0) ? x : (exp(x) - 1.0);",hxe=Xr+`
  return (x < 0.0) ? 0.0 : x;
`,dxe=Xr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,go="return x;",fxe="return 1.0 / (1.0 + exp(-1.0 * x));";const pxe="return x;",mxe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bxe="return 1.0 / (1.0 + exp(-1.0 * x));";class vo{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class xxe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);const t=e.length,s=gs("rc",t),r=$t(t),i=nxe(t,s),a=s.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}const wxe=Jx,vxe=1e-7,Sxe=1e-4,qy={};function Txe(n){return n in qy||(qy[n]={}),qy[n]}const Cxe=ae().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Nxe=600;function kxe(){return ae().global.screen==null?1024:ae().global.screen.height*ae().global.screen.width*window.devicePixelRatio*Nxe/1024/1024}class og extends pb{nextDataId(){return og.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ae().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof f0)t=e;else{const s=xi(ae().getNumber("WEBGL_VERSION"),e);t=new f0(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=xi(ae().getNumber("WEBGL_VERSION"));t=new f0(s),this.binaryCache=Txe(ae().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new ixe(this.gpgpu),this.numMBBeforeWarning=kxe(),this.texData=new h2(this,li())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,i,a){const o=this.makeTensorInfo(t,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,i]},l.texShape=[r,i];const h=$f(t),d=new _3(h,!1,a),p=this.runWebGLProgram(d,[o],s,[[r,i]]);return p.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(o),p.dataId}write(e,t,s){if((ae().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ae().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:xr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(ae().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:xr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:a,shape:o,isPacked:l}=t;if(a!=null){let m;l?m=new vo(o,go):m=new Oi(o,go);const y=this.runWebGLProgram(m,[{dataId:e,shape:o,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=Gn());let p;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);p=$a(m,y)}else p=this.getValuesFromTexture(e);return h&&(this.downloadWaitMs+=Gn()-d),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const b=this.pendingRead.get(e);return new Promise(x=>b.push(x))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:a,complexTensorInfos:o,isPacked:l}=t;if(i!=null){let b;l?b=new vo(r,go):b=new Oi(r,go);const x=this.runWebGLProgram(b,[{dataId:e,shape:r,dtype:a}],a),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(e);if(ae().getBool("DEBUG")&&!ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ae().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(a!=="complex64"&&ae().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Gy(r))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(a==="complex64"){const b=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),x=b[0],w=b[1];p=$a(x,w)}else if(h==null)p=this.getValuesFromTexture(e);else{const b=he(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;Ie(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(e,p),y=this.pendingRead.get(e);return this.pendingRead.delete(e),y.forEach(b=>b(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&li().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:i,slice:a,dtype:o,isPacked:l,texture:h}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let y;l?y=new vo(i,go):y=new Oi(i,go);const b=this.runWebGLProgram(y,[{dataId:e,shape:i,dtype:o}],o),x=this.readToGPU(b,t);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),p=li().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>Na(r));return Qe(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Qe(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!P4(s))throw ae().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=he(t);if(ae().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Gy(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),b}const a=ae().getBool("WEBGL_PACK")&&r===!0,o=a?$f(t):t,l=a?new abe(o):new ibe(o),h=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:e}],"float32"),d=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=Ui(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=Ui(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);o.kernelMs=lM(l),o.getExtraProfileInfo=()=>l.map((h,d)=>({name:a[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gn(),endMs:null}}endTimer(e){return ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Gn(),e)}async getQueryTime(e){if(ae().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:a,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,h=this.dataRefCount.get(l);h>1?this.dataRefCount.set(l,h-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Cxe){return ae().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&he(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return wxe(e.shape,t)}packedUnaryOp(e,t,s){const r=new vo(e.shape,t),i=this.compileAndRun(r,[e],s);return li().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=AU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ae().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,O3,e.dtype);const t=new Oi(e.shape,O3),s=this.compileAndRun(t,[e]);return li().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Di(s[0])){const i=s.map(a=>Mi(a));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return li().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new xxe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new sxe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[iu(e.shape),...au(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[iu(t),...au(t)],a=new OU(i,s),o=!0,l=[s],h=this.runWebGLProgram(a,[r],e.dtype,l,o);return{dataId:h.dataId,shape:t,dtype:h.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:i,dtype:a}=s;if(t!=null){const m=he(i),y=t[0]*t[1]*4;O(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=$f(i);let l;r?l=new rbe(o):l=new sbe(o);const h=!0,d=[t??Gy(o)],p=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:e}],a,d,h,t);return{dtype:a,shape:i,dataId:p.dataId}}runWebGLProgram(e,t,s,r,i=!1,a){const o=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===dp.DENSE){const v=a??Gy(e.outputShape);l.texShape=v.map(C=>C*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),he(o.shape)===0)return l.values=zn(o.dtype,0),o;const h=[],d=t.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(v.dataId);if(C.texture==null){if(!e.packedInputs&&he(v.shape)<=ae().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:C.values};e.packedInputs&&(C.isPacked=!0,C.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!C.isPacked!=!!e.packedInputs)v=C.isPacked?this.unpackTensor(v):this.packTensor(v),h.push(v),C=this.texData.get(v.dataId);else if(C.isPacked&&!fp(C.shape,v.shape)){const N=v,k=v.shape;v.shape=C.shape,v=this.packedReshape(v,k),h.push(v),C=this.texData.get(v.dataId),N.shape=k}return{shape:v.shape,texData:C,isUniform:!1}});this.uploadToGPU(o.dataId);const p={shape:o.shape,texData:l,isUniform:!1},m=nbe(e,d,p),y=this.getAndSaveBinary(m,()=>ebe(this.gpgpu,e,d,p)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),ae().get("ENGINE_COMPILE_ONLY")||tbe(this.gpgpu,y,d,p,r),h.forEach(v=>this.disposeIntermediateTensorInfo(v)),b&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=ae().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const v=Gn();v-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!ae().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const v=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),v}return o}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ae().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=re(()=>{if(!ae().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ae().getBool("DEBUG");ae().set("DEBUG",!1);const t=this.abs(Pe(1e-8)).dataSync()[0];if(ae().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?vxe:Sxe}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:a,usage:o,isPacked:l}=t;if(a!=null)return;const h=this.activeTimers!=null;let d;h&&(d=Gn());let p=t.texShape;if(p==null&&(p=nU(s,l),t.texShape=p),i!=null){const m=$f(s);let y,b=p[1],x=p[0];const w=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!w)&&([b,x]=ud(p[0],p[1])),l?y=new lbe(m,w):y=new _3(m,w);const v=w?[x,b]:p,C=this.makeTensorInfo(v,r),N=this.texData.get(C.dataId);w?N.usage=xr.PIXELS:N.usage=xr.UPLOAD,N.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),b,x,i);const k=[[x,b]],A=this.runWebGLProgram(y,[C],r,k,!0),R=this.texData.get(A.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,ae().get("ENGINE_COMPILE_ONLY")?this.disposeData(A.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(A.dataId)),this.disposeIntermediateTensorInfo(C),h&&(this.uploadWaitMs+=Gn()-d)}else{const m=this.acquireTexture(p,o,r,l);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=Exe(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Jf(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(i){throw i}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await HN(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(sI(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:l}=fU(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:i,width:a,channels:o}=e,l=li().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=l.writeTexture(r,t,s,i,a,o);return li().makeTensorFromDataId(h,t,s,l)}}og.nextDataId=0;function Exe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}const LU="4.22.0";function FU(){ae().set("WEBGL_FORCE_F16_TEXTURES",!0)}w2()&&S2("webgl",()=>new og,2);const Ixe={forceHalfFloat:FU};const fI=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ou{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Xe(t,s),this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const vu=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class md{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Xe(t,s);const i=this.outputShape.length;this.enableShapeUniforms=hs(i);let a="";if(r)if(i===0||he(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${$t(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=gs("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}function Qs(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const $xe={kernelName:wh,backendName:"webgl",kernelFunc:Qs};function Xo(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(i.dataId),o=Qs({inputs:{x:s},backend:t}),l=Qs({inputs:{x:r},backend:t});return a.complexTensorInfos={real:o,imag:l},i}const _xe={kernelName:Tb,backendName:"webgl",kernelFunc:Xo};const MU="return (a < 0.) ? b * a : a;",zU=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Axe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,a=t.makeTensorInfo([],"float32",Oa(i,"float32")),o=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(zU,r.shape,a.shape):new ou(MU,r.shape,a.shape),l=t.runWebGLProgram(o,[r,a],"float32");return t.disposeIntermediateTensorInfo(a),l}const Rxe={kernelName:Wp,backendName:"webgl",kernelFunc:Axe};const PU="return (a < 0.) ? b * a : a;",BU=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Dxe(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(BU,s.shape,r.shape):new ou(PU,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const Oxe={kernelName:um,backendName:"webgl",kernelFunc:Dxe};const gd="if (isnan(x)) return x;";function xt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:a}=r,o=i,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const p=o.texData.get(a.dataId),m=t(p.values,l);return o.makeTensorInfo(a.shape,l,m)}const h=ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return h?d=new vo(a.shape,e):d=new Oi(a.shape,n),o.runWebGLProgram(d,[a],l)}}function ts({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:a,backend:o})=>{const{a:l,b:h}=a,d=o;if(s&&l.dtype==="complex64"){const b=d.texData.get(l.dataId),x=d.texData.get(h.dataId),[w,v]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(N=>{const[k,E]=N,A={dataId:k.dataId,dtype:k.dtype,shape:l.shape},R={dataId:E.dataId,dtype:E.dtype,shape:h.shape},D=new ou(n,l.shape,h.shape);return d.runWebGLProgram(D,[A,R],_s(k.dtype,E.dtype))}),C=Xo({inputs:{real:w,imag:v},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(v),C}const p=i||_s(l.dtype,h.dtype);if((l.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([l,h]))&&r!=null){const b=d.texData.get(l.dataId).values,x=d.texData.get(h.dataId).values,w=l.dtype==="string"?_a(b):b,v=l.dtype==="string"?_a(x):x,[C,N]=r(l.shape,h.shape,w,v,p),k=d.makeTensorInfo(N,p),E=d.texData.get(k.dataId);return E.values=C,k}const m=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let y;return m?y=new md(e,l.shape,h.shape,t):y=new ou(n,l.shape,h.shape),d.runWebGLProgram(y,[l,h],p)}}function pp(n,e=!1){if(n==="linear")return e?pxe:uxe;if(n==="relu")return e?gxe:hxe;if(n==="elu")return e?mxe:cxe;if(n==="relu6")return e?yxe:dxe;if(n==="prelu")return e?BU:PU;if(n==="leakyrelu")return e?zU:MU;if(n==="sigmoid")return e?bxe:fxe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class VU{constructor(e,t,s,r=!1,i=!1,a=!1,o=null,l=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=hs(this.outputShape.length);const d=r?e[1]:e[2],p=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",v="";o&&(l?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:w=`vec4 activation(vec4 x) {
          ${o}
        }`,v="result = activation(result);");const C=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let N="rc.x",k="rc.x";e[0]<t[0]?N=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(k=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${N};
        int batchB = ${k};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${C}

        ${v}

        setOutput(result);
      }
    `}}const L3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class F3{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Xe(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const M3="return a * b;";function pI(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=_s(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),l=t.texData.get(r.dataId),h=new F3(L3.REAL,s.shape,r.shape),d=new F3(L3.IMAG,s.shape,r.shape),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(h,p,"float32"),y=t.runWebGLProgram(d,p,"float32"),b=Xo({inputs:{real:m,imag:y},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}if(t.shouldExecuteOnCPU([s,r])){const o=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[h,d]=Rbe(s.shape,r.shape,o.values,l.values,i),p=t.makeTensorInfo(d,i),m=t.texData.get(p.dataId);return m.values=h,p}let a;return ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new md(M3,s.shape,r.shape):a=new ou(M3,s.shape,r.shape),t.runWebGLProgram(a,[s,r],i)}const Lxe={kernelName:$h,backendName:"webgl",kernelFunc:pI};function Fxe(n,e,t){const s=[iu(n.shape),...au(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[iu(e),...au(e)],a=new OU(i,s),o=!0,l=[s],h=t.runWebGLProgram(a,[r],n.dtype,l,o);return{dataId:h.dataId,shape:e,dtype:h.dtype}}function ke(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,a=t,o=he(r.shape),l=f2(i,o),h=he(l);O(o===h,()=>`The new shape (${l}) has ${h} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=a.texData.get(r.dataId);return d.isPacked&&!fp(r.shape,l)&&!(d.texture!==null&&fp(d.shape,l))?Fxe(r,l,a):(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Mxe={kernelName:hm,backendName:"webgl",kernelFunc:ke};class z3{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];const o=Math.floor(s/4)*4,l=s%4;let h="sumValue += dot(values, ones);";if(t!=null){const p=1/t;h=`sumValue += dot(values * ${Wl(p)?p.toPrecision(2):p}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class zxe{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let o="0.0",l="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",l="min"):t==="max"&&(o="-1.0 / 1e-20",l="max");let h=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?h="sumValue":t==="prod"?h="prodValue":t==="all"?h="allValue":t==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";t==="all"?(o="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):t==="any"&&(o="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function Pxe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=cw(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Su(n,e,t,s){const r=Pxe(n.shape);let i=n;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:l,outSize:h}=r[a];let d,p;t==="mean"?d=a===0?new z3({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:h},o):new z3({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:h}):d=new zxe({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:h},t),p=i,i=s.runWebGLProgram(d,[i],e),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}class Bxe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const r=$t(this.rank),i=Vxe(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Vxe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class Uxe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=$t(this.rank),i=DU("rc",this.rank),a=new Array(this.rank);for(let d=0;d<t.length;d++)a[t[d]]=i[d];const o=`vec2(${a.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${l}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${l}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function Fw(n,e,t){const s=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uxe(n.shape,e):new Bxe(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function jxe(n,e,t,s){const r=e,i=n.shape.length,a=st(r,n.shape);let o=a;const l=Zt(o,i),h=l!=null;let d=n;h&&(d=Fw(n,l,s),o=cn(o.length,i)),Qn("sum",o,i);const[p,m]=Un(d.shape,o);let y=p;t&&(y=un(p,a));const b=he(m),w=he(n.shape)/b,v=ke({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),C=Tx(n.dtype),N=Su(v,C,"sum",s),k=ke({inputs:{x:N},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(N),h&&s.disposeIntermediateTensorInfo(d),k}function Mw(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s;return jxe(r,i,a,t)}const Wxe={kernelName:ym,backendName:"webgl",kernelFunc:Mw};function xs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,a=t,o=r.shape.length,l=new Array(o);for(let d=0;d<l.length;d++)l[d]=r.shape[i[d]];let h;if(a.shouldExecuteOnCPU([r])){const p=a.texData.get(r.dataId).values,m=dI(p,r.shape,r.dtype,i,l);h=a.makeTensorInfo(l,r.dtype);const y=a.texData.get(h.dataId);y.values=m}else h=Fw(r,i,a);return h}const Gxe={kernelName:Bl,backendName:"webgl",kernelFunc:xs};const UU=1e3;function tb({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const h=n.shape.length,d=e.shape.length,p=t?n.shape[h-2]:n.shape[h-1],m=s?e.shape[d-1]:e.shape[d-2],y=t?n.shape[h-1]:n.shape[h-2],b=s?e.shape[d-2]:e.shape[d-1],x=n.shape.slice(0,-2),w=e.shape.slice(0,-2),v=he(x),C=he(w),k=Xe(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([y,b]);O(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[v,p,y]:[v,y,p],A=s?[C,b,m]:[C,m,b],R=ke({inputs:{x:n},backend:r,attrs:{shape:E}}),D=ke({inputs:{x:e},backend:r,attrs:{shape:A}}),L=[R,D],F=Math.max(v,C),_=t?R.shape[1]:R.shape[2],V=i!=null,Q=a!=null,ne=l==="leakyrelu",Z=l!=null?pp(l,!0):null,B=V||Q||ne||Z!=null;let U;if((y===1||b===1)&&_>UU&&B===!1){let X=R,se=D;t&&(X=xs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),L.push(X)),s&&(se=xs({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),L.push(se));const P=b!==1,j=b===1;let te=X;P&&(te=ke({inputs:{x:X},backend:r,attrs:{shape:[F,_,1]}}),L.push(te));const le=b===1?2:1;let me=se;j&&(me=ke({inputs:{x:se},backend:r,attrs:{shape:[F,1,_]}}),L.push(me));const we=pI({inputs:{a:te,b:me},backend:r});U=Mw({inputs:{x:we},backend:r,attrs:{axis:le,keepDims:!0}}),L.push(we)}else{const X=_s(n.dtype,e.dtype),se=new VU(E,A,[F,y,b],t,s,V,Z,Q,ne),P=[R,D];if(i!=null&&P.push(i),Q&&P.push(a),ne){const j=r.makeTensorInfo([],"float32",Oa(o,"float32"));P.push(j),L.push(j)}U=r.runWebGLProgram(se,P,X)}const K=ke({inputs:{x:U},backend:r,attrs:{shape:k}});L.push(U);for(const X of L)r.disposeIntermediateTensorInfo(X);return K}function Hxe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:h,activation:d,leakyreluAlpha:p}=s;return tb({a:r,b:i,transposeA:l,transposeB:h,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:p,activation:d})}const qxe={kernelName:Zf,backendName:"webgl",kernelFunc:Hxe};const P3="return abs(x);";function Kxe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),a=AU(i.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let r;return ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new vo(s.shape,P3):r=new Oi(s.shape,P3),t.runWebGLProgram(r,[s],s.dtype)}const Xxe={kernelName:Sp,backendName:"webgl",kernelFunc:Kxe};const Yxe=Xr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Jxe=xt({opSnippet:Yxe}),Zxe={kernelName:eh,backendName:"webgl",kernelFunc:Jxe};const Qxe=Xr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,ewe=xt({opSnippet:Qxe}),twe={kernelName:th,backendName:"webgl",kernelFunc:ewe};const B3="return a + b;",nwe=ts({opSnippet:B3,packedOpSnippet:B3,supportsComplex:!0,cpuKernelImpl:hbe}),swe={kernelName:hu,backendName:"webgl",kernelFunc:nwe};class rwe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class iwe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,a)=>`T${a}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function p0(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Qs({inputs:{x:s[0]},backend:t});if(s.length>ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),h=p0({inputs:s.slice(0,l),backend:t}),d=p0({inputs:s.slice(l),backend:t});return p0({inputs:[h,d],backend:t})}const r=s.map(l=>l.dtype).reduce((l,h)=>_s(l,h)),i=s.map(l=>l.shape),o=ae().getBool("WEBGL_PACK")?new iwe(s[0].shape,i):new rwe(s[0].shape,i);return t.runWebGLProgram(o,s,r)}const awe={kernelName:Tp,backendName:"webgl",kernelFunc:p0};function owe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=st(i,r.shape);let h=l;const d=Zt(h,o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,o)),Qn("all",h,o);const[m,y]=Un(p.shape,h),b=he(y),x=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=Su(x,x.dtype,"all",t);let v;if(a){const C=un(m,l);v=ke({inputs:{x:w},backend:t,attrs:{shape:C}})}else v=ke({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),v}const lwe={kernelName:yb,backendName:"webgl",kernelFunc:owe};function uwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=st(i,r.shape);let h=l;const d=Zt(h,o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,o)),Qn("any",h,o);const[m,y]=Un(p.shape,h),b=he(y),x=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=Su(x,x.dtype,"any",t);let v;if(a){const C=un(m,l);v=ke({inputs:{x:w},backend:t,attrs:{shape:C}})}else v=ke({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),v}const cwe={kernelName:bb,backendName:"webgl",kernelFunc:uwe};class hwe{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const o=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class dwe{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],a=Math.ceil(i/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,h=$t(l),d=gs("coords",l);let p,m;if(a===1){m=l+1;const D=$t(m);p=`
        ${D} sourceLocR = ${D}(${d.join()}, 0);
        ++${d[l-1]};
        ${D} sourceLocG = ${D}(${d.join()}, 0);
        ++${d[l-2]};
        ${D} sourceLocA = ${D}(${d.join()}, 0);
        --${d[l-1]};
        ${D} sourceLocB = ${D}(${d.join()}, 0);
        --${d[l-2]};`}else m=l,p=`
        ${h} sourceLocR = coords;
        ++${d[l-1]};
        ${h} sourceLocG = coords;
        ++${d[l-2]};
        ${h} sourceLocA = coords;
        --${d[l-1]};
        ${h} sourceLocB = coords;
        --${d[l-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(D=>"int "+D),w=gs("sourceLocR",m-1).concat("inIdx.r"),v=gs("sourceLocG",m-1).concat("inIdx.g"),C=gs("sourceLocB",m-1).concat("inIdx.b"),N=gs("sourceLocA",m-1).concat("inIdx.a"),k=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${N.join()})));`,A=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${C.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${N.join()}) : 0.)`,R=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${d[l-2]} < ${o[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function jU(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const a=cw(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},l=new hwe(o,t,s==null),h=[e];s!=null&&h.push(s);const d=n.runWebGLProgram(l,h,"int32");if(d.shape[1]===1)return d;const p=jU(n,e,t,d);return n.disposeIntermediateTensorInfo(d),p}function WU(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],a=cw(i),o=new dwe(r,a,t,s==null),l=s==null?[e]:[e,s],h=n.runWebGLProgram(o,l,"int32");if(h.shape.length===e.shape.length){const d=WU(n,e,t,h);return n.disposeIntermediateTensorInfo(h),d}return h}function GU(n,e,t,s){const r=[t];if(Qn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ae().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],a=n.texData.get(e.dataId),o=a!==null&&a.isPacked;let l=e;o&&(l=n.unpackTensor(e),i.push(l));const[h,d]=Un(l.shape,r),p=he(d),m=ke({inputs:{x:l},backend:n,attrs:{shape:[-1,p]}});i.push(m);const y=jU(n,m,s);i.push(y);const b=ke({inputs:{x:y},backend:n,attrs:{shape:h}});return i.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return WU(n,e,s)}function fwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=st(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const h=[];o!=null&&(l=xs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),a=cn(a.length,l.shape.length)),Qn("argMax",[a[0]],l.shape.length);const d=GU(t,l,a[0],"max");return h.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const pwe={kernelName:Cp,backendName:"webgl",kernelFunc:fwe};function mwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let a=st(i,r.shape);const o=Zt(a,r.shape.length);let l=r;const h=[];o!=null&&(l=xs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),a=cn(a.length,l.shape.length)),Qn("argMin",[a[0]],l.shape.length);const d=GU(t,l,a[0],"min");return h.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const gwe={kernelName:Np,backendName:"webgl",kernelFunc:mwe};const ywe=Xr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bwe=xt({opSnippet:ywe}),xwe={kernelName:nh,backendName:"webgl",kernelFunc:bwe};const wwe=Xr+"return log(x + sqrt(x * x + 1.0));",vwe=xt({opSnippet:wwe}),Swe={kernelName:sh,backendName:"webgl",kernelFunc:vwe};const Twe=Xr+`
  return atan(x);
`,Cwe=xt({opSnippet:Twe}),Nwe={kernelName:rh,backendName:"webgl",kernelFunc:Cwe};const kwe=fI+`
  return atan(a, b);
`,Ewe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+vu+`
  return result;
`,Iwe=ts({opSnippet:kwe,packedOpSnippet:Ewe}),$we={kernelName:ah,backendName:"webgl",kernelFunc:Iwe};const _we=Xr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Awe=xt({opSnippet:_we}),Rwe={kernelName:ih,backendName:"webgl",kernelFunc:Awe};class mp{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,l=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let C="0.0";if(x||(C="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?w:v:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const E=Math.floor(a/4)*4,A=a%4,R=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${E};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${k});
      }
    `}}class mI{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,l=e.strideHeight,h=e.strideWidth,d=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,v=e.padInfo.top,C=e.padInfo.left;this.outputShape=e.outShape;const N=t==="avg";let k="0.0";if(N||(k="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${h});
        const ivec3 pads = ivec3(${w}, ${v}, ${C});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let A=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(A="avgValue / max(count, 1.0)");const R=Math.floor(a/4)*4,D=a%4,L=`
      if (${N}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${h});
      const ivec3 pads = ivec3(${w}, ${v}, ${C});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${L}
            }

            int xC = xCCorner + ${R};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${L}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${L}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${L}
            }
          }
        }
        setOutput(${A});
      }
    `}}function Dwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;cd(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(a,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=qr(r.shape,i,a,h,o,l);if(d.filterWidth===1&&d.filterHeight===1&&at(d.inShape,d.outShape))return Qs({inputs:{x:r},backend:t});const p=new mp(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const Owe={kernelName:kp,backendName:"webgl",kernelFunc:Dwe};function Lwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:h}=s,d=[1,1,1],p=La(r.shape,i,a,d,o,l,h),m=new mI(p,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const Fwe={kernelName:Ep,backendName:"webgl",kernelFunc:Lwe};class Mwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=l-1-e.padInfo.top,p=h-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class zwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,b=p-1-e.padInfo.front,x=m-1-e.padInfo.top,w=y-1-e.padInfo.left,v=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Pwe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=La(a.shape,o,l,p,h,d),y=new zwe(m);return t.runWebGLProgram(y,[r],a.dtype)}const Bwe={kernelName:wb,backendName:"webgl",kernelFunc:Pwe};function Vwe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i;cd([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:h}=s,d=qr(a.shape,o,l,1,h),p=new Mwe(d);return t.runWebGLProgram(p,[r],a.dtype)}const Uwe={kernelName:xb,backendName:"webgl",kernelFunc:Vwe};function jwe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:a,transposeB:o}=s;return tb({a:r,b:i,transposeA:a,transposeB:o,backend:t})}const Wwe={kernelName:Ip,backendName:"webgl",kernelFunc:jwe};class Gwe{constructor(e,t,s,r,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Xe(e,t),Xe(e,s);let o="0.0";r!=null&&(Xe(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";i!=null&&(Xe(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Hwe{constructor(e,t,s,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Xe(e,t),Xe(e,s);let o="vec4(0.0)";r!=null&&(Xe(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(Xe(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const qwe=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:a,scale:o}=n;O(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const h=[s,r,i];let d=null;a!=null&&(d=a.shape,h.push(a));let p=null;o!=null&&(p=o.shape,h.push(o));const m=ae().getBool("WEBGL_PACK_NORMALIZATION")?new Hwe(s.shape,r.shape,i.shape,d,p,l):new Gwe(s.shape,r.shape,i.shape,d,p,l);return e.runWebGLProgram(m,h,h[0].dtype)},Kwe={kernelName:Vp,backendName:"webgl",kernelFunc:qwe};class Xwe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=$t(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Ywe(this.rank);let r;const i=e.map((a,o)=>`sourceLoc.${wC[o]} = start[${o}] + coords.${wC[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const wC=["x","y","z","w","u","v"];function Ywe(n){if(n===1)return"sourceLoc";if(n<=6)return wC.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Jwe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=$t(this.rank),s=gs("coords",this.rank),r=gs("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,p)=>`start[${p}]`).join()});`:e.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}function Zwe(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=t,a.dtype=n.dtype;let o=WN(e,Be(n.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),i}function yd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:a}=s,[o,l]=uw(r,i,a);if(VN(r,o,l),he(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=t.texData.get(r.dataId),m=jbe(p.values,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,m)}const{isPacked:h}=t.texData.get(r.dataId),d=jN(r.shape,o,l);if(h||!d){const p=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jwe(l):new Xwe(l),m=[o];return t.runWebGLProgram(p,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),Zwe(r,o,l,t)}const Qwe={kernelName:gm,backendName:"webgl",kernelFunc:yd};const eve=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:a}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((C,N)=>C*N),l=Gm(r.shape,i,o),h=Hm(l.length,i.length),d=qm(r.shape,i,o),p=YN(a,i.length),m=JN(d,a,i.length),y=[],b=ke({inputs:{x:r},backend:t,attrs:{shape:l}}),x=xs({inputs:{x:b},backend:t,attrs:{perm:h}}),w=ke({inputs:{x},backend:t,attrs:{shape:d}}),v=yd({inputs:{x:w},backend:t,attrs:{begin:p,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(C=>t.disposeIntermediateTensorInfo(C)),v},tve={kernelName:$p,backendName:"webgl",kernelFunc:eve};function nve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a}=s,o=t.readSync(r.dataId),l=t.readSync(i.dataId),h=_U(o,l,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,h)}const sve={kernelName:vb,backendName:"webgl",kernelFunc:nve};const rve=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,ive=`
  return float(int(a.r) & int(b.r));
`;function ave(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=ae().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||a===1){const l=t.texData.get(s.dataId).values,h=t.texData.get(r.dataId).values,[d,p]=fbe(s.shape,r.shape,l,h,s.dtype),m=t.makeTensorInfo(p,s.dtype),y=t.texData.get(m.dataId);return y.values=d,m}let o;return i?o=new md(rve,s.shape,r.shape,!1):o=new ou(ive,s.shape,r.shape),t.runWebGLProgram(o,[s,r],s.dtype)}const ove={kernelName:_p,backendName:"webgl",kernelFunc:ave};function lve(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),a=t.readSync(r.dataId),o=Xe(Array.from(i),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const uve={kernelName:Sb,backendName:"webgl",kernelFunc:lve};const cve="return float(a != b);",HU=ts({opSnippet:cve,cpuKernelImpl:Obe,dtype:"bool"}),hve={kernelName:rm,backendName:"webgl",kernelFunc:HU};function lg(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Qs({inputs:{x:r.complexTensorInfos.real},backend:t})}const dve={kernelName:nx,backendName:"webgl",kernelFunc:lg};const fve="return float(int(x));";function pve(n,e){const t=new Oi(n.shape,fve),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function vC(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Qs({inputs:{x:r},backend:t});const a=gn(r.shape),o=vC({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Xo({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){const a=lg({inputs:{input:r},backend:t}),o=vC({inputs:{x:a},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(a),o}if(!p2(r.dtype,i)){const a=Qs({inputs:{x:r},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId).values,[o,l,h]=pbe(a,r.shape,r.dtype,i);return t.makeTensorInfo(o,l,h)}if(i==="int32")return pve(r,t);if(i==="bool"){const a=t.makeTensorInfo([],"bool",zn("bool",1)),l=HU({inputs:{a:r,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const mve={kernelName:oh,backendName:"webgl",kernelFunc:vC};const V3="return ceil(x);",gve=xt({opSnippet:V3,packedOpSnippet:V3,cpuKernelImpl:mbe}),yve={kernelName:lh,backendName:"webgl",kernelFunc:gve};class bve{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class xve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function wve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:a}=s;let o;ae().getBool("WEBGL_PACK_CLIP")?o=new xve(r.shape):o=new bve(r.shape);const l=[[i],[a]];return t.runWebGLProgram(o,[r],r.dtype,l)}const vve={kernelName:uh,backendName:"webgl",kernelFunc:wve};class Sve{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function U3(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Tve(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new Sve(s.shape),a=[U3(s,r.complexTensorInfos.real),U3(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,a,a[0].dtype)}const Cve={kernelName:Ap,backendName:"webgl",kernelFunc:Tve};class Nve{constructor(e){this.outputShape=[],this.outputShape=Pi(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class kve{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Pi(e,t);const s=this.outputShape,r=s.length,i=$t(r),a=gs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((x,w)=>`T${w}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][t];const h=o[t],d=o.slice(-2),p=o.join();let m=`if (${h} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let x=1;x<l.length;x++){const w=l[x-1];m+=`
        if (${h} < ${l[x]}  && ${h} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${Ky(o,h,w)}),
            vec2(${Ky(d,h,w)}));
        }`}const y=l.length,b=l[l.length-1];m+=`
        return getChannel(
          getT${y}(${Ky(o,h,b)}),
          vec2(${Ky(d,h,b)}));`,this.userCode=`
      float getValue(${o.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${s[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${s[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${s[r-2]} &&
            ${a[r-1]} < ${s[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Ky(n,e,t){const s=n.indexOf(e);return n.map((i,a)=>a===s?`${i} - ${t}`:i).join()}function zw(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Qs({inputs:{x:r.complexTensorInfos.imag},backend:t})}const Eve={kernelName:Ub,backendName:"webgl",kernelFunc:zw};function _f(n,e,t){const s=n[0].dtype;if(s==="complex64"){const y=n.map(C=>lg({inputs:{input:C},backend:t})),b=n.map(C=>zw({inputs:{input:C},backend:t})),x=_f(y,e,t),w=_f(b,e,t),v=Xo({inputs:{real:x,imag:w},backend:t});return y.forEach(C=>t.disposeIntermediateTensorInfo(C)),b.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),v}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map(k=>{const A=[-1,he(k.shape.slice(e))];return ke({inputs:{x:k},backend:t,attrs:{shape:A}})}),b=y.map(k=>({vals:t.readSync(k.dataId),shape:k.shape})),x=Pi(y.map(k=>k.shape),1),w=y[0].shape[0]===1,v=gbe(b,x,s,w),C=Pi(n.map(k=>k.shape),e),N=t.makeTensorInfo(C,s,v);return y.forEach(k=>t.disposeIntermediateTensorInfo(k)),N}const i=n.filter(y=>he(y.shape)>0),a=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=a?new Oi(n[0].shape,go):new vo(n[0].shape,go);return t.runWebGLProgram(y,n,s)}const o=ae().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){const y=[];for(let x=0;x<i.length;x+=o){const w=i.slice(x,x+o);y.push(_f(w,e,t))}const b=_f(y,e,t);for(const x of y)t.disposeIntermediateTensorInfo(x);return b}if(a){const y=new kve(i.map(b=>b.shape),e);return t.runWebGLProgram(y,i,s)}const{tensors2D:l,outShape:h}=Ive(i,e,t),d=new Nve(l.map(y=>y.shape)),p=t.runWebGLProgram(d,l,s);l.forEach(y=>t.disposeIntermediateTensorInfo(y));const m=ke({inputs:{x:p},attrs:{shape:h},backend:t});return t.disposeIntermediateTensorInfo(p),m}function Ive(n,e,t){const s=Pi(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>ke({inputs:{x:i},attrs:{shape:[-1,he(i.shape.slice(e))]},backend:t})),outShape:s}}function qU(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=st(r,e[0].shape)[0],a=e.map(h=>h.shape);qN(a,i);const o=Pi(e.map(h=>h.shape),i);if(he(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(h=>he(h.shape)>0);return l.length===1?Qs({inputs:{x:l[0]},backend:t}):_f(l,i,t)}const $ve={kernelName:Rp,backendName:"webgl",kernelFunc:qU};class KU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",v=w?1:2,C=w?2:3,N=w?3:1;let k="",E="";s&&(r?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:k=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const A=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${l}, ${h});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${N}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${C}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${E}
        setOutput(result);
      }
    `}}class _ve{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterDepth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class XU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const v=w*2;if(m+=`
           xC = xCCorner + ${v*l};
           `,o===1){if(v<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?m+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<d)){const C=a%2===0?mb(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${C};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:m+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):C===1?m+=`
                     xC${v+1} = xTexelC${v};
                     `:m+=`
                     xCOffset = xC + ${C};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<d&&(a%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<d&&(m+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<d&&(m+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<d&&(m+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class Ave{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);const{dataFormat:s}=t,r=Ss(),i=s==="channelsLast",a=i?1:2,o=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}function nb(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function YU({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const l=n.shape,h=s.texData.get(n.dataId),d=t.inChannels,p=l[0]*l[1]*l[2],m=t.outChannels,y=t.dataFormat==="channelsLast",b=!1,x=!1;let w;const v=[];if(i!=null){const k=nb(i.shape,y);k!=null&&(i=ke({inputs:{x:i},backend:s,attrs:{shape:k}}),v.push(i))}if(r!=null){const k=nb(r.shape,y);k!=null&&(r=ke({inputs:{x:r},backend:s,attrs:{shape:k}}),v.push(r))}if(!((p===1||m===1)&&d>UU)&&h.isPacked&&y&&h.texture!=null&&l[2]%2!==0&&at(h.shape.slice(-3),l.slice(-3))){const k=l[0]*l[1]*(l[2]+1),E={dataId:n.dataId,shape:[1,k,t.inChannels],dtype:n.dtype},A=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,O(fp(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const R=ke({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});v.push(R);const D=tb({a:E,b:R,backend:s,transposeA:b,transposeB:x,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),L=s.texData.get(D.dataId);O(L.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=A,L.shape=t.outShape,w=Qs({inputs:{x:D},backend:s}),w.shape=t.outShape,v.push(D)}else{const k=t.outHeight*t.outWidth,E=ke({inputs:{x:n},backend:s,attrs:{shape:y?[t.batchSize,k,t.inChannels]:[t.batchSize,t.inChannels,k]}}),A=ke({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=tb({a:y?E:A,b:y?A:E,transposeA:!y,transposeB:x,backend:s,bias:r,activation:o,preluActivationWeights:i,leakyreluAlpha:a});w=ke({inputs:{x:R},backend:s,attrs:{shape:t.outShape}}),v.push(E),v.push(A),v.push(R)}for(const k of v)s.disposeIntermediateTensorInfo(k);return w}function JU({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:h,inChannels:d,outWidth:p,outHeight:m,dataFormat:y}=t,b=y==="channelsLast",x=l*h*d,w=m*p,v=[t.batchSize,x,w],C=!0,N=!1,k=[];if(i!=null){const K=nb(i.shape,b);K!=null&&(i=ke({inputs:{x:i},backend:s,attrs:{shape:K}}),k.push(i))}if(r!=null){const K=nb(r.shape,b);K!=null&&(r=ke({inputs:{x:r},backend:s,attrs:{shape:K}}),k.push(r))}const E=ke({inputs:{x:e},backend:s,attrs:{shape:[1,x,he(e.shape)/x]}});k.push(E);const A=new Ave(v,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],D=s.runWebGLProgram(A,[n],"float32",R),L=ke({inputs:{x:D},backend:s,attrs:{shape:v}});k.push(D),k.push(L);const F=r!=null,_=i!=null,V=o==="leakyrelu",Q=o?pp(o,!0):null,ne=new VU(b?L.shape:E.shape,b?E.shape:L.shape,b?[t.batchSize,w,t.outChannels]:[t.batchSize,t.outChannels,w],C,N,F,Q,_,V),Z=b?[L,E]:[E,L];if(r&&Z.push(r),_&&Z.push(i),V){const K=s.makeTensorInfo([],"float32",Oa(a,"float32"));Z.push(K),k.push(K)}const B=s.runWebGLProgram(ne,Z,"float32"),U=ke({inputs:{x:B},backend:s,attrs:{shape:t.outShape}});k.push(B);for(const K of k)s.disposeIntermediateTensorInfo(K);return U}function Rve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:h,dimRoundingMode:d}=s,p=Fa(l),m=Vn(r.shape,i.shape,a,h,o,d,!1,p);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=YU({x:r,filter:i,convInfo:m,backend:t});else if(m.strideWidth<=2&&p==="channelsLast"&&ae().getBool("WEBGL_EXP_CONV")){const x=new XU(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=t.runWebGLProgram(x,[r,i],"float32",w)}else if(ae().getBool("WEBGL_CONV_IM2COL"))y=JU({x:r,filter:i,convInfo:m,backend:t});else{const x=new KU(m);y=t.runWebGLProgram(x,[r,i],"float32")}const b=ke({inputs:{x:y},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(y),b}const Dve={kernelName:Dp,backendName:"webgl",kernelFunc:Rve};class Ove{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Lve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,h=a?1:2,d=a?2:3,p=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Fve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Mve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=t-1-e.padInfo.front,h=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function zve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:h,filterShape:d}=s,p=Fa(l),m=Vn(r.shape,d,a,1,o,h,!1,p),y=new Ove(m);return t.runWebGLProgram(y,[r,i],"float32")}const Pve={kernelName:Cb,backendName:"webgl",kernelFunc:zve};class Bve{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=hs(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,i=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Vve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:h,dimRoundingMode:d}=s,p=Fa(h),m=Vn(a,i.shape,o,1,l,d,!1,p);if(ae().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new Bve(m);return t.runWebGLProgram(b,[r,i],"float32",y)}else{const y=new Lve(m);return t.runWebGLProgram(y,[r,i],"float32")}}const Uve={kernelName:Op,backendName:"webgl",kernelFunc:Vve};function jve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,h=Uo(r.shape,i.shape,a,l,o),d=new _ve(h);return t.runWebGLProgram(d,[r,i],"float32")}const Wve={kernelName:Lp,backendName:"webgl",kernelFunc:jve};function Gve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,pad:o,filterShape:l}=s,h=Uo(r.shape,l,a,1,o),d=new Fve(h);return t.runWebGLProgram(d,[r,i],"float32")}const Hve={kernelName:Nb,backendName:"webgl",kernelFunc:Gve};function qve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:a,strides:o,inputShape:l}=s,h=Uo(l,i.shape,o,1,a),d=new Mve(h);return t.runWebGLProgram(d,[r,i],"float32")}const Kve={kernelName:kb,backendName:"webgl",kernelFunc:qve};const Xve=gd+`
  return cos(x);
`,Yve=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${vu}
  return result;
`,Jve=xt({opSnippet:Xve,packedOpSnippet:Yve}),Zve={kernelName:ch,backendName:"webgl",kernelFunc:Jve};const Qve=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,e1e=xt({opSnippet:Qve}),t1e={kernelName:hh,backendName:"webgl",kernelFunc:e1e};class n1e{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,l,h]=e,[d]=t,[p,m]=s;this.outputShape=[d,p,m,h];const y=r==="bilinear"?1:0,[b,x]=[`${o-1}.0`,`${l-1}.0`],[w,v,C]=p>1?[`${(o-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[N,k,E]=m>1?[`${(l-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${N});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${k};

        float in_y = ${C};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const s1e=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:h}=s,d=new n1e(r.shape,i.shape,o,l,h);return t.runWebGLProgram(d,[r,i,a],"float32")},r1e={kernelName:Ib,backendName:"webgl",kernelFunc:s1e};var gp;(function(n){n.Prod="*",n.Sum="+"})(gp||(gp={}));class j3{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===gp.Prod?"1.0":"0.0",o=s?a:`getX(${W3(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${l-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${l}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${$t(i)} coords = getOutputCoords();
        int end = ${G3(i,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${G3(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${W3(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function W3(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function G3(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function ZU(n,e,t,s,r,i){const a=e.shape.length,o=Zt([s],a);let l=e;o!=null&&(l=xs({inputs:{x:e},backend:t,attrs:{perm:o}}));const h=cn(1,a)[0];if(h!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=l.shape[h];let p=Qs({inputs:{x:l},backend:t});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new j3(n,l.shape,!1,i),b=[[m]],x=p;p=t.runWebGLProgram(y,[p],p.dtype,b),t.disposeIntermediateTensorInfo(x)}if(r){const m=new j3(n,l.shape,r,i),y=p;p=t.runWebGLProgram(m,[p],p.dtype),t.disposeIntermediateTensorInfo(y)}if(o!=null){const m=jo(o),y=xs({inputs:{x:p},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(l),y}return p}function i1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return ZU(gp.Prod,r,t,i,a,o)}const a1e={kernelName:Eb,backendName:"webgl",kernelFunc:i1e};function o1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:a,reverse:o}=s;return ZU(gp.Sum,r,t,i,a,o)}const l1e={kernelName:Fp,backendName:"webgl",kernelFunc:o1e};function u1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:a,binaryOutput:o}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),h=t.readSync(i.dataId),d=_U(l,h,i.dtype,i.shape,a);return t.makeTensorInfo([a],i.dtype,d)}else if(r.shape.length===2){const l=t.bufferSync(r),h=t.bufferSync(i),d=dbe(l,h,a,o);return t.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const c1e={kernelName:$b,backendName:"webgl",kernelFunc:u1e};class h1e{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function d1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:a}=s,o=r.shape[0],l=a==="NHWC"?r.shape[1]:r.shape[2],h=a==="NHWC"?r.shape[2]:r.shape[3],d=a==="NHWC"?r.shape[3]:r.shape[1],p=l*i,m=h*i,y=d/(i*i),b=a==="NHWC"?[o,p,m,y]:[o,y,p,m],x=new h1e(b,i,a);return t.runWebGLProgram(x,[r],r.dtype)}const f1e={kernelName:_b,backendName:"webgl",kernelFunc:d1e};class QU{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}}class ej{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,m=p;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<p;v++)y+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let v=0;v<p;v++)y+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(m+1)/2;v++){const C=v*2;if(y+=`
          xC = xCCorner + ${C*h};
          `,l===1){if(C<p&&(o%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }
              `,h===1&&C>0?y+=`
                xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                  } else {
                    xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xC${C} = xTexelC${C};
                `,C+1<p)){const N=o%2===0?mb(h):h;h%2===0&&o%2===1||h%2!==0&&o%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${N};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                    xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${C+1}.zw = vec2(0.0);
                    }
                    xTexelC${C+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                    } else {
                     xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                    }
                    `:y+=`
                    xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                    `):N===1?y+=`
                    xC${C+1} = xTexelC${C};
                    `:y+=`
                    xCOffset = xC + ${N};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                      xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${C+1}.zw = vec2(0.0);
                      }
                      xTexelC${C+1}Ready = 1;
                    }

                    xC${C+1} = xTexelC${C+1};
                    `}}else C<p&&(o%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.0);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
              `,C+1<p&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(
                  xTexelC${C}.xy, xTexelC${C+1}.xy);
              `,C+1<p&&(y+=`
                  xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                `)));C<p&&(y+=`
            wTexel = getW(r, ${C}, d1, q);
            dotProd += xC${C} * vec4(wTexel.xz, wTexel.xz);
          `,C+1<p&&(y+=`
              wTexel = getW(r, ${C+1}, d1, q);
              dotProd += xC${C+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function p1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:h}=s;let d=l;d==null&&(d=[1,1]),O(Zn(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=Vn(r.shape,i.shape,a,d,o,h,!0);let m;ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new ej(p):m=new QU(p);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(m,[r,i],"float32",y)}const m1e={kernelName:Mp,backendName:"webgl",kernelFunc:p1e};class g1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class y1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,o=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function b1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:h,filterShape:d}=s,p=Vn(r.shape,d,a,o,l,h,!0),m=new g1e(p);return t.runWebGLProgram(m,[r,i],"float32")}const x1e={kernelName:Ab,backendName:"webgl",kernelFunc:b1e};function w1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:h,inputShape:d}=s,p=Vn(d,i.shape,a,o,l,h,!0),m=new y1e(p);return t.runWebGLProgram(m,[r,i],"float32")}const v1e={kernelName:Rb,backendName:"webgl",kernelFunc:w1e};class S1e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function T1e(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=he(s.shape),a=ke({inputs:{x:s},backend:t,attrs:{shape:[i]}}),o=new S1e(i),l=t.runWebGLProgram(o,[a],a.dtype),h=ke({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),h}const C1e={kernelName:Db,backendName:"webgl",kernelFunc:T1e};class N1e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:l,dilationHeight:h,dilationWidth:d}=e,{top:p,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function k1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:a,pad:o,dilations:l}=s,h=Em(r.shape,i.shape,a,o,"NHWC",l);let d;const p=new N1e(h);d=t.runWebGLProgram(p,[r,i],"float32");const m=ke({inputs:{x:d},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(d),m}const E1e={kernelName:zp,backendName:"webgl",kernelFunc:k1e};function I1e(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:a,summedDims:o,idDims:l}=ik(r,i.length);ok(a.length,l,i);const{path:h,steps:d}=lk(o,l),p=d.length;let m=null,y=a.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:v,expandDims:C}=ak(y,l[w]);let N;uk(v)?N=i[w]:(N=xs({inputs:{x:i[w]},backend:t,attrs:{perm:v}}),b.push(N));const k=N.shape.slice();for(let E=0;E<C.length;++E)k.splice(C[E],0,1);at(N.shape,k)||(N=ke({inputs:{x:N},backend:t,attrs:{shape:k}}),b.push(N)),m===null?m=N:(m=pI({inputs:{a:N,b:m},backend:t}),b.push(m))}x<p-1&&(h[x]>=0&&(m=Mw({inputs:{x:m},backend:t,attrs:{axis:h[x]-(a.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const $1e={kernelName:Lb,backendName:"webgl",kernelFunc:I1e};const _1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",A1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,R1e=xt({opSnippet:_1e,packedOpSnippet:A1e}),D1e={kernelName:fh,backendName:"webgl",kernelFunc:R1e};const O1e="return (b >= 0.0) ? a : a * (b + 1.0);",L1e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,F1e=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=ae().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(L1e,s.shape,r.shape):new ou(O1e,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},M1e={kernelName:Fb,backendName:"webgl",kernelFunc:F1e};const z1e=`
  return vec4(equal(a, b));
`,P1e="return float(a == b);",B1e=ts({opSnippet:P1e,packedOpSnippet:z1e,dtype:"bool",cpuKernelImpl:ybe}),V1e={kernelName:Pp,backendName:"webgl",kernelFunc:B1e};const U1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ZN};
  float a1 = ${QN};
  float a2 = ${ek};
  float a3 = ${tk};
  float a4 = ${nk};
  float a5 = ${sk};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,j1e=xt({opSnippet:U1e}),W1e={kernelName:ph,backendName:"webgl",kernelFunc:j1e};const G1e=gd+`
  return exp(x);
`,H1e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tj=xt({opSnippet:G1e,packedOpSnippet:H1e,cpuKernelImpl:bbe,dtype:"float32"}),q1e={kernelName:mh,backendName:"webgl",kernelFunc:tj};function SC(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(O(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),ke({inputs:{x:i},backend:s,attrs:{shape:o}})}const K1e={kernelName:Bp,backendName:"webgl",kernelFunc:SC};const H3="return exp(x) - 1.0;",X1e=xt({opSnippet:H3,packedOpSnippet:H3,cpuKernelImpl:xbe}),Y1e={kernelName:gh,backendName:"webgl",kernelFunc:X1e};class q3{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function nj(n,e,t){const s=t.texData.get(n.dataId),r=he(n.shape),i=n.shape[n.shape.length-1],a=r/i,o=ke({inputs:{x:n},backend:t,attrs:{shape:[a,i]}}),l=o.shape,h=new q3("real",l,e),d=new q3("imag",l,e),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],m=t.runWebGLProgram(h,p,"float32"),y=t.runWebGLProgram(d,p,"float32"),b=Xo({inputs:{real:m,imag:y},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y);const x=ke({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(b),x}function J1e(n){const{inputs:e,backend:t}=n,{input:s}=e;return nj(s,!1,t)}const Z1e={kernelName:Mb,backendName:"webgl",kernelFunc:J1e};class Q1e{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function ug(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||uu(r),i==="string"){const a=tn(i,he(s));return a.fill(r),e.makeTensorInfo(s,i,a)}else{const a=new Q1e(s,r),o=[[r]];return e.runWebGLProgram(a,[],i,o)}}const eSe={kernelName:zb,backendName:"webgl",kernelFunc:ug};class tSe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const nSe={kernelName:Pb,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new tSe(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const K3="return floor(x);",sSe=xt({opSnippet:K3,packedOpSnippet:K3,cpuKernelImpl:wbe}),rSe={kernelName:yh,backendName:"webgl",kernelFunc:sSe};const iSe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,aSe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,oSe=ts({opSnippet:iSe,packedOpSnippet:aSe,dtype:"int32"}),lSe={kernelName:bh,backendName:"webgl",kernelFunc:oSe};class uSe{constructor(e){this.variableNames=["A"];const t=Ss(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class cSe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ss(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const hSe={kernelName:D0,backendName:"webgl",kernelFunc:dSe};let gc,GS=ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function dSe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,a=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,h]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,l],p=[h,l,i];if(o||a){const x=ae().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(gc==null||x!==GS)&&(GS=x,gc=document.createElement("canvas").getContext("2d",{willReadFrequently:GS})),gc.canvas.width=l,gc.canvas.height=h,gc.drawImage(r,0,0,l,h),r=gc.canvas}const m=t.makeTensorInfo(d,"int32");t.texData.get(m.dataId).usage=xr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const y=ae().getBool("WEBGL_PACK")?new cSe(p):new uSe(p),b=t.runWebGLProgram(y,[m],"int32");return t.disposeData(m.dataId),b}function fSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=Fa(d),w=Vn(r.shape,i.shape,l,p,h,m,!1,x);let v;const C=[],N=a!=null,k=o!=null,E=y==="leakyrelu",A=()=>{const D=[r,i],L=(F,_)=>{if(_==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){const V=ke({inputs:{x:F},backend:t,attrs:{shape:[F.shape[0],1,1]}});return C.push(V),V}return F};if(N&&D.push(L(a,d)),k&&D.push(L(o,d)),E){const F=t.makeTensorInfo([],"float32",Oa(b,"float32"));D.push(F),C.push(F)}return D};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))v=YU({x:r,filter:i,convInfo:w,backend:t,bias:a,activation:y,preluActivationWeights:o,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&ae().getBool("WEBGL_EXP_CONV")){const D=y?pp(y,!0):null,L=new XU(w,N,D,k,E),F=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],_=A();v=t.runWebGLProgram(L,_,"float32",F)}else if(ae().getBool("WEBGL_CONV_IM2COL"))v=JU({x:r,filter:i,convInfo:w,backend:t,bias:a,activation:y,preluActivationWeights:o,leakyreluAlpha:b});else{const D=y?pp(y,!1):null,L=new KU(w,N,D,k,E),F=A();v=t.runWebGLProgram(L,F,"float32")}const R=ke({inputs:{x:v},backend:t,attrs:{shape:w.outShape}});return C.push(v),C.forEach(D=>t.disposeIntermediateTensorInfo(D)),R}const pSe={kernelName:Qf,backendName:"webgl",kernelFunc:fSe};function mSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),O(Zn(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const w=Vn(r.shape,i.shape,l,x,h,p,!0),v=ae().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,C=m?pp(m,v):null,N=[r,i],k=a!=null,E=o!=null,A=m==="leakyrelu";if(k&&N.push(a),E&&N.push(o),A){const F=t.makeTensorInfo([],"float32",Oa(y,"float32"));N.push(F),b.push(F)}let R;v?R=new ej(w,k,C,E,A):R=new QU(w,k,C,E,A);const D=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],L=t.runWebGLProgram(R,N,"float32",D);return b.forEach(F=>t.disposeIntermediateTensorInfo(F)),L}const gSe={kernelName:ep,backendName:"webgl",kernelFunc:mSe};class ySe{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=$t(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function bSe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,a=i[i.length-1],o=he(s.shape),[l,h,d,p]=lw(s,r),m=ke({inputs:{x:r},backend:t,attrs:{shape:[h,a]}}),y=ke({inputs:{x:s},backend:t,attrs:{shape:[he(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const v=t.readSync(r.dataId),C=t.bufferSync(s),N=vbe(v,C,s.dtype,h,a,d,p,s.shape,o);return t.makeTensorInfo(l,s.dtype,N.values)}const b=new ySe(a,p,[h,d],s.shape),x=t.runWebGLProgram(b,[y,m],y.dtype),w=ke({inputs:{x},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),w}const xSe={kernelName:Bb,backendName:"webgl",kernelFunc:bSe};class wSe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=$t(this.rank),r=vSe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function vSe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function sj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:a,batchDims:o}=s,l=st(a,r.shape)[0];if(ae().get("DEBUG")){const C=t.readSync(i.dataId),N=r.shape[l];for(let k=0;k<C.length;++k){const E=C[k];O(E<=N-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${N-1}]`)}}const h=hk(r,i,l,o),d=he(i.shape),p=[],m=ke({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=ke({inputs:{x:i},backend:t,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(m),p.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const C=t.bufferSync(y),N=t.bufferSync(m),k=Sbe(N,C,b);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(h.outputShape,k.dtype,k.values)}const x=new wSe(m.shape,b),w=t.runWebGLProgram(x,[m,y],m.dtype);p.push(w);const v=ke({inputs:{x:w},backend:t,attrs:{shape:h.outputShape}});return p.forEach(C=>t.disposeIntermediateTensorInfo(C)),v}const SSe={kernelName:Up,backendName:"webgl",kernelFunc:sj};const TSe="return float(a > b);",CSe=`
  return vec4(greaterThan(a, b));
`,NSe=ts({opSnippet:TSe,packedOpSnippet:CSe,cpuKernelImpl:Tbe,dtype:"bool"}),kSe={kernelName:jp,backendName:"webgl",kernelFunc:NSe};const ESe="return float(a >= b);",ISe=`
  return vec4(greaterThanEqual(a, b));
`,$Se=ts({opSnippet:ESe,packedOpSnippet:ISe,dtype:"bool",cpuKernelImpl:Cbe}),_Se={kernelName:xh,backendName:"webgl",kernelFunc:$Se};function ASe(n){const{inputs:e,backend:t}=n,{input:s}=e;return nj(s,!0,t)}const RSe={kernelName:Vb,backendName:"webgl",kernelFunc:ASe};const DSe="return float(!isnan(x) && !isinf(x));",OSe=xt({opSnippet:DSe,dtype:"bool"}),LSe={kernelName:vh,backendName:"webgl",kernelFunc:OSe};const FSe="return float(isinf(x));",MSe=xt({opSnippet:FSe,dtype:"bool"}),zSe={kernelName:Sh,backendName:"webgl",kernelFunc:MSe};const PSe="return float(isnan(x));",BSe=xt({opSnippet:PSe,dtype:"bool"}),VSe={kernelName:Th,backendName:"webgl",kernelFunc:BSe};const USe="return float(a < b);",jSe=`
  return vec4(lessThan(a, b));
`,WSe=ts({opSnippet:USe,packedOpSnippet:jSe,cpuKernelImpl:Nbe,dtype:"bool"}),GSe={kernelName:Gp,backendName:"webgl",kernelFunc:WSe};const HSe="return float(a <= b);",qSe=`
  return vec4(lessThanEqual(a, b));
`,KSe=ts({opSnippet:HSe,packedOpSnippet:qSe,cpuKernelImpl:kbe,dtype:"bool"}),XSe={kernelName:Hp,backendName:"webgl",kernelFunc:KSe};function YSe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,a=Ebe(s,r,i);return e.makeTensorInfo([a.length],"float32",a)}const JSe={kernelName:jb,backendName:"webgl",kernelFunc:YSe};const ZSe=gd+`
  return x < 0.0 ? 0./0. : log(x);
`,QSe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,eTe=xt({opSnippet:ZSe,packedOpSnippet:QSe,cpuKernelImpl:Ibe}),tTe={kernelName:Ch,backendName:"webgl",kernelFunc:eTe};const nTe=gd+`
  return log(1.0 + x);
`,sTe=xt({opSnippet:nTe}),rTe={kernelName:Nh,backendName:"webgl",kernelFunc:sTe};const iTe="return float(a >= 1.0 && b >= 1.0);",aTe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,oTe=ts({opSnippet:iTe,packedOpSnippet:aTe,dtype:"bool"}),lTe={kernelName:qp,backendName:"webgl",kernelFunc:oTe};const uTe="return float(!(x >= 1.0));",cTe=xt({opSnippet:uTe}),hTe={kernelName:Kp,backendName:"webgl",kernelFunc:cTe};const dTe="return float(a >= 1.0 || b >= 1.0);",fTe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,pTe=ts({opSnippet:dTe,packedOpSnippet:fTe,dtype:"bool"}),mTe={kernelName:Xp,backendName:"webgl",kernelFunc:pTe};class gTe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let l;const h=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${h})`:i===1?l=`1.0/(${h})`:l=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class yTe{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let l;const h=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${h})`:i===1?l=`1.0/(${h})`:l=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const bTe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=s,h=ae().getBool("WEBGL_PACK_NORMALIZATION")?new yTe(r.shape,i,a,o,l):new gTe(r.shape,i,a,o,l);return t.runWebGLProgram(h,[r],r.dtype)},xTe={kernelName:Yp,backendName:"webgl",kernelFunc:bTe};class wTe{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const vTe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:h,beta:d}=s,p=new wTe(r.shape,o,l,h,d);return t.runWebGLProgram(p,[r,i,a],r.dtype)},STe={kernelName:Wb,backendName:"webgl",kernelFunc:vTe};function TTe(n,e,t,s){const r=he(e),a=he(n.shape)/r,o=ke({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=Su(o,n.dtype,"max",s),h=ke({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),h}function rj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,l=st(i,r.shape);let h=l;const d=Zt(h,o),p=d!=null,m=t.shouldExecuteOnCPU([r]);let y=r;if(p){if(m){const N=t.texData.get(y.dataId).values,k=new Array(o);for(let R=0;R<k.length;R++)k[R]=r.shape[d[R]];const E=dI(N,r.shape,r.dtype,d,k);y=t.makeTensorInfo(k,r.dtype);const A=t.texData.get(y.dataId);A.values=E}else y=Fw(r,d,t);h=cn(h.length,o)}Qn("max",h,o);const[b,x]=Un(y.shape,h);let w=b;a&&(w=un(b,l));let v;if(m){const N=t.texData.get(y.dataId).values,k=$be(N,he(x),w,r.dtype);v=t.makeTensorInfo(w,r.dtype);const E=t.texData.get(v.dataId);E.values=k}else v=TTe(y,x,w,t);return p&&t.disposeIntermediateTensorInfo(y),v}const CTe={kernelName:Jp,backendName:"webgl",kernelFunc:rj};const NTe=fI+`
  return max(a, b);
`,kTe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+vu+`
  return result;
`,ETe=ts({opSnippet:NTe,packedOpSnippet:kTe,cpuKernelImpl:_be}),ITe={kernelName:kh,backendName:"webgl",kernelFunc:ETe};function $Te(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;cd(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(a,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=qr(r.shape,i,a,h,o,l);if(d.filterWidth===1&&d.filterHeight===1&&at(d.inShape,d.outShape))return Qs({inputs:{x:r},backend:t});const p=new mp(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const _Te={kernelName:Zp,backendName:"webgl",kernelFunc:$Te};function ATe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:h}=s,d=[1,1,1],p=La(r.shape,i,a,d,o,h,l),m=new mI(p,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const RTe={kernelName:Qp,backendName:"webgl",kernelFunc:ATe};class DTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=i-1-e.padInfo.top,l=a-1-e.padInfo.left,h=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class OTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=l-1-e.padInfo.front,m=h-1-e.padInfo.top,y=d-1-e.padInfo.left,b=l*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function LTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,a=i,{filterSize:o,strides:l,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=La(a.shape,o,l,p,h,d),y=new mI(m,"max",!0),b=t.runWebGLProgram(y,[a],a.dtype),x=new OTe(m),w=t.runWebGLProgram(x,[r,b],a.dtype);return t.disposeIntermediateTensorInfo(b),w}const FTe={kernelName:Hb,backendName:"webgl",kernelFunc:LTe};function MTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:a}=e,o=i;cd([i,a],"maxPoolGrad");const{filterSize:l,strides:h,pad:d,dimRoundingMode:p}=s,m=qr(o.shape,l,h,1,d,p),y=!0,b=new mp(m,"max",y),x=t.runWebGLProgram(b,[o],o.dtype),w=new DTe(m),v=t.runWebGLProgram(w,[r,x],o.dtype);return t.disposeIntermediateTensorInfo(x),v}const zTe={kernelName:Gb,backendName:"webgl",kernelFunc:MTe};function PTe(n,e,t,s){let r=new mp(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new mp(t,"max",!0,!0,e);const a=s.runWebGLProgram(r,[n],"float32");return[i,a]}const BTe={kernelName:qb,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:a,includeBatchInIndex:o}=e,l=t;O(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];O(Zn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=qr(s.shape,r,i,h,a),[p,m]=PTe(s,o,d,l);return[p,m]}};function VTe(n,e,t,s){const r=he(e),a=he(n.shape)/r,o=ke({inputs:{x:n},attrs:{shape:[a,r]},backend:s}),l=Su(o,"float32","mean",s),h=ke({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),h}const UTe={kernelName:em,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,a=t,o=s.shape.length,l=st(i,s.shape);let h=l;const d=Zt(h,o),p=d!=null,m=a.shouldExecuteOnCPU([s]),y=[];let b=s;if(p){if(m){const k=a.texData.get(b.dataId).values,E=new Array(o);for(let D=0;D<E.length;D++)E[D]=s.shape[d[D]];const A=dI(k,s.shape,s.dtype,d,E);b=a.makeTensorInfo(E,s.dtype);const R=a.texData.get(b.dataId);R.values=A}else b=Fw(s,d,a);y.push(b),h=cn(h.length,o)}Qn("sum",h,o);const[x,w]=Un(b.shape,h);let v=x;r&&(v=un(x,l));const C=VTe(b,w,v,a);for(const N of y)a.disposeIntermediateTensorInfo(N);return C}};function jTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=st(i,r.shape);let h=l;const d=Zt(h,o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,r.shape.length)),Qn("min",h,o);const[m,y]=Un(p.shape,h),b=he(y),x=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,b]}}),w=Su(x,x.dtype,"min",t);let v;if(a){const C=un(m,l);v=ke({inputs:{x:w},backend:t,attrs:{shape:C}})}else v=ke({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(p),v}const WTe={kernelName:tm,backendName:"webgl",kernelFunc:jTe};const GTe=fI+`
  return min(a, b);
`,HTe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+vu+`
  return result;
`,qTe=ts({opSnippet:GTe,packedOpSnippet:HTe,cpuKernelImpl:Abe}),KTe={kernelName:Eh,backendName:"webgl",kernelFunc:qTe};class XTe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,p)=>d[0]+e[p]+d[1]);const r=e.length,i=$t(r),a=t.map(d=>d[0]).join(","),o=t.map((d,p)=>d[0]+e[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class YTe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((b,x)=>b[0]+e[x]+b[1]);const r=e.length,i=$t(r),a=t.map(b=>b[0]).join(","),o=t.map((b,x)=>b[0]+e[x]).join(","),l=gs("rc",r),h=gs("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${l[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${l[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${l[r-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const JTe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,a=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YTe(s.shape,r,i):new XTe(s.shape,r,i);return e.runWebGLProgram(a,[s],s.dtype)},ZTe={kernelName:nm,backendName:"webgl",kernelFunc:JTe};const QTe=`if (b == 0.0) return NAN;
  return mod(a, b);`,eCe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+vu+`
  return result;
`,tCe=ts({opSnippet:QTe,packedOpSnippet:eCe}),nCe={kernelName:Ih,backendName:"webgl",kernelFunc:tCe};class sCe{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const rCe=`
if (a == b) {
  return 1.0;
};
return a / b;`,iCe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,ij=ts({opSnippet:rCe,packedOpSnippet:iCe,checkOutOfBounds:!0}),aCe={kernelName:dh,backendName:"webgl",kernelFunc:ij};const X3="return a - b;",aj=ts({opSnippet:X3,packedOpSnippet:X3,supportsComplex:!0,cpuKernelImpl:Zbe}),oCe={kernelName:Wh,backendName:"webgl",kernelFunc:aj};function oj(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,a=st([i],r.shape),o=rj({inputs:{x:r},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),l=un(o.shape,a),h=ke({inputs:{x:o},backend:t,attrs:{shape:l}}),d=aj({inputs:{a:r,b:h},backend:t}),p=tj({inputs:{x:d},backend:t}),m=Mw({inputs:{x:p},backend:t,attrs:{axis:a,keepDims:!1}}),y=ke({inputs:{x:m},backend:t,attrs:{shape:l}}),b=ij({inputs:{a:p,b:y},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const lCe={kernelName:wm,backendName:"webgl",kernelFunc:oj};function uCe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:a,normalized:o}=s,l=o?r:oj({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),h=l.shape[0],d=l.shape[1],p=new sCe(h,d,i),m=[[a]],y=t.runWebGLProgram(p,[l],"int32",m);return o||t.disposeIntermediateTensorInfo(l),y}const cCe={kernelName:Kb,backendName:"webgl",kernelFunc:uCe};const hCe=Xr+`
  return -x;
`,dCe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function fCe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[a,o]=Dbe(i.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}let r;return ae().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new vo(s.shape,dCe):r=new Oi(s.shape,hCe),t.runWebGLProgram(r,[s],s.dtype)}const pCe={kernelName:sm,backendName:"webgl",kernelFunc:fCe};const mCe=sw;function gCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),{selectedIndices:p}=mCe(h,d,a,o,l);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const yCe={kernelName:Xb,backendName:"webgl",kernelFunc:gCe};const bCe=rw;function xCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:h}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=bCe(d,p,a,o,l,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const wCe={kernelName:Yb,backendName:"webgl",kernelFunc:xCe};const vCe=iw;function SCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:h}=s,d=t.readSync(r.dataId),p=t.readSync(i.dataId),m=a,y=o,b=l,x=h,{selectedIndices:w,selectedScores:v}=vCe(d,p,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const TCe={kernelName:Jb,backendName:"webgl",kernelFunc:SCe};class CCe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const NCe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:i,depth:a,onValue:o,offValue:l}=s,h=he(r.shape),d=new CCe(h,a,o,l),p=ke({inputs:{x:r},backend:t,attrs:{shape:[h]}}),m=t.runWebGLProgram(d,[p],i);t.disposeIntermediateTensorInfo(p);const y=[...r.shape,a],b=ke({inputs:{x:m},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(m),b},kCe={kernelName:am,backendName:"webgl",kernelFunc:NCe};function sb(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=lg({inputs:{input:s},backend:t}),i=sb({inputs:{x:r},backend:t}),a=zw({inputs:{input:s},backend:t}),o=sb({inputs:{x:a},backend:t}),l=Xo({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return ug({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const ECe={kernelName:Cm,backendName:"webgl",kernelFunc:sb};function lj(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=lg({inputs:{input:s},backend:t}),i=lj({inputs:{x:r},backend:t}),a=zw({inputs:{input:s},backend:t}),o=sb({inputs:{x:a},backend:t}),l=Xo({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return ug({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const ICe={kernelName:im,backendName:"webgl",kernelFunc:lj};function $Ce(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return SC({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,a=e[0].dtype;e.forEach(d=>{Jn(i,d.shape,"All tensors passed to stack must have matching shapes"),O(a===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const p=SC({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(p),p}),h=qU({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const _Ce={kernelName:om,backendName:"webgl",kernelFunc:$Ce};class ACe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,d)=>h[0]+e[d]+h[1]);const r=e.length,i=$t(r),a=t.map(h=>h[0]).join(","),o=t.map((h,d)=>h[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class RCe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,w)=>x[0]+e[w]+x[1]);const r=e.length,i=$t(r),a=t.map(x=>x[0]).join(","),o=t.map((x,w)=>x[0]+e[w]).join(","),l=gs("rc",r),h=gs("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=r===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const uj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:a}=s;if(he(r.shape)===0){const h=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return ug({backend:t,attrs:{shape:h,value:a,dtype:r.dtype}})}const o=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RCe(r.shape,i,a):new ACe(r.shape,i,a),l=[[a]];return t.runWebGLProgram(o,[r],r.dtype,l)},DCe={kernelName:lm,backendName:"webgl",kernelFunc:uj};const OCe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,LCe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+vu+`
  return result;
`,FCe=ts({opSnippet:OCe,packedOpSnippet:LCe}),MCe={kernelName:_h,backendName:"webgl",kernelFunc:FCe};function zCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:a}=s,o=r.shape.length,l=[],h=st(i,r.shape);let d=h;const p=Zt(d,o);let m=r;p!=null&&(m=xs({inputs:{x:r},backend:t,attrs:{perm:p}}),d=cn(d.length,o),l.push(m)),Qn("prod",d,o);let y;if(t.shouldExecuteOnCPU([m])){const b=t.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:v}=Lbe(m.shape,m.dtype,b,d);y=t.makeTensorInfo(w,v,x)}else{const[b,x]=Un(m.shape,d),w=he(x),v=ke({inputs:{x:m},backend:t,attrs:{shape:[-1,w]}}),C=Tx(r.dtype),N=Su(v,C,"prod",t);y=ke({inputs:{x:N},backend:t,attrs:{shape:b}}),l.push(v),l.push(N)}if(a){l.push(y);const b=un(y.shape,h);y=ke({inputs:{x:y},backend:t,attrs:{shape:b}})}return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const PCe={kernelName:cm,backendName:"webgl",kernelFunc:zCe};function BCe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:o}=s,l=r.map(v=>t.readSync(v.dataId)),h=r.map(v=>v.shape),d=t.readSync(i.dataId),p=t.readSync(a.dataId),[m,y,b]=Fbe(l,h,d,i.shape,i.dtype,p,a.shape,o),x=m.map(v=>t.makeTensorInfo([v.length],"int32",v)),w=t.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const VCe={kernelName:Zb,backendName:"webgl",kernelFunc:BCe};function UCe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:i}=e,a=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(i.dataId),[h,d]=Mbe(a,s.shape,s.dtype,o,r.shape,l,i.shape),p=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const jCe={kernelName:Qb,backendName:"webgl",kernelFunc:UCe};function WCe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,h=t.readSync(r.dataId),d=t.readSync(i.dataId),p=t.readSync(a.dataId),m=o.map(w=>t.readSync(w.dataId)),y=o.map(w=>w.shape),[b,x]=zbe(h,r.shape,d,i.shape,i.dtype,p,a.shape,m,y,l);return t.makeTensorInfo(b,i.dtype,x)}const GCe={kernelName:ex,backendName:"webgl",kernelFunc:WCe};const cj=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:a}=t,o=Pbe(s,r,i,a);return e.makeTensorInfo([o.length],a,o)},HCe={kernelName:tx,backendName:"webgl",kernelFunc:cj};const qCe="return 1.0 / x;",KCe=xt({opSnippet:qCe}),XCe={kernelName:Ah,backendName:"webgl",kernelFunc:KCe};const YCe=Xr+`
  return (x < 0.0) ? 0.0 : x;
`,JCe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZCe=xt({opSnippet:YCe,packedOpSnippet:JCe}),QCe={kernelName:Rh,backendName:"webgl",kernelFunc:ZCe};const e2e=Xr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,t2e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,n2e=xt({opSnippet:e2e,packedOpSnippet:t2e}),s2e={kernelName:Dh,backendName:"webgl",kernelFunc:n2e};class r2e{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,l,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class i2e{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],p=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function a2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,h]=o,d=ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new i2e(r.shape,l,h,i,a):new r2e(r.shape,l,h,i,a);return t.runWebGLProgram(d,[r],"float32")}const o2e={kernelName:fm,backendName:"webgl",kernelFunc:a2e};class l2e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,l=[s&&a>1?r-1:r,s&&o>1?i-1:i],h=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=l[0]/h[0],p=l[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function u2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new l2e(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const c2e={kernelName:rx,backendName:"webgl",kernelFunc:u2e};class h2e{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[a,o,l,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class d2e{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,h]=e;this.outputShape=[a,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],p=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function f2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,h]=o,d=ae().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new d2e(r.shape,l,h,i,a):new h2e(r.shape,l,h,i,a);return t.runWebGLProgram(d,[r],r.dtype)}const p2e={kernelName:dm,backendName:"webgl",kernelFunc:f2e};class m2e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,a,o]=e,l=[s&&a>1?r-1:r,s&&o>1?i-1:i],h=[s&&a>1?a-1:a,s&&o>1?o-1:o],d=l[0]/h[0],p=l[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function g2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:a}=s,o=new m2e(i.shape,r.shape,a);return t.runWebGLProgram(o,[i],i.dtype)}const y2e={kernelName:sx,backendName:"webgl",kernelFunc:g2e};class b2e{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,i=e.map((o,l)=>r(l)).join(","),a=$t(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class x2e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=gs("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=$t(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${h(r.slice())};
          }
          if(${a}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=e.map((C,N)=>y(N,b)),w=x.join(","),v=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${v}))`}function y(b,x){return t.indexOf(b)!==-1&&e[b]!==1?`${e[b]} - ${x[b]} - 1`:`${x[b]}`}}}function w2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,a=r.shape.length,o=st(i,r.shape);if(a===0)return Qs({inputs:{x:r},backend:t});const l=ae().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new x2e(r.shape,o):new b2e(r.shape,o);return t.runWebGLProgram(l,[r],r.dtype)}const v2e={kernelName:pm,backendName:"webgl",kernelFunc:w2e};class S2e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const T2e={kernelName:vx,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:a}=e,o=t,l=new S2e(s.shape,i),[h,d]=XN(a,s.shape[1],s.shape[2]),p=[[h,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[s],s.dtype,p)}};const C2e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,N2e=xt({opSnippet:C2e}),k2e={kernelName:Oh,backendName:"webgl",kernelFunc:N2e};const E2e="return inversesqrt(x);",I2e=xt({opSnippet:E2e,cpuKernelImpl:Bbe}),$2e={kernelName:Lh,backendName:"webgl",kernelFunc:I2e};class gI{constructor(e,t,s,r,i,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const h=$t(i.length),d=$t(a.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,v=t>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class _2e{constructor(e,t,s,r,i,a,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const h=$t(i.length),d=$t(a.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,v=t>1?"strides[j]":"strides",C=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${C};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function A2e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:h,strides:d,outputSize:p}=qo(i,r,a),m=[p/h,h];if(p===0)return t.makeTensorInfo(a,r.dtype);const y=ke({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),b=ke({inputs:{x:i},backend:t,attrs:{shape:[l,h]}}),x=t.makeTensorInfo([],"float32",new Float32Array([0]));let w;ae().getBool("WEBGL_PACK")?w=new _2e(l,o,y.shape.length,b.shape.length,d,m):w=new gI(l,o,y.shape.length,b.shape.length,d,m);const v=t.runWebGLProgram(w,[b,y,x],b.dtype),C=ke({inputs:{x:v},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(x),C}const R2e={kernelName:ix,backendName:"webgl",kernelFunc:A2e};class D2e{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=ae().getNumber("WEBGL_VERSION")===2?i:a,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function O2e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:i}=e,{side:a}=s,o=new D2e(r.shape[0],r.shape[1],i.shape[1],a),l=[[r.shape[1]]];return t.runWebGLProgram(o,[r,i],"int32",l)}const L2e={kernelName:ox,backendName:"webgl",kernelFunc:O2e};class F2e{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],h=[];for(let d=0;d<t.length;d++)h.push(`${o[d]}`),d<e&&l.push(`${o[d]}`);r=l.join(),i=h.join()}const a=$t(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function M2e(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,a=new F2e(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(a,[s,r,i],_s(r.dtype,i.dtype))}const z2e={kernelName:mm,backendName:"webgl",kernelFunc:M2e};const P2e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${hw};
  float scale = ${dw};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,B2e=xt({opSnippet:P2e}),V2e={kernelName:Fh,backendName:"webgl",kernelFunc:B2e};const U2e=gd+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,j2e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,W2e=xt({opSnippet:U2e,packedOpSnippet:j2e,cpuKernelImpl:Ube}),G2e={kernelName:Bh,backendName:"webgl",kernelFunc:W2e};const H2e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,q2e=xt({opSnippet:H2e}),K2e={kernelName:Ph,backendName:"webgl",kernelFunc:q2e};const X2e=gd+`
  return sin(x);
`,Y2e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${vu}
  return result;
`,J2e=xt({opSnippet:X2e,packedOpSnippet:Y2e}),Z2e={kernelName:Mh,backendName:"webgl",kernelFunc:J2e};const Q2e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,eNe=xt({opSnippet:Q2e}),tNe={kernelName:zh,backendName:"webgl",kernelFunc:eNe};const nNe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,sNe=xt({opSnippet:nNe}),rNe={kernelName:Vh,backendName:"webgl",kernelFunc:sNe};const iNe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:a}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=i.reduce((v,C)=>v*C),l=[[0,0]];l.push(...a);for(let v=1+i.length;v<r.shape.length;++v)l.push([0,0]);const h=[],d=uj({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),p=Gm(d.shape,i,o,!1),m=Hm(p.length,i.length,!1),y=qm(d.shape,i,o,!1),b=ke({inputs:{x:d},backend:t,attrs:{shape:p}}),x=xs({inputs:{x:b},backend:t,attrs:{perm:m}}),w=ke({inputs:{x},backend:t,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(v=>t.disposeIntermediateTensorInfo(v)),w},aNe={kernelName:bm,backendName:"webgl",kernelFunc:iNe};function oNe(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),h=t.readSync(i.dataId),d=t.readSync(a.dataId)[0],[p,m,y,b,x]=Wbe(o,s.shape,s.dtype,l,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,p),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const lNe={kernelName:lx,backendName:"webgl",kernelFunc:oNe};function uNe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(t.readSync(r.dataId)),o=t.readSync(s.dataId),l=Array.from(t.readSync(i.dataId)),[h,d,p]=Gbe(o,s.shape,s.dtype,a,l);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const cNe={kernelName:ux,backendName:"webgl",kernelFunc:uNe};function hNe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(i.dataId),[h,d]=RU(a,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(d,s.dtype,h)}const dNe={kernelName:cx,backendName:"webgl",kernelFunc:hNe};function fNe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(i.dataId),[h,d]=RU(a,s.shape,s.dtype,o,l);return t.makeTensorInfo(d,s.dtype,h)}const pNe={kernelName:hx,backendName:"webgl",kernelFunc:fNe};function mNe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=qo(i,r,o),y=!1;if(i.dtype==="string"){const v=t.bufferSync(r),C=t.bufferSync(i),N=Na(t.readSync(a.dataId)[0]),k=Vbe(v,C,o,m,d,h,l,p,N,y);return t.makeTensorInfo(o,k.dtype,k.values)}const b=new gI(h,l,r.shape.length,i.shape.length,p,[m,1],y),x=t.runWebGLProgram(b,[i,r,a],i.dtype),w=ke({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(x),w}const gNe={kernelName:dx,backendName:"webgl",kernelFunc:mNe};function yNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:a}=s,o=st(a,r.shape)[0],l=ck(r,i,o),h=r.shape.length,d=new Array(h).fill(0),p=r.shape.slice();return l.map(m=>{const y=[...p];y[o]=m;const b=yd({inputs:{x:r},backend:t,attrs:{begin:d,size:y}});return d[o]+=m,b})}const bNe={kernelName:xm,backendName:"webgl",kernelFunc:yNe};const Y3="return sqrt(x);",xNe=xt({opSnippet:Y3,packedOpSnippet:Y3,cpuKernelImpl:Hbe}),wNe={kernelName:Uh,backendName:"webgl",kernelFunc:xNe};const vNe="return x * x;",SNe=xt({opSnippet:vNe}),TNe={kernelName:fx,backendName:"webgl",kernelFunc:SNe};const J3="return (a - b) * (a - b);",CNe=ts({opSnippet:J3,packedOpSnippet:J3}),NNe={kernelName:jh,backendName:"webgl",kernelFunc:CNe};function kNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(r.dataId),a=_a(i),o=qbe(a,"string",s);return t.makeTensorInfo(r.shape,"string",o)}const ENe={kernelName:vm,backendName:"webgl",kernelFunc:kNe};function INe({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Xr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new Oi(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const $Ne={kernelName:Kh,backendName:"webgl",kernelFunc:INe};class _Ne{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=$t(s.length),a=$t(s.length);let o="";if(r===1)o="coords * strides + begin";else{let l=0;o=s.map((h,d)=>(l++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}function ANe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:v,begin:C,end:N,strides:k}=GN(r.shape,i,a,o,l,h,d,p,m);let E;if(x)E=ke({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const R=UN(C,N,k),D=yd({inputs:{x:r},backend:t,attrs:{begin:C,size:R}});E=ke({inputs:{x:D},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(D)}else if(t.shouldExecuteOnCPU([r])){const D=t.readSync(r.dataId),L=Qe(r.shape,r.dtype,D),F=Kbe(y,L,k,C);E=t.makeTensorInfo(b,r.dtype,F.values)}else{const D=new _Ne(C,k,y);E=t.runWebGLProgram(D,[r],r.dtype)}const A=ke({inputs:{x:E},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(E),A}const RNe={kernelName:px,backendName:"webgl",kernelFunc:ANe};function DNe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:h}=s,{data:d,dataSplits:p}=e,m=t.readSync(d.dataId),y=t.readSync(p.dataId),[b,x]=Xbe(m,y,r,i,a,o,l,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(p.shape,"int32",x)]}const ONe={kernelName:mx,backendName:"webgl",kernelFunc:DNe};function LNe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(i.dataId),l=t.readSync(a.dataId)[0],[h,d,p]=Ybe(o,l,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const FNe={kernelName:gx,backendName:"webgl",kernelFunc:LNe};function MNe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(i.dataId),o=Jbe(a,r);return t.makeTensorInfo(i.shape,"int32",o)}const zNe={kernelName:yx,backendName:"webgl",kernelFunc:MNe};const PNe="return tan(x);",BNe=xt({opSnippet:PNe}),VNe={kernelName:Gh,backendName:"webgl",kernelFunc:BNe};const UNe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,jNe=xt({opSnippet:UNe}),WNe={kernelName:Hh,backendName:"webgl",kernelFunc:jNe};function GNe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:i,updates:a}=e,{sliceRank:o,numUpdates:l,sliceSize:h,strides:d,outputSize:p}=qo(a,i,r.shape),m=[p/h,h];if(p===0)return t.makeTensorInfo(r.shape,i.dtype);const y=ke({inputs:{x:i},backend:t,attrs:{shape:[l,o]}}),b=ke({inputs:{x:a},backend:t,attrs:{shape:[l,h]}}),x=ke({inputs:{x:r},backend:t,attrs:{shape:m}}),w=new gI(l,o,y.shape.length,b.shape.length,d,m,!1,!0),v=t.runWebGLProgram(w,[b,y,x],x.dtype),C=ke({inputs:{x:v},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),C}const HNe={kernelName:ax,backendName:"webgl",kernelFunc:GNe};class qNe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const r=$t(this.rank),i=KNe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function KNe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function hj(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),h=r.dtype==="string"?l.map(m=>Na(m)):l,d=Qe(r.shape,r.dtype,h),p=Qbe(d,i);return t.makeTensorInfo(p.shape,p.dtype,p.values)}const a=new qNe(r.shape,i);return t.runWebGLProgram(a,[r],r.dtype)}const XNe={kernelName:qh,backendName:"webgl",kernelFunc:hj};class YNe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class JNe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function wl(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Z3(n){let e=1;for(;e<n;)e*=2;return e}function ZNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:a}=s,o=ae().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ae().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(t.shouldExecuteOnCPU([r])||d<o||i>l){const F=t.readSync(r.dataId),[_,V]=exe(F,h,r.dtype,i,a);return[t.makeTensorInfo(_.shape,_.dtype,_.values),t.makeTensorInfo(V.shape,V.dtype,V.values)]}if(i===0)return h[h.length-1]=0,[t.makeTensorInfo(h,r.dtype,[]),t.makeTensorInfo(h,"int32",[])];if(d===1)return[r,ug({attrs:{shape:h,dtype:"int32",value:0},backend:t})];const p=t.texData.get(r.dataId),m=p!==null&&p.isPacked,y=m?t.unpackTensor(r):r,x=he(h)/d,w=ke({inputs:{x:y},attrs:{shape:[x,d]},backend:t});m&&wl(t,y);const v=Z3(i),C=Z3(d);let N=null;const k=()=>N===null?[w,w]:[w,N],E=(F,_,V)=>{const Q=k(),ne=new YNe(V),B=[[d],[N===null?1:0],[Number.NEGATIVE_INFINITY],[F],[_]],U=N;N=t.runWebGLProgram(ne,Q,"int32",B),wl(t,U)};for(let F=1;F<v;F*=2){const _=F*2;for(let V=F;V>=1;V/=2)E(_,V,[x,C])}for(let F=C;F>v;F/=2){const _=k(),V=new JNe([x,F/2]),ne=[[d],[N===null?1:0],[v]],Z=N;N=t.runWebGLProgram(V,_,"int32",ne),wl(t,Z);const B=v/2,U=B*2;for(let K=B;K>=1;K/=2)E(U,K,N.shape)}let A=N;N=yd({inputs:{x:N},backend:t,attrs:{begin:0,size:[x,i]}}),wl(t,A);let R=sj({inputs:{x:w,indices:N},backend:t,attrs:{axis:1,batchDims:1}});wl(t,w);const D=h.slice(0,-1);D.push(i),A=N,N=ke({inputs:{x:N},attrs:{shape:D},backend:t}),wl(t,A);const L=R;return R=ke({inputs:{x:R},attrs:{shape:D},backend:t}),wl(t,L),[R,N]}const QNe={kernelName:bx,backendName:"webgl",kernelFunc:ZNe};class eke{constructor(e,t,s,r,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function tke(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:h}=s,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],v=new eke(p,m,a,o,l,w);return t.runWebGLProgram(v,[r,i],"float32")}const nke={kernelName:xx,backendName:"webgl",kernelFunc:tke};function ske(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;cd(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:l,indices:h}=txe(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const rke={kernelName:wx,backendName:"webgl",kernelFunc:ske};function ike(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],h=new Array(o-1);let d=0;for(let x=0;x<o;x++)x!==i&&(h[d++]=a.shape[x]);const p=[],m=new Array(o).fill(0),y=a.shape.slice();y[i]=1;const b=new Array(l);for(let x=0;x<b.length;x++){m[i]=x;const w=yd({inputs:{x:a},backend:t,attrs:{begin:m,size:y}}),v=ke({inputs:{x:w},backend:t,attrs:{shape:h}});b[x]=v,p.push(w)}return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const ake={kernelName:Sm,backendName:"webgl",kernelFunc:ike};class oke{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,o=a*Math.ceil(i/s);this.outputShape=[r,o];const l="0.0",h="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function lke(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:a}=s,o=r.shape.length,l=[];let h=0;const d=Zt([h],o);let p=r;d!=null&&(p=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),l.push(p),h=cn(1,o)[0]);const m=UP(p.shape,h,a),y=he([p.shape[h]]),b=ke({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}});l.push(b);const x=Tx(r.dtype),w=(k,E,A,R,D)=>{const L=k.shape[0],F=k.shape[1],_=VP(F,D),V={windowSize:_,inSize:F,batchSize:L,numSegments:D},Q=new oke(V,E),ne=t.compileAndRun(Q,[k,A],R);if(l.push(ne),ne.shape[1]===D)return ne;const Z=cj({backend:t,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),B=hj({inputs:{x:Z},backend:t,attrs:{reps:[F/_]}});return l.push(Z),l.push(B),w(ne,E,B,R,D)},v=w(b,"unsortedSegmentSum",i,x,a),C=ke({inputs:{x:v},backend:t,attrs:{shape:m}});let N=C;if(d!=null){l.push(C);const k=jo(d);N=xs({inputs:{x:N},backend:t,attrs:{perm:k}})}return l.forEach(k=>t.disposeIntermediateTensorInfo(k)),N}const uke={kernelName:Tm,backendName:"webgl",kernelFunc:lke};const cke=[qxe,Xxe,Zxe,twe,swe,awe,lwe,cwe,pwe,gwe,xwe,Swe,Nwe,$we,Rwe,Owe,Fwe,Bwe,Uwe,Wwe,Kwe,tve,sve,ove,uve,mve,yve,vve,_xe,Cve,$ve,Dve,Pve,Uve,Wve,Hve,Kve,Zve,t1e,r1e,a1e,l1e,c1e,f1e,m1e,x1e,v1e,C1e,E1e,$1e,D1e,M1e,V1e,W1e,q1e,K1e,Y1e,Z1e,eSe,nSe,rSe,lSe,hSe,pSe,gSe,xSe,SSe,kSe,_Se,$xe,RSe,Eve,LSe,zSe,VSe,Rxe,GSe,XSe,JSe,tTe,rTe,lTe,hTe,mTe,xTe,STe,CTe,ITe,_Te,RTe,FTe,zTe,BTe,UTe,WTe,KTe,ZTe,nCe,cCe,Lxe,pCe,yCe,wCe,TCe,hve,kCe,ICe,_Ce,DCe,MCe,Oxe,PCe,VCe,jCe,GCe,HCe,dve,aCe,XCe,QCe,s2e,Mxe,o2e,c2e,p2e,y2e,v2e,T2e,k2e,$2e,R2e,L2e,z2e,V2e,G2e,K2e,Z2e,tNe,Qwe,lCe,rNe,aNe,lNe,cNe,dNe,pNe,gNe,bNe,wNe,TNe,NNe,ENe,$Ne,RNe,ONe,FNe,zNe,oCe,Wxe,VNe,WNe,HNe,XNe,QNe,nke,Gxe,rke,ake,uke,ECe];for(const n of cke)Sx(n);const hke="4.22.0";const dke={"tfjs-core":bP,"tfjs-backend-cpu":v4,"tfjs-backend-webgl":LU,"tfjs-data":NV,"tfjs-layers":Nw,"tfjs-converter":uV,tfjs:hke},zf=Object.freeze(Object.defineProperty({__proto__:null,Abs:Sp,Acos:eh,Acosh:th,AdadeltaOptimizer:DN,AdagradOptimizer:ON,AdamOptimizer:LN,AdamaxOptimizer:FN,Add:hu,AddN:Tp,All:yb,Any:bb,ArgMax:Cp,ArgMin:Np,Asin:nh,Asinh:sh,Atan:rh,Atan2:ah,Atanh:ih,AvgPool:kp,AvgPool3D:Ep,AvgPool3DGrad:wb,AvgPoolGrad:xb,BatchMatMul:Ip,BatchToSpaceND:$p,Bincount:vb,BitwiseAnd:_p,BroadcastArgs:Sb,BroadcastTo:bM,Callback:rV,CallbackList:oB,Cast:oh,Ceil:lh,ClipByValue:uh,Complex:Tb,ComplexAbs:Ap,Concat:Rp,Conv2D:Dp,Conv2DBackpropFilter:Cb,Conv2DBackpropInput:Op,Conv3D:Lp,Conv3DBackpropFilterV2:Nb,Conv3DBackpropInputV2:kb,Cos:ch,Cosh:hh,CropAndResize:Ib,Cumprod:Eb,Cumsum:Fp,CustomCallback:uB,DataStorage:h2,DenseBincount:$b,DepthToSpace:_b,DepthwiseConv2dNative:Mp,DepthwiseConv2dNativeBackpropFilter:Ab,DepthwiseConv2dNativeBackpropInput:Rb,Diag:Db,Dilation2D:zp,Dilation2DBackpropFilter:R0,Dilation2DBackpropInput:A0,Draw:Ob,get ENV(){return g2},EarlyStopping:iV,Einsum:Lb,Elu:fh,EluGrad:Fb,Environment:gM,Equal:Pp,Erf:ph,Exp:mh,ExpandDims:Bp,Expm1:gh,FFT:Mb,Fill:zb,FlipLeftRight:Pb,Floor:yh,FloorDiv:bh,FromPixels:D0,FusedBatchNorm:Vp,FusedConv2D:Qf,FusedDepthwiseConv2D:ep,GPGPUContext:f0,GatherNd:Bb,GatherV2:Up,GraphModel:UE,Greater:jp,GreaterEqual:xh,History:lB,IFFT:Vb,Identity:wh,Imag:Ub,InputSpec:yn,IsFinite:vh,IsInf:Sh,IsNan:Th,KernelBackend:pb,LRN:Yp,LRNGrad:Wb,LayerVariable:sB,LayersModel:va,LeakyRelu:Wp,Less:Gp,LessEqual:Hp,LinSpace:jb,Log:Ch,Log1p:Nh,LogSoftmax:xM,LogicalAnd:qp,LogicalNot:Kp,LogicalOr:Xp,LogicalXor:J7,LowerBound:Z7,MathBackendCPU:sg,MathBackendWebGL:og,MatrixBandPart:Q7,Max:Jp,MaxPool:Zp,MaxPool3D:Qp,MaxPool3DGrad:Hb,MaxPoolGrad:Gb,MaxPoolWithArgmax:qb,Maximum:kh,Mean:em,Min:tm,Minimum:Eh,MirrorPad:nm,Mod:Ih,MomentumOptimizer:MN,Multinomial:Kb,Multiply:$h,Neg:sm,NonMaxSuppressionV3:Xb,NonMaxSuppressionV4:Yb,NonMaxSuppressionV5:Jb,NotEqual:rm,OP_SCOPE_SUFFIX:v2,OneHot:am,OnesLike:im,Optimizer:Ba,OptimizerConstructors:xP,Pack:om,PadV2:lm,Pool:eX,Pow:_h,Prelu:um,Prod:cm,RMSPropOptimizer:zN,RNN:Ti,RaggedGather:Zb,RaggedRange:Qb,RaggedTensorToTensor:ex,Range:tx,get Rank(){return _T},Real:nx,RealDiv:dh,Reciprocal:Ah,get Reduction(){return ms},Relu:Rh,Relu6:Dh,Reshape:hm,ResizeBilinear:fm,ResizeBilinearGrad:rx,ResizeNearestNeighbor:dm,ResizeNearestNeighborGrad:sx,Reverse:pm,RotateWithOffset:vx,Round:Oh,Rsqrt:Lh,SGDOptimizer:aw,ScatterNd:ix,SearchSorted:ox,Select:mm,Selu:Fh,Sequential:tu,Sigmoid:Bh,Sign:Ph,Sin:Mh,Sinh:zh,Slice:gm,Softmax:wm,Softplus:Vh,SpaceToBatchND:bm,SparseFillEmptyRows:lx,SparseReshape:ux,SparseSegmentMean:cx,SparseSegmentSum:hx,SparseToDense:dx,SplitV:xm,Sqrt:Uh,Square:fx,SquaredDifference:jh,StaticRegexReplace:vm,Step:Kh,StridedSlice:px,StringNGrams:mx,StringSplit:gx,StringToHashBucketFast:yx,Sub:Wh,Sum:ym,SymbolicTensor:bi,Tan:Gh,Tanh:Hh,Tensor:bt,TensorBuffer:bn,TensorScatterUpdate:ax,Tile:qh,TopK:bx,Transform:xx,Transpose:Bl,Unique:wx,Unpack:Sm,UnsortedSegmentSum:Tm,UpperBound:tX,Variable:sp,ZerosLike:Cm,_FusedMatMul:Zf,abs:mn,acos:$2,acosh:_2,add:ve,addN:XM,all:kx,any:ip,argMax:Kl,argMin:A2,asin:R2,asinh:D2,atan:O2,atan2:L2,atanh:F2,avgPool:Im,avgPool3d:z2,backend:T2,backend_util:WP,basicLSTMCell:YM,batchNorm:Xh,batchNorm2d:P2,batchNorm3d:B2,batchNorm4d:V2,batchToSpaceND:$m,bincount:U2,bitwiseAnd:JM,booleanMaskAsync:Lz,broadcastArgs:ZM,broadcastTo:Vl,broadcast_util:RJ,browser:Yne,buffer:Qe,callbacks:fue,cast:Ne,ceil:j2,clipByValue:Rs,clone:zi,complex:Ea,concat:ln,concat1d:W2,concat2d:G2,concat3d:H2,concat4d:q2,constraints:Zie,conv1d:Ex,conv2d:Ia,conv2dTranspose:Ix,conv3d:X2,conv3dTranspose:Y2,copyRegisteredKernels:iX,cos:_m,cosh:$x,cosineWindow:Zx,cumprod:lp,cumsum:_x,customGrad:Gi,data:khe,denseBincount:F0,deprecationWarn:FX,depthToSpace:J2,depthwiseConv2d:Yh,deregisterOp:gue,device_util:_X,diag:ez,dilation2d:Z2,disableDeprecationWarnings:LX,dispose:Ke,disposeVariables:MX,div:Le,divNoNan:Q2,dot:eN,dropout:IN,einsum:Il,elu:Jh,enableDebugMode:OX,enableProdMode:DX,enclosingPowerOfTwo:$N,engine:li,ensureShape:tz,env:ae,equal:Ys,erf:Ax,euclideanNorm:nN,exp:Ds,expandDims:Hn,expm1:sN,eye:Rx,fft:jm,fill:du,findBackend:jX,findBackendFactory:WX,floor:Qh,floorDiv:Nx,forceHalfFloat:FU,fused:Wz,gather:ed,gatherND:Pz,gather_util:Jne,getBackend:LM,getGradient:IT,getKernel:np,getKernelsForBackend:O0,gpgpu_util:ube,grad:mZ,grads:gZ,greater:vs,greaterEqual:Ma,ifft:Wc,imag:Am,image:jr,inTopKAsync:Bz,initializers:pae,input:TB,io:ow,irfft:Hx,isFinite:rN,isInf:iN,isNaN:aN,keep:En,kernel_impls:ase,layers:jle,leakyRelu:Rm,less:Bc,lessEqual:Wo,linalg:RN,linspace:rz,loadGraphModel:Vce,loadGraphModelSync:Uce,loadLayersModel:roe,localResponseNormalization:oN,log:Js,log1p:Dm,logSigmoid:lN,logSoftmax:Ox,logSumExp:Om,logicalAnd:Hr,logicalNot:Lm,logicalOr:Lx,logicalXor:uN,losses:Jz,lowerBound:az,matMul:nt,math:Vne,max:Sr,maxPool:Fm,maxPool3d:cN,maxPoolWithArgmax:oz,maximum:qi,mean:Kt,memory:FT,meshgrid:lz,metrics:aue,min:Pc,minimum:Do,mirrorPad:hN,mod:dN,model:ooe,models:oue,moments:Mm,movingAverage:Fz,mul:q,multiRNNCell:uz,multinomial:cz,neg:Mt,nextFrame:HN,norm:Zh,notEqual:Jl,oneHot:Vc,ones:Is,onesLike:Zs,op:G,outerProduct:hz,pad:za,pad1d:dz,pad2d:fz,pad3d:pz,pad4d:mz,pool:fN,pow:Wi,prelu:Pm,print:I2,prod:pN,profile:zX,raggedGather:gz,raggedRange:yz,raggedTensorToTensor:bz,rand:xz,randomGamma:Sz,randomNormal:Mx,randomStandardNormal:Tz,randomUniform:Go,randomUniformInt:Cz,range:Zl,ready:VX,real:Uc,reciprocal:bN,registerBackend:S2,registerCallbackConstructor:uoe,registerGradient:wM,registerKernel:Sx,registerOp:mue,regularizers:hue,relu:vi,relu6:zx,removeBackend:UX,reshape:Y,reverse:Tr,reverse1d:Nz,reverse2d:kz,reverse3d:Ez,reverse4d:Iz,rfft:Wm,round:Px,rsqrt:Bx,scalar:Pe,scatterND:Mz,scatter_util:wee,searchSorted:Fx,selu:Vx,separableConv2d:Ux,sequential:loe,serialization:vne,setBackend:BX,setPlatform:GX,setWebGLContext:z4,setdiff1dAsync:$z,shared:w4,sigmoid:fi,sign:xN,signal:Yz,sin:jx,sinh:Wx,slice:ht,slice1d:Bm,slice2d:Gx,slice3d:Vm,slice4d:jc,slice_util:yP,softmax:Um,softplus:fu,spaceToBatchND:zm,sparse:Zz,sparseToDense:zz,spectral:Xz,split:$s,sqrt:Pn,square:It,squaredDifference:qx,squeeze:Ho,stack:bs,step:pu,stridedSlice:wN,string:Qz,sub:_e,sum:Re,sumOutType:Tx,tan:vN,tanh:Ro,tensor:Xs,tensor1d:Xn,tensor2d:To,tensor3d:SN,tensor4d:_z,tensor5d:Az,tensor6d:Rz,tensorScatterUpdate:Dz,tensor_util:NX,test_util:DQ,tidy:re,tile:br,time:PX,topk:CN,train:Cl,transpose:lt,truncatedNormal:Xx,unique:NN,unregisterGradient:rX,unregisterKernel:sX,unsortedSegmentSum:Yx,unstack:Cr,upcastType:_s,upperBound:Oz,util:fX,valueAndGrad:yZ,valueAndGrads:bZ,variable:kN,variableGrads:iz,version:dke,version_converter:uV,version_core:bP,version_cpu:v4,version_layers:Nw,version_webgl:LU,webgl:Ixe,webgl_util:m0e,where:Mn,whereAsync:EN,zeros:gn,zerosLike:dt},Symbol.toStringTag,{value:"Module"}));(function(n,e){const t=Tu,s=n();for(;;)try{if(-parseInt(t(514))/1*(parseInt(t(480))/2)+parseInt(t(531))/3*(-parseInt(t(549))/4)+parseInt(t(493))/5+parseInt(t(553))/6+parseInt(t(526))/7*(-parseInt(t(488))/8)+-parseInt(t(568))/9+-parseInt(t(562))/10*(-parseInt(t(566))/11)===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(rb,898314);const fke=async()=>{const n=Tu;try{await zf[n(508)](n(515)),await zf[n(545)]()}catch{console[n(484)](n(507)),await zf[n(508)](n(463))}};function Tu(n,e){return n=n-463,rb()[n]}fke();const Q3=3e5,pke=n=>new Promise((e,t)=>{const s=Tu,r=new Worker(new URL(s(478),import.meta.url),{type:"module"});let i=!1;const a=setTimeout(()=>{const o=s;!i&&(i=!0,r[o(536)](),t(new Error(o(565)+Q3/1e3+o(516))))},Q3);if(r[s(522)]=o=>{const l=s,{type:h,data:d}=o.data;h===l(552)?!i&&(i=!0,clearTimeout(a),r[l(536)](),e(d)):h===l(504)&&!i&&(i=!0,clearTimeout(a),r[l(536)](),t(new Error(d)))},r[s(517)]=o=>{!i&&(i=!0,clearTimeout(a),r.terminate(),t(o))},n[s(482)]?.length<Vr+20){clearTimeout(a),t(new Error(s(474)+(n[s(482)]?.length||0)+" bars, need "+(Vr+20)+"."));return}r[s(464)]({type:s(479),data:n})}),Vr=45,TC=4,HS=(n,e,t)=>(n-e)/(t||1);function rb(){const n=["adam","random","user_id, name","map"," vs ","step","max","min","push","slice","ERROR","pattern","tensor3d","WebGL failed, falling back to CPU. Performance will be reduced.","setBackend","user_id","length","layers","pow","fit","2yKvTdK","webgl","s Limit). Try again or use Fast Mode.","onerror","reduce","model_json","std","mean","onmessage","toFixed","shape","[Brain] Model shape mismatch detected (","7541513kKGcSC","technical","rsi","charCodeAt","name","339BFYOxc","Cloud Model Save Error:","). Discarding legacy model.","lstm","dispose","terminate","dense","compile","byteLength","string","Cloud Model Load Error:","ASSESS_SUCCESS","prices","error","ready","fromCharCode","dataSync","loadLayersModel","63464XZwyYb","glorotUniform","withSaveHandler","TRAIN_SUCCESS","6086238ndoBTD","fromMemory","isArray","linear","predicted","relu","meanSquaredError","maybeSingle","histogram","970EUsdlI","add","sqrt","Neural Training Timed Out (","255288mQnhtL","Bullish","575325NFwtxw","cpu","postMessage","toISOString","Neural Assessment Timed Out (","batchNormalization","regularizers","tensor2d","Cloud Artifact Save Error:","module","actual","upsert","Insufficient price history for neural training. Got ","neural","inputs","macd","./brain.worker.js","TRAIN_AND_PREDICT","740270aXmbhv","select","historicalPrices","s Limit).","warn","from","PROGRESS","weightData","8plfiog","tidy","neural_models","trainOnBatch","sentiment","6535885KoxCFx"];return rb=function(){return n},rb()}const mke=n=>{const e=Tu,{prices:t,rsi:s,macd:r,atr:i}=n,a=Math[e(501)](t[e(510)],s[e(510)],r[e(510)],i?.[e(510)]||0),o=t[e(503)](-a),l=s[e(503)](-a),h=r[e(503)](-a),d=i[e(503)](-a);return[o,l,h,d][e(497)](p=>{const m=e,y=p[m(518)]((x,w)=>x+w,0)/p.length,b=Math[m(564)](p[m(518)]((x,w)=>x+Math.pow(w-y,2),0)/p[m(510)])||1;return{mean:y,std:b}})},gke=(n,e,t)=>{const s=Tu,r=e.prices[0],i=[];for(let h=0;h<Vr;h++)i[s(502)]([(e[s(543)][h]-r)/(r||1),HS(e[s(528)][h],t[1][s(521)],t[1][s(520)]),HS(e[s(477)][h],t[2].mean,t[2].std),HS(e.atr[h],t[3][s(521)],t[3][s(520)])]);const a=zf[s(506)]([i],[1,Vr,TC]),o=n.predict(a),l=o[s(547)]()[0];return a.dispose(),o.dispose(),l*r+r},yke=n=>{n&&n.dispose()},bke=async(n,e,t,s)=>{const r=Tu;if(n)try{if(e[r(487)]instanceof ArrayBuffer){const a=new Uint8Array(e[r(487)]);let o="";for(let l=0;l<a[r(539)];l++)o+=String[r(546)](a[l]);e[r(487)]=btoa(o)}const{error:i}=await ma[r(485)](r(490))[r(473)]([{user_id:n.id,name:t,model_json:e,accuracy:s,created_at:new Date()[r(465)]()}],{onConflict:r(496)});if(i)throw i;return!0}catch(i){return console.error(r(470),i),!1}},xke=async(n,e)=>{const t=Tu;if(!n)return null;try{const{data:s,error:r}=await ma.from(t(490))[t(481)](t(519)).eq(t(509),n.id).eq(t(530),e)[t(560)]();if(r||!s)return null;const i=s[t(519)];if(typeof i[t(487)]===t(540)){const l=atob(i.weightData),h=new Uint8Array(l[t(510)]);for(let d=0;d<l[t(510)];d++)h[d]=l[t(529)](d);i[t(487)]=h.buffer}else Array[t(555)](i[t(487)])&&(i[t(487)]=new Uint8Array(i[t(487)]).buffer);const a=await zf[t(548)](ow[t(554)](i)),o=a[t(476)][0][t(524)];return o[1]!==Vr||o[2]!==TC?(console.warn(t(525)+o[1]+"x"+o[2]+t(498)+Vr+"x"+TC+t(533)),a[t(535)](),null):a}catch(s){return console.error(t(541),s),null}},Ee=dj;function dj(n,e){return n=n-193,ib()[n]}(function(n,e){const t=dj,s=n();for(;;)try{if(-parseInt(t(217))/1*(parseInt(t(278))/2)+-parseInt(t(292))/3+-parseInt(t(245))/4+parseInt(t(324))/5*(-parseInt(t(252))/6)+-parseInt(t(225))/7+parseInt(t(229))/8+parseInt(t(290))/9===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(ib,983066);function ib(){const n=["dash","2951896fNkyxx","BTC","Texas Instruments","map","quant-network","TOTAL","UnitedHealth Group","eos","arbitrum","warn","https://finnhub.io/api/v1/stock/candle?symbol=","USDT","zcash","O H L","change24h","AVAX","1035068guBsip","https://api.allorigins.win/raw?url=","Coca-Cola Co.","Eli Lilly and Co.","usd","qtum","result","84jLBxNU","aptos","high","reduce","Broadcom Inc.","shiba-inu","volume","json","Amazon.com Inc.","https://api.coingecko.com/api/v3/coins/","the-sandbox","aave","CHANGE","celo","polkadot","ripple","matic-network","Microsoft Corp.","uniswap","ethereum-classic","CRYPTO","near","MARKET","regularMarketPrice","CoinGecko","includes","6ZWoWuc","prices","tezos","DAILY","HIGH","algorand","replace","Advanced Micro Devices","PRICE","&to=","CRYPTOCURRENCY","thorchain","39134097iPyYNz","fantom","2479053LrMCUQ","compound-governance-token","NVIDIA Corp.","UTC","quote","stellar","CoinGecko Fetch Error:","-USD","slice","Home Depot Inc.","?interval=1d&range=1y","DOGE","meta","zilliqa","ADA","toUpperCase","XRP","all","pop","axie-infinity","Walmart Inc.","getItem","All proxies failed","Chevron Corp.","setItem","LOW","binancecoin","VOL","nem","JPMorgan Chase & Co.","filter","cosmos","599205GsxQrP","OPEN","filecoin","maker","&resolution=D&from=","SPDR Dow Jones","ethereum","TIME","havven","keys","neo","?interval=1h&range=7d","parse","IBM Corp.","length","Honeywell","Fetch failed for ","max","WEEKLY","Cache read compile error","match","Tesla Inc.","immutable-x","?interval=1d&range=3mo","chart","https://query1.finance.yahoo.com/v8/finance/chart/","Mastercard Inc.","stringify","USD","Apple Inc.","Berkshire Hathaway","https://corsproxy.io/?","Alphabet Inc.","min","iShares Russell 2000","now","litecoin","SPDR S&P 500 ETF","close","previousClose","cardano","CoinGecko History Error:","ETH","indicators","avalanche-2","Visa Inc.","bitcoin","finnhub_key","monero","holo","split","kusama","error","Oracle Corp.","harmony","9116yzkpzV","sort","Yahoo Finance","Intel Corp.","dogecoin","&token=","price","usd_24h_vol","6607398DVLcNZ","the-graph","vechain"];return ib=function(){return n},ib()}const Pf={BTC:Ee(208),ETH:Ee(330),SOL:"solana",XRP:Ee(267),ADA:Ee(202),DOGE:Ee(221),AVAX:Ee(206),DOT:Ee(266),MATIC:Ee(268),LINK:"chainlink",LTC:Ee(198),SHIB:Ee(257),TRX:"tron",UNI:Ee(270),ATOM:Ee(323),XMR:Ee(210),ETC:Ee(271),XLM:Ee(297),BCH:"bitcoin-cash",FIL:Ee(326),APT:Ee(253),QNT:Ee(233),NEAR:Ee(273),ARB:Ee(237),VET:Ee(227),MKR:Ee(327),AAVE:Ee(263),GRT:Ee(226),ALGO:Ee(283),AXS:Ee(311),SAND:Ee(262),EOS:Ee(236),MANA:"decentraland",THETA:"theta-token",EGLD:"elrond-erd-2",FTM:Ee(291),XTZ:Ee(280),FLOW:"flow",IMX:Ee(346),SNX:Ee(332),NEO:Ee(334),CVX:"convex-finance",CRV:"curve-dao-token",BAT:"basic-attention-token",CHZ:"chiliz",ENJ:"enjincoin",DASH:Ee(228),COMP:Ee(293),ZEC:Ee(241),XEM:Ee(320),HOT:Ee(211),IOTX:"iotex",RUNE:Ee(289),KSM:Ee(213),ZIL:Ee(305),RVN:"ravencoin",CELO:Ee(265),ONE:Ee(216),QTUM:Ee(250),BNB:Ee(318)},wke=120*1e3,vke=n=>{const e=Ee;try{const t=localStorage[e(313)]("cache_"+n);if(t){const{data:s,timestamp:r}=JSON[e(336)](t);if(Date[e(197)]()-r<wke)return s}}catch(t){console[e(238)](e(343),t)}return null},Ske=(n,e)=>{const t=Ee;try{localStorage[t(316)]("cache_"+n,JSON[t(351)]({data:e,timestamp:Date.now()}))}catch{try{localStorage.clear()}catch{}}},CC={AAPL:Ee(353),MSFT:Ee(269),GOOGL:Ee(194),AMZN:Ee(260),NVDA:Ee(294),TSLA:Ee(345),META:"Meta Platforms Inc.","BRK.B":Ee(354),V:Ee(207),JNJ:"Johnson & Johnson",WMT:Ee(312),JPM:Ee(321),PG:"Procter & Gamble Co.",MA:Ee(350),LLY:Ee(248),HD:Ee(301),CVX:Ee(315),MRK:"Merck & Co.",KO:Ee(247),PEP:"PepsiCo Inc.",AVGO:Ee(256),COST:"Costco Wholesale Corp.",ORCL:Ee(215),AMD:Ee(285),NFLX:"Netflix Inc.",INTC:Ee(220),IBM:Ee(337),QCOM:"Qualcomm Inc.",TXN:Ee(231),HON:Ee(339),UNH:Ee(235),SPY:Ee(199),QQQ:"Invesco QQQ Trust",IWM:Ee(196),DIA:Ee(329)},fj=n=>{const e=Ee;if(!n)return null;const t=n[e(344)](/\b\d{1,3}(?:[.,]\d{3})*[.,]\d{1,8}\b/g),s=n[e(344)](/\b\d{1,3}(?:,\d{3})+\b/g),r=n[e(344)](/\b\d{4,7}\b/g),i=[...t||[],...s||[],...r||[]],a=i[e(232)](l=>{const h=e,d=l[h(284)](/,/g,""),p=d[h(212)](".");if(p[h(338)]>2){const m=p[h(310)]();return parseFloat(p.join("")+"."+m)}return parseFloat(d)})[e(322)](l=>l>=2e3&&l<=3e3||l===24||l===1||l===7||l===30||l===15||l===60?!1:l>1e-4&&l<2e7);return a.length===0?null:a[e(218)]((l,h)=>{const d=l>.1&&l<15e4,p=h>.1&&h<15e4;if(d&&!p)return-1;if(!d&&p)return 1;const m=l%1!==0,y=h%1!==0;return m&&!y?-1:!m&&y?1:l-h})[0]},Tke=n=>{const e=Ee;if(!n)return null;const t=n[e(307)](),s=[e(319),e(352),e(240),e(295),"CRYPTO",e(288),e(286),e(274),e(264),e(331),e(234),e(317),e(282),e(325),"CLOSE",e(281),e(342)],r=t[e(212)](/[^A-Z0-9]/).filter(l=>l.length>=2);for(const l of Object[e(333)](Pf))if(r.includes(l))return l;const i=t[e(344)](/\b([A-Z0-9]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP|FRAX|DAI)\b/);if(i){const l=i[1];if(Pf[l]||CC[l]||l.length>=2&&!s[e(277)](l))return l}if((t.includes(e(272))||t.includes(e(242)))&&!t[e(277)]("BITCOIN")){const l=fj(n);if(l>4e4&&l<15e4)return e(230);if(l>1500&&l<1e4)return e(204)}const a={BITCOIN:"BTC",ETHEREUM:e(204),SOLANA:"SOL",RIPPLE:e(308),CARDANO:e(306),DOGECOIN:e(303),AVALANCHE:e(244)};for(const[l,h]of Object.entries(a))if(t[e(277)](l))return h;const o=t.match(/\(([A-Z0-9]{2,6})\)[ -]|^([A-Z0-9]{2,6})\s+\d/);if(o){const l=o[1]||o[2];if(Pf[l]||CC[l]||l.length>=2&&!s[e(277)](l))return l}return null},Cke=async n=>{const e=Ee,t=Pf[n];if(!t)return null;try{const s=await fetch("https://api.coingecko.com/api/v3/simple/price?ids="+t+"&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true"),r=await s.json(),i=r[t];return{price:i[e(249)],change24h:i.usd_24h_change,volume:i[e(224)],source:e(276)}}catch(s){return console[e(214)](e(298),s),null}},Nke=async(n,e=90)=>{const t=Ee,s=Pf[n];if(!s)return null;const r=vke(s+"_"+e);if(r)return r;try{const i=await fetch(t(261)+s+"/market_chart?vs_currency=usd&days="+e),a=await i[t(259)](),o=a[t(279)].map(d=>d[1]),l=a.total_volumes[t(232)](d=>d[1]),h={closes:o,highs:o[t(232)](d=>d*1.002),lows:o.map(d=>d*.998),volumes:l};return Ske(s+"_"+e,h),h}catch(i){return console[t(214)](t(203),i),null}},kke=async n=>{const e=Ee,t=n.includes("-")?n[e(284)]("-",""):n;try{const s="https://query1.finance.yahoo.com/v8/finance/chart/"+t+e(347),r=[e(193)+encodeURIComponent(s),e(246)+encodeURIComponent(s)];let i=null;for(const b of r)try{const x=await fetch(b);if(!x.ok)continue;if(i=await x[e(259)](),i?.[e(348)]?.[e(251)])break}catch{continue}if(!i)throw new Error(e(314));const a=i[e(348)][e(251)][0],o=a[e(205)].quote[0].close[e(322)](b=>b!==null),l=a[e(205)][e(296)][0][e(254)][e(322)](b=>b!==null),h=a[e(205)][e(296)][0].low[e(322)](b=>b!==null),d=a[e(205)][e(296)][0][e(258)][e(322)](b=>b!==null),p=a[e(304)].regularMarketPrice,m=a[e(304)][e(201)],y=(p-m)/m*100;return{marketStats:{price:p,change24h:y,volume:d[d[e(338)]-1],source:e(219)},historicalData:{closes:o,highs:l,lows:h,volumes:d}}}catch(s){return console[e(238)]("Yahoo data fetch failed for",n,s),null}},eL=async n=>{const e=Ee;if(!n||n==="VISUAL-SCAN")return null;const t=n.includes("-")?n[e(284)]("-",""):n;try{const s=e(349)+t+e(302),r=[e(193)+encodeURIComponent(s),e(246)+encodeURIComponent(s)];let i=null;for(const o of r)try{const l=await fetch(o);if(!l.ok)continue;if(i=await l.json(),i?.[e(348)]?.[e(251)])break}catch{continue}return i?.chart?.[e(251)]?.[0]?.[e(205)]?.[e(296)]?.[0]?.[e(200)]?.[e(322)](o=>o!==null)||null}catch{return null}},Eke=n=>{const e=Ee;if(!n||n.length<10)return .5;const t=n[n[e(338)]-1],s=n[e(300)](-50)[e(255)]((o,l)=>o+l,0)/Math[e(195)](n[e(338)],50),r=n[e(300)](-200).reduce((o,l)=>o+l,0)/Math[e(195)](n.length,200);let i=.5;t>s&&(i+=.1),t>r&&(i+=.15),s>r&&(i+=.1),t>n[0]&&(i+=.1);const a=(t-n[n.length-20])/n[n[e(338)]-20];return i+=a*.5,Math[e(341)](.1,Math[e(195)](.9,i))};(function(n,e){const t=yI,s=n();for(;;)try{if(-parseInt(t(436))/1*(-parseInt(t(468))/2)+-parseInt(t(484))/3*(parseInt(t(472))/4)+parseInt(t(453))/5*(-parseInt(t(462))/6)+-parseInt(t(416))/7*(-parseInt(t(440))/8)+parseInt(t(426))/9*(parseInt(t(480))/10)+parseInt(t(461))/11*(parseInt(t(457))/12)+-parseInt(t(417))/13===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(ab,748755);function yI(n,e){return n=n-409,ab()[n]}function ab(){const n=["708AMWrtX","predictedPrice","support","strength","263065BtHYzS","30mWTiMm"," (Factor: ","pow","warn","omega","Strong Bearish","39816TlyfBv","Visual Alignment","Deep Intelligence","Sync","6488wWjvbG","Running V4 Predictive Inference...","Confluence","calculateVWAP","Aligning Multi-Timeframe Bias (Daily)...","Major ","max","closes","1796650orLWni","Bullish","Rapid Precision Heuristic Applied...","Gathering Macro V4 Context...","717iyBmvF","High implied volatility suggests widened discovery ranges. ","V5 Bias","sqrt","Moderate Bearish","volumes","%** mathematical confidence. ","histogram","Ensemble","Heuristic","modelArtifacts","resistance","Training Deep LSTM V4 (Parallel Core)...","alpha","min","reduce","RMSE-Optimized","abs","highs","6545987kpWJDG","24038690xqvMbK","price","calculateTrendBias","slice","/5. ","sentiment","gamma","Macro Sentiment","Moderate Bullish","36ORlxao","includes","Neural Net (V5 LSTM)","lows","iterations","name","Bearish","length","lstm_v4_","V5 Institutional analysis of **","54UzHGsX","UNKNOWN","rsi","log","8pyPEEY","MTF Alignment failed, using neutral bias:","Internal V4 Engine","MTF Alignment","toISOString","toFixed","Neural inference highlights terminal distribution phases. ","** structure with **","log10","Syncing V4 Brain to Cloud...","V4-RMSE-PRECISION (Iter: ","[ScaleGuardian] Correcting OCR price scale: ","Neutral","1154275zIGPxC","Deep LSTM detects aggressive institutional accumulation. ","prices","./technicalAnalysis.js"];return ab=function(){return n},ab()}const Ike=(n,e,t,s,r=.95,i=.5,a=.02,o=.5)=>{const l=yI,h=.5,d=.15+(a>.04?.05:0),p=s.omega+s[l(410)]+s[l(423)]+d,m=Z=>(Z-.5)*2,y=m(n),b=s[l(466)]/p,x=r;let w=.5;e===l(481)?w=.85:e==="Bearish"&&(w=.15);const v=m(w),C=s[l(410)]/p,N=t[l(438)][t[l(438)].length-1];let k=.5;N<30?k=.85:N<40?k=.7:N>70?k=.15:N>60&&(k=.3);const E=m(k),A=s[l(423)]/p,R=N<25||N>75?1.3:1,D=m(i),L=d/p,F=m(o),_=.15,V=[{w:b,p:y,c:x,f:1},{w:C,p:v,c:.9,f:1},{w:A,p:E,c:1,f:R},{w:L,p:D,c:1,f:1},{w:_,p:F,c:1,f:1}],Q=V[l(412)]((Z,B)=>{const U=l,K=B.w*B.p*B.c*B.f;return Z*(1-Math[U(478)](-.99,Math.min(.99,K)))},1-h),ne=1-Q;return Math.min(.995,Math[l(478)](.005,ne))},$ke=async(n,e,t,s,r,i,a=.95,o=!1)=>{const l=yI,h=Array.isArray(t)?t:t[l(479)]||[],d=t[l(415)]||h,p=t[l(429)]||h;t.volumes;let m=e[l(418)]||h[h[l(433)]-1];const y=h[h[l(433)]-1];if(e.price&&y){const be=Math[l(448)](y/e[l(418)]);if(Math[l(414)](be)>.6){const Ae=Math[l(464)](10,Math.round(be));console[l(439)](l(451)+e[l(418)]+" -> "+e[l(418)]*Ae+l(463)+Ae+")"),m=e[l(418)]*Ae}}if(h[l(433)]<20)throw new Error("Insufficient historical data for precision analysis");const b=oM(h,14),x=O7(h),w=x[l(491)],v=L7(h),C=F7(d,p,h,14),N=M7(h,d,p);t[l(489)]&&t[l(489)].length>0&&(await import(l(456)))[l(475)](d,p,h,t.volumes);let k=.5;try{i(l(476));const be=await eL(n);be?.prices&&(k=(await import(l(456)))[l(419)](be.prices))}catch(be){console[l(465)](l(441),be)}let E=.5,A=null;const R=C[C.length-1]||m*.02,D=R/m;if(h[l(433)]>=Vr)if(o){const be=h[h[l(433)]-1],Ae=h[h[l(433)]-15],ze=(be-Ae)/Ae;E=.5+Math[l(411)](.45,Math[l(478)](-.45,ze/(D*5))),i(l(482))}else{let be=null;try{const Ae={prices:h,rsi:b,macd:w,atr:C};if(s&&(be=await xke(s,l(434)+n)),be){if(i("Calibrating Cloud Intelligence V4..."),A=mke(Ae),be&&h[l(433)]>=Vr&&A){i(l(473));const ze={prices:h[l(420)](-Vr),rsi:b[l(420)](-Vr),macd:w[l(420)](-Vr),atr:C.slice(-Vr)},it=gke(be,ze,A),mt=1/(D*10||1);E=.5+(it-m)/m*mt,E=Math[l(478)](.02,Math.min(.98,E))}}else{i(l(409));const ze=await pke({ticker:n,historicalPrices:h,rsi:b,macdHist:w,atr:C});if(ze){const it=1/(D*10||1);E=.5+(ze[l(458)]-m)/m*it,E=Math[l(478)](.02,Math.min(.98,E)),A=ze.stats,s&&ze.modelArtifacts&&(i(l(449)),await bke(s,ze[l(494)],l(434)+n,.99))}}}finally{be&&yke(be)}}i(l(483));const L=await eL(n),F=Eke(L?.[l(455)]);let _=Ike(E,v[l(422)],{rsi:b,macd:w},r,a,F,D,k);const V=b[b[l(433)]-1]<45&&v[l(422)]===l(481),Q=b[b.length-1]>55&&v[l(422)]===l(432);if(E>.75&&V){const be=.05+.1*(E-.75);_=Math[l(411)](.99,_+be)}else if(E<.25&&Q){const be=.05+.1*(.25-E);_=Math[l(478)](.01,_-be)}const ne=[{name:l(428),type:l(470),w:r[l(466)],p:E,value:l(o?493:413)},{name:"Pattern Recognition",type:"Geometric",w:r[l(410)],p:v[l(422)]===l(481)?.8:v[l(422)]===l(432)?.2:.5,value:v[l(431)]},{name:"Technical Alpha",type:l(474),w:r[l(423)],p:b[b[l(433)]-1]<45?.8:b[b.length-1]>55?.2:.5,value:"RSI-ATR Sync"},{name:l(424),type:l(492),w:.15,p:F,value:"10Y-Alpha"},{name:l(443),type:l(486),w:.15,p:k,value:k>.6?l(481):k<.4?l(432):l(452)},{name:l(469),type:l(471),w:.1,p:a,value:(a*100)[l(445)](0)+"%"}];let Z=l(452);_>.68?Z="Strong Bullish":_>.55?Z=l(425):_<.32?Z=l(467):_<.45&&(Z=l(488));const B=Z[l(427)](l(481)),U=m<1?5:m<100?3:2,K=B?N[l(460)].s:N.strength.r,X=1.8-K*.1,se=Math[l(478)](m*.005,R*X),P=2+r.iterations*.02;let j,te,le;B?(j=Math[l(411)](m*.99,m-se),N.support<m&&N[l(459)]>j&&(j=N[l(459)]*.998),te=m+se*P,le=m+se*P*1.6):(j=Math[l(478)](m*1.01,m+se),N[l(495)]>m&&N.resistance<j&&(j=N[l(495)]*1.002),te=Math[l(478)](0,m-se*P),le=Math.max(0,m-se*P*1.6));const me={entry:m[l(445)](U),sl:j[l(445)](U),tp1:te[l(445)](U),tp2:le[l(445)](U),rr:P[l(445)](1)},we=((_>.5?_:1-_)*100)[l(445)](1),Te=()=>{const be=l;b[b[be(433)]-1];let Ae=be(435)+n+"** identified a **"+Z+be(447)+we+be(490);return E>.7?Ae+=be(454):E<.3&&(Ae+=be(446)),(N[be(460)].s>3||N[be(460)].r>3)&&(Ae+=be(477)+(N[be(460)].s>N[be(460)].r?"support":be(495))+" detected with strength "+Math.max(N[be(460)].s,N.strength.r)+be(421)),D>.05&&(Ae+=be(485)),Ae},$e={volatility:(D*100).toFixed(2),sharpeRatio:(((m-h[0])/h[0]*100*(252/h[l(433)])-4.5)/(D*Math.sqrt(252)*100||1))[l(445)](2),maxDrawdown:((Math[l(411)](...h[l(420)](-90))-Math[l(478)](...h[l(420)](-90)))/Math[l(478)](...h[l(420)](-90))*100)[l(445)](2),calibration:{rmse:(Math[l(487)](Math[l(464)](1-_,2))*.08).toFixed(4),brier:Math[l(464)](_-(B?1:0),2)[l(445)](4)}};return{id:Date.now().toString(),date:new Date()[l(444)](),p0:r.alpha.toFixed(2),finalProb:Number(_),direction:Z,confidence:we,pattern:v,factors:ne,targets:me,riskMetrics:$e,macroTrend:{...L,source:L?.source||l(442)},overview:Te(),ticker:n||l(437),version:l(450)+r[l(430)]+")",raw_prices:h}},yc="https://diverai.flisoft.agency",_ke=()=>{const{user:n,profile:e,refreshProfile:t,neuralState:s}=R7(),[r,i]=Ce.useState("idle"),[a,o]=Ce.useState(null),[l,h]=Ce.useState(null),[d,p]=Ce.useState(""),[m,y]=Ce.useState(""),[b,x]=Ce.useState(!1),[w,v]=Ce.useState(""),[C,N]=Ce.useState("guest"),[k,E]=Ce.useState(null),[A,R]=Ce.useState([]),[D,L]=Ce.useState("analyze"),[F,_]=Ce.useState(!1);Ce.useEffect(()=>{V();const X=async se=>{if(se.type==="AUTH_SYNC"&&se.session){const{access_token:P,refresh_token:j}=se.session;await ma.auth.setSession({access_token:P,refresh_token:j}),t()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(X),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(X)}},[]);const V=async()=>{try{const X=await fetch("https://api.ipify.org?format=json");if(!X.ok)throw new Error("Network response was not ok");const se=await X.json();E(se.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};Ce.useEffect(()=>{Q()},[n]);const Q=async()=>{if(!n){const P=localStorage.getItem("diver_ai_guest_history");R(P?JSON.parse(P):[]);return}const{data:X,error:se}=await ma.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!se&&X&&R(X.map(P=>({...P.data,db_id:P.id,created_at:P.created_at})))},ne=async X=>{if(n){const{data:se}=await ma.from("prediction_history").insert([{user_id:n.id,data:X}]).select();if(se?.[0]){const P={...X,db_id:se[0].id,created_at:se[0].created_at};R(j=>[P,...j].slice(0,10))}}else{const se=new Date().toISOString(),P={...X,db_id:"local-"+Date.now(),created_at:se};R(j=>{const te=[P,...j].slice(0,5);return localStorage.setItem("diver_ai_guest_history",JSON.stringify(te)),te})}},Z=()=>{if(n)return;const X=new Date().toISOString().split("T")[0],se=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}"),P=k||"unknown",j=se[P]||{count:0,date:X};j.date!==X?(j.count=1,j.date=X):j.count+=1,se[P]=j,localStorage.setItem("diver_ai_guest_ip_logs",JSON.stringify(se))},B=()=>{const X=new Date().toISOString().split("T")[0];if(!n){const P=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}")[k||"unknown"]||{count:0,date:X};return P.date!==X&&(P.count=0,P.date=X),P.count>=3?(v("IP Limit Reached: 3 guest analysis/day. Please log in for expanded access."),N("guest"),x(!0),!1):!0}return n.email_confirmed_at?e&&e.subscription_tier!=="pro"&&(e.upload_count||0)>=3&&e.last_upload_date===X?(v("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),N("free"),x(!0),!1):!0:(v("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),N("verify"),x(!0),!1)},U=async()=>{if(B()){i("scanning"),p("Capturing Visual Stream..."),o(null);try{const X=await new Promise(Ye=>{chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"},ot=>{chrome.runtime.lastError?Ye({error:"Connection to extension background lost. Please refresh the page."}):Ye(ot)})});if(X.error)throw new Error(X.error);const se=X.dataUrl;h(se),i("analyzing"),p("Deep Scan (Cloud OCR)...");const{data:{session:P}}=await ma.auth.getSession();let j=P?.access_token||"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",te=0,le,me=!1;for(;!me&&te<3;)try{if(le=await fetch("https://brrjoheinakfhohesogc.supabase.co/functions/v1/detect_ticker",{method:"POST",headers:{"Content-Type":"application/json",apikey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",Authorization:`Bearer ${te===2?"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A":j}`},body:JSON.stringify({image:se})}),le.ok)me=!0;else if(le.status===401&&te===0){const{data:{session:ot},error:gt}=await ma.auth.refreshSession();if(gt||!ot)throw new Error("Refresh Failed");j=ot.access_token,te++}else if(le.status===401&&te===1)te++;else throw new Error(`Service Error (${le.status})`)}catch(Ye){if(te===2)throw Ye;te++}if(!le||!le.ok)throw new Error("Visualization Service Unavailable");const Te=(await le.json())?.text||"",$e=Tke(Te),be=fj(Te);if(console.log("[Sidebar] OCR Detected:",{ticker:$e,anchorPrice:be}),!$e&&!be)throw new Error("Neural Core Rejected: No valid asset or price identified.");p(`Target Locked: ${$e}. Syncing Data...`);let Ae,ze;if(CC[$e]){const Ye=await kke($e);if(Ye)Ae=Ye.marketStats,ze=Ye.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else Ae=await Cke($e),ze=await Nke($e,90);p("Synchronizing Global Intelligence...");const mt=await $ke($e,Ae,ze,n,s,p,.95,!0);if(n&&e){const Ye=new Date().toISOString().split("T")[0],ot=e.last_upload_date!==Ye?1:(e.upload_count||0)+1;await ma.from("profiles").update({upload_count:ot,last_upload_date:Ye}).eq("id",n.id),t()}else Z();await ne(mt),o(mt),i("success")}catch(X){console.error(X),y(X.message),i("error")}}},K=({id:X,label:se,icon:P})=>pe.jsxs("button",{onClick:()=>L(X),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${D===X?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[pe.jsx(P,{className:"w-3.5 h-3.5"}),se,D===X&&pe.jsx(gl.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return pe.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&pe.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:pe.jsxs("div",{className:"space-y-6 max-w-xs",children:[pe.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:pe.jsx(z8,{className:"text-rose-500"})}),pe.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),pe.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),pe.jsxs("div",{className:"space-y-3",children:[C==="free"?pe.jsx("button",{onClick:()=>window.open(`${yc}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):C==="guest"?pe.jsx("button",{onClick:()=>window.open(`${yc}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):pe.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),pe.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),pe.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[pe.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[pe.jsxs("div",{className:"flex items-center gap-2",children:[pe.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:pe.jsx($8,{className:"w-3.5 h-3.5 text-white"})}),pe.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",pe.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?pe.jsxs("div",{className:"flex items-center gap-3",children:[pe.jsx("div",{className:"text-right",children:pe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:e?.subscription_tier==="pro"?"PRO":"BASIC"})}),pe.jsx("button",{onClick:()=>ma.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:pe.jsx(B8,{className:"w-4 h-4"})})]}):pe.jsx("button",{onClick:()=>window.open(`${yc}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),pe.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[pe.jsx(K,{id:"analyze",label:"Analysis",icon:VD}),pe.jsx(K,{id:"history",label:"History",icon:zD}),n&&pe.jsx(K,{id:"referral",label:"Rewards",icon:Y8})]})]}),pe.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:pe.jsxs(HH,{mode:"wait",children:[D==="history"&&pe.jsx(gl.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:A.length===0?pe.jsxs("div",{className:"text-center py-12 text-slate-600",children:[pe.jsx(zD,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),pe.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):A.map((X,se)=>pe.jsxs("div",{onClick:()=>{o(X),i("success"),L("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[pe.jsxs("div",{className:"flex items-center gap-3",children:[pe.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${X.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:X.direction.includes("Bullish")?pe.jsx(BD,{className:"w-4 h-4"}):pe.jsx(PD,{className:"w-4 h-4"})}),pe.jsxs("div",{children:[pe.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:X.ticker}),pe.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(X.created_at).toLocaleDateString()})]})]}),pe.jsxs("span",{className:`text-xs font-mono font-bold ${X.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(X.finalProb*100).toFixed(0),"%"]})]},X.db_id||se))},"history"),D==="referral"&&n&&pe.jsxs(gl.div,{initial:{opacity:0,x:10},animate:{opacity:1,x:0},className:"space-y-4",children:[pe.jsxs("div",{className:"bg-gradient-to-br from-blue-600 to-indigo-700 rounded-2xl p-5 border border-white/10 shadow-xl relative overflow-hidden",children:[pe.jsx("div",{className:"absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 mix-blend-overlay"}),pe.jsxs("div",{className:"relative z-10 space-y-3",children:[pe.jsx("h3",{className:"text-sm font-black uppercase tracking-tight",children:"Earn Pro Status"}),pe.jsx("p",{className:"text-[10px] text-blue-100 font-medium leading-relaxed",children:"Refer a friend. You both get 30 days of Pro analysis upon their signup."}),pe.jsx("div",{className:"pt-2",children:pe.jsxs("div",{className:"flex gap-2",children:[pe.jsx("div",{className:"flex-1 bg-slate-950/40 border border-white/10 rounded-lg px-3 py-2 text-[9px] font-mono text-blue-200 truncate",children:e?.referral_code?`${yc}/signup?ref=${e.referral_code}`:"Generating..."}),pe.jsx("button",{onClick:()=>{navigator.clipboard.writeText(`${yc}/signup?ref=${e?.referral_code}`),_(!0),setTimeout(()=>_(!1),2e3)},className:"bg-white text-slate-950 p-2 rounded-lg hover:bg-blue-100 transition-colors",children:F?pe.jsx(A8,{className:"w-3.5 h-3.5"}):pe.jsx(D8,{className:"w-3.5 h-3.5"})})]})})]})]}),pe.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[pe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[pe.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Total Referrals"}),pe.jsx("p",{className:"text-xl font-black text-white",children:e?.referral_count||0})]}),pe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[pe.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Days Granted"}),pe.jsx("p",{className:"text-xl font-black text-emerald-400",children:(e?.referral_count||0)*30})]})]}),pe.jsxs("button",{onClick:()=>window.open(`${yc}/referral`,"_blank"),className:"w-full py-3 bg-slate-900 border border-slate-800 hover:border-blue-500/50 text-slate-300 hover:text-white text-[10px] font-bold uppercase tracking-widest rounded-xl transition-all flex items-center justify-center gap-2",children:[pe.jsx(W8,{className:"w-3.5 h-3.5"})," View Full Dashboard"]})]},"referral"),D==="analyze"&&r==="idle"&&pe.jsxs(gl.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:[pe.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:pe.jsx(U8,{className:"w-8 h-8 text-blue-500"})}),pe.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[pe.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),pe.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]},"idle"),(r==="scanning"||r==="analyzing")&&pe.jsxs(gl.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[pe.jsxs("div",{className:"relative w-16 h-16",children:[pe.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),pe.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),pe.jsxs("div",{className:"text-center space-y-2",children:[pe.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),pe.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),r==="success"&&a&&D==="analyze"&&pe.jsxs(gl.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[pe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[pe.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[pe.jsxs("div",{children:[pe.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:a.ticker}),pe.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[pe.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${a.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[a.direction.split(" ")[0]," Signal"]}),pe.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(a.finalProb*100).toFixed(1),"% Conf."]})]})]}),pe.jsx("div",{className:`p-2 rounded-xl ${a.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:a.direction.includes("Bullish")?pe.jsx(BD,{className:"w-5 h-5 text-emerald-500"}):pe.jsx(PD,{className:"w-5 h-5 text-rose-500"})})]}),pe.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${a.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),pe.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[pe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[pe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),pe.jsx("p",{className:"text-lg font-mono font-bold text-white",children:a.targets.entry})]}),pe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[pe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),pe.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",a.targets.rr]})]}),pe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[pe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),pe.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:a.targets.tp1})]}),pe.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[pe.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),pe.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:a.targets.sl})]})]}),pe.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[pe.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[pe.jsx(L8,{className:"w-3 h-3"})," AI Analysis"]}),pe.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:a.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),pe.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:pe.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",a.version.split(" ")[0],"  Data: ",a.macroTrend?.source||"Institutional Feed"]})}),pe.jsx("button",{onClick:()=>i("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),r==="error"&&pe.jsxs(gl.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[pe.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:pe.jsx(K8,{className:"w-6 h-6 text-rose-500"})}),pe.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),pe.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),pe.jsx("button",{onClick:()=>i("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),D==="analyze"&&r==="idle"&&pe.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:pe.jsxs("button",{onClick:U,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[pe.jsx(VD,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};jG.createRoot(document.getElementById("root")).render(pe.jsx(LG.StrictMode,{children:pe.jsx(A7,{children:pe.jsx(_ke,{})})}));
