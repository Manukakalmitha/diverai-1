function TB(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const i=Object.getOwnPropertyDescriptor(s,r);i&&Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=e(r);fetch(r.href,i)}})();function dw(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function kB(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),e}var Jb={exports:{}},eh={};var O$;function $B(){if(O$)return eh;O$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,r,i){var o=null;if(i!==void 0&&(o=""+i),r.key!==void 0&&(o=""+r.key),"key"in r){i={};for(var l in r)l!=="key"&&(i[l]=r[l])}else i=r;return r=i.ref,{$$typeof:n,type:s,key:o,ref:r!==void 0?r:null,props:i}}return eh.Fragment=t,eh.jsx=e,eh.jsxs=e,eh}var M$;function EB(){return M$||(M$=1,Jb.exports=$B()),Jb.exports}var it=EB(),Qb={exports:{}},Ht={};var F$;function IB(){if(F$)return Ht;F$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),i=Symbol.for("react.consumer"),o=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function y(F){return F===null||typeof F!="object"?null:(F=m&&F[m]||F["@@iterator"],typeof F=="function"?F:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function S(F,z,Q){this.props=F,this.context=z,this.refs=w,this.updater=Q||b}S.prototype.isReactComponent={},S.prototype.setState=function(F,z){if(typeof F!="object"&&typeof F!="function"&&F!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,F,z,"setState")},S.prototype.forceUpdate=function(F){this.updater.enqueueForceUpdate(this,F,"forceUpdate")};function T(){}T.prototype=S.prototype;function k(F,z,Q){this.props=F,this.context=z,this.refs=w,this.updater=Q||b}var $=k.prototype=new T;$.constructor=k,x($,S.prototype),$.isPureReactComponent=!0;var E=Array.isArray;function N(){}var _={H:null,A:null,T:null,S:null},R=Object.prototype.hasOwnProperty;function D(F,z,Q){var ct=Q.ref;return{$$typeof:n,type:F,key:z,ref:ct!==void 0?ct:null,props:Q}}function M(F,z){return D(F.type,z,F.props)}function A(F){return typeof F=="object"&&F!==null&&F.$$typeof===n}function B(F){var z={"=":"=0",":":"=2"};return"$"+F.replace(/[=:]/g,function(Q){return z[Q]})}var H=/\/+/g;function W(F,z){return typeof F=="object"&&F!==null&&F.key!=null?B(""+F.key):z.toString(36)}function X(F){switch(F.status){case"fulfilled":return F.value;case"rejected":throw F.reason;default:switch(typeof F.status=="string"?F.then(N,N):(F.status="pending",F.then(function(z){F.status==="pending"&&(F.status="fulfilled",F.value=z)},function(z){F.status==="pending"&&(F.status="rejected",F.reason=z)})),F.status){case"fulfilled":return F.value;case"rejected":throw F.reason}}throw F}function P(F,z,Q,ct,pt){var gt=typeof F;(gt==="undefined"||gt==="boolean")&&(F=null);var xt=!1;if(F===null)xt=!0;else switch(gt){case"bigint":case"string":case"number":xt=!0;break;case"object":switch(F.$$typeof){case n:case t:xt=!0;break;case d:return xt=F._init,P(xt(F._payload),z,Q,ct,pt)}}if(xt)return pt=pt(F),xt=ct===""?"."+W(F,0):ct,E(pt)?(Q="",xt!=null&&(Q=xt.replace(H,"$&/")+"/"),P(pt,z,Q,"",function(Ot){return Ot})):pt!=null&&(A(pt)&&(pt=M(pt,Q+(pt.key==null||F&&F.key===pt.key?"":(""+pt.key).replace(H,"$&/")+"/")+xt)),z.push(pt)),1;xt=0;var kt=ct===""?".":ct+":";if(E(F))for(var Ct=0;Ct<F.length;Ct++)ct=F[Ct],gt=kt+W(ct,Ct),xt+=P(ct,z,Q,gt,pt);else if(Ct=y(F),typeof Ct=="function")for(F=Ct.call(F),Ct=0;!(ct=F.next()).done;)ct=ct.value,gt=kt+W(ct,Ct++),xt+=P(ct,z,Q,gt,pt);else if(gt==="object"){if(typeof F.then=="function")return P(X(F),z,Q,ct,pt);throw z=String(F),Error("Objects are not valid as a React child (found: "+(z==="[object Object]"?"object with keys {"+Object.keys(F).join(", ")+"}":z)+"). If you meant to render a collection of children, use an array instead.")}return xt}function U(F,z,Q){if(F==null)return F;var ct=[],pt=0;return P(F,ct,"","",function(gt){return z.call(Q,gt,pt++)}),ct}function G(F){if(F._status===-1){var z=F._result;z=z(),z.then(function(Q){(F._status===0||F._status===-1)&&(F._status=1,F._result=Q)},function(Q){(F._status===0||F._status===-1)&&(F._status=2,F._result=Q)}),F._status===-1&&(F._status=0,F._result=z)}if(F._status===1)return F._result.default;throw F._result}var tt=typeof reportError=="function"?reportError:function(F){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var z=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof F=="object"&&F!==null&&typeof F.message=="string"?String(F.message):String(F),error:F});if(!window.dispatchEvent(z))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",F);return}console.error(F)},Z={map:U,forEach:function(F,z,Q){U(F,function(){z.apply(this,arguments)},Q)},count:function(F){var z=0;return U(F,function(){z++}),z},toArray:function(F){return U(F,function(z){return z})||[]},only:function(F){if(!A(F))throw Error("React.Children.only expected to receive a single React element child.");return F}};return Ht.Activity=p,Ht.Children=Z,Ht.Component=S,Ht.Fragment=e,Ht.Profiler=r,Ht.PureComponent=k,Ht.StrictMode=s,Ht.Suspense=c,Ht.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=_,Ht.__COMPILER_RUNTIME={__proto__:null,c:function(F){return _.H.useMemoCache(F)}},Ht.cache=function(F){return function(){return F.apply(null,arguments)}},Ht.cacheSignal=function(){return null},Ht.cloneElement=function(F,z,Q){if(F==null)throw Error("The argument must be a React element, but you passed "+F+".");var ct=x({},F.props),pt=F.key;if(z!=null)for(gt in z.key!==void 0&&(pt=""+z.key),z)!R.call(z,gt)||gt==="key"||gt==="__self"||gt==="__source"||gt==="ref"&&z.ref===void 0||(ct[gt]=z[gt]);var gt=arguments.length-2;if(gt===1)ct.children=Q;else if(1<gt){for(var xt=Array(gt),kt=0;kt<gt;kt++)xt[kt]=arguments[kt+2];ct.children=xt}return D(F.type,pt,ct)},Ht.createContext=function(F){return F={$$typeof:o,_currentValue:F,_currentValue2:F,_threadCount:0,Provider:null,Consumer:null},F.Provider=F,F.Consumer={$$typeof:i,_context:F},F},Ht.createElement=function(F,z,Q){var ct,pt={},gt=null;if(z!=null)for(ct in z.key!==void 0&&(gt=""+z.key),z)R.call(z,ct)&&ct!=="key"&&ct!=="__self"&&ct!=="__source"&&(pt[ct]=z[ct]);var xt=arguments.length-2;if(xt===1)pt.children=Q;else if(1<xt){for(var kt=Array(xt),Ct=0;Ct<xt;Ct++)kt[Ct]=arguments[Ct+2];pt.children=kt}if(F&&F.defaultProps)for(ct in xt=F.defaultProps,xt)pt[ct]===void 0&&(pt[ct]=xt[ct]);return D(F,gt,pt)},Ht.createRef=function(){return{current:null}},Ht.forwardRef=function(F){return{$$typeof:l,render:F}},Ht.isValidElement=A,Ht.lazy=function(F){return{$$typeof:d,_payload:{_status:-1,_result:F},_init:G}},Ht.memo=function(F,z){return{$$typeof:h,type:F,compare:z===void 0?null:z}},Ht.startTransition=function(F){var z=_.T,Q={};_.T=Q;try{var ct=F(),pt=_.S;pt!==null&&pt(Q,ct),typeof ct=="object"&&ct!==null&&typeof ct.then=="function"&&ct.then(N,tt)}catch(gt){tt(gt)}finally{z!==null&&Q.types!==null&&(z.types=Q.types),_.T=z}},Ht.unstable_useCacheRefresh=function(){return _.H.useCacheRefresh()},Ht.use=function(F){return _.H.use(F)},Ht.useActionState=function(F,z,Q){return _.H.useActionState(F,z,Q)},Ht.useCallback=function(F,z){return _.H.useCallback(F,z)},Ht.useContext=function(F){return _.H.useContext(F)},Ht.useDebugValue=function(){},Ht.useDeferredValue=function(F,z){return _.H.useDeferredValue(F,z)},Ht.useEffect=function(F,z){return _.H.useEffect(F,z)},Ht.useEffectEvent=function(F){return _.H.useEffectEvent(F)},Ht.useId=function(){return _.H.useId()},Ht.useImperativeHandle=function(F,z,Q){return _.H.useImperativeHandle(F,z,Q)},Ht.useInsertionEffect=function(F,z){return _.H.useInsertionEffect(F,z)},Ht.useLayoutEffect=function(F,z){return _.H.useLayoutEffect(F,z)},Ht.useMemo=function(F,z){return _.H.useMemo(F,z)},Ht.useOptimistic=function(F,z){return _.H.useOptimistic(F,z)},Ht.useReducer=function(F,z,Q){return _.H.useReducer(F,z,Q)},Ht.useRef=function(F){return _.H.useRef(F)},Ht.useState=function(F){return _.H.useState(F)},Ht.useSyncExternalStore=function(F,z,Q){return _.H.useSyncExternalStore(F,z,Q)},Ht.useTransition=function(){return _.H.useTransition()},Ht.version="19.2.3",Ht}var L$;function fw(){return L$||(L$=1,Qb.exports=IB()),Qb.exports}var St=fw();const NB=dw(St);var tx={exports:{}},nh={},ex={exports:{}},nx={};var P$;function AB(){return P$||(P$=1,(function(n){function t(P,U){var G=P.length;P.push(U);t:for(;0<G;){var tt=G-1>>>1,Z=P[tt];if(0<r(Z,U))P[tt]=U,P[G]=Z,G=tt;else break t}}function e(P){return P.length===0?null:P[0]}function s(P){if(P.length===0)return null;var U=P[0],G=P.pop();if(G!==U){P[0]=G;t:for(var tt=0,Z=P.length,F=Z>>>1;tt<F;){var z=2*(tt+1)-1,Q=P[z],ct=z+1,pt=P[ct];if(0>r(Q,G))ct<Z&&0>r(pt,Q)?(P[tt]=pt,P[ct]=G,tt=ct):(P[tt]=Q,P[z]=G,tt=z);else if(ct<Z&&0>r(pt,G))P[tt]=pt,P[ct]=G,tt=ct;else break t}}return U}function r(P,U){var G=P.sortIndex-U.sortIndex;return G!==0?G:P.id-U.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();n.unstable_now=function(){return o.now()-l}}var c=[],h=[],d=1,p=null,m=3,y=!1,b=!1,x=!1,w=!1,S=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,k=typeof setImmediate<"u"?setImmediate:null;function $(P){for(var U=e(h);U!==null;){if(U.callback===null)s(h);else if(U.startTime<=P)s(h),U.sortIndex=U.expirationTime,t(c,U);else break;U=e(h)}}function E(P){if(x=!1,$(P),!b)if(e(c)!==null)b=!0,N||(N=!0,B());else{var U=e(h);U!==null&&X(E,U.startTime-P)}}var N=!1,_=-1,R=5,D=-1;function M(){return w?!0:!(n.unstable_now()-D<R)}function A(){if(w=!1,N){var P=n.unstable_now();D=P;var U=!0;try{t:{b=!1,x&&(x=!1,T(_),_=-1),y=!0;var G=m;try{e:{for($(P),p=e(c);p!==null&&!(p.expirationTime>P&&M());){var tt=p.callback;if(typeof tt=="function"){p.callback=null,m=p.priorityLevel;var Z=tt(p.expirationTime<=P);if(P=n.unstable_now(),typeof Z=="function"){p.callback=Z,$(P),U=!0;break e}p===e(c)&&s(c),$(P)}else s(c);p=e(c)}if(p!==null)U=!0;else{var F=e(h);F!==null&&X(E,F.startTime-P),U=!1}}break t}finally{p=null,m=G,y=!1}U=void 0}}finally{U?B():N=!1}}}var B;if(typeof k=="function")B=function(){k(A)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,W=H.port2;H.port1.onmessage=A,B=function(){W.postMessage(null)}}else B=function(){S(A,0)};function X(P,U){_=S(function(){P(n.unstable_now())},U)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(P){P.callback=null},n.unstable_forceFrameRate=function(P){0>P||125<P?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<P?Math.floor(1e3/P):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(P){switch(m){case 1:case 2:case 3:var U=3;break;default:U=m}var G=m;m=U;try{return P()}finally{m=G}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(P,U){switch(P){case 1:case 2:case 3:case 4:case 5:break;default:P=3}var G=m;m=P;try{return U()}finally{m=G}},n.unstable_scheduleCallback=function(P,U,G){var tt=n.unstable_now();switch(typeof G=="object"&&G!==null?(G=G.delay,G=typeof G=="number"&&0<G?tt+G:tt):G=tt,P){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=G+Z,P={id:d++,callback:U,priorityLevel:P,startTime:G,expirationTime:Z,sortIndex:-1},G>tt?(P.sortIndex=G,t(h,P),e(c)===null&&P===e(h)&&(x?(T(_),_=-1):x=!0,X(E,G-tt))):(P.sortIndex=Z,t(c,P),b||y||(b=!0,N||(N=!0,B()))),P},n.unstable_shouldYield=M,n.unstable_wrapCallback=function(P){var U=m;return function(){var G=m;m=U;try{return P.apply(this,arguments)}finally{m=G}}}})(nx)),nx}var z$;function _B(){return z$||(z$=1,ex.exports=AB()),ex.exports}var sx={exports:{}},ss={};var B$;function RB(){if(B$)return ss;B$=1;var n=fw();function t(c){var h="https://react.dev/errors/"+c;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+c+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},r=Symbol.for("react.portal");function i(c,h,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:p==null?null:""+p,children:c,containerInfo:h,implementation:d}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function l(c,h){if(c==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return ss.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,ss.createPortal=function(c,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(t(299));return i(c,h,null,d)},ss.flushSync=function(c){var h=o.T,d=s.p;try{if(o.T=null,s.p=2,c)return c()}finally{o.T=h,s.p=d,s.d.f()}},ss.preconnect=function(c,h){typeof c=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(c,h))},ss.prefetchDNS=function(c){typeof c=="string"&&s.d.D(c)},ss.preinit=function(c,h){if(typeof c=="string"&&h&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(c,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(c,{crossOrigin:p,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},ss.preinitModule=function(c,h){if(typeof c=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=l(h.as,h.crossOrigin);s.d.M(c,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(c)},ss.preload=function(c,h){if(typeof c=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin);s.d.L(c,d,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},ss.preloadModule=function(c,h){if(typeof c=="string")if(h){var d=l(h.as,h.crossOrigin);s.d.m(c,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(c)},ss.requestFormReset=function(c){s.d.r(c)},ss.unstable_batchedUpdates=function(c,h){return c(h)},ss.useFormState=function(c,h,d){return o.H.useFormState(c,h,d)},ss.useFormStatus=function(){return o.H.useHostTransitionStatus()},ss.version="19.2.3",ss}var V$;function DB(){if(V$)return sx.exports;V$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),sx.exports=RB(),sx.exports}var U$;function OB(){if(U$)return nh;U$=1;var n=_B(),t=fw(),e=DB();function s(a){var u="https://react.dev/errors/"+a;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)u+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+a+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function i(a){var u=a,f=a;if(a.alternate)for(;u.return;)u=u.return;else{a=u;do u=a,(u.flags&4098)!==0&&(f=u.return),a=u.return;while(a)}return u.tag===3?f:null}function o(a){if(a.tag===13){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function l(a){if(a.tag===31){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function c(a){if(i(a)!==a)throw Error(s(188))}function h(a){var u=a.alternate;if(!u){if(u=i(a),u===null)throw Error(s(188));return u!==a?null:a}for(var f=a,g=u;;){var v=f.return;if(v===null)break;var C=v.alternate;if(C===null){if(g=v.return,g!==null){f=g;continue}break}if(v.child===C.child){for(C=v.child;C;){if(C===f)return c(v),a;if(C===g)return c(v),u;C=C.sibling}throw Error(s(188))}if(f.return!==g.return)f=v,g=C;else{for(var I=!1,O=v.child;O;){if(O===f){I=!0,f=v,g=C;break}if(O===g){I=!0,g=v,f=C;break}O=O.sibling}if(!I){for(O=C.child;O;){if(O===f){I=!0,f=C,g=v;break}if(O===g){I=!0,g=C,f=v;break}O=O.sibling}if(!I)throw Error(s(189))}}if(f.alternate!==g)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?a:u}function d(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a;for(a=a.child;a!==null;){if(u=d(a),u!==null)return u;a=a.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),k=Symbol.for("react.context"),$=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),R=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),M=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function B(a){return a===null||typeof a!="object"?null:(a=A&&a[A]||a["@@iterator"],typeof a=="function"?a:null)}var H=Symbol.for("react.client.reference");function W(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===H?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case x:return"Fragment";case S:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case N:return"SuspenseList";case D:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case b:return"Portal";case k:return a.displayName||"Context";case T:return(a._context.displayName||"Context")+".Consumer";case $:var u=a.render;return a=a.displayName,a||(a=u.displayName||u.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case _:return u=a.displayName||null,u!==null?u:W(a.type)||"Memo";case R:u=a._payload,a=a._init;try{return W(a(u))}catch{}}return null}var X=Array.isArray,P=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,U=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,G={pending:!1,data:null,method:null,action:null},tt=[],Z=-1;function F(a){return{current:a}}function z(a){0>Z||(a.current=tt[Z],tt[Z]=null,Z--)}function Q(a,u){Z++,tt[Z]=a.current,a.current=u}var ct=F(null),pt=F(null),gt=F(null),xt=F(null);function kt(a,u){switch(Q(gt,u),Q(pt,a),Q(ct,null),u.nodeType){case 9:case 11:a=(a=u.documentElement)&&(a=a.namespaceURI)?s$(a):0;break;default:if(a=u.tagName,u=u.namespaceURI)u=s$(u),a=r$(u,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}z(ct),Q(ct,a)}function Ct(){z(ct),z(pt),z(gt)}function Ot(a){a.memoizedState!==null&&Q(xt,a);var u=ct.current,f=r$(u,a.type);u!==f&&(Q(pt,a),Q(ct,f))}function Gt(a){pt.current===a&&(z(ct),z(pt)),xt.current===a&&(z(xt),Zu._currentValue=G)}var Yt,ge;function me(a){if(Yt===void 0)try{throw Error()}catch(f){var u=f.stack.trim().match(/\n( *(at )?)/);Yt=u&&u[1]||"",ge=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Yt+a+ge}var re=!1;function Zt(a,u){if(!a||re)return"";re=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(u){var bt=function(){throw Error()};if(Object.defineProperty(bt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(bt,[])}catch(ht){var ut=ht}Reflect.construct(a,[],bt)}else{try{bt.call()}catch(ht){ut=ht}a.call(bt.prototype)}}else{try{throw Error()}catch(ht){ut=ht}(bt=a())&&typeof bt.catch=="function"&&bt.catch(function(){})}}catch(ht){if(ht&&ut&&typeof ht.stack=="string")return[ht.stack,ut.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var v=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");v&&v.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var C=g.DetermineComponentFrameRoot(),I=C[0],O=C[1];if(I&&O){var j=I.split(`
`),at=O.split(`
`);for(v=g=0;g<j.length&&!j[g].includes("DetermineComponentFrameRoot");)g++;for(;v<at.length&&!at[v].includes("DetermineComponentFrameRoot");)v++;if(g===j.length||v===at.length)for(g=j.length-1,v=at.length-1;1<=g&&0<=v&&j[g]!==at[v];)v--;for(;1<=g&&0<=v;g--,v--)if(j[g]!==at[v]){if(g!==1||v!==1)do if(g--,v--,0>v||j[g]!==at[v]){var mt=`
`+j[g].replace(" at new "," at ");return a.displayName&&mt.includes("<anonymous>")&&(mt=mt.replace("<anonymous>",a.displayName)),mt}while(1<=g&&0<=v);break}}}finally{re=!1,Error.prepareStackTrace=f}return(f=a?a.displayName||a.name:"")?me(f):""}function Ce(a,u){switch(a.tag){case 26:case 27:case 5:return me(a.type);case 16:return me("Lazy");case 13:return a.child!==u&&u!==null?me("Suspense Fallback"):me("Suspense");case 19:return me("SuspenseList");case 0:case 15:return Zt(a.type,!1);case 11:return Zt(a.type.render,!1);case 1:return Zt(a.type,!0);case 31:return me("Activity");default:return""}}function ae(a){try{var u="",f=null;do u+=Ce(a,f),f=a,a=a.return;while(a);return u}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var fs=Object.prototype.hasOwnProperty,We=n.unstable_scheduleCallback,ks=n.unstable_cancelCallback,On=n.unstable_shouldYield,Ar=n.unstable_requestPaint,De=n.unstable_now,Bs=n.unstable_getCurrentPriorityLevel,Vs=n.unstable_ImmediatePriority,Pt=n.unstable_UserBlockingPriority,se=n.unstable_NormalPriority,ps=n.unstable_LowPriority,_r=n.unstable_IdlePriority,Rr=n.log,ir=n.unstable_setDisableYieldValue,ns=null,Be=null;function Qr(a){if(typeof Rr=="function"&&ir(a),Be&&typeof Be.setStrictMode=="function")try{Be.setStrictMode(ns,a)}catch{}}var Us=Math.clz32?Math.clz32:uP,lP=Math.log,cP=Math.LN2;function uP(a){return a>>>=0,a===0?32:31-(lP(a)/cP|0)|0}var Sf=256,Cf=262144,Tf=4194304;function ia(a){var u=a&42;if(u!==0)return u;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function kf(a,u,f){var g=a.pendingLanes;if(g===0)return 0;var v=0,C=a.suspendedLanes,I=a.pingedLanes;a=a.warmLanes;var O=g&134217727;return O!==0?(g=O&~C,g!==0?v=ia(g):(I&=O,I!==0?v=ia(I):f||(f=O&~a,f!==0&&(v=ia(f))))):(O=g&~C,O!==0?v=ia(O):I!==0?v=ia(I):f||(f=g&~a,f!==0&&(v=ia(f)))),v===0?0:u!==0&&u!==v&&(u&C)===0&&(C=v&-v,f=u&-u,C>=f||C===32&&(f&4194048)!==0)?u:v}function uu(a,u){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&u)===0}function hP(a,u){switch(a){case 1:case 2:case 4:case 8:case 64:return u+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function PC(){var a=Tf;return Tf<<=1,(Tf&62914560)===0&&(Tf=4194304),a}function B0(a){for(var u=[],f=0;31>f;f++)u.push(a);return u}function hu(a,u){a.pendingLanes|=u,u!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function dP(a,u,f,g,v,C){var I=a.pendingLanes;a.pendingLanes=f,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=f,a.entangledLanes&=f,a.errorRecoveryDisabledLanes&=f,a.shellSuspendCounter=0;var O=a.entanglements,j=a.expirationTimes,at=a.hiddenUpdates;for(f=I&~f;0<f;){var mt=31-Us(f),bt=1<<mt;O[mt]=0,j[mt]=-1;var ut=at[mt];if(ut!==null)for(at[mt]=null,mt=0;mt<ut.length;mt++){var ht=ut[mt];ht!==null&&(ht.lane&=-536870913)}f&=~bt}g!==0&&zC(a,g,0),C!==0&&v===0&&a.tag!==0&&(a.suspendedLanes|=C&~(I&~u))}function zC(a,u,f){a.pendingLanes|=u,a.suspendedLanes&=~u;var g=31-Us(u);a.entangledLanes|=u,a.entanglements[g]=a.entanglements[g]|1073741824|f&261930}function BC(a,u){var f=a.entangledLanes|=u;for(a=a.entanglements;f;){var g=31-Us(f),v=1<<g;v&u|a[g]&u&&(a[g]|=u),f&=~v}}function VC(a,u){var f=u&-u;return f=(f&42)!==0?1:V0(f),(f&(a.suspendedLanes|u))!==0?0:f}function V0(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function U0(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function UC(){var a=U.p;return a!==0?a:(a=window.event,a===void 0?32:E$(a.type))}function jC(a,u){var f=U.p;try{return U.p=a,u()}finally{U.p=f}}var so=Math.random().toString(36).slice(2),Un="__reactFiber$"+so,$s="__reactProps$"+so,vl="__reactContainer$"+so,j0="__reactEvents$"+so,fP="__reactListeners$"+so,pP="__reactHandles$"+so,GC="__reactResources$"+so,du="__reactMarker$"+so;function G0(a){delete a[Un],delete a[$s],delete a[j0],delete a[fP],delete a[pP]}function wl(a){var u=a[Un];if(u)return u;for(var f=a.parentNode;f;){if(u=f[vl]||f[Un]){if(f=u.alternate,u.child!==null||f!==null&&f.child!==null)for(a=h$(a);a!==null;){if(f=a[Un])return f;a=h$(a)}return u}a=f,f=a.parentNode}return null}function Sl(a){if(a=a[Un]||a[vl]){var u=a.tag;if(u===5||u===6||u===13||u===31||u===26||u===27||u===3)return a}return null}function fu(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a.stateNode;throw Error(s(33))}function Cl(a){var u=a[GC];return u||(u=a[GC]={hoistableStyles:new Map,hoistableScripts:new Map}),u}function Mn(a){a[du]=!0}var WC=new Set,HC={};function oa(a,u){Tl(a,u),Tl(a+"Capture",u)}function Tl(a,u){for(HC[a]=u,a=0;a<u.length;a++)WC.add(u[a])}var mP=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),qC={},KC={};function gP(a){return fs.call(KC,a)?!0:fs.call(qC,a)?!1:mP.test(a)?KC[a]=!0:(qC[a]=!0,!1)}function $f(a,u,f){if(gP(u))if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":a.removeAttribute(u);return;case"boolean":var g=u.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){a.removeAttribute(u);return}}a.setAttribute(u,""+f)}}function Ef(a,u,f){if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(u);return}a.setAttribute(u,""+f)}}function Ti(a,u,f,g){if(g===null)a.removeAttribute(f);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(f);return}a.setAttributeNS(u,f,""+g)}}function or(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function XC(a){var u=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(u==="checkbox"||u==="radio")}function yP(a,u,f){var g=Object.getOwnPropertyDescriptor(a.constructor.prototype,u);if(!a.hasOwnProperty(u)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var v=g.get,C=g.set;return Object.defineProperty(a,u,{configurable:!0,get:function(){return v.call(this)},set:function(I){f=""+I,C.call(this,I)}}),Object.defineProperty(a,u,{enumerable:g.enumerable}),{getValue:function(){return f},setValue:function(I){f=""+I},stopTracking:function(){a._valueTracker=null,delete a[u]}}}}function W0(a){if(!a._valueTracker){var u=XC(a)?"checked":"value";a._valueTracker=yP(a,u,""+a[u])}}function YC(a){if(!a)return!1;var u=a._valueTracker;if(!u)return!0;var f=u.getValue(),g="";return a&&(g=XC(a)?a.checked?"true":"false":a.value),a=g,a!==f?(u.setValue(a),!0):!1}function If(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var bP=/[\n"\\]/g;function ar(a){return a.replace(bP,function(u){return"\\"+u.charCodeAt(0).toString(16)+" "})}function H0(a,u,f,g,v,C,I,O){a.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?a.type=I:a.removeAttribute("type"),u!=null?I==="number"?(u===0&&a.value===""||a.value!=u)&&(a.value=""+or(u)):a.value!==""+or(u)&&(a.value=""+or(u)):I!=="submit"&&I!=="reset"||a.removeAttribute("value"),u!=null?q0(a,I,or(u)):f!=null?q0(a,I,or(f)):g!=null&&a.removeAttribute("value"),v==null&&C!=null&&(a.defaultChecked=!!C),v!=null&&(a.checked=v&&typeof v!="function"&&typeof v!="symbol"),O!=null&&typeof O!="function"&&typeof O!="symbol"&&typeof O!="boolean"?a.name=""+or(O):a.removeAttribute("name")}function ZC(a,u,f,g,v,C,I,O){if(C!=null&&typeof C!="function"&&typeof C!="symbol"&&typeof C!="boolean"&&(a.type=C),u!=null||f!=null){if(!(C!=="submit"&&C!=="reset"||u!=null)){W0(a);return}f=f!=null?""+or(f):"",u=u!=null?""+or(u):f,O||u===a.value||(a.value=u),a.defaultValue=u}g=g??v,g=typeof g!="function"&&typeof g!="symbol"&&!!g,a.checked=O?a.checked:!!g,a.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(a.name=I),W0(a)}function q0(a,u,f){u==="number"&&If(a.ownerDocument)===a||a.defaultValue===""+f||(a.defaultValue=""+f)}function kl(a,u,f,g){if(a=a.options,u){u={};for(var v=0;v<f.length;v++)u["$"+f[v]]=!0;for(f=0;f<a.length;f++)v=u.hasOwnProperty("$"+a[f].value),a[f].selected!==v&&(a[f].selected=v),v&&g&&(a[f].defaultSelected=!0)}else{for(f=""+or(f),u=null,v=0;v<a.length;v++){if(a[v].value===f){a[v].selected=!0,g&&(a[v].defaultSelected=!0);return}u!==null||a[v].disabled||(u=a[v])}u!==null&&(u.selected=!0)}}function JC(a,u,f){if(u!=null&&(u=""+or(u),u!==a.value&&(a.value=u),f==null)){a.defaultValue!==u&&(a.defaultValue=u);return}a.defaultValue=f!=null?""+or(f):""}function QC(a,u,f,g){if(u==null){if(g!=null){if(f!=null)throw Error(s(92));if(X(g)){if(1<g.length)throw Error(s(93));g=g[0]}f=g}f==null&&(f=""),u=f}f=or(u),a.defaultValue=f,g=a.textContent,g===f&&g!==""&&g!==null&&(a.value=g),W0(a)}function $l(a,u){if(u){var f=a.firstChild;if(f&&f===a.lastChild&&f.nodeType===3){f.nodeValue=u;return}}a.textContent=u}var xP=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function tT(a,u,f){var g=u.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?g?a.setProperty(u,""):u==="float"?a.cssFloat="":a[u]="":g?a.setProperty(u,f):typeof f!="number"||f===0||xP.has(u)?u==="float"?a.cssFloat=f:a[u]=(""+f).trim():a[u]=f+"px"}function eT(a,u,f){if(u!=null&&typeof u!="object")throw Error(s(62));if(a=a.style,f!=null){for(var g in f)!f.hasOwnProperty(g)||u!=null&&u.hasOwnProperty(g)||(g.indexOf("--")===0?a.setProperty(g,""):g==="float"?a.cssFloat="":a[g]="");for(var v in u)g=u[v],u.hasOwnProperty(v)&&f[v]!==g&&tT(a,v,g)}else for(var C in u)u.hasOwnProperty(C)&&tT(a,C,u[C])}function K0(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var vP=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),wP=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Nf(a){return wP.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function ki(){}var X0=null;function Y0(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var El=null,Il=null;function nT(a){var u=Sl(a);if(u&&(a=u.stateNode)){var f=a[$s]||null;t:switch(a=u.stateNode,u.type){case"input":if(H0(a,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),u=f.name,f.type==="radio"&&u!=null){for(f=a;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+ar(""+u)+'"][type="radio"]'),u=0;u<f.length;u++){var g=f[u];if(g!==a&&g.form===a.form){var v=g[$s]||null;if(!v)throw Error(s(90));H0(g,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name)}}for(u=0;u<f.length;u++)g=f[u],g.form===a.form&&YC(g)}break t;case"textarea":JC(a,f.value,f.defaultValue);break t;case"select":u=f.value,u!=null&&kl(a,!!f.multiple,u,!1)}}}var Z0=!1;function sT(a,u,f){if(Z0)return a(u,f);Z0=!0;try{var g=a(u);return g}finally{if(Z0=!1,(El!==null||Il!==null)&&(gp(),El&&(u=El,a=Il,Il=El=null,nT(u),a)))for(u=0;u<a.length;u++)nT(a[u])}}function pu(a,u){var f=a.stateNode;if(f===null)return null;var g=f[$s]||null;if(g===null)return null;f=g[u];t:switch(u){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(a=a.type,g=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!g;break t;default:a=!1}if(a)return null;if(f&&typeof f!="function")throw Error(s(231,u,typeof f));return f}var $i=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),J0=!1;if($i)try{var mu={};Object.defineProperty(mu,"passive",{get:function(){J0=!0}}),window.addEventListener("test",mu,mu),window.removeEventListener("test",mu,mu)}catch{J0=!1}var ro=null,Q0=null,Af=null;function rT(){if(Af)return Af;var a,u=Q0,f=u.length,g,v="value"in ro?ro.value:ro.textContent,C=v.length;for(a=0;a<f&&u[a]===v[a];a++);var I=f-a;for(g=1;g<=I&&u[f-g]===v[C-g];g++);return Af=v.slice(a,1<g?1-g:void 0)}function _f(a){var u=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&u===13&&(a=13)):a=u,a===10&&(a=13),32<=a||a===13?a:0}function Rf(){return!0}function iT(){return!1}function Es(a){function u(f,g,v,C,I){this._reactName=f,this._targetInst=v,this.type=g,this.nativeEvent=C,this.target=I,this.currentTarget=null;for(var O in a)a.hasOwnProperty(O)&&(f=a[O],this[O]=f?f(C):C[O]);return this.isDefaultPrevented=(C.defaultPrevented!=null?C.defaultPrevented:C.returnValue===!1)?Rf:iT,this.isPropagationStopped=iT,this}return p(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=Rf)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=Rf)},persist:function(){},isPersistent:Rf}),u}var aa={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Df=Es(aa),gu=p({},aa,{view:0,detail:0}),SP=Es(gu),ty,ey,yu,Of=p({},gu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:sy,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==yu&&(yu&&a.type==="mousemove"?(ty=a.screenX-yu.screenX,ey=a.screenY-yu.screenY):ey=ty=0,yu=a),ty)},movementY:function(a){return"movementY"in a?a.movementY:ey}}),oT=Es(Of),CP=p({},Of,{dataTransfer:0}),TP=Es(CP),kP=p({},gu,{relatedTarget:0}),ny=Es(kP),$P=p({},aa,{animationName:0,elapsedTime:0,pseudoElement:0}),EP=Es($P),IP=p({},aa,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),NP=Es(IP),AP=p({},aa,{data:0}),aT=Es(AP),_P={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},RP={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},DP={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function OP(a){var u=this.nativeEvent;return u.getModifierState?u.getModifierState(a):(a=DP[a])?!!u[a]:!1}function sy(){return OP}var MP=p({},gu,{key:function(a){if(a.key){var u=_P[a.key]||a.key;if(u!=="Unidentified")return u}return a.type==="keypress"?(a=_f(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?RP[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:sy,charCode:function(a){return a.type==="keypress"?_f(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?_f(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),FP=Es(MP),LP=p({},Of,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),lT=Es(LP),PP=p({},gu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:sy}),zP=Es(PP),BP=p({},aa,{propertyName:0,elapsedTime:0,pseudoElement:0}),VP=Es(BP),UP=p({},Of,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),jP=Es(UP),GP=p({},aa,{newState:0,oldState:0}),WP=Es(GP),HP=[9,13,27,32],ry=$i&&"CompositionEvent"in window,bu=null;$i&&"documentMode"in document&&(bu=document.documentMode);var qP=$i&&"TextEvent"in window&&!bu,cT=$i&&(!ry||bu&&8<bu&&11>=bu),uT=" ",hT=!1;function dT(a,u){switch(a){case"keyup":return HP.indexOf(u.keyCode)!==-1;case"keydown":return u.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function fT(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var Nl=!1;function KP(a,u){switch(a){case"compositionend":return fT(u);case"keypress":return u.which!==32?null:(hT=!0,uT);case"textInput":return a=u.data,a===uT&&hT?null:a;default:return null}}function XP(a,u){if(Nl)return a==="compositionend"||!ry&&dT(a,u)?(a=rT(),Af=Q0=ro=null,Nl=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(u.ctrlKey||u.altKey||u.metaKey)||u.ctrlKey&&u.altKey){if(u.char&&1<u.char.length)return u.char;if(u.which)return String.fromCharCode(u.which)}return null;case"compositionend":return cT&&u.locale!=="ko"?null:u.data;default:return null}}var YP={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function pT(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u==="input"?!!YP[a.type]:u==="textarea"}function mT(a,u,f,g){El?Il?Il.push(g):Il=[g]:El=g,u=Cp(u,"onChange"),0<u.length&&(f=new Df("onChange","change",null,f,g),a.push({event:f,listeners:u}))}var xu=null,vu=null;function ZP(a){Z2(a,0)}function Mf(a){var u=fu(a);if(YC(u))return a}function gT(a,u){if(a==="change")return u}var yT=!1;if($i){var iy;if($i){var oy="oninput"in document;if(!oy){var bT=document.createElement("div");bT.setAttribute("oninput","return;"),oy=typeof bT.oninput=="function"}iy=oy}else iy=!1;yT=iy&&(!document.documentMode||9<document.documentMode)}function xT(){xu&&(xu.detachEvent("onpropertychange",vT),vu=xu=null)}function vT(a){if(a.propertyName==="value"&&Mf(vu)){var u=[];mT(u,vu,a,Y0(a)),sT(ZP,u)}}function JP(a,u,f){a==="focusin"?(xT(),xu=u,vu=f,xu.attachEvent("onpropertychange",vT)):a==="focusout"&&xT()}function QP(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Mf(vu)}function tz(a,u){if(a==="click")return Mf(u)}function ez(a,u){if(a==="input"||a==="change")return Mf(u)}function nz(a,u){return a===u&&(a!==0||1/a===1/u)||a!==a&&u!==u}var js=typeof Object.is=="function"?Object.is:nz;function wu(a,u){if(js(a,u))return!0;if(typeof a!="object"||a===null||typeof u!="object"||u===null)return!1;var f=Object.keys(a),g=Object.keys(u);if(f.length!==g.length)return!1;for(g=0;g<f.length;g++){var v=f[g];if(!fs.call(u,v)||!js(a[v],u[v]))return!1}return!0}function wT(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ST(a,u){var f=wT(a);a=0;for(var g;f;){if(f.nodeType===3){if(g=a+f.textContent.length,a<=u&&g>=u)return{node:f,offset:u-a};a=g}t:{for(;f;){if(f.nextSibling){f=f.nextSibling;break t}f=f.parentNode}f=void 0}f=wT(f)}}function CT(a,u){return a&&u?a===u?!0:a&&a.nodeType===3?!1:u&&u.nodeType===3?CT(a,u.parentNode):"contains"in a?a.contains(u):a.compareDocumentPosition?!!(a.compareDocumentPosition(u)&16):!1:!1}function TT(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var u=If(a.document);u instanceof a.HTMLIFrameElement;){try{var f=typeof u.contentWindow.location.href=="string"}catch{f=!1}if(f)a=u.contentWindow;else break;u=If(a.document)}return u}function ay(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u&&(u==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||u==="textarea"||a.contentEditable==="true")}var sz=$i&&"documentMode"in document&&11>=document.documentMode,Al=null,ly=null,Su=null,cy=!1;function kT(a,u,f){var g=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;cy||Al==null||Al!==If(g)||(g=Al,"selectionStart"in g&&ay(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),Su&&wu(Su,g)||(Su=g,g=Cp(ly,"onSelect"),0<g.length&&(u=new Df("onSelect","select",null,u,f),a.push({event:u,listeners:g}),u.target=Al)))}function la(a,u){var f={};return f[a.toLowerCase()]=u.toLowerCase(),f["Webkit"+a]="webkit"+u,f["Moz"+a]="moz"+u,f}var _l={animationend:la("Animation","AnimationEnd"),animationiteration:la("Animation","AnimationIteration"),animationstart:la("Animation","AnimationStart"),transitionrun:la("Transition","TransitionRun"),transitionstart:la("Transition","TransitionStart"),transitioncancel:la("Transition","TransitionCancel"),transitionend:la("Transition","TransitionEnd")},uy={},$T={};$i&&($T=document.createElement("div").style,"AnimationEvent"in window||(delete _l.animationend.animation,delete _l.animationiteration.animation,delete _l.animationstart.animation),"TransitionEvent"in window||delete _l.transitionend.transition);function ca(a){if(uy[a])return uy[a];if(!_l[a])return a;var u=_l[a],f;for(f in u)if(u.hasOwnProperty(f)&&f in $T)return uy[a]=u[f];return a}var ET=ca("animationend"),IT=ca("animationiteration"),NT=ca("animationstart"),rz=ca("transitionrun"),iz=ca("transitionstart"),oz=ca("transitioncancel"),AT=ca("transitionend"),_T=new Map,hy="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");hy.push("scrollEnd");function Dr(a,u){_T.set(a,u),oa(u,[a])}var Ff=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var u=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(u))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},lr=[],Rl=0,dy=0;function Lf(){for(var a=Rl,u=dy=Rl=0;u<a;){var f=lr[u];lr[u++]=null;var g=lr[u];lr[u++]=null;var v=lr[u];lr[u++]=null;var C=lr[u];if(lr[u++]=null,g!==null&&v!==null){var I=g.pending;I===null?v.next=v:(v.next=I.next,I.next=v),g.pending=v}C!==0&&RT(f,v,C)}}function Pf(a,u,f,g){lr[Rl++]=a,lr[Rl++]=u,lr[Rl++]=f,lr[Rl++]=g,dy|=g,a.lanes|=g,a=a.alternate,a!==null&&(a.lanes|=g)}function fy(a,u,f,g){return Pf(a,u,f,g),zf(a)}function ua(a,u){return Pf(a,null,null,u),zf(a)}function RT(a,u,f){a.lanes|=f;var g=a.alternate;g!==null&&(g.lanes|=f);for(var v=!1,C=a.return;C!==null;)C.childLanes|=f,g=C.alternate,g!==null&&(g.childLanes|=f),C.tag===22&&(a=C.stateNode,a===null||a._visibility&1||(v=!0)),a=C,C=C.return;return a.tag===3?(C=a.stateNode,v&&u!==null&&(v=31-Us(f),a=C.hiddenUpdates,g=a[v],g===null?a[v]=[u]:g.push(u),u.lane=f|536870912),C):null}function zf(a){if(50<Gu)throw Gu=0,Sb=null,Error(s(185));for(var u=a.return;u!==null;)a=u,u=a.return;return a.tag===3?a.stateNode:null}var Dl={};function az(a,u,f,g){this.tag=a,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=u,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Gs(a,u,f,g){return new az(a,u,f,g)}function py(a){return a=a.prototype,!(!a||!a.isReactComponent)}function Ei(a,u){var f=a.alternate;return f===null?(f=Gs(a.tag,u,a.key,a.mode),f.elementType=a.elementType,f.type=a.type,f.stateNode=a.stateNode,f.alternate=a,a.alternate=f):(f.pendingProps=u,f.type=a.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=a.flags&65011712,f.childLanes=a.childLanes,f.lanes=a.lanes,f.child=a.child,f.memoizedProps=a.memoizedProps,f.memoizedState=a.memoizedState,f.updateQueue=a.updateQueue,u=a.dependencies,f.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext},f.sibling=a.sibling,f.index=a.index,f.ref=a.ref,f.refCleanup=a.refCleanup,f}function DT(a,u){a.flags&=65011714;var f=a.alternate;return f===null?(a.childLanes=0,a.lanes=u,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=f.childLanes,a.lanes=f.lanes,a.child=f.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=f.memoizedProps,a.memoizedState=f.memoizedState,a.updateQueue=f.updateQueue,a.type=f.type,u=f.dependencies,a.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),a}function Bf(a,u,f,g,v,C){var I=0;if(g=a,typeof a=="function")py(a)&&(I=1);else if(typeof a=="string")I=dB(a,f,ct.current)?26:a==="html"||a==="head"||a==="body"?27:5;else t:switch(a){case D:return a=Gs(31,f,u,v),a.elementType=D,a.lanes=C,a;case x:return ha(f.children,v,C,u);case w:I=8,v|=24;break;case S:return a=Gs(12,f,u,v|2),a.elementType=S,a.lanes=C,a;case E:return a=Gs(13,f,u,v),a.elementType=E,a.lanes=C,a;case N:return a=Gs(19,f,u,v),a.elementType=N,a.lanes=C,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case k:I=10;break t;case T:I=9;break t;case $:I=11;break t;case _:I=14;break t;case R:I=16,g=null;break t}I=29,f=Error(s(130,a===null?"null":typeof a,"")),g=null}return u=Gs(I,f,u,v),u.elementType=a,u.type=g,u.lanes=C,u}function ha(a,u,f,g){return a=Gs(7,a,g,u),a.lanes=f,a}function my(a,u,f){return a=Gs(6,a,null,u),a.lanes=f,a}function OT(a){var u=Gs(18,null,null,0);return u.stateNode=a,u}function gy(a,u,f){return u=Gs(4,a.children!==null?a.children:[],a.key,u),u.lanes=f,u.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},u}var MT=new WeakMap;function cr(a,u){if(typeof a=="object"&&a!==null){var f=MT.get(a);return f!==void 0?f:(u={value:a,source:u,stack:ae(u)},MT.set(a,u),u)}return{value:a,source:u,stack:ae(u)}}var Ol=[],Ml=0,Vf=null,Cu=0,ur=[],hr=0,io=null,ti=1,ei="";function Ii(a,u){Ol[Ml++]=Cu,Ol[Ml++]=Vf,Vf=a,Cu=u}function FT(a,u,f){ur[hr++]=ti,ur[hr++]=ei,ur[hr++]=io,io=a;var g=ti;a=ei;var v=32-Us(g)-1;g&=~(1<<v),f+=1;var C=32-Us(u)+v;if(30<C){var I=v-v%5;C=(g&(1<<I)-1).toString(32),g>>=I,v-=I,ti=1<<32-Us(u)+v|f<<v|g,ei=C+a}else ti=1<<C|f<<v|g,ei=a}function yy(a){a.return!==null&&(Ii(a,1),FT(a,1,0))}function by(a){for(;a===Vf;)Vf=Ol[--Ml],Ol[Ml]=null,Cu=Ol[--Ml],Ol[Ml]=null;for(;a===io;)io=ur[--hr],ur[hr]=null,ei=ur[--hr],ur[hr]=null,ti=ur[--hr],ur[hr]=null}function LT(a,u){ur[hr++]=ti,ur[hr++]=ei,ur[hr++]=io,ti=u.id,ei=u.overflow,io=a}var jn=null,Ve=null,ue=!1,oo=null,dr=!1,xy=Error(s(519));function ao(a){var u=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Tu(cr(u,a)),xy}function PT(a){var u=a.stateNode,f=a.type,g=a.memoizedProps;switch(u[Un]=a,u[$s]=g,f){case"dialog":oe("cancel",u),oe("close",u);break;case"iframe":case"object":case"embed":oe("load",u);break;case"video":case"audio":for(f=0;f<Hu.length;f++)oe(Hu[f],u);break;case"source":oe("error",u);break;case"img":case"image":case"link":oe("error",u),oe("load",u);break;case"details":oe("toggle",u);break;case"input":oe("invalid",u),ZC(u,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":oe("invalid",u);break;case"textarea":oe("invalid",u),QC(u,g.value,g.defaultValue,g.children)}f=g.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||u.textContent===""+f||g.suppressHydrationWarning===!0||e$(u.textContent,f)?(g.popover!=null&&(oe("beforetoggle",u),oe("toggle",u)),g.onScroll!=null&&oe("scroll",u),g.onScrollEnd!=null&&oe("scrollend",u),g.onClick!=null&&(u.onclick=ki),u=!0):u=!1,u||ao(a,!0)}function zT(a){for(jn=a.return;jn;)switch(jn.tag){case 5:case 31:case 13:dr=!1;return;case 27:case 3:dr=!0;return;default:jn=jn.return}}function Fl(a){if(a!==jn)return!1;if(!ue)return zT(a),ue=!0,!1;var u=a.tag,f;if((f=u!==3&&u!==27)&&((f=u===5)&&(f=a.type,f=!(f!=="form"&&f!=="button")||Lb(a.type,a.memoizedProps)),f=!f),f&&Ve&&ao(a),zT(a),u===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Ve=u$(a)}else if(u===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));Ve=u$(a)}else u===27?(u=Ve,So(a.type)?(a=Ub,Ub=null,Ve=a):Ve=u):Ve=jn?pr(a.stateNode.nextSibling):null;return!0}function da(){Ve=jn=null,ue=!1}function vy(){var a=oo;return a!==null&&(_s===null?_s=a:_s.push.apply(_s,a),oo=null),a}function Tu(a){oo===null?oo=[a]:oo.push(a)}var wy=F(null),fa=null,Ni=null;function lo(a,u,f){Q(wy,u._currentValue),u._currentValue=f}function Ai(a){a._currentValue=wy.current,z(wy)}function Sy(a,u,f){for(;a!==null;){var g=a.alternate;if((a.childLanes&u)!==u?(a.childLanes|=u,g!==null&&(g.childLanes|=u)):g!==null&&(g.childLanes&u)!==u&&(g.childLanes|=u),a===f)break;a=a.return}}function Cy(a,u,f,g){var v=a.child;for(v!==null&&(v.return=a);v!==null;){var C=v.dependencies;if(C!==null){var I=v.child;C=C.firstContext;t:for(;C!==null;){var O=C;C=v;for(var j=0;j<u.length;j++)if(O.context===u[j]){C.lanes|=f,O=C.alternate,O!==null&&(O.lanes|=f),Sy(C.return,f,a),g||(I=null);break t}C=O.next}}else if(v.tag===18){if(I=v.return,I===null)throw Error(s(341));I.lanes|=f,C=I.alternate,C!==null&&(C.lanes|=f),Sy(I,f,a),I=null}else I=v.child;if(I!==null)I.return=v;else for(I=v;I!==null;){if(I===a){I=null;break}if(v=I.sibling,v!==null){v.return=I.return,I=v;break}I=I.return}v=I}}function Ll(a,u,f,g){a=null;for(var v=u,C=!1;v!==null;){if(!C){if((v.flags&524288)!==0)C=!0;else if((v.flags&262144)!==0)break}if(v.tag===10){var I=v.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var O=v.type;js(v.pendingProps.value,I.value)||(a!==null?a.push(O):a=[O])}}else if(v===xt.current){if(I=v.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==v.memoizedState.memoizedState&&(a!==null?a.push(Zu):a=[Zu])}v=v.return}a!==null&&Cy(u,a,f,g),u.flags|=262144}function Uf(a){for(a=a.firstContext;a!==null;){if(!js(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function pa(a){fa=a,Ni=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function Gn(a){return BT(fa,a)}function jf(a,u){return fa===null&&pa(a),BT(a,u)}function BT(a,u){var f=u._currentValue;if(u={context:u,memoizedValue:f,next:null},Ni===null){if(a===null)throw Error(s(308));Ni=u,a.dependencies={lanes:0,firstContext:u},a.flags|=524288}else Ni=Ni.next=u;return f}var lz=typeof AbortController<"u"?AbortController:function(){var a=[],u=this.signal={aborted:!1,addEventListener:function(f,g){a.push(g)}};this.abort=function(){u.aborted=!0,a.forEach(function(f){return f()})}},cz=n.unstable_scheduleCallback,uz=n.unstable_NormalPriority,fn={$$typeof:k,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Ty(){return{controller:new lz,data:new Map,refCount:0}}function ku(a){a.refCount--,a.refCount===0&&cz(uz,function(){a.controller.abort()})}var $u=null,ky=0,Pl=0,zl=null;function hz(a,u){if($u===null){var f=$u=[];ky=0,Pl=Ib(),zl={status:"pending",value:void 0,then:function(g){f.push(g)}}}return ky++,u.then(VT,VT),u}function VT(){if(--ky===0&&$u!==null){zl!==null&&(zl.status="fulfilled");var a=$u;$u=null,Pl=0,zl=null;for(var u=0;u<a.length;u++)(0,a[u])()}}function dz(a,u){var f=[],g={status:"pending",value:null,reason:null,then:function(v){f.push(v)}};return a.then(function(){g.status="fulfilled",g.value=u;for(var v=0;v<f.length;v++)(0,f[v])(u)},function(v){for(g.status="rejected",g.reason=v,v=0;v<f.length;v++)(0,f[v])(void 0)}),g}var UT=P.S;P.S=function(a,u){k2=De(),typeof u=="object"&&u!==null&&typeof u.then=="function"&&hz(a,u),UT!==null&&UT(a,u)};var ma=F(null);function $y(){var a=ma.current;return a!==null?a:Oe.pooledCache}function Gf(a,u){u===null?Q(ma,ma.current):Q(ma,u.pool)}function jT(){var a=$y();return a===null?null:{parent:fn._currentValue,pool:a}}var Bl=Error(s(460)),Ey=Error(s(474)),Wf=Error(s(542)),Hf={then:function(){}};function GT(a){return a=a.status,a==="fulfilled"||a==="rejected"}function WT(a,u,f){switch(f=a[f],f===void 0?a.push(u):f!==u&&(u.then(ki,ki),u=f),u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,qT(a),a;default:if(typeof u.status=="string")u.then(ki,ki);else{if(a=Oe,a!==null&&100<a.shellSuspendCounter)throw Error(s(482));a=u,a.status="pending",a.then(function(g){if(u.status==="pending"){var v=u;v.status="fulfilled",v.value=g}},function(g){if(u.status==="pending"){var v=u;v.status="rejected",v.reason=g}})}switch(u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,qT(a),a}throw ya=u,Bl}}function ga(a){try{var u=a._init;return u(a._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(ya=f,Bl):f}}var ya=null;function HT(){if(ya===null)throw Error(s(459));var a=ya;return ya=null,a}function qT(a){if(a===Bl||a===Wf)throw Error(s(483))}var Vl=null,Eu=0;function qf(a){var u=Eu;return Eu+=1,Vl===null&&(Vl=[]),WT(Vl,a,u)}function Iu(a,u){u=u.props.ref,a.ref=u!==void 0?u:null}function Kf(a,u){throw u.$$typeof===m?Error(s(525)):(a=Object.prototype.toString.call(u),Error(s(31,a==="[object Object]"?"object with keys {"+Object.keys(u).join(", ")+"}":a)))}function KT(a){function u(st,K){if(a){var ot=st.deletions;ot===null?(st.deletions=[K],st.flags|=16):ot.push(K)}}function f(st,K){if(!a)return null;for(;K!==null;)u(st,K),K=K.sibling;return null}function g(st){for(var K=new Map;st!==null;)st.key!==null?K.set(st.key,st):K.set(st.index,st),st=st.sibling;return K}function v(st,K){return st=Ei(st,K),st.index=0,st.sibling=null,st}function C(st,K,ot){return st.index=ot,a?(ot=st.alternate,ot!==null?(ot=ot.index,ot<K?(st.flags|=67108866,K):ot):(st.flags|=67108866,K)):(st.flags|=1048576,K)}function I(st){return a&&st.alternate===null&&(st.flags|=67108866),st}function O(st,K,ot,yt){return K===null||K.tag!==6?(K=my(ot,st.mode,yt),K.return=st,K):(K=v(K,ot),K.return=st,K)}function j(st,K,ot,yt){var Ft=ot.type;return Ft===x?mt(st,K,ot.props.children,yt,ot.key):K!==null&&(K.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===R&&ga(Ft)===K.type)?(K=v(K,ot.props),Iu(K,ot),K.return=st,K):(K=Bf(ot.type,ot.key,ot.props,null,st.mode,yt),Iu(K,ot),K.return=st,K)}function at(st,K,ot,yt){return K===null||K.tag!==4||K.stateNode.containerInfo!==ot.containerInfo||K.stateNode.implementation!==ot.implementation?(K=gy(ot,st.mode,yt),K.return=st,K):(K=v(K,ot.children||[]),K.return=st,K)}function mt(st,K,ot,yt,Ft){return K===null||K.tag!==7?(K=ha(ot,st.mode,yt,Ft),K.return=st,K):(K=v(K,ot),K.return=st,K)}function bt(st,K,ot){if(typeof K=="string"&&K!==""||typeof K=="number"||typeof K=="bigint")return K=my(""+K,st.mode,ot),K.return=st,K;if(typeof K=="object"&&K!==null){switch(K.$$typeof){case y:return ot=Bf(K.type,K.key,K.props,null,st.mode,ot),Iu(ot,K),ot.return=st,ot;case b:return K=gy(K,st.mode,ot),K.return=st,K;case R:return K=ga(K),bt(st,K,ot)}if(X(K)||B(K))return K=ha(K,st.mode,ot,null),K.return=st,K;if(typeof K.then=="function")return bt(st,qf(K),ot);if(K.$$typeof===k)return bt(st,jf(st,K),ot);Kf(st,K)}return null}function ut(st,K,ot,yt){var Ft=K!==null?K.key:null;if(typeof ot=="string"&&ot!==""||typeof ot=="number"||typeof ot=="bigint")return Ft!==null?null:O(st,K,""+ot,yt);if(typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case y:return ot.key===Ft?j(st,K,ot,yt):null;case b:return ot.key===Ft?at(st,K,ot,yt):null;case R:return ot=ga(ot),ut(st,K,ot,yt)}if(X(ot)||B(ot))return Ft!==null?null:mt(st,K,ot,yt,null);if(typeof ot.then=="function")return ut(st,K,qf(ot),yt);if(ot.$$typeof===k)return ut(st,K,jf(st,ot),yt);Kf(st,ot)}return null}function ht(st,K,ot,yt,Ft){if(typeof yt=="string"&&yt!==""||typeof yt=="number"||typeof yt=="bigint")return st=st.get(ot)||null,O(K,st,""+yt,Ft);if(typeof yt=="object"&&yt!==null){switch(yt.$$typeof){case y:return st=st.get(yt.key===null?ot:yt.key)||null,j(K,st,yt,Ft);case b:return st=st.get(yt.key===null?ot:yt.key)||null,at(K,st,yt,Ft);case R:return yt=ga(yt),ht(st,K,ot,yt,Ft)}if(X(yt)||B(yt))return st=st.get(ot)||null,mt(K,st,yt,Ft,null);if(typeof yt.then=="function")return ht(st,K,ot,qf(yt),Ft);if(yt.$$typeof===k)return ht(st,K,ot,jf(K,yt),Ft);Kf(K,yt)}return null}function It(st,K,ot,yt){for(var Ft=null,ye=null,_t=K,Jt=K=0,ce=null;_t!==null&&Jt<ot.length;Jt++){_t.index>Jt?(ce=_t,_t=null):ce=_t.sibling;var be=ut(st,_t,ot[Jt],yt);if(be===null){_t===null&&(_t=ce);break}a&&_t&&be.alternate===null&&u(st,_t),K=C(be,K,Jt),ye===null?Ft=be:ye.sibling=be,ye=be,_t=ce}if(Jt===ot.length)return f(st,_t),ue&&Ii(st,Jt),Ft;if(_t===null){for(;Jt<ot.length;Jt++)_t=bt(st,ot[Jt],yt),_t!==null&&(K=C(_t,K,Jt),ye===null?Ft=_t:ye.sibling=_t,ye=_t);return ue&&Ii(st,Jt),Ft}for(_t=g(_t);Jt<ot.length;Jt++)ce=ht(_t,st,Jt,ot[Jt],yt),ce!==null&&(a&&ce.alternate!==null&&_t.delete(ce.key===null?Jt:ce.key),K=C(ce,K,Jt),ye===null?Ft=ce:ye.sibling=ce,ye=ce);return a&&_t.forEach(function(Eo){return u(st,Eo)}),ue&&Ii(st,Jt),Ft}function zt(st,K,ot,yt){if(ot==null)throw Error(s(151));for(var Ft=null,ye=null,_t=K,Jt=K=0,ce=null,be=ot.next();_t!==null&&!be.done;Jt++,be=ot.next()){_t.index>Jt?(ce=_t,_t=null):ce=_t.sibling;var Eo=ut(st,_t,be.value,yt);if(Eo===null){_t===null&&(_t=ce);break}a&&_t&&Eo.alternate===null&&u(st,_t),K=C(Eo,K,Jt),ye===null?Ft=Eo:ye.sibling=Eo,ye=Eo,_t=ce}if(be.done)return f(st,_t),ue&&Ii(st,Jt),Ft;if(_t===null){for(;!be.done;Jt++,be=ot.next())be=bt(st,be.value,yt),be!==null&&(K=C(be,K,Jt),ye===null?Ft=be:ye.sibling=be,ye=be);return ue&&Ii(st,Jt),Ft}for(_t=g(_t);!be.done;Jt++,be=ot.next())be=ht(_t,st,Jt,be.value,yt),be!==null&&(a&&be.alternate!==null&&_t.delete(be.key===null?Jt:be.key),K=C(be,K,Jt),ye===null?Ft=be:ye.sibling=be,ye=be);return a&&_t.forEach(function(CB){return u(st,CB)}),ue&&Ii(st,Jt),Ft}function _e(st,K,ot,yt){if(typeof ot=="object"&&ot!==null&&ot.type===x&&ot.key===null&&(ot=ot.props.children),typeof ot=="object"&&ot!==null){switch(ot.$$typeof){case y:t:{for(var Ft=ot.key;K!==null;){if(K.key===Ft){if(Ft=ot.type,Ft===x){if(K.tag===7){f(st,K.sibling),yt=v(K,ot.props.children),yt.return=st,st=yt;break t}}else if(K.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===R&&ga(Ft)===K.type){f(st,K.sibling),yt=v(K,ot.props),Iu(yt,ot),yt.return=st,st=yt;break t}f(st,K);break}else u(st,K);K=K.sibling}ot.type===x?(yt=ha(ot.props.children,st.mode,yt,ot.key),yt.return=st,st=yt):(yt=Bf(ot.type,ot.key,ot.props,null,st.mode,yt),Iu(yt,ot),yt.return=st,st=yt)}return I(st);case b:t:{for(Ft=ot.key;K!==null;){if(K.key===Ft)if(K.tag===4&&K.stateNode.containerInfo===ot.containerInfo&&K.stateNode.implementation===ot.implementation){f(st,K.sibling),yt=v(K,ot.children||[]),yt.return=st,st=yt;break t}else{f(st,K);break}else u(st,K);K=K.sibling}yt=gy(ot,st.mode,yt),yt.return=st,st=yt}return I(st);case R:return ot=ga(ot),_e(st,K,ot,yt)}if(X(ot))return It(st,K,ot,yt);if(B(ot)){if(Ft=B(ot),typeof Ft!="function")throw Error(s(150));return ot=Ft.call(ot),zt(st,K,ot,yt)}if(typeof ot.then=="function")return _e(st,K,qf(ot),yt);if(ot.$$typeof===k)return _e(st,K,jf(st,ot),yt);Kf(st,ot)}return typeof ot=="string"&&ot!==""||typeof ot=="number"||typeof ot=="bigint"?(ot=""+ot,K!==null&&K.tag===6?(f(st,K.sibling),yt=v(K,ot),yt.return=st,st=yt):(f(st,K),yt=my(ot,st.mode,yt),yt.return=st,st=yt),I(st)):f(st,K)}return function(st,K,ot,yt){try{Eu=0;var Ft=_e(st,K,ot,yt);return Vl=null,Ft}catch(_t){if(_t===Bl||_t===Wf)throw _t;var ye=Gs(29,_t,null,st.mode);return ye.lanes=yt,ye.return=st,ye}}}var ba=KT(!0),XT=KT(!1),co=!1;function Iy(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Ny(a,u){a=a.updateQueue,u.updateQueue===a&&(u.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function uo(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function ho(a,u,f){var g=a.updateQueue;if(g===null)return null;if(g=g.shared,(Se&2)!==0){var v=g.pending;return v===null?u.next=u:(u.next=v.next,v.next=u),g.pending=u,u=zf(a),RT(a,null,f),u}return Pf(a,g,u,f),zf(a)}function Nu(a,u,f){if(u=u.updateQueue,u!==null&&(u=u.shared,(f&4194048)!==0)){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,BC(a,f)}}function Ay(a,u){var f=a.updateQueue,g=a.alternate;if(g!==null&&(g=g.updateQueue,f===g)){var v=null,C=null;if(f=f.firstBaseUpdate,f!==null){do{var I={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};C===null?v=C=I:C=C.next=I,f=f.next}while(f!==null);C===null?v=C=u:C=C.next=u}else v=C=u;f={baseState:g.baseState,firstBaseUpdate:v,lastBaseUpdate:C,shared:g.shared,callbacks:g.callbacks},a.updateQueue=f;return}a=f.lastBaseUpdate,a===null?f.firstBaseUpdate=u:a.next=u,f.lastBaseUpdate=u}var _y=!1;function Au(){if(_y){var a=zl;if(a!==null)throw a}}function _u(a,u,f,g){_y=!1;var v=a.updateQueue;co=!1;var C=v.firstBaseUpdate,I=v.lastBaseUpdate,O=v.shared.pending;if(O!==null){v.shared.pending=null;var j=O,at=j.next;j.next=null,I===null?C=at:I.next=at,I=j;var mt=a.alternate;mt!==null&&(mt=mt.updateQueue,O=mt.lastBaseUpdate,O!==I&&(O===null?mt.firstBaseUpdate=at:O.next=at,mt.lastBaseUpdate=j))}if(C!==null){var bt=v.baseState;I=0,mt=at=j=null,O=C;do{var ut=O.lane&-536870913,ht=ut!==O.lane;if(ht?(le&ut)===ut:(g&ut)===ut){ut!==0&&ut===Pl&&(_y=!0),mt!==null&&(mt=mt.next={lane:0,tag:O.tag,payload:O.payload,callback:null,next:null});t:{var It=a,zt=O;ut=u;var _e=f;switch(zt.tag){case 1:if(It=zt.payload,typeof It=="function"){bt=It.call(_e,bt,ut);break t}bt=It;break t;case 3:It.flags=It.flags&-65537|128;case 0:if(It=zt.payload,ut=typeof It=="function"?It.call(_e,bt,ut):It,ut==null)break t;bt=p({},bt,ut);break t;case 2:co=!0}}ut=O.callback,ut!==null&&(a.flags|=64,ht&&(a.flags|=8192),ht=v.callbacks,ht===null?v.callbacks=[ut]:ht.push(ut))}else ht={lane:ut,tag:O.tag,payload:O.payload,callback:O.callback,next:null},mt===null?(at=mt=ht,j=bt):mt=mt.next=ht,I|=ut;if(O=O.next,O===null){if(O=v.shared.pending,O===null)break;ht=O,O=ht.next,ht.next=null,v.lastBaseUpdate=ht,v.shared.pending=null}}while(!0);mt===null&&(j=bt),v.baseState=j,v.firstBaseUpdate=at,v.lastBaseUpdate=mt,C===null&&(v.shared.lanes=0),yo|=I,a.lanes=I,a.memoizedState=bt}}function YT(a,u){if(typeof a!="function")throw Error(s(191,a));a.call(u)}function ZT(a,u){var f=a.callbacks;if(f!==null)for(a.callbacks=null,a=0;a<f.length;a++)YT(f[a],u)}var Ul=F(null),Xf=F(0);function JT(a,u){a=zi,Q(Xf,a),Q(Ul,u),zi=a|u.baseLanes}function Ry(){Q(Xf,zi),Q(Ul,Ul.current)}function Dy(){zi=Xf.current,z(Ul),z(Xf)}var Ws=F(null),fr=null;function fo(a){var u=a.alternate;Q(cn,cn.current&1),Q(Ws,a),fr===null&&(u===null||Ul.current!==null||u.memoizedState!==null)&&(fr=a)}function Oy(a){Q(cn,cn.current),Q(Ws,a),fr===null&&(fr=a)}function QT(a){a.tag===22?(Q(cn,cn.current),Q(Ws,a),fr===null&&(fr=a)):po()}function po(){Q(cn,cn.current),Q(Ws,Ws.current)}function Hs(a){z(Ws),fr===a&&(fr=null),z(cn)}var cn=F(0);function Yf(a){for(var u=a;u!==null;){if(u.tag===13){var f=u.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||Bb(f)||Vb(f)))return u}else if(u.tag===19&&(u.memoizedProps.revealOrder==="forwards"||u.memoizedProps.revealOrder==="backwards"||u.memoizedProps.revealOrder==="unstable_legacy-backwards"||u.memoizedProps.revealOrder==="together")){if((u.flags&128)!==0)return u}else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return null;u=u.return}u.sibling.return=u.return,u=u.sibling}return null}var _i=0,Kt=null,Ne=null,pn=null,Zf=!1,jl=!1,xa=!1,Jf=0,Ru=0,Gl=null,fz=0;function Je(){throw Error(s(321))}function My(a,u){if(u===null)return!1;for(var f=0;f<u.length&&f<a.length;f++)if(!js(a[f],u[f]))return!1;return!0}function Fy(a,u,f,g,v,C){return _i=C,Kt=u,u.memoizedState=null,u.updateQueue=null,u.lanes=0,P.H=a===null||a.memoizedState===null?Fk:Zy,xa=!1,C=f(g,v),xa=!1,jl&&(C=ek(u,f,g,v)),tk(a),C}function tk(a){P.H=Mu;var u=Ne!==null&&Ne.next!==null;if(_i=0,pn=Ne=Kt=null,Zf=!1,Ru=0,Gl=null,u)throw Error(s(300));a===null||mn||(a=a.dependencies,a!==null&&Uf(a)&&(mn=!0))}function ek(a,u,f,g){Kt=a;var v=0;do{if(jl&&(Gl=null),Ru=0,jl=!1,25<=v)throw Error(s(301));if(v+=1,pn=Ne=null,a.updateQueue!=null){var C=a.updateQueue;C.lastEffect=null,C.events=null,C.stores=null,C.memoCache!=null&&(C.memoCache.index=0)}P.H=Lk,C=u(f,g)}while(jl);return C}function pz(){var a=P.H,u=a.useState()[0];return u=typeof u.then=="function"?Du(u):u,a=a.useState()[0],(Ne!==null?Ne.memoizedState:null)!==a&&(Kt.flags|=1024),u}function Ly(){var a=Jf!==0;return Jf=0,a}function Py(a,u,f){u.updateQueue=a.updateQueue,u.flags&=-2053,a.lanes&=~f}function zy(a){if(Zf){for(a=a.memoizedState;a!==null;){var u=a.queue;u!==null&&(u.pending=null),a=a.next}Zf=!1}_i=0,pn=Ne=Kt=null,jl=!1,Ru=Jf=0,Gl=null}function ms(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return pn===null?Kt.memoizedState=pn=a:pn=pn.next=a,pn}function un(){if(Ne===null){var a=Kt.alternate;a=a!==null?a.memoizedState:null}else a=Ne.next;var u=pn===null?Kt.memoizedState:pn.next;if(u!==null)pn=u,Ne=a;else{if(a===null)throw Kt.alternate===null?Error(s(467)):Error(s(310));Ne=a,a={memoizedState:Ne.memoizedState,baseState:Ne.baseState,baseQueue:Ne.baseQueue,queue:Ne.queue,next:null},pn===null?Kt.memoizedState=pn=a:pn=pn.next=a}return pn}function Qf(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Du(a){var u=Ru;return Ru+=1,Gl===null&&(Gl=[]),a=WT(Gl,a,u),u=Kt,(pn===null?u.memoizedState:pn.next)===null&&(u=u.alternate,P.H=u===null||u.memoizedState===null?Fk:Zy),a}function tp(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return Du(a);if(a.$$typeof===k)return Gn(a)}throw Error(s(438,String(a)))}function By(a){var u=null,f=Kt.updateQueue;if(f!==null&&(u=f.memoCache),u==null){var g=Kt.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(u={data:g.data.map(function(v){return v.slice()}),index:0})))}if(u==null&&(u={data:[],index:0}),f===null&&(f=Qf(),Kt.updateQueue=f),f.memoCache=u,f=u.data[u.index],f===void 0)for(f=u.data[u.index]=Array(a),g=0;g<a;g++)f[g]=M;return u.index++,f}function Ri(a,u){return typeof u=="function"?u(a):u}function ep(a){var u=un();return Vy(u,Ne,a)}function Vy(a,u,f){var g=a.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=f;var v=a.baseQueue,C=g.pending;if(C!==null){if(v!==null){var I=v.next;v.next=C.next,C.next=I}u.baseQueue=v=C,g.pending=null}if(C=a.baseState,v===null)a.memoizedState=C;else{u=v.next;var O=I=null,j=null,at=u,mt=!1;do{var bt=at.lane&-536870913;if(bt!==at.lane?(le&bt)===bt:(_i&bt)===bt){var ut=at.revertLane;if(ut===0)j!==null&&(j=j.next={lane:0,revertLane:0,gesture:null,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null}),bt===Pl&&(mt=!0);else if((_i&ut)===ut){at=at.next,ut===Pl&&(mt=!0);continue}else bt={lane:0,revertLane:at.revertLane,gesture:null,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null},j===null?(O=j=bt,I=C):j=j.next=bt,Kt.lanes|=ut,yo|=ut;bt=at.action,xa&&f(C,bt),C=at.hasEagerState?at.eagerState:f(C,bt)}else ut={lane:bt,revertLane:at.revertLane,gesture:at.gesture,action:at.action,hasEagerState:at.hasEagerState,eagerState:at.eagerState,next:null},j===null?(O=j=ut,I=C):j=j.next=ut,Kt.lanes|=bt,yo|=bt;at=at.next}while(at!==null&&at!==u);if(j===null?I=C:j.next=O,!js(C,a.memoizedState)&&(mn=!0,mt&&(f=zl,f!==null)))throw f;a.memoizedState=C,a.baseState=I,a.baseQueue=j,g.lastRenderedState=C}return v===null&&(g.lanes=0),[a.memoizedState,g.dispatch]}function Uy(a){var u=un(),f=u.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=a;var g=f.dispatch,v=f.pending,C=u.memoizedState;if(v!==null){f.pending=null;var I=v=v.next;do C=a(C,I.action),I=I.next;while(I!==v);js(C,u.memoizedState)||(mn=!0),u.memoizedState=C,u.baseQueue===null&&(u.baseState=C),f.lastRenderedState=C}return[C,g]}function nk(a,u,f){var g=Kt,v=un(),C=ue;if(C){if(f===void 0)throw Error(s(407));f=f()}else f=u();var I=!js((Ne||v).memoizedState,f);if(I&&(v.memoizedState=f,mn=!0),v=v.queue,Wy(ik.bind(null,g,v,a),[a]),v.getSnapshot!==u||I||pn!==null&&pn.memoizedState.tag&1){if(g.flags|=2048,Wl(9,{destroy:void 0},rk.bind(null,g,v,f,u),null),Oe===null)throw Error(s(349));C||(_i&127)!==0||sk(g,u,f)}return f}function sk(a,u,f){a.flags|=16384,a={getSnapshot:u,value:f},u=Kt.updateQueue,u===null?(u=Qf(),Kt.updateQueue=u,u.stores=[a]):(f=u.stores,f===null?u.stores=[a]:f.push(a))}function rk(a,u,f,g){u.value=f,u.getSnapshot=g,ok(u)&&ak(a)}function ik(a,u,f){return f(function(){ok(u)&&ak(a)})}function ok(a){var u=a.getSnapshot;a=a.value;try{var f=u();return!js(a,f)}catch{return!0}}function ak(a){var u=ua(a,2);u!==null&&Rs(u,a,2)}function jy(a){var u=ms();if(typeof a=="function"){var f=a;if(a=f(),xa){Qr(!0);try{f()}finally{Qr(!1)}}}return u.memoizedState=u.baseState=a,u.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ri,lastRenderedState:a},u}function lk(a,u,f,g){return a.baseState=f,Vy(a,Ne,typeof g=="function"?g:Ri)}function mz(a,u,f,g,v){if(rp(a))throw Error(s(485));if(a=u.action,a!==null){var C={payload:v,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){C.listeners.push(I)}};P.T!==null?f(!0):C.isTransition=!1,g(C),f=u.pending,f===null?(C.next=u.pending=C,ck(u,C)):(C.next=f.next,u.pending=f.next=C)}}function ck(a,u){var f=u.action,g=u.payload,v=a.state;if(u.isTransition){var C=P.T,I={};P.T=I;try{var O=f(v,g),j=P.S;j!==null&&j(I,O),uk(a,u,O)}catch(at){Gy(a,u,at)}finally{C!==null&&I.types!==null&&(C.types=I.types),P.T=C}}else try{C=f(v,g),uk(a,u,C)}catch(at){Gy(a,u,at)}}function uk(a,u,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(g){hk(a,u,g)},function(g){return Gy(a,u,g)}):hk(a,u,f)}function hk(a,u,f){u.status="fulfilled",u.value=f,dk(u),a.state=f,u=a.pending,u!==null&&(f=u.next,f===u?a.pending=null:(f=f.next,u.next=f,ck(a,f)))}function Gy(a,u,f){var g=a.pending;if(a.pending=null,g!==null){g=g.next;do u.status="rejected",u.reason=f,dk(u),u=u.next;while(u!==g)}a.action=null}function dk(a){a=a.listeners;for(var u=0;u<a.length;u++)(0,a[u])()}function fk(a,u){return u}function pk(a,u){if(ue){var f=Oe.formState;if(f!==null){t:{var g=Kt;if(ue){if(Ve){e:{for(var v=Ve,C=dr;v.nodeType!==8;){if(!C){v=null;break e}if(v=pr(v.nextSibling),v===null){v=null;break e}}C=v.data,v=C==="F!"||C==="F"?v:null}if(v){Ve=pr(v.nextSibling),g=v.data==="F!";break t}}ao(g)}g=!1}g&&(u=f[0])}}return f=ms(),f.memoizedState=f.baseState=u,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:fk,lastRenderedState:u},f.queue=g,f=Dk.bind(null,Kt,g),g.dispatch=f,g=jy(!1),C=Yy.bind(null,Kt,!1,g.queue),g=ms(),v={state:u,dispatch:null,action:a,pending:null},g.queue=v,f=mz.bind(null,Kt,v,C,f),v.dispatch=f,g.memoizedState=a,[u,f,!1]}function mk(a){var u=un();return gk(u,Ne,a)}function gk(a,u,f){if(u=Vy(a,u,fk)[0],a=ep(Ri)[0],typeof u=="object"&&u!==null&&typeof u.then=="function")try{var g=Du(u)}catch(I){throw I===Bl?Wf:I}else g=u;u=un();var v=u.queue,C=v.dispatch;return f!==u.memoizedState&&(Kt.flags|=2048,Wl(9,{destroy:void 0},gz.bind(null,v,f),null)),[g,C,a]}function gz(a,u){a.action=u}function yk(a){var u=un(),f=Ne;if(f!==null)return gk(u,f,a);un(),u=u.memoizedState,f=un();var g=f.queue.dispatch;return f.memoizedState=a,[u,g,!1]}function Wl(a,u,f,g){return a={tag:a,create:f,deps:g,inst:u,next:null},u=Kt.updateQueue,u===null&&(u=Qf(),Kt.updateQueue=u),f=u.lastEffect,f===null?u.lastEffect=a.next=a:(g=f.next,f.next=a,a.next=g,u.lastEffect=a),a}function bk(){return un().memoizedState}function np(a,u,f,g){var v=ms();Kt.flags|=a,v.memoizedState=Wl(1|u,{destroy:void 0},f,g===void 0?null:g)}function sp(a,u,f,g){var v=un();g=g===void 0?null:g;var C=v.memoizedState.inst;Ne!==null&&g!==null&&My(g,Ne.memoizedState.deps)?v.memoizedState=Wl(u,C,f,g):(Kt.flags|=a,v.memoizedState=Wl(1|u,C,f,g))}function xk(a,u){np(8390656,8,a,u)}function Wy(a,u){sp(2048,8,a,u)}function yz(a){Kt.flags|=4;var u=Kt.updateQueue;if(u===null)u=Qf(),Kt.updateQueue=u,u.events=[a];else{var f=u.events;f===null?u.events=[a]:f.push(a)}}function vk(a){var u=un().memoizedState;return yz({ref:u,nextImpl:a}),function(){if((Se&2)!==0)throw Error(s(440));return u.impl.apply(void 0,arguments)}}function wk(a,u){return sp(4,2,a,u)}function Sk(a,u){return sp(4,4,a,u)}function Ck(a,u){if(typeof u=="function"){a=a();var f=u(a);return function(){typeof f=="function"?f():u(null)}}if(u!=null)return a=a(),u.current=a,function(){u.current=null}}function Tk(a,u,f){f=f!=null?f.concat([a]):null,sp(4,4,Ck.bind(null,u,a),f)}function Hy(){}function kk(a,u){var f=un();u=u===void 0?null:u;var g=f.memoizedState;return u!==null&&My(u,g[1])?g[0]:(f.memoizedState=[a,u],a)}function $k(a,u){var f=un();u=u===void 0?null:u;var g=f.memoizedState;if(u!==null&&My(u,g[1]))return g[0];if(g=a(),xa){Qr(!0);try{a()}finally{Qr(!1)}}return f.memoizedState=[g,u],g}function qy(a,u,f){return f===void 0||(_i&1073741824)!==0&&(le&261930)===0?a.memoizedState=u:(a.memoizedState=f,a=E2(),Kt.lanes|=a,yo|=a,f)}function Ek(a,u,f,g){return js(f,u)?f:Ul.current!==null?(a=qy(a,f,g),js(a,u)||(mn=!0),a):(_i&42)===0||(_i&1073741824)!==0&&(le&261930)===0?(mn=!0,a.memoizedState=f):(a=E2(),Kt.lanes|=a,yo|=a,u)}function Ik(a,u,f,g,v){var C=U.p;U.p=C!==0&&8>C?C:8;var I=P.T,O={};P.T=O,Yy(a,!1,u,f);try{var j=v(),at=P.S;if(at!==null&&at(O,j),j!==null&&typeof j=="object"&&typeof j.then=="function"){var mt=dz(j,g);Ou(a,u,mt,Xs(a))}else Ou(a,u,g,Xs(a))}catch(bt){Ou(a,u,{then:function(){},status:"rejected",reason:bt},Xs())}finally{U.p=C,I!==null&&O.types!==null&&(I.types=O.types),P.T=I}}function bz(){}function Ky(a,u,f,g){if(a.tag!==5)throw Error(s(476));var v=Nk(a).queue;Ik(a,v,u,G,f===null?bz:function(){return Ak(a),f(g)})}function Nk(a){var u=a.memoizedState;if(u!==null)return u;u={memoizedState:G,baseState:G,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ri,lastRenderedState:G},next:null};var f={};return u.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Ri,lastRenderedState:f},next:null},a.memoizedState=u,a=a.alternate,a!==null&&(a.memoizedState=u),u}function Ak(a){var u=Nk(a);u.next===null&&(u=a.alternate.memoizedState),Ou(a,u.next.queue,{},Xs())}function Xy(){return Gn(Zu)}function _k(){return un().memoizedState}function Rk(){return un().memoizedState}function xz(a){for(var u=a.return;u!==null;){switch(u.tag){case 24:case 3:var f=Xs();a=uo(f);var g=ho(u,a,f);g!==null&&(Rs(g,u,f),Nu(g,u,f)),u={cache:Ty()},a.payload=u;return}u=u.return}}function vz(a,u,f){var g=Xs();f={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},rp(a)?Ok(u,f):(f=fy(a,u,f,g),f!==null&&(Rs(f,a,g),Mk(f,u,g)))}function Dk(a,u,f){var g=Xs();Ou(a,u,f,g)}function Ou(a,u,f,g){var v={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(rp(a))Ok(u,v);else{var C=a.alternate;if(a.lanes===0&&(C===null||C.lanes===0)&&(C=u.lastRenderedReducer,C!==null))try{var I=u.lastRenderedState,O=C(I,f);if(v.hasEagerState=!0,v.eagerState=O,js(O,I))return Pf(a,u,v,0),Oe===null&&Lf(),!1}catch{}if(f=fy(a,u,v,g),f!==null)return Rs(f,a,g),Mk(f,u,g),!0}return!1}function Yy(a,u,f,g){if(g={lane:2,revertLane:Ib(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},rp(a)){if(u)throw Error(s(479))}else u=fy(a,f,g,2),u!==null&&Rs(u,a,2)}function rp(a){var u=a.alternate;return a===Kt||u!==null&&u===Kt}function Ok(a,u){jl=Zf=!0;var f=a.pending;f===null?u.next=u:(u.next=f.next,f.next=u),a.pending=u}function Mk(a,u,f){if((f&4194048)!==0){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,BC(a,f)}}var Mu={readContext:Gn,use:tp,useCallback:Je,useContext:Je,useEffect:Je,useImperativeHandle:Je,useLayoutEffect:Je,useInsertionEffect:Je,useMemo:Je,useReducer:Je,useRef:Je,useState:Je,useDebugValue:Je,useDeferredValue:Je,useTransition:Je,useSyncExternalStore:Je,useId:Je,useHostTransitionStatus:Je,useFormState:Je,useActionState:Je,useOptimistic:Je,useMemoCache:Je,useCacheRefresh:Je};Mu.useEffectEvent=Je;var Fk={readContext:Gn,use:tp,useCallback:function(a,u){return ms().memoizedState=[a,u===void 0?null:u],a},useContext:Gn,useEffect:xk,useImperativeHandle:function(a,u,f){f=f!=null?f.concat([a]):null,np(4194308,4,Ck.bind(null,u,a),f)},useLayoutEffect:function(a,u){return np(4194308,4,a,u)},useInsertionEffect:function(a,u){np(4,2,a,u)},useMemo:function(a,u){var f=ms();u=u===void 0?null:u;var g=a();if(xa){Qr(!0);try{a()}finally{Qr(!1)}}return f.memoizedState=[g,u],g},useReducer:function(a,u,f){var g=ms();if(f!==void 0){var v=f(u);if(xa){Qr(!0);try{f(u)}finally{Qr(!1)}}}else v=u;return g.memoizedState=g.baseState=v,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:v},g.queue=a,a=a.dispatch=vz.bind(null,Kt,a),[g.memoizedState,a]},useRef:function(a){var u=ms();return a={current:a},u.memoizedState=a},useState:function(a){a=jy(a);var u=a.queue,f=Dk.bind(null,Kt,u);return u.dispatch=f,[a.memoizedState,f]},useDebugValue:Hy,useDeferredValue:function(a,u){var f=ms();return qy(f,a,u)},useTransition:function(){var a=jy(!1);return a=Ik.bind(null,Kt,a.queue,!0,!1),ms().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,u,f){var g=Kt,v=ms();if(ue){if(f===void 0)throw Error(s(407));f=f()}else{if(f=u(),Oe===null)throw Error(s(349));(le&127)!==0||sk(g,u,f)}v.memoizedState=f;var C={value:f,getSnapshot:u};return v.queue=C,xk(ik.bind(null,g,C,a),[a]),g.flags|=2048,Wl(9,{destroy:void 0},rk.bind(null,g,C,f,u),null),f},useId:function(){var a=ms(),u=Oe.identifierPrefix;if(ue){var f=ei,g=ti;f=(g&~(1<<32-Us(g)-1)).toString(32)+f,u="_"+u+"R_"+f,f=Jf++,0<f&&(u+="H"+f.toString(32)),u+="_"}else f=fz++,u="_"+u+"r_"+f.toString(32)+"_";return a.memoizedState=u},useHostTransitionStatus:Xy,useFormState:pk,useActionState:pk,useOptimistic:function(a){var u=ms();u.memoizedState=u.baseState=a;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return u.queue=f,u=Yy.bind(null,Kt,!0,f),f.dispatch=u,[a,u]},useMemoCache:By,useCacheRefresh:function(){return ms().memoizedState=xz.bind(null,Kt)},useEffectEvent:function(a){var u=ms(),f={impl:a};return u.memoizedState=f,function(){if((Se&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},Zy={readContext:Gn,use:tp,useCallback:kk,useContext:Gn,useEffect:Wy,useImperativeHandle:Tk,useInsertionEffect:wk,useLayoutEffect:Sk,useMemo:$k,useReducer:ep,useRef:bk,useState:function(){return ep(Ri)},useDebugValue:Hy,useDeferredValue:function(a,u){var f=un();return Ek(f,Ne.memoizedState,a,u)},useTransition:function(){var a=ep(Ri)[0],u=un().memoizedState;return[typeof a=="boolean"?a:Du(a),u]},useSyncExternalStore:nk,useId:_k,useHostTransitionStatus:Xy,useFormState:mk,useActionState:mk,useOptimistic:function(a,u){var f=un();return lk(f,Ne,a,u)},useMemoCache:By,useCacheRefresh:Rk};Zy.useEffectEvent=vk;var Lk={readContext:Gn,use:tp,useCallback:kk,useContext:Gn,useEffect:Wy,useImperativeHandle:Tk,useInsertionEffect:wk,useLayoutEffect:Sk,useMemo:$k,useReducer:Uy,useRef:bk,useState:function(){return Uy(Ri)},useDebugValue:Hy,useDeferredValue:function(a,u){var f=un();return Ne===null?qy(f,a,u):Ek(f,Ne.memoizedState,a,u)},useTransition:function(){var a=Uy(Ri)[0],u=un().memoizedState;return[typeof a=="boolean"?a:Du(a),u]},useSyncExternalStore:nk,useId:_k,useHostTransitionStatus:Xy,useFormState:yk,useActionState:yk,useOptimistic:function(a,u){var f=un();return Ne!==null?lk(f,Ne,a,u):(f.baseState=a,[a,f.queue.dispatch])},useMemoCache:By,useCacheRefresh:Rk};Lk.useEffectEvent=vk;function Jy(a,u,f,g){u=a.memoizedState,f=f(g,u),f=f==null?u:p({},u,f),a.memoizedState=f,a.lanes===0&&(a.updateQueue.baseState=f)}var Qy={enqueueSetState:function(a,u,f){a=a._reactInternals;var g=Xs(),v=uo(g);v.payload=u,f!=null&&(v.callback=f),u=ho(a,v,g),u!==null&&(Rs(u,a,g),Nu(u,a,g))},enqueueReplaceState:function(a,u,f){a=a._reactInternals;var g=Xs(),v=uo(g);v.tag=1,v.payload=u,f!=null&&(v.callback=f),u=ho(a,v,g),u!==null&&(Rs(u,a,g),Nu(u,a,g))},enqueueForceUpdate:function(a,u){a=a._reactInternals;var f=Xs(),g=uo(f);g.tag=2,u!=null&&(g.callback=u),u=ho(a,g,f),u!==null&&(Rs(u,a,f),Nu(u,a,f))}};function Pk(a,u,f,g,v,C,I){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(g,C,I):u.prototype&&u.prototype.isPureReactComponent?!wu(f,g)||!wu(v,C):!0}function zk(a,u,f,g){a=u.state,typeof u.componentWillReceiveProps=="function"&&u.componentWillReceiveProps(f,g),typeof u.UNSAFE_componentWillReceiveProps=="function"&&u.UNSAFE_componentWillReceiveProps(f,g),u.state!==a&&Qy.enqueueReplaceState(u,u.state,null)}function va(a,u){var f=u;if("ref"in u){f={};for(var g in u)g!=="ref"&&(f[g]=u[g])}if(a=a.defaultProps){f===u&&(f=p({},f));for(var v in a)f[v]===void 0&&(f[v]=a[v])}return f}function Bk(a){Ff(a)}function Vk(a){console.error(a)}function Uk(a){Ff(a)}function ip(a,u){try{var f=a.onUncaughtError;f(u.value,{componentStack:u.stack})}catch(g){setTimeout(function(){throw g})}}function jk(a,u,f){try{var g=a.onCaughtError;g(f.value,{componentStack:f.stack,errorBoundary:u.tag===1?u.stateNode:null})}catch(v){setTimeout(function(){throw v})}}function tb(a,u,f){return f=uo(f),f.tag=3,f.payload={element:null},f.callback=function(){ip(a,u)},f}function Gk(a){return a=uo(a),a.tag=3,a}function Wk(a,u,f,g){var v=f.type.getDerivedStateFromError;if(typeof v=="function"){var C=g.value;a.payload=function(){return v(C)},a.callback=function(){jk(u,f,g)}}var I=f.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(a.callback=function(){jk(u,f,g),typeof v!="function"&&(bo===null?bo=new Set([this]):bo.add(this));var O=g.stack;this.componentDidCatch(g.value,{componentStack:O!==null?O:""})})}function wz(a,u,f,g,v){if(f.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(u=f.alternate,u!==null&&Ll(u,f,v,!0),f=Ws.current,f!==null){switch(f.tag){case 31:case 13:return fr===null?yp():f.alternate===null&&Qe===0&&(Qe=3),f.flags&=-257,f.flags|=65536,f.lanes=v,g===Hf?f.flags|=16384:(u=f.updateQueue,u===null?f.updateQueue=new Set([g]):u.add(g),kb(a,g,v)),!1;case 22:return f.flags|=65536,g===Hf?f.flags|=16384:(u=f.updateQueue,u===null?(u={transitions:null,markerInstances:null,retryQueue:new Set([g])},f.updateQueue=u):(f=u.retryQueue,f===null?u.retryQueue=new Set([g]):f.add(g)),kb(a,g,v)),!1}throw Error(s(435,f.tag))}return kb(a,g,v),yp(),!1}if(ue)return u=Ws.current,u!==null?((u.flags&65536)===0&&(u.flags|=256),u.flags|=65536,u.lanes=v,g!==xy&&(a=Error(s(422),{cause:g}),Tu(cr(a,f)))):(g!==xy&&(u=Error(s(423),{cause:g}),Tu(cr(u,f))),a=a.current.alternate,a.flags|=65536,v&=-v,a.lanes|=v,g=cr(g,f),v=tb(a.stateNode,g,v),Ay(a,v),Qe!==4&&(Qe=2)),!1;var C=Error(s(520),{cause:g});if(C=cr(C,f),ju===null?ju=[C]:ju.push(C),Qe!==4&&(Qe=2),u===null)return!0;g=cr(g,f),f=u;do{switch(f.tag){case 3:return f.flags|=65536,a=v&-v,f.lanes|=a,a=tb(f.stateNode,g,a),Ay(f,a),!1;case 1:if(u=f.type,C=f.stateNode,(f.flags&128)===0&&(typeof u.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(bo===null||!bo.has(C))))return f.flags|=65536,v&=-v,f.lanes|=v,v=Gk(v),Wk(v,a,f,g),Ay(f,v),!1}f=f.return}while(f!==null);return!1}var eb=Error(s(461)),mn=!1;function Wn(a,u,f,g){u.child=a===null?XT(u,null,f,g):ba(u,a.child,f,g)}function Hk(a,u,f,g,v){f=f.render;var C=u.ref;if("ref"in g){var I={};for(var O in g)O!=="ref"&&(I[O]=g[O])}else I=g;return pa(u),g=Fy(a,u,f,I,C,v),O=Ly(),a!==null&&!mn?(Py(a,u,v),Di(a,u,v)):(ue&&O&&yy(u),u.flags|=1,Wn(a,u,g,v),u.child)}function qk(a,u,f,g,v){if(a===null){var C=f.type;return typeof C=="function"&&!py(C)&&C.defaultProps===void 0&&f.compare===null?(u.tag=15,u.type=C,Kk(a,u,C,g,v)):(a=Bf(f.type,null,g,u,u.mode,v),a.ref=u.ref,a.return=u,u.child=a)}if(C=a.child,!cb(a,v)){var I=C.memoizedProps;if(f=f.compare,f=f!==null?f:wu,f(I,g)&&a.ref===u.ref)return Di(a,u,v)}return u.flags|=1,a=Ei(C,g),a.ref=u.ref,a.return=u,u.child=a}function Kk(a,u,f,g,v){if(a!==null){var C=a.memoizedProps;if(wu(C,g)&&a.ref===u.ref)if(mn=!1,u.pendingProps=g=C,cb(a,v))(a.flags&131072)!==0&&(mn=!0);else return u.lanes=a.lanes,Di(a,u,v)}return nb(a,u,f,g,v)}function Xk(a,u,f,g){var v=g.children,C=a!==null?a.memoizedState:null;if(a===null&&u.stateNode===null&&(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((u.flags&128)!==0){if(C=C!==null?C.baseLanes|f:f,a!==null){for(g=u.child=a.child,v=0;g!==null;)v=v|g.lanes|g.childLanes,g=g.sibling;g=v&~C}else g=0,u.child=null;return Yk(a,u,C,f,g)}if((f&536870912)!==0)u.memoizedState={baseLanes:0,cachePool:null},a!==null&&Gf(u,C!==null?C.cachePool:null),C!==null?JT(u,C):Ry(),QT(u);else return g=u.lanes=536870912,Yk(a,u,C!==null?C.baseLanes|f:f,f,g)}else C!==null?(Gf(u,C.cachePool),JT(u,C),po(),u.memoizedState=null):(a!==null&&Gf(u,null),Ry(),po());return Wn(a,u,v,f),u.child}function Fu(a,u){return a!==null&&a.tag===22||u.stateNode!==null||(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),u.sibling}function Yk(a,u,f,g,v){var C=$y();return C=C===null?null:{parent:fn._currentValue,pool:C},u.memoizedState={baseLanes:f,cachePool:C},a!==null&&Gf(u,null),Ry(),QT(u),a!==null&&Ll(a,u,g,!0),u.childLanes=v,null}function op(a,u){return u=lp({mode:u.mode,children:u.children},a.mode),u.ref=a.ref,a.child=u,u.return=a,u}function Zk(a,u,f){return ba(u,a.child,null,f),a=op(u,u.pendingProps),a.flags|=2,Hs(u),u.memoizedState=null,a}function Sz(a,u,f){var g=u.pendingProps,v=(u.flags&128)!==0;if(u.flags&=-129,a===null){if(ue){if(g.mode==="hidden")return a=op(u,g),u.lanes=536870912,Fu(null,a);if(Oy(u),(a=Ve)?(a=c$(a,dr),a=a!==null&&a.data==="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:io!==null?{id:ti,overflow:ei}:null,retryLane:536870912,hydrationErrors:null},f=OT(a),f.return=u,u.child=f,jn=u,Ve=null)):a=null,a===null)throw ao(u);return u.lanes=536870912,null}return op(u,g)}var C=a.memoizedState;if(C!==null){var I=C.dehydrated;if(Oy(u),v)if(u.flags&256)u.flags&=-257,u=Zk(a,u,f);else if(u.memoizedState!==null)u.child=a.child,u.flags|=128,u=null;else throw Error(s(558));else if(mn||Ll(a,u,f,!1),v=(f&a.childLanes)!==0,mn||v){if(g=Oe,g!==null&&(I=VC(g,f),I!==0&&I!==C.retryLane))throw C.retryLane=I,ua(a,I),Rs(g,a,I),eb;yp(),u=Zk(a,u,f)}else a=C.treeContext,Ve=pr(I.nextSibling),jn=u,ue=!0,oo=null,dr=!1,a!==null&&LT(u,a),u=op(u,g),u.flags|=4096;return u}return a=Ei(a.child,{mode:g.mode,children:g.children}),a.ref=u.ref,u.child=a,a.return=u,a}function ap(a,u){var f=u.ref;if(f===null)a!==null&&a.ref!==null&&(u.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(a===null||a.ref!==f)&&(u.flags|=4194816)}}function nb(a,u,f,g,v){return pa(u),f=Fy(a,u,f,g,void 0,v),g=Ly(),a!==null&&!mn?(Py(a,u,v),Di(a,u,v)):(ue&&g&&yy(u),u.flags|=1,Wn(a,u,f,v),u.child)}function Jk(a,u,f,g,v,C){return pa(u),u.updateQueue=null,f=ek(u,g,f,v),tk(a),g=Ly(),a!==null&&!mn?(Py(a,u,C),Di(a,u,C)):(ue&&g&&yy(u),u.flags|=1,Wn(a,u,f,C),u.child)}function Qk(a,u,f,g,v){if(pa(u),u.stateNode===null){var C=Dl,I=f.contextType;typeof I=="object"&&I!==null&&(C=Gn(I)),C=new f(g,C),u.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,C.updater=Qy,u.stateNode=C,C._reactInternals=u,C=u.stateNode,C.props=g,C.state=u.memoizedState,C.refs={},Iy(u),I=f.contextType,C.context=typeof I=="object"&&I!==null?Gn(I):Dl,C.state=u.memoizedState,I=f.getDerivedStateFromProps,typeof I=="function"&&(Jy(u,f,I,g),C.state=u.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(I=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),I!==C.state&&Qy.enqueueReplaceState(C,C.state,null),_u(u,g,C,v),Au(),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!0}else if(a===null){C=u.stateNode;var O=u.memoizedProps,j=va(f,O);C.props=j;var at=C.context,mt=f.contextType;I=Dl,typeof mt=="object"&&mt!==null&&(I=Gn(mt));var bt=f.getDerivedStateFromProps;mt=typeof bt=="function"||typeof C.getSnapshotBeforeUpdate=="function",O=u.pendingProps!==O,mt||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(O||at!==I)&&zk(u,C,g,I),co=!1;var ut=u.memoizedState;C.state=ut,_u(u,g,C,v),Au(),at=u.memoizedState,O||ut!==at||co?(typeof bt=="function"&&(Jy(u,f,bt,g),at=u.memoizedState),(j=co||Pk(u,f,j,g,ut,at,I))?(mt||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount()),typeof C.componentDidMount=="function"&&(u.flags|=4194308)):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),u.memoizedProps=g,u.memoizedState=at),C.props=g,C.state=at,C.context=I,g=j):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!1)}else{C=u.stateNode,Ny(a,u),I=u.memoizedProps,mt=va(f,I),C.props=mt,bt=u.pendingProps,ut=C.context,at=f.contextType,j=Dl,typeof at=="object"&&at!==null&&(j=Gn(at)),O=f.getDerivedStateFromProps,(at=typeof O=="function"||typeof C.getSnapshotBeforeUpdate=="function")||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(I!==bt||ut!==j)&&zk(u,C,g,j),co=!1,ut=u.memoizedState,C.state=ut,_u(u,g,C,v),Au();var ht=u.memoizedState;I!==bt||ut!==ht||co||a!==null&&a.dependencies!==null&&Uf(a.dependencies)?(typeof O=="function"&&(Jy(u,f,O,g),ht=u.memoizedState),(mt=co||Pk(u,f,mt,g,ut,ht,j)||a!==null&&a.dependencies!==null&&Uf(a.dependencies))?(at||typeof C.UNSAFE_componentWillUpdate!="function"&&typeof C.componentWillUpdate!="function"||(typeof C.componentWillUpdate=="function"&&C.componentWillUpdate(g,ht,j),typeof C.UNSAFE_componentWillUpdate=="function"&&C.UNSAFE_componentWillUpdate(g,ht,j)),typeof C.componentDidUpdate=="function"&&(u.flags|=4),typeof C.getSnapshotBeforeUpdate=="function"&&(u.flags|=1024)):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=1024),u.memoizedProps=g,u.memoizedState=ht),C.props=g,C.state=ht,C.context=j,g=mt):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&ut===a.memoizedState||(u.flags|=1024),g=!1)}return C=g,ap(a,u),g=(u.flags&128)!==0,C||g?(C=u.stateNode,f=g&&typeof f.getDerivedStateFromError!="function"?null:C.render(),u.flags|=1,a!==null&&g?(u.child=ba(u,a.child,null,v),u.child=ba(u,null,f,v)):Wn(a,u,f,v),u.memoizedState=C.state,a=u.child):a=Di(a,u,v),a}function t2(a,u,f,g){return da(),u.flags|=256,Wn(a,u,f,g),u.child}var sb={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function rb(a){return{baseLanes:a,cachePool:jT()}}function ib(a,u,f){return a=a!==null?a.childLanes&~f:0,u&&(a|=Ks),a}function e2(a,u,f){var g=u.pendingProps,v=!1,C=(u.flags&128)!==0,I;if((I=C)||(I=a!==null&&a.memoizedState===null?!1:(cn.current&2)!==0),I&&(v=!0,u.flags&=-129),I=(u.flags&32)!==0,u.flags&=-33,a===null){if(ue){if(v?fo(u):po(),(a=Ve)?(a=c$(a,dr),a=a!==null&&a.data!=="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:io!==null?{id:ti,overflow:ei}:null,retryLane:536870912,hydrationErrors:null},f=OT(a),f.return=u,u.child=f,jn=u,Ve=null)):a=null,a===null)throw ao(u);return Vb(a)?u.lanes=32:u.lanes=536870912,null}var O=g.children;return g=g.fallback,v?(po(),v=u.mode,O=lp({mode:"hidden",children:O},v),g=ha(g,v,f,null),O.return=u,g.return=u,O.sibling=g,u.child=O,g=u.child,g.memoizedState=rb(f),g.childLanes=ib(a,I,f),u.memoizedState=sb,Fu(null,g)):(fo(u),ob(u,O))}var j=a.memoizedState;if(j!==null&&(O=j.dehydrated,O!==null)){if(C)u.flags&256?(fo(u),u.flags&=-257,u=ab(a,u,f)):u.memoizedState!==null?(po(),u.child=a.child,u.flags|=128,u=null):(po(),O=g.fallback,v=u.mode,g=lp({mode:"visible",children:g.children},v),O=ha(O,v,f,null),O.flags|=2,g.return=u,O.return=u,g.sibling=O,u.child=g,ba(u,a.child,null,f),g=u.child,g.memoizedState=rb(f),g.childLanes=ib(a,I,f),u.memoizedState=sb,u=Fu(null,g));else if(fo(u),Vb(O)){if(I=O.nextSibling&&O.nextSibling.dataset,I)var at=I.dgst;I=at,g=Error(s(419)),g.stack="",g.digest=I,Tu({value:g,source:null,stack:null}),u=ab(a,u,f)}else if(mn||Ll(a,u,f,!1),I=(f&a.childLanes)!==0,mn||I){if(I=Oe,I!==null&&(g=VC(I,f),g!==0&&g!==j.retryLane))throw j.retryLane=g,ua(a,g),Rs(I,a,g),eb;Bb(O)||yp(),u=ab(a,u,f)}else Bb(O)?(u.flags|=192,u.child=a.child,u=null):(a=j.treeContext,Ve=pr(O.nextSibling),jn=u,ue=!0,oo=null,dr=!1,a!==null&&LT(u,a),u=ob(u,g.children),u.flags|=4096);return u}return v?(po(),O=g.fallback,v=u.mode,j=a.child,at=j.sibling,g=Ei(j,{mode:"hidden",children:g.children}),g.subtreeFlags=j.subtreeFlags&65011712,at!==null?O=Ei(at,O):(O=ha(O,v,f,null),O.flags|=2),O.return=u,g.return=u,g.sibling=O,u.child=g,Fu(null,g),g=u.child,O=a.child.memoizedState,O===null?O=rb(f):(v=O.cachePool,v!==null?(j=fn._currentValue,v=v.parent!==j?{parent:j,pool:j}:v):v=jT(),O={baseLanes:O.baseLanes|f,cachePool:v}),g.memoizedState=O,g.childLanes=ib(a,I,f),u.memoizedState=sb,Fu(a.child,g)):(fo(u),f=a.child,a=f.sibling,f=Ei(f,{mode:"visible",children:g.children}),f.return=u,f.sibling=null,a!==null&&(I=u.deletions,I===null?(u.deletions=[a],u.flags|=16):I.push(a)),u.child=f,u.memoizedState=null,f)}function ob(a,u){return u=lp({mode:"visible",children:u},a.mode),u.return=a,a.child=u}function lp(a,u){return a=Gs(22,a,null,u),a.lanes=0,a}function ab(a,u,f){return ba(u,a.child,null,f),a=ob(u,u.pendingProps.children),a.flags|=2,u.memoizedState=null,a}function n2(a,u,f){a.lanes|=u;var g=a.alternate;g!==null&&(g.lanes|=u),Sy(a.return,u,f)}function lb(a,u,f,g,v,C){var I=a.memoizedState;I===null?a.memoizedState={isBackwards:u,rendering:null,renderingStartTime:0,last:g,tail:f,tailMode:v,treeForkCount:C}:(I.isBackwards=u,I.rendering=null,I.renderingStartTime=0,I.last=g,I.tail=f,I.tailMode=v,I.treeForkCount=C)}function s2(a,u,f){var g=u.pendingProps,v=g.revealOrder,C=g.tail;g=g.children;var I=cn.current,O=(I&2)!==0;if(O?(I=I&1|2,u.flags|=128):I&=1,Q(cn,I),Wn(a,u,g,f),g=ue?Cu:0,!O&&a!==null&&(a.flags&128)!==0)t:for(a=u.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&n2(a,f,u);else if(a.tag===19)n2(a,f,u);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===u)break t;for(;a.sibling===null;){if(a.return===null||a.return===u)break t;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(v){case"forwards":for(f=u.child,v=null;f!==null;)a=f.alternate,a!==null&&Yf(a)===null&&(v=f),f=f.sibling;f=v,f===null?(v=u.child,u.child=null):(v=f.sibling,f.sibling=null),lb(u,!1,v,f,C,g);break;case"backwards":case"unstable_legacy-backwards":for(f=null,v=u.child,u.child=null;v!==null;){if(a=v.alternate,a!==null&&Yf(a)===null){u.child=v;break}a=v.sibling,v.sibling=f,f=v,v=a}lb(u,!0,f,null,C,g);break;case"together":lb(u,!1,null,null,void 0,g);break;default:u.memoizedState=null}return u.child}function Di(a,u,f){if(a!==null&&(u.dependencies=a.dependencies),yo|=u.lanes,(f&u.childLanes)===0)if(a!==null){if(Ll(a,u,f,!1),(f&u.childLanes)===0)return null}else return null;if(a!==null&&u.child!==a.child)throw Error(s(153));if(u.child!==null){for(a=u.child,f=Ei(a,a.pendingProps),u.child=f,f.return=u;a.sibling!==null;)a=a.sibling,f=f.sibling=Ei(a,a.pendingProps),f.return=u;f.sibling=null}return u.child}function cb(a,u){return(a.lanes&u)!==0?!0:(a=a.dependencies,!!(a!==null&&Uf(a)))}function Cz(a,u,f){switch(u.tag){case 3:kt(u,u.stateNode.containerInfo),lo(u,fn,a.memoizedState.cache),da();break;case 27:case 5:Ot(u);break;case 4:kt(u,u.stateNode.containerInfo);break;case 10:lo(u,u.type,u.memoizedProps.value);break;case 31:if(u.memoizedState!==null)return u.flags|=128,Oy(u),null;break;case 13:var g=u.memoizedState;if(g!==null)return g.dehydrated!==null?(fo(u),u.flags|=128,null):(f&u.child.childLanes)!==0?e2(a,u,f):(fo(u),a=Di(a,u,f),a!==null?a.sibling:null);fo(u);break;case 19:var v=(a.flags&128)!==0;if(g=(f&u.childLanes)!==0,g||(Ll(a,u,f,!1),g=(f&u.childLanes)!==0),v){if(g)return s2(a,u,f);u.flags|=128}if(v=u.memoizedState,v!==null&&(v.rendering=null,v.tail=null,v.lastEffect=null),Q(cn,cn.current),g)break;return null;case 22:return u.lanes=0,Xk(a,u,f,u.pendingProps);case 24:lo(u,fn,a.memoizedState.cache)}return Di(a,u,f)}function r2(a,u,f){if(a!==null)if(a.memoizedProps!==u.pendingProps)mn=!0;else{if(!cb(a,f)&&(u.flags&128)===0)return mn=!1,Cz(a,u,f);mn=(a.flags&131072)!==0}else mn=!1,ue&&(u.flags&1048576)!==0&&FT(u,Cu,u.index);switch(u.lanes=0,u.tag){case 16:t:{var g=u.pendingProps;if(a=ga(u.elementType),u.type=a,typeof a=="function")py(a)?(g=va(a,g),u.tag=1,u=Qk(null,u,a,g,f)):(u.tag=0,u=nb(null,u,a,g,f));else{if(a!=null){var v=a.$$typeof;if(v===$){u.tag=11,u=Hk(null,u,a,g,f);break t}else if(v===_){u.tag=14,u=qk(null,u,a,g,f);break t}}throw u=W(a)||a,Error(s(306,u,""))}}return u;case 0:return nb(a,u,u.type,u.pendingProps,f);case 1:return g=u.type,v=va(g,u.pendingProps),Qk(a,u,g,v,f);case 3:t:{if(kt(u,u.stateNode.containerInfo),a===null)throw Error(s(387));g=u.pendingProps;var C=u.memoizedState;v=C.element,Ny(a,u),_u(u,g,null,f);var I=u.memoizedState;if(g=I.cache,lo(u,fn,g),g!==C.cache&&Cy(u,[fn],f,!0),Au(),g=I.element,C.isDehydrated)if(C={element:g,isDehydrated:!1,cache:I.cache},u.updateQueue.baseState=C,u.memoizedState=C,u.flags&256){u=t2(a,u,g,f);break t}else if(g!==v){v=cr(Error(s(424)),u),Tu(v),u=t2(a,u,g,f);break t}else for(a=u.stateNode.containerInfo,a.nodeType===9?a=a.body:a=a.nodeName==="HTML"?a.ownerDocument.body:a,Ve=pr(a.firstChild),jn=u,ue=!0,oo=null,dr=!0,f=XT(u,null,g,f),u.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(da(),g===v){u=Di(a,u,f);break t}Wn(a,u,g,f)}u=u.child}return u;case 26:return ap(a,u),a===null?(f=m$(u.type,null,u.pendingProps,null))?u.memoizedState=f:ue||(f=u.type,a=u.pendingProps,g=Tp(gt.current).createElement(f),g[Un]=u,g[$s]=a,Hn(g,f,a),Mn(g),u.stateNode=g):u.memoizedState=m$(u.type,a.memoizedProps,u.pendingProps,a.memoizedState),null;case 27:return Ot(u),a===null&&ue&&(g=u.stateNode=d$(u.type,u.pendingProps,gt.current),jn=u,dr=!0,v=Ve,So(u.type)?(Ub=v,Ve=pr(g.firstChild)):Ve=v),Wn(a,u,u.pendingProps.children,f),ap(a,u),a===null&&(u.flags|=4194304),u.child;case 5:return a===null&&ue&&((v=g=Ve)&&(g=Qz(g,u.type,u.pendingProps,dr),g!==null?(u.stateNode=g,jn=u,Ve=pr(g.firstChild),dr=!1,v=!0):v=!1),v||ao(u)),Ot(u),v=u.type,C=u.pendingProps,I=a!==null?a.memoizedProps:null,g=C.children,Lb(v,C)?g=null:I!==null&&Lb(v,I)&&(u.flags|=32),u.memoizedState!==null&&(v=Fy(a,u,pz,null,null,f),Zu._currentValue=v),ap(a,u),Wn(a,u,g,f),u.child;case 6:return a===null&&ue&&((a=f=Ve)&&(f=tB(f,u.pendingProps,dr),f!==null?(u.stateNode=f,jn=u,Ve=null,a=!0):a=!1),a||ao(u)),null;case 13:return e2(a,u,f);case 4:return kt(u,u.stateNode.containerInfo),g=u.pendingProps,a===null?u.child=ba(u,null,g,f):Wn(a,u,g,f),u.child;case 11:return Hk(a,u,u.type,u.pendingProps,f);case 7:return Wn(a,u,u.pendingProps,f),u.child;case 8:return Wn(a,u,u.pendingProps.children,f),u.child;case 12:return Wn(a,u,u.pendingProps.children,f),u.child;case 10:return g=u.pendingProps,lo(u,u.type,g.value),Wn(a,u,g.children,f),u.child;case 9:return v=u.type._context,g=u.pendingProps.children,pa(u),v=Gn(v),g=g(v),u.flags|=1,Wn(a,u,g,f),u.child;case 14:return qk(a,u,u.type,u.pendingProps,f);case 15:return Kk(a,u,u.type,u.pendingProps,f);case 19:return s2(a,u,f);case 31:return Sz(a,u,f);case 22:return Xk(a,u,f,u.pendingProps);case 24:return pa(u),g=Gn(fn),a===null?(v=$y(),v===null&&(v=Oe,C=Ty(),v.pooledCache=C,C.refCount++,C!==null&&(v.pooledCacheLanes|=f),v=C),u.memoizedState={parent:g,cache:v},Iy(u),lo(u,fn,v)):((a.lanes&f)!==0&&(Ny(a,u),_u(u,null,null,f),Au()),v=a.memoizedState,C=u.memoizedState,v.parent!==g?(v={parent:g,cache:g},u.memoizedState=v,u.lanes===0&&(u.memoizedState=u.updateQueue.baseState=v),lo(u,fn,g)):(g=C.cache,lo(u,fn,g),g!==v.cache&&Cy(u,[fn],f,!0))),Wn(a,u,u.pendingProps.children,f),u.child;case 29:throw u.pendingProps}throw Error(s(156,u.tag))}function Oi(a){a.flags|=4}function ub(a,u,f,g,v){if((u=(a.mode&32)!==0)&&(u=!1),u){if(a.flags|=16777216,(v&335544128)===v)if(a.stateNode.complete)a.flags|=8192;else if(_2())a.flags|=8192;else throw ya=Hf,Ey}else a.flags&=-16777217}function i2(a,u){if(u.type!=="stylesheet"||(u.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!v$(u))if(_2())a.flags|=8192;else throw ya=Hf,Ey}function cp(a,u){u!==null&&(a.flags|=4),a.flags&16384&&(u=a.tag!==22?PC():536870912,a.lanes|=u,Xl|=u)}function Lu(a,u){if(!ue)switch(a.tailMode){case"hidden":u=a.tail;for(var f=null;u!==null;)u.alternate!==null&&(f=u),u=u.sibling;f===null?a.tail=null:f.sibling=null;break;case"collapsed":f=a.tail;for(var g=null;f!==null;)f.alternate!==null&&(g=f),f=f.sibling;g===null?u||a.tail===null?a.tail=null:a.tail.sibling=null:g.sibling=null}}function Ue(a){var u=a.alternate!==null&&a.alternate.child===a.child,f=0,g=0;if(u)for(var v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags&65011712,g|=v.flags&65011712,v.return=a,v=v.sibling;else for(v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags,g|=v.flags,v.return=a,v=v.sibling;return a.subtreeFlags|=g,a.childLanes=f,u}function Tz(a,u,f){var g=u.pendingProps;switch(by(u),u.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ue(u),null;case 1:return Ue(u),null;case 3:return f=u.stateNode,g=null,a!==null&&(g=a.memoizedState.cache),u.memoizedState.cache!==g&&(u.flags|=2048),Ai(fn),Ct(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(a===null||a.child===null)&&(Fl(u)?Oi(u):a===null||a.memoizedState.isDehydrated&&(u.flags&256)===0||(u.flags|=1024,vy())),Ue(u),null;case 26:var v=u.type,C=u.memoizedState;return a===null?(Oi(u),C!==null?(Ue(u),i2(u,C)):(Ue(u),ub(u,v,null,g,f))):C?C!==a.memoizedState?(Oi(u),Ue(u),i2(u,C)):(Ue(u),u.flags&=-16777217):(a=a.memoizedProps,a!==g&&Oi(u),Ue(u),ub(u,v,a,g,f)),null;case 27:if(Gt(u),f=gt.current,v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Oi(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return Ue(u),null}a=ct.current,Fl(u)?PT(u):(a=d$(v,g,f),u.stateNode=a,Oi(u))}return Ue(u),null;case 5:if(Gt(u),v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Oi(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return Ue(u),null}if(C=ct.current,Fl(u))PT(u);else{var I=Tp(gt.current);switch(C){case 1:C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":C=I.createElement("div"),C.innerHTML="<script><\/script>",C=C.removeChild(C.firstChild);break;case"select":C=typeof g.is=="string"?I.createElement("select",{is:g.is}):I.createElement("select"),g.multiple?C.multiple=!0:g.size&&(C.size=g.size);break;default:C=typeof g.is=="string"?I.createElement(v,{is:g.is}):I.createElement(v)}}C[Un]=u,C[$s]=g;t:for(I=u.child;I!==null;){if(I.tag===5||I.tag===6)C.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===u)break t;for(;I.sibling===null;){if(I.return===null||I.return===u)break t;I=I.return}I.sibling.return=I.return,I=I.sibling}u.stateNode=C;t:switch(Hn(C,v,g),v){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break t;case"img":g=!0;break t;default:g=!1}g&&Oi(u)}}return Ue(u),ub(u,u.type,a===null?null:a.memoizedProps,u.pendingProps,f),null;case 6:if(a&&u.stateNode!=null)a.memoizedProps!==g&&Oi(u);else{if(typeof g!="string"&&u.stateNode===null)throw Error(s(166));if(a=gt.current,Fl(u)){if(a=u.stateNode,f=u.memoizedProps,g=null,v=jn,v!==null)switch(v.tag){case 27:case 5:g=v.memoizedProps}a[Un]=u,a=!!(a.nodeValue===f||g!==null&&g.suppressHydrationWarning===!0||e$(a.nodeValue,f)),a||ao(u,!0)}else a=Tp(a).createTextNode(g),a[Un]=u,u.stateNode=a}return Ue(u),null;case 31:if(f=u.memoizedState,a===null||a.memoizedState!==null){if(g=Fl(u),f!==null){if(a===null){if(!g)throw Error(s(318));if(a=u.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(557));a[Un]=u}else da(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Ue(u),a=!1}else f=vy(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=f),a=!0;if(!a)return u.flags&256?(Hs(u),u):(Hs(u),null);if((u.flags&128)!==0)throw Error(s(558))}return Ue(u),null;case 13:if(g=u.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(v=Fl(u),g!==null&&g.dehydrated!==null){if(a===null){if(!v)throw Error(s(318));if(v=u.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(s(317));v[Un]=u}else da(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Ue(u),v=!1}else v=vy(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=v),v=!0;if(!v)return u.flags&256?(Hs(u),u):(Hs(u),null)}return Hs(u),(u.flags&128)!==0?(u.lanes=f,u):(f=g!==null,a=a!==null&&a.memoizedState!==null,f&&(g=u.child,v=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(v=g.alternate.memoizedState.cachePool.pool),C=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(C=g.memoizedState.cachePool.pool),C!==v&&(g.flags|=2048)),f!==a&&f&&(u.child.flags|=8192),cp(u,u.updateQueue),Ue(u),null);case 4:return Ct(),a===null&&Rb(u.stateNode.containerInfo),Ue(u),null;case 10:return Ai(u.type),Ue(u),null;case 19:if(z(cn),g=u.memoizedState,g===null)return Ue(u),null;if(v=(u.flags&128)!==0,C=g.rendering,C===null)if(v)Lu(g,!1);else{if(Qe!==0||a!==null&&(a.flags&128)!==0)for(a=u.child;a!==null;){if(C=Yf(a),C!==null){for(u.flags|=128,Lu(g,!1),a=C.updateQueue,u.updateQueue=a,cp(u,a),u.subtreeFlags=0,a=f,f=u.child;f!==null;)DT(f,a),f=f.sibling;return Q(cn,cn.current&1|2),ue&&Ii(u,g.treeForkCount),u.child}a=a.sibling}g.tail!==null&&De()>pp&&(u.flags|=128,v=!0,Lu(g,!1),u.lanes=4194304)}else{if(!v)if(a=Yf(C),a!==null){if(u.flags|=128,v=!0,a=a.updateQueue,u.updateQueue=a,cp(u,a),Lu(g,!0),g.tail===null&&g.tailMode==="hidden"&&!C.alternate&&!ue)return Ue(u),null}else 2*De()-g.renderingStartTime>pp&&f!==536870912&&(u.flags|=128,v=!0,Lu(g,!1),u.lanes=4194304);g.isBackwards?(C.sibling=u.child,u.child=C):(a=g.last,a!==null?a.sibling=C:u.child=C,g.last=C)}return g.tail!==null?(a=g.tail,g.rendering=a,g.tail=a.sibling,g.renderingStartTime=De(),a.sibling=null,f=cn.current,Q(cn,v?f&1|2:f&1),ue&&Ii(u,g.treeForkCount),a):(Ue(u),null);case 22:case 23:return Hs(u),Dy(),g=u.memoizedState!==null,a!==null?a.memoizedState!==null!==g&&(u.flags|=8192):g&&(u.flags|=8192),g?(f&536870912)!==0&&(u.flags&128)===0&&(Ue(u),u.subtreeFlags&6&&(u.flags|=8192)):Ue(u),f=u.updateQueue,f!==null&&cp(u,f.retryQueue),f=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),g=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(g=u.memoizedState.cachePool.pool),g!==f&&(u.flags|=2048),a!==null&&z(ma),null;case 24:return f=null,a!==null&&(f=a.memoizedState.cache),u.memoizedState.cache!==f&&(u.flags|=2048),Ai(fn),Ue(u),null;case 25:return null;case 30:return null}throw Error(s(156,u.tag))}function kz(a,u){switch(by(u),u.tag){case 1:return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 3:return Ai(fn),Ct(),a=u.flags,(a&65536)!==0&&(a&128)===0?(u.flags=a&-65537|128,u):null;case 26:case 27:case 5:return Gt(u),null;case 31:if(u.memoizedState!==null){if(Hs(u),u.alternate===null)throw Error(s(340));da()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 13:if(Hs(u),a=u.memoizedState,a!==null&&a.dehydrated!==null){if(u.alternate===null)throw Error(s(340));da()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 19:return z(cn),null;case 4:return Ct(),null;case 10:return Ai(u.type),null;case 22:case 23:return Hs(u),Dy(),a!==null&&z(ma),a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 24:return Ai(fn),null;case 25:return null;default:return null}}function o2(a,u){switch(by(u),u.tag){case 3:Ai(fn),Ct();break;case 26:case 27:case 5:Gt(u);break;case 4:Ct();break;case 31:u.memoizedState!==null&&Hs(u);break;case 13:Hs(u);break;case 19:z(cn);break;case 10:Ai(u.type);break;case 22:case 23:Hs(u),Dy(),a!==null&&z(ma);break;case 24:Ai(fn)}}function Pu(a,u){try{var f=u.updateQueue,g=f!==null?f.lastEffect:null;if(g!==null){var v=g.next;f=v;do{if((f.tag&a)===a){g=void 0;var C=f.create,I=f.inst;g=C(),I.destroy=g}f=f.next}while(f!==v)}}catch(O){Ee(u,u.return,O)}}function mo(a,u,f){try{var g=u.updateQueue,v=g!==null?g.lastEffect:null;if(v!==null){var C=v.next;g=C;do{if((g.tag&a)===a){var I=g.inst,O=I.destroy;if(O!==void 0){I.destroy=void 0,v=u;var j=f,at=O;try{at()}catch(mt){Ee(v,j,mt)}}}g=g.next}while(g!==C)}}catch(mt){Ee(u,u.return,mt)}}function a2(a){var u=a.updateQueue;if(u!==null){var f=a.stateNode;try{ZT(u,f)}catch(g){Ee(a,a.return,g)}}}function l2(a,u,f){f.props=va(a.type,a.memoizedProps),f.state=a.memoizedState;try{f.componentWillUnmount()}catch(g){Ee(a,u,g)}}function zu(a,u){try{var f=a.ref;if(f!==null){switch(a.tag){case 26:case 27:case 5:var g=a.stateNode;break;case 30:g=a.stateNode;break;default:g=a.stateNode}typeof f=="function"?a.refCleanup=f(g):f.current=g}}catch(v){Ee(a,u,v)}}function ni(a,u){var f=a.ref,g=a.refCleanup;if(f!==null)if(typeof g=="function")try{g()}catch(v){Ee(a,u,v)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(v){Ee(a,u,v)}else f.current=null}function c2(a){var u=a.type,f=a.memoizedProps,g=a.stateNode;try{t:switch(u){case"button":case"input":case"select":case"textarea":f.autoFocus&&g.focus();break t;case"img":f.src?g.src=f.src:f.srcSet&&(g.srcset=f.srcSet)}}catch(v){Ee(a,a.return,v)}}function hb(a,u,f){try{var g=a.stateNode;qz(g,a.type,f,u),g[$s]=u}catch(v){Ee(a,a.return,v)}}function u2(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&So(a.type)||a.tag===4}function db(a){t:for(;;){for(;a.sibling===null;){if(a.return===null||u2(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&So(a.type)||a.flags&2||a.child===null||a.tag===4)continue t;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function fb(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(a,u):(u=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,u.appendChild(a),f=f._reactRootContainer,f!=null||u.onclick!==null||(u.onclick=ki));else if(g!==4&&(g===27&&So(a.type)&&(f=a.stateNode,u=null),a=a.child,a!==null))for(fb(a,u,f),a=a.sibling;a!==null;)fb(a,u,f),a=a.sibling}function up(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?f.insertBefore(a,u):f.appendChild(a);else if(g!==4&&(g===27&&So(a.type)&&(f=a.stateNode),a=a.child,a!==null))for(up(a,u,f),a=a.sibling;a!==null;)up(a,u,f),a=a.sibling}function h2(a){var u=a.stateNode,f=a.memoizedProps;try{for(var g=a.type,v=u.attributes;v.length;)u.removeAttributeNode(v[0]);Hn(u,g,f),u[Un]=a,u[$s]=f}catch(C){Ee(a,a.return,C)}}var Mi=!1,gn=!1,pb=!1,d2=typeof WeakSet=="function"?WeakSet:Set,Fn=null;function $z(a,u){if(a=a.containerInfo,Mb=_p,a=TT(a),ay(a)){if("selectionStart"in a)var f={start:a.selectionStart,end:a.selectionEnd};else t:{f=(f=a.ownerDocument)&&f.defaultView||window;var g=f.getSelection&&f.getSelection();if(g&&g.rangeCount!==0){f=g.anchorNode;var v=g.anchorOffset,C=g.focusNode;g=g.focusOffset;try{f.nodeType,C.nodeType}catch{f=null;break t}var I=0,O=-1,j=-1,at=0,mt=0,bt=a,ut=null;e:for(;;){for(var ht;bt!==f||v!==0&&bt.nodeType!==3||(O=I+v),bt!==C||g!==0&&bt.nodeType!==3||(j=I+g),bt.nodeType===3&&(I+=bt.nodeValue.length),(ht=bt.firstChild)!==null;)ut=bt,bt=ht;for(;;){if(bt===a)break e;if(ut===f&&++at===v&&(O=I),ut===C&&++mt===g&&(j=I),(ht=bt.nextSibling)!==null)break;bt=ut,ut=bt.parentNode}bt=ht}f=O===-1||j===-1?null:{start:O,end:j}}else f=null}f=f||{start:0,end:0}}else f=null;for(Fb={focusedElem:a,selectionRange:f},_p=!1,Fn=u;Fn!==null;)if(u=Fn,a=u.child,(u.subtreeFlags&1028)!==0&&a!==null)a.return=u,Fn=a;else for(;Fn!==null;){switch(u=Fn,C=u.alternate,a=u.flags,u.tag){case 0:if((a&4)!==0&&(a=u.updateQueue,a=a!==null?a.events:null,a!==null))for(f=0;f<a.length;f++)v=a[f],v.ref.impl=v.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&C!==null){a=void 0,f=u,v=C.memoizedProps,C=C.memoizedState,g=f.stateNode;try{var It=va(f.type,v);a=g.getSnapshotBeforeUpdate(It,C),g.__reactInternalSnapshotBeforeUpdate=a}catch(zt){Ee(f,f.return,zt)}}break;case 3:if((a&1024)!==0){if(a=u.stateNode.containerInfo,f=a.nodeType,f===9)zb(a);else if(f===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":zb(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(s(163))}if(a=u.sibling,a!==null){a.return=u.return,Fn=a;break}Fn=u.return}}function f2(a,u,f){var g=f.flags;switch(f.tag){case 0:case 11:case 15:Li(a,f),g&4&&Pu(5,f);break;case 1:if(Li(a,f),g&4)if(a=f.stateNode,u===null)try{a.componentDidMount()}catch(I){Ee(f,f.return,I)}else{var v=va(f.type,u.memoizedProps);u=u.memoizedState;try{a.componentDidUpdate(v,u,a.__reactInternalSnapshotBeforeUpdate)}catch(I){Ee(f,f.return,I)}}g&64&&a2(f),g&512&&zu(f,f.return);break;case 3:if(Li(a,f),g&64&&(a=f.updateQueue,a!==null)){if(u=null,f.child!==null)switch(f.child.tag){case 27:case 5:u=f.child.stateNode;break;case 1:u=f.child.stateNode}try{ZT(a,u)}catch(I){Ee(f,f.return,I)}}break;case 27:u===null&&g&4&&h2(f);case 26:case 5:Li(a,f),u===null&&g&4&&c2(f),g&512&&zu(f,f.return);break;case 12:Li(a,f);break;case 31:Li(a,f),g&4&&g2(a,f);break;case 13:Li(a,f),g&4&&y2(a,f),g&64&&(a=f.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(f=Mz.bind(null,f),eB(a,f))));break;case 22:if(g=f.memoizedState!==null||Mi,!g){u=u!==null&&u.memoizedState!==null||gn,v=Mi;var C=gn;Mi=g,(gn=u)&&!C?Pi(a,f,(f.subtreeFlags&8772)!==0):Li(a,f),Mi=v,gn=C}break;case 30:break;default:Li(a,f)}}function p2(a){var u=a.alternate;u!==null&&(a.alternate=null,p2(u)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(u=a.stateNode,u!==null&&G0(u)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var He=null,Is=!1;function Fi(a,u,f){for(f=f.child;f!==null;)m2(a,u,f),f=f.sibling}function m2(a,u,f){if(Be&&typeof Be.onCommitFiberUnmount=="function")try{Be.onCommitFiberUnmount(ns,f)}catch{}switch(f.tag){case 26:gn||ni(f,u),Fi(a,u,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:gn||ni(f,u);var g=He,v=Is;So(f.type)&&(He=f.stateNode,Is=!1),Fi(a,u,f),Ku(f.stateNode),He=g,Is=v;break;case 5:gn||ni(f,u);case 6:if(g=He,v=Is,He=null,Fi(a,u,f),He=g,Is=v,He!==null)if(Is)try{(He.nodeType===9?He.body:He.nodeName==="HTML"?He.ownerDocument.body:He).removeChild(f.stateNode)}catch(C){Ee(f,u,C)}else try{He.removeChild(f.stateNode)}catch(C){Ee(f,u,C)}break;case 18:He!==null&&(Is?(a=He,a$(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,f.stateNode),sc(a)):a$(He,f.stateNode));break;case 4:g=He,v=Is,He=f.stateNode.containerInfo,Is=!0,Fi(a,u,f),He=g,Is=v;break;case 0:case 11:case 14:case 15:mo(2,f,u),gn||mo(4,f,u),Fi(a,u,f);break;case 1:gn||(ni(f,u),g=f.stateNode,typeof g.componentWillUnmount=="function"&&l2(f,u,g)),Fi(a,u,f);break;case 21:Fi(a,u,f);break;case 22:gn=(g=gn)||f.memoizedState!==null,Fi(a,u,f),gn=g;break;default:Fi(a,u,f)}}function g2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{sc(a)}catch(f){Ee(u,u.return,f)}}}function y2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{sc(a)}catch(f){Ee(u,u.return,f)}}function Ez(a){switch(a.tag){case 31:case 13:case 19:var u=a.stateNode;return u===null&&(u=a.stateNode=new d2),u;case 22:return a=a.stateNode,u=a._retryCache,u===null&&(u=a._retryCache=new d2),u;default:throw Error(s(435,a.tag))}}function hp(a,u){var f=Ez(a);u.forEach(function(g){if(!f.has(g)){f.add(g);var v=Fz.bind(null,a,g);g.then(v,v)}})}function Ns(a,u){var f=u.deletions;if(f!==null)for(var g=0;g<f.length;g++){var v=f[g],C=a,I=u,O=I;t:for(;O!==null;){switch(O.tag){case 27:if(So(O.type)){He=O.stateNode,Is=!1;break t}break;case 5:He=O.stateNode,Is=!1;break t;case 3:case 4:He=O.stateNode.containerInfo,Is=!0;break t}O=O.return}if(He===null)throw Error(s(160));m2(C,I,v),He=null,Is=!1,C=v.alternate,C!==null&&(C.return=null),v.return=null}if(u.subtreeFlags&13886)for(u=u.child;u!==null;)b2(u,a),u=u.sibling}var Or=null;function b2(a,u){var f=a.alternate,g=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:Ns(u,a),As(a),g&4&&(mo(3,a,a.return),Pu(3,a),mo(5,a,a.return));break;case 1:Ns(u,a),As(a),g&512&&(gn||f===null||ni(f,f.return)),g&64&&Mi&&(a=a.updateQueue,a!==null&&(g=a.callbacks,g!==null&&(f=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=f===null?g:f.concat(g))));break;case 26:var v=Or;if(Ns(u,a),As(a),g&512&&(gn||f===null||ni(f,f.return)),g&4){var C=f!==null?f.memoizedState:null;if(g=a.memoizedState,f===null)if(g===null)if(a.stateNode===null){t:{g=a.type,f=a.memoizedProps,v=v.ownerDocument||v;e:switch(g){case"title":C=v.getElementsByTagName("title")[0],(!C||C[du]||C[Un]||C.namespaceURI==="http://www.w3.org/2000/svg"||C.hasAttribute("itemprop"))&&(C=v.createElement(g),v.head.insertBefore(C,v.querySelector("head > title"))),Hn(C,g,f),C[Un]=a,Mn(C),g=C;break t;case"link":var I=b$("link","href",v).get(g+(f.href||""));if(I){for(var O=0;O<I.length;O++)if(C=I[O],C.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&C.getAttribute("rel")===(f.rel==null?null:f.rel)&&C.getAttribute("title")===(f.title==null?null:f.title)&&C.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){I.splice(O,1);break e}}C=v.createElement(g),Hn(C,g,f),v.head.appendChild(C);break;case"meta":if(I=b$("meta","content",v).get(g+(f.content||""))){for(O=0;O<I.length;O++)if(C=I[O],C.getAttribute("content")===(f.content==null?null:""+f.content)&&C.getAttribute("name")===(f.name==null?null:f.name)&&C.getAttribute("property")===(f.property==null?null:f.property)&&C.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&C.getAttribute("charset")===(f.charSet==null?null:f.charSet)){I.splice(O,1);break e}}C=v.createElement(g),Hn(C,g,f),v.head.appendChild(C);break;default:throw Error(s(468,g))}C[Un]=a,Mn(C),g=C}a.stateNode=g}else x$(v,a.type,a.stateNode);else a.stateNode=y$(v,g,a.memoizedProps);else C!==g?(C===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):C.count--,g===null?x$(v,a.type,a.stateNode):y$(v,g,a.memoizedProps)):g===null&&a.stateNode!==null&&hb(a,a.memoizedProps,f.memoizedProps)}break;case 27:Ns(u,a),As(a),g&512&&(gn||f===null||ni(f,f.return)),f!==null&&g&4&&hb(a,a.memoizedProps,f.memoizedProps);break;case 5:if(Ns(u,a),As(a),g&512&&(gn||f===null||ni(f,f.return)),a.flags&32){v=a.stateNode;try{$l(v,"")}catch(It){Ee(a,a.return,It)}}g&4&&a.stateNode!=null&&(v=a.memoizedProps,hb(a,v,f!==null?f.memoizedProps:v)),g&1024&&(pb=!0);break;case 6:if(Ns(u,a),As(a),g&4){if(a.stateNode===null)throw Error(s(162));g=a.memoizedProps,f=a.stateNode;try{f.nodeValue=g}catch(It){Ee(a,a.return,It)}}break;case 3:if(Ep=null,v=Or,Or=kp(u.containerInfo),Ns(u,a),Or=v,As(a),g&4&&f!==null&&f.memoizedState.isDehydrated)try{sc(u.containerInfo)}catch(It){Ee(a,a.return,It)}pb&&(pb=!1,x2(a));break;case 4:g=Or,Or=kp(a.stateNode.containerInfo),Ns(u,a),As(a),Or=g;break;case 12:Ns(u,a),As(a);break;case 31:Ns(u,a),As(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,hp(a,g)));break;case 13:Ns(u,a),As(a),a.child.flags&8192&&a.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(fp=De()),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,hp(a,g)));break;case 22:v=a.memoizedState!==null;var j=f!==null&&f.memoizedState!==null,at=Mi,mt=gn;if(Mi=at||v,gn=mt||j,Ns(u,a),gn=mt,Mi=at,As(a),g&8192)t:for(u=a.stateNode,u._visibility=v?u._visibility&-2:u._visibility|1,v&&(f===null||j||Mi||gn||wa(a)),f=null,u=a;;){if(u.tag===5||u.tag===26){if(f===null){j=f=u;try{if(C=j.stateNode,v)I=C.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{O=j.stateNode;var bt=j.memoizedProps.style,ut=bt!=null&&bt.hasOwnProperty("display")?bt.display:null;O.style.display=ut==null||typeof ut=="boolean"?"":(""+ut).trim()}}catch(It){Ee(j,j.return,It)}}}else if(u.tag===6){if(f===null){j=u;try{j.stateNode.nodeValue=v?"":j.memoizedProps}catch(It){Ee(j,j.return,It)}}}else if(u.tag===18){if(f===null){j=u;try{var ht=j.stateNode;v?l$(ht,!0):l$(j.stateNode,!1)}catch(It){Ee(j,j.return,It)}}}else if((u.tag!==22&&u.tag!==23||u.memoizedState===null||u===a)&&u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break t;for(;u.sibling===null;){if(u.return===null||u.return===a)break t;f===u&&(f=null),u=u.return}f===u&&(f=null),u.sibling.return=u.return,u=u.sibling}g&4&&(g=a.updateQueue,g!==null&&(f=g.retryQueue,f!==null&&(g.retryQueue=null,hp(a,f))));break;case 19:Ns(u,a),As(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,hp(a,g)));break;case 30:break;case 21:break;default:Ns(u,a),As(a)}}function As(a){var u=a.flags;if(u&2){try{for(var f,g=a.return;g!==null;){if(u2(g)){f=g;break}g=g.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var v=f.stateNode,C=db(a);up(a,C,v);break;case 5:var I=f.stateNode;f.flags&32&&($l(I,""),f.flags&=-33);var O=db(a);up(a,O,I);break;case 3:case 4:var j=f.stateNode.containerInfo,at=db(a);fb(a,at,j);break;default:throw Error(s(161))}}catch(mt){Ee(a,a.return,mt)}a.flags&=-3}u&4096&&(a.flags&=-4097)}function x2(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var u=a;x2(u),u.tag===5&&u.flags&1024&&u.stateNode.reset(),a=a.sibling}}function Li(a,u){if(u.subtreeFlags&8772)for(u=u.child;u!==null;)f2(a,u.alternate,u),u=u.sibling}function wa(a){for(a=a.child;a!==null;){var u=a;switch(u.tag){case 0:case 11:case 14:case 15:mo(4,u,u.return),wa(u);break;case 1:ni(u,u.return);var f=u.stateNode;typeof f.componentWillUnmount=="function"&&l2(u,u.return,f),wa(u);break;case 27:Ku(u.stateNode);case 26:case 5:ni(u,u.return),wa(u);break;case 22:u.memoizedState===null&&wa(u);break;case 30:wa(u);break;default:wa(u)}a=a.sibling}}function Pi(a,u,f){for(f=f&&(u.subtreeFlags&8772)!==0,u=u.child;u!==null;){var g=u.alternate,v=a,C=u,I=C.flags;switch(C.tag){case 0:case 11:case 15:Pi(v,C,f),Pu(4,C);break;case 1:if(Pi(v,C,f),g=C,v=g.stateNode,typeof v.componentDidMount=="function")try{v.componentDidMount()}catch(at){Ee(g,g.return,at)}if(g=C,v=g.updateQueue,v!==null){var O=g.stateNode;try{var j=v.shared.hiddenCallbacks;if(j!==null)for(v.shared.hiddenCallbacks=null,v=0;v<j.length;v++)YT(j[v],O)}catch(at){Ee(g,g.return,at)}}f&&I&64&&a2(C),zu(C,C.return);break;case 27:h2(C);case 26:case 5:Pi(v,C,f),f&&g===null&&I&4&&c2(C),zu(C,C.return);break;case 12:Pi(v,C,f);break;case 31:Pi(v,C,f),f&&I&4&&g2(v,C);break;case 13:Pi(v,C,f),f&&I&4&&y2(v,C);break;case 22:C.memoizedState===null&&Pi(v,C,f),zu(C,C.return);break;case 30:break;default:Pi(v,C,f)}u=u.sibling}}function mb(a,u){var f=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),a=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(a=u.memoizedState.cachePool.pool),a!==f&&(a!=null&&a.refCount++,f!=null&&ku(f))}function gb(a,u){a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&ku(a))}function Mr(a,u,f,g){if(u.subtreeFlags&10256)for(u=u.child;u!==null;)v2(a,u,f,g),u=u.sibling}function v2(a,u,f,g){var v=u.flags;switch(u.tag){case 0:case 11:case 15:Mr(a,u,f,g),v&2048&&Pu(9,u);break;case 1:Mr(a,u,f,g);break;case 3:Mr(a,u,f,g),v&2048&&(a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&ku(a)));break;case 12:if(v&2048){Mr(a,u,f,g),a=u.stateNode;try{var C=u.memoizedProps,I=C.id,O=C.onPostCommit;typeof O=="function"&&O(I,u.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(j){Ee(u,u.return,j)}}else Mr(a,u,f,g);break;case 31:Mr(a,u,f,g);break;case 13:Mr(a,u,f,g);break;case 23:break;case 22:C=u.stateNode,I=u.alternate,u.memoizedState!==null?C._visibility&2?Mr(a,u,f,g):Bu(a,u):C._visibility&2?Mr(a,u,f,g):(C._visibility|=2,Hl(a,u,f,g,(u.subtreeFlags&10256)!==0||!1)),v&2048&&mb(I,u);break;case 24:Mr(a,u,f,g),v&2048&&gb(u.alternate,u);break;default:Mr(a,u,f,g)}}function Hl(a,u,f,g,v){for(v=v&&((u.subtreeFlags&10256)!==0||!1),u=u.child;u!==null;){var C=a,I=u,O=f,j=g,at=I.flags;switch(I.tag){case 0:case 11:case 15:Hl(C,I,O,j,v),Pu(8,I);break;case 23:break;case 22:var mt=I.stateNode;I.memoizedState!==null?mt._visibility&2?Hl(C,I,O,j,v):Bu(C,I):(mt._visibility|=2,Hl(C,I,O,j,v)),v&&at&2048&&mb(I.alternate,I);break;case 24:Hl(C,I,O,j,v),v&&at&2048&&gb(I.alternate,I);break;default:Hl(C,I,O,j,v)}u=u.sibling}}function Bu(a,u){if(u.subtreeFlags&10256)for(u=u.child;u!==null;){var f=a,g=u,v=g.flags;switch(g.tag){case 22:Bu(f,g),v&2048&&mb(g.alternate,g);break;case 24:Bu(f,g),v&2048&&gb(g.alternate,g);break;default:Bu(f,g)}u=u.sibling}}var Vu=8192;function ql(a,u,f){if(a.subtreeFlags&Vu)for(a=a.child;a!==null;)w2(a,u,f),a=a.sibling}function w2(a,u,f){switch(a.tag){case 26:ql(a,u,f),a.flags&Vu&&a.memoizedState!==null&&fB(f,Or,a.memoizedState,a.memoizedProps);break;case 5:ql(a,u,f);break;case 3:case 4:var g=Or;Or=kp(a.stateNode.containerInfo),ql(a,u,f),Or=g;break;case 22:a.memoizedState===null&&(g=a.alternate,g!==null&&g.memoizedState!==null?(g=Vu,Vu=16777216,ql(a,u,f),Vu=g):ql(a,u,f));break;default:ql(a,u,f)}}function S2(a){var u=a.alternate;if(u!==null&&(a=u.child,a!==null)){u.child=null;do u=a.sibling,a.sibling=null,a=u;while(a!==null)}}function Uu(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Fn=g,T2(g,a)}S2(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)C2(a),a=a.sibling}function C2(a){switch(a.tag){case 0:case 11:case 15:Uu(a),a.flags&2048&&mo(9,a,a.return);break;case 3:Uu(a);break;case 12:Uu(a);break;case 22:var u=a.stateNode;a.memoizedState!==null&&u._visibility&2&&(a.return===null||a.return.tag!==13)?(u._visibility&=-3,dp(a)):Uu(a);break;default:Uu(a)}}function dp(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Fn=g,T2(g,a)}S2(a)}for(a=a.child;a!==null;){switch(u=a,u.tag){case 0:case 11:case 15:mo(8,u,u.return),dp(u);break;case 22:f=u.stateNode,f._visibility&2&&(f._visibility&=-3,dp(u));break;default:dp(u)}a=a.sibling}}function T2(a,u){for(;Fn!==null;){var f=Fn;switch(f.tag){case 0:case 11:case 15:mo(8,f,u);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var g=f.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:ku(f.memoizedState.cache)}if(g=f.child,g!==null)g.return=f,Fn=g;else t:for(f=a;Fn!==null;){g=Fn;var v=g.sibling,C=g.return;if(p2(g),g===f){Fn=null;break t}if(v!==null){v.return=C,Fn=v;break t}Fn=C}}}var Iz={getCacheForType:function(a){var u=Gn(fn),f=u.data.get(a);return f===void 0&&(f=a(),u.data.set(a,f)),f},cacheSignal:function(){return Gn(fn).controller.signal}},Nz=typeof WeakMap=="function"?WeakMap:Map,Se=0,Oe=null,ie=null,le=0,$e=0,qs=null,go=!1,Kl=!1,yb=!1,zi=0,Qe=0,yo=0,Sa=0,bb=0,Ks=0,Xl=0,ju=null,_s=null,xb=!1,fp=0,k2=0,pp=1/0,mp=null,bo=null,$n=0,xo=null,Yl=null,Bi=0,vb=0,wb=null,$2=null,Gu=0,Sb=null;function Xs(){return(Se&2)!==0&&le!==0?le&-le:P.T!==null?Ib():UC()}function E2(){if(Ks===0)if((le&536870912)===0||ue){var a=Cf;Cf<<=1,(Cf&3932160)===0&&(Cf=262144),Ks=a}else Ks=536870912;return a=Ws.current,a!==null&&(a.flags|=32),Ks}function Rs(a,u,f){(a===Oe&&($e===2||$e===9)||a.cancelPendingCommit!==null)&&(Zl(a,0),vo(a,le,Ks,!1)),hu(a,f),((Se&2)===0||a!==Oe)&&(a===Oe&&((Se&2)===0&&(Sa|=f),Qe===4&&vo(a,le,Ks,!1)),si(a))}function I2(a,u,f){if((Se&6)!==0)throw Error(s(327));var g=!f&&(u&127)===0&&(u&a.expiredLanes)===0||uu(a,u),v=g?Rz(a,u):Tb(a,u,!0),C=g;do{if(v===0){Kl&&!g&&vo(a,u,0,!1);break}else{if(f=a.current.alternate,C&&!Az(f)){v=Tb(a,u,!1),C=!1;continue}if(v===2){if(C=u,a.errorRecoveryDisabledLanes&C)var I=0;else I=a.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){u=I;t:{var O=a;v=ju;var j=O.current.memoizedState.isDehydrated;if(j&&(Zl(O,I).flags|=256),I=Tb(O,I,!1),I!==2){if(yb&&!j){O.errorRecoveryDisabledLanes|=C,Sa|=C,v=4;break t}C=_s,_s=v,C!==null&&(_s===null?_s=C:_s.push.apply(_s,C))}v=I}if(C=!1,v!==2)continue}}if(v===1){Zl(a,0),vo(a,u,0,!0);break}t:{switch(g=a,C=v,C){case 0:case 1:throw Error(s(345));case 4:if((u&4194048)!==u)break;case 6:vo(g,u,Ks,!go);break t;case 2:_s=null;break;case 3:case 5:break;default:throw Error(s(329))}if((u&62914560)===u&&(v=fp+300-De(),10<v)){if(vo(g,u,Ks,!go),kf(g,0,!0)!==0)break t;Bi=u,g.timeoutHandle=i$(N2.bind(null,g,f,_s,mp,xb,u,Ks,Sa,Xl,go,C,"Throttled",-0,0),v);break t}N2(g,f,_s,mp,xb,u,Ks,Sa,Xl,go,C,null,-0,0)}}break}while(!0);si(a)}function N2(a,u,f,g,v,C,I,O,j,at,mt,bt,ut,ht){if(a.timeoutHandle=-1,bt=u.subtreeFlags,bt&8192||(bt&16785408)===16785408){bt={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:ki},w2(u,C,bt);var It=(C&62914560)===C?fp-De():(C&4194048)===C?k2-De():0;if(It=pB(bt,It),It!==null){Bi=C,a.cancelPendingCommit=It(L2.bind(null,a,u,C,f,g,v,I,O,j,mt,bt,null,ut,ht)),vo(a,C,I,!at);return}}L2(a,u,C,f,g,v,I,O,j)}function Az(a){for(var u=a;;){var f=u.tag;if((f===0||f===11||f===15)&&u.flags&16384&&(f=u.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var g=0;g<f.length;g++){var v=f[g],C=v.getSnapshot;v=v.value;try{if(!js(C(),v))return!1}catch{return!1}}if(f=u.child,u.subtreeFlags&16384&&f!==null)f.return=u,u=f;else{if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return!0;u=u.return}u.sibling.return=u.return,u=u.sibling}}return!0}function vo(a,u,f,g){u&=~bb,u&=~Sa,a.suspendedLanes|=u,a.pingedLanes&=~u,g&&(a.warmLanes|=u),g=a.expirationTimes;for(var v=u;0<v;){var C=31-Us(v),I=1<<C;g[C]=-1,v&=~I}f!==0&&zC(a,f,u)}function gp(){return(Se&6)===0?(Wu(0),!1):!0}function Cb(){if(ie!==null){if($e===0)var a=ie.return;else a=ie,Ni=fa=null,zy(a),Vl=null,Eu=0,a=ie;for(;a!==null;)o2(a.alternate,a),a=a.return;ie=null}}function Zl(a,u){var f=a.timeoutHandle;f!==-1&&(a.timeoutHandle=-1,Yz(f)),f=a.cancelPendingCommit,f!==null&&(a.cancelPendingCommit=null,f()),Bi=0,Cb(),Oe=a,ie=f=Ei(a.current,null),le=u,$e=0,qs=null,go=!1,Kl=uu(a,u),yb=!1,Xl=Ks=bb=Sa=yo=Qe=0,_s=ju=null,xb=!1,(u&8)!==0&&(u|=u&32);var g=a.entangledLanes;if(g!==0)for(a=a.entanglements,g&=u;0<g;){var v=31-Us(g),C=1<<v;u|=a[v],g&=~C}return zi=u,Lf(),f}function A2(a,u){Kt=null,P.H=Mu,u===Bl||u===Wf?(u=HT(),$e=3):u===Ey?(u=HT(),$e=4):$e=u===eb?8:u!==null&&typeof u=="object"&&typeof u.then=="function"?6:1,qs=u,ie===null&&(Qe=1,ip(a,cr(u,a.current)))}function _2(){var a=Ws.current;return a===null?!0:(le&4194048)===le?fr===null:(le&62914560)===le||(le&536870912)!==0?a===fr:!1}function R2(){var a=P.H;return P.H=Mu,a===null?Mu:a}function D2(){var a=P.A;return P.A=Iz,a}function yp(){Qe=4,go||(le&4194048)!==le&&Ws.current!==null||(Kl=!0),(yo&134217727)===0&&(Sa&134217727)===0||Oe===null||vo(Oe,le,Ks,!1)}function Tb(a,u,f){var g=Se;Se|=2;var v=R2(),C=D2();(Oe!==a||le!==u)&&(mp=null,Zl(a,u)),u=!1;var I=Qe;t:do try{if($e!==0&&ie!==null){var O=ie,j=qs;switch($e){case 8:Cb(),I=6;break t;case 3:case 2:case 9:case 6:Ws.current===null&&(u=!0);var at=$e;if($e=0,qs=null,Jl(a,O,j,at),f&&Kl){I=0;break t}break;default:at=$e,$e=0,qs=null,Jl(a,O,j,at)}}_z(),I=Qe;break}catch(mt){A2(a,mt)}while(!0);return u&&a.shellSuspendCounter++,Ni=fa=null,Se=g,P.H=v,P.A=C,ie===null&&(Oe=null,le=0,Lf()),I}function _z(){for(;ie!==null;)O2(ie)}function Rz(a,u){var f=Se;Se|=2;var g=R2(),v=D2();Oe!==a||le!==u?(mp=null,pp=De()+500,Zl(a,u)):Kl=uu(a,u);t:do try{if($e!==0&&ie!==null){u=ie;var C=qs;e:switch($e){case 1:$e=0,qs=null,Jl(a,u,C,1);break;case 2:case 9:if(GT(C)){$e=0,qs=null,M2(u);break}u=function(){$e!==2&&$e!==9||Oe!==a||($e=7),si(a)},C.then(u,u);break t;case 3:$e=7;break t;case 4:$e=5;break t;case 7:GT(C)?($e=0,qs=null,M2(u)):($e=0,qs=null,Jl(a,u,C,7));break;case 5:var I=null;switch(ie.tag){case 26:I=ie.memoizedState;case 5:case 27:var O=ie;if(I?v$(I):O.stateNode.complete){$e=0,qs=null;var j=O.sibling;if(j!==null)ie=j;else{var at=O.return;at!==null?(ie=at,bp(at)):ie=null}break e}}$e=0,qs=null,Jl(a,u,C,5);break;case 6:$e=0,qs=null,Jl(a,u,C,6);break;case 8:Cb(),Qe=6;break t;default:throw Error(s(462))}}Dz();break}catch(mt){A2(a,mt)}while(!0);return Ni=fa=null,P.H=g,P.A=v,Se=f,ie!==null?0:(Oe=null,le=0,Lf(),Qe)}function Dz(){for(;ie!==null&&!On();)O2(ie)}function O2(a){var u=r2(a.alternate,a,zi);a.memoizedProps=a.pendingProps,u===null?bp(a):ie=u}function M2(a){var u=a,f=u.alternate;switch(u.tag){case 15:case 0:u=Jk(f,u,u.pendingProps,u.type,void 0,le);break;case 11:u=Jk(f,u,u.pendingProps,u.type.render,u.ref,le);break;case 5:zy(u);default:o2(f,u),u=ie=DT(u,zi),u=r2(f,u,zi)}a.memoizedProps=a.pendingProps,u===null?bp(a):ie=u}function Jl(a,u,f,g){Ni=fa=null,zy(u),Vl=null,Eu=0;var v=u.return;try{if(wz(a,v,u,f,le)){Qe=1,ip(a,cr(f,a.current)),ie=null;return}}catch(C){if(v!==null)throw ie=v,C;Qe=1,ip(a,cr(f,a.current)),ie=null;return}u.flags&32768?(ue||g===1?a=!0:Kl||(le&536870912)!==0?a=!1:(go=a=!0,(g===2||g===9||g===3||g===6)&&(g=Ws.current,g!==null&&g.tag===13&&(g.flags|=16384))),F2(u,a)):bp(u)}function bp(a){var u=a;do{if((u.flags&32768)!==0){F2(u,go);return}a=u.return;var f=Tz(u.alternate,u,zi);if(f!==null){ie=f;return}if(u=u.sibling,u!==null){ie=u;return}ie=u=a}while(u!==null);Qe===0&&(Qe=5)}function F2(a,u){do{var f=kz(a.alternate,a);if(f!==null){f.flags&=32767,ie=f;return}if(f=a.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!u&&(a=a.sibling,a!==null)){ie=a;return}ie=a=f}while(a!==null);Qe=6,ie=null}function L2(a,u,f,g,v,C,I,O,j){a.cancelPendingCommit=null;do xp();while($n!==0);if((Se&6)!==0)throw Error(s(327));if(u!==null){if(u===a.current)throw Error(s(177));if(C=u.lanes|u.childLanes,C|=dy,dP(a,f,C,I,O,j),a===Oe&&(ie=Oe=null,le=0),Yl=u,xo=a,Bi=f,vb=C,wb=v,$2=g,(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,Lz(se,function(){return U2(),null})):(a.callbackNode=null,a.callbackPriority=0),g=(u.flags&13878)!==0,(u.subtreeFlags&13878)!==0||g){g=P.T,P.T=null,v=U.p,U.p=2,I=Se,Se|=4;try{$z(a,u,f)}finally{Se=I,U.p=v,P.T=g}}$n=1,P2(),z2(),B2()}}function P2(){if($n===1){$n=0;var a=xo,u=Yl,f=(u.flags&13878)!==0;if((u.subtreeFlags&13878)!==0||f){f=P.T,P.T=null;var g=U.p;U.p=2;var v=Se;Se|=4;try{b2(u,a);var C=Fb,I=TT(a.containerInfo),O=C.focusedElem,j=C.selectionRange;if(I!==O&&O&&O.ownerDocument&&CT(O.ownerDocument.documentElement,O)){if(j!==null&&ay(O)){var at=j.start,mt=j.end;if(mt===void 0&&(mt=at),"selectionStart"in O)O.selectionStart=at,O.selectionEnd=Math.min(mt,O.value.length);else{var bt=O.ownerDocument||document,ut=bt&&bt.defaultView||window;if(ut.getSelection){var ht=ut.getSelection(),It=O.textContent.length,zt=Math.min(j.start,It),_e=j.end===void 0?zt:Math.min(j.end,It);!ht.extend&&zt>_e&&(I=_e,_e=zt,zt=I);var st=ST(O,zt),K=ST(O,_e);if(st&&K&&(ht.rangeCount!==1||ht.anchorNode!==st.node||ht.anchorOffset!==st.offset||ht.focusNode!==K.node||ht.focusOffset!==K.offset)){var ot=bt.createRange();ot.setStart(st.node,st.offset),ht.removeAllRanges(),zt>_e?(ht.addRange(ot),ht.extend(K.node,K.offset)):(ot.setEnd(K.node,K.offset),ht.addRange(ot))}}}}for(bt=[],ht=O;ht=ht.parentNode;)ht.nodeType===1&&bt.push({element:ht,left:ht.scrollLeft,top:ht.scrollTop});for(typeof O.focus=="function"&&O.focus(),O=0;O<bt.length;O++){var yt=bt[O];yt.element.scrollLeft=yt.left,yt.element.scrollTop=yt.top}}_p=!!Mb,Fb=Mb=null}finally{Se=v,U.p=g,P.T=f}}a.current=u,$n=2}}function z2(){if($n===2){$n=0;var a=xo,u=Yl,f=(u.flags&8772)!==0;if((u.subtreeFlags&8772)!==0||f){f=P.T,P.T=null;var g=U.p;U.p=2;var v=Se;Se|=4;try{f2(a,u.alternate,u)}finally{Se=v,U.p=g,P.T=f}}$n=3}}function B2(){if($n===4||$n===3){$n=0,Ar();var a=xo,u=Yl,f=Bi,g=$2;(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?$n=5:($n=0,Yl=xo=null,V2(a,a.pendingLanes));var v=a.pendingLanes;if(v===0&&(bo=null),U0(f),u=u.stateNode,Be&&typeof Be.onCommitFiberRoot=="function")try{Be.onCommitFiberRoot(ns,u,void 0,(u.current.flags&128)===128)}catch{}if(g!==null){u=P.T,v=U.p,U.p=2,P.T=null;try{for(var C=a.onRecoverableError,I=0;I<g.length;I++){var O=g[I];C(O.value,{componentStack:O.stack})}}finally{P.T=u,U.p=v}}(Bi&3)!==0&&xp(),si(a),v=a.pendingLanes,(f&261930)!==0&&(v&42)!==0?a===Sb?Gu++:(Gu=0,Sb=a):Gu=0,Wu(0)}}function V2(a,u){(a.pooledCacheLanes&=u)===0&&(u=a.pooledCache,u!=null&&(a.pooledCache=null,ku(u)))}function xp(){return P2(),z2(),B2(),U2()}function U2(){if($n!==5)return!1;var a=xo,u=vb;vb=0;var f=U0(Bi),g=P.T,v=U.p;try{U.p=32>f?32:f,P.T=null,f=wb,wb=null;var C=xo,I=Bi;if($n=0,Yl=xo=null,Bi=0,(Se&6)!==0)throw Error(s(331));var O=Se;if(Se|=4,C2(C.current),v2(C,C.current,I,f),Se=O,Wu(0,!1),Be&&typeof Be.onPostCommitFiberRoot=="function")try{Be.onPostCommitFiberRoot(ns,C)}catch{}return!0}finally{U.p=v,P.T=g,V2(a,u)}}function j2(a,u,f){u=cr(f,u),u=tb(a.stateNode,u,2),a=ho(a,u,2),a!==null&&(hu(a,2),si(a))}function Ee(a,u,f){if(a.tag===3)j2(a,a,f);else for(;u!==null;){if(u.tag===3){j2(u,a,f);break}else if(u.tag===1){var g=u.stateNode;if(typeof u.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(bo===null||!bo.has(g))){a=cr(f,a),f=Gk(2),g=ho(u,f,2),g!==null&&(Wk(f,g,u,a),hu(g,2),si(g));break}}u=u.return}}function kb(a,u,f){var g=a.pingCache;if(g===null){g=a.pingCache=new Nz;var v=new Set;g.set(u,v)}else v=g.get(u),v===void 0&&(v=new Set,g.set(u,v));v.has(f)||(yb=!0,v.add(f),a=Oz.bind(null,a,u,f),u.then(a,a))}function Oz(a,u,f){var g=a.pingCache;g!==null&&g.delete(u),a.pingedLanes|=a.suspendedLanes&f,a.warmLanes&=~f,Oe===a&&(le&f)===f&&(Qe===4||Qe===3&&(le&62914560)===le&&300>De()-fp?(Se&2)===0&&Zl(a,0):bb|=f,Xl===le&&(Xl=0)),si(a)}function G2(a,u){u===0&&(u=PC()),a=ua(a,u),a!==null&&(hu(a,u),si(a))}function Mz(a){var u=a.memoizedState,f=0;u!==null&&(f=u.retryLane),G2(a,f)}function Fz(a,u){var f=0;switch(a.tag){case 31:case 13:var g=a.stateNode,v=a.memoizedState;v!==null&&(f=v.retryLane);break;case 19:g=a.stateNode;break;case 22:g=a.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(u),G2(a,f)}function Lz(a,u){return We(a,u)}var vp=null,Ql=null,$b=!1,wp=!1,Eb=!1,wo=0;function si(a){a!==Ql&&a.next===null&&(Ql===null?vp=Ql=a:Ql=Ql.next=a),wp=!0,$b||($b=!0,zz())}function Wu(a,u){if(!Eb&&wp){Eb=!0;do for(var f=!1,g=vp;g!==null;){if(a!==0){var v=g.pendingLanes;if(v===0)var C=0;else{var I=g.suspendedLanes,O=g.pingedLanes;C=(1<<31-Us(42|a)+1)-1,C&=v&~(I&~O),C=C&201326741?C&201326741|1:C?C|2:0}C!==0&&(f=!0,K2(g,C))}else C=le,C=kf(g,g===Oe?C:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(C&3)===0||uu(g,C)||(f=!0,K2(g,C));g=g.next}while(f);Eb=!1}}function Pz(){W2()}function W2(){wp=$b=!1;var a=0;wo!==0&&Xz()&&(a=wo);for(var u=De(),f=null,g=vp;g!==null;){var v=g.next,C=H2(g,u);C===0?(g.next=null,f===null?vp=v:f.next=v,v===null&&(Ql=f)):(f=g,(a!==0||(C&3)!==0)&&(wp=!0)),g=v}$n!==0&&$n!==5||Wu(a),wo!==0&&(wo=0)}function H2(a,u){for(var f=a.suspendedLanes,g=a.pingedLanes,v=a.expirationTimes,C=a.pendingLanes&-62914561;0<C;){var I=31-Us(C),O=1<<I,j=v[I];j===-1?((O&f)===0||(O&g)!==0)&&(v[I]=hP(O,u)):j<=u&&(a.expiredLanes|=O),C&=~O}if(u=Oe,f=le,f=kf(a,a===u?f:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g=a.callbackNode,f===0||a===u&&($e===2||$e===9)||a.cancelPendingCommit!==null)return g!==null&&g!==null&&ks(g),a.callbackNode=null,a.callbackPriority=0;if((f&3)===0||uu(a,f)){if(u=f&-f,u===a.callbackPriority)return u;switch(g!==null&&ks(g),U0(f)){case 2:case 8:f=Pt;break;case 32:f=se;break;case 268435456:f=_r;break;default:f=se}return g=q2.bind(null,a),f=We(f,g),a.callbackPriority=u,a.callbackNode=f,u}return g!==null&&g!==null&&ks(g),a.callbackPriority=2,a.callbackNode=null,2}function q2(a,u){if($n!==0&&$n!==5)return a.callbackNode=null,a.callbackPriority=0,null;var f=a.callbackNode;if(xp()&&a.callbackNode!==f)return null;var g=le;return g=kf(a,a===Oe?g:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g===0?null:(I2(a,g,u),H2(a,De()),a.callbackNode!=null&&a.callbackNode===f?q2.bind(null,a):null)}function K2(a,u){if(xp())return null;I2(a,u,!0)}function zz(){Zz(function(){(Se&6)!==0?We(Vs,Pz):W2()})}function Ib(){if(wo===0){var a=Pl;a===0&&(a=Sf,Sf<<=1,(Sf&261888)===0&&(Sf=256)),wo=a}return wo}function X2(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:Nf(""+a)}function Y2(a,u){var f=u.ownerDocument.createElement("input");return f.name=u.name,f.value=u.value,a.id&&f.setAttribute("form",a.id),u.parentNode.insertBefore(f,u),a=new FormData(a),f.parentNode.removeChild(f),a}function Bz(a,u,f,g,v){if(u==="submit"&&f&&f.stateNode===v){var C=X2((v[$s]||null).action),I=g.submitter;I&&(u=(u=I[$s]||null)?X2(u.formAction):I.getAttribute("formAction"),u!==null&&(C=u,I=null));var O=new Df("action","action",null,g,v);a.push({event:O,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(wo!==0){var j=I?Y2(v,I):new FormData(v);Ky(f,{pending:!0,data:j,method:v.method,action:C},null,j)}}else typeof C=="function"&&(O.preventDefault(),j=I?Y2(v,I):new FormData(v),Ky(f,{pending:!0,data:j,method:v.method,action:C},C,j))},currentTarget:v}]})}}for(var Nb=0;Nb<hy.length;Nb++){var Ab=hy[Nb],Vz=Ab.toLowerCase(),Uz=Ab[0].toUpperCase()+Ab.slice(1);Dr(Vz,"on"+Uz)}Dr(ET,"onAnimationEnd"),Dr(IT,"onAnimationIteration"),Dr(NT,"onAnimationStart"),Dr("dblclick","onDoubleClick"),Dr("focusin","onFocus"),Dr("focusout","onBlur"),Dr(rz,"onTransitionRun"),Dr(iz,"onTransitionStart"),Dr(oz,"onTransitionCancel"),Dr(AT,"onTransitionEnd"),Tl("onMouseEnter",["mouseout","mouseover"]),Tl("onMouseLeave",["mouseout","mouseover"]),Tl("onPointerEnter",["pointerout","pointerover"]),Tl("onPointerLeave",["pointerout","pointerover"]),oa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),oa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),oa("onBeforeInput",["compositionend","keypress","textInput","paste"]),oa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),oa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),oa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Hu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),jz=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Hu));function Z2(a,u){u=(u&4)!==0;for(var f=0;f<a.length;f++){var g=a[f],v=g.event;g=g.listeners;t:{var C=void 0;if(u)for(var I=g.length-1;0<=I;I--){var O=g[I],j=O.instance,at=O.currentTarget;if(O=O.listener,j!==C&&v.isPropagationStopped())break t;C=O,v.currentTarget=at;try{C(v)}catch(mt){Ff(mt)}v.currentTarget=null,C=j}else for(I=0;I<g.length;I++){if(O=g[I],j=O.instance,at=O.currentTarget,O=O.listener,j!==C&&v.isPropagationStopped())break t;C=O,v.currentTarget=at;try{C(v)}catch(mt){Ff(mt)}v.currentTarget=null,C=j}}}}function oe(a,u){var f=u[j0];f===void 0&&(f=u[j0]=new Set);var g=a+"__bubble";f.has(g)||(J2(u,a,2,!1),f.add(g))}function _b(a,u,f){var g=0;u&&(g|=4),J2(f,a,g,u)}var Sp="_reactListening"+Math.random().toString(36).slice(2);function Rb(a){if(!a[Sp]){a[Sp]=!0,WC.forEach(function(f){f!=="selectionchange"&&(jz.has(f)||_b(f,!1,a),_b(f,!0,a))});var u=a.nodeType===9?a:a.ownerDocument;u===null||u[Sp]||(u[Sp]=!0,_b("selectionchange",!1,u))}}function J2(a,u,f,g){switch(E$(u)){case 2:var v=yB;break;case 8:v=bB;break;default:v=qb}f=v.bind(null,u,f,a),v=void 0,!J0||u!=="touchstart"&&u!=="touchmove"&&u!=="wheel"||(v=!0),g?v!==void 0?a.addEventListener(u,f,{capture:!0,passive:v}):a.addEventListener(u,f,!0):v!==void 0?a.addEventListener(u,f,{passive:v}):a.addEventListener(u,f,!1)}function Db(a,u,f,g,v){var C=g;if((u&1)===0&&(u&2)===0&&g!==null)t:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var O=g.stateNode.containerInfo;if(O===v)break;if(I===4)for(I=g.return;I!==null;){var j=I.tag;if((j===3||j===4)&&I.stateNode.containerInfo===v)return;I=I.return}for(;O!==null;){if(I=wl(O),I===null)return;if(j=I.tag,j===5||j===6||j===26||j===27){g=C=I;continue t}O=O.parentNode}}g=g.return}sT(function(){var at=C,mt=Y0(f),bt=[];t:{var ut=_T.get(a);if(ut!==void 0){var ht=Df,It=a;switch(a){case"keypress":if(_f(f)===0)break t;case"keydown":case"keyup":ht=FP;break;case"focusin":It="focus",ht=ny;break;case"focusout":It="blur",ht=ny;break;case"beforeblur":case"afterblur":ht=ny;break;case"click":if(f.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ht=oT;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ht=TP;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ht=zP;break;case ET:case IT:case NT:ht=EP;break;case AT:ht=VP;break;case"scroll":case"scrollend":ht=SP;break;case"wheel":ht=jP;break;case"copy":case"cut":case"paste":ht=NP;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ht=lT;break;case"toggle":case"beforetoggle":ht=WP}var zt=(u&4)!==0,_e=!zt&&(a==="scroll"||a==="scrollend"),st=zt?ut!==null?ut+"Capture":null:ut;zt=[];for(var K=at,ot;K!==null;){var yt=K;if(ot=yt.stateNode,yt=yt.tag,yt!==5&&yt!==26&&yt!==27||ot===null||st===null||(yt=pu(K,st),yt!=null&&zt.push(qu(K,yt,ot))),_e)break;K=K.return}0<zt.length&&(ut=new ht(ut,It,null,f,mt),bt.push({event:ut,listeners:zt}))}}if((u&7)===0){t:{if(ut=a==="mouseover"||a==="pointerover",ht=a==="mouseout"||a==="pointerout",ut&&f!==X0&&(It=f.relatedTarget||f.fromElement)&&(wl(It)||It[vl]))break t;if((ht||ut)&&(ut=mt.window===mt?mt:(ut=mt.ownerDocument)?ut.defaultView||ut.parentWindow:window,ht?(It=f.relatedTarget||f.toElement,ht=at,It=It?wl(It):null,It!==null&&(_e=i(It),zt=It.tag,It!==_e||zt!==5&&zt!==27&&zt!==6)&&(It=null)):(ht=null,It=at),ht!==It)){if(zt=oT,yt="onMouseLeave",st="onMouseEnter",K="mouse",(a==="pointerout"||a==="pointerover")&&(zt=lT,yt="onPointerLeave",st="onPointerEnter",K="pointer"),_e=ht==null?ut:fu(ht),ot=It==null?ut:fu(It),ut=new zt(yt,K+"leave",ht,f,mt),ut.target=_e,ut.relatedTarget=ot,yt=null,wl(mt)===at&&(zt=new zt(st,K+"enter",It,f,mt),zt.target=ot,zt.relatedTarget=_e,yt=zt),_e=yt,ht&&It)e:{for(zt=Gz,st=ht,K=It,ot=0,yt=st;yt;yt=zt(yt))ot++;yt=0;for(var Ft=K;Ft;Ft=zt(Ft))yt++;for(;0<ot-yt;)st=zt(st),ot--;for(;0<yt-ot;)K=zt(K),yt--;for(;ot--;){if(st===K||K!==null&&st===K.alternate){zt=st;break e}st=zt(st),K=zt(K)}zt=null}else zt=null;ht!==null&&Q2(bt,ut,ht,zt,!1),It!==null&&_e!==null&&Q2(bt,_e,It,zt,!0)}}t:{if(ut=at?fu(at):window,ht=ut.nodeName&&ut.nodeName.toLowerCase(),ht==="select"||ht==="input"&&ut.type==="file")var ye=gT;else if(pT(ut))if(yT)ye=ez;else{ye=QP;var _t=JP}else ht=ut.nodeName,!ht||ht.toLowerCase()!=="input"||ut.type!=="checkbox"&&ut.type!=="radio"?at&&K0(at.elementType)&&(ye=gT):ye=tz;if(ye&&(ye=ye(a,at))){mT(bt,ye,f,mt);break t}_t&&_t(a,ut,at),a==="focusout"&&at&&ut.type==="number"&&at.memoizedProps.value!=null&&q0(ut,"number",ut.value)}switch(_t=at?fu(at):window,a){case"focusin":(pT(_t)||_t.contentEditable==="true")&&(Al=_t,ly=at,Su=null);break;case"focusout":Su=ly=Al=null;break;case"mousedown":cy=!0;break;case"contextmenu":case"mouseup":case"dragend":cy=!1,kT(bt,f,mt);break;case"selectionchange":if(sz)break;case"keydown":case"keyup":kT(bt,f,mt)}var Jt;if(ry)t:{switch(a){case"compositionstart":var ce="onCompositionStart";break t;case"compositionend":ce="onCompositionEnd";break t;case"compositionupdate":ce="onCompositionUpdate";break t}ce=void 0}else Nl?dT(a,f)&&(ce="onCompositionEnd"):a==="keydown"&&f.keyCode===229&&(ce="onCompositionStart");ce&&(cT&&f.locale!=="ko"&&(Nl||ce!=="onCompositionStart"?ce==="onCompositionEnd"&&Nl&&(Jt=rT()):(ro=mt,Q0="value"in ro?ro.value:ro.textContent,Nl=!0)),_t=Cp(at,ce),0<_t.length&&(ce=new aT(ce,a,null,f,mt),bt.push({event:ce,listeners:_t}),Jt?ce.data=Jt:(Jt=fT(f),Jt!==null&&(ce.data=Jt)))),(Jt=qP?KP(a,f):XP(a,f))&&(ce=Cp(at,"onBeforeInput"),0<ce.length&&(_t=new aT("onBeforeInput","beforeinput",null,f,mt),bt.push({event:_t,listeners:ce}),_t.data=Jt)),Bz(bt,a,at,f,mt)}Z2(bt,u)})}function qu(a,u,f){return{instance:a,listener:u,currentTarget:f}}function Cp(a,u){for(var f=u+"Capture",g=[];a!==null;){var v=a,C=v.stateNode;if(v=v.tag,v!==5&&v!==26&&v!==27||C===null||(v=pu(a,f),v!=null&&g.unshift(qu(a,v,C)),v=pu(a,u),v!=null&&g.push(qu(a,v,C))),a.tag===3)return g;a=a.return}return[]}function Gz(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function Q2(a,u,f,g,v){for(var C=u._reactName,I=[];f!==null&&f!==g;){var O=f,j=O.alternate,at=O.stateNode;if(O=O.tag,j!==null&&j===g)break;O!==5&&O!==26&&O!==27||at===null||(j=at,v?(at=pu(f,C),at!=null&&I.unshift(qu(f,at,j))):v||(at=pu(f,C),at!=null&&I.push(qu(f,at,j)))),f=f.return}I.length!==0&&a.push({event:u,listeners:I})}var Wz=/\r\n?/g,Hz=/\u0000|\uFFFD/g;function t$(a){return(typeof a=="string"?a:""+a).replace(Wz,`
`).replace(Hz,"")}function e$(a,u){return u=t$(u),t$(a)===u}function Ae(a,u,f,g,v,C){switch(f){case"children":typeof g=="string"?u==="body"||u==="textarea"&&g===""||$l(a,g):(typeof g=="number"||typeof g=="bigint")&&u!=="body"&&$l(a,""+g);break;case"className":Ef(a,"class",g);break;case"tabIndex":Ef(a,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":Ef(a,f,g);break;case"style":eT(a,g,C);break;case"data":if(u!=="object"){Ef(a,"data",g);break}case"src":case"href":if(g===""&&(u!=="a"||f!=="href")){a.removeAttribute(f);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=Nf(""+g),a.setAttribute(f,g);break;case"action":case"formAction":if(typeof g=="function"){a.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof C=="function"&&(f==="formAction"?(u!=="input"&&Ae(a,u,"name",v.name,v,null),Ae(a,u,"formEncType",v.formEncType,v,null),Ae(a,u,"formMethod",v.formMethod,v,null),Ae(a,u,"formTarget",v.formTarget,v,null)):(Ae(a,u,"encType",v.encType,v,null),Ae(a,u,"method",v.method,v,null),Ae(a,u,"target",v.target,v,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=Nf(""+g),a.setAttribute(f,g);break;case"onClick":g!=null&&(a.onclick=ki);break;case"onScroll":g!=null&&oe("scroll",a);break;case"onScrollEnd":g!=null&&oe("scrollend",a);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"multiple":a.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":a.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){a.removeAttribute("xlink:href");break}f=Nf(""+g),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""+g):a.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""):a.removeAttribute(f);break;case"capture":case"download":g===!0?a.setAttribute(f,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,g):a.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?a.setAttribute(f,g):a.removeAttribute(f);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?a.removeAttribute(f):a.setAttribute(f,g);break;case"popover":oe("beforetoggle",a),oe("toggle",a),$f(a,"popover",g);break;case"xlinkActuate":Ti(a,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":Ti(a,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":Ti(a,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":Ti(a,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":Ti(a,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":Ti(a,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":Ti(a,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":Ti(a,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":Ti(a,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":$f(a,"is",g);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=vP.get(f)||f,$f(a,f,g))}}function Ob(a,u,f,g,v,C){switch(f){case"style":eT(a,g,C);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"children":typeof g=="string"?$l(a,g):(typeof g=="number"||typeof g=="bigint")&&$l(a,""+g);break;case"onScroll":g!=null&&oe("scroll",a);break;case"onScrollEnd":g!=null&&oe("scrollend",a);break;case"onClick":g!=null&&(a.onclick=ki);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!HC.hasOwnProperty(f))t:{if(f[0]==="o"&&f[1]==="n"&&(v=f.endsWith("Capture"),u=f.slice(2,v?f.length-7:void 0),C=a[$s]||null,C=C!=null?C[f]:null,typeof C=="function"&&a.removeEventListener(u,C,v),typeof g=="function")){typeof C!="function"&&C!==null&&(f in a?a[f]=null:a.hasAttribute(f)&&a.removeAttribute(f)),a.addEventListener(u,g,v);break t}f in a?a[f]=g:g===!0?a.setAttribute(f,""):$f(a,f,g)}}}function Hn(a,u,f){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":oe("error",a),oe("load",a);var g=!1,v=!1,C;for(C in f)if(f.hasOwnProperty(C)){var I=f[C];if(I!=null)switch(C){case"src":g=!0;break;case"srcSet":v=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:Ae(a,u,C,I,f,null)}}v&&Ae(a,u,"srcSet",f.srcSet,f,null),g&&Ae(a,u,"src",f.src,f,null);return;case"input":oe("invalid",a);var O=C=I=v=null,j=null,at=null;for(g in f)if(f.hasOwnProperty(g)){var mt=f[g];if(mt!=null)switch(g){case"name":v=mt;break;case"type":I=mt;break;case"checked":j=mt;break;case"defaultChecked":at=mt;break;case"value":C=mt;break;case"defaultValue":O=mt;break;case"children":case"dangerouslySetInnerHTML":if(mt!=null)throw Error(s(137,u));break;default:Ae(a,u,g,mt,f,null)}}ZC(a,C,O,j,at,I,v,!1);return;case"select":oe("invalid",a),g=I=C=null;for(v in f)if(f.hasOwnProperty(v)&&(O=f[v],O!=null))switch(v){case"value":C=O;break;case"defaultValue":I=O;break;case"multiple":g=O;default:Ae(a,u,v,O,f,null)}u=C,f=I,a.multiple=!!g,u!=null?kl(a,!!g,u,!1):f!=null&&kl(a,!!g,f,!0);return;case"textarea":oe("invalid",a),C=v=g=null;for(I in f)if(f.hasOwnProperty(I)&&(O=f[I],O!=null))switch(I){case"value":g=O;break;case"defaultValue":v=O;break;case"children":C=O;break;case"dangerouslySetInnerHTML":if(O!=null)throw Error(s(91));break;default:Ae(a,u,I,O,f,null)}QC(a,g,v,C);return;case"option":for(j in f)f.hasOwnProperty(j)&&(g=f[j],g!=null)&&(j==="selected"?a.selected=g&&typeof g!="function"&&typeof g!="symbol":Ae(a,u,j,g,f,null));return;case"dialog":oe("beforetoggle",a),oe("toggle",a),oe("cancel",a),oe("close",a);break;case"iframe":case"object":oe("load",a);break;case"video":case"audio":for(g=0;g<Hu.length;g++)oe(Hu[g],a);break;case"image":oe("error",a),oe("load",a);break;case"details":oe("toggle",a);break;case"embed":case"source":case"link":oe("error",a),oe("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(at in f)if(f.hasOwnProperty(at)&&(g=f[at],g!=null))switch(at){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:Ae(a,u,at,g,f,null)}return;default:if(K0(u)){for(mt in f)f.hasOwnProperty(mt)&&(g=f[mt],g!==void 0&&Ob(a,u,mt,g,f,void 0));return}}for(O in f)f.hasOwnProperty(O)&&(g=f[O],g!=null&&Ae(a,u,O,g,f,null))}function qz(a,u,f,g){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var v=null,C=null,I=null,O=null,j=null,at=null,mt=null;for(ht in f){var bt=f[ht];if(f.hasOwnProperty(ht)&&bt!=null)switch(ht){case"checked":break;case"value":break;case"defaultValue":j=bt;default:g.hasOwnProperty(ht)||Ae(a,u,ht,null,g,bt)}}for(var ut in g){var ht=g[ut];if(bt=f[ut],g.hasOwnProperty(ut)&&(ht!=null||bt!=null))switch(ut){case"type":C=ht;break;case"name":v=ht;break;case"checked":at=ht;break;case"defaultChecked":mt=ht;break;case"value":I=ht;break;case"defaultValue":O=ht;break;case"children":case"dangerouslySetInnerHTML":if(ht!=null)throw Error(s(137,u));break;default:ht!==bt&&Ae(a,u,ut,ht,g,bt)}}H0(a,I,O,j,at,mt,C,v);return;case"select":ht=I=O=ut=null;for(C in f)if(j=f[C],f.hasOwnProperty(C)&&j!=null)switch(C){case"value":break;case"multiple":ht=j;default:g.hasOwnProperty(C)||Ae(a,u,C,null,g,j)}for(v in g)if(C=g[v],j=f[v],g.hasOwnProperty(v)&&(C!=null||j!=null))switch(v){case"value":ut=C;break;case"defaultValue":O=C;break;case"multiple":I=C;default:C!==j&&Ae(a,u,v,C,g,j)}u=O,f=I,g=ht,ut!=null?kl(a,!!f,ut,!1):!!g!=!!f&&(u!=null?kl(a,!!f,u,!0):kl(a,!!f,f?[]:"",!1));return;case"textarea":ht=ut=null;for(O in f)if(v=f[O],f.hasOwnProperty(O)&&v!=null&&!g.hasOwnProperty(O))switch(O){case"value":break;case"children":break;default:Ae(a,u,O,null,g,v)}for(I in g)if(v=g[I],C=f[I],g.hasOwnProperty(I)&&(v!=null||C!=null))switch(I){case"value":ut=v;break;case"defaultValue":ht=v;break;case"children":break;case"dangerouslySetInnerHTML":if(v!=null)throw Error(s(91));break;default:v!==C&&Ae(a,u,I,v,g,C)}JC(a,ut,ht);return;case"option":for(var It in f)ut=f[It],f.hasOwnProperty(It)&&ut!=null&&!g.hasOwnProperty(It)&&(It==="selected"?a.selected=!1:Ae(a,u,It,null,g,ut));for(j in g)ut=g[j],ht=f[j],g.hasOwnProperty(j)&&ut!==ht&&(ut!=null||ht!=null)&&(j==="selected"?a.selected=ut&&typeof ut!="function"&&typeof ut!="symbol":Ae(a,u,j,ut,g,ht));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var zt in f)ut=f[zt],f.hasOwnProperty(zt)&&ut!=null&&!g.hasOwnProperty(zt)&&Ae(a,u,zt,null,g,ut);for(at in g)if(ut=g[at],ht=f[at],g.hasOwnProperty(at)&&ut!==ht&&(ut!=null||ht!=null))switch(at){case"children":case"dangerouslySetInnerHTML":if(ut!=null)throw Error(s(137,u));break;default:Ae(a,u,at,ut,g,ht)}return;default:if(K0(u)){for(var _e in f)ut=f[_e],f.hasOwnProperty(_e)&&ut!==void 0&&!g.hasOwnProperty(_e)&&Ob(a,u,_e,void 0,g,ut);for(mt in g)ut=g[mt],ht=f[mt],!g.hasOwnProperty(mt)||ut===ht||ut===void 0&&ht===void 0||Ob(a,u,mt,ut,g,ht);return}}for(var st in f)ut=f[st],f.hasOwnProperty(st)&&ut!=null&&!g.hasOwnProperty(st)&&Ae(a,u,st,null,g,ut);for(bt in g)ut=g[bt],ht=f[bt],!g.hasOwnProperty(bt)||ut===ht||ut==null&&ht==null||Ae(a,u,bt,ut,g,ht)}function n$(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function Kz(){if(typeof performance.getEntriesByType=="function"){for(var a=0,u=0,f=performance.getEntriesByType("resource"),g=0;g<f.length;g++){var v=f[g],C=v.transferSize,I=v.initiatorType,O=v.duration;if(C&&O&&n$(I)){for(I=0,O=v.responseEnd,g+=1;g<f.length;g++){var j=f[g],at=j.startTime;if(at>O)break;var mt=j.transferSize,bt=j.initiatorType;mt&&n$(bt)&&(j=j.responseEnd,I+=mt*(j<O?1:(O-at)/(j-at)))}if(--g,u+=8*(C+I)/(v.duration/1e3),a++,10<a)break}}if(0<a)return u/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var Mb=null,Fb=null;function Tp(a){return a.nodeType===9?a:a.ownerDocument}function s$(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function r$(a,u){if(a===0)switch(u){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&u==="foreignObject"?0:a}function Lb(a,u){return a==="textarea"||a==="noscript"||typeof u.children=="string"||typeof u.children=="number"||typeof u.children=="bigint"||typeof u.dangerouslySetInnerHTML=="object"&&u.dangerouslySetInnerHTML!==null&&u.dangerouslySetInnerHTML.__html!=null}var Pb=null;function Xz(){var a=window.event;return a&&a.type==="popstate"?a===Pb?!1:(Pb=a,!0):(Pb=null,!1)}var i$=typeof setTimeout=="function"?setTimeout:void 0,Yz=typeof clearTimeout=="function"?clearTimeout:void 0,o$=typeof Promise=="function"?Promise:void 0,Zz=typeof queueMicrotask=="function"?queueMicrotask:typeof o$<"u"?function(a){return o$.resolve(null).then(a).catch(Jz)}:i$;function Jz(a){setTimeout(function(){throw a})}function So(a){return a==="head"}function a$(a,u){var f=u,g=0;do{var v=f.nextSibling;if(a.removeChild(f),v&&v.nodeType===8)if(f=v.data,f==="/$"||f==="/&"){if(g===0){a.removeChild(v),sc(u);return}g--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")g++;else if(f==="html")Ku(a.ownerDocument.documentElement);else if(f==="head"){f=a.ownerDocument.head,Ku(f);for(var C=f.firstChild;C;){var I=C.nextSibling,O=C.nodeName;C[du]||O==="SCRIPT"||O==="STYLE"||O==="LINK"&&C.rel.toLowerCase()==="stylesheet"||f.removeChild(C),C=I}}else f==="body"&&Ku(a.ownerDocument.body);f=v}while(f);sc(u)}function l$(a,u){var f=a;a=0;do{var g=f.nextSibling;if(f.nodeType===1?u?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(u?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),g&&g.nodeType===8)if(f=g.data,f==="/$"){if(a===0)break;a--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||a++;f=g}while(f)}function zb(a){var u=a.firstChild;for(u&&u.nodeType===10&&(u=u.nextSibling);u;){var f=u;switch(u=u.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":zb(f),G0(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}a.removeChild(f)}}function Qz(a,u,f,g){for(;a.nodeType===1;){var v=f;if(a.nodeName.toLowerCase()!==u.toLowerCase()){if(!g&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(g){if(!a[du])switch(u){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(C=a.getAttribute("rel"),C==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(C!==v.rel||a.getAttribute("href")!==(v.href==null||v.href===""?null:v.href)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin)||a.getAttribute("title")!==(v.title==null?null:v.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(C=a.getAttribute("src"),(C!==(v.src==null?null:v.src)||a.getAttribute("type")!==(v.type==null?null:v.type)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin))&&C&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(u==="input"&&a.type==="hidden"){var C=v.name==null?null:""+v.name;if(v.type==="hidden"&&a.getAttribute("name")===C)return a}else return a;if(a=pr(a.nextSibling),a===null)break}return null}function tB(a,u,f){if(u==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!f||(a=pr(a.nextSibling),a===null))return null;return a}function c$(a,u){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!u||(a=pr(a.nextSibling),a===null))return null;return a}function Bb(a){return a.data==="$?"||a.data==="$~"}function Vb(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function eB(a,u){var f=a.ownerDocument;if(a.data==="$~")a._reactRetry=u;else if(a.data!=="$?"||f.readyState!=="loading")u();else{var g=function(){u(),f.removeEventListener("DOMContentLoaded",g)};f.addEventListener("DOMContentLoaded",g),a._reactRetry=g}}function pr(a){for(;a!=null;a=a.nextSibling){var u=a.nodeType;if(u===1||u===3)break;if(u===8){if(u=a.data,u==="$"||u==="$!"||u==="$?"||u==="$~"||u==="&"||u==="F!"||u==="F")break;if(u==="/$"||u==="/&")return null}}return a}var Ub=null;function u$(a){a=a.nextSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="/$"||f==="/&"){if(u===0)return pr(a.nextSibling);u--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||u++}a=a.nextSibling}return null}function h$(a){a=a.previousSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(u===0)return a;u--}else f!=="/$"&&f!=="/&"||u++}a=a.previousSibling}return null}function d$(a,u,f){switch(u=Tp(f),a){case"html":if(a=u.documentElement,!a)throw Error(s(452));return a;case"head":if(a=u.head,!a)throw Error(s(453));return a;case"body":if(a=u.body,!a)throw Error(s(454));return a;default:throw Error(s(451))}}function Ku(a){for(var u=a.attributes;u.length;)a.removeAttributeNode(u[0]);G0(a)}var mr=new Map,f$=new Set;function kp(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var Vi=U.d;U.d={f:nB,r:sB,D:rB,C:iB,L:oB,m:aB,X:cB,S:lB,M:uB};function nB(){var a=Vi.f(),u=gp();return a||u}function sB(a){var u=Sl(a);u!==null&&u.tag===5&&u.type==="form"?Ak(u):Vi.r(a)}var tc=typeof document>"u"?null:document;function p$(a,u,f){var g=tc;if(g&&typeof u=="string"&&u){var v=ar(u);v='link[rel="'+a+'"][href="'+v+'"]',typeof f=="string"&&(v+='[crossorigin="'+f+'"]'),f$.has(v)||(f$.add(v),a={rel:a,crossOrigin:f,href:u},g.querySelector(v)===null&&(u=g.createElement("link"),Hn(u,"link",a),Mn(u),g.head.appendChild(u)))}}function rB(a){Vi.D(a),p$("dns-prefetch",a,null)}function iB(a,u){Vi.C(a,u),p$("preconnect",a,u)}function oB(a,u,f){Vi.L(a,u,f);var g=tc;if(g&&a&&u){var v='link[rel="preload"][as="'+ar(u)+'"]';u==="image"&&f&&f.imageSrcSet?(v+='[imagesrcset="'+ar(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(v+='[imagesizes="'+ar(f.imageSizes)+'"]')):v+='[href="'+ar(a)+'"]';var C=v;switch(u){case"style":C=ec(a);break;case"script":C=nc(a)}mr.has(C)||(a=p({rel:"preload",href:u==="image"&&f&&f.imageSrcSet?void 0:a,as:u},f),mr.set(C,a),g.querySelector(v)!==null||u==="style"&&g.querySelector(Xu(C))||u==="script"&&g.querySelector(Yu(C))||(u=g.createElement("link"),Hn(u,"link",a),Mn(u),g.head.appendChild(u)))}}function aB(a,u){Vi.m(a,u);var f=tc;if(f&&a){var g=u&&typeof u.as=="string"?u.as:"script",v='link[rel="modulepreload"][as="'+ar(g)+'"][href="'+ar(a)+'"]',C=v;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":C=nc(a)}if(!mr.has(C)&&(a=p({rel:"modulepreload",href:a},u),mr.set(C,a),f.querySelector(v)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(Yu(C)))return}g=f.createElement("link"),Hn(g,"link",a),Mn(g),f.head.appendChild(g)}}}function lB(a,u,f){Vi.S(a,u,f);var g=tc;if(g&&a){var v=Cl(g).hoistableStyles,C=ec(a);u=u||"default";var I=v.get(C);if(!I){var O={loading:0,preload:null};if(I=g.querySelector(Xu(C)))O.loading=5;else{a=p({rel:"stylesheet",href:a,"data-precedence":u},f),(f=mr.get(C))&&jb(a,f);var j=I=g.createElement("link");Mn(j),Hn(j,"link",a),j._p=new Promise(function(at,mt){j.onload=at,j.onerror=mt}),j.addEventListener("load",function(){O.loading|=1}),j.addEventListener("error",function(){O.loading|=2}),O.loading|=4,$p(I,u,g)}I={type:"stylesheet",instance:I,count:1,state:O},v.set(C,I)}}}function cB(a,u){Vi.X(a,u);var f=tc;if(f&&a){var g=Cl(f).hoistableScripts,v=nc(a),C=g.get(v);C||(C=f.querySelector(Yu(v)),C||(a=p({src:a,async:!0},u),(u=mr.get(v))&&Gb(a,u),C=f.createElement("script"),Mn(C),Hn(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function uB(a,u){Vi.M(a,u);var f=tc;if(f&&a){var g=Cl(f).hoistableScripts,v=nc(a),C=g.get(v);C||(C=f.querySelector(Yu(v)),C||(a=p({src:a,async:!0,type:"module"},u),(u=mr.get(v))&&Gb(a,u),C=f.createElement("script"),Mn(C),Hn(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function m$(a,u,f,g){var v=(v=gt.current)?kp(v):null;if(!v)throw Error(s(446));switch(a){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(u=ec(f.href),f=Cl(v).hoistableStyles,g=f.get(u),g||(g={type:"style",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){a=ec(f.href);var C=Cl(v).hoistableStyles,I=C.get(a);if(I||(v=v.ownerDocument||v,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},C.set(a,I),(C=v.querySelector(Xu(a)))&&!C._p&&(I.instance=C,I.state.loading=5),mr.has(a)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},mr.set(a,f),C||hB(v,a,f,I.state))),u&&g===null)throw Error(s(528,""));return I}if(u&&g!==null)throw Error(s(529,""));return null;case"script":return u=f.async,f=f.src,typeof f=="string"&&u&&typeof u!="function"&&typeof u!="symbol"?(u=nc(f),f=Cl(v).hoistableScripts,g=f.get(u),g||(g={type:"script",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,a))}}function ec(a){return'href="'+ar(a)+'"'}function Xu(a){return'link[rel="stylesheet"]['+a+"]"}function g$(a){return p({},a,{"data-precedence":a.precedence,precedence:null})}function hB(a,u,f,g){a.querySelector('link[rel="preload"][as="style"]['+u+"]")?g.loading=1:(u=a.createElement("link"),g.preload=u,u.addEventListener("load",function(){return g.loading|=1}),u.addEventListener("error",function(){return g.loading|=2}),Hn(u,"link",f),Mn(u),a.head.appendChild(u))}function nc(a){return'[src="'+ar(a)+'"]'}function Yu(a){return"script[async]"+a}function y$(a,u,f){if(u.count++,u.instance===null)switch(u.type){case"style":var g=a.querySelector('style[data-href~="'+ar(f.href)+'"]');if(g)return u.instance=g,Mn(g),g;var v=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return g=(a.ownerDocument||a).createElement("style"),Mn(g),Hn(g,"style",v),$p(g,f.precedence,a),u.instance=g;case"stylesheet":v=ec(f.href);var C=a.querySelector(Xu(v));if(C)return u.state.loading|=4,u.instance=C,Mn(C),C;g=g$(f),(v=mr.get(v))&&jb(g,v),C=(a.ownerDocument||a).createElement("link"),Mn(C);var I=C;return I._p=new Promise(function(O,j){I.onload=O,I.onerror=j}),Hn(C,"link",g),u.state.loading|=4,$p(C,f.precedence,a),u.instance=C;case"script":return C=nc(f.src),(v=a.querySelector(Yu(C)))?(u.instance=v,Mn(v),v):(g=f,(v=mr.get(C))&&(g=p({},f),Gb(g,v)),a=a.ownerDocument||a,v=a.createElement("script"),Mn(v),Hn(v,"link",g),a.head.appendChild(v),u.instance=v);case"void":return null;default:throw Error(s(443,u.type))}else u.type==="stylesheet"&&(u.state.loading&4)===0&&(g=u.instance,u.state.loading|=4,$p(g,f.precedence,a));return u.instance}function $p(a,u,f){for(var g=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),v=g.length?g[g.length-1]:null,C=v,I=0;I<g.length;I++){var O=g[I];if(O.dataset.precedence===u)C=O;else if(C!==v)break}C?C.parentNode.insertBefore(a,C.nextSibling):(u=f.nodeType===9?f.head:f,u.insertBefore(a,u.firstChild))}function jb(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.title==null&&(a.title=u.title)}function Gb(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.integrity==null&&(a.integrity=u.integrity)}var Ep=null;function b$(a,u,f){if(Ep===null){var g=new Map,v=Ep=new Map;v.set(f,g)}else v=Ep,g=v.get(f),g||(g=new Map,v.set(f,g));if(g.has(a))return g;for(g.set(a,null),f=f.getElementsByTagName(a),v=0;v<f.length;v++){var C=f[v];if(!(C[du]||C[Un]||a==="link"&&C.getAttribute("rel")==="stylesheet")&&C.namespaceURI!=="http://www.w3.org/2000/svg"){var I=C.getAttribute(u)||"";I=a+I;var O=g.get(I);O?O.push(C):g.set(I,[C])}}return g}function x$(a,u,f){a=a.ownerDocument||a,a.head.insertBefore(f,u==="title"?a.querySelector("head > title"):null)}function dB(a,u,f){if(f===1||u.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof u.precedence!="string"||typeof u.href!="string"||u.href==="")break;return!0;case"link":if(typeof u.rel!="string"||typeof u.href!="string"||u.href===""||u.onLoad||u.onError)break;return u.rel==="stylesheet"?(a=u.disabled,typeof u.precedence=="string"&&a==null):!0;case"script":if(u.async&&typeof u.async!="function"&&typeof u.async!="symbol"&&!u.onLoad&&!u.onError&&u.src&&typeof u.src=="string")return!0}return!1}function v$(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function fB(a,u,f,g){if(f.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var v=ec(g.href),C=u.querySelector(Xu(v));if(C){u=C._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(a.count++,a=Ip.bind(a),u.then(a,a)),f.state.loading|=4,f.instance=C,Mn(C);return}C=u.ownerDocument||u,g=g$(g),(v=mr.get(v))&&jb(g,v),C=C.createElement("link"),Mn(C);var I=C;I._p=new Promise(function(O,j){I.onload=O,I.onerror=j}),Hn(C,"link",g),f.instance=C}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(f,u),(u=f.state.preload)&&(f.state.loading&3)===0&&(a.count++,f=Ip.bind(a),u.addEventListener("load",f),u.addEventListener("error",f))}}var Wb=0;function pB(a,u){return a.stylesheets&&a.count===0&&Ap(a,a.stylesheets),0<a.count||0<a.imgCount?function(f){var g=setTimeout(function(){if(a.stylesheets&&Ap(a,a.stylesheets),a.unsuspend){var C=a.unsuspend;a.unsuspend=null,C()}},6e4+u);0<a.imgBytes&&Wb===0&&(Wb=62500*Kz());var v=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&Ap(a,a.stylesheets),a.unsuspend)){var C=a.unsuspend;a.unsuspend=null,C()}},(a.imgBytes>Wb?50:800)+u);return a.unsuspend=f,function(){a.unsuspend=null,clearTimeout(g),clearTimeout(v)}}:null}function Ip(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Ap(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var Np=null;function Ap(a,u){a.stylesheets=null,a.unsuspend!==null&&(a.count++,Np=new Map,u.forEach(mB,a),Np=null,Ip.call(a))}function mB(a,u){if(!(u.state.loading&4)){var f=Np.get(a);if(f)var g=f.get(null);else{f=new Map,Np.set(a,f);for(var v=a.querySelectorAll("link[data-precedence],style[data-precedence]"),C=0;C<v.length;C++){var I=v[C];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(f.set(I.dataset.precedence,I),g=I)}g&&f.set(null,g)}v=u.instance,I=v.getAttribute("data-precedence"),C=f.get(I)||g,C===g&&f.set(null,v),f.set(I,v),this.count++,g=Ip.bind(this),v.addEventListener("load",g),v.addEventListener("error",g),C?C.parentNode.insertBefore(v,C.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(v,a.firstChild)),u.state.loading|=4}}var Zu={$$typeof:k,Provider:null,Consumer:null,_currentValue:G,_currentValue2:G,_threadCount:0};function gB(a,u,f,g,v,C,I,O,j){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=B0(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=B0(0),this.hiddenUpdates=B0(null),this.identifierPrefix=g,this.onUncaughtError=v,this.onCaughtError=C,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=j,this.incompleteTransitions=new Map}function w$(a,u,f,g,v,C,I,O,j,at,mt,bt){return a=new gB(a,u,f,I,j,at,mt,bt,O),u=1,C===!0&&(u|=24),C=Gs(3,null,null,u),a.current=C,C.stateNode=a,u=Ty(),u.refCount++,a.pooledCache=u,u.refCount++,C.memoizedState={element:g,isDehydrated:f,cache:u},Iy(C),a}function S$(a){return a?(a=Dl,a):Dl}function C$(a,u,f,g,v,C){v=S$(v),g.context===null?g.context=v:g.pendingContext=v,g=uo(u),g.payload={element:f},C=C===void 0?null:C,C!==null&&(g.callback=C),f=ho(a,g,u),f!==null&&(Rs(f,a,u),Nu(f,a,u))}function T$(a,u){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var f=a.retryLane;a.retryLane=f!==0&&f<u?f:u}}function Hb(a,u){T$(a,u),(a=a.alternate)&&T$(a,u)}function k$(a){if(a.tag===13||a.tag===31){var u=ua(a,67108864);u!==null&&Rs(u,a,67108864),Hb(a,67108864)}}function $$(a){if(a.tag===13||a.tag===31){var u=Xs();u=V0(u);var f=ua(a,u);f!==null&&Rs(f,a,u),Hb(a,u)}}var _p=!0;function yB(a,u,f,g){var v=P.T;P.T=null;var C=U.p;try{U.p=2,qb(a,u,f,g)}finally{U.p=C,P.T=v}}function bB(a,u,f,g){var v=P.T;P.T=null;var C=U.p;try{U.p=8,qb(a,u,f,g)}finally{U.p=C,P.T=v}}function qb(a,u,f,g){if(_p){var v=Kb(g);if(v===null)Db(a,u,g,Rp,f),I$(a,g);else if(vB(v,a,u,f,g))g.stopPropagation();else if(I$(a,g),u&4&&-1<xB.indexOf(a)){for(;v!==null;){var C=Sl(v);if(C!==null)switch(C.tag){case 3:if(C=C.stateNode,C.current.memoizedState.isDehydrated){var I=ia(C.pendingLanes);if(I!==0){var O=C;for(O.pendingLanes|=2,O.entangledLanes|=2;I;){var j=1<<31-Us(I);O.entanglements[1]|=j,I&=~j}si(C),(Se&6)===0&&(pp=De()+500,Wu(0))}}break;case 31:case 13:O=ua(C,2),O!==null&&Rs(O,C,2),gp(),Hb(C,2)}if(C=Kb(g),C===null&&Db(a,u,g,Rp,f),C===v)break;v=C}v!==null&&g.stopPropagation()}else Db(a,u,g,null,f)}}function Kb(a){return a=Y0(a),Xb(a)}var Rp=null;function Xb(a){if(Rp=null,a=wl(a),a!==null){var u=i(a);if(u===null)a=null;else{var f=u.tag;if(f===13){if(a=o(u),a!==null)return a;a=null}else if(f===31){if(a=l(u),a!==null)return a;a=null}else if(f===3){if(u.stateNode.current.memoizedState.isDehydrated)return u.tag===3?u.stateNode.containerInfo:null;a=null}else u!==a&&(a=null)}}return Rp=a,null}function E$(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Bs()){case Vs:return 2;case Pt:return 8;case se:case ps:return 32;case _r:return 268435456;default:return 32}default:return 32}}var Yb=!1,Co=null,To=null,ko=null,Ju=new Map,Qu=new Map,$o=[],xB="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function I$(a,u){switch(a){case"focusin":case"focusout":Co=null;break;case"dragenter":case"dragleave":To=null;break;case"mouseover":case"mouseout":ko=null;break;case"pointerover":case"pointerout":Ju.delete(u.pointerId);break;case"gotpointercapture":case"lostpointercapture":Qu.delete(u.pointerId)}}function th(a,u,f,g,v,C){return a===null||a.nativeEvent!==C?(a={blockedOn:u,domEventName:f,eventSystemFlags:g,nativeEvent:C,targetContainers:[v]},u!==null&&(u=Sl(u),u!==null&&k$(u)),a):(a.eventSystemFlags|=g,u=a.targetContainers,v!==null&&u.indexOf(v)===-1&&u.push(v),a)}function vB(a,u,f,g,v){switch(u){case"focusin":return Co=th(Co,a,u,f,g,v),!0;case"dragenter":return To=th(To,a,u,f,g,v),!0;case"mouseover":return ko=th(ko,a,u,f,g,v),!0;case"pointerover":var C=v.pointerId;return Ju.set(C,th(Ju.get(C)||null,a,u,f,g,v)),!0;case"gotpointercapture":return C=v.pointerId,Qu.set(C,th(Qu.get(C)||null,a,u,f,g,v)),!0}return!1}function N$(a){var u=wl(a.target);if(u!==null){var f=i(u);if(f!==null){if(u=f.tag,u===13){if(u=o(f),u!==null){a.blockedOn=u,jC(a.priority,function(){$$(f)});return}}else if(u===31){if(u=l(f),u!==null){a.blockedOn=u,jC(a.priority,function(){$$(f)});return}}else if(u===3&&f.stateNode.current.memoizedState.isDehydrated){a.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Dp(a){if(a.blockedOn!==null)return!1;for(var u=a.targetContainers;0<u.length;){var f=Kb(a.nativeEvent);if(f===null){f=a.nativeEvent;var g=new f.constructor(f.type,f);X0=g,f.target.dispatchEvent(g),X0=null}else return u=Sl(f),u!==null&&k$(u),a.blockedOn=f,!1;u.shift()}return!0}function A$(a,u,f){Dp(a)&&f.delete(u)}function wB(){Yb=!1,Co!==null&&Dp(Co)&&(Co=null),To!==null&&Dp(To)&&(To=null),ko!==null&&Dp(ko)&&(ko=null),Ju.forEach(A$),Qu.forEach(A$)}function Op(a,u){a.blockedOn===u&&(a.blockedOn=null,Yb||(Yb=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,wB)))}var Mp=null;function _$(a){Mp!==a&&(Mp=a,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Mp===a&&(Mp=null);for(var u=0;u<a.length;u+=3){var f=a[u],g=a[u+1],v=a[u+2];if(typeof g!="function"){if(Xb(g||f)===null)continue;break}var C=Sl(f);C!==null&&(a.splice(u,3),u-=3,Ky(C,{pending:!0,data:v,method:f.method,action:g},g,v))}}))}function sc(a){function u(j){return Op(j,a)}Co!==null&&Op(Co,a),To!==null&&Op(To,a),ko!==null&&Op(ko,a),Ju.forEach(u),Qu.forEach(u);for(var f=0;f<$o.length;f++){var g=$o[f];g.blockedOn===a&&(g.blockedOn=null)}for(;0<$o.length&&(f=$o[0],f.blockedOn===null);)N$(f),f.blockedOn===null&&$o.shift();if(f=(a.ownerDocument||a).$$reactFormReplay,f!=null)for(g=0;g<f.length;g+=3){var v=f[g],C=f[g+1],I=v[$s]||null;if(typeof C=="function")I||_$(f);else if(I){var O=null;if(C&&C.hasAttribute("formAction")){if(v=C,I=C[$s]||null)O=I.formAction;else if(Xb(v)!==null)continue}else O=I.action;typeof O=="function"?f[g+1]=O:(f.splice(g,3),g-=3),_$(f)}}}function R$(){function a(C){C.canIntercept&&C.info==="react-transition"&&C.intercept({handler:function(){return new Promise(function(I){return v=I})},focusReset:"manual",scroll:"manual"})}function u(){v!==null&&(v(),v=null),g||setTimeout(f,20)}function f(){if(!g&&!navigation.transition){var C=navigation.currentEntry;C&&C.url!=null&&navigation.navigate(C.url,{state:C.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,v=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",u),navigation.addEventListener("navigateerror",u),setTimeout(f,100),function(){g=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",u),navigation.removeEventListener("navigateerror",u),v!==null&&(v(),v=null)}}}function Zb(a){this._internalRoot=a}Fp.prototype.render=Zb.prototype.render=function(a){var u=this._internalRoot;if(u===null)throw Error(s(409));var f=u.current,g=Xs();C$(f,g,a,u,null,null)},Fp.prototype.unmount=Zb.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var u=a.containerInfo;C$(a.current,2,null,a,null,null),gp(),u[vl]=null}};function Fp(a){this._internalRoot=a}Fp.prototype.unstable_scheduleHydration=function(a){if(a){var u=UC();a={blockedOn:null,target:a,priority:u};for(var f=0;f<$o.length&&u!==0&&u<$o[f].priority;f++);$o.splice(f,0,a),f===0&&N$(a)}};var D$=t.version;if(D$!=="19.2.3")throw Error(s(527,D$,"19.2.3"));U.findDOMNode=function(a){var u=a._reactInternals;if(u===void 0)throw typeof a.render=="function"?Error(s(188)):(a=Object.keys(a).join(","),Error(s(268,a)));return a=h(u),a=a!==null?d(a):null,a=a===null?null:a.stateNode,a};var SB={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:P,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Lp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Lp.isDisabled&&Lp.supportsFiber)try{ns=Lp.inject(SB),Be=Lp}catch{}}return nh.createRoot=function(a,u){if(!r(a))throw Error(s(299));var f=!1,g="",v=Bk,C=Vk,I=Uk;return u!=null&&(u.unstable_strictMode===!0&&(f=!0),u.identifierPrefix!==void 0&&(g=u.identifierPrefix),u.onUncaughtError!==void 0&&(v=u.onUncaughtError),u.onCaughtError!==void 0&&(C=u.onCaughtError),u.onRecoverableError!==void 0&&(I=u.onRecoverableError)),u=w$(a,1,!1,null,null,f,g,null,v,C,I,R$),a[vl]=u.current,Rb(a),new Zb(u)},nh.hydrateRoot=function(a,u,f){if(!r(a))throw Error(s(299));var g=!1,v="",C=Bk,I=Vk,O=Uk,j=null;return f!=null&&(f.unstable_strictMode===!0&&(g=!0),f.identifierPrefix!==void 0&&(v=f.identifierPrefix),f.onUncaughtError!==void 0&&(C=f.onUncaughtError),f.onCaughtError!==void 0&&(I=f.onCaughtError),f.onRecoverableError!==void 0&&(O=f.onRecoverableError),f.formState!==void 0&&(j=f.formState)),u=w$(a,1,!0,u,f??null,g,v,j,C,I,O,R$),u.context=S$(null),f=u.current,g=Xs(),g=V0(g),v=uo(g),v.callback=null,ho(f,v,g),f=g,u.current.lanes=f,hu(u,f),si(u),a[vl]=u.current,Rb(a),new Fp(u)},nh.version="19.2.3",nh}var j$;function MB(){if(j$)return tx.exports;j$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),tx.exports=OB(),tx.exports}var FB=MB();const LB=dw(FB),pw=St.createContext({});function mw(n){const t=St.useRef(null);return t.current===null&&(t.current=n()),t.current}const gw=typeof window<"u",EA=gw?St.useLayoutEffect:St.useEffect,rg=St.createContext(null);function yw(n,t){n.indexOf(t)===-1&&n.push(t)}function bw(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const Hi=(n,t,e)=>e>t?t:e<n?n:e;let xw=()=>{};const qi={},IA=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function NA(n){return typeof n=="object"&&n!==null}const AA=n=>/^0[^.\s]+$/u.test(n);function vw(n){let t;return()=>(t===void 0&&(t=n()),t)}const Tr=n=>n,PB=(n,t)=>e=>t(n(e)),Yh=(...n)=>n.reduce(PB),$h=(n,t,e)=>{const s=t-n;return s===0?1:(e-n)/s};class ww{constructor(){this.subscriptions=[]}add(t){return yw(this.subscriptions,t),()=>bw(this.subscriptions,t)}notify(t,e,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](t,e,s);else for(let i=0;i<r;i++){const o=this.subscriptions[i];o&&o(t,e,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const ui=n=>n*1e3,wr=n=>n/1e3;function _A(n,t){return t?n*(1e3/t):0}const RA=(n,t,e)=>(((1-3*e+3*t)*n+(3*e-6*t))*n+3*t)*n,zB=1e-7,BB=12;function VB(n,t,e,s,r){let i,o,l=0;do o=t+(e-t)/2,i=RA(o,s,r)-n,i>0?e=o:t=o;while(Math.abs(i)>zB&&++l<BB);return o}function Zh(n,t,e,s){if(n===t&&e===s)return Tr;const r=i=>VB(i,0,1,n,e);return i=>i===0||i===1?i:RA(r(i),t,s)}const DA=n=>t=>t<=.5?n(2*t)/2:(2-n(2*(1-t)))/2,OA=n=>t=>1-n(1-t),MA=Zh(.33,1.53,.69,.99),Sw=OA(MA),FA=DA(Sw),LA=n=>(n*=2)<1?.5*Sw(n):.5*(2-Math.pow(2,-10*(n-1))),Cw=n=>1-Math.sin(Math.acos(n)),PA=OA(Cw),zA=DA(Cw),UB=Zh(.42,0,1,1),jB=Zh(0,0,.58,1),BA=Zh(.42,0,.58,1),GB=n=>Array.isArray(n)&&typeof n[0]!="number",VA=n=>Array.isArray(n)&&typeof n[0]=="number",WB={linear:Tr,easeIn:UB,easeInOut:BA,easeOut:jB,circIn:Cw,circInOut:zA,circOut:PA,backIn:Sw,backInOut:FA,backOut:MA,anticipate:LA},HB=n=>typeof n=="string",G$=n=>{if(VA(n)){xw(n.length===4);const[t,e,s,r]=n;return Zh(t,e,s,r)}else if(HB(n))return WB[n];return n},Pp=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function qB(n,t){let e=new Set,s=new Set,r=!1,i=!1;const o=new WeakSet;let l={delta:0,timestamp:0,isProcessing:!1};function c(d){o.has(d)&&(h.schedule(d),n()),d(l)}const h={schedule:(d,p=!1,m=!1)=>{const b=m&&r?e:s;return p&&o.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),o.delete(d)},process:d=>{if(l=d,r){i=!0;return}r=!0,[e,s]=[s,e],e.forEach(c),e.clear(),r=!1,i&&(i=!1,h.process(d))}};return h}const KB=40;function UA(n,t){let e=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},i=()=>e=!0,o=Pp.reduce((k,$)=>(k[$]=qB(i),k),{}),{setup:l,read:c,resolveKeyframes:h,preUpdate:d,update:p,preRender:m,render:y,postRender:b}=o,x=()=>{const k=qi.useManualTiming?r.timestamp:performance.now();e=!1,qi.useManualTiming||(r.delta=s?1e3/60:Math.max(Math.min(k-r.timestamp,KB),1)),r.timestamp=k,r.isProcessing=!0,l.process(r),c.process(r),h.process(r),d.process(r),p.process(r),m.process(r),y.process(r),b.process(r),r.isProcessing=!1,e&&t&&(s=!1,n(x))},w=()=>{e=!0,s=!0,r.isProcessing||n(x)};return{schedule:Pp.reduce((k,$)=>{const E=o[$];return k[$]=(N,_=!1,R=!1)=>(e||w(),E.schedule(N,_,R)),k},{}),cancel:k=>{for(let $=0;$<Pp.length;$++)o[Pp[$]].cancel(k)},state:r,steps:o}}const{schedule:qe,cancel:zo,state:Xn,steps:rx}=UA(typeof requestAnimationFrame<"u"?requestAnimationFrame:Tr,!0);let im;function XB(){im=void 0}const Ms={now:()=>(im===void 0&&Ms.set(Xn.isProcessing||qi.useManualTiming?Xn.timestamp:performance.now()),im),set:n=>{im=n,queueMicrotask(XB)}},jA=n=>t=>typeof t=="string"&&t.startsWith(n),GA=jA("--"),YB=jA("var(--"),Tw=n=>YB(n)?ZB.test(n.split("/*")[0].trim()):!1,ZB=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Wc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},Eh={...Wc,transform:n=>Hi(0,1,n)},zp={...Wc,default:1},yh=n=>Math.round(n*1e5)/1e5,kw=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function JB(n){return n==null}const QB=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,$w=(n,t)=>e=>!!(typeof e=="string"&&QB.test(e)&&e.startsWith(n)||t&&!JB(e)&&Object.prototype.hasOwnProperty.call(e,t)),WA=(n,t,e)=>s=>{if(typeof s!="string")return s;const[r,i,o,l]=s.match(kw);return{[n]:parseFloat(r),[t]:parseFloat(i),[e]:parseFloat(o),alpha:l!==void 0?parseFloat(l):1}},tV=n=>Hi(0,255,n),ix={...Wc,transform:n=>Math.round(tV(n))},Pa={test:$w("rgb","red"),parse:WA("red","green","blue"),transform:({red:n,green:t,blue:e,alpha:s=1})=>"rgba("+ix.transform(n)+", "+ix.transform(t)+", "+ix.transform(e)+", "+yh(Eh.transform(s))+")"};function eV(n){let t="",e="",s="",r="";return n.length>5?(t=n.substring(1,3),e=n.substring(3,5),s=n.substring(5,7),r=n.substring(7,9)):(t=n.substring(1,2),e=n.substring(2,3),s=n.substring(3,4),r=n.substring(4,5),t+=t,e+=e,s+=s,r+=r),{red:parseInt(t,16),green:parseInt(e,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const Xx={test:$w("#"),parse:eV,transform:Pa.transform},Jh=n=>({test:t=>typeof t=="string"&&t.endsWith(n)&&t.split(" ").length===1,parse:parseFloat,transform:t=>`${t}${n}`}),Io=Jh("deg"),hi=Jh("%"),Wt=Jh("px"),nV=Jh("vh"),sV=Jh("vw"),W$={...hi,parse:n=>hi.parse(n)/100,transform:n=>hi.transform(n*100)},xc={test:$w("hsl","hue"),parse:WA("hue","saturation","lightness"),transform:({hue:n,saturation:t,lightness:e,alpha:s=1})=>"hsla("+Math.round(n)+", "+hi.transform(yh(t))+", "+hi.transform(yh(e))+", "+yh(Eh.transform(s))+")"},bn={test:n=>Pa.test(n)||Xx.test(n)||xc.test(n),parse:n=>Pa.test(n)?Pa.parse(n):xc.test(n)?xc.parse(n):Xx.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?Pa.transform(n):xc.transform(n),getAnimatableNone:n=>{const t=bn.parse(n);return t.alpha=0,bn.transform(t)}},rV=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function iV(n){return isNaN(n)&&typeof n=="string"&&(n.match(kw)?.length||0)+(n.match(rV)?.length||0)>0}const HA="number",qA="color",oV="var",aV="var(",H$="${}",lV=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Ih(n){const t=n.toString(),e=[],s={color:[],number:[],var:[]},r=[];let i=0;const l=t.replace(lV,c=>(bn.test(c)?(s.color.push(i),r.push(qA),e.push(bn.parse(c))):c.startsWith(aV)?(s.var.push(i),r.push(oV),e.push(c)):(s.number.push(i),r.push(HA),e.push(parseFloat(c))),++i,H$)).split(H$);return{values:e,split:l,indexes:s,types:r}}function KA(n){return Ih(n).values}function XA(n){const{split:t,types:e}=Ih(n),s=t.length;return r=>{let i="";for(let o=0;o<s;o++)if(i+=t[o],r[o]!==void 0){const l=e[o];l===HA?i+=yh(r[o]):l===qA?i+=bn.transform(r[o]):i+=r[o]}return i}}const cV=n=>typeof n=="number"?0:bn.test(n)?bn.getAnimatableNone(n):n;function uV(n){const t=KA(n);return XA(n)(t.map(cV))}const Bo={test:iV,parse:KA,createTransformer:XA,getAnimatableNone:uV};function ox(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+(t-n)*6*e:e<1/2?t:e<2/3?n+(t-n)*(2/3-e)*6:n}function hV({hue:n,saturation:t,lightness:e,alpha:s}){n/=360,t/=100,e/=100;let r=0,i=0,o=0;if(!t)r=i=o=e;else{const l=e<.5?e*(1+t):e+t-e*t,c=2*e-l;r=ox(c,l,n+1/3),i=ox(c,l,n),o=ox(c,l,n-1/3)}return{red:Math.round(r*255),green:Math.round(i*255),blue:Math.round(o*255),alpha:s}}function bm(n,t){return e=>e>0?t:n}const Ze=(n,t,e)=>n+(t-n)*e,ax=(n,t,e)=>{const s=n*n,r=e*(t*t-s)+s;return r<0?0:Math.sqrt(r)},dV=[Xx,Pa,xc],fV=n=>dV.find(t=>t.test(n));function q$(n){const t=fV(n);if(!t)return!1;let e=t.parse(n);return t===xc&&(e=hV(e)),e}const K$=(n,t)=>{const e=q$(n),s=q$(t);if(!e||!s)return bm(n,t);const r={...e};return i=>(r.red=ax(e.red,s.red,i),r.green=ax(e.green,s.green,i),r.blue=ax(e.blue,s.blue,i),r.alpha=Ze(e.alpha,s.alpha,i),Pa.transform(r))},Yx=new Set(["none","hidden"]);function pV(n,t){return Yx.has(n)?e=>e<=0?n:t:e=>e>=1?t:n}function mV(n,t){return e=>Ze(n,t,e)}function Ew(n){return typeof n=="number"?mV:typeof n=="string"?Tw(n)?bm:bn.test(n)?K$:bV:Array.isArray(n)?YA:typeof n=="object"?bn.test(n)?K$:gV:bm}function YA(n,t){const e=[...n],s=e.length,r=n.map((i,o)=>Ew(i)(i,t[o]));return i=>{for(let o=0;o<s;o++)e[o]=r[o](i);return e}}function gV(n,t){const e={...n,...t},s={};for(const r in e)n[r]!==void 0&&t[r]!==void 0&&(s[r]=Ew(n[r])(n[r],t[r]));return r=>{for(const i in s)e[i]=s[i](r);return e}}function yV(n,t){const e=[],s={color:0,var:0,number:0};for(let r=0;r<t.values.length;r++){const i=t.types[r],o=n.indexes[i][s[i]],l=n.values[o]??0;e[r]=l,s[i]++}return e}const bV=(n,t)=>{const e=Bo.createTransformer(t),s=Ih(n),r=Ih(t);return s.indexes.var.length===r.indexes.var.length&&s.indexes.color.length===r.indexes.color.length&&s.indexes.number.length>=r.indexes.number.length?Yx.has(n)&&!r.values.length||Yx.has(t)&&!s.values.length?pV(n,t):Yh(YA(yV(s,r),r.values),e):bm(n,t)};function ZA(n,t,e){return typeof n=="number"&&typeof t=="number"&&typeof e=="number"?Ze(n,t,e):Ew(n)(n,t)}const xV=n=>{const t=({timestamp:e})=>n(e);return{start:(e=!0)=>qe.update(t,e),stop:()=>zo(t),now:()=>Xn.isProcessing?Xn.timestamp:Ms.now()}},JA=(n,t,e=10)=>{let s="";const r=Math.max(Math.round(t/e),2);for(let i=0;i<r;i++)s+=Math.round(n(i/(r-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},xm=2e4;function Iw(n){let t=0;const e=50;let s=n.next(t);for(;!s.done&&t<xm;)t+=e,s=n.next(t);return t>=xm?1/0:t}function vV(n,t=100,e){const s=e({...n,keyframes:[0,t]}),r=Math.min(Iw(s),xm);return{type:"keyframes",ease:i=>s.next(r*i).value/t,duration:wr(r)}}const wV=5;function QA(n,t,e){const s=Math.max(t-wV,0);return _A(e-n(s),t-s)}const en={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},lx=.001;function SV({duration:n=en.duration,bounce:t=en.bounce,velocity:e=en.velocity,mass:s=en.mass}){let r,i,o=1-t;o=Hi(en.minDamping,en.maxDamping,o),n=Hi(en.minDuration,en.maxDuration,wr(n)),o<1?(r=h=>{const d=h*o,p=d*n,m=d-e,y=Zx(h,o),b=Math.exp(-p);return lx-m/y*b},i=h=>{const p=h*o*n,m=p*e+e,y=Math.pow(o,2)*Math.pow(h,2)*n,b=Math.exp(-p),x=Zx(Math.pow(h,2),o);return(-r(h)+lx>0?-1:1)*((m-y)*b)/x}):(r=h=>{const d=Math.exp(-h*n),p=(h-e)*n+1;return-lx+d*p},i=h=>{const d=Math.exp(-h*n),p=(e-h)*(n*n);return d*p});const l=5/n,c=TV(r,i,l);if(n=ui(n),isNaN(c))return{stiffness:en.stiffness,damping:en.damping,duration:n};{const h=Math.pow(c,2)*s;return{stiffness:h,damping:o*2*Math.sqrt(s*h),duration:n}}}const CV=12;function TV(n,t,e){let s=e;for(let r=1;r<CV;r++)s=s-n(s)/t(s);return s}function Zx(n,t){return n*Math.sqrt(1-t*t)}const kV=["duration","bounce"],$V=["stiffness","damping","mass"];function X$(n,t){return t.some(e=>n[e]!==void 0)}function EV(n){let t={velocity:en.velocity,stiffness:en.stiffness,damping:en.damping,mass:en.mass,isResolvedFromDuration:!1,...n};if(!X$(n,$V)&&X$(n,kV))if(n.visualDuration){const e=n.visualDuration,s=2*Math.PI/(e*1.2),r=s*s,i=2*Hi(.05,1,1-(n.bounce||0))*Math.sqrt(r);t={...t,mass:en.mass,stiffness:r,damping:i}}else{const e=SV(n);t={...t,...e,mass:en.mass},t.isResolvedFromDuration=!0}return t}function vm(n=en.visualDuration,t=en.bounce){const e=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:t}:n;let{restSpeed:s,restDelta:r}=e;const i=e.keyframes[0],o=e.keyframes[e.keyframes.length-1],l={done:!1,value:i},{stiffness:c,damping:h,mass:d,duration:p,velocity:m,isResolvedFromDuration:y}=EV({...e,velocity:-wr(e.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(c*d)),w=o-i,S=wr(Math.sqrt(c/d)),T=Math.abs(w)<5;s||(s=T?en.restSpeed.granular:en.restSpeed.default),r||(r=T?en.restDelta.granular:en.restDelta.default);let k;if(x<1){const E=Zx(S,x);k=N=>{const _=Math.exp(-x*S*N);return o-_*((b+x*S*w)/E*Math.sin(E*N)+w*Math.cos(E*N))}}else if(x===1)k=E=>o-Math.exp(-S*E)*(w+(b+S*w)*E);else{const E=S*Math.sqrt(x*x-1);k=N=>{const _=Math.exp(-x*S*N),R=Math.min(E*N,300);return o-_*((b+x*S*w)*Math.sinh(R)+E*w*Math.cosh(R))/E}}const $={calculatedDuration:y&&p||null,next:E=>{const N=k(E);if(y)l.done=E>=p;else{let _=E===0?b:0;x<1&&(_=E===0?ui(b):QA(k,E,N));const R=Math.abs(_)<=s,D=Math.abs(o-N)<=r;l.done=R&&D}return l.value=l.done?o:N,l},toString:()=>{const E=Math.min(Iw($),xm),N=JA(_=>$.next(E*_).value,E,30);return E+"ms "+N},toTransition:()=>{}};return $}vm.applyToOptions=n=>{const t=vV(n,100,vm);return n.ease=t.ease,n.duration=ui(t.duration),n.type="keyframes",n};function Jx({keyframes:n,velocity:t=0,power:e=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:i=500,modifyTarget:o,min:l,max:c,restDelta:h=.5,restSpeed:d}){const p=n[0],m={done:!1,value:p},y=R=>l!==void 0&&R<l||c!==void 0&&R>c,b=R=>l===void 0?c:c===void 0||Math.abs(l-R)<Math.abs(c-R)?l:c;let x=e*t;const w=p+x,S=o===void 0?w:o(w);S!==w&&(x=S-p);const T=R=>-x*Math.exp(-R/s),k=R=>S+T(R),$=R=>{const D=T(R),M=k(R);m.done=Math.abs(D)<=h,m.value=m.done?S:M};let E,N;const _=R=>{y(m.value)&&(E=R,N=vm({keyframes:[m.value,b(m.value)],velocity:QA(k,R,m.value),damping:r,stiffness:i,restDelta:h,restSpeed:d}))};return _(0),{calculatedDuration:null,next:R=>{let D=!1;return!N&&E===void 0&&(D=!0,$(R),_(R)),E!==void 0&&R>=E?N.next(R-E):(!D&&$(R),m)}}}function IV(n,t,e){const s=[],r=e||qi.mix||ZA,i=n.length-1;for(let o=0;o<i;o++){let l=r(n[o],n[o+1]);if(t){const c=Array.isArray(t)?t[o]||Tr:t;l=Yh(c,l)}s.push(l)}return s}function NV(n,t,{clamp:e=!0,ease:s,mixer:r}={}){const i=n.length;if(xw(i===t.length),i===1)return()=>t[0];if(i===2&&t[0]===t[1])return()=>t[1];const o=n[0]===n[1];n[0]>n[i-1]&&(n=[...n].reverse(),t=[...t].reverse());const l=IV(t,s,r),c=l.length,h=d=>{if(o&&d<n[0])return t[0];let p=0;if(c>1)for(;p<n.length-2&&!(d<n[p+1]);p++);const m=$h(n[p],n[p+1],d);return l[p](m)};return e?d=>h(Hi(n[0],n[i-1],d)):h}function AV(n,t){const e=n[n.length-1];for(let s=1;s<=t;s++){const r=$h(0,t,s);n.push(Ze(e,1,r))}}function _V(n){const t=[0];return AV(t,n.length-1),t}function RV(n,t){return n.map(e=>e*t)}function DV(n,t){return n.map(()=>t||BA).splice(0,n.length-1)}function bh({duration:n=300,keyframes:t,times:e,ease:s="easeInOut"}){const r=GB(s)?s.map(G$):G$(s),i={done:!1,value:t[0]},o=RV(e&&e.length===t.length?e:_V(t),n),l=NV(o,t,{ease:Array.isArray(r)?r:DV(t,r)});return{calculatedDuration:n,next:c=>(i.value=l(c),i.done=c>=n,i)}}const OV=n=>n!==null;function Nw(n,{repeat:t,repeatType:e="loop"},s,r=1){const i=n.filter(OV),l=r<0||t&&e!=="loop"&&t%2===1?0:i.length-1;return!l||s===void 0?i[l]:s}const MV={decay:Jx,inertia:Jx,tween:bh,keyframes:bh,spring:vm};function t_(n){typeof n.type=="string"&&(n.type=MV[n.type])}class Aw{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(t=>{this.resolve=t})}notifyFinished(){this.resolve()}then(t,e){return this.finished.then(t,e)}}const FV=n=>n/100;class _w extends Aw{constructor(t){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:e}=this.options;e&&e.updatedAt!==Ms.now()&&this.tick(Ms.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=t,this.initAnimation(),this.play(),t.autoplay===!1&&this.pause()}initAnimation(){const{options:t}=this;t_(t);const{type:e=bh,repeat:s=0,repeatDelay:r=0,repeatType:i,velocity:o=0}=t;let{keyframes:l}=t;const c=e||bh;c!==bh&&typeof l[0]!="number"&&(this.mixKeyframes=Yh(FV,ZA(l[0],l[1])),l=[0,100]);const h=c({...t,keyframes:l});i==="mirror"&&(this.mirroredGenerator=c({...t,keyframes:[...l].reverse(),velocity:-o})),h.calculatedDuration===null&&(h.calculatedDuration=Iw(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+r,this.totalDuration=this.resolvedDuration*(s+1)-r,this.generator=h}updateTime(t){const e=Math.round(t-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=e}tick(t,e=!1){const{generator:s,totalDuration:r,mixKeyframes:i,mirroredGenerator:o,resolvedDuration:l,calculatedDuration:c}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:p,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-r/this.speed,this.startTime)),e?this.currentTime=t:this.updateTime(t);const S=this.currentTime-h*(this.playbackSpeed>=0?1:-1),T=this.playbackSpeed>=0?S<0:S>r;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=r);let k=this.currentTime,$=s;if(p){const R=Math.min(this.currentTime,r)/l;let D=Math.floor(R),M=R%1;!M&&R>=1&&(M=1),M===1&&D--,D=Math.min(D,p+1),D%2&&(m==="reverse"?(M=1-M,y&&(M-=y/l)):m==="mirror"&&($=o)),k=Hi(0,1,M)*l}const E=T?{done:!1,value:d[0]}:$.next(k);i&&(E.value=i(E.value));let{done:N}=E;!T&&c!==null&&(N=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const _=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&N);return _&&b!==Jx&&(E.value=Nw(d,this.options,w,this.speed)),x&&x(E.value),_&&this.finish(),E}then(t,e){return this.finished.then(t,e)}get duration(){return wr(this.calculatedDuration)}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+wr(t)}get time(){return wr(this.currentTime)}set time(t){t=ui(t),this.currentTime=t,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(t){this.updateTime(Ms.now());const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=wr(this.currentTime))}play(){if(this.isStopped)return;const{driver:t=xV,startTime:e}=this.options;this.driver||(this.driver=t(r=>this.tick(r))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=e??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Ms.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}attachTimeline(t){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),t.observe(this)}}function LV(n){for(let t=1;t<n.length;t++)n[t]??(n[t]=n[t-1])}const za=n=>n*180/Math.PI,Qx=n=>{const t=za(Math.atan2(n[1],n[0]));return tv(t)},PV={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:Qx,rotateZ:Qx,skewX:n=>za(Math.atan(n[1])),skewY:n=>za(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},tv=n=>(n=n%360,n<0&&(n+=360),n),Y$=Qx,Z$=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),J$=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),zV={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:Z$,scaleY:J$,scale:n=>(Z$(n)+J$(n))/2,rotateX:n=>tv(za(Math.atan2(n[6],n[5]))),rotateY:n=>tv(za(Math.atan2(-n[2],n[0]))),rotateZ:Y$,rotate:Y$,skewX:n=>za(Math.atan(n[4])),skewY:n=>za(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function ev(n){return n.includes("scale")?1:0}function nv(n,t){if(!n||n==="none")return ev(t);const e=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,r;if(e)s=zV,r=e;else{const l=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=PV,r=l}if(!r)return ev(t);const i=s[t],o=r[1].split(",").map(VV);return typeof i=="function"?i(o):o[i]}const BV=(n,t)=>{const{transform:e="none"}=getComputedStyle(n);return nv(e,t)};function VV(n){return parseFloat(n.trim())}const Hc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],qc=new Set(Hc),Q$=n=>n===Wc||n===Wt,UV=new Set(["x","y","z"]),jV=Hc.filter(n=>!UV.has(n));function GV(n){const t=[];return jV.forEach(e=>{const s=n.getValue(e);s!==void 0&&(t.push([e,s.get()]),s.set(e.startsWith("scale")?1:0))}),t}const ja={width:({x:n},{paddingLeft:t="0",paddingRight:e="0"})=>n.max-n.min-parseFloat(t)-parseFloat(e),height:({y:n},{paddingTop:t="0",paddingBottom:e="0"})=>n.max-n.min-parseFloat(t)-parseFloat(e),top:(n,{top:t})=>parseFloat(t),left:(n,{left:t})=>parseFloat(t),bottom:({y:n},{top:t})=>parseFloat(t)+(n.max-n.min),right:({x:n},{left:t})=>parseFloat(t)+(n.max-n.min),x:(n,{transform:t})=>nv(t,"x"),y:(n,{transform:t})=>nv(t,"y")};ja.translateX=ja.x;ja.translateY=ja.y;const Ga=new Set;let sv=!1,rv=!1,iv=!1;function e_(){if(rv){const n=Array.from(Ga).filter(s=>s.needsMeasurement),t=new Set(n.map(s=>s.element)),e=new Map;t.forEach(s=>{const r=GV(s);r.length&&(e.set(s,r),s.render())}),n.forEach(s=>s.measureInitialState()),t.forEach(s=>{s.render();const r=e.get(s);r&&r.forEach(([i,o])=>{s.getValue(i)?.set(o)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}rv=!1,sv=!1,Ga.forEach(n=>n.complete(iv)),Ga.clear()}function n_(){Ga.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(rv=!0)})}function WV(){iv=!0,n_(),e_(),iv=!1}class Rw{constructor(t,e,s,r,i,o=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=s,this.motionValue=r,this.element=i,this.isAsync=o}scheduleResolve(){this.state="scheduled",this.isAsync?(Ga.add(this),sv||(sv=!0,qe.read(n_),qe.resolveKeyframes(e_))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:s,motionValue:r}=this;if(t[0]===null){const i=r?.get(),o=t[t.length-1];if(i!==void 0)t[0]=i;else if(s&&e){const l=s.readValue(e,o);l!=null&&(t[0]=l)}t[0]===void 0&&(t[0]=o),r&&i===void 0&&r.set(t[0])}LV(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,t),Ga.delete(this)}cancel(){this.state==="scheduled"&&(Ga.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const HV=n=>n.startsWith("--");function qV(n,t,e){HV(t)?n.style.setProperty(t,e):n.style[t]=e}const KV=vw(()=>window.ScrollTimeline!==void 0),XV={};function YV(n,t){const e=vw(n);return()=>XV[t]??e()}const s_=YV(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),ch=([n,t,e,s])=>`cubic-bezier(${n}, ${t}, ${e}, ${s})`,tE={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:ch([0,.65,.55,1]),circOut:ch([.55,0,1,.45]),backIn:ch([.31,.01,.66,-.59]),backOut:ch([.33,1.53,.69,.99])};function r_(n,t){if(n)return typeof n=="function"?s_()?JA(n,t):"ease-out":VA(n)?ch(n):Array.isArray(n)?n.map(e=>r_(e,t)||tE.easeOut):tE[n]}function ZV(n,t,e,{delay:s=0,duration:r=300,repeat:i=0,repeatType:o="loop",ease:l="easeOut",times:c}={},h=void 0){const d={[t]:e};c&&(d.offset=c);const p=r_(l,r);Array.isArray(p)&&(d.easing=p);const m={delay:s,duration:r,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:i+1,direction:o==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function i_(n){return typeof n=="function"&&"applyToOptions"in n}function JV({type:n,...t}){return i_(n)&&s_()?n.applyToOptions(t):(t.duration??(t.duration=300),t.ease??(t.ease="easeOut"),t)}class QV extends Aw{constructor(t){if(super(),this.finishedTime=null,this.isStopped=!1,!t)return;const{element:e,name:s,keyframes:r,pseudoElement:i,allowFlatten:o=!1,finalKeyframe:l,onComplete:c}=t;this.isPseudoElement=!!i,this.allowFlatten=o,this.options=t,xw(typeof t.type!="string");const h=JV(t);this.animation=ZV(e,s,r,h,i),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!i){const d=Nw(r,this.options,l,this.speed);this.updateMotionValue?this.updateMotionValue(d):qV(e,s,d),this.animation.cancel()}c?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:t}=this;t==="idle"||t==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const t=this.animation.effect?.getComputedTiming?.().duration||0;return wr(Number(t))}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+wr(t)}get time(){return wr(Number(this.animation.currentTime)||0)}set time(t){this.finishedTime=null,this.animation.currentTime=ui(t)}get speed(){return this.animation.playbackRate}set speed(t){t<0&&(this.finishedTime=null),this.animation.playbackRate=t}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(t){this.animation.startTime=t}attachTimeline({timeline:t,observe:e}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,t&&KV()?(this.animation.timeline=t,Tr):e(this)}}const o_={anticipate:LA,backInOut:FA,circInOut:zA};function tU(n){return n in o_}function eU(n){typeof n.ease=="string"&&tU(n.ease)&&(n.ease=o_[n.ease])}const eE=10;class nU extends QV{constructor(t){eU(t),t_(t),super(t),t.startTime&&(this.startTime=t.startTime),this.options=t}updateMotionValue(t){const{motionValue:e,onUpdate:s,onComplete:r,element:i,...o}=this.options;if(!e)return;if(t!==void 0){e.set(t);return}const l=new _w({...o,autoplay:!1}),c=ui(this.finishedTime??this.time);e.setWithVelocity(l.sample(c-eE).value,l.sample(c).value,eE),l.stop()}}const nE=(n,t)=>t==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(Bo.test(n)||n==="0")&&!n.startsWith("url("));function sU(n){const t=n[0];if(n.length===1)return!0;for(let e=0;e<n.length;e++)if(n[e]!==t)return!0}function rU(n,t,e,s){const r=n[0];if(r===null)return!1;if(t==="display"||t==="visibility")return!0;const i=n[n.length-1],o=nE(r,t),l=nE(i,t);return!o||!l?!1:sU(n)||(e==="spring"||i_(e))&&s}function ov(n){n.duration=0,n.type="keyframes"}const iU=new Set(["opacity","clipPath","filter","transform"]),oU=vw(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function aU(n){const{motionValue:t,name:e,repeatDelay:s,repeatType:r,damping:i,type:o}=n;if(!(t?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:c,transformTemplate:h}=t.owner.getProps();return oU()&&e&&iU.has(e)&&(e!=="transform"||!h)&&!c&&!s&&r!=="mirror"&&i!==0&&o!=="inertia"}const lU=40;class cU extends Aw{constructor({autoplay:t=!0,delay:e=0,type:s="keyframes",repeat:r=0,repeatDelay:i=0,repeatType:o="loop",keyframes:l,name:c,motionValue:h,element:d,...p}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Ms.now();const m={autoplay:t,delay:e,type:s,repeat:r,repeatDelay:i,repeatType:o,name:c,motionValue:h,element:d,...p},y=d?.KeyframeResolver||Rw;this.keyframeResolver=new y(l,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),c,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(t,e,s,r){this.keyframeResolver=void 0;const{name:i,type:o,velocity:l,delay:c,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Ms.now(),rU(t,i,o,l)||((qi.instantAnimations||!c)&&d?.(Nw(t,s,e)),t[0]=t[t.length-1],ov(s),s.repeat=0);const m={startTime:r?this.resolvedAt?this.resolvedAt-this.createdAt>lU?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:e,...s,keyframes:t},y=!h&&aU(m)?new nU({...m,element:m.motionValue.owner.current}):new _w(m);y.finished.then(()=>this.notifyFinished()).catch(Tr),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(t,e){return this.finished.finally(t).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),WV()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(t){this.animation.time=t}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(t){this.animation.speed=t}get startTime(){return this.animation.startTime}attachTimeline(t){return this._animation?this.stopTimeline=this.animation.attachTimeline(t):this.pendingTimeline=t,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const uU=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function hU(n){const t=uU.exec(n);if(!t)return[,];const[,e,s,r]=t;return[`--${e??s}`,r]}function a_(n,t,e=1){const[s,r]=hU(n);if(!s)return;const i=window.getComputedStyle(t).getPropertyValue(s);if(i){const o=i.trim();return IA(o)?parseFloat(o):o}return Tw(r)?a_(r,t,e+1):r}function Dw(n,t){return n?.[t]??n?.default??n}const l_=new Set(["width","height","top","left","right","bottom",...Hc]),dU={test:n=>n==="auto",parse:n=>n},c_=n=>t=>t.test(n),u_=[Wc,Wt,hi,Io,sV,nV,dU],sE=n=>u_.find(c_(n));function fU(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||AA(n):!0}const pU=new Set(["brightness","contrast","saturate","opacity"]);function mU(n){const[t,e]=n.slice(0,-1).split("(");if(t==="drop-shadow")return n;const[s]=e.match(kw)||[];if(!s)return n;const r=e.replace(s,"");let i=pU.has(t)?1:0;return s!==e&&(i*=100),t+"("+i+r+")"}const gU=/\b([a-z-]*)\(.*?\)/gu,av={...Bo,getAnimatableNone:n=>{const t=n.match(gU);return t?t.map(mU).join(" "):n}},rE={...Wc,transform:Math.round},yU={rotate:Io,rotateX:Io,rotateY:Io,rotateZ:Io,scale:zp,scaleX:zp,scaleY:zp,scaleZ:zp,skew:Io,skewX:Io,skewY:Io,distance:Wt,translateX:Wt,translateY:Wt,translateZ:Wt,x:Wt,y:Wt,z:Wt,perspective:Wt,transformPerspective:Wt,opacity:Eh,originX:W$,originY:W$,originZ:Wt},Ow={borderWidth:Wt,borderTopWidth:Wt,borderRightWidth:Wt,borderBottomWidth:Wt,borderLeftWidth:Wt,borderRadius:Wt,radius:Wt,borderTopLeftRadius:Wt,borderTopRightRadius:Wt,borderBottomRightRadius:Wt,borderBottomLeftRadius:Wt,width:Wt,maxWidth:Wt,height:Wt,maxHeight:Wt,top:Wt,right:Wt,bottom:Wt,left:Wt,padding:Wt,paddingTop:Wt,paddingRight:Wt,paddingBottom:Wt,paddingLeft:Wt,margin:Wt,marginTop:Wt,marginRight:Wt,marginBottom:Wt,marginLeft:Wt,backgroundPositionX:Wt,backgroundPositionY:Wt,...yU,zIndex:rE,fillOpacity:Eh,strokeOpacity:Eh,numOctaves:rE},bU={...Ow,color:bn,backgroundColor:bn,outlineColor:bn,fill:bn,stroke:bn,borderColor:bn,borderTopColor:bn,borderRightColor:bn,borderBottomColor:bn,borderLeftColor:bn,filter:av,WebkitFilter:av},h_=n=>bU[n];function d_(n,t){let e=h_(n);return e!==av&&(e=Bo),e.getAnimatableNone?e.getAnimatableNone(t):void 0}const xU=new Set(["auto","none","0"]);function vU(n,t,e){let s=0,r;for(;s<n.length&&!r;){const i=n[s];typeof i=="string"&&!xU.has(i)&&Ih(i).values.length&&(r=n[s]),s++}if(r&&e)for(const i of t)n[i]=d_(e,r)}class wU extends Rw{constructor(t,e,s,r,i){super(t,e,s,r,i,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:s}=this;if(!e||!e.current)return;super.readKeyframes();for(let c=0;c<t.length;c++){let h=t[c];if(typeof h=="string"&&(h=h.trim(),Tw(h))){const d=a_(h,e.current);d!==void 0&&(t[c]=d),c===t.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!l_.has(s)||t.length!==2)return;const[r,i]=t,o=sE(r),l=sE(i);if(o!==l)if(Q$(o)&&Q$(l))for(let c=0;c<t.length;c++){const h=t[c];typeof h=="string"&&(t[c]=parseFloat(h))}else ja[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,s=[];for(let r=0;r<t.length;r++)(t[r]===null||fU(t[r]))&&s.push(r);s.length&&vU(t,s,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:s}=this;if(!t||!t.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=ja[s](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const r=e[e.length-1];r!==void 0&&t.getValue(s,r).jump(r,!1)}measureEndState(){const{element:t,name:e,unresolvedKeyframes:s}=this;if(!t||!t.current)return;const r=t.getValue(e);r&&r.jump(this.measuredOrigin,!1);const i=s.length-1,o=s[i];s[i]=ja[e](t.measureViewportBox(),window.getComputedStyle(t.current)),o!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=o),this.removedTransforms?.length&&this.removedTransforms.forEach(([l,c])=>{t.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function SU(n,t,e){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const r=e?.[n]??s.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}const f_=(n,t)=>t&&typeof n=="number"?t.transform(n):n;function p_(n){return NA(n)&&"offsetHeight"in n}const iE=30,CU=n=>!isNaN(parseFloat(n));class TU{constructor(t,e={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const r=Ms.now();if(this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const i of this.dependents)i.dirty()},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){this.current=t,this.updatedAt=Ms.now(),this.canTrackVelocity===null&&t!==void 0&&(this.canTrackVelocity=CU(this.current))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new ww);const s=this.events[t].add(e);return t==="change"?()=>{s(),qe.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t){this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t)}setWithVelocity(t,e,s){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-s}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(t){this.dependents||(this.dependents=new Set),this.dependents.add(t)}removeDependent(t){this.dependents&&this.dependents.delete(t)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const t=Ms.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||t-this.updatedAt>iE)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,iE);return _A(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Rc(n,t){return new TU(n,t)}const{schedule:Mw}=UA(queueMicrotask,!1),zr={x:!1,y:!1};function m_(){return zr.x||zr.y}function kU(n){return n==="x"||n==="y"?zr[n]?null:(zr[n]=!0,()=>{zr[n]=!1}):zr.x||zr.y?null:(zr.x=zr.y=!0,()=>{zr.x=zr.y=!1})}function g_(n,t){const e=SU(n),s=new AbortController,r={passive:!0,...t,signal:s.signal};return[e,r,()=>s.abort()]}function oE(n){return!(n.pointerType==="touch"||m_())}function $U(n,t,e={}){const[s,r,i]=g_(n,e),o=l=>{if(!oE(l))return;const{target:c}=l,h=t(c,l);if(typeof h!="function"||!c)return;const d=p=>{oE(p)&&(h(p),c.removeEventListener("pointerleave",d))};c.addEventListener("pointerleave",d,r)};return s.forEach(l=>{l.addEventListener("pointerenter",o,r)}),i}const y_=(n,t)=>t?n===t?!0:y_(n,t.parentElement):!1,Fw=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,EU=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function IU(n){return EU.has(n.tagName)||n.tabIndex!==-1}const om=new WeakSet;function aE(n){return t=>{t.key==="Enter"&&n(t)}}function cx(n,t){n.dispatchEvent(new PointerEvent("pointer"+t,{isPrimary:!0,bubbles:!0}))}const NU=(n,t)=>{const e=n.currentTarget;if(!e)return;const s=aE(()=>{if(om.has(e))return;cx(e,"down");const r=aE(()=>{cx(e,"up")}),i=()=>cx(e,"cancel");e.addEventListener("keyup",r,t),e.addEventListener("blur",i,t)});e.addEventListener("keydown",s,t),e.addEventListener("blur",()=>e.removeEventListener("keydown",s),t)};function lE(n){return Fw(n)&&!m_()}function AU(n,t,e={}){const[s,r,i]=g_(n,e),o=l=>{const c=l.currentTarget;if(!lE(l))return;om.add(c);const h=t(c,l),d=(y,b)=>{window.removeEventListener("pointerup",p),window.removeEventListener("pointercancel",m),om.has(c)&&om.delete(c),lE(y)&&typeof h=="function"&&h(y,{success:b})},p=y=>{d(y,c===window||c===document||e.useGlobalTarget||y_(c,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",p,r),window.addEventListener("pointercancel",m,r)};return s.forEach(l=>{(e.useGlobalTarget?window:l).addEventListener("pointerdown",o,r),p_(l)&&(l.addEventListener("focus",h=>NU(h,r)),!IU(l)&&!l.hasAttribute("tabindex")&&(l.tabIndex=0))}),i}function b_(n){return NA(n)&&"ownerSVGElement"in n}function _U(n){return b_(n)&&n.tagName==="svg"}const ls=n=>!!(n&&n.getVelocity),RU=[...u_,bn,Bo],DU=n=>RU.find(c_(n)),Lw=St.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function cE(n,t){if(typeof n=="function")return n(t);n!=null&&(n.current=t)}function OU(...n){return t=>{let e=!1;const s=n.map(r=>{const i=cE(r,t);return!e&&typeof i=="function"&&(e=!0),i});if(e)return()=>{for(let r=0;r<s.length;r++){const i=s[r];typeof i=="function"?i():cE(n[r],null)}}}}function MU(...n){return St.useCallback(OU(...n),n)}class FU extends St.Component{getSnapshotBeforeUpdate(t){const e=this.props.childRef.current;if(e&&t.isPresent&&!this.props.isPresent){const s=e.offsetParent,r=p_(s)&&s.offsetWidth||0,i=this.props.sizeRef.current;i.height=e.offsetHeight||0,i.width=e.offsetWidth||0,i.top=e.offsetTop,i.left=e.offsetLeft,i.right=r-i.width-i.left}return null}componentDidUpdate(){}render(){return this.props.children}}function LU({children:n,isPresent:t,anchorX:e,root:s}){const r=St.useId(),i=St.useRef(null),o=St.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:l}=St.useContext(Lw),c=MU(i,n?.ref);return St.useInsertionEffect(()=>{const{width:h,height:d,top:p,left:m,right:y}=o.current;if(t||!i.current||!h||!d)return;const b=e==="left"?`left: ${m}`:`right: ${y}`;i.current.dataset.motionPopId=r;const x=document.createElement("style");l&&(x.nonce=l);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${p}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[t]),it.jsx(FU,{isPresent:t,childRef:i,sizeRef:o,children:St.cloneElement(n,{ref:c})})}const PU=({children:n,initial:t,isPresent:e,onExitComplete:s,custom:r,presenceAffectsLayout:i,mode:o,anchorX:l,root:c})=>{const h=mw(zU),d=St.useId();let p=!0,m=St.useMemo(()=>(p=!1,{id:d,initial:t,isPresent:e,custom:r,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[e,h,s]);return i&&p&&(m={...m}),St.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[e]),St.useEffect(()=>{!e&&!h.size&&s&&s()},[e]),o==="popLayout"&&(n=it.jsx(LU,{isPresent:e,anchorX:l,root:c,children:n})),it.jsx(rg.Provider,{value:m,children:n})};function zU(){return new Map}function x_(n=!0){const t=St.useContext(rg);if(t===null)return[!0,null];const{isPresent:e,onExitComplete:s,register:r}=t,i=St.useId();St.useEffect(()=>{if(n)return r(i)},[n]);const o=St.useCallback(()=>n&&s&&s(i),[i,s,n]);return!e&&s?[!1,o]:[!0]}const Bp=n=>n.key||"";function uE(n){const t=[];return St.Children.forEach(n,e=>{St.isValidElement(e)&&t.push(e)}),t}const BU=({children:n,custom:t,initial:e=!0,onExitComplete:s,presenceAffectsLayout:r=!0,mode:i="sync",propagate:o=!1,anchorX:l="left",root:c})=>{const[h,d]=x_(o),p=St.useMemo(()=>uE(n),[n]),m=o&&!h?[]:p.map(Bp),y=St.useRef(!0),b=St.useRef(p),x=mw(()=>new Map),[w,S]=St.useState(p),[T,k]=St.useState(p);EA(()=>{y.current=!1,b.current=p;for(let N=0;N<T.length;N++){const _=Bp(T[N]);m.includes(_)?x.delete(_):x.get(_)!==!0&&x.set(_,!1)}},[T,m.length,m.join("-")]);const $=[];if(p!==w){let N=[...p];for(let _=0;_<T.length;_++){const R=T[_],D=Bp(R);m.includes(D)||(N.splice(_,0,R),$.push(R))}return i==="wait"&&$.length&&(N=$),k(uE(N)),S(p),null}const{forceRender:E}=St.useContext(pw);return it.jsx(it.Fragment,{children:T.map(N=>{const _=Bp(N),R=o&&!h?!1:p===T||m.includes(_),D=()=>{if(x.has(_))x.set(_,!0);else return;let M=!0;x.forEach(A=>{A||(M=!1)}),M&&(E?.(),k(b.current),o&&d?.(),s&&s())};return it.jsx(PU,{isPresent:R,initial:!y.current||e?void 0:!1,custom:t,presenceAffectsLayout:r,mode:i,root:c,onExitComplete:R?void 0:D,anchorX:l,children:N},_)})})},v_=St.createContext({strict:!1}),hE={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Dc={};for(const n in hE)Dc[n]={isEnabled:t=>hE[n].some(e=>!!t[e])};function VU(n){for(const t in n)Dc[t]={...Dc[t],...n[t]}}const UU=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function wm(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||UU.has(n)}let w_=n=>!wm(n);function jU(n){typeof n=="function"&&(w_=t=>t.startsWith("on")?!wm(t):n(t))}try{jU(require("@emotion/is-prop-valid").default)}catch{}function GU(n,t,e){const s={};for(const r in n)r==="values"&&typeof n.values=="object"||(w_(r)||e===!0&&wm(r)||!t&&!wm(r)||n.draggable&&r.startsWith("onDrag"))&&(s[r]=n[r]);return s}const ig=St.createContext({});function og(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function Nh(n){return typeof n=="string"||Array.isArray(n)}const Pw=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],zw=["initial",...Pw];function ag(n){return og(n.animate)||zw.some(t=>Nh(n[t]))}function S_(n){return!!(ag(n)||n.variants)}function WU(n,t){if(ag(n)){const{initial:e,animate:s}=n;return{initial:e===!1||Nh(e)?e:void 0,animate:Nh(s)?s:void 0}}return n.inherit!==!1?t:{}}function HU(n){const{initial:t,animate:e}=WU(n,St.useContext(ig));return St.useMemo(()=>({initial:t,animate:e}),[dE(t),dE(e)])}function dE(n){return Array.isArray(n)?n.join(" "):n}function fE(n,t){return t.max===t.min?0:n/(t.max-t.min)*100}const sh={correct:(n,t)=>{if(!t.target)return n;if(typeof n=="string")if(Wt.test(n))n=parseFloat(n);else return n;const e=fE(n,t.target.x),s=fE(n,t.target.y);return`${e}% ${s}%`}},qU={correct:(n,{treeScale:t,projectionDelta:e})=>{const s=n,r=Bo.parse(n);if(r.length>5)return s;const i=Bo.createTransformer(n),o=typeof r[0]!="number"?1:0,l=e.x.scale*t.x,c=e.y.scale*t.y;r[0+o]/=l,r[1+o]/=c;const h=Ze(l,c,.5);return typeof r[2+o]=="number"&&(r[2+o]/=h),typeof r[3+o]=="number"&&(r[3+o]/=h),i(r)}},lv={borderRadius:{...sh,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:sh,borderTopRightRadius:sh,borderBottomLeftRadius:sh,borderBottomRightRadius:sh,boxShadow:qU};function C_(n,{layout:t,layoutId:e}){return qc.has(n)||n.startsWith("origin")||(t||e!==void 0)&&(!!lv[n]||n==="opacity")}const KU={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},XU=Hc.length;function YU(n,t,e){let s="",r=!0;for(let i=0;i<XU;i++){const o=Hc[i],l=n[o];if(l===void 0)continue;let c=!0;if(typeof l=="number"?c=l===(o.startsWith("scale")?1:0):c=parseFloat(l)===0,!c||e){const h=f_(l,Ow[o]);if(!c){r=!1;const d=KU[o]||o;s+=`${d}(${h}) `}e&&(t[o]=h)}}return s=s.trim(),e?s=e(t,r?"":s):r&&(s="none"),s}function Bw(n,t,e){const{style:s,vars:r,transformOrigin:i}=n;let o=!1,l=!1;for(const c in t){const h=t[c];if(qc.has(c)){o=!0;continue}else if(GA(c)){r[c]=h;continue}else{const d=f_(h,Ow[c]);c.startsWith("origin")?(l=!0,i[c]=d):s[c]=d}}if(t.transform||(o||e?s.transform=YU(t,n.transform,e):s.transform&&(s.transform="none")),l){const{originX:c="50%",originY:h="50%",originZ:d=0}=i;s.transformOrigin=`${c} ${h} ${d}`}}const Vw=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function T_(n,t,e){for(const s in t)!ls(t[s])&&!C_(s,e)&&(n[s]=t[s])}function ZU({transformTemplate:n},t){return St.useMemo(()=>{const e=Vw();return Bw(e,t,n),Object.assign({},e.vars,e.style)},[t])}function JU(n,t){const e=n.style||{},s={};return T_(s,e,n),Object.assign(s,ZU(n,t)),s}function QU(n,t){const e={},s=JU(n,t);return n.drag&&n.dragListener!==!1&&(e.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(e.tabIndex=0),e.style=s,e}const t4={offset:"stroke-dashoffset",array:"stroke-dasharray"},e4={offset:"strokeDashoffset",array:"strokeDasharray"};function n4(n,t,e=1,s=0,r=!0){n.pathLength=1;const i=r?t4:e4;n[i.offset]=Wt.transform(-s);const o=Wt.transform(t),l=Wt.transform(e);n[i.array]=`${o} ${l}`}function k_(n,{attrX:t,attrY:e,attrScale:s,pathLength:r,pathSpacing:i=1,pathOffset:o=0,...l},c,h,d){if(Bw(n,l,h),c){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:m}=n;p.transform&&(m.transform=p.transform,delete p.transform),(m.transform||p.transformOrigin)&&(m.transformOrigin=p.transformOrigin??"50% 50%",delete p.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete p.transformBox),t!==void 0&&(p.x=t),e!==void 0&&(p.y=e),s!==void 0&&(p.scale=s),r!==void 0&&n4(p,r,i,o,!1)}const $_=()=>({...Vw(),attrs:{}}),E_=n=>typeof n=="string"&&n.toLowerCase()==="svg";function s4(n,t,e,s){const r=St.useMemo(()=>{const i=$_();return k_(i,t,E_(s),n.transformTemplate,n.style),{...i.attrs,style:{...i.style}}},[t]);if(n.style){const i={};T_(i,n.style,n),r.style={...i,...r.style}}return r}const r4=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Uw(n){return typeof n!="string"||n.includes("-")?!1:!!(r4.indexOf(n)>-1||/[A-Z]/u.test(n))}function i4(n,t,e,{latestValues:s},r,i=!1){const l=(Uw(n)?s4:QU)(t,s,r,n),c=GU(t,typeof n=="string",i),h=n!==St.Fragment?{...c,...l,ref:e}:{},{children:d}=t,p=St.useMemo(()=>ls(d)?d.get():d,[d]);return St.createElement(n,{...h,children:p})}function pE(n){const t=[{},{}];return n?.values.forEach((e,s)=>{t[0][s]=e.get(),t[1][s]=e.getVelocity()}),t}function jw(n,t,e,s){if(typeof t=="function"){const[r,i]=pE(s);t=t(e!==void 0?e:n.custom,r,i)}if(typeof t=="string"&&(t=n.variants&&n.variants[t]),typeof t=="function"){const[r,i]=pE(s);t=t(e!==void 0?e:n.custom,r,i)}return t}function am(n){return ls(n)?n.get():n}function o4({scrapeMotionValuesFromProps:n,createRenderState:t},e,s,r){return{latestValues:a4(e,s,r,n),renderState:t()}}function a4(n,t,e,s){const r={},i=s(n,{});for(const m in i)r[m]=am(i[m]);let{initial:o,animate:l}=n;const c=ag(n),h=S_(n);t&&h&&!c&&n.inherit!==!1&&(o===void 0&&(o=t.initial),l===void 0&&(l=t.animate));let d=e?e.initial===!1:!1;d=d||o===!1;const p=d?l:o;if(p&&typeof p!="boolean"&&!og(p)){const m=Array.isArray(p)?p:[p];for(let y=0;y<m.length;y++){const b=jw(n,m[y]);if(b){const{transitionEnd:x,transition:w,...S}=b;for(const T in S){let k=S[T];if(Array.isArray(k)){const $=d?k.length-1:0;k=k[$]}k!==null&&(r[T]=k)}for(const T in x)r[T]=x[T]}}}return r}const I_=n=>(t,e)=>{const s=St.useContext(ig),r=St.useContext(rg),i=()=>o4(n,t,s,r);return e?i():mw(i)};function Gw(n,t,e){const{style:s}=n,r={};for(const i in s)(ls(s[i])||t.style&&ls(t.style[i])||C_(i,n)||e?.getValue(i)?.liveStyle!==void 0)&&(r[i]=s[i]);return r}const l4=I_({scrapeMotionValuesFromProps:Gw,createRenderState:Vw});function N_(n,t,e){const s=Gw(n,t,e);for(const r in n)if(ls(n[r])||ls(t[r])){const i=Hc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;s[i]=n[r]}return s}const c4=I_({scrapeMotionValuesFromProps:N_,createRenderState:$_}),u4=Symbol.for("motionComponentSymbol");function vc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function h4(n,t,e){return St.useCallback(s=>{s&&n.onMount&&n.onMount(s),t&&(s?t.mount(s):t.unmount()),e&&(typeof e=="function"?e(s):vc(e)&&(e.current=s))},[t])}const Ww=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),d4="framerAppearId",A_="data-"+Ww(d4),__=St.createContext({});function f4(n,t,e,s,r){const{visualElement:i}=St.useContext(ig),o=St.useContext(v_),l=St.useContext(rg),c=St.useContext(Lw).reducedMotion,h=St.useRef(null);s=s||o.renderer,!h.current&&s&&(h.current=s(n,{visualState:t,parent:i,props:e,presenceContext:l,blockInitialAnimation:l?l.initial===!1:!1,reducedMotionConfig:c}));const d=h.current,p=St.useContext(__);d&&!d.projection&&r&&(d.type==="html"||d.type==="svg")&&p4(h.current,e,r,p);const m=St.useRef(!1);St.useInsertionEffect(()=>{d&&m.current&&d.update(e,l)});const y=e[A_],b=St.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return EA(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),St.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function p4(n,t,e,s){const{layoutId:r,layout:i,drag:o,dragConstraints:l,layoutScroll:c,layoutRoot:h,layoutCrossfade:d}=t;n.projection=new e(n.latestValues,t["data-framer-portal-id"]?void 0:R_(n.parent)),n.projection.setOptions({layoutId:r,layout:i,alwaysMeasureLayout:!!o||l&&vc(l),visualElement:n,animationType:typeof i=="string"?i:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:c,layoutRoot:h})}function R_(n){if(n)return n.options.allowProjection!==!1?n.projection:R_(n.parent)}function ux(n,{forwardMotionProps:t=!1}={},e,s){e&&VU(e);const r=Uw(n)?c4:l4;function i(l,c){let h;const d={...St.useContext(Lw),...l,layoutId:m4(l)},{isStatic:p}=d,m=HU(l),y=r(l,p);if(!p&&gw){g4();const b=y4(d);h=b.MeasureLayout,m.visualElement=f4(n,y,d,s,b.ProjectionNode)}return it.jsxs(ig.Provider,{value:m,children:[h&&m.visualElement?it.jsx(h,{visualElement:m.visualElement,...d}):null,i4(n,l,h4(y,m.visualElement,c),y,p,t)]})}i.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const o=St.forwardRef(i);return o[u4]=n,o}function m4({layoutId:n}){const t=St.useContext(pw).id;return t&&n!==void 0?t+"-"+n:n}function g4(n,t){St.useContext(v_).strict}function y4(n){const{drag:t,layout:e}=Dc;if(!t&&!e)return{};const s={...t,...e};return{MeasureLayout:t?.isEnabled(n)||e?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function b4(n,t){if(typeof Proxy>"u")return ux;const e=new Map,s=(i,o)=>ux(i,o,n,t),r=(i,o)=>s(i,o);return new Proxy(r,{get:(i,o)=>o==="create"?s:(e.has(o)||e.set(o,ux(o,void 0,n,t)),e.get(o))})}function D_({top:n,left:t,right:e,bottom:s}){return{x:{min:t,max:e},y:{min:n,max:s}}}function x4({x:n,y:t}){return{top:t.min,right:n.max,bottom:t.max,left:n.min}}function v4(n,t){if(!t)return n;const e=t({x:n.left,y:n.top}),s=t({x:n.right,y:n.bottom});return{top:e.y,left:e.x,bottom:s.y,right:s.x}}function hx(n){return n===void 0||n===1}function cv({scale:n,scaleX:t,scaleY:e}){return!hx(n)||!hx(t)||!hx(e)}function Aa(n){return cv(n)||O_(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function O_(n){return mE(n.x)||mE(n.y)}function mE(n){return n&&n!=="0%"}function Sm(n,t,e){const s=n-e,r=t*s;return e+r}function gE(n,t,e,s,r){return r!==void 0&&(n=Sm(n,r,s)),Sm(n,e,s)+t}function uv(n,t=0,e=1,s,r){n.min=gE(n.min,t,e,s,r),n.max=gE(n.max,t,e,s,r)}function M_(n,{x:t,y:e}){uv(n.x,t.translate,t.scale,t.originPoint),uv(n.y,e.translate,e.scale,e.originPoint)}const yE=.999999999999,bE=1.0000000000001;function w4(n,t,e,s=!1){const r=e.length;if(!r)return;t.x=t.y=1;let i,o;for(let l=0;l<r;l++){i=e[l],o=i.projectionDelta;const{visualElement:c}=i.options;c&&c.props.style&&c.props.style.display==="contents"||(s&&i.options.layoutScroll&&i.scroll&&i!==i.root&&Sc(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),o&&(t.x*=o.x.scale,t.y*=o.y.scale,M_(n,o)),s&&Aa(i.latestValues)&&Sc(n,i.latestValues))}t.x<bE&&t.x>yE&&(t.x=1),t.y<bE&&t.y>yE&&(t.y=1)}function wc(n,t){n.min=n.min+t,n.max=n.max+t}function xE(n,t,e,s,r=.5){const i=Ze(n.min,n.max,r);uv(n,t,e,i,s)}function Sc(n,t){xE(n.x,t.x,t.scaleX,t.scale,t.originX),xE(n.y,t.y,t.scaleY,t.scale,t.originY)}function F_(n,t){return D_(v4(n.getBoundingClientRect(),t))}function S4(n,t,e){const s=F_(n,e),{scroll:r}=t;return r&&(wc(s.x,r.offset.x),wc(s.y,r.offset.y)),s}const vE=()=>({translate:0,scale:1,origin:0,originPoint:0}),Cc=()=>({x:vE(),y:vE()}),wE=()=>({min:0,max:0}),In=()=>({x:wE(),y:wE()}),hv={current:null},L_={current:!1};function C4(){if(L_.current=!0,!!gw)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),t=()=>hv.current=n.matches;n.addEventListener("change",t),t()}else hv.current=!1}const T4=new WeakMap;function k4(n,t,e){for(const s in t){const r=t[s],i=e[s];if(ls(r))n.addValue(s,r);else if(ls(i))n.addValue(s,Rc(r,{owner:n}));else if(i!==r)if(n.hasValue(s)){const o=n.getValue(s);o.liveStyle===!0?o.jump(r):o.hasAnimated||o.set(r)}else{const o=n.getStaticValue(s);n.addValue(s,Rc(o!==void 0?o:r,{owner:n}))}}for(const s in e)t[s]===void 0&&n.removeValue(s);return t}const SE=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class $4{scrapeMotionValuesFromProps(t,e,s){return{}}constructor({parent:t,props:e,presenceContext:s,reducedMotionConfig:r,blockInitialAnimation:i,visualState:o},l={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=Rw,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Ms.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,qe.render(this.render,!1,!0))};const{latestValues:c,renderState:h}=o;this.latestValues=c,this.baseTarget={...c},this.initialValues=e.initial?{...c}:{},this.renderState=h,this.parent=t,this.props=e,this.presenceContext=s,this.depth=t?t.depth+1:0,this.reducedMotionConfig=r,this.options=l,this.blockInitialAnimation=!!i,this.isControllingVariants=ag(e),this.isVariantNode=S_(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(t&&t.current);const{willChange:d,...p}=this.scrapeMotionValuesFromProps(e,{},this);for(const m in p){const y=p[m];c[m]!==void 0&&ls(y)&&y.set(c[m])}}mount(t){this.current=t,T4.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((e,s)=>this.bindToMotionValue(s,e)),L_.current||C4(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:hv.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),zo(this.notifyUpdate),zo(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}addChild(t){this.children.add(t),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(t)}removeChild(t){this.children.delete(t),this.enteringChildren&&this.enteringChildren.delete(t)}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const s=qc.has(t);s&&this.onBindTransform&&this.onBindTransform();const r=e.on("change",o=>{this.latestValues[t]=o,this.props.onUpdate&&qe.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let i;window.MotionCheckAppearSync&&(i=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{r(),i&&i(),e.owner&&e.stop()})}sortNodePosition(t){return!this.current||!this.sortInstanceNodePosition||this.type!==t.type?0:this.sortInstanceNodePosition(this.current,t.current)}updateFeatures(){let t="animation";for(t in Dc){const e=Dc[t];if(!e)continue;const{isEnabled:s,Feature:r}=e;if(!this.features[t]&&r&&s(this.props)&&(this.features[t]=new r(this)),this.features[t]){const i=this.features[t];i.isMounted?i.update():(i.mount(),i.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):In()}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let s=0;s<SE.length;s++){const r=SE[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const i="on"+r,o=t[i];o&&(this.propEventSubscriptions[r]=this.on(r,o))}this.prevMotionValues=k4(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const s=this.values.get(t);e!==s&&(s&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let s=this.values.get(t);return s===void 0&&e!==void 0&&(s=Rc(e===null?void 0:e,{owner:this}),this.addValue(t,s)),s}readValue(t,e){let s=this.latestValues[t]!==void 0||!this.current?this.latestValues[t]:this.getBaseTargetFromProps(this.props,t)??this.readValueFromInstance(this.current,t,this.options);return s!=null&&(typeof s=="string"&&(IA(s)||AA(s))?s=parseFloat(s):!DU(s)&&Bo.test(e)&&(s=d_(t,e)),this.setBaseTarget(t,ls(s)?s.get():s)),ls(s)?s.get():s}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){const{initial:e}=this.props;let s;if(typeof e=="string"||typeof e=="object"){const i=jw(this.props,e,this.presenceContext?.custom);i&&(s=i[t])}if(e&&s!==void 0)return s;const r=this.getBaseTargetFromProps(this.props,t);return r!==void 0&&!ls(r)?r:this.initialValues[t]!==void 0&&s===void 0?void 0:this.baseTarget[t]}on(t,e){return this.events[t]||(this.events[t]=new ww),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}scheduleRenderMicrotask(){Mw.render(this.render)}}class P_ extends $4{constructor(){super(...arguments),this.KeyframeResolver=wU}sortInstanceNodePosition(t,e){return t.compareDocumentPosition(e)&2?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:s}){delete e[t],delete s[t]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;ls(t)&&(this.childSubscription=t.on("change",e=>{this.current&&(this.current.textContent=`${e}`)}))}}function z_(n,{style:t,vars:e},s,r){const i=n.style;let o;for(o in t)i[o]=t[o];r?.applyProjectionStyles(i,s);for(o in e)i.setProperty(o,e[o])}function E4(n){return window.getComputedStyle(n)}class I4 extends P_{constructor(){super(...arguments),this.type="html",this.renderInstance=z_}readValueFromInstance(t,e){if(qc.has(e))return this.projection?.isProjecting?ev(e):BV(t,e);{const s=E4(t),r=(GA(e)?s.getPropertyValue(e):s[e])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(t,{transformPagePoint:e}){return F_(t,e)}build(t,e,s){Bw(t,e,s.transformTemplate)}scrapeMotionValuesFromProps(t,e,s){return Gw(t,e,s)}}const B_=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function N4(n,t,e,s){z_(n,t,void 0,s);for(const r in t.attrs)n.setAttribute(B_.has(r)?r:Ww(r),t.attrs[r])}class A4 extends P_{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=In}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(qc.has(e)){const s=h_(e);return s&&s.default||0}return e=B_.has(e)?e:Ww(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,s){return N_(t,e,s)}build(t,e,s){k_(t,e,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(t,e,s,r){N4(t,e,s,r)}mount(t){this.isSVGTag=E_(t.tagName),super.mount(t)}}const _4=(n,t)=>Uw(n)?new A4(t):new I4(t,{allowProjection:n!==St.Fragment});function kc(n,t,e){const s=n.getProps();return jw(s,t,e!==void 0?e:s.custom,n)}const dv=n=>Array.isArray(n);function R4(n,t,e){n.hasValue(t)?n.getValue(t).set(e):n.addValue(t,Rc(e))}function D4(n){return dv(n)?n[n.length-1]||0:n}function O4(n,t){const e=kc(n,t);let{transitionEnd:s={},transition:r={},...i}=e||{};i={...i,...s};for(const o in i){const l=D4(i[o]);R4(n,o,l)}}function M4(n){return!!(ls(n)&&n.add)}function fv(n,t){const e=n.getValue("willChange");if(M4(e))return e.add(t);if(!e&&qi.WillChange){const s=new qi.WillChange("auto");n.addValue("willChange",s),s.add(t)}}function V_(n){return n.props[A_]}const F4=n=>n!==null;function L4(n,{repeat:t,repeatType:e="loop"},s){const r=n.filter(F4),i=t&&e!=="loop"&&t%2===1?0:r.length-1;return r[i]}const P4={type:"spring",stiffness:500,damping:25,restSpeed:10},z4=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),B4={type:"keyframes",duration:.8},V4={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},U4=(n,{keyframes:t})=>t.length>2?B4:qc.has(n)?n.startsWith("scale")?z4(t[1]):P4:V4;function j4({when:n,delay:t,delayChildren:e,staggerChildren:s,staggerDirection:r,repeat:i,repeatType:o,repeatDelay:l,from:c,elapsed:h,...d}){return!!Object.keys(d).length}const Hw=(n,t,e,s={},r,i)=>o=>{const l=Dw(s,n)||{},c=l.delay||s.delay||0;let{elapsed:h=0}=s;h=h-ui(c);const d={keyframes:Array.isArray(e)?e:[null,e],ease:"easeOut",velocity:t.getVelocity(),...l,delay:-h,onUpdate:m=>{t.set(m),l.onUpdate&&l.onUpdate(m)},onComplete:()=>{o(),l.onComplete&&l.onComplete()},name:n,motionValue:t,element:i?void 0:r};j4(l)||Object.assign(d,U4(n,d)),d.duration&&(d.duration=ui(d.duration)),d.repeatDelay&&(d.repeatDelay=ui(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let p=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(ov(d),d.delay===0&&(p=!0)),(qi.instantAnimations||qi.skipAnimations)&&(p=!0,ov(d),d.delay=0),d.allowFlatten=!l.type&&!l.ease,p&&!i&&t.get()!==void 0){const m=L4(d.keyframes,l);if(m!==void 0){qe.update(()=>{d.onUpdate(m),d.onComplete()});return}}return l.isSync?new _w(d):new cU(d)};function G4({protectedKeys:n,needsAnimating:t},e){const s=n.hasOwnProperty(e)&&t[e]!==!0;return t[e]=!1,s}function U_(n,t,{delay:e=0,transitionOverride:s,type:r}={}){let{transition:i=n.getDefaultTransition(),transitionEnd:o,...l}=t;s&&(i=s);const c=[],h=r&&n.animationState&&n.animationState.getState()[r];for(const d in l){const p=n.getValue(d,n.latestValues[d]??null),m=l[d];if(m===void 0||h&&G4(h,d))continue;const y={delay:e,...Dw(i||{},d)},b=p.get();if(b!==void 0&&!p.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=V_(n);if(S){const T=window.MotionHandoffAnimation(S,d,qe);T!==null&&(y.startTime=T,x=!0)}}fv(n,d),p.start(Hw(d,p,m,n.shouldReduceMotion&&l_.has(d)?{type:!1}:y,n,x));const w=p.animation;w&&c.push(w)}return o&&Promise.all(c).then(()=>{qe.update(()=>{o&&O4(n,o)})}),c}function j_(n,t,e,s=0,r=1){const i=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(t),o=n.size,l=(o-1)*s;return typeof e=="function"?e(i,o):r===1?i*s:l-i*s}function pv(n,t,e={}){const s=kc(n,t,e.type==="exit"?n.presenceContext?.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=s||{};e.transitionOverride&&(r=e.transitionOverride);const i=s?()=>Promise.all(U_(n,s,e)):()=>Promise.resolve(),o=n.variantChildren&&n.variantChildren.size?(c=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:p}=r;return W4(n,t,c,h,d,p,e)}:()=>Promise.resolve(),{when:l}=r;if(l){const[c,h]=l==="beforeChildren"?[i,o]:[o,i];return c().then(()=>h())}else return Promise.all([i(),o(e.delay)])}function W4(n,t,e=0,s=0,r=0,i=1,o){const l=[];for(const c of n.variantChildren)c.notify("AnimationStart",t),l.push(pv(c,t,{...o,delay:e+(typeof s=="function"?0:s)+j_(n.variantChildren,c,s,r,i)}).then(()=>c.notify("AnimationComplete",t)));return Promise.all(l)}function H4(n,t,e={}){n.notify("AnimationStart",t);let s;if(Array.isArray(t)){const r=t.map(i=>pv(n,i,e));s=Promise.all(r)}else if(typeof t=="string")s=pv(n,t,e);else{const r=typeof t=="function"?kc(n,t,e.custom):t;s=Promise.all(U_(n,r,e))}return s.then(()=>{n.notify("AnimationComplete",t)})}function G_(n,t){if(!Array.isArray(t))return!1;const e=t.length;if(e!==n.length)return!1;for(let s=0;s<e;s++)if(t[s]!==n[s])return!1;return!0}const q4=zw.length;function W_(n){if(!n)return;if(!n.isControllingVariants){const e=n.parent?W_(n.parent)||{}:{};return n.props.initial!==void 0&&(e.initial=n.props.initial),e}const t={};for(let e=0;e<q4;e++){const s=zw[e],r=n.props[s];(Nh(r)||r===!1)&&(t[s]=r)}return t}const K4=[...Pw].reverse(),X4=Pw.length;function Y4(n){return t=>Promise.all(t.map(({animation:e,options:s})=>H4(n,e,s)))}function Z4(n){let t=Y4(n),e=CE(),s=!0;const r=c=>(h,d)=>{const p=kc(n,d,c==="exit"?n.presenceContext?.custom:void 0);if(p){const{transition:m,transitionEnd:y,...b}=p;h={...h,...b,...y}}return h};function i(c){t=c(n)}function o(c){const{props:h}=n,d=W_(n.parent)||{},p=[],m=new Set;let y={},b=1/0;for(let w=0;w<X4;w++){const S=K4[w],T=e[S],k=h[S]!==void 0?h[S]:d[S],$=Nh(k),E=S===c?T.isActive:null;E===!1&&(b=w);let N=k===d[S]&&k!==h[S]&&$;if(N&&s&&n.manuallyAnimateOnMount&&(N=!1),T.protectedKeys={...y},!T.isActive&&E===null||!k&&!T.prevProp||og(k)||typeof k=="boolean")continue;const _=J4(T.prevProp,k);let R=_||S===c&&T.isActive&&!N&&$||w>b&&$,D=!1;const M=Array.isArray(k)?k:[k];let A=M.reduce(r(S),{});E===!1&&(A={});const{prevResolvedValues:B={}}=T,H={...B,...A},W=U=>{R=!0,m.has(U)&&(D=!0,m.delete(U)),T.needsAnimating[U]=!0;const G=n.getValue(U);G&&(G.liveStyle=!1)};for(const U in H){const G=A[U],tt=B[U];if(y.hasOwnProperty(U))continue;let Z=!1;dv(G)&&dv(tt)?Z=!G_(G,tt):Z=G!==tt,Z?G!=null?W(U):m.add(U):G!==void 0&&m.has(U)?W(U):T.protectedKeys[U]=!0}T.prevProp=k,T.prevResolvedValues=A,T.isActive&&(y={...y,...A}),s&&n.blockInitialAnimation&&(R=!1);const X=N&&_;R&&(!X||D)&&p.push(...M.map(U=>{const G={type:S};if(typeof U=="string"&&s&&!X&&n.manuallyAnimateOnMount&&n.parent){const{parent:tt}=n,Z=kc(tt,U);if(tt.enteringChildren&&Z){const{delayChildren:F}=Z.transition||{};G.delay=j_(tt.enteringChildren,n,F)}}return{animation:U,options:G}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const S=kc(n,Array.isArray(h.initial)?h.initial[0]:h.initial);S&&S.transition&&(w.transition=S.transition)}m.forEach(S=>{const T=n.getBaseTarget(S),k=n.getValue(S);k&&(k.liveStyle=!0),w[S]=T??null}),p.push({animation:w})}let x=!!p.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?t(p):Promise.resolve()}function l(c,h){if(e[c].isActive===h)return Promise.resolve();n.variantChildren?.forEach(p=>p.animationState?.setActive(c,h)),e[c].isActive=h;const d=o(c);for(const p in e)e[p].protectedKeys={};return d}return{animateChanges:o,setActive:l,setAnimateFunction:i,getState:()=>e,reset:()=>{e=CE()}}}function J4(n,t){return typeof t=="string"?t!==n:Array.isArray(t)?!G_(t,n):!1}function Ca(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function CE(){return{animate:Ca(!0),whileInView:Ca(),whileHover:Ca(),whileTap:Ca(),whileDrag:Ca(),whileFocus:Ca(),exit:Ca()}}class qo{constructor(t){this.isMounted=!1,this.node=t}update(){}}class Q4 extends qo{constructor(t){super(t),t.animationState||(t.animationState=Z4(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();og(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:e}=this.node.prevProps||{};t!==e&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let tj=0;class ej extends qo{constructor(){super(...arguments),this.id=tj++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:e}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===s)return;const r=this.node.animationState.setActive("exit",!t);e&&!t&&r.then(()=>{e(this.id)})}mount(){const{register:t,onExitComplete:e}=this.node.presenceContext||{};e&&e(this.id),t&&(this.unmount=t(this.id))}unmount(){}}const nj={animation:{Feature:Q4},exit:{Feature:ej}};function Ah(n,t,e,s={passive:!0}){return n.addEventListener(t,e,s),()=>n.removeEventListener(t,e)}function Qh(n){return{point:{x:n.pageX,y:n.pageY}}}const sj=n=>t=>Fw(t)&&n(t,Qh(t));function xh(n,t,e,s){return Ah(n,t,sj(e),s)}const H_=1e-4,rj=1-H_,ij=1+H_,q_=.01,oj=0-q_,aj=0+q_;function vs(n){return n.max-n.min}function lj(n,t,e){return Math.abs(n-t)<=e}function TE(n,t,e,s=.5){n.origin=s,n.originPoint=Ze(t.min,t.max,n.origin),n.scale=vs(e)/vs(t),n.translate=Ze(e.min,e.max,n.origin)-n.originPoint,(n.scale>=rj&&n.scale<=ij||isNaN(n.scale))&&(n.scale=1),(n.translate>=oj&&n.translate<=aj||isNaN(n.translate))&&(n.translate=0)}function vh(n,t,e,s){TE(n.x,t.x,e.x,s?s.originX:void 0),TE(n.y,t.y,e.y,s?s.originY:void 0)}function kE(n,t,e){n.min=e.min+t.min,n.max=n.min+vs(t)}function cj(n,t,e){kE(n.x,t.x,e.x),kE(n.y,t.y,e.y)}function $E(n,t,e){n.min=t.min-e.min,n.max=n.min+vs(t)}function Cm(n,t,e){$E(n.x,t.x,e.x),$E(n.y,t.y,e.y)}function br(n){return[n("x"),n("y")]}const K_=({current:n})=>n?n.ownerDocument.defaultView:null,EE=(n,t)=>Math.abs(n-t);function uj(n,t){const e=EE(n.x,t.x),s=EE(n.y,t.y);return Math.sqrt(e**2+s**2)}class X_{constructor(t,e,{transformPagePoint:s,contextWindow:r=window,dragSnapToOrigin:i=!1,distanceThreshold:o=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=fx(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=uj(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=Xn;this.history.push({...x,timestamp:w});const{onStart:S,onMove:T}=this.handlers;y||(S&&S(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),T&&T(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=dx(y,this.transformPagePoint),qe.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const S=fx(m.type==="pointercancel"?this.lastMoveEventInfo:dx(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,S),x&&x(m,S)},!Fw(t))return;this.dragSnapToOrigin=i,this.handlers=e,this.transformPagePoint=s,this.distanceThreshold=o,this.contextWindow=r||window;const l=Qh(t),c=dx(l,this.transformPagePoint),{point:h}=c,{timestamp:d}=Xn;this.history=[{...h,timestamp:d}];const{onSessionStart:p}=e;p&&p(t,fx(c,this.history)),this.removeListeners=Yh(xh(this.contextWindow,"pointermove",this.handlePointerMove),xh(this.contextWindow,"pointerup",this.handlePointerUp),xh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(t){this.handlers=t}end(){this.removeListeners&&this.removeListeners(),zo(this.updatePoint)}}function dx(n,t){return t?{point:t(n.point)}:n}function IE(n,t){return{x:n.x-t.x,y:n.y-t.y}}function fx({point:n},t){return{point:n,delta:IE(n,Y_(t)),offset:IE(n,hj(t)),velocity:dj(t,.1)}}function hj(n){return n[0]}function Y_(n){return n[n.length-1]}function dj(n,t){if(n.length<2)return{x:0,y:0};let e=n.length-1,s=null;const r=Y_(n);for(;e>=0&&(s=n[e],!(r.timestamp-s.timestamp>ui(t)));)e--;if(!s)return{x:0,y:0};const i=wr(r.timestamp-s.timestamp);if(i===0)return{x:0,y:0};const o={x:(r.x-s.x)/i,y:(r.y-s.y)/i};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}function fj(n,{min:t,max:e},s){return t!==void 0&&n<t?n=s?Ze(t,n,s.min):Math.max(n,t):e!==void 0&&n>e&&(n=s?Ze(e,n,s.max):Math.min(n,e)),n}function NE(n,t,e){return{min:t!==void 0?n.min+t:void 0,max:e!==void 0?n.max+e-(n.max-n.min):void 0}}function pj(n,{top:t,left:e,bottom:s,right:r}){return{x:NE(n.x,e,r),y:NE(n.y,t,s)}}function AE(n,t){let e=t.min-n.min,s=t.max-n.max;return t.max-t.min<n.max-n.min&&([e,s]=[s,e]),{min:e,max:s}}function mj(n,t){return{x:AE(n.x,t.x),y:AE(n.y,t.y)}}function gj(n,t){let e=.5;const s=vs(n),r=vs(t);return r>s?e=$h(t.min,t.max-s,n.min):s>r&&(e=$h(n.min,n.max-r,t.min)),Hi(0,1,e)}function yj(n,t){const e={};return t.min!==void 0&&(e.min=t.min-n.min),t.max!==void 0&&(e.max=t.max-n.min),e}const mv=.35;function bj(n=mv){return n===!1?n=0:n===!0&&(n=mv),{x:_E(n,"left","right"),y:_E(n,"top","bottom")}}function _E(n,t,e){return{min:RE(n,t),max:RE(n,e)}}function RE(n,t){return typeof n=="number"?n:n[t]||0}const xj=new WeakMap;class vj{constructor(t){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=In(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=t}start(t,{snapToCursor:e=!1,distanceThreshold:s}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const i=p=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),e&&this.snapToCursor(Qh(p).point)},o=(p,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=kU(y),!this.openDragLock))return;this.latestPointerEvent=p,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),br(S=>{let T=this.getAxisMotionValue(S).get()||0;if(hi.test(T)){const{projection:k}=this.visualElement;if(k&&k.layout){const $=k.layout.layoutBox[S];$&&(T=vs($)*(parseFloat(T)/100))}}this.originPoint[S]=T}),x&&qe.postRender(()=>x(p,m)),fv(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},l=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:S}=m;if(b&&this.currentDirection===null){this.currentDirection=wj(S),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,S),this.updateAxis("y",m.point,S),this.visualElement.render(),w&&w(p,m)},c=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m,this.stop(p,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>br(p=>this.getAnimationState(p)==="paused"&&this.getAxisMotionValue(p).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new X_(t,{onSessionStart:i,onStart:o,onMove:l,onSessionEnd:c,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:K_(this.visualElement)})}stop(t,e){const s=t||this.latestPointerEvent,r=e||this.latestPanInfo,i=this.isDragging;if(this.cancel(),!i||!r||!s)return;const{velocity:o}=r;this.startAnimation(o);const{onDragEnd:l}=this.getProps();l&&qe.postRender(()=>l(s,r))}cancel(){this.isDragging=!1;const{projection:t,animationState:e}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),e&&e.setActive("whileDrag",!1)}updateAxis(t,e,s){const{drag:r}=this.getProps();if(!s||!Vp(t,r,this.currentDirection))return;const i=this.getAxisMotionValue(t);let o=this.originPoint[t]+s[t];this.constraints&&this.constraints[t]&&(o=fj(o,this.constraints[t],this.elastic[t])),i.set(o)}resolveConstraints(){const{dragConstraints:t,dragElastic:e}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;t&&vc(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):t&&s?this.constraints=pj(s.layoutBox,t):this.constraints=!1,this.elastic=bj(e),r!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&br(i=>{this.constraints!==!1&&this.getAxisMotionValue(i)&&(this.constraints[i]=yj(s.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:e}=this.getProps();if(!t||!vc(t))return!1;const s=t.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const i=S4(s,r.root,this.visualElement.getTransformPagePoint());let o=mj(r.layout.layoutBox,i);if(e){const l=e(x4(o));this.hasMutatedConstraints=!!l,l&&(o=D_(l))}return o}startAnimation(t){const{drag:e,dragMomentum:s,dragElastic:r,dragTransition:i,dragSnapToOrigin:o,onDragTransitionEnd:l}=this.getProps(),c=this.constraints||{},h=br(d=>{if(!Vp(d,e,this.currentDirection))return;let p=c&&c[d]||{};o&&(p={min:0,max:0});const m=r?200:1e6,y=r?40:1e7,b={type:"inertia",velocity:s?t[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...i,...p};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(l)}startAxisValueAnimation(t,e){const s=this.getAxisMotionValue(t);return fv(this.visualElement,t),s.start(Hw(t,s,0,e,this.visualElement,!1))}stopAnimation(){br(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){br(t=>this.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){return this.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){const e=`_drag${t.toUpperCase()}`,s=this.visualElement.getProps(),r=s[e];return r||this.visualElement.getValue(t,(s.initial?s.initial[t]:void 0)||0)}snapToCursor(t){br(e=>{const{drag:s}=this.getProps();if(!Vp(e,s,this.currentDirection))return;const{projection:r}=this.visualElement,i=this.getAxisMotionValue(e);if(r&&r.layout){const{min:o,max:l}=r.layout.layoutBox[e];i.set(t[e]-Ze(o,l,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:e}=this.getProps(),{projection:s}=this.visualElement;if(!vc(e)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};br(o=>{const l=this.getAxisMotionValue(o);if(l&&this.constraints!==!1){const c=l.get();r[o]=gj({min:c,max:c},this.constraints[o])}});const{transformTemplate:i}=this.visualElement.getProps();this.visualElement.current.style.transform=i?i({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),br(o=>{if(!Vp(o,t,null))return;const l=this.getAxisMotionValue(o),{min:c,max:h}=this.constraints[o];l.set(Ze(c,h,r[o]))})}addListeners(){if(!this.visualElement.current)return;xj.set(this.visualElement,this);const t=this.visualElement.current,e=xh(t,"pointerdown",c=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(c)}),s=()=>{const{dragConstraints:c}=this.getProps();vc(c)&&c.current&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,i=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),qe.read(s);const o=Ah(window,"resize",()=>this.scalePositionWithinConstraints()),l=r.addEventListener("didUpdate",(({delta:c,hasLayoutChanged:h})=>{this.isDragging&&h&&(br(d=>{const p=this.getAxisMotionValue(d);p&&(this.originPoint[d]+=c[d].translate,p.set(p.get()+c[d].translate))}),this.visualElement.render())}));return()=>{o(),e(),i(),l&&l()}}getProps(){const t=this.visualElement.getProps(),{drag:e=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:i=!1,dragElastic:o=mv,dragMomentum:l=!0}=t;return{...t,drag:e,dragDirectionLock:s,dragPropagation:r,dragConstraints:i,dragElastic:o,dragMomentum:l}}}function Vp(n,t,e){return(t===!0||t===n)&&(e===null||e===n)}function wj(n,t=10){let e=null;return Math.abs(n.y)>t?e="y":Math.abs(n.x)>t&&(e="x"),e}class Sj extends qo{constructor(t){super(t),this.removeGroupControls=Tr,this.removeListeners=Tr,this.controls=new vj(t)}mount(){const{dragControls:t}=this.node.getProps();t&&(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||Tr}unmount(){this.removeGroupControls(),this.removeListeners()}}const DE=n=>(t,e)=>{n&&qe.postRender(()=>n(t,e))};class Cj extends qo{constructor(){super(...arguments),this.removePointerDownListener=Tr}onPointerDown(t){this.session=new X_(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:K_(this.node)})}createPanHandlers(){const{onPanSessionStart:t,onPanStart:e,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:DE(t),onStart:DE(e),onMove:s,onEnd:(i,o)=>{delete this.session,r&&qe.postRender(()=>r(i,o))}}}mount(){this.removePointerDownListener=xh(this.node.current,"pointerdown",t=>this.onPointerDown(t))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const lm={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let px=!1;class Tj extends St.Component{componentDidMount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:s,layoutId:r}=this.props,{projection:i}=t;i&&(e.group&&e.group.add(i),s&&s.register&&r&&s.register(i),px&&i.root.didUpdate(),i.addEventListener("animationComplete",()=>{this.safeToRemove()}),i.setOptions({...i.options,onExitComplete:()=>this.safeToRemove()})),lm.hasEverUpdated=!0}getSnapshotBeforeUpdate(t){const{layoutDependency:e,visualElement:s,drag:r,isPresent:i}=this.props,{projection:o}=s;return o&&(o.isPresent=i,px=!0,r||t.layoutDependency!==e||e===void 0||t.isPresent!==i?o.willUpdate():this.safeToRemove(),t.isPresent!==i&&(i?o.promote():o.relegate()||qe.postRender(()=>{const l=o.getStack();(!l||!l.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:t}=this.props.visualElement;t&&(t.root.didUpdate(),Mw.postRender(()=>{!t.currentAnimation&&t.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:s}=this.props,{projection:r}=t;px=!0,r&&(r.scheduleCheckAfterUnmount(),e&&e.group&&e.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:t}=this.props;t&&t()}render(){return null}}function Z_(n){const[t,e]=x_(),s=St.useContext(pw);return it.jsx(Tj,{...n,layoutGroup:s,switchLayoutGroup:St.useContext(__),isPresent:t,safeToRemove:e})}function kj(n,t,e){const s=ls(n)?n:Rc(n);return s.start(Hw("",s,t,e)),s.animation}const $j=(n,t)=>n.depth-t.depth;class Ej{constructor(){this.children=[],this.isDirty=!1}add(t){yw(this.children,t),this.isDirty=!0}remove(t){bw(this.children,t),this.isDirty=!0}forEach(t){this.isDirty&&this.children.sort($j),this.isDirty=!1,this.children.forEach(t)}}function Ij(n,t){const e=Ms.now(),s=({timestamp:r})=>{const i=r-e;i>=t&&(zo(s),n(i-t))};return qe.setup(s,!0),()=>zo(s)}const J_=["TopLeft","TopRight","BottomLeft","BottomRight"],Nj=J_.length,OE=n=>typeof n=="string"?parseFloat(n):n,ME=n=>typeof n=="number"||Wt.test(n);function Aj(n,t,e,s,r,i){r?(n.opacity=Ze(0,e.opacity??1,_j(s)),n.opacityExit=Ze(t.opacity??1,0,Rj(s))):i&&(n.opacity=Ze(t.opacity??1,e.opacity??1,s));for(let o=0;o<Nj;o++){const l=`border${J_[o]}Radius`;let c=FE(t,l),h=FE(e,l);if(c===void 0&&h===void 0)continue;c||(c=0),h||(h=0),c===0||h===0||ME(c)===ME(h)?(n[l]=Math.max(Ze(OE(c),OE(h),s),0),(hi.test(h)||hi.test(c))&&(n[l]+="%")):n[l]=h}(t.rotate||e.rotate)&&(n.rotate=Ze(t.rotate||0,e.rotate||0,s))}function FE(n,t){return n[t]!==void 0?n[t]:n.borderRadius}const _j=Q_(0,.5,PA),Rj=Q_(.5,.95,Tr);function Q_(n,t,e){return s=>s<n?0:s>t?1:e($h(n,t,s))}function LE(n,t){n.min=t.min,n.max=t.max}function Fr(n,t){LE(n.x,t.x),LE(n.y,t.y)}function PE(n,t){n.translate=t.translate,n.scale=t.scale,n.originPoint=t.originPoint,n.origin=t.origin}function zE(n,t,e,s,r){return n-=t,n=Sm(n,1/e,s),r!==void 0&&(n=Sm(n,1/r,s)),n}function Dj(n,t=0,e=1,s=.5,r,i=n,o=n){if(hi.test(t)&&(t=parseFloat(t),t=Ze(o.min,o.max,t/100)-o.min),typeof t!="number")return;let l=Ze(i.min,i.max,s);n===i&&(l-=t),n.min=zE(n.min,t,e,l,r),n.max=zE(n.max,t,e,l,r)}function BE(n,t,[e,s,r],i,o){Dj(n,t[e],t[s],t[r],t.scale,i,o)}const Oj=["x","scaleX","originX"],Mj=["y","scaleY","originY"];function VE(n,t,e,s){BE(n.x,t,Oj,e?e.x:void 0,s?s.x:void 0),BE(n.y,t,Mj,e?e.y:void 0,s?s.y:void 0)}function UE(n){return n.translate===0&&n.scale===1}function tR(n){return UE(n.x)&&UE(n.y)}function jE(n,t){return n.min===t.min&&n.max===t.max}function Fj(n,t){return jE(n.x,t.x)&&jE(n.y,t.y)}function GE(n,t){return Math.round(n.min)===Math.round(t.min)&&Math.round(n.max)===Math.round(t.max)}function eR(n,t){return GE(n.x,t.x)&&GE(n.y,t.y)}function WE(n){return vs(n.x)/vs(n.y)}function HE(n,t){return n.translate===t.translate&&n.scale===t.scale&&n.originPoint===t.originPoint}class Lj{constructor(){this.members=[]}add(t){yw(this.members,t),t.scheduleRender()}remove(t){if(bw(this.members,t),t===this.prevLead&&(this.prevLead=void 0),t===this.lead){const e=this.members[this.members.length-1];e&&this.promote(e)}}relegate(t){const e=this.members.findIndex(r=>t===r);if(e===0)return!1;let s;for(let r=e;r>=0;r--){const i=this.members[r];if(i.isPresent!==!1){s=i;break}}return s?(this.promote(s),!0):!1}promote(t,e){const s=this.lead;if(t!==s&&(this.prevLead=s,this.lead=t,t.show(),s)){s.instance&&s.scheduleRender(),t.scheduleRender(),t.resumeFrom=s,e&&(t.resumeFrom.preserveOpacity=!0),s.snapshot&&(t.snapshot=s.snapshot,t.snapshot.latestValues=s.animationValues||s.latestValues),t.root&&t.root.isUpdating&&(t.isLayoutDirty=!0);const{crossfade:r}=t.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(t=>{const{options:e,resumingFrom:s}=t;e.onExitComplete&&e.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(t=>{t.instance&&t.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function Pj(n,t,e){let s="";const r=n.x.translate/t.x,i=n.y.translate/t.y,o=e?.z||0;if((r||i||o)&&(s=`translate3d(${r}px, ${i}px, ${o}px) `),(t.x!==1||t.y!==1)&&(s+=`scale(${1/t.x}, ${1/t.y}) `),e){const{transformPerspective:h,rotate:d,rotateX:p,rotateY:m,skewX:y,skewY:b}=e;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),p&&(s+=`rotateX(${p}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const l=n.x.scale*t.x,c=n.y.scale*t.y;return(l!==1||c!==1)&&(s+=`scale(${l}, ${c})`),s||"none"}const mx=["","X","Y","Z"],zj=1e3;let Bj=0;function gx(n,t,e,s){const{latestValues:r}=t;r[n]&&(e[n]=r[n],t.setStaticValue(n,0),s&&(s[n]=0))}function nR(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:t}=n.options;if(!t)return;const e=V_(t);if(window.MotionHasOptimisedAnimation(e,"transform")){const{layout:r,layoutId:i}=n.options;window.MotionCancelOptimisedAnimation(e,"transform",qe,!(r||i))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&nR(s)}function sR({attachResizeListener:n,defaultParent:t,measureScroll:e,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(o={},l=t?.()){this.id=Bj++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(jj),this.nodes.forEach(qj),this.nodes.forEach(Kj),this.nodes.forEach(Gj)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=l?l.root||l:this,this.path=l?[...l.path,l]:[],this.parent=l,this.depth=l?l.depth+1:0;for(let c=0;c<this.path.length;c++)this.path[c].shouldResetTransform=!0;this.root===this&&(this.nodes=new Ej)}addEventListener(o,l){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new ww),this.eventHandlers.get(o).add(l)}notifyListeners(o,...l){const c=this.eventHandlers.get(o);c&&c.notify(...l)}hasListeners(o){return this.eventHandlers.has(o)}mount(o){if(this.instance)return;this.isSVG=b_(o)&&!_U(o),this.instance=o;const{layoutId:l,layout:c,visualElement:h}=this.options;if(h&&!h.current&&h.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(c||l)&&(this.isLayoutDirty=!0),n){let d,p=0;const m=()=>this.root.updateBlockedByResize=!1;qe.read(()=>{p=window.innerWidth}),n(o,()=>{const y=window.innerWidth;y!==p&&(p=y,this.root.updateBlockedByResize=!0,d&&d(),d=Ij(m,250),lm.hasAnimatedSinceResize&&(lm.hasAnimatedSinceResize=!1,this.nodes.forEach(XE)))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&h&&(l||c)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:p,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||Qj,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),S=!this.targetLayout||!eR(this.targetLayout,y),T=!p&&m;if(this.options.layoutRoot||this.resumeFrom||T||p&&(S||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const k={...Dw(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(k.delay=0,k.type=!1),this.startAnimation(k),this.setAnimationOrigin(d,T)}else p||XE(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),zo(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Xj),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&nR(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const p=this.path[d];p.shouldResetTransform=!0,p.updateScroll("snapshot"),p.options.layoutRoot&&p.willUpdate(!1)}const{layoutId:l,layout:c}=this.options;if(l===void 0&&!c)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(qE);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(KE);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(Hj),this.nodes.forEach(Vj),this.nodes.forEach(Uj)):this.nodes.forEach(KE),this.clearAllSnapshots();const l=Ms.now();Xn.delta=Hi(0,1e3/60,l-Xn.timestamp),Xn.timestamp=l,Xn.isProcessing=!0,rx.update.process(Xn),rx.preRender.process(Xn),rx.render.process(Xn),Xn.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Mw.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Wj),this.sharedNodes.forEach(Yj)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,qe.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){qe.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!vs(this.snapshot.measuredBox.x)&&!vs(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let c=0;c<this.path.length;c++)this.path[c].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=In(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:l}=this.options;l&&l.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let l=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(l=!1),l&&this.instance){const c=s(this.instance);this.scroll={animationId:this.root.animationId,phase:o,isRoot:c,offset:e(this.instance),wasRoot:this.scroll?this.scroll.isRoot:c}}}resetTransform(){if(!r)return;const o=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,l=this.projectionDelta&&!tR(this.projectionDelta),c=this.getTransformTemplate(),h=c?c(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;o&&this.instance&&(l||Aa(this.latestValues)||d)&&(r(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const l=this.measurePageBox();let c=this.removeElementScroll(l);return o&&(c=this.removeTransform(c)),tG(c),{animationId:this.root.animationId,measuredBox:l,layoutBox:c,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:o}=this.options;if(!o)return In();const l=o.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(eG))){const{scroll:h}=this.root;h&&(wc(l.x,h.offset.x),wc(l.y,h.offset.y))}return l}removeElementScroll(o){const l=In();if(Fr(l,o),this.scroll?.wasRoot)return l;for(let c=0;c<this.path.length;c++){const h=this.path[c],{scroll:d,options:p}=h;h!==this.root&&d&&p.layoutScroll&&(d.wasRoot&&Fr(l,o),wc(l.x,d.offset.x),wc(l.y,d.offset.y))}return l}applyTransform(o,l=!1){const c=In();Fr(c,o);for(let h=0;h<this.path.length;h++){const d=this.path[h];!l&&d.options.layoutScroll&&d.scroll&&d!==d.root&&Sc(c,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),Aa(d.latestValues)&&Sc(c,d.latestValues)}return Aa(this.latestValues)&&Sc(c,this.latestValues),c}removeTransform(o){const l=In();Fr(l,o);for(let c=0;c<this.path.length;c++){const h=this.path[c];if(!h.instance||!Aa(h.latestValues))continue;cv(h.latestValues)&&h.updateSnapshot();const d=In(),p=h.measurePageBox();Fr(d,p),VE(l,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return Aa(this.latestValues)&&VE(l,this.latestValues),l}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==Xn.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const c=!!this.resumingFrom||this!==l;if(!(o||c&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:p}=this.options;if(!this.layout||!(d||p))return;this.resolvedRelativeTargetAt=Xn.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=In(),this.targetWithTransforms=In()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),cj(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Fr(this.target,this.layout.layoutBox),M_(this.target,this.targetDelta)):Fr(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||cv(this.parent.latestValues)||O_(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(o,l,c){this.relativeParent=o,this.linkedParentVersion=o.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=In(),this.relativeTargetOrigin=In(),Cm(this.relativeTargetOrigin,l,c),Fr(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const o=this.getLead(),l=!!this.resumingFrom||this!==o;let c=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(c=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(c=!1),this.resolvedRelativeTargetAt===Xn.timestamp&&(c=!1),c)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;Fr(this.layoutCorrected,this.layout.layoutBox);const p=this.treeScale.x,m=this.treeScale.y;w4(this.layoutCorrected,this.treeScale,this.path,l),o.layout&&!o.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(o.target=o.layout.layoutBox,o.targetWithTransforms=In());const{target:y}=o;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(PE(this.prevProjectionDelta.x,this.projectionDelta.x),PE(this.prevProjectionDelta.y,this.projectionDelta.y)),vh(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==p||this.treeScale.y!==m||!HE(this.projectionDelta.x,this.prevProjectionDelta.x)||!HE(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){if(this.options.visualElement?.scheduleRender(),o){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=Cc(),this.projectionDelta=Cc(),this.projectionDeltaWithTransform=Cc()}setAnimationOrigin(o,l=!1){const c=this.snapshot,h=c?c.latestValues:{},d={...this.latestValues},p=Cc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!l;const m=In(),y=c?c.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),S=!w||w.members.length<=1,T=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(Jj));this.animationProgress=0;let k;this.mixTargetDelta=$=>{const E=$/1e3;YE(p.x,o.x,E),YE(p.y,o.y,E),this.setTargetDelta(p),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Cm(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),Zj(this.relativeTarget,this.relativeTargetOrigin,m,E),k&&Fj(this.relativeTarget,k)&&(this.isProjectionDirty=!1),k||(k=In()),Fr(k,this.relativeTarget)),x&&(this.animationValues=d,Aj(d,h,this.latestValues,E,T,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(zo(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=qe.update(()=>{lm.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Rc(0)),this.currentAnimation=kj(this.motionValue,[0,1e3],{...o,velocity:0,isSync:!0,onUpdate:l=>{this.mixTargetDelta(l),o.onUpdate&&o.onUpdate(l)},onStop:()=>{},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(zj),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:l,target:c,layout:h,latestValues:d}=o;if(!(!l||!c||!h)){if(this!==o&&this.layout&&h&&rR(this.options.animationType,this.layout.layoutBox,h.layoutBox)){c=this.target||In();const p=vs(this.layout.layoutBox.x);c.x.min=o.target.x.min,c.x.max=c.x.min+p;const m=vs(this.layout.layoutBox.y);c.y.min=o.target.y.min,c.y.max=c.y.min+m}Fr(l,c),Sc(l,d),vh(this.projectionDeltaWithTransform,this.layoutCorrected,l,d)}}registerSharedNode(o,l){this.sharedNodes.has(o)||this.sharedNodes.set(o,new Lj),this.sharedNodes.get(o).add(l);const h=l.options.initialPromotionConfig;l.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(l):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){const{layoutId:o}=this.options;return o?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:o}=this.options;return o?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:l,preserveFollowOpacity:c}={}){const h=this.getStack();h&&h.promote(this,c),o&&(this.projectionDelta=void 0,this.needsReset=!0),l&&this.setOptions({transition:l})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetSkewAndRotation(){const{visualElement:o}=this.options;if(!o)return;let l=!1;const{latestValues:c}=o;if((c.z||c.rotate||c.rotateX||c.rotateY||c.rotateZ||c.skewX||c.skewY)&&(l=!0),!l)return;const h={};c.z&&gx("z",o,h,this.animationValues);for(let d=0;d<mx.length;d++)gx(`rotate${mx[d]}`,o,h,this.animationValues),gx(`skew${mx[d]}`,o,h,this.animationValues);o.render();for(const d in h)o.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);o.scheduleRender()}applyProjectionStyles(o,l){if(!this.instance||this.isSVG)return;if(!this.isVisible){o.visibility="hidden";return}const c=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,o.visibility="",o.opacity="",o.pointerEvents=am(l?.pointerEvents)||"",o.transform=c?c(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(o.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,o.pointerEvents=am(l?.pointerEvents)||""),this.hasProjected&&!Aa(this.latestValues)&&(o.transform=c?c({},""):"none",this.hasProjected=!1);return}o.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let p=Pj(this.projectionDeltaWithTransform,this.treeScale,d);c&&(p=c(d,p)),o.transform=p;const{x:m,y}=this.projectionDelta;o.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?o.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:o.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in lv){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:S}=lv[b],T=p==="none"?d[b]:x(d[b],h);if(w){const k=w.length;for(let $=0;$<k;$++)o[w[$]]=T}else S?this.options.visualElement.renderState.vars[b]=T:o[b]=T}this.options.layoutId&&(o.pointerEvents=h===this?am(l?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>o.currentAnimation?.stop()),this.root.nodes.forEach(qE),this.root.sharedNodes.clear()}}}function Vj(n){n.updateLayout()}function Uj(n){const t=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&t&&n.hasListeners("didUpdate")){const{layoutBox:e,measuredBox:s}=n.layout,{animationType:r}=n.options,i=t.source!==n.layout.source;r==="size"?br(d=>{const p=i?t.measuredBox[d]:t.layoutBox[d],m=vs(p);p.min=e[d].min,p.max=p.min+m}):rR(r,t.layoutBox,e)&&br(d=>{const p=i?t.measuredBox[d]:t.layoutBox[d],m=vs(e[d]);p.max=p.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const o=Cc();vh(o,e,t.layoutBox);const l=Cc();i?vh(l,n.applyTransform(s,!0),t.measuredBox):vh(l,e,t.layoutBox);const c=!tR(o);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:p,layout:m}=d;if(p&&m){const y=In();Cm(y,t.layoutBox,p.layoutBox);const b=In();Cm(b,e,m.layoutBox),eR(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:e,snapshot:t,delta:l,layoutDelta:o,hasLayoutChanged:c,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:e}=n.options;e&&e()}n.options.transition=void 0}function jj(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Gj(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Wj(n){n.clearSnapshot()}function qE(n){n.clearMeasurements()}function KE(n){n.isLayoutDirty=!1}function Hj(n){const{visualElement:t}=n.options;t&&t.getProps().onBeforeLayoutMeasure&&t.notify("BeforeLayoutMeasure"),n.resetTransform()}function XE(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function qj(n){n.resolveTargetDelta()}function Kj(n){n.calcProjection()}function Xj(n){n.resetSkewAndRotation()}function Yj(n){n.removeLeadSnapshot()}function YE(n,t,e){n.translate=Ze(t.translate,0,e),n.scale=Ze(t.scale,1,e),n.origin=t.origin,n.originPoint=t.originPoint}function ZE(n,t,e,s){n.min=Ze(t.min,e.min,s),n.max=Ze(t.max,e.max,s)}function Zj(n,t,e,s){ZE(n.x,t.x,e.x,s),ZE(n.y,t.y,e.y,s)}function Jj(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const Qj={duration:.45,ease:[.4,0,.1,1]},JE=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),QE=JE("applewebkit/")&&!JE("chrome/")?Math.round:Tr;function tI(n){n.min=QE(n.min),n.max=QE(n.max)}function tG(n){tI(n.x),tI(n.y)}function rR(n,t,e){return n==="position"||n==="preserve-aspect"&&!lj(WE(t),WE(e),.2)}function eG(n){return n!==n.root&&n.scroll?.wasRoot}const nG=sR({attachResizeListener:(n,t)=>Ah(n,"resize",t),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),yx={current:void 0},iR=sR({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!yx.current){const n=new nG({});n.mount(window),n.setOptions({layoutScroll:!0}),yx.current=n}return yx.current},resetTransform:(n,t)=>{n.style.transform=t!==void 0?t:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),sG={pan:{Feature:Cj},drag:{Feature:Sj,ProjectionNode:iR,MeasureLayout:Z_}};function eI(n,t,e){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",e==="Start");const r="onHover"+e,i=s[r];i&&qe.postRender(()=>i(t,Qh(t)))}class rG extends qo{mount(){const{current:t}=this.node;t&&(this.unmount=$U(t,(e,s)=>(eI(this.node,s,"Start"),r=>eI(this.node,r,"End"))))}unmount(){}}class iG extends qo{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch{t=!0}!t||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Yh(Ah(this.node.current,"focus",()=>this.onFocus()),Ah(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function nI(n,t,e){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",e==="Start");const r="onTap"+(e==="End"?"":e),i=s[r];i&&qe.postRender(()=>i(t,Qh(t)))}class oG extends qo{mount(){const{current:t}=this.node;t&&(this.unmount=AU(t,(e,s)=>(nI(this.node,s,"Start"),(r,{success:i})=>nI(this.node,r,i?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const gv=new WeakMap,bx=new WeakMap,aG=n=>{const t=gv.get(n.target);t&&t(n)},lG=n=>{n.forEach(aG)};function cG({root:n,...t}){const e=n||document;bx.has(e)||bx.set(e,{});const s=bx.get(e),r=JSON.stringify(t);return s[r]||(s[r]=new IntersectionObserver(lG,{root:n,...t})),s[r]}function uG(n,t,e){const s=cG(t);return gv.set(n,e),s.observe(n),()=>{gv.delete(n),s.unobserve(n)}}const hG={some:0,all:1};class dG extends qo{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:e,margin:s,amount:r="some",once:i}=t,o={root:e?e.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:hG[r]},l=c=>{const{isIntersecting:h}=c;if(this.isInView===h||(this.isInView=h,i&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:p}=this.node.getProps(),m=h?d:p;m&&m(c)};return uG(this.node.current,o,l)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:t,prevProps:e}=this.node;["amount","margin","root"].some(fG(t,e))&&this.startObserver()}unmount(){}}function fG({viewport:n={}},{viewport:t={}}={}){return e=>n[e]!==t[e]}const pG={inView:{Feature:dG},tap:{Feature:oG},focus:{Feature:iG},hover:{Feature:rG}},mG={layout:{ProjectionNode:iR,MeasureLayout:Z_}},gG={...nj,...pG,...sG,...mG},Ta=b4(gG,_4);const yG=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),bG=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,e,s)=>s?s.toUpperCase():e.toLowerCase()),sI=n=>{const t=bG(n);return t.charAt(0).toUpperCase()+t.slice(1)},oR=(...n)=>n.filter((t,e,s)=>!!t&&t.trim()!==""&&s.indexOf(t)===e).join(" ").trim(),xG=n=>{for(const t in n)if(t.startsWith("aria-")||t==="role"||t==="title")return!0};var vG={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const wG=St.forwardRef(({color:n="currentColor",size:t=24,strokeWidth:e=2,absoluteStrokeWidth:s,className:r="",children:i,iconNode:o,...l},c)=>St.createElement("svg",{ref:c,...vG,width:t,height:t,stroke:n,strokeWidth:s?Number(e)*24/Number(t):e,className:oR("lucide",r),...!i&&!xG(l)&&{"aria-hidden":"true"},...l},[...o.map(([h,d])=>St.createElement(h,d)),...Array.isArray(i)?i:[i]]));const hs=(n,t)=>{const e=St.forwardRef(({className:s,...r},i)=>St.createElement(wG,{ref:i,iconNode:t,className:oR(`lucide-${yG(sI(n))}`,`lucide-${n}`,s),...r}));return e.displayName=sI(n),e};const SG=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],CG=hs("activity",SG);const TG=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],kG=hs("circle-check",TG);const $G=[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]],EG=hs("copy",$G);const IG=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],NG=hs("cpu",IG);const AG=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],rI=hs("history",AG);const _G=[["path",{d:"M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",key:"zw3jo"}],["path",{d:"M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",key:"1wduqc"}],["path",{d:"M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",key:"kqbvx6"}]],RG=hs("layers",_G);const DG=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],iI=hs("lock",DG);const OG=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],MG=hs("log-out",OG);const FG=[["path",{d:"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",key:"1a8usu"}],["path",{d:"m15 5 4 4",key:"1mk7zo"}]],LG=hs("pencil",FG);const PG=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],zG=hs("search",PG);const BG=[["circle",{cx:"18",cy:"5",r:"3",key:"gq8acd"}],["circle",{cx:"6",cy:"12",r:"3",key:"w7nqdw"}],["circle",{cx:"18",cy:"19",r:"3",key:"1xt0gg"}],["line",{x1:"8.59",x2:"15.42",y1:"13.51",y2:"17.49",key:"47mynk"}],["line",{x1:"15.41",x2:"8.59",y1:"6.51",y2:"10.49",key:"1n3mei"}]],VG=hs("share-2",BG);const UG=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],oI=hs("trending-down",UG);const jG=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],aI=hs("trending-up",jG);const GG=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],WG=hs("triangle-alert",GG);const HG=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],qG=hs("trophy",HG);const KG=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],lI=hs("zap",KG);function lg(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e}function XG(n,t,e,s){function r(i){return i instanceof e?i:new e(function(o){o(i)})}return new(e||(e=Promise))(function(i,o){function l(d){try{h(s.next(d))}catch(p){o(p)}}function c(d){try{h(s.throw(d))}catch(p){o(p)}}function h(d){d.done?i(d.value):r(d.value).then(l,c)}h((s=s.apply(n,t||[])).next())})}const YG=n=>n?(...t)=>n(...t):(...t)=>fetch(...t);class qw extends Error{constructor(t,e="FunctionsError",s){super(t),this.name=e,this.context=s}}class ZG extends qw{constructor(t){super("Failed to send a request to the Edge Function","FunctionsFetchError",t)}}class cI extends qw{constructor(t){super("Relay Error invoking the Edge Function","FunctionsRelayError",t)}}class uI extends qw{constructor(t){super("Edge Function returned a non-2xx status code","FunctionsHttpError",t)}}var yv;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(yv||(yv={}));class JG{constructor(t,{headers:e={},customFetch:s,region:r=yv.Any}={}){this.url=t,this.headers=e,this.region=r,this.fetch=YG(s)}setAuth(t){this.headers.Authorization=`Bearer ${t}`}invoke(t){return XG(this,arguments,void 0,function*(e,s={}){var r;let i,o;try{const{headers:l,method:c,body:h,signal:d,timeout:p}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${e}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(l&&!Object.prototype.hasOwnProperty.call(l,"Content-Type")||!l)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;p&&(o=new AbortController,i=setTimeout(()=>o.abort(),p),d?(w=o.signal,d.addEventListener("abort",()=>o.abort())):w=o.signal);const S=yield this.fetch(b.toString(),{method:c||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),l),body:x,signal:w}).catch(E=>{throw new ZG(E)}),T=S.headers.get("x-relay-error");if(T&&T==="true")throw new cI(S);if(!S.ok)throw new uI(S);let k=((r=S.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),$;return k==="application/json"?$=yield S.json():k==="application/octet-stream"||k==="application/pdf"?$=yield S.blob():k==="text/event-stream"?$=S:k==="multipart/form-data"?$=yield S.formData():$=yield S.text(),{data:$,error:null,response:S}}catch(l){return{data:null,error:l,response:l instanceof uI||l instanceof cI?l.context:void 0}}finally{i&&clearTimeout(i)}})}}var QG=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},tW=class{constructor(n){var t,e;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(t=n.shouldThrowOnError)!==null&&t!==void 0?t:!1,this.signal=n.signal,this.isMaybeSingle=(e=n.isMaybeSingle)!==null&&e!==void 0?e:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,t){return this.headers=new Headers(this.headers),this.headers.set(n,t),this}then(n,t){var e=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let r=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async i=>{let o=null,l=null,c=null,h=i.status,d=i.statusText;if(i.ok){var p,m;if(e.method!=="HEAD"){var y;const S=await i.text();S===""||(e.headers.get("Accept")==="text/csv"||e.headers.get("Accept")&&(!((y=e.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?l=S:l=JSON.parse(S))}const x=(p=e.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),w=(m=i.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(c=parseInt(w[1])),e.isMaybeSingle&&e.method==="GET"&&Array.isArray(l)&&(l.length>1?(o={code:"PGRST116",details:`Results contain ${l.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},l=null,c=null,h=406,d="Not Acceptable"):l.length===1?l=l[0]:l=null)}else{var b;const x=await i.text();try{o=JSON.parse(x),Array.isArray(o)&&i.status===404&&(l=[],o=null,h=200,d="OK")}catch{i.status===404&&x===""?(h=204,d="No Content"):o={message:x}}if(o&&e.isMaybeSingle&&(!(o==null||(b=o.details)===null||b===void 0)&&b.includes("0 rows"))&&(o=null,h=200,d="OK"),o&&e.shouldThrowOnError)throw new QG(o)}return{error:o,data:l,count:c,status:h,statusText:d}});return this.shouldThrowOnError||(r=r.catch(i=>{var o;let l="";const c=i?.cause;if(c){var h,d,p,m;const b=(h=c?.message)!==null&&h!==void 0?h:"",x=(d=c?.code)!==null&&d!==void 0?d:"";l=`${(p=i?.name)!==null&&p!==void 0?p:"FetchError"}: ${i?.message}`,l+=`

Caused by: ${(m=c?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(l+=` (${x})`),c?.stack&&(l+=`
${c.stack}`)}else{var y;l=(y=i?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(o=i?.name)!==null&&o!==void 0?o:"FetchError"}: ${i?.message}`,details:l,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(n,t)}returns(){return this}overrideTypes(){return this}},eW=class extends tW{select(n){let t=!1;const e=(n??"*").split("").map(s=>/\s/.test(s)&&!t?"":(s==='"'&&(t=!t),s)).join("");return this.url.searchParams.set("select",e),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:t=!0,nullsFirst:e,foreignTable:s,referencedTable:r=s}={}){const i=r?`${r}.order`:"order",o=this.url.searchParams.get(i);return this.url.searchParams.set(i,`${o?`${o},`:""}${n}.${t?"asc":"desc"}${e===void 0?"":e?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:t,referencedTable:e=t}={}){const s=typeof e>"u"?"limit":`${e}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,t,{foreignTable:e,referencedTable:s=e}={}){const r=typeof s>"u"?"offset":`${s}.offset`,i=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(r,`${n}`),this.url.searchParams.set(i,`${t-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:t=!1,settings:e=!1,buffers:s=!1,wal:r=!1,format:i="text"}={}){var o;const l=[n?"analyze":null,t?"verbose":null,e?"settings":null,s?"buffers":null,r?"wal":null].filter(Boolean).join("|"),c=(o=this.headers.get("Accept"))!==null&&o!==void 0?o:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${i}; for="${c}"; options=${l};`),i==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const hI=new RegExp("[,()]");var fc=class extends eW{eq(n,t){return this.url.searchParams.append(n,`eq.${t}`),this}neq(n,t){return this.url.searchParams.append(n,`neq.${t}`),this}gt(n,t){return this.url.searchParams.append(n,`gt.${t}`),this}gte(n,t){return this.url.searchParams.append(n,`gte.${t}`),this}lt(n,t){return this.url.searchParams.append(n,`lt.${t}`),this}lte(n,t){return this.url.searchParams.append(n,`lte.${t}`),this}like(n,t){return this.url.searchParams.append(n,`like.${t}`),this}likeAllOf(n,t){return this.url.searchParams.append(n,`like(all).{${t.join(",")}}`),this}likeAnyOf(n,t){return this.url.searchParams.append(n,`like(any).{${t.join(",")}}`),this}ilike(n,t){return this.url.searchParams.append(n,`ilike.${t}`),this}ilikeAllOf(n,t){return this.url.searchParams.append(n,`ilike(all).{${t.join(",")}}`),this}ilikeAnyOf(n,t){return this.url.searchParams.append(n,`ilike(any).{${t.join(",")}}`),this}regexMatch(n,t){return this.url.searchParams.append(n,`match.${t}`),this}regexIMatch(n,t){return this.url.searchParams.append(n,`imatch.${t}`),this}is(n,t){return this.url.searchParams.append(n,`is.${t}`),this}isDistinct(n,t){return this.url.searchParams.append(n,`isdistinct.${t}`),this}in(n,t){const e=Array.from(new Set(t)).map(s=>typeof s=="string"&&hI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${e})`),this}notIn(n,t){const e=Array.from(new Set(t)).map(s=>typeof s=="string"&&hI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${e})`),this}contains(n,t){return typeof t=="string"?this.url.searchParams.append(n,`cs.${t}`):Array.isArray(t)?this.url.searchParams.append(n,`cs.{${t.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(t)}`),this}containedBy(n,t){return typeof t=="string"?this.url.searchParams.append(n,`cd.${t}`):Array.isArray(t)?this.url.searchParams.append(n,`cd.{${t.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(t)}`),this}rangeGt(n,t){return this.url.searchParams.append(n,`sr.${t}`),this}rangeGte(n,t){return this.url.searchParams.append(n,`nxl.${t}`),this}rangeLt(n,t){return this.url.searchParams.append(n,`sl.${t}`),this}rangeLte(n,t){return this.url.searchParams.append(n,`nxr.${t}`),this}rangeAdjacent(n,t){return this.url.searchParams.append(n,`adj.${t}`),this}overlaps(n,t){return typeof t=="string"?this.url.searchParams.append(n,`ov.${t}`):this.url.searchParams.append(n,`ov.{${t.join(",")}}`),this}textSearch(n,t,{config:e,type:s}={}){let r="";s==="plain"?r="pl":s==="phrase"?r="ph":s==="websearch"&&(r="w");const i=e===void 0?"":`(${e})`;return this.url.searchParams.append(n,`${r}fts${i}.${t}`),this}match(n){return Object.entries(n).forEach(([t,e])=>{this.url.searchParams.append(t,`eq.${e}`)}),this}not(n,t,e){return this.url.searchParams.append(n,`not.${t}.${e}`),this}or(n,{foreignTable:t,referencedTable:e=t}={}){const s=e?`${e}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,t,e){return this.url.searchParams.append(n,`${t}.${e}`),this}},nW=class{constructor(n,{headers:t={},schema:e,fetch:s}){this.url=n,this.headers=new Headers(t),this.schema=e,this.fetch=s}select(n,t){const{head:e=!1,count:s}=t??{},r=e?"HEAD":"GET";let i=!1;const o=(n??"*").split("").map(l=>/\s/.test(l)&&!i?"":(l==='"'&&(i=!i),l)).join("");return this.url.searchParams.set("select",o),s&&this.headers.append("Prefer",`count=${s}`),new fc({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:t,defaultToNull:e=!0}={}){var s;const r="POST";if(t&&this.headers.append("Prefer",`count=${t}`),e||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const i=n.reduce((o,l)=>o.concat(Object.keys(l)),[]);if(i.length>0){const o=[...new Set(i)].map(l=>`"${l}"`);this.url.searchParams.set("columns",o.join(","))}}return new fc({method:r,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:t,ignoreDuplicates:e=!1,count:s,defaultToNull:r=!0}={}){var i;const o="POST";if(this.headers.append("Prefer",`resolution=${e?"ignore":"merge"}-duplicates`),t!==void 0&&this.url.searchParams.set("on_conflict",t),s&&this.headers.append("Prefer",`count=${s}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const l=n.reduce((c,h)=>c.concat(Object.keys(h)),[]);if(l.length>0){const c=[...new Set(l)].map(h=>`"${h}"`);this.url.searchParams.set("columns",c.join(","))}}return new fc({method:o,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}update(n,{count:t}={}){var e;const s="PATCH";return t&&this.headers.append("Prefer",`count=${t}`),new fc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}delete({count:n}={}){var t;const e="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new fc({method:e,url:this.url,headers:this.headers,schema:this.schema,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}},sW=class aR{constructor(t,{headers:e={},schema:s,fetch:r}={}){this.url=t,this.headers=new Headers(e),this.schemaName=s,this.fetch=r}from(t){if(!t||typeof t!="string"||t.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new nW(new URL(`${this.url}/${t}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(t){return new aR(this.url,{headers:this.headers,schema:t,fetch:this.fetch})}rpc(t,e={},{head:s=!1,get:r=!1,count:i}={}){var o;let l;const c=new URL(`${this.url}/rpc/${t}`);let h;s||r?(l=s?"HEAD":"GET",Object.entries(e).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{c.searchParams.append(p,m)})):(l="POST",h=e);const d=new Headers(this.headers);return i&&d.set("Prefer",`count=${i}`),new fc({method:l,url:c,headers:d,schema:this.schemaName,body:h,fetch:(o=this.fetch)!==null&&o!==void 0?o:fetch})}};class rW{constructor(){}static detectEnvironment(){var t;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((t=navigator.userAgent)===null||t===void 0)&&t.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const e=process.versions;if(e&&e.node){const s=e.node,r=parseInt(s.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const t=this.detectEnvironment();if(t.constructor)return t.constructor;let e=t.error||"WebSocket not supported in this environment.";throw t.workaround&&(e+=`

Suggested solution: ${t.workaround}`),new Error(e)}static createWebSocket(t,e){const s=this.getWebSocketConstructor();return new s(t,e)}static isWebSocketSupported(){try{const t=this.detectEnvironment();return t.type==="native"||t.type==="ws"}catch{return!1}}}const iW="2.89.0",oW=`realtime-js/${iW}`,lR="1.0.0",aW="2.0.0",dI=lR,bv=1e4,lW=1e3,cW=100;var No;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(No||(No={}));var En;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(En||(En={}));var Ur;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(Ur||(Ur={}));var xv;(function(n){n.websocket="websocket"})(xv||(xv={}));var Da;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(Da||(Da={}));class uW{constructor(t){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=t??[]}encode(t,e){if(t.event===this.BROADCAST_EVENT&&!(t.payload instanceof ArrayBuffer)&&typeof t.payload.event=="string")return e(this._binaryEncodeUserBroadcastPush(t));let s=[t.join_ref,t.ref,t.topic,t.event,t.payload];return e(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(t){var e;return this._isArrayBuffer((e=t.payload)===null||e===void 0?void 0:e.payload)?this._encodeBinaryUserBroadcastPush(t):this._encodeJsonUserBroadcastPush(t)}_encodeBinaryUserBroadcastPush(t){var e,s;const r=(s=(e=t.payload)===null||e===void 0?void 0:e.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(t,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(t){var e,s;const r=(s=(e=t.payload)===null||e===void 0?void 0:e.payload)!==null&&s!==void 0?s:{},o=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(t,this.JSON_ENCODING,o)}_encodeUserBroadcastPush(t,e,s){var r,i;const o=t.topic,l=(r=t.ref)!==null&&r!==void 0?r:"",c=(i=t.join_ref)!==null&&i!==void 0?i:"",h=t.payload.event,d=this.allowedMetadataKeys?this._pick(t.payload,this.allowedMetadataKeys):{},p=Object.keys(d).length===0?"":JSON.stringify(d);if(c.length>255)throw new Error(`joinRef length ${c.length} exceeds maximum of 255`);if(l.length>255)throw new Error(`ref length ${l.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`topic length ${o.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+c.length+l.length+o.length+h.length+p.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,c.length),b.setUint8(x++,l.length),b.setUint8(x++,o.length),b.setUint8(x++,h.length),b.setUint8(x++,p.length),b.setUint8(x++,e),Array.from(c,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(l,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(o,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(h,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(p,S=>b.setUint8(x++,S.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(t,e){if(this._isArrayBuffer(t)){let s=this._binaryDecode(t);return e(s)}if(typeof t=="string"){const s=JSON.parse(t),[r,i,o,l,c]=s;return e({join_ref:r,ref:i,topic:o,event:l,payload:c})}return e({})}_binaryDecode(t){const e=new DataView(t),s=e.getUint8(0),r=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(t,e,r)}_decodeUserBroadcast(t,e,s){const r=e.getUint8(1),i=e.getUint8(2),o=e.getUint8(3),l=e.getUint8(4);let c=this.HEADER_LENGTH+4;const h=s.decode(t.slice(c,c+r));c=c+r;const d=s.decode(t.slice(c,c+i));c=c+i;const p=s.decode(t.slice(c,c+o));c=c+o;const m=t.slice(c,t.byteLength),y=l===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return o>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(t){var e;return t instanceof ArrayBuffer||((e=t?.constructor)===null||e===void 0?void 0:e.name)==="ArrayBuffer"}_pick(t,e){return!t||typeof t!="object"?{}:Object.fromEntries(Object.entries(t).filter(([s])=>e.includes(s)))}}class cR{constructor(t,e){this.callback=t,this.timerCalc=e,this.timer=void 0,this.tries=0,this.callback=t,this.timerCalc=e}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Pe;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Pe||(Pe={}));const fI=(n,t,e={})=>{var s;const r=(s=e.skipTypes)!==null&&s!==void 0?s:[];return t?Object.keys(t).reduce((i,o)=>(i[o]=hW(o,n,t,r),i),{}):{}},hW=(n,t,e,s)=>{const r=t.find(l=>l.name===n),i=r?.type,o=e[n];return i&&!s.includes(i)?uR(i,o):vv(o)},uR=(n,t)=>{if(n.charAt(0)==="_"){const e=n.slice(1,n.length);return mW(t,e)}switch(n){case Pe.bool:return dW(t);case Pe.float4:case Pe.float8:case Pe.int2:case Pe.int4:case Pe.int8:case Pe.numeric:case Pe.oid:return fW(t);case Pe.json:case Pe.jsonb:return pW(t);case Pe.timestamp:return gW(t);case Pe.abstime:case Pe.date:case Pe.daterange:case Pe.int4range:case Pe.int8range:case Pe.money:case Pe.reltime:case Pe.text:case Pe.time:case Pe.timestamptz:case Pe.timetz:case Pe.tsrange:case Pe.tstzrange:return vv(t);default:return vv(t)}},vv=n=>n,dW=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},fW=n=>{if(typeof n=="string"){const t=parseFloat(n);if(!Number.isNaN(t))return t}return n},pW=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},mW=(n,t)=>{if(typeof n!="string")return n;const e=n.length-1,s=n[e];if(n[0]==="{"&&s==="}"){let i;const o=n.slice(1,e);try{i=JSON.parse("["+o+"]")}catch{i=o?o.split(","):[]}return i.map(l=>uR(t,l))}return n},gW=n=>typeof n=="string"?n.replace(" ","T"):n,hR=n=>{const t=new URL(n);return t.protocol=t.protocol.replace(/^ws/i,"http"),t.pathname=t.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),t.pathname===""||t.pathname==="/"?t.pathname="/api/broadcast":t.pathname=t.pathname+"/api/broadcast",t.href};class xx{constructor(t,e,s={},r=bv){this.channel=t,this.event=e,this.payload=s,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(t){this.timeout=t,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(t){this.payload=Object.assign(Object.assign({},this.payload),t)}receive(t,e){var s;return this._hasReceived(t)&&e((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:t,callback:e}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const t=e=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=e,this._matchReceive(e)};this.channel._on(this.refEvent,{},t),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(t,e){this.refEvent&&this.channel._trigger(this.refEvent,{status:t,response:e})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:t,response:e}){this.recHooks.filter(s=>s.status===t).forEach(s=>s.callback(e))}_hasReceived(t){return this.receivedResp&&this.receivedResp.status===t}}var pI;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(pI||(pI={}));class wh{constructor(t,e){this.channel=t,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=e?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},r=>{const{onJoin:i,onLeave:o,onSync:l}=this.caller;this.joinRef=this.channel._joinRef(),this.state=wh.syncState(this.state,r,i,o),this.pendingDiffs.forEach(c=>{this.state=wh.syncDiff(this.state,c,i,o)}),this.pendingDiffs=[],l()}),this.channel._on(s.diff,{},r=>{const{onJoin:i,onLeave:o,onSync:l}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=wh.syncDiff(this.state,r,i,o),l())}),this.onJoin((r,i,o)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:i,newPresences:o})}),this.onLeave((r,i,o)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:i,leftPresences:o})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(t,e,s,r){const i=this.cloneDeep(t),o=this.transformState(e),l={},c={};return this.map(i,(h,d)=>{o[h]||(c[h]=d)}),this.map(o,(h,d)=>{const p=i[h];if(p){const m=d.map(w=>w.presence_ref),y=p.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=p.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(l[h]=b),x.length>0&&(c[h]=x)}else l[h]=d}),this.syncDiff(i,{joins:l,leaves:c},s,r)}static syncDiff(t,e,s,r){const{joins:i,leaves:o}={joins:this.transformState(e.joins),leaves:this.transformState(e.leaves)};return s||(s=()=>{}),r||(r=()=>{}),this.map(i,(l,c)=>{var h;const d=(h=t[l])!==null&&h!==void 0?h:[];if(t[l]=this.cloneDeep(c),d.length>0){const p=t[l].map(y=>y.presence_ref),m=d.filter(y=>p.indexOf(y.presence_ref)<0);t[l].unshift(...m)}s(l,d,c)}),this.map(o,(l,c)=>{let h=t[l];if(!h)return;const d=c.map(p=>p.presence_ref);h=h.filter(p=>d.indexOf(p.presence_ref)<0),t[l]=h,r(l,h,c),h.length===0&&delete t[l]}),t}static map(t,e){return Object.getOwnPropertyNames(t).map(s=>e(s,t[s]))}static transformState(t){return t=this.cloneDeep(t),Object.getOwnPropertyNames(t).reduce((e,s)=>{const r=t[s];return"metas"in r?e[s]=r.metas.map(i=>(i.presence_ref=i.phx_ref,delete i.phx_ref,delete i.phx_ref_prev,i)):e[s]=r,e},{})}static cloneDeep(t){return JSON.parse(JSON.stringify(t))}onJoin(t){this.caller.onJoin=t}onLeave(t){this.caller.onLeave=t}onSync(t){this.caller.onSync=t}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var mI;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(mI||(mI={}));var Sh;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(Sh||(Sh={}));var Ui;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(Ui||(Ui={}));class Tc{constructor(t,e={config:{}},s){var r,i;if(this.topic=t,this.params=e,this.socket=s,this.bindings={},this.state=En.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=t.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},e.config),this.timeout=this.socket.timeout,this.joinPush=new xx(this,Ur.join,this.params,this.timeout),this.rejoinTimer=new cR(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=En.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=En.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=En.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=En.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=En.errored,this.rejoinTimer.scheduleTimeout())}),this._on(Ur.reply,{},(o,l)=>{this._trigger(this._replyEventName(l),o)}),this.presence=new wh(this),this.broadcastEndpointURL=hR(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((i=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||i===void 0)&&i.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(t,e=this.timeout){var s,r,i;if(this.socket.isConnected()||this.socket.connect(),this.state==En.closed){const{config:{broadcast:o,presence:l,private:c}}=this.params,h=(r=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&r!==void 0?r:[],d=!!this.bindings[Sh.PRESENCE]&&this.bindings[Sh.PRESENCE].length>0||((i=this.params.config.presence)===null||i===void 0?void 0:i.enabled)===!0,p={},m={broadcast:o,presence:Object.assign(Object.assign({},l),{enabled:d}),postgres_changes:h,private:c};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(y=>t?.(Ui.CHANNEL_ERROR,y)),this._onClose(()=>t?.(Ui.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(e),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){t?.(Ui.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,S=[];for(let T=0;T<w;T++){const k=x[T],{filter:{event:$,schema:E,table:N,filter:_}}=k,R=y&&y[T];if(R&&R.event===$&&Tc.isFilterValueEqual(R.schema,E)&&Tc.isFilterValueEqual(R.table,N)&&Tc.isFilterValueEqual(R.filter,_))S.push(Object.assign(Object.assign({},k),{id:R.id}));else{this.unsubscribe(),this.state=En.errored,t?.(Ui.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=S,t&&t(Ui.SUBSCRIBED);return}}).receive("error",y=>{this.state=En.errored,t?.(Ui.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{t?.(Ui.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(t,e={}){return await this.send({type:"presence",event:"track",payload:t},e.timeout||this.timeout)}async untrack(t={}){return await this.send({type:"presence",event:"untrack"},t)}on(t,e,s){return this.state===En.joined&&t===Sh.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(t,e,s)}async httpSend(t,e,s={}){var r;if(e==null)return Promise.reject("Payload is required for httpSend()");const i={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(i.Authorization=`Bearer ${this.socket.accessTokenValue}`);const o={method:"POST",headers:i,body:JSON.stringify({messages:[{topic:this.subTopic,event:t,payload:e,private:this.private}]})},l=await this._fetchWithTimeout(this.broadcastEndpointURL,o,(r=s.timeout)!==null&&r!==void 0?r:this.timeout);if(l.status===202)return{success:!0};let c=l.statusText;try{const h=await l.json();c=h.error||h.message||c}catch{}return Promise.reject(new Error(c))}async send(t,e={}){var s,r;if(!this._canPush()&&t.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:i,payload:o}=t,l={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(l.Authorization=`Bearer ${this.socket.accessTokenValue}`);const c={method:"POST",headers:l,body:JSON.stringify({messages:[{topic:this.subTopic,event:i,payload:o,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,c,(s=e.timeout)!==null&&s!==void 0?s:this.timeout);return await((r=h.body)===null||r===void 0?void 0:r.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(i=>{var o,l,c;const h=this._push(t.type,t,e.timeout||this.timeout);t.type==="broadcast"&&!(!((c=(l=(o=this.params)===null||o===void 0?void 0:o.config)===null||l===void 0?void 0:l.broadcast)===null||c===void 0)&&c.ack)&&i("ok"),h.receive("ok",()=>i("ok")),h.receive("error",()=>i("error")),h.receive("timeout",()=>i("timed out"))})}updateJoinPayload(t){this.joinPush.updatePayload(t)}unsubscribe(t=this.timeout){this.state=En.leaving;const e=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(Ur.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(r=>{s=new xx(this,Ur.leave,{},t),s.receive("ok",()=>{e(),r("ok")}).receive("timeout",()=>{e(),r("timed out")}).receive("error",()=>{r("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(t=>t.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=En.closed,this.bindings={}}async _fetchWithTimeout(t,e,s){const r=new AbortController,i=setTimeout(()=>r.abort(),s),o=await this.socket.fetch(t,Object.assign(Object.assign({},e),{signal:r.signal}));return clearTimeout(i),o}_push(t,e,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new xx(this,t,e,s);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(t){if(t.startTimeout(),this.pushBuffer.push(t),this.pushBuffer.length>cW){const e=this.pushBuffer.shift();e&&(e.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${e.event}`,e.payload))}}_onMessage(t,e,s){return e}_isMember(t){return this.topic===t}_joinRef(){return this.joinPush.ref}_trigger(t,e,s){var r,i;const o=t.toLocaleLowerCase(),{close:l,error:c,leave:h,join:d}=Ur;if(s&&[l,c,h,d].indexOf(o)>=0&&s!==this._joinRef())return;let m=this._onMessage(o,e,s);if(e&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===o}).map(y=>y.callback(m,s)):(i=this.bindings[o])===null||i===void 0||i.filter(y=>{var b,x,w,S,T,k;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in y){const $=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return $&&((x=e.ids)===null||x===void 0?void 0:x.includes($))&&(E==="*"||E?.toLocaleLowerCase()===((w=e.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const $=(T=(S=y?.filter)===null||S===void 0?void 0:S.event)===null||T===void 0?void 0:T.toLocaleLowerCase();return $==="*"||$===((k=e?.event)===null||k===void 0?void 0:k.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===o}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:S,type:T,errors:k}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:S,eventType:T,new:{},old:{},errors:k}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===En.closed}_isJoined(){return this.state===En.joined}_isJoining(){return this.state===En.joining}_isLeaving(){return this.state===En.leaving}_replyEventName(t){return`chan_reply_${t}`}_on(t,e,s){const r=t.toLocaleLowerCase(),i={type:r,filter:e,callback:s};return this.bindings[r]?this.bindings[r].push(i):this.bindings[r]=[i],this}_off(t,e){const s=t.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(r=>{var i;return!(((i=r.type)===null||i===void 0?void 0:i.toLocaleLowerCase())===s&&Tc.isEqual(r.filter,e))})),this}static isEqual(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const s in t)if(t[s]!==e[s])return!1;return!0}static isFilterValueEqual(t,e){return(t??void 0)===(e??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(t){this._on(Ur.close,{},t)}_onError(t){this._on(Ur.error,{},e=>t(e))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(t=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=En.joining,this.joinPush.resend(t))}_getPayloadRecords(t){const e={new:{},old:{}};return(t.type==="INSERT"||t.type==="UPDATE")&&(e.new=fI(t.columns,t.record)),(t.type==="UPDATE"||t.type==="DELETE")&&(e.old=fI(t.columns,t.old_record)),e}}const vx=()=>{},Up={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},yW=[1e3,2e3,5e3,1e4],bW=1e4,xW=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class vW{constructor(t,e){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=bv,this.transport=null,this.heartbeatIntervalMs=Up.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=vx,this.ref=0,this.reconnectTimer=null,this.vsn=dI,this.logger=vx,this.conn=null,this.sendBuffer=[],this.serializer=new uW,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...i)=>r(...i):(...i)=>fetch(...i),!(!((s=e?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=e.params.apikey,this.endPoint=`${t}/${xv.websocket}`,this.httpEndpoint=hR(t),this._initializeOptions(e),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(e?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=rW.createWebSocket(this.endpointURL())}catch(t){this._setConnectionState("disconnected");const e=t.message;throw e.includes("Node.js")?new Error(`${e}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${e}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(t,e){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(t?this.conn.close(t,e??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(t){const e=await t.unsubscribe();return this.channels.length===0&&this.disconnect(),e}async removeAllChannels(){const t=await Promise.all(this.channels.map(e=>e.unsubscribe()));return this.channels=[],this.disconnect(),t}log(t,e,s){this.logger(t,e,s)}connectionState(){switch(this.conn&&this.conn.readyState){case No.connecting:return Da.Connecting;case No.open:return Da.Open;case No.closing:return Da.Closing;default:return Da.Closed}}isConnected(){return this.connectionState()===Da.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(t,e={config:{}}){const s=`realtime:${t}`,r=this.getChannels().find(i=>i.topic===s);if(r)return r;{const i=new Tc(`realtime:${t}`,e,this);return this.channels.push(i),i}}push(t){const{topic:e,event:s,payload:r,ref:i}=t,o=()=>{this.encode(t,l=>{var c;(c=this.conn)===null||c===void 0||c.send(l)})};this.log("push",`${e} ${s} (${i})`,r),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(t=null){this._authPromise=this._performAuth(t);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var t;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(e){this.log("error","error in heartbeat callback",e)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(e){this.log("error","error in heartbeat callback",e)}this._wasManualDisconnect=!1,(t=this.conn)===null||t===void 0||t.close(lW,"heartbeat timeout"),setTimeout(()=>{var e;this.isConnected()||(e=this.reconnectTimer)===null||e===void 0||e.scheduleTimeout()},Up.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(e){this.log("error","error in heartbeat callback",e)}this._setAuthSafely("heartbeat")}onHeartbeat(t){this.heartbeatCallback=t}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(t=>t()),this.sendBuffer=[])}_makeRef(){let t=this.ref+1;return t===this.ref?this.ref=0:this.ref=t,this.ref.toString()}_leaveOpenTopic(t){let e=this.channels.find(s=>s.topic===t&&(s._isJoined()||s._isJoining()));e&&(this.log("transport",`leaving duplicate topic "${t}"`),e.unsubscribe())}_remove(t){this.channels=this.channels.filter(e=>e.topic!==t.topic)}_onConnMessage(t){this.decode(t.data,e=>{if(e.topic==="phoenix"&&e.event==="phx_reply")try{this.heartbeatCallback(e.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}e.ref&&e.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:r,payload:i,ref:o}=e,l=o?`(${o})`:"",c=i.status||"";this.log("receive",`${c} ${s} ${r} ${l}`.trim(),i),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(r,i,o)),this._triggerStateCallbacks("message",e)})}_clearTimer(t){var e;t==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):t==="reconnect"&&((e=this.reconnectTimer)===null||e===void 0||e.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=t=>this._onConnError(t),this.conn.onmessage=t=>this._onConnMessage(t),this.conn.onclose=t=>this._onConnClose(t),this.conn.readyState===No.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===No.open||this.conn.readyState===No.connecting)try{this.conn.close()}catch(t){this.log("error","Error closing connection",t)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(t=>t.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(e=>{this.log("error","error waiting for auth on connect",e),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const t=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(t),this.workerRef.onerror=e=>{this.log("worker","worker error",e.message),this._terminateWorker()},this.workerRef.onmessage=e=>{e.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(t){var e;this._setConnectionState("disconnected"),this.log("transport","close",t),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(e=this.reconnectTimer)===null||e===void 0||e.scheduleTimeout(),this._triggerStateCallbacks("close",t)}_onConnError(t){this._setConnectionState("disconnected"),this.log("transport",`${t}`),this._triggerChanError(),this._triggerStateCallbacks("error",t)}_triggerChanError(){this.channels.forEach(t=>t._trigger(Ur.error))}_appendParams(t,e){if(Object.keys(e).length===0)return t;const s=t.match(/\?/)?"&":"?",r=new URLSearchParams(e);return`${t}${s}${r}`}_workerObjectUrl(t){let e;if(t)e=t;else{const s=new Blob([xW],{type:"application/javascript"});e=URL.createObjectURL(s)}return e}_setConnectionState(t,e=!1){this._connectionState=t,t==="connecting"?this._wasManualDisconnect=!1:t==="disconnecting"&&(this._wasManualDisconnect=e)}async _performAuth(t=null){let e,s=!1;if(t)e=t,s=!0;else if(this.accessToken)try{e=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),e=this.accessTokenValue}else e=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=e&&(this.accessTokenValue=e,this.channels.forEach(r=>{const i={access_token:e,version:oW};e&&r.updateJoinPayload(i),r.joinedOnce&&r._isJoined()&&r._push(Ur.access_token,{access_token:e})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(t="general"){this._isManualToken()||this.setAuth().catch(e=>{this.log("error",`Error setting auth in ${t}`,e)})}_triggerStateCallbacks(t,e){try{this.stateChangeCallbacks[t].forEach(s=>{try{s(e)}catch(r){this.log("error",`error in ${t} callback`,r)}})}catch(s){this.log("error",`error triggering ${t} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new cR(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},Up.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(t){var e,s,r,i,o,l,c,h,d,p,m,y;switch(this.transport=(e=t?.transport)!==null&&e!==void 0?e:null,this.timeout=(s=t?.timeout)!==null&&s!==void 0?s:bv,this.heartbeatIntervalMs=(r=t?.heartbeatIntervalMs)!==null&&r!==void 0?r:Up.HEARTBEAT_INTERVAL,this.worker=(i=t?.worker)!==null&&i!==void 0?i:!1,this.accessToken=(o=t?.accessToken)!==null&&o!==void 0?o:null,this.heartbeatCallback=(l=t?.heartbeatCallback)!==null&&l!==void 0?l:vx,this.vsn=(c=t?.vsn)!==null&&c!==void 0?c:dI,t?.params&&(this.params=t.params),t?.logger&&(this.logger=t.logger),(t?.logLevel||t?.log_level)&&(this.logLevel=t.logLevel||t.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=t?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>yW[b-1]||bW),this.vsn){case lR:this.encode=(d=t?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(p=t?.decode)!==null&&p!==void 0?p:((b,x)=>x(JSON.parse(b)));break;case aW:this.encode=(m=t?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=t?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=t?.workerUrl}}}var _h=class extends Error{constructor(n,t){super(n),this.name="IcebergError",this.status=t.status,this.icebergType=t.icebergType,this.icebergCode=t.icebergCode,this.details=t.details,this.isCommitStateUnknown=t.icebergType==="CommitStateUnknownException"||[500,502,504].includes(t.status)&&t.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function wW(n,t,e){const s=new URL(t,n);if(e)for(const[r,i]of Object.entries(e))i!==void 0&&s.searchParams.set(r,i);return s.toString()}async function SW(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function CW(n){const t=n.fetchImpl??globalThis.fetch;return{async request({method:e,path:s,query:r,body:i,headers:o}){const l=wW(n.baseUrl,s,r),c=await SW(n.auth),h=await t(l,{method:e,headers:{...i?{"Content-Type":"application/json"}:{},...c,...o},body:i?JSON.stringify(i):void 0}),d=await h.text(),p=(h.headers.get("content-type")||"").includes("application/json"),m=p&&d?JSON.parse(d):d;if(!h.ok){const y=p?m:void 0,b=y?.error;throw new _h(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function jp(n){return n.join("")}var TW=class{constructor(n,t=""){this.client=n,this.prefix=t}async listNamespaces(n){const t=n?{parent:jp(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:t})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,t){const e={namespace:n.namespace,properties:t?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:e})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${jp(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${jp(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${jp(n.namespace)}`}),!0}catch(t){if(t instanceof _h&&t.status===404)return!1;throw t}}async createNamespaceIfNotExists(n,t){try{return await this.createNamespace(n,t)}catch(e){if(e instanceof _h&&e.status===409)return;throw e}}};function rc(n){return n.join("")}var kW=class{constructor(n,t="",e){this.client=n,this.prefix=t,this.accessDelegation=e}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${rc(n.namespace)}/tables`})).data.identifiers}async createTable(n,t){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${rc(n.namespace)}/tables`,body:t,headers:e})).data.metadata}async updateTable(n,t){const e=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${rc(n.namespace)}/tables/${n.name}`,body:t});return{"metadata-location":e.data["metadata-location"],metadata:e.data.metadata}}async dropTable(n,t){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${rc(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(t?.purge??!1)}})}async loadTable(n){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${rc(n.namespace)}/tables/${n.name}`,headers:t})).data.metadata}async tableExists(n){const t={};this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${rc(n.namespace)}/tables/${n.name}`,headers:t}),!0}catch(e){if(e instanceof _h&&e.status===404)return!1;throw e}}async createTableIfNotExists(n,t){try{return await this.createTable(n,t)}catch(e){if(e instanceof _h&&e.status===409)return await this.loadTable({namespace:n.namespace,name:t.name});throw e}}},$W=class{constructor(n){let t="v1";n.catalogName&&(t+=`/${n.catalogName}`);const e=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=CW({baseUrl:e,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new TW(this.client,t),this.tableOps=new kW(this.client,t,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,t){return this.namespaceOps.createNamespace(n,t)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,t){return this.tableOps.createTable(n,t)}async updateTable(n,t){return this.tableOps.updateTable(n,t)}async dropTable(n,t){await this.tableOps.dropTable(n,t)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,t){return this.namespaceOps.createNamespaceIfNotExists(n,t)}async createTableIfNotExists(n,t){return this.tableOps.createTableIfNotExists(n,t)}},cg=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function Ye(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var EW=class extends cg{constructor(n,t,e){super(n),this.name="StorageApiError",this.status=t,this.statusCode=e}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},wv=class extends cg{constructor(n,t){super(n),this.name="StorageUnknownError",this.originalError=t}};const Kw=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),IW=()=>Response,Sv=n=>{if(Array.isArray(n))return n.map(e=>Sv(e));if(typeof n=="function"||n!==Object(n))return n;const t={};return Object.entries(n).forEach(([e,s])=>{const r=e.replace(/([-_][a-z])/gi,i=>i.toUpperCase().replace(/[-_]/g,""));t[r]=Sv(s)}),t},NW=n=>{if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},AW=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function Rh(n){"@babel/helpers - typeof";return Rh=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Rh(n)}function _W(n,t){if(Rh(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var s=e.call(n,t);if(Rh(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function RW(n){var t=_W(n,"string");return Rh(t)=="symbol"?t:t+""}function DW(n,t,e){return(t=RW(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function gI(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);t&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),e.push.apply(e,s)}return e}function Ut(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?gI(Object(e),!0).forEach(function(s){DW(n,s,e[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):gI(Object(e)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(e,s))})}return n}const wx=n=>{var t;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(t=n.error)===null||t===void 0?void 0:t.message)||JSON.stringify(n)},OW=async(n,t,e)=>{n instanceof await IW()&&!e?.noResolveJson?n.json().then(s=>{const r=n.status||500,i=s?.statusCode||r+"";t(new EW(wx(s),r,i))}).catch(s=>{t(new wv(wx(s),s))}):t(new wv(wx(n),n))},MW=(n,t,e,s)=>{const r={method:n,headers:t?.headers||{}};return n==="GET"||!s?r:(NW(s)?(r.headers=Ut({"Content-Type":"application/json"},t?.headers),r.body=JSON.stringify(s)):r.body=s,t?.duplex&&(r.duplex=t.duplex),Ut(Ut({},r),e))};async function td(n,t,e,s,r,i){return new Promise((o,l)=>{n(e,MW(t,s,r,i)).then(c=>{if(!c.ok)throw c;return s?.noResolveJson?c:c.json()}).then(c=>o(c)).catch(c=>OW(c,l,s))})}async function Dh(n,t,e,s){return td(n,"GET",t,e,s)}async function Vr(n,t,e,s,r){return td(n,"POST",t,s,r,e)}async function Cv(n,t,e,s,r){return td(n,"PUT",t,s,r,e)}async function FW(n,t,e,s){return td(n,"HEAD",t,Ut(Ut({},e),{},{noResolveJson:!0}),s)}async function Xw(n,t,e,s,r){return td(n,"DELETE",t,s,r,e)}var LW=class{constructor(n,t){this.downloadFn=n,this.shouldThrowOnError=t}then(n,t){return this.execute().then(n,t)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(t){if(n.shouldThrowOnError)throw t;if(Ye(t))return{data:null,error:t};throw t}}};let dR;dR=Symbol.toStringTag;var PW=class{constructor(n,t){this.downloadFn=n,this.shouldThrowOnError=t,this[dR]="BlobDownloadBuilder",this.promise=null}asStream(){return new LW(this.downloadFn,this.shouldThrowOnError)}then(n,t){return this.getPromise().then(n,t)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(t){if(n.shouldThrowOnError)throw t;if(Ye(t))return{data:null,error:t};throw t}}};const zW={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},yI={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var BW=class{constructor(n,t={},e,s){this.shouldThrowOnError=!1,this.url=n,this.headers=t,this.bucketId=e,this.fetch=Kw(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,t,e,s){var r=this;try{let i;const o=Ut(Ut({},yI),s);let l=Ut(Ut({},r.headers),n==="POST"&&{"x-upsert":String(o.upsert)});const c=o.metadata;typeof Blob<"u"&&e instanceof Blob?(i=new FormData,i.append("cacheControl",o.cacheControl),c&&i.append("metadata",r.encodeMetadata(c)),i.append("",e)):typeof FormData<"u"&&e instanceof FormData?(i=e,i.has("cacheControl")||i.append("cacheControl",o.cacheControl),c&&!i.has("metadata")&&i.append("metadata",r.encodeMetadata(c))):(i=e,l["cache-control"]=`max-age=${o.cacheControl}`,l["content-type"]=o.contentType,c&&(l["x-metadata"]=r.toBase64(r.encodeMetadata(c))),(typeof ReadableStream<"u"&&i instanceof ReadableStream||i&&typeof i=="object"&&"pipe"in i&&typeof i.pipe=="function")&&!o.duplex&&(o.duplex="half")),s?.headers&&(l=Ut(Ut({},l),s.headers));const h=r._removeEmptyFolders(t),d=r._getFinalPath(h),p=await(n=="PUT"?Cv:Vr)(r.fetch,`${r.url}/object/${d}`,i,Ut({headers:l},o?.duplex?{duplex:o.duplex}:{}));return{data:{path:h,id:p.Id,fullPath:p.Key},error:null}}catch(i){if(r.shouldThrowOnError)throw i;if(Ye(i))return{data:null,error:i};throw i}}async upload(n,t,e){return this.uploadOrUpdate("POST",n,t,e)}async uploadToSignedUrl(n,t,e,s){var r=this;const i=r._removeEmptyFolders(n),o=r._getFinalPath(i),l=new URL(r.url+`/object/upload/sign/${o}`);l.searchParams.set("token",t);try{let c;const h=Ut({upsert:yI.upsert},s),d=Ut(Ut({},r.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&e instanceof Blob?(c=new FormData,c.append("cacheControl",h.cacheControl),c.append("",e)):typeof FormData<"u"&&e instanceof FormData?(c=e,c.append("cacheControl",h.cacheControl)):(c=e,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:i,fullPath:(await Cv(r.fetch,l.toString(),c,{headers:d})).Key},error:null}}catch(c){if(r.shouldThrowOnError)throw c;if(Ye(c))return{data:null,error:c};throw c}}async createSignedUploadUrl(n,t){var e=this;try{let s=e._getFinalPath(n);const r=Ut({},e.headers);t?.upsert&&(r["x-upsert"]="true");const i=await Vr(e.fetch,`${e.url}/object/upload/sign/${s}`,{},{headers:r}),o=new URL(e.url+i.url),l=o.searchParams.get("token");if(!l)throw new cg("No token returned by API");return{data:{signedUrl:o.toString(),path:n,token:l},error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ye(s))return{data:null,error:s};throw s}}async update(n,t,e){return this.uploadOrUpdate("PUT",n,t,e)}async move(n,t,e){var s=this;try{return{data:await Vr(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:t,destinationBucket:e?.destinationBucket},{headers:s.headers}),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ye(r))return{data:null,error:r};throw r}}async copy(n,t,e){var s=this;try{return{data:{path:(await Vr(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:t,destinationBucket:e?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ye(r))return{data:null,error:r};throw r}}async createSignedUrl(n,t,e){var s=this;try{let r=s._getFinalPath(n),i=await Vr(s.fetch,`${s.url}/object/sign/${r}`,Ut({expiresIn:t},e?.transform?{transform:e.transform}:{}),{headers:s.headers});const o=e?.download?`&download=${e.download===!0?"":e.download}`:"";return i={signedUrl:encodeURI(`${s.url}${i.signedURL}${o}`)},{data:i,error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ye(r))return{data:null,error:r};throw r}}async createSignedUrls(n,t,e){var s=this;try{const r=await Vr(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:t,paths:n},{headers:s.headers}),i=e?.download?`&download=${e.download===!0?"":e.download}`:"";return{data:r.map(o=>Ut(Ut({},o),{},{signedUrl:o.signedURL?encodeURI(`${s.url}${o.signedURL}${i}`):null})),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ye(r))return{data:null,error:r};throw r}}download(n,t){const e=typeof t?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(t?.transform||{}),r=s?`?${s}`:"",i=this._getFinalPath(n),o=()=>Dh(this.fetch,`${this.url}/${e}/${i}${r}`,{headers:this.headers,noResolveJson:!0});return new PW(o,this.shouldThrowOnError)}async info(n){var t=this;const e=t._getFinalPath(n);try{return{data:Sv(await Dh(t.fetch,`${t.url}/object/info/${e}`,{headers:t.headers})),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ye(s))return{data:null,error:s};throw s}}async exists(n){var t=this;const e=t._getFinalPath(n);try{return await FW(t.fetch,`${t.url}/object/${e}`,{headers:t.headers}),{data:!0,error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Ye(s)&&s instanceof wv){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,t){const e=this._getFinalPath(n),s=[],r=t?.download?`download=${t.download===!0?"":t.download}`:"";r!==""&&s.push(r);const i=typeof t?.transform<"u"?"render/image":"object",o=this.transformOptsToQueryString(t?.transform||{});o!==""&&s.push(o);let l=s.join("&");return l!==""&&(l=`?${l}`),{data:{publicUrl:encodeURI(`${this.url}/${i}/public/${e}${l}`)}}}async remove(n){var t=this;try{return{data:await Xw(t.fetch,`${t.url}/object/${t.bucketId}`,{prefixes:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}async list(n,t,e){var s=this;try{const r=Ut(Ut(Ut({},zW),t),{},{prefix:n||""});return{data:await Vr(s.fetch,`${s.url}/object/list/${s.bucketId}`,r,{headers:s.headers},e),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Ye(r))return{data:null,error:r};throw r}}async listV2(n,t){var e=this;try{const s=Ut({},n);return{data:await Vr(e.fetch,`${e.url}/object/list-v2/${e.bucketId}`,s,{headers:e.headers},t),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ye(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const t=[];return n.width&&t.push(`width=${n.width}`),n.height&&t.push(`height=${n.height}`),n.resize&&t.push(`resize=${n.resize}`),n.format&&t.push(`format=${n.format}`),n.quality&&t.push(`quality=${n.quality}`),t.join("&")}};const fR="2.89.0",pR={"X-Client-Info":`storage-js/${fR}`};var VW=class{constructor(n,t={},e,s){this.shouldThrowOnError=!1;const r=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=Ut(Ut({},pR),t),this.fetch=Kw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var t=this;try{const e=t.listBucketOptionsToQueryString(n);return{data:await Dh(t.fetch,`${t.url}/bucket${e}`,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}async getBucket(n){var t=this;try{return{data:await Dh(t.fetch,`${t.url}/bucket/${n}`,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}async createBucket(n,t={public:!1}){var e=this;try{return{data:await Vr(e.fetch,`${e.url}/bucket`,{id:n,name:n,type:t.type,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ye(s))return{data:null,error:s};throw s}}async updateBucket(n,t){var e=this;try{return{data:await Cv(e.fetch,`${e.url}/bucket/${n}`,{id:n,name:n,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Ye(s))return{data:null,error:s};throw s}}async emptyBucket(n){var t=this;try{return{data:await Vr(t.fetch,`${t.url}/bucket/${n}/empty`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Xw(t.fetch,`${t.url}/bucket/${n}`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}listBucketOptionsToQueryString(n){const t={};return n&&("limit"in n&&(t.limit=String(n.limit)),"offset"in n&&(t.offset=String(n.offset)),n.search&&(t.search=n.search),n.sortColumn&&(t.sortColumn=n.sortColumn),n.sortOrder&&(t.sortOrder=n.sortOrder)),Object.keys(t).length>0?"?"+new URLSearchParams(t).toString():""}},UW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},pR),t),this.fetch=Kw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var t=this;try{return{data:await Vr(t.fetch,`${t.url}/bucket`,{name:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}async listBuckets(n){var t=this;try{const e=new URLSearchParams;n?.limit!==void 0&&e.set("limit",n.limit.toString()),n?.offset!==void 0&&e.set("offset",n.offset.toString()),n?.sortColumn&&e.set("sortColumn",n.sortColumn),n?.sortOrder&&e.set("sortOrder",n.sortOrder),n?.search&&e.set("search",n.search);const s=e.toString(),r=s?`${t.url}/bucket?${s}`:`${t.url}/bucket`;return{data:await Dh(t.fetch,r,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Xw(t.fetch,`${t.url}/bucket/${n}`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Ye(e))return{data:null,error:e};throw e}}from(n){var t=this;if(!AW(n))throw new cg("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const e=new $W({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>t.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(e,{get(r,i){const o=r[i];return typeof o!="function"?o:async(...l)=>{try{return{data:await o.apply(r,l),error:null}}catch(c){if(s)throw c;return{data:null,error:c}}}}})}};const Yw={"X-Client-Info":`storage-js/${fR}`,"Content-Type":"application/json"};var mR=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function Zs(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var Sx=class extends mR{constructor(n,t,e){super(n),this.name="StorageVectorsApiError",this.status=t,this.statusCode=e}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},jW=class extends mR{constructor(n,t){super(n),this.name="StorageVectorsUnknownError",this.originalError=t}};const Zw=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),GW=n=>{if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},bI=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),WW=async(n,t,e)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!e?.noResolveJson){const s=n.status||500,r=n;if(typeof r.json=="function")r.json().then(i=>{const o=i?.statusCode||i?.code||s+"";t(new Sx(bI(i),s,o))}).catch(()=>{const i=s+"";t(new Sx(r.statusText||`HTTP ${s} error`,s,i))});else{const i=s+"";t(new Sx(r.statusText||`HTTP ${s} error`,s,i))}}else t(new jW(bI(n),n))},HW=(n,t,e,s)=>{const r={method:n,headers:t?.headers||{}};return s?(GW(s)?(r.headers=Ut({"Content-Type":"application/json"},t?.headers),r.body=JSON.stringify(s)):r.body=s,Ut(Ut({},r),e)):r};async function qW(n,t,e,s,r,i){return new Promise((o,l)=>{n(e,HW(t,s,r,i)).then(c=>{if(!c.ok)throw c;if(s?.noResolveJson)return c;const h=c.headers.get("content-type");return!h||!h.includes("application/json")?{}:c.json()}).then(c=>o(c)).catch(c=>WW(c,l,s))})}async function Js(n,t,e,s,r){return qW(n,"POST",t,s,r,e)}var KW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Yw),t),this.fetch=Zw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/CreateIndex`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async getIndex(n,t){var e=this;try{return{data:await Js(e.fetch,`${e.url}/GetIndex`,{vectorBucketName:n,indexName:t},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Zs(s))return{data:null,error:s};throw s}}async listIndexes(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/ListIndexes`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async deleteIndex(n,t){var e=this;try{return{data:await Js(e.fetch,`${e.url}/DeleteIndex`,{vectorBucketName:n,indexName:t},{headers:e.headers})||{},error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Zs(s))return{data:null,error:s};throw s}}},XW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Yw),t),this.fetch=Zw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var t=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await Js(t.fetch,`${t.url}/PutVectors`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async getVectors(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/GetVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async listVectors(n){var t=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await Js(t.fetch,`${t.url}/ListVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async queryVectors(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/QueryVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async deleteVectors(n){var t=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await Js(t.fetch,`${t.url}/DeleteVectors`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}},YW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Yw),t),this.fetch=Zw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async getBucket(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/GetVectorBucket`,{vectorBucketName:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async listBuckets(n={}){var t=this;try{return{data:await Js(t.fetch,`${t.url}/ListVectorBuckets`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Js(t.fetch,`${t.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(Zs(e))return{data:null,error:e};throw e}}},ZW=class extends YW{constructor(n,t={}){super(n,t.headers||{},t.fetch)}from(n){return new JW(this.url,this.headers,n,this.fetch)}async createBucket(n){var t=()=>super.createBucket,e=this;return t().call(e,n)}async getBucket(n){var t=()=>super.getBucket,e=this;return t().call(e,n)}async listBuckets(n={}){var t=()=>super.listBuckets,e=this;return t().call(e,n)}async deleteBucket(n){var t=()=>super.deleteBucket,e=this;return t().call(e,n)}},JW=class extends KW{constructor(n,t,e,s){super(n,t,s),this.vectorBucketName=e}async createIndex(n){var t=()=>super.createIndex,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName}))}async listIndexes(n={}){var t=()=>super.listIndexes,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName}))}async getIndex(n){var t=()=>super.getIndex,e=this;return t().call(e,e.vectorBucketName,n)}async deleteIndex(n){var t=()=>super.deleteIndex,e=this;return t().call(e,e.vectorBucketName,n)}index(n){return new QW(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},QW=class extends XW{constructor(n,t,e,s,r){super(n,t,r),this.vectorBucketName=e,this.indexName=s}async putVectors(n){var t=()=>super.putVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async getVectors(n){var t=()=>super.getVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async listVectors(n={}){var t=()=>super.listVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async queryVectors(n){var t=()=>super.queryVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async deleteVectors(n){var t=()=>super.deleteVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}},tH=class extends VW{constructor(n,t={},e,s){super(n,t,e,s)}from(n){return new BW(this.url,this.headers,n,this.fetch)}get vectors(){return new ZW(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new UW(this.url+"/iceberg",this.headers,this.fetch)}};const gR="2.89.0",pc=30*1e3,Tv=3,Cx=Tv*pc,eH="http://localhost:9999",nH="supabase.auth.token",sH={"X-Client-Info":`gotrue-js/${gR}`},kv="X-Supabase-Api-Version",yR={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},rH=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,iH=600*1e3;class Oh extends Error{constructor(t,e,s){super(t),this.__isAuthError=!0,this.name="AuthError",this.status=e,this.code=s}}function Rt(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class oH extends Oh{constructor(t,e,s){super(t,e,s),this.name="AuthApiError",this.status=e,this.code=s}}function aH(n){return Rt(n)&&n.name==="AuthApiError"}class Oa extends Oh{constructor(t,e){super(t),this.name="AuthUnknownError",this.originalError=e}}class Ji extends Oh{constructor(t,e,s,r){super(t,s,r),this.name=e,this.status=s}}class Ys extends Ji{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function lH(n){return Rt(n)&&n.name==="AuthSessionMissingError"}class ic extends Ji{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class Gp extends Ji{constructor(t){super(t,"AuthInvalidCredentialsError",400,void 0)}}class Wp extends Ji{constructor(t,e=null){super(t,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function cH(n){return Rt(n)&&n.name==="AuthImplicitGrantRedirectError"}class xI extends Ji{constructor(t,e=null){super(t,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class uH extends Ji{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class $v extends Ji{constructor(t,e){super(t,"AuthRetryableFetchError",e,void 0)}}function Tx(n){return Rt(n)&&n.name==="AuthRetryableFetchError"}class vI extends Ji{constructor(t,e,s){super(t,"AuthWeakPasswordError",e,"weak_password"),this.reasons=s}}class Ev extends Ji{constructor(t){super(t,"AuthInvalidJwtError",400,"invalid_jwt")}}const Tm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),wI=` 	
\r=`.split(""),hH=(()=>{const n=new Array(128);for(let t=0;t<n.length;t+=1)n[t]=-1;for(let t=0;t<wI.length;t+=1)n[wI[t].charCodeAt(0)]=-2;for(let t=0;t<Tm.length;t+=1)n[Tm[t].charCodeAt(0)]=t;return n})();function SI(n,t,e){if(n!==null)for(t.queue=t.queue<<8|n,t.queuedBits+=8;t.queuedBits>=6;){const s=t.queue>>t.queuedBits-6&63;e(Tm[s]),t.queuedBits-=6}else if(t.queuedBits>0)for(t.queue=t.queue<<6-t.queuedBits,t.queuedBits=6;t.queuedBits>=6;){const s=t.queue>>t.queuedBits-6&63;e(Tm[s]),t.queuedBits-=6}}function bR(n,t,e){const s=hH[n];if(s>-1)for(t.queue=t.queue<<6|s,t.queuedBits+=6;t.queuedBits>=8;)e(t.queue>>t.queuedBits-8&255),t.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function CI(n){const t=[],e=o=>{t.push(String.fromCodePoint(o))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},i=o=>{pH(o,s,e)};for(let o=0;o<n.length;o+=1)bR(n.charCodeAt(o),r,i);return t.join("")}function dH(n,t){if(n<=127){t(n);return}else if(n<=2047){t(192|n>>6),t(128|n&63);return}else if(n<=65535){t(224|n>>12),t(128|n>>6&63),t(128|n&63);return}else if(n<=1114111){t(240|n>>18),t(128|n>>12&63),t(128|n>>6&63),t(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function fH(n,t){for(let e=0;e<n.length;e+=1){let s=n.charCodeAt(e);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(e+1)-56320&65535|r)+65536,e+=1}dH(s,t)}}function pH(n,t,e){if(t.utf8seq===0){if(n<=127){e(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){t.utf8seq=s;break}if(t.utf8seq===2)t.codepoint=n&31;else if(t.utf8seq===3)t.codepoint=n&15;else if(t.utf8seq===4)t.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");t.utf8seq-=1}else if(t.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");t.codepoint=t.codepoint<<6|n&63,t.utf8seq-=1,t.utf8seq===0&&e(t.codepoint)}}function $c(n){const t=[],e={queue:0,queuedBits:0},s=r=>{t.push(r)};for(let r=0;r<n.length;r+=1)bR(n.charCodeAt(r),e,s);return new Uint8Array(t)}function mH(n){const t=[];return fH(n,e=>t.push(e)),new Uint8Array(t)}function Ba(n){const t=[],e={queue:0,queuedBits:0},s=r=>{t.push(r)};return n.forEach(r=>SI(r,e,s)),SI(null,e,s),t.join("")}function gH(n){return Math.round(Date.now()/1e3)+n}function yH(){return Symbol("auth-callback")}const Kn=()=>typeof window<"u"&&typeof document<"u",ka={tested:!1,writable:!1},xR=()=>{if(!Kn())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(ka.tested)return ka.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),ka.tested=!0,ka.writable=!0}catch{ka.tested=!0,ka.writable=!1}return ka.writable};function bH(n){const t={},e=new URL(n);if(e.hash&&e.hash[0]==="#")try{new URLSearchParams(e.hash.substring(1)).forEach((r,i)=>{t[i]=r})}catch{}return e.searchParams.forEach((s,r)=>{t[r]=s}),t}const vR=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),xH=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",mc=async(n,t,e)=>{await n.setItem(t,JSON.stringify(e))},$a=async(n,t)=>{const e=await n.getItem(t);if(!e)return null;try{return JSON.parse(e)}catch{return e}},qn=async(n,t)=>{await n.removeItem(t)};class ug{constructor(){this.promise=new ug.promiseConstructor((t,e)=>{this.resolve=t,this.reject=e})}}ug.promiseConstructor=Promise;function kx(n){const t=n.split(".");if(t.length!==3)throw new Ev("Invalid JWT structure");for(let s=0;s<t.length;s++)if(!rH.test(t[s]))throw new Ev("JWT not in base64url format");return{header:JSON.parse(CI(t[0])),payload:JSON.parse(CI(t[1])),signature:$c(t[2]),raw:{header:t[0],payload:t[1]}}}async function vH(n){return await new Promise(t=>{setTimeout(()=>t(null),n)})}function wH(n,t){return new Promise((s,r)=>{(async()=>{for(let i=0;i<1/0;i++)try{const o=await n(i);if(!t(i,null,o)){s(o);return}}catch(o){if(!t(i,o)){r(o);return}}})()})}function SH(n){return("0"+n.toString(16)).substr(-2)}function CH(){const t=new Uint32Array(56);if(typeof crypto>"u"){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=e.length;let r="";for(let i=0;i<56;i++)r+=e.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(t),Array.from(t,SH).join("")}async function TH(n){const e=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",e),r=new Uint8Array(s);return Array.from(r).map(i=>String.fromCharCode(i)).join("")}async function kH(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const e=await TH(n);return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function oc(n,t,e=!1){const s=CH();let r=s;e&&(r+="/PASSWORD_RECOVERY"),await mc(n,`${t}-code-verifier`,r);const i=await kH(s);return[i,s===i?"plain":"s256"]}const $H=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function EH(n){const t=n.headers.get(kv);if(!t||!t.match($H))return null;try{return new Date(`${t}T00:00:00.0Z`)}catch{return null}}function IH(n){if(!n)throw new Error("Missing exp claim");const t=Math.floor(Date.now()/1e3);if(n<=t)throw new Error("JWT has expired")}function NH(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const AH=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function ac(n){if(!AH.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function $x(){const n={};return new Proxy(n,{get:(t,e)=>{if(e==="__isUserNotAvailableProxy")return!0;if(typeof e=="symbol"){const s=e.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${e}" property of the session object is not supported. Please use getUser() instead.`)},set:(t,e)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${e}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(t,e)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${e}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function _H(n,t){return new Proxy(n,{get:(e,s,r)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const i=s.toString();if(i==="Symbol(Symbol.toPrimitive)"||i==="Symbol(Symbol.toStringTag)"||i==="Symbol(util.inspect.custom)"||i==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(e,s,r)}return!t.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),t.value=!0),Reflect.get(e,s,r)}})}function TI(n){return JSON.parse(JSON.stringify(n))}const _a=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),RH=[502,503,504];async function kI(n){var t;if(!xH(n))throw new $v(_a(n),0);if(RH.includes(n.status))throw new $v(_a(n),n.status);let e;try{e=await n.json()}catch(i){throw new Oa(_a(i),i)}let s;const r=EH(n);if(r&&r.getTime()>=yR["2024-01-01"].timestamp&&typeof e=="object"&&e&&typeof e.code=="string"?s=e.code:typeof e=="object"&&e&&typeof e.error_code=="string"&&(s=e.error_code),s){if(s==="weak_password")throw new vI(_a(e),n.status,((t=e.weak_password)===null||t===void 0?void 0:t.reasons)||[]);if(s==="session_not_found")throw new Ys}else if(typeof e=="object"&&e&&typeof e.weak_password=="object"&&e.weak_password&&Array.isArray(e.weak_password.reasons)&&e.weak_password.reasons.length&&e.weak_password.reasons.reduce((i,o)=>i&&typeof o=="string",!0))throw new vI(_a(e),n.status,e.weak_password.reasons);throw new oH(_a(e),n.status||500,s)}const DH=(n,t,e,s)=>{const r={method:n,headers:t?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},t?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),e))};async function Vt(n,t,e,s){var r;const i=Object.assign({},s?.headers);i[kv]||(i[kv]=yR["2024-01-01"].name),s?.jwt&&(i.Authorization=`Bearer ${s.jwt}`);const o=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(o.redirect_to=s.redirectTo);const l=Object.keys(o).length?"?"+new URLSearchParams(o).toString():"",c=await OH(n,t,e+l,{headers:i,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(c):{data:Object.assign({},c),error:null}}async function OH(n,t,e,s,r,i){const o=DH(t,s,r,i);let l;try{l=await n(e,Object.assign({},o))}catch(c){throw console.error(c),new $v(_a(c),0)}if(l.ok||await kI(l),s?.noResolveJson)return l;try{return await l.json()}catch(c){await kI(c)}}function Pr(n){var t;let e=null;LH(n)&&(e=Object.assign({},n),n.expires_at||(e.expires_at=gH(n.expires_in)));const s=(t=n.user)!==null&&t!==void 0?t:n;return{data:{session:e,user:s},error:null}}function $I(n){const t=Pr(n);return!t.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((e,s)=>e&&typeof s=="string",!0)&&(t.data.weak_password=n.weak_password),t}function _o(n){var t;return{data:{user:(t=n.user)!==null&&t!==void 0?t:n},error:null}}function MH(n){return{data:n,error:null}}function FH(n){const{action_link:t,email_otp:e,hashed_token:s,redirect_to:r,verification_type:i}=n,o=lg(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),l={action_link:t,email_otp:e,hashed_token:s,redirect_to:r,verification_type:i},c=Object.assign({},o);return{data:{properties:l,user:c},error:null}}function EI(n){return n}function LH(n){return n.access_token&&n.refresh_token&&n.expires_in}const Ex=["global","local","others"];class PH{constructor({url:t="",headers:e={},fetch:s}){this.url=t,this.headers=e,this.fetch=vR(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(t,e=Ex[0]){if(Ex.indexOf(e)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${Ex.join(", ")}`);try{return await Vt(this.fetch,"POST",`${this.url}/logout?scope=${e}`,{headers:this.headers,jwt:t,noResolveJson:!0}),{data:null,error:null}}catch(s){if(Rt(s))return{data:null,error:s};throw s}}async inviteUserByEmail(t,e={}){try{return await Vt(this.fetch,"POST",`${this.url}/invite`,{body:{email:t,data:e.data},headers:this.headers,redirectTo:e.redirectTo,xform:_o})}catch(s){if(Rt(s))return{data:{user:null},error:s};throw s}}async generateLink(t){try{const{options:e}=t,s=lg(t,["options"]),r=Object.assign(Object.assign({},s),e);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await Vt(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:FH,redirectTo:e?.redirectTo})}catch(e){if(Rt(e))return{data:{properties:null,user:null},error:e};throw e}}async createUser(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/users`,{body:t,headers:this.headers,xform:_o})}catch(e){if(Rt(e))return{data:{user:null},error:e};throw e}}async listUsers(t){var e,s,r,i,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Vt(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=t?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:EI});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Rt(h))return{data:{users:[]},error:h};throw h}}async getUserById(t){ac(t);try{return await Vt(this.fetch,"GET",`${this.url}/admin/users/${t}`,{headers:this.headers,xform:_o})}catch(e){if(Rt(e))return{data:{user:null},error:e};throw e}}async updateUserById(t,e){ac(t);try{return await Vt(this.fetch,"PUT",`${this.url}/admin/users/${t}`,{body:e,headers:this.headers,xform:_o})}catch(s){if(Rt(s))return{data:{user:null},error:s};throw s}}async deleteUser(t,e=!1){ac(t);try{return await Vt(this.fetch,"DELETE",`${this.url}/admin/users/${t}`,{headers:this.headers,body:{should_soft_delete:e},xform:_o})}catch(s){if(Rt(s))return{data:{user:null},error:s};throw s}}async _listFactors(t){ac(t.userId);try{const{data:e,error:s}=await Vt(this.fetch,"GET",`${this.url}/admin/users/${t.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:e,error:s}}catch(e){if(Rt(e))return{data:null,error:e};throw e}}async _deleteFactor(t){ac(t.userId),ac(t.id);try{return{data:await Vt(this.fetch,"DELETE",`${this.url}/admin/users/${t.userId}/factors/${t.id}`,{headers:this.headers}),error:null}}catch(e){if(Rt(e))return{data:null,error:e};throw e}}async _listOAuthClients(t){var e,s,r,i,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Vt(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&s!==void 0?s:"",per_page:(i=(r=t?.perPage)===null||r===void 0?void 0:r.toString())!==null&&i!==void 0?i:""},xform:EI});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Rt(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:t,headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Rt(e))return{data:null,error:e};throw e}}async _getOAuthClient(t){try{return await Vt(this.fetch,"GET",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Rt(e))return{data:null,error:e};throw e}}async _updateOAuthClient(t,e){try{return await Vt(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${t}`,{body:e,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(Rt(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(t){try{return await Vt(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(e){if(Rt(e))return{data:null,error:e};throw e}}async _regenerateOAuthClientSecret(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/oauth/clients/${t}/regenerate_secret`,{headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Rt(e))return{data:null,error:e};throw e}}}function II(n={}){return{getItem:t=>n[t]||null,setItem:(t,e)=>{n[t]=e},removeItem:t=>{delete n[t]}}}const lc={debug:!!(globalThis&&xR()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class wR extends Error{constructor(t){super(t),this.isAcquireTimeout=!0}}class zH extends wR{}async function BH(n,t,e){lc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,t);const s=new globalThis.AbortController;return t>0&&setTimeout(()=>{s.abort(),lc.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},t),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,t===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){lc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await e()}finally{lc.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(t===0)throw lc.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new zH(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(lc.debug)try{const i=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(i,null,"  "))}catch(i){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",i)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await e()}}))}function VH(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function SR(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function UH(n){return parseInt(n,16)}function jH(n){const t=new TextEncoder().encode(n);return"0x"+Array.from(t,s=>s.toString(16).padStart(2,"0")).join("")}function GH(n){var t;const{chainId:e,domain:s,expirationTime:r,issuedAt:i=new Date,nonce:o,notBefore:l,requestId:c,resources:h,scheme:d,uri:p,version:m}=n;{if(!Number.isInteger(e))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${e}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(o&&o.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((t=n.statement)===null||t===void 0)&&t.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=SR(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let S=`URI: ${p}
Version: ${m}
Chain ID: ${e}${o?`
Nonce: ${o}`:""}
Issued At: ${i.toISOString()}`;if(r&&(S+=`
Expiration Time: ${r.toISOString()}`),l&&(S+=`
Not Before: ${l.toISOString()}`),c&&(S+=`
Request ID: ${c}`),h){let T=`
Resources:`;for(const k of h){if(!k||typeof k!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${k}`);T+=`
- ${k}`}S+=T}return`${w}
${S}`}class yn extends Error{constructor({message:t,code:e,cause:s,name:r}){var i;super(t,{cause:s}),this.__isWebAuthnError=!0,this.name=(i=r??(s instanceof Error?s.name:void 0))!==null&&i!==void 0?i:"Unknown Error",this.code=e}}class km extends yn{constructor(t,e){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e,message:t}),this.name="WebAuthnUnknownError",this.originalError=e}}function WH({error:n,options:t}){var e,s,r;const{publicKey:i}=t;if(!i)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(t.signal instanceof AbortSignal)return new yn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((e=i.authenticatorSelection)===null||e===void 0?void 0:e.requireResidentKey)===!0)return new yn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(t.mediation==="conditional"&&((s=i.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new yn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((r=i.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new yn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new yn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new yn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return i.pubKeyCredParams.filter(l=>l.type==="public-key").length===0?new yn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new yn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const o=window.location.hostname;if(CR(o)){if(i.rp.id!==o)return new yn({message:`The RP ID "${i.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new yn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(i.user.id.byteLength<1||i.user.id.byteLength>64)return new yn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new yn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new yn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function HH({error:n,options:t}){const{publicKey:e}=t;if(!e)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(t.signal instanceof AbortSignal)return new yn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new yn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(CR(s)){if(e.rpId!==s)return new yn({message:`The RP ID "${e.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new yn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new yn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new yn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class qH{createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const KH=new qH;function XH(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:t,user:e,excludeCredentials:s}=n,r=lg(n,["challenge","user","excludeCredentials"]),i=$c(t).buffer,o=Object.assign(Object.assign({},e),{id:$c(e.id).buffer}),l=Object.assign(Object.assign({},r),{challenge:i,user:o});if(s&&s.length>0){l.excludeCredentials=new Array(s.length);for(let c=0;c<s.length;c++){const h=s[c];l.excludeCredentials[c]=Object.assign(Object.assign({},h),{id:$c(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return l}function YH(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:t,allowCredentials:e}=n,s=lg(n,["challenge","allowCredentials"]),r=$c(t).buffer,i=Object.assign(Object.assign({},s),{challenge:r});if(e&&e.length>0){i.allowCredentials=new Array(e.length);for(let o=0;o<e.length;o++){const l=e[o];i.allowCredentials[o]=Object.assign(Object.assign({},l),{id:$c(l.id).buffer,type:l.type||"public-key",transports:l.transports})}}return i}function ZH(n){var t;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const e=n;return{id:n.id,rawId:n.id,response:{attestationObject:Ba(new Uint8Array(n.response.attestationObject)),clientDataJSON:Ba(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(t=e.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function JH(n){var t;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const e=n,s=n.getClientExtensionResults(),r=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:Ba(new Uint8Array(r.authenticatorData)),clientDataJSON:Ba(new Uint8Array(r.clientDataJSON)),signature:Ba(new Uint8Array(r.signature)),userHandle:r.userHandle?Ba(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(t=e.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function CR(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function NI(){var n,t;return!!(Kn()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((t=navigator?.credentials)===null||t===void 0?void 0:t.get)=="function")}async function QH(n){try{const t=await navigator.credentials.create(n);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new km("Browser returned unexpected credential type",t)}:{data:null,error:new km("Empty credential response",t)}}catch(t){return{data:null,error:WH({error:t,options:n})}}}async function t5(n){try{const t=await navigator.credentials.get(n);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new km("Browser returned unexpected credential type",t)}:{data:null,error:new km("Empty credential response",t)}}catch(t){return{data:null,error:HH({error:t,options:n})}}}const e5={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},n5={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function $m(...n){const t=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),e=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),s={};for(const r of n)if(r)for(const i in r){const o=r[i];if(o!==void 0)if(Array.isArray(o))s[i]=o;else if(e(o))s[i]=o;else if(t(o)){const l=s[i];t(l)?s[i]=$m(l,o):s[i]=$m(o)}else s[i]=o}return s}function s5(n,t){return $m(e5,n,t||{})}function r5(n,t){return $m(n5,n,t||{})}class i5{constructor(t){this.client=t,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(t){return this.client.mfa.enroll(Object.assign(Object.assign({},t),{factorType:"webauthn"}))}async _challenge({factorId:t,webauthn:e,friendlyName:s,signal:r},i){try{const{data:o,error:l}=await this.client.mfa.challenge({factorId:t,webauthn:e});if(!o)return{data:null,error:l};const c=r??KH.createNewAbortSignal();if(o.webauthn.type==="create"){const{user:h}=o.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(o.webauthn.type){case"create":{const h=s5(o.webauthn.credential_options.publicKey,i?.create),{data:d,error:p}=await QH({publicKey:h,signal:c});return d?{data:{factorId:t,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}case"request":{const h=r5(o.webauthn.credential_options.publicKey,i?.request),{data:d,error:p}=await t5(Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:h,signal:c}));return d?{data:{factorId:t,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}}}catch(o){return Rt(o)?{data:null,error:o}:{data:null,error:new Oa("Unexpected error in challenge",o)}}}async _verify({challengeId:t,factorId:e,webauthn:s}){return this.client.mfa.verify({factorId:e,challengeId:t,webauthn:s})}async _authenticate({factorId:t,webauthn:{rpId:e=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!e)return{data:null,error:new Oh("rpId is required for WebAuthn authentication")};try{if(!NI())return{data:null,error:new Oa("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this.challenge({factorId:t,webauthn:{rpId:e,rpOrigins:s},signal:r},{request:i});if(!o)return{data:null,error:l};const{webauthn:c}=o;return this._verify({factorId:t,challengeId:o.challengeId,webauthn:{type:c.type,rpId:e,rpOrigins:s,credential_response:c.credential_response}})}catch(o){return Rt(o)?{data:null,error:o}:{data:null,error:new Oa("Unexpected error in authenticate",o)}}}async _register({friendlyName:t,webauthn:{rpId:e=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},i){if(!e)return{data:null,error:new Oh("rpId is required for WebAuthn registration")};try{if(!NI())return{data:null,error:new Oa("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this._enroll({friendlyName:t});if(!o)return await this.client.mfa.listFactors().then(d=>{var p;return(p=d.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===t&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:l};const{data:c,error:h}=await this._challenge({factorId:o.id,friendlyName:o.friendly_name,webauthn:{rpId:e,rpOrigins:s},signal:r},{create:i});return c?this._verify({factorId:o.id,challengeId:c.challengeId,webauthn:{rpId:e,rpOrigins:s,type:c.webauthn.type,credential_response:c.webauthn.credential_response}}):{data:null,error:h}}catch(o){return Rt(o)?{data:null,error:o}:{data:null,error:new Oa("Unexpected error in register",o)}}}}VH();const o5={url:eH,storageKey:nH,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:sH,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function AI(n,t,e){return await e()}const cc={};class Mh{get jwks(){var t,e;return(e=(t=cc[this.storageKey])===null||t===void 0?void 0:t.jwks)!==null&&e!==void 0?e:{keys:[]}}set jwks(t){cc[this.storageKey]=Object.assign(Object.assign({},cc[this.storageKey]),{jwks:t})}get jwks_cached_at(){var t,e;return(e=(t=cc[this.storageKey])===null||t===void 0?void 0:t.cachedAt)!==null&&e!==void 0?e:Number.MIN_SAFE_INTEGER}set jwks_cached_at(t){cc[this.storageKey]=Object.assign(Object.assign({},cc[this.storageKey]),{cachedAt:t})}constructor(t){var e,s,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const i=Object.assign(Object.assign({},o5),t);if(this.storageKey=i.storageKey,this.instanceID=(e=Mh.nextInstanceID[this.storageKey])!==null&&e!==void 0?e:0,Mh.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!i.debug,typeof i.debug=="function"&&(this.logger=i.debug),this.instanceID>0&&Kn()){const o=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(o),this.logDebugMessages&&console.trace(o)}if(this.persistSession=i.persistSession,this.autoRefreshToken=i.autoRefreshToken,this.admin=new PH({url:i.url,headers:i.headers,fetch:i.fetch}),this.url=i.url,this.headers=i.headers,this.fetch=vR(i.fetch),this.lock=i.lock||AI,this.detectSessionInUrl=i.detectSessionInUrl,this.flowType=i.flowType,this.hasCustomAuthorizationHeader=i.hasCustomAuthorizationHeader,this.throwOnError=i.throwOnError,i.lock?this.lock=i.lock:this.persistSession&&Kn()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=BH:this.lock=AI,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new i5(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(i.storage?this.storage=i.storage:xR()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=II(this.memoryStorage)),i.userStorage&&(this.userStorage=i.userStorage)):(this.memoryStorage={},this.storage=II(this.memoryStorage)),Kn()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(o){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",o)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async o=>{this._debug("received broadcast notification from other tab or client",o),await this._notifyAllSubscribers(o.data.event,o.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(t){if(this.throwOnError&&t&&t.error)throw t.error;return t}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${gR}) ${new Date().toISOString()}`}_debug(...t){return this.logDebugMessages&&this.logger(this._logPrefix(),...t),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var t;try{let e={},s="none";if(Kn()&&(e=bH(window.location.href),this._isImplicitGrantCallback(e)?s="implicit":await this._isPKCECallback(e)&&(s="pkce")),Kn()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:i}=await this._getSessionFromURL(e,s);if(i){if(this._debug("#_initialize()","error detecting session from URL",i),cH(i)){const c=(t=i.details)===null||t===void 0?void 0:t.code;if(c==="identity_already_exists"||c==="identity_not_found"||c==="single_identity_not_deletable")return{error:i}}return await this._removeSession(),{error:i}}const{session:o,redirectType:l}=r;return this._debug("#_initialize()","detected session in URL",o,"redirect type",l),await this._saveSession(o),setTimeout(async()=>{l==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",o):await this._notifyAllSubscribers("SIGNED_IN",o)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(e){return Rt(e)?this._returnResult({error:e}):this._returnResult({error:new Oa("Unexpected error during initialization",e)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(t){var e,s,r;try{const i=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(e=t?.options)===null||e===void 0?void 0:e.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=t?.options)===null||r===void 0?void 0:r.captchaToken}},xform:Pr}),{data:o,error:l}=i;if(l||!o)return this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(Rt(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signUp(t){var e,s,r;try{let i;if("email"in t){const{email:d,password:p,options:m}=t;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await oc(this.storage,this.storageKey)),i=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:p,data:(e=m?.data)!==null&&e!==void 0?e:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:Pr})}else if("phone"in t){const{phone:d,password:p,options:m}=t;i=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:p,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:Pr})}else throw new Gp("You must provide either an email or phone number and a password");const{data:o,error:l}=i;if(l||!o)return await qn(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signInWithPassword(t){try{let e;if("email"in t){const{email:i,password:o,options:l}=t;e=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:i,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:$I})}else if("phone"in t){const{phone:i,password:o,options:l}=t;e=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:i,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:$I})}else throw new Gp("You must provide either an email or phone number and a password");const{data:s,error:r}=e;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!s||!s.session||!s.user){const i=new ic;return this._returnResult({data:{user:null,session:null},error:i})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(e){if(Rt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async signInWithOAuth(t){var e,s,r,i;return await this._handleProviderSignIn(t.provider,{redirectTo:(e=t.options)===null||e===void 0?void 0:e.redirectTo,scopes:(s=t.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=t.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(i=t.options)===null||i===void 0?void 0:i.skipBrowserRedirect})}async exchangeCodeForSession(t){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(t))}async signInWithWeb3(t){const{chain:e}=t;switch(e){case"ethereum":return await this.signInWithEthereum(t);case"solana":return await this.signInWithSolana(t);default:throw new Error(`@supabase/auth-js: Unsupported chain "${e}"`)}}async signInWithEthereum(t){var e,s,r,i,o,l,c,h,d,p,m;let y,b;if("message"in t)y=t.message,b=t.signature;else{const{chain:x,wallet:w,statement:S,options:T}=t;let k;if(Kn())if(typeof w=="object")k=w;else{const D=window;if("ethereum"in D&&typeof D.ethereum=="object"&&"request"in D.ethereum&&typeof D.ethereum.request=="function")k=D.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!T?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=w}const $=new URL((e=T?.url)!==null&&e!==void 0?e:window.location.href),E=await k.request({method:"eth_requestAccounts"}).then(D=>D).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const N=SR(E[0]);let _=(s=T?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!_){const D=await k.request({method:"eth_chainId"});_=UH(D)}const R={domain:$.host,address:N,statement:S,uri:$.href,version:"1",chainId:_,nonce:(r=T?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(o=(i=T?.signInWithEthereum)===null||i===void 0?void 0:i.issuedAt)!==null&&o!==void 0?o:new Date,expirationTime:(l=T?.signInWithEthereum)===null||l===void 0?void 0:l.expirationTime,notBefore:(c=T?.signInWithEthereum)===null||c===void 0?void 0:c.notBefore,requestId:(h=T?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=T?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=GH(R),b=await k.request({method:"personal_sign",params:[jH(y),N]})}try{const{data:x,error:w}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((p=t.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=t.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:Pr});if(w)throw w;if(!x||!x.session||!x.user){const S=new ic;return this._returnResult({data:{user:null,session:null},error:S})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(Rt(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(t){var e,s,r,i,o,l,c,h,d,p,m,y;let b,x;if("message"in t)b=t.message,x=t.signature;else{const{chain:w,wallet:S,statement:T,options:k}=t;let $;if(Kn())if(typeof S=="object")$=S;else{const N=window;if("solana"in N&&typeof N.solana=="object"&&("signIn"in N.solana&&typeof N.solana.signIn=="function"||"signMessage"in N.solana&&typeof N.solana.signMessage=="function"))$=N.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof S!="object"||!k?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");$=S}const E=new URL((e=k?.url)!==null&&e!==void 0?e:window.location.href);if("signIn"in $&&$.signIn){const N=await $.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},k?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),T?{statement:T}:null));let _;if(Array.isArray(N)&&N[0]&&typeof N[0]=="object")_=N[0];else if(N&&typeof N=="object"&&"signedMessage"in N&&"signature"in N)_=N;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in _&&"signature"in _&&(typeof _.signedMessage=="string"||_.signedMessage instanceof Uint8Array)&&_.signature instanceof Uint8Array)b=typeof _.signedMessage=="string"?_.signedMessage:new TextDecoder().decode(_.signedMessage),x=_.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in $)||typeof $.signMessage!="function"||!("publicKey"in $)||typeof $!="object"||!$.publicKey||!("toBase58"in $.publicKey)||typeof $.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,$.publicKey.toBase58(),...T?["",T,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(r=(s=k?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((i=k?.signInWithSolana)===null||i===void 0)&&i.notBefore?[`Not Before: ${k.signInWithSolana.notBefore}`]:[],...!((o=k?.signInWithSolana)===null||o===void 0)&&o.expirationTime?[`Expiration Time: ${k.signInWithSolana.expirationTime}`]:[],...!((l=k?.signInWithSolana)===null||l===void 0)&&l.chainId?[`Chain ID: ${k.signInWithSolana.chainId}`]:[],...!((c=k?.signInWithSolana)===null||c===void 0)&&c.nonce?[`Nonce: ${k.signInWithSolana.nonce}`]:[],...!((h=k?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${k.signInWithSolana.requestId}`]:[],...!((p=(d=k?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||p===void 0)&&p.length?["Resources",...k.signInWithSolana.resources.map(_=>`- ${_}`)]:[]].join(`
`);const N=await $.signMessage(new TextEncoder().encode(b),"utf8");if(!N||!(N instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=N}}try{const{data:w,error:S}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:Ba(x)},!((m=t.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=t.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:Pr});if(S)throw S;if(!w||!w.session||!w.user){const T=new ic;return this._returnResult({data:{user:null,session:null},error:T})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:S})}catch(w){if(Rt(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(t){const e=await $a(this.storage,`${this.storageKey}-code-verifier`),[s,r]=(e??"").split("/");try{if(!s&&this.flowType==="pkce")throw new uH;const{data:i,error:o}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:t,code_verifier:s},xform:Pr});if(await qn(this.storage,`${this.storageKey}-code-verifier`),o)throw o;if(!i||!i.session||!i.user){const l=new ic;return this._returnResult({data:{user:null,session:null,redirectType:null},error:l})}return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",i.session)),this._returnResult({data:Object.assign(Object.assign({},i),{redirectType:r??null}),error:o})}catch(i){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(i))return this._returnResult({data:{user:null,session:null,redirectType:null},error:i});throw i}}async signInWithIdToken(t){try{const{options:e,provider:s,token:r,access_token:i,nonce:o}=t,l=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:r,access_token:i,nonce:o,gotrue_meta_security:{captcha_token:e?.captchaToken}},xform:Pr}),{data:c,error:h}=l;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!c||!c.session||!c.user){const d=new ic;return this._returnResult({data:{user:null,session:null},error:d})}return c.session&&(await this._saveSession(c.session),await this._notifyAllSubscribers("SIGNED_IN",c.session)),this._returnResult({data:c,error:h})}catch(e){if(Rt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async signInWithOtp(t){var e,s,r,i,o;try{if("email"in t){const{email:l,options:c}=t;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await oc(this.storage,this.storageKey));const{error:p}=await Vt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:l,data:(e=c?.data)!==null&&e!==void 0?e:{},create_user:(s=c?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:c?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in t){const{phone:l,options:c}=t,{data:h,error:d}=await Vt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:l,data:(r=c?.data)!==null&&r!==void 0?r:{},create_user:(i=c?.shouldCreateUser)!==null&&i!==void 0?i:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},channel:(o=c?.channel)!==null&&o!==void 0?o:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new Gp("You must provide either an email or phone number.")}catch(l){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(l))return this._returnResult({data:{user:null,session:null},error:l});throw l}}async verifyOtp(t){var e,s;try{let r,i;"options"in t&&(r=(e=t.options)===null||e===void 0?void 0:e.redirectTo,i=(s=t.options)===null||s===void 0?void 0:s.captchaToken);const{data:o,error:l}=await Vt(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},t),{gotrue_meta_security:{captcha_token:i}}),redirectTo:r,xform:Pr});if(l)throw l;if(!o)throw new Error("An error occurred on token verification.");const c=o.session,h=o.user;return c?.access_token&&(await this._saveSession(c),await this._notifyAllSubscribers(t.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(r){if(Rt(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(t){var e,s,r,i,o;try{let l=null,c=null;this.flowType==="pkce"&&([l,c]=await oc(this.storage,this.storageKey));const h=await Vt(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in t?{provider_id:t.providerId}:null),"domain"in t?{domain:t.domain}:null),{redirect_to:(s=(e=t.options)===null||e===void 0?void 0:e.redirectTo)!==null&&s!==void 0?s:void 0}),!((r=t?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:t.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:l,code_challenge_method:c}),headers:this.headers,xform:MH});return!((i=h.data)===null||i===void 0)&&i.url&&Kn()&&!(!((o=t.options)===null||o===void 0)&&o.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(l){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(l))return this._returnResult({data:null,error:l});throw l}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async t=>{const{data:{session:e},error:s}=t;if(s)throw s;if(!e)throw new Ys;const{error:r}=await Vt(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:e.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(t){if(Rt(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async resend(t){try{const e=`${this.url}/resend`;if("email"in t){const{email:s,type:r,options:i}=t,{error:o}=await Vt(this.fetch,"POST",e,{headers:this.headers,body:{email:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}},redirectTo:i?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:o})}else if("phone"in t){const{phone:s,type:r,options:i}=t,{data:o,error:l}=await Vt(this.fetch,"POST",e,{headers:this.headers,body:{phone:s,type:r,gotrue_meta_security:{captcha_token:i?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:o?.message_id},error:l})}throw new Gp("You must provide either an email or phone number and a type")}catch(e){if(Rt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async e=>e))}async _acquireLock(t,e){this._debug("#_acquireLock","begin",t);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await s,await e()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,t,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=e();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(t){this._debug("#_useSession","begin");try{const e=await this.__loadSession();return await t(e)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let t=null;const e=await $a(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",e),e!==null&&(this._isValidSession(e)?t=e:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!t)return{data:{session:null},error:null};const s=t.expires_at?t.expires_at*1e3-Date.now()<Cx:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",t.expires_at),!s){if(this.userStorage){const o=await $a(this.userStorage,this.storageKey+"-user");o?.user?t.user=o.user:t.user=$x()}if(this.storage.isServer&&t.user&&!t.user.__isUserNotAvailableProxy){const o={value:this.suppressGetSessionWarning};t.user=_H(t.user,o),o.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:t},error:null}}const{data:r,error:i}=await this._callRefreshToken(t.refresh_token);return i?this._returnResult({data:{session:null},error:i}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(t){if(t)return await this._getUser(t);await this.initializePromise;const e=await this._acquireLock(-1,async()=>await this._getUser());return e.data.user&&(this.suppressGetSessionWarning=!0),e}async _getUser(t){try{return t?await Vt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:t,xform:_o}):await this._useSession(async e=>{var s,r,i;const{data:o,error:l}=e;if(l)throw l;return!(!((s=o.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new Ys}:await Vt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(i=(r=o.session)===null||r===void 0?void 0:r.access_token)!==null&&i!==void 0?i:void 0,xform:_o})})}catch(e){if(Rt(e))return lH(e)&&(await this._removeSession(),await qn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:e});throw e}}async updateUser(t,e={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(t,e))}async _updateUser(t,e={}){try{return await this._useSession(async s=>{const{data:r,error:i}=s;if(i)throw i;if(!r.session)throw new Ys;const o=r.session;let l=null,c=null;this.flowType==="pkce"&&t.email!=null&&([l,c]=await oc(this.storage,this.storageKey));const{data:h,error:d}=await Vt(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:e?.emailRedirectTo,body:Object.assign(Object.assign({},t),{code_challenge:l,code_challenge_method:c}),jwt:o.access_token,xform:_o});if(d)throw d;return o.user=h.user,await this._saveSession(o),await this._notifyAllSubscribers("USER_UPDATED",o),this._returnResult({data:{user:o.user},error:null})})}catch(s){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(t))}async _setSession(t){try{if(!t.access_token||!t.refresh_token)throw new Ys;const e=Date.now()/1e3;let s=e,r=!0,i=null;const{payload:o}=kx(t.access_token);if(o.exp&&(s=o.exp,r=s<=e),r){const{data:l,error:c}=await this._callRefreshToken(t.refresh_token);if(c)return this._returnResult({data:{user:null,session:null},error:c});if(!l)return{data:{user:null,session:null},error:null};i=l}else{const{data:l,error:c}=await this._getUser(t.access_token);if(c)throw c;i={access_token:t.access_token,refresh_token:t.refresh_token,user:l.user,token_type:"bearer",expires_in:s-e,expires_at:s},await this._saveSession(i),await this._notifyAllSubscribers("SIGNED_IN",i)}return this._returnResult({data:{user:i.user,session:i},error:null})}catch(e){if(Rt(e))return this._returnResult({data:{session:null,user:null},error:e});throw e}}async refreshSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(t))}async _refreshSession(t){try{return await this._useSession(async e=>{var s;if(!t){const{data:o,error:l}=e;if(l)throw l;t=(s=o.session)!==null&&s!==void 0?s:void 0}if(!t?.refresh_token)throw new Ys;const{data:r,error:i}=await this._callRefreshToken(t.refresh_token);return i?this._returnResult({data:{user:null,session:null},error:i}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(e){if(Rt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async _getSessionFromURL(t,e){try{if(!Kn())throw new Wp("No browser detected.");if(t.error||t.error_description||t.error_code)throw new Wp(t.error_description||"Error in URL with unspecified error_description",{error:t.error||"unspecified_error",code:t.error_code||"unspecified_code"});switch(e){case"implicit":if(this.flowType==="pkce")throw new xI("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Wp("Not a valid implicit grant flow url.");break;default:}if(e==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!t.code)throw new xI("No code detected.");const{data:T,error:k}=await this._exchangeCodeForSession(t.code);if(k)throw k;const $=new URL(window.location.href);return $.searchParams.delete("code"),window.history.replaceState(window.history.state,"",$.toString()),{data:{session:T.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:r,access_token:i,refresh_token:o,expires_in:l,expires_at:c,token_type:h}=t;if(!i||!l||!o||!h)throw new Wp("No session defined in URL");const d=Math.round(Date.now()/1e3),p=parseInt(l);let m=d+p;c&&(m=parseInt(c));const y=m-d;y*1e3<=pc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${p}s`);const b=m-p;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(i);if(w)throw w;const S={provider_token:s,provider_refresh_token:r,access_token:i,expires_in:p,expires_at:m,refresh_token:o,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:S,redirectType:t.type},error:null})}catch(s){if(Rt(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(t){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),t):!!(t.access_token||t.error_description)}async _isPKCECallback(t){const e=await $a(this.storage,`${this.storageKey}-code-verifier`);return!!(t.code&&e)}async signOut(t={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(t))}async _signOut({scope:t}={scope:"global"}){return await this._useSession(async e=>{var s;const{data:r,error:i}=e;if(i)return this._returnResult({error:i});const o=(s=r.session)===null||s===void 0?void 0:s.access_token;if(o){const{error:l}=await this.admin.signOut(o,t);if(l&&!(aH(l)&&(l.status===404||l.status===401||l.status===403)))return this._returnResult({error:l})}return t!=="others"&&(await this._removeSession(),await qn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(t){const e=yH(),s={id:e,callback:t,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",e),this.stateChangeEmitters.delete(e)}};return this._debug("#onAuthStateChange()","registered callback with id",e),this.stateChangeEmitters.set(e,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(e)})))(),{data:{subscription:s}}}async _emitInitialSession(t){return await this._useSession(async e=>{var s,r;try{const{data:{session:i},error:o}=e;if(o)throw o;await((s=this.stateChangeEmitters.get(t))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",i)),this._debug("INITIAL_SESSION","callback id",t,"session",i)}catch(i){await((r=this.stateChangeEmitters.get(t))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",t,"error",i),console.error(i)}})}async resetPasswordForEmail(t,e={}){let s=null,r=null;this.flowType==="pkce"&&([s,r]=await oc(this.storage,this.storageKey,!0));try{return await Vt(this.fetch,"POST",`${this.url}/recover`,{body:{email:t,code_challenge:s,code_challenge_method:r,gotrue_meta_security:{captcha_token:e.captchaToken}},headers:this.headers,redirectTo:e.redirectTo})}catch(i){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(i))return this._returnResult({data:null,error:i});throw i}}async getUserIdentities(){var t;try{const{data:e,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(t=e.user.identities)!==null&&t!==void 0?t:[]},error:null})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}}async linkIdentity(t){return"token"in t?this.linkIdentityIdToken(t):this.linkIdentityOAuth(t)}async linkIdentityOAuth(t){var e;try{const{data:s,error:r}=await this._useSession(async i=>{var o,l,c,h,d;const{data:p,error:m}=i;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,t.provider,{redirectTo:(o=t.options)===null||o===void 0?void 0:o.redirectTo,scopes:(l=t.options)===null||l===void 0?void 0:l.scopes,queryParams:(c=t.options)===null||c===void 0?void 0:c.queryParams,skipBrowserRedirect:!0});return await Vt(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=p.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(r)throw r;return Kn()&&!(!((e=t.options)===null||e===void 0)&&e.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:t.provider,url:s?.url},error:null})}catch(s){if(Rt(s))return this._returnResult({data:{provider:t.provider,url:null},error:s});throw s}}async linkIdentityIdToken(t){return await this._useSession(async e=>{var s;try{const{error:r,data:{session:i}}=e;if(r)throw r;const{options:o,provider:l,token:c,access_token:h,nonce:d}=t,p=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=i?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:l,id_token:c,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:Pr}),{data:m,error:y}=p;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new ic}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(r){if(await qn(this.storage,`${this.storageKey}-code-verifier`),Rt(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(t){try{return await this._useSession(async e=>{var s,r;const{data:i,error:o}=e;if(o)throw o;return await Vt(this.fetch,"DELETE",`${this.url}/user/identities/${t.identity_id}`,{headers:this.headers,jwt:(r=(s=i.session)===null||s===void 0?void 0:s.access_token)!==null&&r!==void 0?r:void 0})})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}}async _refreshAccessToken(t){const e=`#_refreshAccessToken(${t.substring(0,5)}...)`;this._debug(e,"begin");try{const s=Date.now();return await wH(async r=>(r>0&&await vH(200*Math.pow(2,r-1)),this._debug(e,"refreshing attempt",r),await Vt(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:t},headers:this.headers,xform:Pr})),(r,i)=>{const o=200*Math.pow(2,r);return i&&Tx(i)&&Date.now()+o-s<pc})}catch(s){if(this._debug(e,"error",s),Rt(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(e,"end")}}_isValidSession(t){return typeof t=="object"&&t!==null&&"access_token"in t&&"refresh_token"in t&&"expires_at"in t}async _handleProviderSignIn(t,e){const s=await this._getUrlForProvider(`${this.url}/authorize`,t,{redirectTo:e.redirectTo,scopes:e.scopes,queryParams:e.queryParams});return this._debug("#_handleProviderSignIn()","provider",t,"options",e,"url",s),Kn()&&!e.skipBrowserRedirect&&window.location.assign(s),{data:{provider:t,url:s},error:null}}async _recoverAndRefresh(){var t,e;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const r=await $a(this.storage,this.storageKey);if(r&&this.userStorage){let o=await $a(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!o&&(o={user:r.user},await mc(this.userStorage,this.storageKey+"-user",o)),r.user=(t=o?.user)!==null&&t!==void 0?t:$x()}else if(r&&!r.user&&!r.user){const o=await $a(this.storage,this.storageKey+"-user");o&&o?.user?(r.user=o.user,await qn(this.storage,this.storageKey+"-user"),await mc(this.storage,this.storageKey,r)):r.user=$x()}if(this._debug(s,"session from storage",r),!this._isValidSession(r)){this._debug(s,"session is not valid"),r!==null&&await this._removeSession();return}const i=((e=r.expires_at)!==null&&e!==void 0?e:1/0)*1e3-Date.now()<Cx;if(this._debug(s,`session has${i?"":" not"} expired with margin of ${Cx}s`),i){if(this.autoRefreshToken&&r.refresh_token){const{error:o}=await this._callRefreshToken(r.refresh_token);o&&(console.error(o),Tx(o)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",o),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:o,error:l}=await this._getUser(r.access_token);!l&&o?.user?(r.user=o.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(o){console.error("Error getting user data:",o),this._debug(s,"error getting user data, skipping SIGNED_IN notification",o)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(s,"error",r),console.error(r);return}finally{this._debug(s,"end")}}async _callRefreshToken(t){var e,s;if(!t)throw new Ys;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${t.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new ug;const{data:i,error:o}=await this._refreshAccessToken(t);if(o)throw o;if(!i.session)throw new Ys;await this._saveSession(i.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",i.session);const l={data:i.session,error:null};return this.refreshingDeferred.resolve(l),l}catch(i){if(this._debug(r,"error",i),Rt(i)){const o={data:null,error:i};return Tx(i)||await this._removeSession(),(e=this.refreshingDeferred)===null||e===void 0||e.resolve(o),o}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(i),i}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(t,e,s=!0){const r=`#_notifyAllSubscribers(${t})`;this._debug(r,"begin",e,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:t,session:e});const i=[],o=Array.from(this.stateChangeEmitters.values()).map(async l=>{try{await l.callback(t,e)}catch(c){i.push(c)}});if(await Promise.all(o),i.length>0){for(let l=0;l<i.length;l+=1)console.error(i[l]);throw i[0]}}finally{this._debug(r,"end")}}async _saveSession(t){this._debug("#_saveSession()",t),this.suppressGetSessionWarning=!0,await qn(this.storage,`${this.storageKey}-code-verifier`);const e=Object.assign({},t),s=e.user&&e.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&e.user&&await mc(this.userStorage,this.storageKey+"-user",{user:e.user});const r=Object.assign({},e);delete r.user;const i=TI(r);await mc(this.storage,this.storageKey,i)}else{const r=TI(e);await mc(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await qn(this.storage,this.storageKey),await qn(this.storage,this.storageKey+"-code-verifier"),await qn(this.storage,this.storageKey+"-user"),this.userStorage&&await qn(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const t=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{t&&Kn()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",t)}catch(e){console.error("removing visibilitychange callback failed",e)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const t=setInterval(()=>this._autoRefreshTokenTick(),pc);this.autoRefreshTicker=t,t&&typeof t=="object"&&typeof t.unref=="function"?t.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(t),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const t=this.autoRefreshTicker;this.autoRefreshTicker=null,t&&clearInterval(t)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const t=Date.now();try{return await this._useSession(async e=>{const{data:{session:s}}=e;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((s.expires_at*1e3-t)/pc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${pc}ms, refresh threshold is ${Tv} ticks`),r<=Tv&&await this._callRefreshToken(s.refresh_token)})}catch(e){console.error("Auto refresh tick failed with error. This is likely a transient error.",e)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(t){if(t.isAcquireTimeout||t instanceof wR)this._debug("auto refresh token tick lock not available");else throw t}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!Kn()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(t){console.error("_handleVisibilityChange",t)}}async _onVisibilityChanged(t){const e=`#_onVisibilityChanged(${t})`;this._debug(e,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),t||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(e,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(t,e,s){const r=[`provider=${encodeURIComponent(e)}`];if(s?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&r.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[i,o]=await oc(this.storage,this.storageKey),l=new URLSearchParams({code_challenge:`${encodeURIComponent(i)}`,code_challenge_method:`${encodeURIComponent(o)}`});r.push(l.toString())}if(s?.queryParams){const i=new URLSearchParams(s.queryParams);r.push(i.toString())}return s?.skipBrowserRedirect&&r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${t}?${r.join("&")}`}async _unenroll(t){try{return await this._useSession(async e=>{var s;const{data:r,error:i}=e;return i?this._returnResult({data:null,error:i}):await Vt(this.fetch,"DELETE",`${this.url}/factors/${t.factorId}`,{headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token})})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}}async _enroll(t){try{return await this._useSession(async e=>{var s,r;const{data:i,error:o}=e;if(o)return this._returnResult({data:null,error:o});const l=Object.assign({friendly_name:t.friendlyName,factor_type:t.factorType},t.factorType==="phone"?{phone:t.phone}:t.factorType==="totp"?{issuer:t.issuer}:{}),{data:c,error:h}=await Vt(this.fetch,"POST",`${this.url}/factors`,{body:l,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(t.factorType==="totp"&&c.type==="totp"&&(!((r=c?.totp)===null||r===void 0)&&r.qr_code)&&(c.totp.qr_code=`data:image/svg+xml;utf-8,${c.totp.qr_code}`),this._returnResult({data:c,error:null}))})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}}async _verify(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async e=>{var s;const{data:r,error:i}=e;if(i)return this._returnResult({data:null,error:i});const o=Object.assign({challenge_id:t.challengeId},"webauthn"in t?{webauthn:Object.assign(Object.assign({},t.webauthn),{credential_response:t.webauthn.type==="create"?ZH(t.webauthn.credential_response):JH(t.webauthn.credential_response)})}:{code:t.code}),{data:l,error:c}=await Vt(this.fetch,"POST",`${this.url}/factors/${t.factorId}/verify`,{body:o,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return c?this._returnResult({data:null,error:c}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+l.expires_in},l)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",l),this._returnResult({data:l,error:c}))})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}})}async _challenge(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async e=>{var s;const{data:r,error:i}=e;if(i)return this._returnResult({data:null,error:i});const o=await Vt(this.fetch,"POST",`${this.url}/factors/${t.factorId}/challenge`,{body:t,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});if(o.error)return o;const{data:l}=o;if(l.type!=="webauthn")return{data:l,error:null};switch(l.webauthn.type){case"create":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:XH(l.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:YH(l.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}})}async _challengeAndVerify(t){const{data:e,error:s}=await this._challenge({factorId:t.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:t.factorId,challengeId:e.id,code:t.code})}async _listFactors(){var t;const{data:{user:e},error:s}=await this.getUser();if(s)return{data:null,error:s};const r={all:[],phone:[],totp:[],webauthn:[]};for(const i of(t=e?.factors)!==null&&t!==void 0?t:[])r.all.push(i),i.status==="verified"&&r[i.factor_type].push(i);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var t,e;const{data:{session:s},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:i}=kx(s.access_token);let o=null;i.aal&&(o=i.aal);let l=o;((e=(t=s.user.factors)===null||t===void 0?void 0:t.filter(d=>d.status==="verified"))!==null&&e!==void 0?e:[]).length>0&&(l="aal2");const h=i.amr||[];return{data:{currentLevel:o,nextLevel:l,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(t){try{return await this._useSession(async e=>{const{data:{session:s},error:r}=e;return r?this._returnResult({data:null,error:r}):s?await Vt(this.fetch,"GET",`${this.url}/oauth/authorizations/${t}`,{headers:this.headers,jwt:s.access_token,xform:i=>({data:i,error:null})}):this._returnResult({data:null,error:new Ys})})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}}async _approveAuthorization(t,e){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new Ys});const o=await Vt(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Kn()&&!e?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(Rt(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(t,e){try{return await this._useSession(async s=>{const{data:{session:r},error:i}=s;if(i)return this._returnResult({data:null,error:i});if(!r)return this._returnResult({data:null,error:new Ys});const o=await Vt(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Kn()&&!e?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(Rt(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async t=>{const{data:{session:e},error:s}=t;return s?this._returnResult({data:null,error:s}):e?await Vt(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:e.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new Ys})})}catch(t){if(Rt(t))return this._returnResult({data:null,error:t});throw t}}async _revokeOAuthGrant(t){try{return await this._useSession(async e=>{const{data:{session:s},error:r}=e;return r?this._returnResult({data:null,error:r}):s?(await Vt(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:t.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new Ys})})}catch(e){if(Rt(e))return this._returnResult({data:null,error:e});throw e}}async fetchJwk(t,e={keys:[]}){let s=e.keys.find(l=>l.kid===t);if(s)return s;const r=Date.now();if(s=this.jwks.keys.find(l=>l.kid===t),s&&this.jwks_cached_at+iH>r)return s;const{data:i,error:o}=await Vt(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(o)throw o;return!i.keys||i.keys.length===0||(this.jwks=i,this.jwks_cached_at=r,s=i.keys.find(l=>l.kid===t),!s)?null:s}async getClaims(t,e={}){try{let s=t;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:r,payload:i,signature:o,raw:{header:l,payload:c}}=kx(s);e?.allowExpired||IH(i.exp);const h=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,e?.keys?{keys:e.keys}:e?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:i,header:r,signature:o},error:null}}const d=NH(r.alg),p=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,p,o,mH(`${l}.${c}`)))throw new Ev("Invalid JWT signature");return{data:{claims:i,header:r,signature:o},error:null}}catch(s){if(Rt(s))return this._returnResult({data:null,error:s});throw s}}}Mh.nextInstanceID={};const a5=Mh,l5="2.89.0";let uh="";typeof Deno<"u"?uh="deno":typeof document<"u"?uh="web":typeof navigator<"u"&&navigator.product==="ReactNative"?uh="react-native":uh="node";const c5={"X-Client-Info":`supabase-js-${uh}/${l5}`},u5={headers:c5},h5={schema:"public"},d5={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},f5={};function Fh(n){"@babel/helpers - typeof";return Fh=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Fh(n)}function p5(n,t){if(Fh(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var s=e.call(n,t);if(Fh(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function m5(n){var t=p5(n,"string");return Fh(t)=="symbol"?t:t+""}function g5(n,t,e){return(t=m5(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function _I(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);t&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),e.push.apply(e,s)}return e}function tn(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?_I(Object(e),!0).forEach(function(s){g5(n,s,e[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):_I(Object(e)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(e,s))})}return n}const y5=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),b5=()=>Headers,x5=(n,t,e)=>{const s=y5(e),r=b5();return async(i,o)=>{var l;const c=(l=await t())!==null&&l!==void 0?l:n;let h=new r(o?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${c}`),s(i,tn(tn({},o),{},{headers:h}))}};function v5(n){return n.endsWith("/")?n:n+"/"}function w5(n,t){var e,s;const{db:r,auth:i,realtime:o,global:l}=n,{db:c,auth:h,realtime:d,global:p}=t,m={db:tn(tn({},c),r),auth:tn(tn({},h),i),realtime:tn(tn({},d),o),storage:{},global:tn(tn(tn({},p),l),{},{headers:tn(tn({},(e=p?.headers)!==null&&e!==void 0?e:{}),(s=l?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function S5(n){const t=n?.trim();if(!t)throw new Error("supabaseUrl is required.");if(!t.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(v5(t))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var C5=class extends a5{constructor(n){super(n)}},T5=class{constructor(n,t,e){var s,r;this.supabaseUrl=n,this.supabaseKey=t;const i=S5(n);if(!t)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",i),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",i),this.storageUrl=new URL("storage/v1",i),this.functionsUrl=new URL("functions/v1",i);const o=`sb-${i.hostname.split(".")[0]}-auth-token`,l={db:h5,realtime:f5,auth:tn(tn({},d5),{},{storageKey:o}),global:u5},c=w5(e??{},l);if(this.storageKey=(s=c.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(r=c.global.headers)!==null&&r!==void 0?r:{},c.accessToken)this.accessToken=c.accessToken,this.auth=new Proxy({},{get:(d,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=c.auth)!==null&&h!==void 0?h:{},this.headers,c.global.fetch)}this.fetch=x5(t,this._getAccessToken.bind(this),c.global.fetch),this.realtime=this._initRealtimeClient(tn({headers:this.headers,accessToken:this._getAccessToken.bind(this)},c.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new sW(new URL("rest/v1",i).href,{headers:this.headers,schema:c.db.schema,fetch:this.fetch}),this.storage=new tH(this.storageUrl.href,this.headers,this.fetch,e?.storage),c.accessToken||this._listenForAuthEvents()}get functions(){return new JG(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,t={},e={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,t,e)}channel(n,t={config:{}}){return this.realtime.channel(n,t)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,t,e;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(t=(e=s.session)===null||e===void 0?void 0:e.access_token)!==null&&t!==void 0?t:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:t,detectSessionInUrl:e,storage:s,userStorage:r,storageKey:i,flowType:o,lock:l,debug:c,throwOnError:h},d,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new C5({url:this.authUrl.href,headers:tn(tn({},m),d),storageKey:i,autoRefreshToken:n,persistSession:t,detectSessionInUrl:e,storage:s,userStorage:r,flowType:o,lock:l,debug:c,throwOnError:h,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new vW(this.realtimeUrl.href,tn(tn({},n),{},{params:tn(tn({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,t)=>{this._handleTokenChanged(n,"CLIENT",t?.access_token)})}_handleTokenChanged(n,t,e){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==e?(this.changedAccessToken=e,this.realtime.setAuth(e)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),t=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const k5=(n,t,e)=>new T5(n,t,e);function $5(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const t=n.match(/^v(\d+)\./);return t?parseInt(t[1],10)<=18:!1}$5()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const E5="https://brrjoheinakfhohesogc.supabase.co",I5="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",N5={getItem:n=>typeof chrome<"u"&&chrome.storage&&chrome.storage.local?new Promise(t=>{chrome.storage.local.get([n],e=>t(e[n]||null))}):localStorage.getItem(n),setItem:(n,t)=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.set({[n]:t}):localStorage.setItem(n,t)},removeItem:n=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.remove([n]):localStorage.removeItem(n)}},gs=k5(E5,I5,{auth:{storage:N5,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!1}}),TR=St.createContext(),A5=({children:n})=>{const[t,e]=St.useState(null),[s,r]=St.useState(null),[i,o]=St.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[l,c]=St.useState(!0);St.useEffect(()=>{p(),gs.auth.getSession().then(({data:{session:y}})=>{e(y?.user||null),y?.user?h(y.user.id,y.user.email):c(!1)});const{data:{subscription:m}}=gs.auth.onAuthStateChange((y,b)=>{e(b?.user||null),b?.user?h(b.user.id,b.user.email):(r(null),c(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await gs.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:S}=await gs.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();S||(b=w)}b&&b.subscription_tier==="pro"&&b.pro_expires_at&&new Date(b.pro_expires_at)<new Date&&(console.log("Pro status expired. Downgrading to free tier..."),await gs.from("profiles").update({subscription_tier:"free"}).eq("id",m),b.subscription_tier="free"),r(b)}catch(b){console.error("Profile fetch error:",b)}finally{c(!1)}},d=()=>{t&&h(t.id,t.email)},p=async()=>{try{const{data:m,error:y}=await gs.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&o(m)}catch(m){console.error("Neural state sync error:",m)}};return it.jsx(TR.Provider,{value:{user:t,profile:s,neuralState:i,loading:l,refreshProfile:d,fetchNeuralState:p,setUser:e,setProfile:r,setNeuralState:o},children:n})},_5=()=>St.useContext(TR),Iv=(n,t)=>{if(!n||n.length<t)return[];const e=[];for(let s=t-1;s<n.length;s++){const r=n.slice(s-t+1,s+1).reduce((i,o)=>i+o,0);e.push(r/t)}return e},Wa=(n,t)=>{if(n.length<t)return[];const e=2/(t+1);let s=[n[0]];for(let r=1;r<n.length;r++)s.push(n[r]*e+s[r-1]*(1-e));return s},R5=(n,t=14)=>{if(n.length<t+1)return[];let e=0,s=0;for(let c=1;c<=t;c++){const h=n[c]-n[c-1];h>=0?e+=h:s+=Math.abs(h)}let r=e/t,i=s/t;const o=[];let l=i===0?100:r/i;o.push(100-100/(1+l));for(let c=t+1;c<n.length;c++){const h=n[c]-n[c-1];h>=0?(r=(r*(t-1)+h)/t,i=(i*(t-1)+0)/t):(r=(r*(t-1)+0)/t,i=(i*(t-1)+Math.abs(h))/t),l=i===0?100:r/i,o.push(100-100/(1+l))}return o},kR=(n,t=20,e=2)=>{if(n.length<t)return[];const s=[],r=[],i=Iv(n,t);for(let o=0;o<i.length;o++){const l=n.slice(o,o+t),c=i[o],d=l.map(m=>Math.pow(m-c,2)).reduce((m,y)=>m+y,0)/t,p=Math.sqrt(d);r.push(c+e*p),s.push(c-e*p)}return{basis:i,upper:r,lower:s}},D5=(n,t=12,e=26,s=9)=>{const r=Wa(n,t),i=Wa(n,e),o=[],l=Math.min(r.length,i.length);for(let d=0;d<l;d++)o.push(r[d]-i[d]);const c=Wa(o,s),h=[];for(let d=0;d<Math.min(o.length,c.length);d++)h.push(o[d]-c[d]);return{macdLine:o,signalLine:c,histogram:h}},O5=(n,t=[],e=[],s=[])=>{if(n.length<50)return[{name:"Insufficient Data",sentiment:"Neutral",confidence:0}];const r=n[n.length-1],i=n[n.length-2],o=s.length>0?s[s.length-1]:i,l=t.length>0?t[t.length-1]:Math.max(r,o),c=e.length>0?e[e.length-1]:Math.min(r,o),h=Math.abs(r-o),d=l-c||1e-4,p=(r+o)/2,m=r>o,y=r<o;let b=[];h/d<.1&&(p>l-d*.2?b.push({name:"Dragonfly Doji",sentiment:"Bullish",icon:"zap"}):p<c+d*.2?b.push({name:"Gravestone Doji",sentiment:"Bearish",icon:"trending-down"}):b.push({name:"Doji Star",sentiment:"Neutral",icon:"minus"}));const x=Math.min(o,r)-c,w=l-Math.max(o,r);if(x>h*2&&w<h*.5&&b.push({name:"Hammer",sentiment:"Bullish",icon:"thumbs-up"}),w>h*2&&x<h*.5&&b.push({name:m?"Inverted Hammer":"Shooting Star",sentiment:m?"Bullish":"Bearish",icon:m?"zap":"trending-down"}),s.length>1){const A=s[s.length-2],B=n[n.length-2],H=B<A,W=B>A;m&&H&&r>A&&o<B?b.push({name:"Bullish Engulfing",sentiment:"Bullish",icon:"zap"}):y&&W&&r<A&&o>B&&b.push({name:"Bearish Engulfing",sentiment:"Bearish",icon:"trending-down"})}if(s.length>1){const A=s[s.length-2],B=n[n.length-2],H=t[t.length-2]||Math.max(A,B),W=e[e.length-2]||Math.min(A,B);l<H&&c>W&&b.push({name:"Harami (Inside Bar)",sentiment:m?"Bullish":"Bearish",icon:"activity"})}h/d>.9&&b.push({name:m?"Bullish Marubozu":"Bearish Marubozu",sentiment:m?"Bullish":"Bearish",icon:"zap"});const S=Iv(n.slice(-20),10),T=Iv(n.slice(-50),40),k=S[S.length-1],$=T[T.length-1],E=k>$,{upper:N,lower:_}=kR(n,20),R=N[N.length-1],D=_[_.length-1];return(R-D)/r<.05&&b.push({name:"Volatility Squeeze",sentiment:"Neutral",icon:"activity"}),b.length===0&&(E?b.push({name:"Bullish Continuation",sentiment:"Bullish",icon:"trending-up"}):b.push({name:"Bearish Continuation",sentiment:"Bearish",icon:"trending-down"})),b},M5=(n,t,e,s=14)=>{let r=[];const i=Array.isArray(n)&&Array.isArray(t)&&Array.isArray(e),o=i||Array.isArray(n)?n.length:0;if(o<s+1)return[];for(let d=1;d<o;d++){let p;if(i){const m=n[d],y=t[d],b=e[d-1];p=Math.max(m-y,Math.abs(m-b),Math.abs(y-b))}else{const m=n[d],y=n[d-1],b=Math.abs(m-y);p=Math.max(b,m*.0075)}r.push(p)}const l=[];let c=r.slice(0,s).reduce((d,p)=>d+p,0)/s;l.push(c);for(let d=s;d<r.length;d++){const p=(l[l.length-1]*(s-1)+r[d])/s;l.push(p)}return[...new Array(o-l.length).fill(l[0]),...l]},F5=(n,t,e)=>{const s=Array.isArray(n)?n:[];if(s.length<20)return{support:Math.min(...s),resistance:Math.max(...s),strength:{s:1,r:1}};const r=Array.isArray(t)&&Array.isArray(e)&&t.length===s.length,i=[],o=5;for(let p=o;p<s.length-o;p++)if(r){const m=t.slice(p-o,p+o+1),y=t[p];m.every(w=>w<=y)&&i.push({price:y,type:"Resistance"});const b=e.slice(p-o,p+o+1),x=e[p];b.every(w=>w>=x)&&i.push({price:x,type:"Support"})}else{const m=s.slice(p-o,p+o+1),y=s[p],b=m.every(w=>w<=y),x=m.every(w=>w>=y);b&&i.push({price:y,type:"Resistance"}),x&&i.push({price:y,type:"Support"})}const l=s[s.length-1],c=(p,m)=>{const y=i.filter(S=>S.type===p&&(p==="Support"?S.price<m:S.price>m));if(y.length===0)return{price:p==="Support"?Math.min(...s):Math.max(...s),strength:1};const x=y.sort((S,T)=>Math.abs(S.price-m)-Math.abs(T.price-m))[0].price,w=i.filter(S=>S.type===p&&Math.abs(S.price-x)/x<.005).length;return{price:x,strength:Math.min(5,w)}},h=c("Support",l),d=c("Resistance",l);return{support:h.price,resistance:d.price,strength:{s:h.strength,r:d.strength}}},L5=(n,t,e,s)=>{if(!s||s.length===0||s.length!==e.length)return e;let r=0,i=0;const o=[];for(let l=0;l<e.length;l++){const c=(n[l]+t[l]+e[l])/3;r+=c*s[l],i+=s[l],o.push(i===0?c:r/i)}return o},P5=n=>{if(!n||n.length<50)return .5;const t=Wa(n.slice(-20),10),e=Wa(n.slice(-50),40),s=t[t.length-1],r=e[e.length-1];let i=.5;s>r&&(i=.75),s<r&&(i=.25);const o=n[n.length-1];return o>s&&s>r&&(i=.9),o<s&&s<r&&(i=.1),i};const z5=1e-7,B5=1e-4;class $R{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Jw{refCount(t){return Ds("refCount")}incRef(t){return Ds("incRef")}timerAvailable(){return!0}time(t){return Ds("time")}read(t){return Ds("read")}readSync(t){return Ds("readSync")}readToGPU(t,e){return Ds("readToGPU")}numDataIds(){return Ds("numDataIds")}disposeData(t,e){return Ds("disposeData")}write(t,e,s){return Ds("write")}move(t,e,s,r,i){return Ds("move")}createTensorFromGPUData(t,e,s){return Ds("createTensorFromGPUData")}memory(){return Ds("memory")}floatPrecision(){return Ds("floatPrecision")}epsilon(){return this.floatPrecision()===32?z5:B5}dispose(){return Ds("dispose")}}function Ds(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function V5(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,gc(n,t,e)}function Xa(n,t,e){return Math.max(n,Math.min(t,e))}function Qw(n){return n%2===0?n:n+1}function gc(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function U5(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function L(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function t1(n,t,e=""){L(we(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function e1(n){L(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ft(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function we(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Oc(n){return n%1===0}function Nv(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Ec(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function RI(n,t=r=>0,e,s){return new Promise((r,i)=>{let o=0;const l=()=>{if(n()){r();return}o++;const c=t(o);if(e!=null&&o>=e){i();return}s!=null?s(l,c):setTimeout(l,c)};l()})}function ER(n,t){let e=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[s]=t/e,r}function ee(n,t){const e=t.length;return n=n==null?t.map((s,r)=>r):[].concat(n),L(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),L(n.every(s=>Oc(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function Ko(n,t){const e=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:ee(t,n).sort();let o=0;for(let l=0;l<n.length;++l){if(i!=null){if(i[o]===l&&n[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${n[l]}' is not 1`);(i[o]==null||i[o]>l)&&n[l]===1&&(e.push(n[l]),s.push(l)),i[o]<=l&&o++}n[l]!==1&&(e.push(n[l]),s.push(l))}return{newShape:e,keptDims:s}}function Yn(n,t){return nn(n,t)}function nn(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function j5(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function G5(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function IR(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function Em(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function W5(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function ed(n){return typeof n=="string"||n instanceof String}function H5(n){return typeof n=="boolean"}function Av(n){return typeof n=="number"}function Kc(n){return Array.isArray(n)?Kc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Av(n)?"float32":ed(n)?"string":H5(n)?"bool":"float32"}function _v(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Rv(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function Dt(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function NR(n,t,e,s=!1){const r=new Array;if(t.length===1){const i=t[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=e[n+o]}else{const i=t[0],o=t.slice(1),l=o.reduce((c,h)=>c*h)*(s?2:1);for(let c=0;c<i;c++)r[c]=NR(n+c*l,o,e,s)}return r}function Hr(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((r,i)=>r*i)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return NR(0,n,t,e)}function q5(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function n1(n,t){const e=Zn(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function Zn(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function AR(n,t){const e=n.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return Hr(n,new Float32Array(e));if(t==="int32")return Hr(n,new Int32Array(e));if(t==="bool")return Hr(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Qi(n){n.forEach(t=>{L(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function di(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function Xc(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function s1(n){return n&&n.then&&typeof n.then=="function"}const DI="tfjsflags";class K5{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=X5,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(lt().getBool("IS_TEST")||lt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];lt().getBool("IS_TEST")||lt().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(s1(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);DI in t&&t[DI].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=Z5(r,i)})}}function X5(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(Y5(t,s[0],s[1]),s.join("="))),t}function Y5(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function Z5(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function lt(){return _R}let _R=null;function J5(n){_R=n}let Ix;function RR(){if(Ix==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Ix=n}return Ix}function Q5(){const n=RR();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function r1(n,t){const e=Q5();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const hg="Abs",nd="Acos",sd="Acosh",Yc="Add",i1="AddN",o1="All",a1="Any",dg="ArgMax",fg="ArgMin",rd="Asin",id="Asinh",od="Atan",ad="Atanh",ld="Atan2",pg="AvgPool",l1="AvgPoolGrad",mg="AvgPool3D",c1="AvgPool3DGrad",gg="BatchMatMul",yg="BatchToSpaceND",u1="Bincount",h1="BitwiseAnd",t6="BroadcastTo",DR="BroadcastArgs",cd="Cast",ud="Ceil",hd="ClipByValue",d1="Complex",bg="ComplexAbs",xg="Concat",vg="Conv2D",f1="Conv2DBackpropFilter",wg="Conv2DBackpropInput",Sg="Conv3D",p1="Conv3DBackpropFilterV2",m1="Conv3DBackpropInputV2",dd="Cos",fd="Cosh",g1="Cumprod",Cg="Cumsum",y1="CropAndResize",b1="DenseBincount",x1="DepthToSpace",Tg="DepthwiseConv2dNative",v1="DepthwiseConv2dNativeBackpropFilter",w1="DepthwiseConv2dNativeBackpropInput",OR="Diag",kg="Dilation2D",Dv="Dilation2DBackpropInput",Ov="Dilation2DBackpropFilter",e6="Draw",pd="RealDiv",S1="Einsum",md="Elu",C1="EluGrad",gd="Erf",$g="Equal",yd="Exp",Eg="ExpandDims",bd="Expm1",T1="FFT",k1="Fill",$1="FlipLeftRight",xd="Floor",vd="FloorDiv",Ig="FusedBatchNorm",Ng="GatherV2",MR="GatherNd",Ag="Greater",wd="GreaterEqual",Sd="Identity",E1="IFFT",I1="Imag",Cd="IsFinite",Td="IsInf",kd="IsNan",_g="LeakyRelu",Rg="Less",Dg="LessEqual",FR="LinSpace",$d="Log",Ed="Log1p",Og="LogicalAnd",Mg="LogicalNot",Fg="LogicalOr",n6="LogSoftmax",Lg="LRN",N1="LRNGrad",Pg="Max",Id="Maximum",zg="MaxPool",A1="MaxPoolGrad",Bg="MaxPool3D",_1="MaxPool3DGrad",LR="MaxPoolWithArgmax",Vg="Mean",Ug="Min",Nd="Minimum",jg="MirrorPad",Ad="Mod",PR="Multinomial",_d="Multiply",Gg="Neg",Wg="NotEqual",R1="NonMaxSuppressionV3",D1="NonMaxSuppressionV4",O1="NonMaxSuppressionV5",Hg="OnesLike",qg="OneHot",Kg="Pack",Xg="PadV2",Rd="Pow",Yg="Prelu",Zg="Prod",zR="RaggedGather",BR="RaggedRange",VR="RaggedTensorToTensor",M1="Range",F1="Real",Dd="Reciprocal",Od="Relu",Jg="Reshape",Qg="ResizeNearestNeighbor",L1="ResizeNearestNeighborGrad",t0="ResizeBilinear",P1="ResizeBilinearGrad",Md="Relu6",e0="Reverse",Fd="Round",Ld="Rsqrt",UR="ScatterNd",jR="TensorScatterUpdate",GR="SearchSorted",n0="Select",Pd="Selu",s0="Slice",zd="Sin",Bd="Sinh",Vd="Sign",Ud="Sigmoid",jd="Softplus",Gd="Sqrt",r0="Sum",i0="SpaceToBatchND",o0="SplitV",a0="Softmax",WR="SparseFillEmptyRows",HR="SparseReshape",qR="SparseSegmentMean",KR="SparseSegmentSum",XR="SparseToDense",Wd="SquaredDifference",z1="Square",B1="StaticRegexReplace",V1="StridedSlice",YR="StringNGrams",ZR="StringSplit",JR="StringToHashBucketFast",Hd="Sub",qd="Tan",Kd="Tanh",Xd="Tile",U1="TopK",j1="Transform",Ic="Transpose",G1="Unique",l0="Unpack",c0="UnsortedSegmentSum",u0="ZerosLike",Yd="Step",s6="FromPixels",W1="RotateWithOffset",Im="_FusedMatMul",Nm="FusedConv2D",QR="FusedDepthwiseConv2D";function Qs(...n){lt().getBool("IS_TEST")||lt().getBool("PROD")||console.warn(...n)}function r6(...n){lt().getBool("IS_TEST")||lt().getBool("PROD")||console.log(...n)}const Am=r1("kernelRegistry",()=>new Map),Mv=r1("gradRegistry",()=>new Map);function OI(n,t){const e=eD(n,t);return Am.get(e)}function MI(n){return Mv.get(n)}function FI(n){const t=Am.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,o]=r,[l]=i.split("_");l===n&&e.push(o)}return e}function tD(n){const{kernelName:t,backendName:e}=n,s=eD(t,e);Am.has(s)&&Qs(`The kernel '${t}' for backend '${e}' is already registered`),Am.set(s,n)}function i6(n){const{kernelName:t}=n;Mv.has(t)&&lt().getBool("DEBUG")&&Qs(`Overriding the gradient for '${t}'`),Mv.set(t,n)}function eD(n,t){return`${t}_${n}`}function nD(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Nx,LI;function o6(){if(LI)return Nx;LI=1,Nx=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(M,A,B){this.low=M|0,this.high=A|0,this.unsigned=!!B}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(M){return(M&&M.__isLong__)===!0}t.isLong=e;var s={},r={};function i(M,A){var B,H,W;return A?(M>>>=0,(W=0<=M&&M<256)&&(H=r[M],H)?H:(B=l(M,(M|0)<0?-1:0,!0),W&&(r[M]=B),B)):(M|=0,(W=-128<=M&&M<128)&&(H=s[M],H)?H:(B=l(M,M<0?-1:0,!1),W&&(s[M]=B),B))}t.fromInt=i;function o(M,A){if(isNaN(M))return A?T:S;if(A){if(M<0)return T;if(M>=b)return _}else{if(M<=-x)return R;if(M+1>=x)return N}return M<0?o(-M,A).neg():l(M%y|0,M/y|0,A)}t.fromNumber=o;function l(M,A,B){return new t(M,A,B)}t.fromBits=l;var c=Math.pow;function h(M,A,B){if(M.length===0)throw Error("empty string");if(M==="NaN"||M==="Infinity"||M==="+Infinity"||M==="-Infinity")return S;if(typeof A=="number"?(B=A,A=!1):A=!!A,B=B||10,B<2||36<B)throw RangeError("radix");var H;if((H=M.indexOf("-"))>0)throw Error("interior hyphen");if(H===0)return h(M.substring(1),A,B).neg();for(var W=o(c(B,8)),X=S,P=0;P<M.length;P+=8){var U=Math.min(8,M.length-P),G=parseInt(M.substring(P,P+U),B);if(U<8){var tt=o(c(B,U));X=X.mul(tt).add(o(G))}else X=X.mul(W),X=X.add(o(G))}return X.unsigned=A,X}t.fromString=h;function d(M,A){return typeof M=="number"?o(M,A):typeof M=="string"?h(M,A):l(M.low,M.high,typeof A=="boolean"?A:M.unsigned)}t.fromValue=d;var p=65536,m=1<<24,y=p*p,b=y*y,x=b/2,w=i(m),S=i(0);t.ZERO=S;var T=i(0,!0);t.UZERO=T;var k=i(1);t.ONE=k;var $=i(1,!0);t.UONE=$;var E=i(-1);t.NEG_ONE=E;var N=l(-1,2147483647,!1);t.MAX_VALUE=N;var _=l(-1,-1,!0);t.MAX_UNSIGNED_VALUE=_;var R=l(0,-2147483648,!1);t.MIN_VALUE=R;var D=t.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},D.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var B=o(A),H=this.div(B),W=H.mul(B).sub(this);return H.toString(A)+W.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var X=o(c(A,6),this.unsigned),P=this,U="";;){var G=P.div(X),tt=P.sub(G.mul(X)).toInt()>>>0,Z=tt.toString(A);if(P=G,P.isZero())return Z+U;for(;Z.length<6;)Z="0"+Z;U=""+Z+U}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,B=31;B>0&&(A&1<<B)==0;B--);return this.high!=0?B+33:B+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(A){return e(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},D.eq=D.equals,D.notEquals=function(A){return!this.eq(A)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(A){return this.comp(A)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(A){return this.comp(A)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(A){return this.comp(A)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(A){return this.comp(A)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(A){if(e(A)||(A=d(A)),this.eq(A))return 0;var B=this.isNegative(),H=A.isNegative();return B&&!H?-1:!B&&H?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(k)},D.neg=D.negate,D.add=function(A){e(A)||(A=d(A));var B=this.high>>>16,H=this.high&65535,W=this.low>>>16,X=this.low&65535,P=A.high>>>16,U=A.high&65535,G=A.low>>>16,tt=A.low&65535,Z=0,F=0,z=0,Q=0;return Q+=X+tt,z+=Q>>>16,Q&=65535,z+=W+G,F+=z>>>16,z&=65535,F+=H+U,Z+=F>>>16,F&=65535,Z+=B+P,Z&=65535,l(z<<16|Q,Z<<16|F,this.unsigned)},D.subtract=function(A){return e(A)||(A=d(A)),this.add(A.neg())},D.sub=D.subtract,D.multiply=function(A){if(this.isZero())return S;if(e(A)||(A=d(A)),n){var B=n.mul(this.low,this.high,A.low,A.high);return l(B,n.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(R))return A.isOdd()?R:S;if(A.eq(R))return this.isOdd()?R:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return o(this.toNumber()*A.toNumber(),this.unsigned);var H=this.high>>>16,W=this.high&65535,X=this.low>>>16,P=this.low&65535,U=A.high>>>16,G=A.high&65535,tt=A.low>>>16,Z=A.low&65535,F=0,z=0,Q=0,ct=0;return ct+=P*Z,Q+=ct>>>16,ct&=65535,Q+=X*Z,z+=Q>>>16,Q&=65535,Q+=P*tt,z+=Q>>>16,Q&=65535,z+=W*Z,F+=z>>>16,z&=65535,z+=X*tt,F+=z>>>16,z&=65535,z+=P*G,F+=z>>>16,z&=65535,F+=H*Z+W*tt+X*G+P*U,F&=65535,l(Q<<16|ct,F<<16|z,this.unsigned)},D.mul=D.multiply,D.divide=function(A){if(e(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var B=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return l(B,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:S;var H,W,X;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return T;if(A.gt(this.shru(1)))return $;X=T}else{if(this.eq(R)){if(A.eq(k)||A.eq(E))return R;if(A.eq(R))return k;var P=this.shr(1);return H=P.div(A).shl(1),H.eq(S)?A.isNegative()?k:E:(W=this.sub(A.mul(H)),X=H.add(W.div(A)),X)}else if(A.eq(R))return this.unsigned?T:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();X=S}for(W=this;W.gte(A);){H=Math.max(1,Math.floor(W.toNumber()/A.toNumber()));for(var U=Math.ceil(Math.log(H)/Math.LN2),G=U<=48?1:c(2,U-48),tt=o(H),Z=tt.mul(A);Z.isNegative()||Z.gt(W);)H-=G,tt=o(H,this.unsigned),Z=tt.mul(A);tt.isZero()&&(tt=k),X=X.add(tt),W=W.sub(Z)}return X},D.div=D.divide,D.modulo=function(A){if(e(A)||(A=d(A)),n){var B=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return l(B,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return l(~this.low,~this.high,this.unsigned)},D.and=function(A){return e(A)||(A=d(A)),l(this.low&A.low,this.high&A.high,this.unsigned)},D.or=function(A){return e(A)||(A=d(A)),l(this.low|A.low,this.high|A.high,this.unsigned)},D.xor=function(A){return e(A)||(A=d(A)),l(this.low^A.low,this.high^A.high,this.unsigned)},D.shiftLeft=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):l(0,this.low<<A-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):l(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(A){if(e(A)&&(A=A.toInt()),A&=63,A===0)return this;var B=this.high;if(A<32){var H=this.low;return l(H>>>A|B<<32-A,B>>>A,this.unsigned)}else return A===32?l(B,0,this.unsigned):l(B>>>A-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},D.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var A=this.high,B=this.low;return[B&255,B>>>8&255,B>>>16&255,B>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},D.toBytesBE=function(){var A=this.high,B=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,B>>>24,B>>>16&255,B>>>8&255,B&255]},t.fromBytes=function(A,B,H){return H?t.fromBytesLE(A,B):t.fromBytesBE(A,B)},t.fromBytesLE=function(A,B){return new t(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,B)},t.fromBytesBE=function(A,B){return new t(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],B)},Nx}var sD=o6();const rD=dw(sD),a6=TB({__proto__:null,default:rD},[sD]);const Ma=rD||a6;function h0(n){return Ma.fromString(n,!0,16)}const iD=h0("c3a5c85c97cb3127"),Ra=h0("b492b66fbe98f273"),os=h0("9ae16a3b2f90404f");function Fv(n){return n.xor(n.shru(47))}function oD(n,t,e){const s=n.slice(t,t+e);return Ma.fromBytes(Array.from(s),!0,!0)}function Me(n,t){return oD(n,t,8)}function PI(n,t){return oD(n,t,4)}function An(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Mo(n,t,e=h0("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let r=t.xor(s).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function l6(n,t,e,s,r,i){r=r.add(n),i=An(i.add(r).add(s),21);const o=r;return r=r.add(t),r=r.add(e),i=i.add(An(r,44)),[r.add(s),i.add(o)]}function Hp(n,t,e,s){return l6(Me(n,t),Me(n,t+8),Me(n,t+16),Me(n,t+24),e,s)}function c6(n,t=n.length){if(t>=8){const e=os.add(t*2),s=Me(n,0).add(os),r=Me(n,t-8),i=An(r,37).mul(e).add(s),o=An(s,25).add(r).mul(e);return Mo(i,o,e)}if(t>=4){const e=os.add(t*2),s=PI(n,0);return Mo(s.shl(3).add(t),PI(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],r=n[t-1],i=e+(s<<8),o=t+(r<<2);return Fv(os.mul(i).xor(iD.mul(o))).mul(os)}return os}function u6(n,t=n.length){const e=os.add(t*2),s=Me(n,0).mul(Ra),r=Me(n,8),i=Me(n,t-8).mul(e),o=Me(n,t-16).mul(os);return Mo(An(s.add(r),43).add(An(i,30)).add(o),s.add(An(r.add(os),18)).add(i),e)}function h6(n,t=n.length){const e=os.add(t*2),s=Me(n,0).mul(os),r=Me(n,8),i=Me(n,t-8).mul(e),o=Me(n,t-16).mul(os),l=An(s.add(r),43).add(An(i,30)).add(o),c=Mo(l,s.add(An(r.add(os),18)).add(i),e),h=Me(n,16).mul(e),d=Me(n,24),p=l.add(Me(n,t-32)).mul(e),m=c.add(Me(n,t-24)).mul(e);return Mo(An(h.add(d),43).add(An(p,30)).add(m),h.add(An(d.add(s),18)).add(p),e)}function d6(n,t=n.length){const e=Ma.fromNumber(81,!0);if(t<=32)return t<=16?c6(n,t):u6(n,t);if(t<=64)return h6(n,t);let s=e,r=e.mul(Ra).add(113),i=Fv(r.mul(os).add(113)).mul(os),o=[Ma.UZERO,Ma.UZERO],l=[Ma.UZERO,Ma.UZERO];s=s.mul(os).add(Me(n,0));let c=0;const h=(t-1>>6)*64,d=h+(t-1&63)-63;do s=An(s.add(r).add(o[0]).add(Me(n,c+8)),37).mul(Ra),r=An(r.add(o[1]).add(Me(n,c+48)),42).mul(Ra),s=s.xor(l[1]),r=r.add(o[0]).add(Me(n,c+40)),i=An(i.add(l[0]),33).mul(Ra),o=Hp(n,c,o[1].mul(Ra),s.add(l[0])),l=Hp(n,c+32,i.add(l[1]),r.add(Me(n,c+16))),[i,s]=[s,i],c+=64;while(c!==h);const p=Ra.add(i.and(255).shl(1));return c=d,l[0]=l[0].add(t-1&63),o[0]=o[0].add(l[0]),l[0]=l[0].add(o[0]),s=An(s.add(r).add(o[0]).add(Me(n,c+8)),37).mul(p),r=An(r.add(o[1]).add(Me(n,c+48)),42).mul(p),s=s.xor(l[1].mul(9)),r=r.add(o[0].mul(9).add(Me(n,c+40))),i=An(i.add(l[0]),33).mul(p),o=Hp(n,c,o[1].mul(p),s.add(l[0])),l=Hp(n,c+32,i.add(l[1]),r.add(Me(n,c+16))),[i,s]=[s,i],Mo(Mo(o[0],l[0],p).add(Fv(r).mul(iD)).add(i),Mo(o[1],l[1],p).add(s),p)}function Xo(n,t){return t==="string"?Fo(n):ul([n],t)}function f6(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function ul(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ya(n)),lt().getBool("DEBUG")&&j5(n,t),f6(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function ys(){return lt().platform.now()}function Fo(n,t="utf-8"){return t=t||"utf-8",lt().platform.encode(n,t)}function Vo(n,t="utf-8"){return t=t||"utf-8",lt().platform.decode(n,t)}function kr(n){return lt().platform.isTypedArray!=null?lt().platform.isTypedArray(n):nD(n)}function Ya(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||s1(n)||n==null||kr(n)&&e)t.push(n);else if(Array.isArray(n)||kr(n))for(let s=0;s<n.length;++s)Ya(n[s],t,e);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Ya(n[r],t,e)}return t}class p6{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new g6)}profileKernel(t,e,s){let r;const i=()=>{r=s()};let o;const l=ys();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const h of r)h.dataSync();o=Promise.resolve({kernelMs:ys()-l})}if(lt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(p=>{m6(p,d.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(h=>h.kernelMs),extraInfo:o.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:i,extraInfo:o}=t;s.forEach(l=>{Promise.all([l.data(),r,o]).then(c=>{this.logger.logKernelProfile(e,l,c[0],c[1],i,c[2])})})}}function m6(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class g6{logKernelProfile(t,e,s,r,i,o){const l=typeof r=="number"?Ec(`${r}ms`,9):r.error,c=Ec(t,25),h=e.rank,d=e.size,p=Ec(e.shape.toString(),14);let m="";for(const y in i){const b=i[y];if(b!=null){const x=b.shape||e.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${c}	%c${l}	%c${h}D ${p}	%c${d}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function y6(n,t,e){const s={},r={};for(let c=0;c<t.length;c++)s[t[c].id]=!0;for(let c=0;c<n.length;c++){const h=n[c],d=h.inputs;for(const p in d){const m=d[p];let y=!1;for(let b=0;b<t.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const i={};i[e.id]=!0;const o={};for(let c=n.length-1;c>=0;c--){const h=n[c],d=h.inputs;for(let p=0;p<h.outputs.length;p++)if(i[h.outputs[p].id]){for(const m in d)i[d[m].id]=!0,o[h.id]=!0;break}}const l=[];for(let c=0;c<n.length;c++){const h=n[c];if(r[h.id]&&o[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const p=Object.assign({},h);p.inputs=d,p.outputs=h.outputs,l.push(p)}}return l}function b6(n,t,e,s){for(let r=t.length-1;r>=0;r--){const i=t[r],o=[];if(i.outputs.forEach(c=>{const h=n[c.id];h!=null?o.push(h):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const l=i.gradient(o);for(const c in i.inputs){if(!(c in l))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(l)}.`);const h=e(()=>l[c]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${h.dtype}'`);const d=i.inputs[c];if(!we(h.shape,d.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${c}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const p=n[d.id];n[d.id]=s(p,h),p.dispose()}}}}const zI=20,rh=3,Ax=7;function x6(n,t,e,s){const r=Dt(t),i=v6(n,t,e,r),o=t.length,l=cm(n,t,e,r,i),c=["Tensor"];return s&&(c.push(`  dtype: ${e}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map(h=>"    "+h).join(`
`)),c.join(`
`)}function v6(n,t,e,s){const r=ft(t),i=s[s.length-1],o=new Array(i).fill(0),l=t.length,c=e==="complex64"?dh(n):n;if(l>1)for(let h=0;h<r/i;h++){const d=h*i;for(let p=0;p<i;p++)o[p]=Math.max(o[p],hh(c[d+p],0,e).length)}return o}function hh(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Ax))} + ${parseFloat(n[1].toFixed(Ax))}j`:ed(n)?s=`'${n}'`:e==="bool"?s=aD(n):s=parseFloat(n.toFixed(Ax)).toString(),Ec(s,t)}function aD(n){return n===0?"false":"true"}function cm(n,t,e,s,r,i=!0){const o=e==="complex64"?2:1,l=t[0],c=t.length;if(c===0){if(e==="complex64"){const x=dh(n);return[hh(x[0],0,e)]}return e==="bool"?[aD(n[0])]:[n[0].toString()]}if(c===1){if(l>zI){const w=rh*o;let S=Array.from(n.slice(0,w)),T=Array.from(n.slice((l-rh)*o,l*o));return e==="complex64"&&(S=dh(S),T=dh(T)),["["+S.map((k,$)=>hh(k,r[$],e)).join(", ")+", ..., "+T.map((k,$)=>hh(k,r[l-rh+$],e)).join(", ")+"]"]}return["["+(e==="complex64"?dh(n):Array.from(n)).map((w,S)=>hh(w,r[S],e)).join(", ")+"]"]}const h=t.slice(1),d=s.slice(1),p=s[0]*o,m=[];if(l>zI){for(let x=0;x<rh;x++){const w=x*p,S=w+p;m.push(...cm(n.slice(w,S),h,e,d,r,!1))}m.push("...");for(let x=l-rh;x<l;x++){const w=x*p,S=w+p;m.push(...cm(n.slice(w,S),h,e,d,r,x===l-1))}}else for(let x=0;x<l;x++){const w=x*p,S=w+p;m.push(...cm(n.slice(w,S),h,e,d,r,x===l-1))}const y=c===2?",":"";m[0]="["+(l>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<c;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(i?"":b),m}function dh(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Pn{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=ft(t),s!=null){const r=s.length;L(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||nn(e,this.size),this.strides=Dt(t)}set(t,...e){e.length===0&&(e=[0]),L(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const i=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(i)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return jr().makeTensor(this.values,this.shape,this.dtype)}}let jr=null,yc=null;function w6(n){jr=n}function S6(n){yc=n}class xn{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ft(t),this.strides=Dt(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return yc.buffer(this.shape,this.dtype,t)}bufferSync(){return yc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Hr(this.shape,t,this.dtype==="complex64")}arraySync(){return Hr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=jr().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>Vo(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),jr().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=jr().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Vo(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await jr().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),jr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return yc.print(this,t)}clone(){return this.throwIfDisposed(),yc.clone(this)}toString(t=!1){const e=this.dataSync();return x6(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),yc.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),jr().makeVariable(this,t,e,s)}}Object.defineProperty(xn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function dt(){return r1("Tensor",()=>xn)}dt();class _m extends xn{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!we(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);jr().disposeTensor(this),this.dataId=t.dataId,jr().incRef(this,null)}dispose(){jr().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(_m,Symbol.hasInstance,{value:n=>n instanceof xn&&n.assign!=null&&n.assign instanceof Function});var BI;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(BI||(BI={}));var Lv;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Lv||(Lv={}));var Pv;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Pv||(Pv={}));var zv;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(zv||(zv={}));var Bv;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Bv||(Bv={}));const C6={float32:zv,int32:Lv,bool:Pv,complex64:Bv};function Ls(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return C6[n][t]}function H1(n){return Ls(n,"int32")}function lD(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function cD(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function rn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ls(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function uD(n){const t=[];return hD(n,t,new Set),t}function hD(n,t,e){if(n==null)return;if(n instanceof xn){t.push(n);return}if(!T6(n))return;const s=n;for(const r in s){const i=s[r];e.has(i)||(e.add(i),hD(i,t,e))}}function T6(n){return Array.isArray(n)||typeof n=="object"}function _x(n){return n.kernelName!=null}class VI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Mc{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new VI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Qs(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new p6(this.backendInstance),!0}setupRegisteredKernels(){FI(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){FI(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof Jw)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Qs(`Initialization of backend ${t} failed`),Qs(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Qs(`Initialization of backend ${t} failed`),Qs(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),r=s.backend,i=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),s.backend=t,t.move(e,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=e(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,e,s){t();try{const r=s();return e(),r}catch(r){throw e(),r}}nextTensorId(){return Mc.nextTensorId++}nextVariableId(){return Mc.nextVariableId++}clone(t){const e=J.runKernel(Sd,{x:t}),s={x:t},r=o=>({x:()=>{const l="float32",c={x:o},h={dtype:l};return J.runKernel(cd,c,h)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[e],r,i,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(OI(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const r=this.backend.numDataIds();let i=0;s.forEach(c=>{i+=c.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-e-i-o;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let c;const h=_x(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(_x(t)){const{kernelName:b,inputs:x,attrs:w}=t;this.backendName==null&&this.backend;const S=OI(b,this.backendName);L(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),l=()=>{const T=this.backend.numDataIds();c=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const k=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,T,k);const $=k.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(b,x,$);s=this.saveTensorsForBackwardMode(E)}return $}}else{const{forwardFunc:b}=t,x=w=>{r&&(s=w.map(S=>this.keep(this.clone(S))))};l=()=>{const w=this.backend.numDataIds();c=this.tidy(()=>b(this.backend,x));const S=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,S),S}}const{inputs:d,attrs:p}=t,m=_x(t)?null:t.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=l():(y=this.profiler.profileKernel(h,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),r&&this.addTapeNode(h,d,e,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:e.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(c)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const r=MI(t);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let l;r.saveAllInputs?(L(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(e).map(h=>e[h])):l=i.map(h=>e[h]);const c=s.filter((h,d)=>o[d]);return l.concat(c)}return[]}makeTensor(t,e,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=t;s==="string"&&ed(t[0])&&(i=t.map(c=>Fo(c)));const o=r.write(i,e,s),l=new xn(e,s,o,this.nextTensorId());if(this.trackTensor(l,r),s==="string"){const c=this.state.tensorInfo.get(o),h=W5(i);this.state.numBytes+=h-c.bytes,c.bytes=h}return l}makeTensorFromDataId(t,e,s,r){s=s||"float32";const i={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:r,dtype:i}=t,o=new xn(r,i,s,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const i=new _m(t,e,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Em(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof _m||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Em(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,r,i,o){const l={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:i},c=MI(t);c!=null&&(r=c.gradFunc),r!=null&&(l.gradient=h=>(h=h.map((d,p)=>{if(d==null){const m=s[p],y=Zn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],i,o))),this.state.activeTape.push(l)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=uD(t),s=new Set(e.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(t,e,s,r=!1){if(L(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));L(i instanceof xn,()=>"The result y returned by f() must be a tensor.");const o=y6(this.state.activeTape,e,i);if(!r&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??k6(i.shape),b6(l,o,h=>this.tidy(h),$6);const c=e.map(h=>l[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(t){return L(_v(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{L(e.every(l=>l instanceof xn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};e.forEach((l,c)=>{r[c]=l});const i=(l,c)=>(s=t(...e,c),L(s.value instanceof xn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),L(_v(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(l,c)=>{const h=s.gradFunc(l,c),d=Array.isArray(h)?h:[h];L(d.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),L(d.every(m=>m instanceof xn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,y)=>{p[y]=()=>m}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=ys(),s=await this.backend.time(t);return s.wallMs=ys()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new VI;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Mc.nextTensorId=0;Mc.nextVariableId=0;function k6(n){const t=n1(ft(n),"float32");return J.makeTensor(t,n,"float32")}function dD(){const n=RR();if(n._tfengine==null){const t=new K5(n);n._tfengine=new Mc(t)}return J5(n._tfengine.ENV),w6(()=>n._tfengine),n._tfengine}const J=dD();function $6(n,t){const e={a:n,b:t};return J.runKernel(Yc,e)}function E6(){return typeof navigator<"u"&&navigator!=null}function fD(n){if(n||E6()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function pD(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Ss=lt();Ss.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ss.registerFlag("IS_BROWSER",()=>pD());Ss.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ss.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ss.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Ss.registerFlag("PROD",()=>!1);Ss.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ss.getBool("DEBUG"));Ss.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ss.registerFlag("IS_TEST",()=>!1);Ss.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ss.getBool("DEBUG"));Ss.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ss.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ss.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Zd(n,t){let e=n;if(kr(n))return t==="string"?[]:[n.length];if(lD(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(cD(n))return[n.buffer.size/(t==null?4:Em(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||kr(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&lt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&mD(n,s,[]),s}function mD(n,t,e){if(e=e||[],!Array.isArray(n)&&!kr(n)){L(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}L(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),L(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)mD(n[r],s,e.concat(r))}function UI(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function V(n,t,e,s="numeric"){if(n instanceof dt())return UI(s,n.dtype,t,e),n;let r=Kc(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),UI(s,r,t,e),n==null||!kr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${c}'`)}const i=Zd(n,r);!kr(n)&&!Array.isArray(n)&&(n=[n]);const l=r!=="string"?ul(n,r):Ya(n,[],!0);return J.makeTensor(l,i,r)}function gD(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>V(i,`${t}[${o}]`,e,s))}const I6="__op";function nt(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+I6;const r=(...i)=>{J.startScope(e);try{const o=s(...i);return s1(o)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(o),o}catch(o){throw J.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}function N6(n,t){const e=V(n,"real","complex"),s=V(t,"imag","complex");t1(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:e,imag:s};return J.runKernel(d1,r)}const Za=nt({complex_:N6});function Jd(n,t,e,s){if(s==null)s=Kc(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(cD(n)||lD(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return J.backend.createTensorFromGPUData(n,t||e,s)}if(!kr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Qi(t);const r=ft(t),i=ft(e);L(r===i,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<e.length;++o){const l=e[o],c=o===e.length-1?l!==ft(t.slice(o)):!0;L(e[o]===t[o]||!c,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!kr(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?ul(n,s):Ya(n,[],!0),J.makeTensor(n,t,s)}function Ch(n,t,e){const s=Zd(n,e);return Jd(n,t,s,e)}const Rm={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Yo{static join(t){return new Yo(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>kr(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=e+r.byteLength;this.shards.push({buffer:r,start:e,end:i}),e=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=e-t,i=new ArrayBuffer(r),o=new Uint8Array(i);let l=0;for(let c=s;c<this.shards.length;c++){const h=this.shards[c],p=t+l-h.start,m=l,b=Math.min(e,h.end)-h.start,x=new Uint8Array(h.buffer,p,b-p);if(o.set(x,m),l+=x.length,e<h.end)break}return i}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=A6(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function A6(n,t){let e=0,s=n.length;for(;e<=s;){const r=Math.floor((s-e)/2)+e,i=t(n[r]);if(i===0)return r;i<0?s=r:e=r+1}return-1}function ri(){return J}function jI(){return J.memory()}function rt(n,t){return J.tidy(n,t)}function Qt(n){uD(n).forEach(e=>e.dispose())}function fi(n){return J.keep(n)}function GI(n){return J.setBackend(n)}function _6(){return J.ready()}function yD(n,t,e=1){return J.registerBackend(n,t,e)}function R6(){return J.backend}const Fc=4;async function WI(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const l=r[o],c=Array.isArray(n)?n[o].tensor:n[l];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${c.dtype}`);const h={name:l,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const d=new Promise(async p=>{const m=await c.bytes(),y=m.reduce((w,S)=>w+S.length,0)+Fc*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const S=m[w],T=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(T,x),x+=Fc,b.set(S,x),x+=S.length}p(b)});s.push(d)}else s.push(c.data());t!=null&&(h.group=t),e.push(h)}const i=await Promise.all(s);return{data:F6(i),specs:e}}function D6(n,t){const e=new Yo(n),s={};let r=0;for(const i of t){const o=O6(i,(l,c)=>e.slice(r+l,r+c));s[i.name]=M6(i,e.slice(r,r+o)),r+=o}return s}function O6(n,t){const e=ft(n.shape);let s;if("quantization"in n){const r=n.quantization;s=Rm[r.dtype]}else if(n.dtype==="string"){let r=0;for(let i=0;i<e;i++)r+=Fc+new Uint32Array(t(r,r+Fc))[0];return r}else s=Rm[n.dtype];return e*s}function M6(n,t){const e=n.name,s=n.dtype,r=n.shape,i=ft(r);let o,l=0;if("quantization"in n){const c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=Rm[c.dtype],d=c.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){o=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=m*c.scale+c.min}}else if(c.dtype==="float16")o=H6()(d);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(s==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);o=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=Math.round(m*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);l+=i*h}else if(s==="string"){const c=ft(n.shape);o=[];for(let h=0;h<c;h++){const d=new Uint32Array(t.slice(l,l+Fc))[0];l+=Fc;const p=new Uint8Array(t.slice(l,l+d));o.push(p),l+=d}}else{const c=Rm[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);const h=new Float32Array(o.length/2),d=new Float32Array(o.length/2);for(let b=0;b<h.length;b++)h[b]=o[b*2],d[b]=o[b*2+1];const p=Ch(h,r,"float32"),m=Ch(d,r,"float32"),y=Za(p,m);return p.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);l+=i*c}return Ch(o,r,s)}function F6(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(i=>{s.set(new Uint8Array(i.buffer),r),r+=i.byteLength}),s.buffer}const q1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function HI(n){return q1?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function L6(n){if(q1)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function P6(n){if(q1){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function z6(n){return Yo.join(n)}function B6(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function V6(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function U6(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),V6(n,e,s)}function K1(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:HI(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:HI(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Yo(n.weightData).byteLength}}function qI(n){const t=[];for(const e of n)t.push(...e.weights);return t}function j6(){const n=e=>{let s=e<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function G6(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function W6(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function H6(){const n=j6(),t=G6(),e=W6();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const l=s[o],c=n[e[l>>10]+(l&1023)]+t[l>>10];i[o]=c}return new Float32Array(r)}}class Nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Nn.instance==null&&(Nn.instance=new Nn),Nn.instance}static registerSaveRouter(t){Nn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Nn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Nn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Nn.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return(e==="load"?Nn.getInstance().loadRouters:Nn.getInstance().saveRouters).forEach(o=>{const l=o(t,s);l!==null&&r.push(l)}),r}}const q6=n=>Nn.getSaveHandlers(n),K6=(n,t)=>Nn.getLoadHandlers(n,t);const Vv="tensorflowjs",Uv=1,Va="models_store",Ro="model_info_store";function bD(){if(!lt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function jv(n){const t=n.result;t.createObjectStore(Va,{keyPath:"modelPath"}),t.createObjectStore(Ro,{keyPath:"modelPath"})}class Ja{constructor(t){if(this.indexedDB=bD(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,r)=>{const i=this.indexedDB.open(Vv,Uv);i.onupgradeneeded=()=>jv(i),i.onsuccess=()=>{const o=i.result;if(e==null){const l=o.transaction(Va,"readonly"),h=l.objectStore(Va).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(o.close(),r(h.error)),l.oncomplete=()=>o.close()}else{e.weightData=Yo.join(e.weightData);const l=K1(e),c=o.transaction(Ro,"readwrite");let h=c.objectStore(Ro),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(m){return r(m)}let p;d.onsuccess=()=>{p=o.transaction(Va,"readwrite");const m=p.objectStore(Va);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:l})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:l}),y.onerror=b=>{h=c.objectStore(Ro);const x=h.delete(this.modelPath);x.onsuccess=()=>(o.close(),r(y.error)),x.onerror=w=>(o.close(),r(y.error))}},d.onerror=m=>(o.close(),r(d.error)),c.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Ja.URL_SCHEME="indexeddb://";const xD=n=>lt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ja.URL_SCHEME)?X6(n.slice(Ja.URL_SCHEME.length)):null;Nn.registerSaveRouter(xD);Nn.registerLoadRouter(xD);function X6(n){return new Ja(n)}function Y6(n){return n.startsWith(Ja.URL_SCHEME)?n.slice(Ja.URL_SCHEME.length):n}class Z6{constructor(){this.indexedDB=bD()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(Vv,Uv);s.onupgradeneeded=()=>jv(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Ro,"readonly"),l=i.objectStore(Ro).getAll();l.onsuccess=()=>{const c={};for(const h of l.result)c[h.modelPath]=h.modelArtifactsInfo;t(c)},l.onerror=c=>(r.close(),e(l.error)),i.oncomplete=()=>r.close()},s.onerror=r=>e(s.error)})}async removeModel(t){return t=Y6(t),new Promise((e,s)=>{const r=this.indexedDB.open(Vv,Uv);r.onupgradeneeded=()=>jv(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Ro,"readwrite"),l=o.objectStore(Ro),c=l.get(t);let h;c.onsuccess=()=>{if(c.result==null)return i.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),p=()=>{h=i.transaction(Va,"readwrite");const y=h.objectStore(Va).delete(t);y.onsuccess=()=>e(c.result.modelArtifactsInfo),y.onerror=b=>s(c.error)};d.onsuccess=p,d.onerror=m=>(p(),i.close(),s(c.error))}},c.onerror=d=>(i.close(),s(c.error)),o.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}const Gi="/",bc="tensorflowjs_models",vD="info",J6="model_topology",Q6="weight_specs",tq="weight_data",eq="model_metadata";function wD(n){return{info:[bc,n,vD].join(Gi),topology:[bc,n,J6].join(Gi),weightSpecs:[bc,n,Q6].join(Gi),weightData:[bc,n,tq].join(Gi),modelMetadata:[bc,n,eq].join(Gi)}}function SD(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function nq(n){const t=n.split(Gi);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Gi)}function sq(n){return n.startsWith(Qa.URL_SCHEME)?n.slice(Qa.URL_SCHEME.length):n}class Qa{constructor(t){if(!lt().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=wD(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=K1(t),i=Yo.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,L6(i));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw SD(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const l=JSON.parse(i);e.format=l.format,e.generatedBy=l.generatedBy,e.convertedBy=l.convertedBy,l.signature!=null&&(e.signature=l.signature),l.userDefinedMetadata!=null&&(e.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(e.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(e.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(e.trainingConfig=l.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=P6(o),e}}Qa.URL_SCHEME="localstorage://";const CD=n=>lt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Qa.URL_SCHEME)?rq(n.slice(Qa.URL_SCHEME.length)):null;Nn.registerSaveRouter(CD);Nn.registerLoadRouter(CD);function rq(n){return new Qa(n)}class iq{constructor(){L(lt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),L(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=bc+Gi,s=Gi+vD;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(e)&&i.endsWith(s)){const o=nq(i);t[o]=JSON.parse(this.LS.getItem(i))}}return t}async removeModel(t){t=sq(t);const e=wD(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return SD(e),s}}const KI="://";class ii{constructor(){this.managers={}}static getInstance(){return ii.instance==null&&(ii.instance=new ii),ii.instance}static registerManager(t,e){L(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(KI)&&(t=t.slice(0,t.indexOf(KI))),L(t.length>0,()=>"scheme must not be an empty string.");const s=ii.getInstance();L(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=ii.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(ii.getInstance().managers)}}class oq{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!lt().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return nD(t)}}if(lt().get("IS_BROWSER")){lt().setPlatform("browser",new oq);try{ii.registerManager(Qa.URL_SCHEME,new iq)}catch{}try{ii.registerManager(Ja.URL_SCHEME,new Z6)}catch{}}const aq={importFetch:()=>require("node-fetch")};let Rx;class lq{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return lt().global.fetch!=null?lt().global.fetch(t,e):(Rx==null&&(Rx=aq.importFetch()),Rx(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}lt().get("IS_NODE")&&!lt().get("IS_BROWSER")&&lt().setPlatform("node",new lq);function te(n,t="float32",e){return t=t||"float32",Qi(n),new Pn(n,t,e)}function cq(n,t){const e=V(n,"x","cast");if(!G5(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},r={dtype:t};return J.runKernel(cd,s,r)}const Et=nt({cast_:cq});function uq(n){const e={x:V(n,"x","clone","string_or_numeric")};return J.runKernel(Sd,e)}const Ha=nt({clone_:uq});function hq(n,t=!1){console.log(n.toString(t))}dD();const dq={buffer:te,cast:Et,clone:Ha,print:hq};S6(dq);function fq(n,t){let e=V(n,"a","add"),s=V(t,"b","add");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(Yc,r)}const wt=nt({add_:fq});function pq(n,t){let e=V(n,"a","floorDiv"),s=V(t,"b","floorDiv");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(vd,r)}const TD=nt({floorDiv_:pq});function mq(n,t){let e=V(n,"a","div"),s=V(t,"b","div");if([e,s]=rn(e,s),e.dtype==="int32"&&s.dtype==="int32")return TD(e,s);const r={a:e,b:s},i={};return J.runKernel(pd,r,i)}const Lt=nt({div_:mq});function gq(n,t){let e=V(n,"a","mul"),s=V(t,"b","mul");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(_d,r)}const Y=nt({mul_:gq});function yq(n){const t=V(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return J.runKernel(bg,e)}else{const e={x:t};return J.runKernel(hg,e)}}const is=nt({abs_:yq});function bq(n){const e={x:V(n,"x","acos")};return J.runKernel(nd,e)}const xq=nt({acos_:bq});function vq(n){const e={x:V(n,"x","acosh")};return J.runKernel(sd,e)}const wq=nt({acosh_:vq});function Sq(n,t=null,e=!1){const r={x:V(n,"x","all","bool")},i={axis:t,keepDims:e};return J.runKernel(o1,r,i)}const kD=nt({all_:Sq});function Cq(n,t=null,e=!1){const r={x:V(n,"x","any","bool")},i={axis:t,keepDims:e};return J.runKernel(a1,r,i)}const Gv=nt({any_:Cq});function Tq(n,t=0){const s={x:V(n,"x","argMax")},r={axis:t};return J.runKernel(dg,s,r)}const Lh=nt({argMax_:Tq});function kq(n,t=0){const s={x:V(n,"x","argMin")},r={axis:t};return J.runKernel(fg,s,r)}const $q=nt({argMin_:kq});function Eq(n){const e={x:V(n,"x","asin")};return J.runKernel(rd,e)}const Iq=nt({asin_:Eq});function Nq(n){const e={x:V(n,"x","asinh")};return J.runKernel(id,e)}const Aq=nt({asinh_:Nq});function _q(n){const e={x:V(n,"x","atan")};return J.runKernel(od,e)}const Rq=nt({atan_:_q});function Dq(n,t){let e=V(n,"a","atan2"),s=V(t,"b","atan2");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(ld,r)}const Oq=nt({atan2_:Dq});function Mq(n){const e={x:V(n,"x","atanh")};return J.runKernel(ad,e)}const Fq=nt({atanh_:Mq});function Qd(n,t,e,s,r="NHWC",i){const o=n[3],l=[...t,o],c=eo(r);return zn(n,l,e,i,s,null,null,c)}function Er(n,t,e,s,r,i,o="channelsLast"){const[l,c]=Ph(t);let h;if(o==="channelsLast")h=[l,c,n[3],n[3]];else if(o==="channelsFirst")h=[l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return zn(n,h,e,s,r,i,!1,o)}function to(n,t,e,s,r,i,o="NDHWC"){const[l,c,h]=Wv(t);let d,p;if(o==="NDHWC")p="channelsLast",d=[l,c,h,n[4],n[4]];else if(o==="NCDHW")p="channelsFirst",d=[l,c,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Zo(n,d,e,s,r,!1,p,i)}function zn(n,t,e,s,r,i,o=!1,l="channelsLast"){let[c,h,d,p]=[-1,-1,-1,-1];if(l==="channelsLast")[c,h,d,p]=n;else if(l==="channelsFirst")[c,p,h,d]=n;else throw new Error(`Unknown dataFormat ${l}`);const[m,y,,b]=t,[x,w]=Ph(e),[S,T]=Ph(s),k=Nc(m,S),$=Nc(y,T),{padInfo:E,outHeight:N,outWidth:_}=zq(r,h,d,x,w,k,$,i,l),R=o?b*p:b;let D;return l==="channelsFirst"?D=[c,R,N,_]:l==="channelsLast"&&(D=[c,N,_,R]),{batchSize:c,dataFormat:l,inHeight:h,inWidth:d,inChannels:p,outHeight:N,outWidth:_,outChannels:R,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:k,effectiveFilterWidth:$,dilationHeight:S,dilationWidth:T,inShape:n,outShape:D,filterShape:t}}function Zo(n,t,e,s,r,i=!1,o="channelsLast",l){let[c,h,d,p,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[c,h,d,p,m]=n;else if(o==="channelsFirst")[c,m,h,d,p]=n;else throw new Error(`Unknown dataFormat ${o}`);const[y,b,x,,w]=t,[S,T,k]=Wv(e),[$,E,N]=Wv(s),_=Nc(y,$),R=Nc(b,E),D=Nc(x,N),{padInfo:M,outDepth:A,outHeight:B,outWidth:H}=Bq(r,h,d,p,S,T,k,_,R,D,l),W=i?w*m:w;let X;return o==="channelsFirst"?X=[c,W,A,B,H]:o==="channelsLast"&&(X=[c,A,B,H,W]),{batchSize:c,dataFormat:o,inDepth:h,inHeight:d,inWidth:p,inChannels:m,outDepth:A,outHeight:B,outWidth:H,outChannels:W,padInfo:M,strideDepth:S,strideHeight:T,strideWidth:k,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:_,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:$,dilationHeight:E,dilationWidth:N,inShape:n,outShape:X,filterShape:t}}function Lq(n,t,e,s,r){s==null&&(s=X1(n,t,e));const i=n[0],o=n[1],l=zh((i-t+2*s)/e+1,r),c=zh((o-t+2*s)/e+1,r);return[l,c]}function Pq(n,t,e,s,r,i){r==null&&(r=X1(n,t[0],s[0]));const o=[0,0,0,e];for(let l=0;l<3;l++)n[l]+2*r>=t[l]&&(o[l]=zh((n[l]-t[l]+2*r)/s[l]+1,i));return o}function X1(n,t,e,s=1){const r=Nc(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function Ph(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Wv(n){return typeof n=="number"?[n,n,n]:n}function Nc(n,t){return t<=1?n:n+(n-1)*(t-1)}function zq(n,t,e,s,r,i,o,l,c){let h,d,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=Lq([t,e],i,s,n,l);d=y[0],p=y[1]}else if(n==="same"){d=Math.ceil(t/s),p=Math.ceil(e/r);const m=Math.max(0,(d-1)*s+i-t),y=Math.max(0,(p-1)*r+o-e),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),S=y-w;h={top:b,bottom:x,left:w,right:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-i+1)/s),p=Math.ceil((e-o+1)/r);else if(typeof n=="object"){const m=c==="channelsLast"?n[1][0]:n[2][0],y=c==="channelsLast"?n[1][1]:n[2][1],b=c==="channelsLast"?n[2][0]:n[3][0],x=c==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=zh((t-i+m+y)/s+1,l),p=zh((e-o+b+x)/r+1,l)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:p}}function Bq(n,t,e,s,r,i,o,l,c,h,d){let p,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=Pq([t,e,s,1],[l,c,h],1,[r,i,o],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(t/r),y=Math.ceil(e/i),b=Math.ceil(s/o);const x=(m-1)*r+l-t,w=(y-1)*i+c-e,S=(b-1)*o+h-s,T=Math.floor(x/2),k=x-T,$=Math.floor(w/2),E=w-$,N=Math.floor(S/2),_=S-N;p={top:$,bottom:E,left:N,right:_,front:T,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:y,outWidth:b}}function zh(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function tl(n){const[t,e,s]=Ph(n);return t===1&&e===1&&s===1}function Qn(n,t){return tl(n)||tl(t)}function el(n){return Ph(n).every(t=>t>0)}function eo(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Ts(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")L(Oc(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{L(Oc(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function Vq(n,t){const s={x:V(n,"x","reshape","string_or_numeric")},r={shape:t};return J.runKernel(Jg,s,r)}const et=nt({reshape_:Vq});function Uq(n,t,e,s,r){const i=V(n,"x","avgPool","float32"),o=1;L(Qn(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let l=i,c=!1;i.rank===3&&(c=!0,l=et(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),Ts("avgPool",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r};let p=J.runKernel(pg,h,d);return p=Et(p,i.dtype),c?et(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Y1=nt({avgPool_:Uq});function jq(n,t,e,s,r,i="NDHWC"){const o=V(n,"x","avgPool3d","float32");let l=o,c=!1;o.rank===4&&(c=!0,l=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),L(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),L(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),Ts("avgPool3d",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i};let p=J.runKernel(mg,h,d);return p=Et(p,l.dtype),c?et(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Gq=nt({avgPool3d_:jq});function Wq(n,t=0){L(n.length>=1,()=>"Pass at least one tensor to concat");const e=gD(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),e.length===1)return Ha(e[0]);const s=e,r={axis:t};return J.runKernel(xg,s,r)}const ws=nt({concat_:Wq});function Hq(n,t,e=!1,s=!1){let r=V(n,"a","matMul"),i=V(t,"b","matMul");[r,i]=rn(r,i);const o={a:r,b:i},l={transposeA:e,transposeB:s};return J.runKernel(gg,o,l)}const xe=nt({matMul_:Hq});function qq(n){const e={x:V(n,"x","sigmoid","float32")};return J.runKernel(Ud,e)}const Zc=nt({sigmoid_:qq});function Kq(n,t,e){const s=V(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:e};return J.runKernel(s0,r,i)}const Fe=nt({slice_:Kq});function Xq(n){const e={x:V(n,"x","tanh","float32")};return J.runKernel(Kd,e)}const d0=nt({tanh_:Xq});function Yq(n,t,e){const s=V(n,"x","batchToSpaceND"),r=t.reduce((l,c)=>l*c);L(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),L(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),L(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const i={x:s},o={blockShape:t,crops:e};return J.runKernel(yg,i,o)}const Z1=nt({batchToSpaceND_:Yq});function Zq(n){let t;return n.rank===0||n.rank===1?t=et(n,[1,1,1,n.size]):n.rank===2?t=et(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=et(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function Jq(n,t,e,s,r,i){i==null&&(i=.001);const o=V(n,"x","batchNorm"),l=V(t,"mean","batchNorm"),c=V(e,"variance","batchNorm");let h;r!=null&&(h=V(r,"scale","batchNorm"));let d;s!=null&&(d=V(s,"offset","batchNorm")),L(l.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(h==null||l.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:Zq(o),scale:h,offset:d,mean:l,variance:c},y={varianceEpsilon:i},b=J.runKernel(Ig,m,y);return et(b,o.shape)}const f0=nt({batchNorm_:Jq});function Qq(n,t,e,s,r,i){const o=V(n,"x","batchNorm"),l=V(t,"mean","batchNorm"),c=V(e,"variance","batchNorm");let h;r!=null&&(h=V(r,"scale","batchNorm"));let d;return s!=null&&(d=V(s,"offset","batchNorm")),L(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),L(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),L(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),f0(o,l,c,d,h,i)}const t8=nt({batchNorm2d_:Qq});function e8(n,t,e,s,r,i){const o=V(n,"x","batchNorm"),l=V(t,"mean","batchNorm"),c=V(e,"variance","batchNorm");let h;r!=null&&(h=V(r,"scale","batchNorm"));let d;return s!=null&&(d=V(s,"offset","batchNorm")),L(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),L(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),L(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),f0(o,l,c,d,h,i)}const n8=nt({batchNorm3d_:e8});function s8(n,t,e,s,r,i){const o=V(n,"x","batchNorm"),l=V(t,"mean","batchNorm"),c=V(e,"variance","batchNorm");let h;r!=null&&(h=V(r,"scale","batchNorm"));let d;return s!=null&&(d=V(s,"offset","batchNorm")),L(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),L(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),L(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&L(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&L(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),f0(o,l,c,d,h,i)}const r8=nt({batchNorm4d_:s8});function i8(n,t,e){const s=V(n,"x","bincount"),r=V(t,"weights","bincount");L(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),L(e>=0,()=>`size must be non-negative, but got ${e}.`),L(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:e};return J.runKernel(u1,i,o)}const o8=nt({bincount_:i8});function a8(n,t){let e=V(n,"broadcastTo","x");const s=e.shape;if(Qi(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const h=e.shape.slice();for(;h.length<t.length;)h.unshift(1);e=et(e,h)}const r=e.shape,i=Array.from(t);for(let h=t.length-1;h>=0;h--)if(r[h]===t[h])i[h]=1;else if(e.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(i.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Ha(e);const l={x:e},c={reps:i};return J.runKernel(Xd,l,c)}const Th=nt({broadcastTo_:a8});function l8(n){const e={x:V(n,"x","ceil","float32")};return J.runKernel(ud,e)}const c8=nt({ceil_:l8});function p0(n,t,e){Qi(n),e=e||Kc(t);const s={shape:n,value:t,dtype:e};return J.runKernel(k1,{},s)}function u8(n,t,e){const s=V(n,"x","clipByValue");if(L(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return p0(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:e};return J.runKernel(hd,r,i)}const nr=nt({clipByValue_:u8});function h8(n){return ws(n,0)}const d8=nt({concat1d_:h8});function f8(n,t){return ws(n,t)}const p8=nt({concat2d_:f8});function m8(n,t){return ws(n,t)}const g8=nt({concat3d_:m8});function y8(n,t){return ws(n,t)}const b8=nt({concat4d_:y8});function x8(n,t,e,s,r="NHWC",i=[1,1],o){const l=V(n,"x","conv2d","float32"),c=V(t,"filter","conv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),L(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Ts("conv2d",s,o);const p=r==="NHWC"?h.shape[3]:h.shape[1];L(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),L(Qn(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),L(el(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),L(el(e),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:c},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=J.runKernel(vg,m,y);return d?et(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const nl=nt({conv2d_:x8});function v8(n,t,e,s,r="NWC",i=1,o){const l=V(n,"x","conv1d"),c=V(t,"filter","conv1d");let h=l,d=!1;l.rank===2&&(d=!0,h=et(l,[1,l.shape[0],l.shape[1]])),L(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),L(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Ts("conv1d",s,o),L(h.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${c.shape[1]}.`),L(Qn(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),L(el(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),L(el(e),()=>"Error in conv1D: Stride should be larger than 0."),L(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const p=et(c,[1,c.shape[0],c.shape[1],c.shape[2]]),m=et(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=nl(m,p,[1,e],s,"NHWC",[1,i],o);return d?et(w,[w.shape[2],w.shape[3]]):et(w,[w.shape[0],w.shape[2],w.shape[3]])}const $D=nt({conv1d_:v8});function w8(n,t,e,s,r,i="NHWC",o){L(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let l=n,c=t,h=!1;t.rank===3&&(h=!0,c=et(t,[1,t.shape[0],t.shape[1],t.shape[2]]),l=[1,n[0],n[1],n[2]]),L(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),L(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),L(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const d=i==="NHWC"?l[3]:l[1],p=i==="NHWC"?c.shape[3]:c.shape[1];L(d===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${e.shape[2]}.`),L(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Ts("conv2dDerInput",r,o);const m={dy:c,filter:e},y={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:l},b=J.runKernel(wg,m,y);return h?et(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const J1=nt({conv2DBackpropInput_:w8});function S8(n,t,e,s,r,i){const o=V(n,"x","conv2dTranspose"),l=V(t,"filter","conv2dTranspose");return J1(e,o,l,s,r,"NHWC",i)}const ED=nt({conv2dTranspose_:S8});function C8(n,t,e,s,r="NDHWC",i=[1,1,1]){const o=V(n,"x","conv3d"),l=V(t,"filter","conv3d");let c=o,h=!1;o.rank===4&&(h=!0,c=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),L(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),L(c.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${l.shape[3]}.`),L(Qn(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),L(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),L(el(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),L(el(e),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:e,pad:s,dataFormat:r,dilations:i},m=J.runKernel(Sg,d,p);return h?et(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const T8=nt({conv3d_:C8});function k8(n,t,e,s,r){L(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,l=!1;t.rank===4&&(l=!0,o=et(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const c=i[4],h=o.shape[4];L(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),L(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),L(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),L(c===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[3]}.`),L(h===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[4]}.`);const d={dy:o,filter:e},p={pad:r,strides:s,inputShape:i},m=J.runKernel(m1,d,p);return l?et(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const ID=nt({conv3DBackpropInput_:k8});function $8(n,t,e,s,r){const i=V(n,"x","conv3dTranspose"),o=V(t,"filter","conv3dTranspose");return ID(e,i,o,s,r)}const E8=nt({conv3dTranspose_:$8});function I8(n){const e={x:V(n,"x","cos","float32")};return J.runKernel(dd,e)}const Q1=nt({cos_:I8});function N8(n){const e={x:V(n,"x","cosh","float32")};return J.runKernel(fd,e)}const ND=nt({cosh_:N8});function A8(n,t=0,e=!1,s=!1){const i={x:V(n,"x","cumprod")},o={axis:t,exclusive:e,reverse:s};return J.runKernel(g1,i,o)}const Hv=nt({cumprod_:A8});function _8(n,t=0,e=!1,s=!1){const i={x:V(n,"x","cumsum")},o={axis:t,exclusive:e,reverse:s};return J.runKernel(Cg,i,o)}const AD=nt({cumsum_:_8});function R8(n,t,e,s=!1){const r=V(n,"x","denseBincount"),i=V(t,"weights","denseBincount");L(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),L(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),L(e>=0,()=>`size must be non-negative, but got ${e}.`),L(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},l={size:e,binaryOutput:s};return J.runKernel(b1,o,l)}const XI=nt({denseBincount_:R8});function D8(n,t,e="NHWC"){const s=V(n,"x","depthToSpace","float32"),r=e==="NHWC"?s.shape[1]:s.shape[2],i=e==="NHWC"?s.shape[2]:s.shape[3],o=e==="NHWC"?s.shape[3]:s.shape[1];L(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),L(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),L(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t} for depthToSpace with input shape
        ${s.shape}`),L(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const l={x:s},c={blockSize:t,dataFormat:e};return J.runKernel(x1,l,c)}const O8=nt({depthToSpace_:D8});function M8(n,t,e,s,r="NHWC",i=[1,1],o){const l=V(n,"x","depthwiseConv2d","float32"),c=V(t,"filter","depthwiseConv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),L(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const p=r==="NHWC"?h.shape[3]:h.shape[1];L(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),Ts("depthwiseConv2d",s,o);const m={x:h,filter:c},y={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},b=J.runKernel(Tg,m,y);return d?et(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const tS=nt({depthwiseConv2d_:M8});function F8(n,t,e,s,r=[1,1],i="NHWC"){const o=V(n,"x","dilation2d"),l=V(t,"filter","dilation2d");L(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),L(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),L(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let c=o,h=!1;o.rank===3&&(c=et(o,[1,o.shape[0],o.shape[1],o.shape[2]]),h=!0),L(c.shape[3]===l.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${l.shape[2]}`);const d={x:c,filter:l},p={strides:e,pad:s,dilations:r},m=J.runKernel(kg,d,p);return h?et(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const L8=nt({dilation2d_:F8});function Lc(n,t){const e=n.length,s=[];for(let r=0;r<e;r++){const i=e-1-r,o=n[i]||1;(t[t.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function Tn(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],i=t.length-s-1,o=t[i];(r==null||r===1&&o>1)&&e.unshift(i)}return e}function qt(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let r=0;r<e;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=t[t.length-r-1];if(o==null&&(o=1),i===1)s[e-r-1]=o;else if(o===1)s[e-r-1]=i;else if(i!==o){const l=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(l)}else s[e-r-1]=i}return s}function P8(n,t){let e=V(n,"a","equal","string_or_numeric"),s=V(t,"b","equal","string_or_numeric");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel($g,r)}const bi=nt({equal_:P8});function z8(n,t,e){const s=V(t,"a","where"),r=V(e,"b","where"),i=V(n,"condition","where","bool"),o=qt(qt(i.shape,s.shape),r.shape),l=Th(i,o),c=Th(s,o),h=Th(r,o),d={condition:l,t:c,e:h};return J.runKernel(n0,d)}const cs=nt({where_:z8});function B8(n){const e={x:V(n,"x","zerosLike")};return J.runKernel(u0,e)}const de=nt({zerosLike_:B8});function V8(n,t){let e=V(n,"a","div"),s=V(t,"b","div");[e,s]=rn(e,s);const r=Lt(e,s),i=de(r),o=bi(s,i);return cs(o,i,r)}const U8=nt({divNoNan_:V8});function j8(n,t){const e=V(n,"t1","dot"),s=V(t,"t2","dot");L((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const r=e.rank===1?e.size:e.shape[1],i=s.rank===1?s.size:s.shape[0];if(L(r===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`),e.rank===1&&s.rank===1){const o=et(e,[1,-1]),l=et(s,[-1,1]),c=xe(o,l);return et(c,[])}else if(e.rank===1&&s.rank===2){const o=et(e,[1,-1]),l=et(s,[s.shape[0],s.shape[1]]),c=xe(o,l);return et(c,[c.size])}else if(e.rank===2&&s.rank===1){const o=et(s,[-1,1]),l=xe(e,o);return et(l,[l.size])}else{const o=et(s,[s.shape[0],s.shape[1]]);return xe(e,o)}}const G8=nt({dot_:j8});function W8(n,...t){const e=t.map((r,i)=>V(r,`tensors${i}`,"einsum")),s={equation:n};return J.runKernel(S1,e,s)}const ih=nt({einsum_:W8});function H8(n){const e={x:V(n,"x","elu","float32")};return J.runKernel(md,e)}const m0=nt({elu_:H8});function q8(n){let t=V(n,"x","erf");L(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Et(t,"float32"));const e={x:t};return J.runKernel(gd,e)}const _D=nt({erf_:q8});function eS(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function RD(n,t,e){const s=n.length+t.length,r=[];let i=0,o=0;for(let l=0;l<s;l++)e.indexOf(l)===-1?r.push(n[i++]):r.push(t[o++]);return r}function Dn(n,t){const e=[],s=n.length;for(let i=0;i<s;i++)t.indexOf(i)===-1&&e.push(n[i]);const r=t.map(i=>n[i]);return[e,r]}function dn(n,t){const e=t.map(s=>1);return RD(n,e,t)}function Bn(n,t,e){L(eS(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Xe(n,t){if(eS(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function Jo(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function on(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}function K8(n,t=null,e=!1){const r={x:V(n,"x","max")},i={reductionIndices:t,keepDims:e};return J.runKernel(Pg,r,i)}const qr=nt({max_:K8});function X8(n,t=null,e=!1){const r={x:V(n,"x","min")},i={axis:t,keepDims:e};return J.runKernel(Ug,r,i)}const Dm=nt({min_:X8});function Y8(n,t){let e=V(n,"base","pow"),s=V(t,"exp","pow");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(Rd,r)}const sl=nt({pow_:Y8});function ve(n,t){if((kr(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&kr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Jd(n,[],[],t)}function Z8(n){const e={x:V(n,"x","sqrt","float32")};return J.runKernel(Gd,e)}const Jn=nt({sqrt_:Z8});function J8(n){const t=V(n,"x","square"),e={};return J.runKernel("Square",{x:t},e)}const ze=nt({square_:J8});function Q8(n,t=null,e=!1){let s=V(n,"x","sum");s.dtype==="bool"&&(s=Et(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return J.runKernel(r0,r,i)}const Mt=nt({sum_:Q8});function tK(n,t="euclidean",e=null,s=!1){n=V(n,"x","norm");const r=DD(n,t,e);let i=r.shape;if(s){const o=ee(e,n.shape);i=dn(r.shape,o)}return et(r,i)}function DD(n,t,e=null){if(n.rank===0)return is(n);if(n.rank!==1&&e===null)return DD(et(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return Mt(is(n),e);if(t===1/0)return qr(is(n),e);if(t===-1/0)return Dm(is(n),e);if(t==="euclidean"||t===2)return Jn(Mt(sl(is(n),ve(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return qr(Mt(is(n),e[0]),e[1]-1);if(t===1/0)return qr(Mt(is(n),e[1]),e[0]);if(t===-1/0)return Dm(Mt(is(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Jn(Mt(ze(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const g0=nt({norm_:tK});function eK(n,t=null,e=!1){return g0(n,"euclidean",t,e)}const nK=nt({euclideanNorm_:eK});function sK(n){const e={x:V(n,"x","exp")};return J.runKernel(yd,e)}const xi=nt({exp_:sK});function rK(n,t=0){const e=V(n,"x","expandDims","string_or_numeric");L(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},r={dim:t};return J.runKernel(Eg,s,r)}const bs=nt({expandDims_:rK});function iK(n){const e={x:V(n,"x","expm1")};return J.runKernel(bd,e)}const oK=nt({expm1_:iK});function aK(n,t){const e=V(n,"x","tile","string_or_numeric");L(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},r={reps:t};return J.runKernel(Xd,s,r)}const Wr=nt({tile_:aK});function lK(n,t,e,s="float32"){t==null&&(t=n);const r=te([n,t],s),i=n<=t?n:t;for(let l=0;l<i;++l)r.set(1,l,l);const o=et(r.toTensor(),[n,t]);if(e==null)return o;if(e.length===1)return Wr(bs(o,0),[e[0],1,1]);if(e.length===2)return Wr(bs(bs(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return Wr(bs(bs(bs(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const OD=nt({eye_:lK});function cK(n){const e={x:V(n,"x","floor","float32")};return J.runKernel(xd,e)}const y0=nt({floor_:cK});function uK(n,t,e=0,s=0){const r=V(n,"x","gather"),i=V(t,"indices","gather","int32"),o={x:r,indices:i},l={axis:e,batchDims:s};return J.runKernel(Ng,o,l)}const nS=nt({gather_:uK});function hK(n,t){let e=V(n,"a","greater","string_or_numeric"),s=V(t,"b","greater","string_or_numeric");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Ag,r)}const sr=nt({greater_:hK});function dK(n,t){let e=V(n,"a","greaterEqual","string_or_numeric"),s=V(t,"b","greaterEqual","string_or_numeric");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(wd,r)}const hl=nt({greaterEqual_:dK});function fK(n){const e={input:V(n,"input","imag")};return J.runKernel(I1,e)}const sS=nt({imag_:fK});function pK(n){const e={x:V(n,"x","isFinite")};return J.runKernel(Cd,e)}const mK=nt({isFinite_:pK});function gK(n){const e={x:V(n,"x","isInf")};return J.runKernel(Td,e)}const yK=nt({isInf_:gK});function bK(n){const e={x:V(n,"x","isNaN")};return J.runKernel(kd,e)}const xK=nt({isNaN_:bK});function vK(n,t=.2){const s={x:V(n,"x","leakyRelu")},r={alpha:t};return J.runKernel(_g,s,r)}const rS=nt({leakyRelu_:vK});function wK(n,t){let e=V(n,"a","less","string_or_numeric"),s=V(t,"b","less","string_or_numeric");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Rg,r)}const Om=nt({less_:wK});function SK(n,t){let e=V(n,"a","lessEqual","string_or_numeric"),s=V(t,"b","lessEqual","string_or_numeric");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Dg,r)}const Jc=nt({lessEqual_:SK});function CK(n,t=5,e=1,s=1,r=.5){const i=V(n,"x","localResponseNormalization");L(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),L(Oc(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,l=!1;i.rank===3&&(l=!0,o=et(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c={x:o},h={depthRadius:t,bias:e,alpha:s,beta:r},d=J.runKernel(Lg,c,h);return l?et(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const TK=nt({localResponseNormalization_:CK});function kK(n){const e={x:V(n,"x","log","float32")};return J.runKernel($d,e)}const vi=nt({log_:kK});function $K(n){const e={x:V(n,"x","log1p")};return J.runKernel(Ed,e)}const MD=nt({log1p_:$K});function EK(n,t){L(_v(n),()=>"The f passed in variableGrads(f) must be a function"),L(t==null||Array.isArray(t)&&t.every(h=>h instanceof _m),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const h in J.registeredVariables)t.push(J.registeredVariables[h])}const s=e?t.filter(h=>!h.trainable):null,r=t.length;t=t.filter(h=>h.trainable),L(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const i=!0,{value:o,grads:l}=J.gradients(n,t,null,i);L(l.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),L(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const c={};return t.forEach((h,d)=>{l[d]!=null&&(c[h.name]=l[d])}),s?.forEach(h=>c[h.name]=null),{value:o,grads:c}}function Pc(n){return J.customGrad(n)}function IK(n){const e={x:V(n,"x","neg")};return J.runKernel(Gg,e)}const sn=nt({neg_:IK});function NK(n){const e={x:V(n,"x","softplus")};return J.runKernel(jd,e)}const tf=nt({softplus_:NK});function AK(n){const t=V(n,"x","logSigmoid");return Pc(s=>({value:sn(tf(sn(s))),gradFunc:o=>Y(o,Zc(sn(s)))}))(t)}const _K=nt({logSigmoid_:AK});function RK(n,t){let e=V(n,"a","sub"),s=V(t,"b","sub");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(Hd,r)}const Bt=nt({sub_:RK});function DK(n,t=-1){const e=V(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Pc((r,i)=>{const l=qr(r,t,!0),c=Bt(r,l),h=Bt(Et(c,"float32"),vi(Mt(xi(c),t,!0)));return i([h]),{value:h,gradFunc:(p,m)=>{const[y]=m,b=!0,x=xi(y);return Bt(p,Y(Mt(p,t,b),x))}}})(e)}const FD=nt({logSoftmax_:DK});function OK(n,t=null,e=!1){const s=V(n,"x","logSumExp"),r=ee(t,s.shape),i=qr(s,r,!0),o=Bt(s,i),l=xi(o),c=Mt(l,r),h=vi(c),d=wt(et(i,h.shape),h);if(e){const p=dn(d.shape,r);return et(d,p)}return d}const LD=nt({logSumExp_:OK});function MK(n,t){const e=V(n,"a","logicalAnd","bool"),s=V(t,"b","logicalAnd","bool");qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Og,r)}const Ki=nt({logicalAnd_:MK});function FK(n){const e={x:V(n,"x","logicalNot","bool")};return J.runKernel(Mg,e)}const iS=nt({logicalNot_:FK});function LK(n,t){const e=V(n,"a","logicalOr","bool"),s=V(t,"b","logicalOr","bool");qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Fg,r)}const PD=nt({logicalOr_:LK});function PK(n,t){const e=V(n,"a","logicalXor","bool"),s=V(t,"b","logicalXor","bool");return qt(e.shape,s.shape),Ki(PD(n,t),iS(Ki(n,t)))}const zK=nt({logicalXor_:PK});function BK(n,t,e,s,r){const i=V(n,"x","maxPool"),o=1;let l=i,c=!1;i.rank===3&&(c=!0,l=et(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),L(Qn(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),Ts("maxPool",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r},p=J.runKernel(zg,h,d);return c?et(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const oS=nt({maxPool_:BK});function VK(n,t=[1,1,1],e,s,r,i="NDHWC"){const o=V(n,"x","maxPool3d");let l=o,c=!1;o.rank===4&&(c=!0,l=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),L(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),L(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Ts("maxPool3d",s,r);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:i},p=J.runKernel(Bg,h,d);return c?et(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const UK=nt({maxPool3d_:VK});function jK(n,t){let e=V(n,"a","maximum"),s=V(t,"b","maximum");[e,s]=rn(e,s),e.dtype==="bool"&&(e=Et(e,"int32"),s=Et(s,"int32")),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Id,r)}const Qo=nt({maximum_:jK});function GK(n,t=null,e=!1){const r={x:V(n,"x","mean")},i={axis:t,keepDims:e};return J.runKernel(Vg,r,i)}const hn=nt({mean_:GK});function _n(n,t="float32"){if(Qi(n),t==="complex64"){const s=_n(n,"float32"),r=_n(n,"float32");return Za(s,r)}const e=Zn(ft(n),t);return J.makeTensor(e,n,t)}function ta(n,t="float32"){if(Qi(n),t==="complex64"){const s=ta(n,"float32"),r=_n(n,"float32");return Za(s,r)}const e=n1(ft(n),t);return J.makeTensor(e,n,t)}function WK(n,t){let e=V(n,"a","minimum"),s=V(t,"b","minimum");[e,s]=rn(e,s),e.dtype==="bool"&&(e=Et(e,"int32"),s=Et(s,"int32")),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Nd,r)}const Bh=nt({minimum_:WK});function HK(n,t,e){L(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=V(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");L(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=e==="reflect"?1:0;for(let l=0;l<s.rank;l++)L(t[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),L(t[l][0]>=0&&t[l][0]<=s.shape[l]-r&&t[l][1]>=0&&t[l][1]<=s.shape[l]-r,()=>`Padding in dimension ${l} cannot be greater than or equal to ${s.shape[l]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:t,mode:e},o={x:s};return J.runKernel(jg,o,i)}const qK=nt({mirrorPad_:HK});function KK(n,t){let e=V(n,"a","mod"),s=V(t,"b","mod");[e,s]=rn(e,s);const r={a:e,b:s};return J.runKernel(Ad,r)}const XK=nt({mod_:KK});function YK(n,t=null,e=!1){n=V(n,"x","moments");const s=ee(t,n.shape),r=hn(n,s,e);let i=r.shape;e||(i=dn(r.shape,s));const o=ze(Bt(Et(n,"float32"),et(r,i))),l=hn(o,s,e);return{mean:r,variance:l}}const aS=nt({moments_:YK});function ZK(n,t){let e=V(n,"a","notEqual","string_or_numeric"),s=V(t,"b","notEqual","string_or_numeric");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s};return J.runKernel(Wg,r)}const Mm=nt({notEqual_:ZK});function JK(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:V(n,"indices","oneHot","int32")},l={dtype:r,depth:t,onValue:e,offValue:s};return J.runKernel(qg,o,l)}const zD=nt({oneHot_:JK});function QK(n){const e={x:V(n,"x","onesLike")};return J.runKernel(Hg,e)}const $r=nt({onesLike_:QK});function tX(n,t,e=0){const s=V(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:e},i={x:s};return J.runKernel(Xg,i,r)}const lS=nt({pad_:tX});function eX(n,t,e){const s=V(n,"x","spaceToBatchND");L(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),L(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),L(s.shape.reduce((o,l,c)=>c>0&&c<=t.length?o&&(l+e[c-1][0]+e[c-1][1])%t[c-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},i={blockShape:t,paddings:e};return J.runKernel(i0,r,i)}const cS=nt({spaceToBatchND_:eX});function nX(n,t,e,s,r,i,o){r==null&&(r=[1,1]),i==null&&(i=1),s===0&&(s="valid");const l=V(n,"x","maxPool");let c=l,h=!1;l.rank===3&&(h=!0,c=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),L(Qn(i,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`);const d=Er(c.shape,t,i,r,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=rX([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const y=p[0]===1&&p[1]===1,[b,x]=sX([d.inHeight,d.inWidth],p,m),w=y?s:"valid",S=y?c:cS(c,p,b),k=(e==="avg"?()=>Y1(S,t,i,w,o):()=>oS(S,t,i,w,o))(),$=y?k:Z1(k,p,x);return h?et($,[$.shape[1],$.shape[2],$.shape[3]]):$}function sX(n,t,e){const s=e.map(d=>d[0]),r=e.map(d=>d[1]),i=n.concat(s,r),o=t.map((d,p)=>(d-i[p]%d)%d),l=r.map((d,p)=>d+o[p]),c=t.map((d,p)=>[s[p],l[p]]),h=t.map((d,p)=>[0,o[p]]);return[c,h]}function rX(n,t){const s=n.map((o,l)=>o+(o-1)*(t[l]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),i=s.map((o,l)=>o-r[l]);return s.map((o,l)=>[r[l],i[l]])}const iX=nt({pool_:nX});function oX(n,t){const e=V(n,"x","prelu"),s=V(t,"alpha","prelu"),r={x:e,alpha:s};return J.runKernel(Yg,r)}const uS=nt({prelu_:oX});function aX(n,t=null,e=!1){let s=V(n,"x","prod");s.dtype==="bool"&&(s=Et(s,"int32"));const r={x:s},i={axis:t,keepDims:e};return J.runKernel(Zg,r,i)}const lX=nt({prod_:aX});var um={exports:{}},cX=um.exports,YI;function uX(){return YI||(YI=1,(function(n){(function(t,e,s){function r(c){var h=this,d=l();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(c),h.s0<0&&(h.s0+=1),h.s1-=d(c),h.s1<0&&(h.s1+=1),h.s2-=d(c),h.s2<0&&(h.s2+=1),d=null}function i(c,h){return h.c=c.c,h.s0=c.s0,h.s1=c.s1,h.s2=c.s2,h}function o(c,h){var d=new r(c),p=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&i(p,d),m.state=function(){return i(d,{})}),m}function l(){var c=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){c+=d.charCodeAt(p);var m=.02519603282416938*c;c=m>>>0,m-=c,m*=c,c=m>>>0,m-=c,c+=m*4294967296}return(c>>>0)*23283064365386963e-26};return h}e&&e.exports?e.exports=o:this.alea=o})(cX,n)})(um)),um.exports}var hm={exports:{}},hX=hm.exports,ZI;function dX(){return ZI||(ZI=1,(function(n){(function(t,e,s){function r(l){var c=this,h="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xor128=o})(hX,n)})(hm)),hm.exports}var dm={exports:{}},fX=dm.exports,JI;function pX(){return JI||(JI=1,(function(n){(function(t,e,s){function r(l){var c=this,h="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,d==h.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xorwow=o})(fX,n)})(dm)),dm.exports}var fm={exports:{}},mX=fm.exports,QI;function gX(){return QI||(QI=1,(function(n){(function(t,e,s){function r(l){var c=this;c.next=function(){var d=c.x,p=c.i,m,y;return m=d[p],m^=m>>>7,y=m^m<<24,m=d[p+1&7],y^=m^m>>>10,m=d[p+3&7],y^=m^m>>>3,m=d[p+4&7],y^=m^m<<7,m=d[p+7&7],m=m^m<<13,y^=m^m<<9,d[p]=y,c.i=p+1&7,y};function h(d,p){var m,y=[];if(p===(p|0))y[0]=p;else for(p=""+p,m=0;m<p.length;++m)y[m&7]=y[m&7]<<15^p.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(c,l)}function i(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.x&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xorshift7=o})(mX,n)})(fm)),fm.exports}var pm={exports:{}},yX=pm.exports,tN;function bX(){return tN||(tN=1,(function(n){(function(t,e,s){function r(l){var c=this;c.next=function(){var d=c.w,p=c.X,m=c.i,y,b;return c.w=d=d+1640531527|0,b=p[m+34&127],y=p[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=p[m]=b^y,c.i=m,b+(d^d>>>16)|0};function h(d,p){var m,y,b,x,w,S=[],T=128;for(p===(p|0)?(y=p,p=null):(p=p+"\0",y=0,T=Math.max(T,p.length)),b=0,x=-32;x<T;++x)p&&(y^=p.charCodeAt((x+32)%p.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=S[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(S[(p&&p.length||0)&127]=-1),b=127,x=512;x>0;--x)y=S[b+34&127],m=S[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,S[b]=y^m;d.w=w,d.X=S,d.i=b}h(c,l)}function i(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.X&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.xor4096=o})(yX,n)})(pm)),pm.exports}var mm={exports:{}},xX=mm.exports,eN;function vX(){return eN||(eN=1,(function(n){(function(t,e,s){function r(l){var c=this,h="";c.next=function(){var p=c.b,m=c.c,y=c.d,b=c.a;return p=p<<25^p>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-p|0,c.b=p=p<<20^p>>>12^m,c.c=m=m-y|0,c.d=y<<16^m>>>16^b,c.a=b-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):h+=l;for(var d=0;d<h.length+20;d++)c.b^=h.charCodeAt(d)|0,c.next()}function i(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var h=new r(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&i(d,h),p.state=function(){return i(h,{})}),p}e&&e.exports?e.exports=o:this.tychei=o})(xX,n)})(mm)),mm.exports}var gm={exports:{}};const wX={},SX=Object.freeze(Object.defineProperty({__proto__:null,default:wX},Symbol.toStringTag,{value:"Module"})),CX=kB(SX);var TX=gm.exports,nN;function kX(){return nN||(nN=1,(function(n){(function(t,e,s){var r=256,i=6,o=52,l="random",c=s.pow(r,i),h=s.pow(2,o),d=h*2,p=r-1,m;function y($,E,N){var _=[];E=E==!0?{entropy:!0}:E||{};var R=S(w(E.entropy?[$,k(e)]:$??T(),3),_),D=new b(_),M=function(){for(var A=D.g(i),B=c,H=0;A<h;)A=(A+H)*r,B*=r,H=D.g(1);for(;A>=d;)A/=2,B/=2,H>>>=1;return(A+H)/B};return M.int32=function(){return D.g(4)|0},M.quick=function(){return D.g(4)/4294967296},M.double=M,S(k(D.S),e),(E.pass||N||function(A,B,H,W){return W&&(W.S&&x(W,D),A.state=function(){return x(D,{})}),H?(s[l]=A,B):A})(M,R,"global"in E?E.global:this==s,E.state)}function b($){var E,N=$.length,_=this,R=0,D=_.i=_.j=0,M=_.S=[];for(N||($=[N++]);R<r;)M[R]=R++;for(R=0;R<r;R++)M[R]=M[D=p&D+$[R%N]+(E=M[R])],M[D]=E;(_.g=function(A){for(var B,H=0,W=_.i,X=_.j,P=_.S;A--;)B=P[W=p&W+1],H=H*r+P[p&(P[W]=P[X=p&X+B])+(P[X]=B)];return _.i=W,_.j=X,H})(r)}function x($,E){return E.i=$.i,E.j=$.j,E.S=$.S.slice(),E}function w($,E){var N=[],_=typeof $,R;if(E&&_=="object")for(R in $)try{N.push(w($[R],E-1))}catch{}return N.length?N:_=="string"?$:$+"\0"}function S($,E){for(var N=$+"",_,R=0;R<N.length;)E[p&R]=p&(_^=E[p&R]*19)+N.charCodeAt(R++);return k(E)}function T(){try{var $;return m&&($=m.randomBytes)?$=$(r):($=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues($)),k($)}catch{var E=t.navigator,N=E&&E.plugins;return[+new Date,t,N,t.screen,k(e)]}}function k($){return String.fromCharCode.apply(0,$)}if(S(s.random(),e),n.exports){n.exports=y;try{m=CX}catch{}}else s["seed"+l]=y})(typeof self<"u"?self:TX,[],Math)})(gm)),gm.exports}var Dx,sN;function $X(){if(sN)return Dx;sN=1;var n=uX(),t=dX(),e=pX(),s=gX(),r=bX(),i=vX(),o=kX();return o.alea=n,o.xor128=t,o.xorwow=e,o.xorshift7=s,o.xor4096=r,o.tychei=i,Dx=o,Dx}var hS=$X();class BD{constructor(t,e,s,r,i){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=hS.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const l=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*l,e=this.mean+this.stdDev*i*l,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class EX{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=hS.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function IX(n,t=0,e=1,s,r){if(Qi(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const i=new BD(t,e,s,!1,r),o=te(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const NX=nt({randomNormal_:IX});function AX(n,t=0,e=1,s="float32",r){Qi(n);const i=te(n,s),o=new EX(t,e,null,r);for(let l=0;l<i.values.length;l++)i.values[l]=o.nextValue();return i.toTensor()}const ef=nt({randomUniform_:AX});function Vh(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:t,step:e,dtype:s};return J.runKernel(M1,{},r)}function _X(n){const e={input:V(n,"input","real")};return J.runKernel(F1,e)}const Fm=nt({real_:_X});function RX(n){const e={x:V(n,"x","reciprocal")};return J.runKernel(Dd,e)}const DX=nt({reciprocal_:RX});function OX(n){const e={x:V(n,"x","relu")};return J.runKernel(Od,e)}const dl=nt({relu_:OX});function MX(n){const e={x:V(n,"x","relu6")};return J.runKernel(Md,e)}const VD=nt({relu6_:MX});function FX(n,t){const s={x:V(n,"x","reverse")},r={dims:t};return J.runKernel(e0,s,r)}const rl=nt({reverse_:FX});function LX(n){const e={x:V(n,"x","round")};return J.runKernel(Fd,e)}const UD=nt({round_:LX});function PX(n){const e={x:V(n,"x","rsqrt","float32")};return J.runKernel(Ld,e)}const jD=nt({rsqrt_:PX});function zX(n){const e={x:V(n,"x","selu")};return J.runKernel(Pd,e)}const GD=nt({selu_:zX});function BX(n,t,e,s,r,i=[1,1],o="NHWC"){const l=V(n,"x","separableConv2d"),c=V(t,"depthwiseFilter","separableConv2d"),h=V(e,"pointwiseFilter","separableConv2d");let d=l,p=!1;if(l.rank===3&&(p=!0,d=et(l,[1,l.shape[0],l.shape[1],l.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");L(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),L(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),L(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),L(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),L(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=c.shape[2],y=c.shape[3];L(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=tS(d,c,s,r,o,i),w=nl(b,h,1,"valid",o);return p?et(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const WD=nt({separableConv2d_:BX});function VX(n){const e={x:V(n,"x","sign")};return J.runKernel(Vd,e)}const UX=nt({sign_:VX});function jX(n){const e={x:V(n,"x","sin","float32")};return J.runKernel(zd,e)}const HD=nt({sin_:jX});function GX(n){const e={x:V(n,"x","sinh")};return J.runKernel(Bd,e)}const qD=nt({sinh_:GX});function WX(n,t,e){const s=V(n,"x","slice1d");return L(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Fe(s,[t],[e])}const dS=nt({slice1d_:WX});function HX(n,t,e){const s=V(n,"x","slice2d");return L(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Fe(s,t,e)}const KD=nt({slice2d_:HX});function qX(n,t,e){const s=V(n,"x","slice3d");return L(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Fe(s,t,e)}const fS=nt({slice3d_:qX});function KX(n,t,e){const s=V(n,"x","slice4d");return L(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Fe(s,t,e)}const Lm=nt({slice4d_:KX});function XX(n,t=-1){const e=V(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},r={dim:t};return J.runKernel(a0,s,r)}const pS=nt({softmax_:XX});function YX(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return J.runKernel(T1,t)}const XD=nt({fft_:YX});function ZX(n){L(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return J.runKernel(E1,t)}const qv=nt({ifft_:ZX});function JX(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const r=et(n,[e,t]);s=qv(r)}else{const r=[e,2*(t-1)],i=et(Fm(n),[e,t]),o=et(sS(n),[e,t]),l=rl(Fe(i,[0,1],[e,t-2]),1),c=Y(rl(Fe(o,[0,1],[e,t-2]),1),ve(-1)),h=ws([i,l],1),d=ws([o,c],1),p=et(Za(h,d),[r[0],r[1]]);s=qv(p)}if(s=Fm(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=et(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const QX=nt({irfft_:JX});function t9(n,t,e=0){const r={x:V(n,"x","split")},i={numOrSizeSplits:t,axis:e};return J.runKernel(o0,r,i)}const er=nt({split_:t9});function e9(n,t){L(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let r;if(t!=null&&t<e){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=t,r=Fe(n,b,x),e=t}else if(t!=null&&t>e){const b=n.shape.map(x=>x);b[n.shape.length-1]=t-e,r=ws([n,_n(b)],n.shape.length-1),e=t}else r=n;const i=de(r),o=et(Za(r,i),[s,e]),l=XD(o),c=Math.floor(e/2)+1,h=Fm(l),d=sS(l),p=er(h,[c,e-c],h.shape.length-1),m=er(d,[c,e-c],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=c,et(Za(p[0],m[0]),y)}const n9=nt({rfft_:e9});function s9(n,t){let e=V(n,"a","squaredDifference"),s=V(t,"b","squaredDifference");[e,s]=rn(e,s),qt(e.shape,s.shape);const r={a:e,b:s},i={};return J.runKernel(Wd,r,i)}const r9=nt({squaredDifference_:s9});function i9(n,t){const e=V(n,"x","squeeze","string_or_numeric");return et(e,Ko(e.shape,t).newShape)}const nf=nt({squeeze_:i9});function o9(n,t=0){const e=gD(n,"tensors","stack","string_or_numeric");L(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&L(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,r={axis:t};return J.runKernel(Kg,s,r)}const Xi=nt({stack_:o9});function a9(n,t=0){const s={x:V(n,"x","step")},r={alpha:t};return J.runKernel(Yd,s,r)}const sf=nt({step_:a9});function l9(n,t,e,s,r=0,i=0,o=0,l=0,c=0){const d={x:V(n,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};return J.runKernel(V1,d,p)}const c9=nt({stridedSlice_:l9});function u9(n){const e={x:V(n,"x","tan","float32")};return J.runKernel(qd,e)}const h9=nt({tan_:u9});function Fs(n,t){e1(n);const e=Zd(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Jd(n,null,e,t)}function Ox(n,t,e){if(e1(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Zd(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Jd(n,t,s,e)}function d9(n,t,e){if(e1(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Zd(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Jd(n,t,s,e)}function YD(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(i+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function f9(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}YD(e,t,n)}function fl(n,t,e){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=e.length;let o=1;for(let p=r;p<i;++p)o*=e[p];const l=r<1?1:r,c=ft(t.shape)/l,h=[...Dt(e.slice(0,r)),1],d=ft(e);return{sliceRank:r,numUpdates:c,sliceSize:o,strides:h,outputSize:d}}function p9(n,t=1,e=!0){const s=V(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},o={k:t,sorted:e},[l,c]=J.runKernel(U1,i,o);return{values:l,indices:c}}const m9=nt({topk_:p9});function g9(n,t=0,e=1,s,r){if(Qi(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new BD(t,e,s,!0,r),o=te(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=i.nextValue();return o.toTensor()}const ZD=nt({truncatedNormal_:g9});function y9(n,t=0){const e=V(n,"x","unique","string_or_numeric");L(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},r={axis:t},[i,o]=J.runKernel(G1,s,r);return{values:i,indices:o}}const b9=nt({unique_:y9});function x9(n,t,e){const s=V(n,"x","unsortedSegmentSum"),r=V(t,"segmentIds","unsortedSegmentSum","int32");L(Oc(e),()=>"numSegments must be of dtype int");const i={x:s,segmentIds:r},o={numSegments:e};return J.runKernel(c0,i,o)}const JD=nt({unsortedSegmentSum_:x9});function v9(n,t=0){const e=V(n,"x","unstack","string_or_numeric");L(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},r={axis:t};return J.runKernel(l0,s,r)}const il=nt({unstack_:v9});function w9(n,t=!0,e,s){return J.makeVariable(n,t,e,s)}function QD(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const s=te(n,"int32"),r=te([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=s.indexToLoc(e[i]),l=i*n.length;r.values.set(o,l)}return r.toTensor()}function S9(n,t,e){const s=V(n,"x","transpose");if(t==null&&(t=s.shape.map((o,l)=>l).reverse()),L(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{L(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return s.dtype==="complex64"?rt(()=>{let o=Fm(s),l=sS(s);return o=J.runKernel(Ic,{x:o},i),l=J.runKernel(Ic,{x:l},i),e&&(l=sn(l)),Za(o,l)}):J.runKernel(Ic,r,i)}const he=nt({transpose_:S9});function C9(n,t){if(t==null)return n.shape.slice();if(we(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function T9(n,t,e,s){const r=V(n,"x","dropout");if(L(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),L(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof xn?r.clone():r;const i=C9(r,e),o=1-t,l=Lt(y0(wt(ef(i,0,1,"float32",s),o)),o);return Y(r,l)}const k9=nt({dropout_:T9});function $9(n,t,e,s,r,i="NHWC",o){let l=n;n.rank===3&&(l=et(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=et(t,[1,t.shape[0],t.shape[1],t.shape[2]])),L(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),L(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),L(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const h=i==="NHWC"?l.shape[3]:l.shape[1],d=i==="NHWC"?c.shape[3]:c.shape[1];L(h===e[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${e[2]}.`),L(d===e[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${e[3]}).`),Ts("conv2dDerFilter",r,o);const p={x:l,dy:c},m={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:e};return J.runKernel(f1,p,m)}const mS=nt({conv2DBackpropFilter_:$9});function gS(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return Y(n,sf(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function yS(n,t){let e=t;const s=Tn(n.shape,t.shape);return s.length>0&&(e=Mt(e,s)),et(e,n.shape)}function bS(n,t,e,s){if(t==="linear")return n;if(t==="relu")return dl(n);if(t==="elu")return m0(n);if(t==="relu6")return VD(n);if(t==="prelu")return uS(n,e);if(t==="leakyrelu")return rS(n,s);if(t==="sigmoid")return Zc(n);throw new Error(`Unknown fused activation ${t}.`)}const xS=(n,t)=>!(n>0)||t==="linear";function E9({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:c="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(c=c||"linear",xS(J.state.gradientDepth,c)===!1){L(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=nl(n,t,e,s,r,i,o);return l!=null&&(N=wt(N,l)),bS(N,c,h,d)}const p=V(n,"x","conv2d","float32"),m=V(t,"filter","conv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=et(p,[1,p.shape[0],p.shape[1],p.shape[2]])),L(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),L(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Ts("fused conv2d",s,o);const x=r==="NHWC"?y.shape[3]:y.shape[1];L(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),L(Qn(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const w=zn(y.shape,m.shape,e,i,s,o);let S;l!=null&&(S=V(l,"bias","fused conv2d"),[S]=rn(S,p),r==="NHWC"?qt(w.outShape,S.shape):(L(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),L(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let T;if(h!=null){const N=h.shape;if(L(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)L(N[0]===1||N[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${w.outChannels}).`);else if(N.length===3)try{qt(N,w.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(R)}T=V(h,"prelu weights","fused conv2d")}const k=(N,_)=>{L(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,D,M,A]=_,B=gS(N,M,c);L(tl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const H=J1(D.shape,B,R,e,s),W=mS(D,B,R.shape,e,s),X=[H,W];if(A!=null){const P=yS(A,B);X.push(P)}return X},$={x:y,filter:m,bias:S,preluActivationWeights:T},E={strides:e,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:c,leakyreluAlpha:d};return l==null?Pc((_,R,D)=>{let M=J.runKernel(Nm,$,E);return D([R,_,M]),b&&(M=et(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:k}})(y,m):Pc((_,R,D,M)=>{let A=J.runKernel(Nm,$,E);return M([R,_,A,D]),b&&(A=et(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:k}})(y,m,S)}const I9=nt({fusedConv2d_:E9});function N9(n,t,e,s,r,i=[1,1],o){let l=n;n.rank===3&&(l=et(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=et(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:l,dy:c},d={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:e};return J.runKernel(v1,h,d)}const A9=nt({depthwiseConv2dNativeBackpropFilter_:N9});function _9(n,t,e,s,r,i=[1,1],o){let l=t,c=!1;t.rank===3&&(c=!0,l=et(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:l,filter:e},d={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},p=J.runKernel(w1,h,d);return c?et(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const R9=nt({depthwiseConv2dNativeBackpropInput_:_9});function D9({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}){if(xS(J.state.gradientDepth,i)===!1){let A=xe(n,t,e,s);return r!=null&&(A=wt(A,r)),bS(A,i,o,l)}let c=V(n,"a","fused matMul"),h=V(t,"b","fused matMul");[c,h]=rn(c,h);const d=e?c.shape[c.rank-2]:c.shape[c.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=e?c.shape[c.rank-1]:c.shape[c.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=c.shape.slice(0,-2),x=h.shape.slice(0,-2),w=ft(b),S=ft(x);L(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${c.shape} and ${h.shape} and transposeA=${e} and transposeB=${s} must match.`);const k=qt(c.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),$=e?et(c,[w,d,m]):et(c,[w,m,d]),E=s?et(h,[S,y,p]):et(h,[S,p,y]);let N;r!=null&&(N=V(r,"bias","fused matMul"),[N]=rn(N,c),qt(k,N.shape));let _;o!=null&&(_=V(o,"prelu weights","fused matMul"));const R=(A,B)=>{const[H,W,X,P]=B,U=gS(et(A,X.shape),X,i);let G,tt;if(!e&&!s?(G=xe(U,W,!1,!0),tt=xe(H,U,!0,!1)):!e&&s?(G=xe(U,W,!1,!1),tt=xe(U,H,!0,!1)):e&&!s?(G=xe(W,U,!1,!0),tt=xe(H,U,!1,!1)):(G=xe(W,U,!0,!0),tt=xe(U,H,!0,!0)),r!=null){const Z=yS(P,U);return[G,tt,Z]}else return[G,tt]},D={a:$,b:E,bias:N,preluActivationWeights:_},M={transposeA:e,transposeB:s,activation:i,leakyreluAlpha:l};return r==null?Pc((B,H,W)=>{const X=J.runKernel(Im,D,M);return W([B,H,X]),{value:et(X,k),gradFunc:R}})($,E):Pc((B,H,W,X)=>{const P=J.runKernel(Im,D,M);return X([B,H,P,W]),{value:et(P,k),gradFunc:R}})($,E,N)}const rN=nt({fusedMatMul_:D9});function O9(n,t,e,s,r="bilinear",i=0){const o=V(n,"image","cropAndResize"),l=V(t,"boxes","cropAndResize","float32"),c=V(e,"boxInd","cropAndResize","int32"),h=l.shape[0];L(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),L(l.rank===2&&l.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${l.shape}.`),L(c.rank===1&&c.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${l.shape}.`),L(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),L(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),L(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:o,boxes:l,boxInd:c},p={method:r,extrapolationValue:i,cropSize:s};return J.runKernel(y1,d,p)}const M9=nt({cropAndResize_:O9});function F9(n){const t=V(n,"image","flipLeftRight","float32");L(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return J.runKernel($1,e,{})}const L9=nt({flipLeftRight_:F9});function P9(n){const t=V(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];L(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),L(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,Wr(t,r)}const z9=nt({grayscaleToRGB_:P9});function B9(n){const t=V(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];L(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),L(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,i=Et(t,"float32"),o=Fs([.2989,.587,.114]);let l;switch(t.rank){case 2:l=ih("ij,j->i",i,o);break;case 3:l=ih("ijk,k->ij",i,o);break;case 4:l=ih("ijkl,l->ijk",i,o);break;case 5:l=ih("ijklm,m->ijkl",i,o);break;case 6:l=ih("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return l=bs(l,-1),Et(l,r)}const V9=nt({rgbToGrayscale_:B9});function U9(n,t,e=0,s=.5){const r=V(n,"image","rotateWithOffset","float32");L(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:t,fillValue:e,center:s};return J.runKernel(W1,i,o)}const j9=nt({rotateWithOffset_:U9});function Qc(n,t,e,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return e=Math.min(e,o),L(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),L(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),L(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),L(t.rank===1,()=>"scores must be a 1D tensor"),L(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),L(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}function G9(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=V(n,"boxes","nonMaxSuppression","float32"),o=V(t,"scores","nonMaxSuppression","float32"),l=Qc(i,o,e,s,r);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const c={maxOutputSize:e,iouThreshold:s,scoreThreshold:r};return J.runKernel(R1,{boxes:i,scores:o},c)}const W9=nt({nonMaxSuppression_:G9});function H9(n,t,e){const s=q9(n,t,e),r=s<0?-(s+1):s;n.splice(r,0,t)}function q9(n,t,e){return X9(n,t,e||K9)}function K9(n,t){return n>t?1:n<t?-1:0}function X9(n,t,e){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const l=e(t,n[i]);l>0?s=i+1:(r=i,o=!l)}return o?s:-s-1}function vS(n,t,e,s,r){return CS(n,t,e,s,r,0)}function wS(n,t,e,s,r,i){return CS(n,t,e,s,r,0,!1,i,!0)}function SS(n,t,e,s,r,i){return CS(n,t,e,s,r,i,!0)}function CS(n,t,e,s,r,i,o=!1,l=!1,c=!1){const h=[];for(let w=0;w<t.length;w++)t[w]>r&&h.push({score:t[w],boxIndex:w,suppressBeginIndex:0});h.sort(iN);const d=i>0?-.5/i:0,p=[],m=[];for(;p.length<e&&h.length>0;){const w=h.pop(),{score:S,boxIndex:T,suppressBeginIndex:k}=w;if(S<r)break;let $=!1;for(let E=p.length-1;E>=k;--E){const N=Y9(n,T,p[E]);if(N>=s){$=!0;break}if(w.score=w.score*Z9(s,d,N),w.score<=r)break}w.suppressBeginIndex=p.length,$||(w.score===S?(p.push(T),m.push(w.score)):w.score>r&&H9(h,w,iN))}const y=p.length,b=e-y;l&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:p};return o&&(x.selectedScores=m),c&&(x.validOutputs=y),x}function Y9(n,t,e){const s=n.subarray(t*4,t*4+4),r=n.subarray(e*4,e*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),p=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(l-i)*(c-o),b=(p-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(i,h),w=Math.max(o,d),S=Math.min(l,p),T=Math.min(c,m),k=Math.max(S-x,0)*Math.max(T-w,0);return k/(y+b-k)}function Z9(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function iN(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function J9(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const i=V(n,"boxes","nonMaxSuppressionAsync"),o=V(t,"scores","nonMaxSuppressionAsync"),l=Qc(i,o,e,s,r);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold;const c=await Promise.all([i.data(),o.data()]),h=c[0],d=c[1],{selectedIndices:p}=vS(h,d,e,s,r);return i!==n&&i.dispose(),o!==t&&o.dispose(),Fs(p,"int32")}const Q9=J9;function t7(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=V(n,"boxes","nonMaxSuppression"),l=V(t,"scores","nonMaxSuppression"),c=Qc(o,l,e,s,r,i);e=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,i=c.softNmsSigma;const h={boxes:o,scores:l},d={maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},p=J.runKernel(O1,h,d);return{selectedIndices:p[0],selectedScores:p[1]}}const e7=nt({nonMaxSuppressionWithScore_:t7});async function n7(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=V(n,"boxes","nonMaxSuppressionAsync"),l=V(t,"scores","nonMaxSuppressionAsync"),c=Qc(o,l,e,s,r,i);e=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,i=c.softNmsSigma;const h=await Promise.all([o.data(),l.data()]),d=h[0],p=h[1],{selectedIndices:m,selectedScores:y}=SS(d,p,e,s,r,i);return o!==n&&o.dispose(),l!==t&&l.dispose(),{selectedIndices:Fs(m,"int32"),selectedScores:Fs(y)}}const s7=n7;function r7(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=V(n,"boxes","nonMaxSuppression"),l=V(t,"scores","nonMaxSuppression"),c=Qc(o,l,e,s,r,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,m={boxes:o,scores:l},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:i},b=J.runKernel(D1,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const i7=nt({nonMaxSuppressionPadded_:r7});async function o7(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=V(n,"boxes","nonMaxSuppressionAsync"),l=V(t,"scores","nonMaxSuppressionAsync"),c=Qc(o,l,e,s,r,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,[m,y]=await Promise.all([o.data(),l.data()]),{selectedIndices:b,validOutputs:x}=wS(m,y,h,d,p,i);return o!==n&&o.dispose(),l!==t&&l.dispose(),{selectedIndices:Fs(b,"int32"),validOutputs:ve(x,"int32")}}const a7=o7;function l7(n,t,e=!1,s=!1){const r=V(n,"images","resizeBilinear");L(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),L(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),L(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=et(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},c={alignCorners:e,halfPixelCenters:s,size:t},h=J.runKernel(t0,l,c);return o?et(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const tO=nt({resizeBilinear_:l7});function c7(n,t,e=!1,s=!1){const r=V(n,"images","resizeNearestNeighbor");L(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),L(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),L(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),L(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=et(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={images:i},c={alignCorners:e,halfPixelCenters:s,size:t},h=J.runKernel(Qg,l,c);return o?et(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const eO=nt({resizeNearestNeighbor_:c7});function u7(n,t="binary",e=!1,s=.5){const r=V(n,"image","threshold"),i=.2989,o=.587,l=.114,c=r.shape[0]*r.shape[1];let h=Y(Fs([s]),255),d,p,m,y;if(L(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),L(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),L(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),L(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[d,p,m]=er(r,[1,1,1],-1);const w=Y(d,i),S=Y(p,o),T=Y(m,l);y=wt(wt(w,S),T)}else y=n;if(t==="otsu"){const w=o8(Et(UD(y),"int32"),Ch([]),256);h=h7(w,c)}const b=e?Jc(y,h):sr(y,h);return Et(Y(b,255),"int32")}function h7(n,t){let e=Fs([-1]),s=Fs([0]),r=Fs([0]),i,o,l,c,h,d;for(let p=0;p<n.size-1;p++){i=Fe(n,0,p+1),o=Fe(n,p+1),h=Lt(Mt(i),t),d=Lt(Mt(o),t);const m=Mt(Y(i,Vh(0,i.size)));l=Lt(m,Mt(i));const y=p0(o.shape,i.size),b=wt(Vh(0,o.size),y),x=Y(o,b);c=Lt(Mt(x),Mt(o));const w=Bt(l,c),S=Bt(l,c),T=Y(h,d);r=Y(Y(T,w),S);const k=sr(r,s);s=cs(k,r,s),e=cs(k,Fs([p]),e)}return e}const d7=nt({threshold_:u7});function f7(n,t,e="nearest",s="constant",r=0,i){const o=V(n,"image","transform","float32"),l=V(t,"transforms","transform","float32");L(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),L(l.rank===2&&(l.shape[0]===o.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),L(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const c={image:o,transforms:l},h={interpolation:e,fillMode:s,fillValue:r,outputShape:i};return J.runKernel(j1,c,h)}const p7=nt({transform_:f7});function m7(n,t,e){const s=V(n,"a","bandPart");L(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);let l,c;typeof t=="number"?(L(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),L(t<=i,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`),l=V(t<0?i:t,"numLower","bandPart")):(L(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),l=cs(Om(t,0),i,Bh(t,i))),typeof e=="number"?(L(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),L(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),c=V(e<0?o:e,"numUpper","bandPart")):(L(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=cs(Om(e,0),o,Bh(e,o)));const h=et(Vh(0,i,1,"int32"),[-1,1]),d=Vh(0,o,1,"int32"),p=Bt(h,d),m=Ki(Jc(p,l),hl(p,sn(c))),y=_n([i,o],s.dtype);return et(Xi(il(et(s,[-1,i,o])).map(b=>cs(m,b,y))),r)}const g7=nt({bandPart_:m7});function y7(n){let t;if(Array.isArray(n)){t=!1,L(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)L(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else t=!0,n=er(n,n.shape[0],0).map(r=>nf(r,[0]));L(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(J.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const l=Y(Mt(Y(e[o],i)),e[o]);i=Bt(i,l)}return Lt(i,g0(i,"euclidean"))}));return t?Xi(e,0):e}const b7=nt({gramSchmidt_:y7});function x7(n,t=!1){if(L(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return oN(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((c,h)=>c*h),s=il(et(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(c=>{const[h,d]=oN(c,t);r.push(h),i.push(d)});const o=et(Xi(r,0),n.shape),l=et(Xi(i,0),n.shape);return[o,l]}}function oN(n,t=!1){return J.tidy(()=>{L(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=OD(e),i=Ha(n);const o=Ox([[1]],[1,1]);let l=Ha(o);const c=e>=s?s:e;for(let h=0;h<c;++h){const d=i,p=l,m=r;[l,i,r]=J.tidy(()=>{const y=Fe(i,[h,h],[e-h,1]),b=g0(y),x=Fe(i,[h,h],[1,1]),w=cs(sr(x,0),Ox([[-1]]),Ox([[1]])),S=Bt(x,Y(w,b)),T=Lt(y,S);T.shape[0]===1?l=Ha(o):l=ws([o,Fe(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const k=sn(Lt(xe(w,S),b)),$=Fe(i,[h,0],[e-h,s]),E=Y(k,l),N=he(l);if(h===0)i=Bt($,xe(E,xe(N,$)));else{const D=Bt($,xe(E,xe(N,$)));i=ws([Fe(i,[0,0],[h,s]),D],0)}const _=he(E),R=Fe(r,[0,h],[e,r.shape[1]-h]);if(h===0)r=Bt(R,xe(xe(R,l),_));else{const D=Bt(R,xe(xe(R,l),_));r=ws([Fe(r,[0,0],[e,h]),D],1)}return[l,i,r]}),Qt([d,p,m])}return!t&&e>s&&(r=Fe(r,[0,0],[e,s]),i=Fe(i,[0,0],[s,s])),[r,i]})}const v7=nt({qr_:x7});const Wi={flipLeftRight:L9,grayscaleToRGB:z9,resizeNearestNeighbor:eO,resizeBilinear:tO,rgbToGrayscale:V9,rotateWithOffset:j9,cropAndResize:M9,nonMaxSuppression:W9,nonMaxSuppressionAsync:Q9,nonMaxSuppressionWithScore:e7,nonMaxSuppressionWithScoreAsync:s7,nonMaxSuppressionPadded:i7,nonMaxSuppressionPaddedAsync:a7,threshold:d7,transform:p7},w7={bandPart:g7,gramSchmidt:b7,qr:v7};const S7=new Map,C7=new Map;class tu{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class vr{constructor(){this.classNameMap={}}static getMap(){return vr.instance==null&&(vr.instance=new vr),vr.instance}static register(t){vr.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function vt(n,t,e){L(n.className!=null,()=>"Class being registered does not have the static className property defined."),L(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),L(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,r=t+">"+s;return vr.register(n),S7.set(r,n),C7.set(n,r),n}class ea extends tu{minimize(t,e=!1,s){const{value:r,grads:i}=this.computeGradients(t,s);if(s!=null){const o=s.map(l=>({name:l.name,tensor:i[l.name]}));this.applyGradients(o)}else this.applyGradients(i);return Qt(i),e?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return EK(t,e)}dispose(){this.iterations_!=null&&Qt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ve(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ea,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class nO extends ea{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:rt(()=>de(i).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:rt(()=>de(i).variable(o))});const l=Array.isArray(t)?t[r].tensor:t[s];if(l==null)return;const c=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;rt(()=>{const d=wt(Y(c,this.rho),Y(ze(l),1-this.rho)),p=Y(Lt(Jn(wt(h,this.epsilon)),Jn(wt(c,this.epsilon))),l),m=wt(Y(h,this.rho),Y(ze(p),1-this.rho));c.assign(d),h.assign(m);const y=wt(Y(p,-this.learningRate),i);i.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Qt(this.accumulatedGrads.map(t=>t.variable)),Qt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}class sO extends ea{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:rt(()=>p0(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const l=this.accumulatedGrads[r].variable;rt(()=>{const c=wt(l,ze(o));l.assign(c);const h=wt(Y(Lt(o,Jn(wt(c,J.backend.epsilon()))),-this.learningRate),i);i.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Qt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}class rO extends ea{static get className(){return"Adam"}constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],rt(()=>{this.accBeta1=ve(e).variable(),this.accBeta2=ve(s).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);rt(()=>{const s=Bt(1,this.accBeta1),r=Bt(1,this.accBeta2);e.forEach((i,o)=>{const l=J.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:rt(()=>de(l).variable(c))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:rt(()=>de(l).variable(c))});const h=Array.isArray(t)?t[o].tensor:t[i];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedSecondMoment[o].variable,m=wt(Y(d,this.beta1),Y(h,1-this.beta1)),y=wt(Y(p,this.beta2),Y(ze(h),1-this.beta2)),b=Lt(m,s),x=Lt(y,r);d.assign(m),p.assign(y);const w=wt(Y(Lt(b,wt(Jn(x),this.epsilon)),-this.learningRate),l);l.assign(w)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Qt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Qt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),rt(()=>{this.accBeta1.assign(sl(this.beta1,this.iterations_+1)),this.accBeta2.assign(sl(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}class iO extends ea{static get className(){return"Adamax"}constructor(t,e,s,r=null,i=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],rt(()=>{this.iteration=ve(0).variable(),this.accBeta1=ve(e).variable()}),r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);rt(()=>{const s=Bt(1,this.accBeta1),r=Lt(-this.learningRate,wt(Y(this.iteration,this.decay),1));e.forEach((i,o)=>{const l=J.registeredVariables[i],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:de(l).variable(c)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:de(l).variable(c)});const h=Array.isArray(t)?t[o].tensor:t[i];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedWeightedInfNorm[o].variable,m=wt(Y(d,this.beta1),Y(h,1-this.beta1)),y=Y(p,this.beta2),b=is(h),x=Qo(y,b);d.assign(m),p.assign(x);const w=wt(Y(Lt(r,s),Lt(m,wt(x,this.epsilon))),l);l.assign(w)}),this.iteration.assign(wt(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Qt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Qt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class TS extends ea{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const o=J.registeredVariables[s];rt(()=>{const l=wt(Y(this.c,i),o);o.assign(l)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=fi(ve(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class oO extends TS{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=ve(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:rt(()=>de(i).variable(!1))});const o=this.accumulations[r].variable,l=Array.isArray(t)?t[r].tensor:t[s];l!=null&&rt(()=>{let c;const h=wt(Y(this.m,o),l);this.useNesterov?c=wt(Y(this.c,wt(l,Y(h,this.m))),i):c=wt(Y(this.c,h),i),o.assign(h),i.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Qt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class aO extends ea{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,r=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r==null&&(this.epsilon=J.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const i=J.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:rt(()=>de(i).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:rt(()=>de(i).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:rt(()=>de(i).variable(o))});const l=Array.isArray(t)?t[r].tensor:t[s];if(l==null)return;const c=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;rt(()=>{const d=wt(Y(c,this.decay),Y(ze(l),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[r].variable,m=wt(Y(p,this.decay),Y(l,1-this.decay)),y=Lt(Y(l,this.learningRate),Jn(Bt(d,wt(ze(m),this.epsilon)))),b=wt(Y(h,this.momentum),y);c.assign(d),p.assign(m),h.assign(b);const x=Bt(i,b);i.assign(x)}else{const p=wt(Y(c,this.decay),Y(ze(l),1-this.decay)),m=wt(Y(h,this.momentum),Lt(Y(l,this.learningRate),Jn(wt(p,this.epsilon))));c.assign(p),h.assign(m);const y=Bt(i,m);i.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Qt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Qt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Qt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const T7=[nO,sO,rO,iO,oO,aO,TS];function k7(){for(const n of T7)vt(n)}function aN(n,t,e,s){o(n),e=e??0,s=s??1,l(e,s);let r=0;const i=c=>(c.then(h=>{const d=e+ ++r/n.length*(s-e);return t(d),h}),c);function o(c){L(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function l(c,h){L(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),L(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),L(h>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${h}`)}return Promise.all(n.map(i))}async function $7(n,t){t==null&&(t={});const e=t.fetchFunc==null?lt().platform.fetch:t.fetchFunc,s=n.map(p=>e(p,t.requestInit,{isBinary:!0})),l=(t.onProgress==null?await Promise.all(s):await aN(s,t.onProgress,0,.5)).map(p=>p.arrayBuffer());return t.onProgress==null?await Promise.all(l):await aN(l,t.onProgress,.5,1)}function E7(n,t){var e;const s=t.fetchFunc==null?lt().platform.fetch:t.fetchFunc;let r=0,i;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async o=>{for(var l;r<n.length;){i||(i=(await s(n[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:c,value:h}=await i.read();if(c){r++,i=void 0,(l=t.onProgress)===null||l===void 0||l.call(t,r/n.length);continue}o.enqueue(h);return}o.close()}})}const I7="application/octet-stream",N7="application/json";class kS{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(L(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=lt().platform.fetch,L(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&L(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=B6(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(r)],{type:N7}),"model.json"),t.weightData!=null){const o=Yo.join(t.weightData);e.body.append("model.weights.bin",new Blob([o],{type:I7}),"model.weights.bin")}const i=await this.fetch(this.path,e);if(i.ok)return{modelArtifactsInfo:K1(t),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=e.modelTopology,r=e.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return U6(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=qI(t.weightsManifest),r=()=>E7(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=A7(e),i=this.weightPathPrefix||s,o=[],l=[];for(const c of t)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):o.push(i+h+r);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(t){const e=await this.getWeightUrls(t),s=qI(t),r=await $7(e,this.loadOptions);return[s,r]}}kS.URL_SCHEME_REGEX=/^https?:\/\//;function A7(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),r=e>t?n.substring(e):"";return[s+"/",r]}function lN(n){return n.match(kS.URL_SCHEME_REGEX)!=null}const lO=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>lN(s)):e=lN(n),e)return cO(n,t)}return null};Nn.registerSaveRouter(lO);Nn.registerLoadRouter(lO);function cO(n,t){return new kS(n,t)}function _7(n,t){return cO(n,t)}class Mx{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class R7{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function D7(n,t,e,s){const r=arguments;return new R7(O7(...r))}function O7(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Mx(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Mx({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Mx({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function $S(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(ft(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,i=r[r.length-1];let o=1;for(let p=0;p<r.length-1;++p)o*=r[p];const l=n.shape,c=r.slice();c.pop();let h=1;for(let p=i;p<e;++p)h*=l[p],c.push(l[p]);const d=[...Dt(n.shape).map(p=>p/h),1].slice(0,i);return[c,o,h,d]}const Kv=-2,M7=-1;function ES(n,t,e){const s=n.shape.length;L(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),L(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)L(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function F7(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function IS(n,t,e){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function uO(n,t,e,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<e;i++)i===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function hO(n,t,e){return e<=n?e:e-(t-1)}function dO(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function L7(n,t,e,s,r,i,o,l,c){const h=n.length;let d=new Array(h),p=new Array(h),m=new Array(h);if(t.length&&e>0){const y=t[0],b=e+1;d=fO(o,y,b,s,n),p=pO(l,y,b,r,n),m=uO(i,y,b,n)}else for(let y=0;y<h;y++)d[y]=gO(o,s,i,n,y,c),p[y]=yO(l,r,i,n,y,c),m[y]=mO(i,y,c);return{begin:d,end:p,strides:m}}function fO(n,t,e,s,r){const i=[...r],o=dO(e,t);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=0;else{const c=hO(t,e,l);let h=s[c];n&1<<c&&(h=0),i[l]=h}return i}function pO(n,t,e,s,r){const i=[...r],o=dO(e,t);for(let l=0;l<i.length;l++)if(o.indexOf(l)>-1)i[l]=Number.MAX_SAFE_INTEGER;else{const c=hO(t,e,l);let h=s[c];n&1<<c&&(h=Number.MAX_SAFE_INTEGER),i[l]=h}for(let l=0;l<i.length;l++){const c=r[l];i[l]<0&&(i[l]+=c),i[l]=Xa(0,i[l],r[l])}return i}function mO(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function gO(n,t,e,s,r,i){let o=t[r];const l=e[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),o=Xa(0,o,c-1),o}function yO(n,t,e,s,r,i){let o=t[r];const l=e[r]||1;(n&1<<r||i&1<<r||o==null)&&(l>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),l>0?o=Xa(0,o,c):o=Xa(-1,o,c-1),o}function NS(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function AS(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function b0(n,t,e){let s;const r=n.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{L(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return e==null?i=new Array(r).fill(-1):typeof e=="number"?i=[e,...new Array(r-1).fill(-1)]:e.length<r?i=e.concat(new Array(r-e.length).fill(-1)):i=e,i=i.map((o,l)=>o>=0?o:(L(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,i]}function _S(n,t,e,s,r,i,o,l,c){let h;if(s==null?(h=new Array(t.length),h.fill(1)):h=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:h.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};for(let k=0;k<p.dims;k++)d&&(1<<k&l)!==0&&p.numAddAxisAfterEllipsis++,1<<k&o&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};P7(p,m);let y=!0,b=!0,x=!0;const w=[],S=[];for(let k=0;k<n.length;++k){if(m.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);const $=!!(m.shrinkAxisMask&1<<k),E=n[k];if(E===-1){w.push($?1:-1);continue}const N=[m.beginMask&1<<k,m.endMask&1<<k],_=[m.strides[k]>0?0:-1,m.strides[k]>0?E:E-1];if($&&m.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[k]===1;const R=!!(m.beginMask&1<<k&&m.endMask&1<<k);if(m.beginValid&&m.endValid){if($){const B=m.begin[k]<0?E+m.begin[k]:m.begin[k];if(m.begin[k]=B,m.end[k]=m.begin[k]+1,B<0||B>=E)throw Error(`slice index ${m.begin[k]} of dimension ${k} out of bounds.`)}else m.begin[k]=cN(m.begin[k],0,m.strides[k],E,N,_),m.end[k]=cN(m.end[k],1,m.strides[k],E,N,_);const A=m.strides[k]===1&&m.begin[k]===0&&m.end[k]===E;y=y&&A,b=b&&(k===0&&m.strides[k]===1||A)}else y=y&&m.strides[k]===1&&R,b=b&&(k===0&&m.strides[k]===1||R);let D,M=!1;if(m.beginValid&&m.endValid?(D=m.end[k]-m.begin[k],M=!0):$?(D=1,M=!0):R&&E>=0&&(m.strides[k]<0?D=-E:D=E,M=!0),M){let A;D===0||D<0!=m.strides[k]<0?A=0:A=Math.trunc(D/m.strides[k])+(D%m.strides[k]!==0?1:0),w.push(A)}else w.push(-1)}for(let k=0;k<m.finalShapeGatherIndices.length;++k){const $=m.finalShapeGatherIndices[k];$>=0?S.push(w[$]):$===Kv&&S.push(1)}return{finalShapeSparse:S.filter((k,$)=>m.finalShapeGatherIndices[$]!==Kv),finalShape:S,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function P7(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(Kv),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(M7),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function cN(n,t,e,s,r,i){if(r[t])return e>0?i[t]:i[t+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const z7=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:ES,computeFlatOffset:AS,computeOutShape:IS,getNormalizedAxes:L7,isSliceContinous:NS,maskToAxes:F7,parseSliceParams:b0,sliceInfo:_S,startForAxis:gO,startIndicesWithElidedDims:fO,stopForAxis:yO,stopIndicesWithElidedDims:pO,stridesForAxis:mO,stridesWithElidedDims:uO},Symbol.toStringTag,{value:"Module"}));class B7{static sgd(t){return new TS(t)}static momentum(t,e,s=!1){return new oO(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,i=!1){return new aO(t,e,s,r,i)}static adam(t=.001,e=.9,s=.999,r=null){return new rO(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new nO(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,i=0){return new iO(t,e,s,r,i)}static adagrad(t,e=.1){return new sO(t,e)}}const uc=B7;const V7=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function bO(){return new Promise(n=>V7(()=>n()))}function RS(n,t){const e=n[0].length;n.forEach((r,i)=>{L(r.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),L(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<e;o++)L(o===t||r[o]===s[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function pi(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var Gr;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Gr||(Gr={}));function xO(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let r=1;r<e.length;++r){const i=e[r],o=s[s.length-e.length+r],l=s[o];if(i>=0)if(l>=0){if(l!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${i} but shape[${r+n}] = ${l}`)}else s[o]=i}return s}function vO(n){const t={FIRST_DIM_SIZE:Gr.FIRST_DIM_SIZE,VALUE_ROWIDS:Gr.VALUE_ROWIDS,ROW_LENGTHS:Gr.ROW_LENGTHS,ROW_SPLITS:Gr.ROW_SPLITS,ROW_LIMITS:Gr.ROW_LIMITS,ROW_STARTS:Gr.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function wO(n){return n.length===0?0:n[0]===Gr.FIRST_DIM_SIZE?n.length-1:n.length}function SO(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(e,s-1);++r){const i=n[r],o=t[r+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${i} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const DS=30;function x0(n){return n<=DS?n:Rv(n,Math.floor(Math.sqrt(n)))}function OS(n,t,e){const s=e*(typeof n=="number"?n:n[0]),r=t*(typeof n=="number"?n:n[1]);return[s,r]}function rf(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/t[o],t[o]]);r=r.concat(n.slice(i+1))}return r}function of(n,t,e=!0){const s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=t*2+1||o%2===1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function af(n,t,e,s=!0){const r=[];s?r.push(n[0]/e):r.push(n[0]*e);for(let i=1;i<n.length;++i)i<=t.length?s?r.push(t[i-1]*n[i]):r.push(n[i]/t[i-1]):r.push(n[i]);return r}function MS(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function FS(n,t,e){const s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}const v0=1.7580993408473768,w0=1.0507009873554805;const LS=.3275911,PS=.254829592,zS=-.284496736,BS=1.421413741,VS=-1.453152027,US=1.061405429;function Yi(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function CO(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function TO(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function kO(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function jS(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function $O(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function EO(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:e,imag:s}}function IO(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}const Fx="->",U7=/->/g,uN=",",hN="...";function GS(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(U7,"").length)/Fx.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${Fx}").`);const[s,r]=n.split(Fx);L(s.indexOf(hN)===-1,()=>`The ellipsis notation ("${hN}") is not supported yet.`);const i=s.split(uN),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<r.length;++m){const y=r[m];if(!i.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);l.indexOf(y)===-1&&l.push(y)}for(let m=0;m<s.length;++m){const y=s[m];l.indexOf(y)===-1&&y!==uN&&l.push(y)}const c=new Array(i.length);for(let m=0;m<o;++m){if(new Set(i[m].split("")).size!==i[m].length)throw new Error(`Found duplicate axes in input component ${i[m]}. Support for duplicate axes in input is not implemented yet.`);c[m]=[];for(let y=0;y<i[m].length;++y)c[m].push(l.indexOf(i[m][y]))}const h=l.length,d=r.length,p=[];for(let m=d;m<h;++m)p.push(m);return{allDims:l,summedDims:p,idDims:c}}function WS(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const s=[];for(let r=0;r<n;++r)e[r]===-1&&s.push(r);return e=e.filter(r=>r!==-1),{permutationIndices:e,expandDims:s}}function HS(n,t,e){const s=new Array(n);for(let r=0;r<e.length;++r){const i=e[r].shape;for(let o=0;o<t[r].length;++o)s[t[r][o]]===void 0?s[t[r][o]]=i[o]:L(s[t[r][o]]===i[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function qS(n,t){const e=n,s=[];let r=0;n.length===0&&e.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<e.length;++o){const l=e[o],c=j7(t,l);for(const h of c)i.indexOf(h)===-1&&(s[o].push(h),i.push(h))}return{path:e,steps:s}}function KS(n){return n.every((t,e)=>t===e)}function j7(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function XS(n,t,e=0){let s=[];if(typeof t=="number")L(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const r=t.reduce((o,l)=>(l===-1&&(o+=1),o),0);L(r<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(i!==-1){const o=t.reduce((l,c)=>c>0?l+c:l);t[i]=n.shape[e]-o}L(n.shape[e]===t.reduce((o,l)=>o+l),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function NO(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function AO(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function _O(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function RO(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function DO(n,t){return`size ${n} must be non-negative, not ${t}`}function OO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function MO(n,t){const e=ft(n),s=ft(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function FO(n,t){const e=ft(n),s=ft(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}function Xv(){return"segment ids must be >= 0"}function LO(){return"segment ids are not increasing"}function PO(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function zO(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function BO(n,t){let e=!1,s;for(n<=DS?(s=n,e=!0):s=Rv(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=Rv(n,s+1);return s}function VO(n,t,e){const s=[],r=n.length;for(let i=0;i<r;i++)i!==t?s.push(n[i]):s.push(e);return s}function YS(n,t,e,s){const r=t.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let p=0;p<s;++p)if(n.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);const o=n.shape[e],l=[];let c=1,h=1,d=1;for(let p=0;p<s;++p)l.push(n.shape[p]),c*=n.shape[p];for(let p=s;p<e;p++)l.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<r;p++)l.push(t.shape[p]);for(let p=e+1;p<i;p++)l.push(n.shape[p]),d*=n.shape[p];return{batchSize:c,sliceSize:d,outerSize:h,dimSize:o,outputShape:l}}const G7=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:YS,computeOutShape:VO,segOpComputeOptimalWindowSize:BO},Symbol.toStringTag,{value:"Module"}));function Zi(n){try{return n.map(t=>Vo(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function UO(n){return n.map(t=>Fo(t))}const W7=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:PS,ERF_A2:zS,ERF_A3:BS,ERF_A4:VS,ERF_A5:US,ERF_P:LS,PARALLELIZE_THRESHOLD:DS,get RowPartitionType(){return Gr},SELU_SCALE:w0,SELU_SCALEALPHA:v0,applyActivation:bS,assertAndGetBroadcastShape:qt,assertAxesAreInnerMostDims:Bn,assertParamsConsistent:RS,assignToTypedArray:$O,axesAreInnerMostDims:eS,calculateShapes:fl,checkEinsumDimSizes:HS,checkPadOnDimRoundingMode:Ts,combineLocations:RD,combineRaggedTensorToTensorShapes:xO,complexWithEvenIndex:TO,complexWithOddIndex:kO,computeConv2DInfo:zn,computeConv3DInfo:Zo,computeDefaultPad:X1,computeDilation2DInfo:Qd,computeOptimalWindowSize:x0,computeOutAndReduceShapes:Dn,computeOutShape:pi,computePool2DInfo:Er,computePool3DInfo:to,convertConv2DDataFormat:eo,decodeEinsumEquation:GS,eitherStridesOrDilationsAreOne:Qn,expandShapeToKeepDim:dn,exponent:IO,exponents:EO,fromStringArrayToUint8:UO,fromUint8ToStringArray:Zi,getAxesPermutation:Xe,getBroadcastDims:Lc,getComplexWithIndex:jS,getEinsumComputePath:qS,getEinsumPermutation:WS,getFusedBiasGradient:yS,getFusedDyActivation:gS,getImageCenter:OS,getInnerMostAxes:on,getPermuted:of,getRaggedRank:wO,getReductionAxes:Tn,getReshaped:rf,getReshapedPermuted:af,getRowPartitionTypesHelper:vO,getSliceBeginCoords:MS,getSliceSize:FS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:NO,getSparseFillEmptyRowsNegativeIndexErrorMessage:AO,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:_O,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:OO,getSparseReshapeInputOutputMismatchErrorMessage:FO,getSparseReshapeInputOutputMultipleErrorMessage:MO,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:RO,getSparseReshapeNegativeOutputDimErrorMessage:DO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:zO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Xv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:LO,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:PO,getUndoAxesPermutation:Jo,isIdentityPermutation:KS,log:r6,mergeRealAndImagArrays:Yi,prepareAndValidate:$S,prepareSplitSize:XS,segment_util:G7,shouldFuse:xS,slice_util:z7,splitRealAndImagArrays:CO,stridesOrDilationsArePositive:el,tupleValuesAreOne:tl,upcastType:Ls,validateDefaultValueShape:SO,validateInput:f9,validateUpdateShape:YD,warn:Qs},Symbol.toStringTag,{value:"Module"}));k7();const jO={kernelName:hg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,sf(Et(e,"float32"),-1))}}};const H7={kernelName:nd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=ze(Et(e,"float32")),r=Jn(Bt(ve(1),s));return sn(Lt(n,r))}}}};const q7={kernelName:sd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Jn(Bt(ze(Et(e,"float32")),1));return Lt(n,s)}}}};const K7={kernelName:Yc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{let l=n;const c=Tn(e.shape,r);return c.length>0&&(l=Mt(l,c)),et(l,e.shape)},b:()=>{let l=n;const c=Tn(s.shape,r);return c.length>0&&(l=Mt(l,c)),et(l,s.shape)}}}};const X7={kernelName:i1,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}};const Y7={kernelName:dg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>de(e)}}};const Z7={kernelName:fg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>de(e)}}};const J7={kernelName:rd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Jn(Bt(ve(1),ze(Et(e,"float32")))))}}};const Q7={kernelName:id,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Jn(wt(ve(1),ze(Et(e,"float32"))));return Lt(n,s)}}}};const tY={kernelName:ld,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=wt(ze(e),ze(s));let c=Y(n,Lt(s,l));const h=Tn(e.shape,r);return h.length>0&&(c=Mt(c,h)),et(c,e.shape)},b:()=>{const l=wt(ze(e),ze(s));let c=sn(Y(n,Lt(e,l)));const h=Tn(s.shape,r);return h.length>0&&(c=Mt(c,h)),et(c,s.shape)}}}};const eY={kernelName:od,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,wt(ze(Et(e,"float32")),1))}}};const nY={kernelName:ad,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Bt(ve(1),ze(Et(e,"float32"))))}}};function sY(n,t,e,s,r,i){const o=V(n,"dy","avgPool3dGrad"),l=V(t,"input","avgPool3dGrad");let c=o,h=l,d=!1;l.rank===4&&(d=!0,c=et(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=et(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),L(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),L(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),Ts("avgPool3dGrad",r,i);const p={dy:c,input:h},m={filterSize:e,strides:s,pad:r,dimRoundingMode:i},y=J.runKernel(c1,p,m);return d?et(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const rY=nt({avgPool3dGrad_:sY});const iY={kernelName:mg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o,dimRoundingMode:l}=e;return{x:()=>rY(n,s,r,i,o,l)}}};function oY(n,t,e,s,r){const i=V(n,"dy","avgPoolGrad"),o=V(t,"input","avgPoolGrad");L(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let l=o,c=i,h=!1;o.rank===3&&(h=!0,l=et(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=et(i,[1,i.shape[0],i.shape[1],i.shape[2]])),L(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),L(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);const d={dy:c,input:l},p={filterSize:e,strides:s,pad:r},m=J.runKernel(l1,d,p);return h?et(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const aY=nt({avgPoolGrad_:oY});const lY={kernelName:pg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:i,pad:o}=e;return{x:()=>aY(n,s,r,i,o)}}};const cY={kernelName:gg,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:i,transposeB:o}=e;return!i&&!o?{a:()=>xe(n,r,!1,!0),b:()=>xe(s,n,!0,!1)}:!i&&o?{a:()=>xe(n,r,!1,!1),b:()=>xe(n,s,!0,!1)}:i&&!o?{a:()=>xe(r,n,!1,!0),b:()=>xe(s,n,!1,!1)}:{a:()=>xe(r,n,!0,!0),b:()=>xe(n,s,!0,!0)}}};const uY={kernelName:yg,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>cS(n,s,r)}}};const hY={kernelName:t6,gradFunc:(n,t,e)=>{const s=e,r=s.inputShape,i=s.shape,o=Array.from(i);for(let c=r.length-1;c>=0;c--)if(r[c]===i[c])o[c]=1;else if(r[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const l=[];for(let c=0;c<o.length;c++)o[c]>1&&l.push(c);return{x:()=>Mt(n,l,!0)}}};const dY={kernelName:cd,gradFunc:n=>({x:()=>n.clone()})};const fY={kernelName:ud,gradFunc:n=>({x:()=>de(n)})};const pY={kernelName:hd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=e;return{x:()=>cs(Ki(hl(s,r),Jc(s,i)),n,de(n))}}};const mY={kernelName:bg,inputsToSave:["x"],gradFunc:jO.gradFunc};const gY={kernelName:xg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(c=>c.shape),{axis:r}=e,i=ee(r,t[0].shape)[0],o=s.map(c=>c[i]);return er(n,o,i).map(c=>()=>c)}};const yY={kernelName:vg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:i,strides:o,pad:l,dataFormat:c}=e;return L(tl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>J1(s.shape,n,r,o,l,c),filter:()=>mS(s,n,r.shape,o,l,c)}}};const bY={kernelName:wg,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:c}=e;return{dy:()=>nl(n,r,i,o,l,1,c),filter:()=>mS(n,s,r.shape,i,o,l,c)}}};function xY(n,t,e,s,r){let i=n;n.rank===4&&(i=et(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;o.rank===4&&(o=et(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),L(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),L(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),L(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),L(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),L(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const l={x:i,dy:o},c={strides:s,pad:r,filterShape:e};return J.runKernel(p1,l,c)}const vY=nt({conv3DBackpropFilter_:xY});const wY={kernelName:Sg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i}=e;L(tl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,l]=t;return{x:()=>ID(o.shape,n,l,r,i),filter:()=>vY(o,n,l.shape,r,i)}}};const SY={kernelName:dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(sn(HD(Et(e,"float32"))),n)}}};const CY={kernelName:fd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(qD(Et(e,"float32")),n)}}};const TY={kernelName:Cg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:i,reverse:o}=e;return{x:()=>{const l=Xe([r],s.rank);let c=AD(n,r,i,!o);return l!=null&&(c=he(c,l)),c}}}};const kY={kernelName:Tg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:o}=e,l=s??[1,1];L(tl(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);const[c,h]=t;return L(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),L(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),L(c.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),L(Qn(r,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${l}'.`),Ts("depthwiseConv2d",i,o),{x:()=>R9(c.shape,n,h,r,i,l,o),filter:()=>A9(c,n,h.shape,r,i,l,o)}}};const $Y={kernelName:kg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,i={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>J.runKernel(Dv,i,e),filter:()=>J.runKernel(Ov,o,e)}}};const EY={kernelName:md,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>J.runKernel(C1,s)}}};const IY={kernelName:gd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Y(xi(sn(ze(e))),2/Math.sqrt(Math.PI));return{x:()=>Y(n,s)}}};const NY={kernelName:yd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,e)}}};const AY={kernelName:Eg,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>et(n,e.shape)}}};const _Y={kernelName:bd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,xi(e))}}};const RY={kernelName:xd,gradFunc:n=>({x:()=>de(n)})};const DY={kernelName:vd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Lt(n,Et(s,"float32")),c=Tn(e.shape,r);return c.length>0?et(Mt(l,c),e.shape):l},b:()=>{let l=Y(n,Et(e,"float32"));const c=Tn(s.shape,r);c.length>0&&(l=et(Mt(l,c),s.shape));const h=ze(s);return sn(Lt(l,Et(h,"float32")))}}}};const OY={kernelName:Ig,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,i,o,l]=t,c=l??ve(1),h=Tn(i.shape,r.shape),d=[];if(i.rank===1){for(let $=0;$<r.shape.length-1;++$)d.push(r.shape[$]);d.push(1)}const p=Bt(r,i),m=Y(n,c),y=jD(wt(o,ve(s))),b=Y(Y(Y(y,y),y),ve(-.5));return{x:()=>i.rank===1?et(Y(Y(n,Wr(et(y,[1,1,1,i.shape[0]]),d)),c),r.shape):et(Y(Y(n,y),c),r.shape),mean:()=>{let $=Y(Y(y,ve(-1)),m);return i.rank===1&&($=Mt($,h)),et($,i.shape)},variance:()=>{let $=Y(Y(b,p),m);return i.rank===1&&($=Mt($,h)),et($,i.shape)},scale:()=>{const $=Y(p,y);let E=Y(n,$);return i.rank===1&&(E=Mt(E,h)),et(E,i.shape)},offset:()=>{let $=n;return i.rank===1&&($=Mt($,h)),et($,i.shape)}}}};const MY={kernelName:Ng,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:i,batchDims:o}=e,l=ee(i,s.shape)[0],c=(h,d,p)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,l),x=b.length,w=m.slice(i,m.length).slice(1),S=w.length,T=dN(0,x),k=dN(x+1,x+1+S),$=fN([b,[y],w]),E=et(p,$),N=et(d,[y]),_=fN([[x],T,k]),R=he(E,_);let D=JD(R,N,h.shape[l]);const M=Jo(_);return D=he(D,M),D};if(o===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>Xi(d.map((y,b)=>c(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:c(s,r,n),indices:()=>r}}};function dN(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function fN(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const FY={kernelName:wd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>de(e),b:()=>de(s)}}};const LY={kernelName:Sd,gradFunc:n=>({x:()=>Et(n,"float32")})};const PY={kernelName:Cd,gradFunc:n=>({x:()=>de(n)})};const zY={kernelName:Td,gradFunc:n=>({x:()=>de(n)})};const BY={kernelName:kd,gradFunc:n=>({x:()=>de(n)})};const VY={kernelName:_g,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,i=sr(s,0);return{x:()=>cs(i,n,Y(n,r))}}};const UY={kernelName:Ed,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,wt(e,1))}}};const jY={kernelName:$d,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Et(e,"float32"))}}};const GY={kernelName:n6,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const o=xi(s);return Bt(n,Y(Mt(n,r,!0),o))}}}};function WY(n,t,e,s=5,r=1,i=1,o=.5){const l={x:n,y:t,dy:e},c={depthRadius:s,bias:r,alpha:i,beta:o};return J.runKernel(N1,l,c)}const HY=nt({localResponseNormalizationBackprop_:WY});const qY={kernelName:Lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:i,bias:o,alpha:l,beta:c}=e;return{x:()=>HY(s,r,n,i,o,l,c)}}};function GO(n,t,e,s){return t.rank<e.rank&&(t=et(t,dn(t.shape,s))),n.rank<e.rank&&(n=et(n,dn(n.shape,s))),{x:()=>Y(n,Et(bi(e,t),n.dtype))}}const pN={kernelName:Pg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,i=t[0],o=t[1],l=ee(r,i.shape),c=GO(n,o,i,l);return{x:()=>c.x()}}};const KY={kernelName:Id,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Y(n,Et(hl(e,s),"float32")),b:()=>Y(n,Et(Om(e,s),"float32"))}}};function XY(n,t,e,s,r,i,o){const l=V(n,"dy","maxPool3dGrad"),c=V(t,"input","maxPool3dGrad"),h=V(e,"output","maxPool3dGrad");let d=l,p=c,m=h,y=!1;c.rank===4&&(y=!0,d=et(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=et(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),m=et(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),L(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),L(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),L(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Ts("maxPool3dGrad",i,o);const b={dy:d,input:p,output:m},x={filterSize:s,strides:r,pad:i,dimRoundingMode:o},w=J.runKernel(_1,b,x);return y?et(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const YY=nt({maxPool3dGrad_:XY});const ZY={kernelName:Bg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=e;return{x:()=>YY(n,s,r,i,o,l,c)}}};function JY(n,t,e,s,r,i,o){const l=V(n,"dy","maxPoolGrad"),c=V(t,"input","maxPoolGrad"),h=V(e,"output","maxPoolGrad");L(c.rank===l.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${l.rank})`),L(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),L(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),Ts("maxPoolGrad",i,o);const d={dy:l,input:c,output:h},p={filterSize:s,strides:r,pad:i,dimRoundingMode:o};return J.runKernel(A1,d,p)}const QY=nt({maxPoolGrad_:JY});const tZ={kernelName:zg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:i,strides:o,pad:l}=e;return{x:()=>QY(n,s,r,i,o,l)}}};const eZ={kernelName:Vg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,i=ee(r,s.shape),l=Dn(s.shape,i)[1],c=ft(l);return{x:()=>{const d=s.shape.slice();i.forEach(y=>{d[y]=1});const p=et(n,d);return Lt(Y(p,ta(s.shape,"float32")),c)}}}};const nZ={kernelName:Ug,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[i,o]=t,l=ee(r,i.shape),c=GO(n,o,i,l);return{x:()=>c.x()}}};const sZ={kernelName:Nd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Y(n,Et(Jc(e,s),"float32")),b:()=>Y(n,Et(sr(e,s),"float32"))}}};const rZ={kernelName:jg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Fe(n,i,s.shape)}}};const iZ={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Tn(e.shape,r);return l.length>0?et(Mt(n,l),e.shape):n},b:()=>{const l=Y(n,sn(y0(Lt(e,s)))),c=Tn(s.shape,r);return c.length>0?et(Mt(l,c),s.shape):l}}}};const oZ={kernelName:_d,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Y(n,Et(s,"float32")),c=Tn(e.shape,r);return c.length>0?et(Mt(l,c),e.shape):l},b:()=>{const l=Y(n,Et(e,"float32")),c=Tn(s.shape,r);return c.length>0?et(Mt(l,c),s.shape):l}}}};const aZ={kernelName:Gg,gradFunc:n=>({x:()=>sn(n)})};const lZ={kernelName:qg,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>_n(e.shape,"float32")}}};const cZ={kernelName:Hg,gradFunc:n=>({x:()=>de(n)})};const uZ={kernelName:Kg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return il(n,s).map(i=>()=>i)}};const mN={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,i=r.map(o=>o[0]);return{x:()=>Fe(n,i,s.shape)}}};const hZ={kernelName:Rd,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,i=e,o=s,l=qt(i.shape,o.shape);return{a:()=>{const d=Et(o,"float32");let p=Y(n,Y(d,sl(i,Bt(d,ve(1)))));const m=Tn(i.shape,l);return m.length>0&&(p=Mt(p,m)),et(p,i.shape)},b:()=>{const d=sr(i,0),p=cs(d,vi(i),de(i));let m=Y(n,Y(r,p));const y=Tn(o.shape,l);return y.length>0&&(m=Mt(m,y)),et(m,o.shape)}}}};const dZ={kernelName:Yg,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=sr(e,0);return{x:()=>cs(r,n,Y(n,s)),alpha:()=>{let i=cs(r,de(n),Y(n,e));const o=Tn(s.shape,n.shape);return o.length>0&&(i=Mt(i,o)),et(i,s.shape)}}}};function fZ(n,t,e){const s=n.shape.slice();s[e]=1;const r=et(t,s),i=Hv(n,e,!0,!1),o=Hv(n,e,!0,!0),l=Y(i,o);return Y(r,l)}function pZ(n,t,e){const s=n.shape.length,r=s-e.length,i=Xe(e,s);let o=n;i!=null&&(o=he(n,i));const l=o.shape.slice(),h=l.splice(s-e.length,e.length).reduce((m,y)=>m*y,1);l.push(h);const d=o.reshape(l);let p=fZ(d,t,r);if(p=p.reshape(o.shape),i!=null){const m=Jo(i);p=he(p,m)}return p}const mZ={kernelName:Zg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let i=[];return r==null?i=s.shape.map((o,l)=>l):typeof r=="number"?i=[r]:i=r,{x:()=>pZ(s,n,i)}}};const gZ={kernelName:pd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{const l=Lt(n,Et(s,"float32")),c=Tn(e.shape,r);return c.length>0?et(Mt(l,c),e.shape):l},b:()=>{let l=Y(n,Et(e,"float32"));const c=Tn(s.shape,r);c.length>0&&(l=et(Mt(l,c),s.shape));const h=ze(s);return sn(Lt(l,Et(h,"float32")))}}}};const yZ={kernelName:Dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,sn(ze(e)))}}};const bZ={kernelName:Md,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Y(Jc(e,6),sf(e));return{x:()=>Y(n,Et(s,"float32"))}}};const xZ={kernelName:Od,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Et(sf(e),"float32"))}}};const vZ={kernelName:Jg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,e.shape)}}};const wZ={kernelName:t0,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>J.runKernel(P1,r,e)}}};const SZ={kernelName:Qg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>J.runKernel(L1,r,e)}}};const CZ={kernelName:e0,gradFunc:(n,t,e)=>{const{dims:s}=e,r=ee(s,n.shape);return{x:()=>rl(n,r)}}};const TZ={kernelName:Fd,gradFunc:n=>({x:()=>de(n)})};const kZ={kernelName:Ld,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>sn(Lt(n,Y(sl(e,1.5),2)))}}};const $Z={kernelName:n0,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Et(de(e),"float32"),t:()=>Y(n,Et(e,n.dtype)),e:()=>Y(n,Et(iS(e),n.dtype))}}};const EZ={kernelName:Pd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=sr(e,ve(0)),r=ve(v0),i=ve(w0),o=Y(n,i),l=Y(Y(n,r),xi(Et(e,"float32")));return cs(s,o,l)}}}};const IZ={kernelName:Ud,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Y(e,Bt(ve(1),e)))}}};const NZ={kernelName:Vd,gradFunc:n=>({x:()=>de(n)})};const AZ={kernelName:zd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(Q1(Et(e,"float32")),n)}}};const _Z={kernelName:Bd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(ND(Et(e,"float32")),n)}}};const RZ={kernelName:s0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:i}=e,o=s.shape,[l,c]=b0(s,r,i),h=[];for(let d=0;d<n.rank;d++)h.push([l[d],o[d]-l[d]-c[d]]);return{x:()=>lS(n,h)}}};const DZ={kernelName:a0,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,i=!0,o=Y(n,s);return{logits:()=>Bt(o,Y(Mt(o,[r],i),s))}}};const OZ={kernelName:jd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Zc(e))}}};const gN={kernelName:i0,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>Z1(n,s,r)}}};const yN={kernelName:o0,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>ws(n,s)}}};const MZ={kernelName:Gd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Y(Jn(Et(e,"float32")),2))}}};const FZ={kernelName:z1,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Y(Et(e,"float32"),2))}}};const LZ={kernelName:Wd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=ve(2);return{a:()=>Y(n,Y(r,Bt(e,s))),b:()=>Y(n,Y(r,Bt(s,e)))}}};const PZ={kernelName:Yd,gradFunc:n=>({x:()=>de(n)})};const zZ={kernelName:Hd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=qt(e.shape,s.shape);return{a:()=>{let l=n;const c=Tn(e.shape,r);return c.length>0&&(l=Mt(l,c)),et(l,e.shape)},b:()=>{let l=n;const c=Tn(s.shape,r);return c.length>0&&(l=Mt(l,c)),et(sn(l),s.shape)}}}};const BZ={kernelName:r0,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:i}=e;ee(i,s.shape).forEach(h=>{r[h]=1});const l=et(n,r),c=Y(l,ta(s.shape,"float32"));return{x:()=>c}}};const VZ={kernelName:qd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,ze(Q1(e)))}}};const UZ={kernelName:Kd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(Bt(ve(1),ze(e)),n)}}};const jZ={kernelName:Xd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let o=de(s);if(s.rank===1)for(let l=0;l<r[0];++l)o=wt(o,Fe(n,[l*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)o=wt(o,Fe(n,[l*s.shape[0],c*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let h=0;h<r[2];++h)o=wt(o,Fe(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let l=0;l<r[0];++l)for(let c=0;c<r[1];++c)for(let h=0;h<r[2];++h)for(let d=0;d<r[3];++d)o=wt(o,Fe(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};const GZ={kernelName:Ic,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,i=Jo(r);return{x:()=>he(n,i)}}};const WZ={kernelName:l0,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>Xi(n,r)}}};const HZ={kernelName:c0,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>qZ(n,e)}}};function qZ(n,t){const e=Qo(t,de(t)),s=nS(n,e);let r=hl(t,ve(0,"int32"));const i=s.rank-r.rank;for(let l=0;l<i;++l)r=bs(r,l+1);r=Ki(r,ta(s.shape,"bool"));const o=de(s);return cs(r,s,o)}const KZ={kernelName:u0,gradFunc:n=>({x:()=>de(n)})};const XZ=[jO,H7,q7,K7,X7,Y7,Z7,J7,Q7,tY,eY,nY,iY,lY,cY,uY,hY,dY,fY,pY,mY,gY,bY,yY,wY,SY,CY,TY,kY,$Y,gZ,EY,IY,NY,AY,_Y,DY,RY,OY,MY,FY,LY,PY,zY,BY,VY,UY,jY,GY,qY,pN,pN,KY,ZY,tZ,eZ,nZ,sZ,rZ,iZ,oZ,aZ,lZ,cZ,uZ,mN,mN,hZ,dZ,mZ,yZ,bZ,xZ,vZ,wZ,SZ,CZ,TZ,kZ,$Z,EZ,IZ,NZ,AZ,_Z,RZ,DZ,OZ,gN,gN,yN,yN,MZ,LZ,FZ,PZ,zZ,BZ,VZ,UZ,jZ,GZ,WZ,HZ,KZ];for(const n of XZ)i6(n);dt().prototype.abs=function(){return this.throwIfDisposed(),is(this)};dt().prototype.acos=function(){return this.throwIfDisposed(),xq(this)};dt().prototype.acosh=function(){return this.throwIfDisposed(),wq(this)};dt().prototype.add=function(n){return this.throwIfDisposed(),wt(this,n)};dt().prototype.all=function(n,t){return this.throwIfDisposed(),kD(this,n,t)};dt().prototype.any=function(n,t){return this.throwIfDisposed(),Gv(this,n,t)};dt().prototype.argMax=function(n){return this.throwIfDisposed(),Lh(this,n)};dt().prototype.argMin=function(n){return this.throwIfDisposed(),$q(this,n)};dt().prototype.asScalar=function(){return this.throwIfDisposed(),L(this.size===1,()=>"The array must have only 1 element."),et(this,[])};dt().prototype.asType=function(n){return this.throwIfDisposed(),Et(this,n)};dt().prototype.as1D=function(){return this.throwIfDisposed(),et(this,[this.size])};dt().prototype.as2D=function(n,t){return this.throwIfDisposed(),et(this,[n,t])};dt().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),et(this,[n,t,e])};dt().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),et(this,[n,t,e,s])};dt().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),et(this,[n,t,e,s,r])};dt().prototype.asin=function(){return this.throwIfDisposed(),Iq(this)};dt().prototype.asinh=function(){return this.throwIfDisposed(),Aq(this)};dt().prototype.atan=function(){return this.throwIfDisposed(),Rq(this)};dt().prototype.atan2=function(n){return this.throwIfDisposed(),Oq(this,n)};dt().prototype.atanh=function(){return this.throwIfDisposed(),Fq(this)};dt().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),Y1(this,n,t,e,s)};dt().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Z1(this,n,t)};dt().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),f0(this,n,t,e,s,r)};dt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Th(this,n)};dt().prototype.cast=function(n){return this.throwIfDisposed(),Et(this,n)};dt().prototype.ceil=function(){return this.throwIfDisposed(),c8(this)};dt().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),nr(this,n,t)};dt().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof xn&&(n=[n]),ws([this,...n],t)};dt().prototype.conv1d=function(n,t,e,s,r,i){return this.throwIfDisposed(),$D(this,n,t,e,s,r,i)};dt().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),ED(this,n,t,e,s,r)};dt().prototype.conv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),nl(this,n,t,e,s,r,i)};dt().prototype.cos=function(){return this.throwIfDisposed(),Q1(this)};dt().prototype.cosh=function(){return this.throwIfDisposed(),ND(this)};dt().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Hv(this,n,t,e)};dt().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),AD(this,n,t,e)};dt().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),O8(this,n,t)};dt().prototype.depthwiseConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),tS(this,n,t,e,s,r,i)};dt().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),L8(this,n,t,e,s,r)};dt().prototype.divNoNan=function(n){return this.throwIfDisposed(),U8(this,n)};dt().prototype.div=function(n){return this.throwIfDisposed(),Lt(this,n)};dt().prototype.dot=function(n){return this.throwIfDisposed(),G8(this,n)};dt().prototype.elu=function(){return this.throwIfDisposed(),m0(this)};dt().prototype.equal=function(n){return this.throwIfDisposed(),bi(this,n)};dt().prototype.erf=function(){return this.throwIfDisposed(),_D(this)};dt().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),nK(this,n,t)};dt().prototype.exp=function(){return this.throwIfDisposed(),xi(this)};dt().prototype.expandDims=function(n){return this.throwIfDisposed(),bs(this,n)};dt().prototype.expm1=function(){return this.throwIfDisposed(),oK(this)};dt().prototype.fft=function(){return this.throwIfDisposed(),XD(this)};dt().prototype.flatten=function(){return this.throwIfDisposed(),et(this,[this.size])};dt().prototype.floor=function(){return this.throwIfDisposed(),y0(this)};dt().prototype.floorDiv=function(n){return this.throwIfDisposed(),TD(this,n)};dt().prototype.gather=function(n,t,e){return this.throwIfDisposed(),nS(this,n,t,e)};dt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),hl(this,n)};dt().prototype.greater=function(n){return this.throwIfDisposed(),sr(this,n)};dt().prototype.ifft=function(){return this.throwIfDisposed(),qv(this)};dt().prototype.irfft=function(){return this.throwIfDisposed(),QX(this)};dt().prototype.isFinite=function(){return this.throwIfDisposed(),mK(this)};dt().prototype.isInf=function(){return this.throwIfDisposed(),yK(this)};dt().prototype.isNaN=function(){return this.throwIfDisposed(),xK(this)};dt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),rS(this,n)};dt().prototype.lessEqual=function(n){return this.throwIfDisposed(),Jc(this,n)};dt().prototype.less=function(n){return this.throwIfDisposed(),Om(this,n)};dt().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),TK(this,n,t,e,s)};dt().prototype.logSigmoid=function(){return this.throwIfDisposed(),_K(this)};dt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),FD(this,n)};dt().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),LD(this,n,t)};dt().prototype.log=function(){return this.throwIfDisposed(),vi(this)};dt().prototype.log1p=function(){return this.throwIfDisposed(),MD(this)};dt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ki(this,n)};dt().prototype.logicalNot=function(){return this.throwIfDisposed(),iS(this)};dt().prototype.logicalOr=function(n){return this.throwIfDisposed(),PD(this,n)};dt().prototype.logicalXor=function(n){return this.throwIfDisposed(),zK(this,n)};dt().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),xe(this,n,t,e)};dt().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),oS(this,n,t,e,s)};dt().prototype.max=function(n,t){return this.throwIfDisposed(),qr(this,n,t)};dt().prototype.maximum=function(n){return this.throwIfDisposed(),Qo(this,n)};dt().prototype.mean=function(n,t){return this.throwIfDisposed(),hn(this,n,t)};dt().prototype.min=function(n,t){return this.throwIfDisposed(),Dm(this,n,t)};dt().prototype.minimum=function(n){return this.throwIfDisposed(),Bh(this,n)};dt().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),qK(this,n,t)};dt().prototype.mod=function(n){return this.throwIfDisposed(),XK(this,n)};dt().prototype.mul=function(n){return this.throwIfDisposed(),Y(this,n)};dt().prototype.neg=function(){return this.throwIfDisposed(),sn(this)};dt().prototype.norm=function(n,t,e){return this.throwIfDisposed(),g0(this,n,t,e)};dt().prototype.notEqual=function(n){return this.throwIfDisposed(),Mm(this,n)};dt().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),zD(this,n,t,e)};dt().prototype.onesLike=function(){return this.throwIfDisposed(),$r(this)};dt().prototype.pad=function(n,t){return this.throwIfDisposed(),lS(this,n,t)};dt().prototype.pool=function(n,t,e,s,r,i){return this.throwIfDisposed(),iX(this,n,t,e,s,r,i)};dt().prototype.pow=function(n){return this.throwIfDisposed(),sl(this,n)};dt().prototype.prelu=function(n){return this.throwIfDisposed(),uS(this,n)};dt().prototype.prod=function(n,t){return this.throwIfDisposed(),lX(this,n,t)};dt().prototype.reciprocal=function(){return this.throwIfDisposed(),DX(this)};dt().prototype.relu=function(){return this.throwIfDisposed(),dl(this)};dt().prototype.relu6=function(){return this.throwIfDisposed(),VD(this)};dt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),et(this,n.shape)};dt().prototype.reshape=function(n){return this.throwIfDisposed(),et(this,n)};dt().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),tO(this,n,t,e)};dt().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),eO(this,n,t,e)};dt().prototype.reverse=function(n){return this.throwIfDisposed(),rl(this,n)};dt().prototype.rfft=function(){return this.throwIfDisposed(),n9(this)};dt().prototype.round=function(){return this.throwIfDisposed(),UD(this)};dt().prototype.rsqrt=function(){return this.throwIfDisposed(),jD(this)};dt().prototype.selu=function(){return this.throwIfDisposed(),GD(this)};dt().prototype.separableConv2d=function(n,t,e,s,r,i){return this.throwIfDisposed(),WD(this,n,t,e,s,r,i)};dt().prototype.sigmoid=function(){return this.throwIfDisposed(),Zc(this)};dt().prototype.sign=function(){return this.throwIfDisposed(),UX(this)};dt().prototype.sin=function(){return this.throwIfDisposed(),HD(this)};dt().prototype.sinh=function(){return this.throwIfDisposed(),qD(this)};dt().prototype.slice=function(n,t){return this.throwIfDisposed(),Fe(this,n,t)};dt().prototype.softmax=function(n){return this.throwIfDisposed(),pS(this,n)};dt().prototype.softplus=function(){return this.throwIfDisposed(),tf(this)};dt().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),cS(this,n,t)};dt().prototype.split=function(n,t){return this.throwIfDisposed(),er(this,n,t)};dt().prototype.sqrt=function(){return this.throwIfDisposed(),Jn(this)};dt().prototype.square=function(){return this.throwIfDisposed(),ze(this)};dt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),r9(this,n)};dt().prototype.squeeze=function(n){return this.throwIfDisposed(),nf(this,n)};dt().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof xn?[this,n]:[this,...n];return Xi(e,t)};dt().prototype.step=function(n){return this.throwIfDisposed(),sf(this,n)};dt().prototype.stridedSlice=function(n,t,e,s,r,i,o,l){return this.throwIfDisposed(),c9(this,n,t,e,s,r,i,o,l)};dt().prototype.sub=function(n){return this.throwIfDisposed(),Bt(this,n)};dt().prototype.sum=function(n,t){return this.throwIfDisposed(),Mt(this,n,t)};dt().prototype.tan=function(){return this.throwIfDisposed(),h9(this)};dt().prototype.tanh=function(){return this.throwIfDisposed(),d0(this)};dt().prototype.tile=function(n){return this.throwIfDisposed(),Wr(this,n)};dt().prototype.toBool=function(){return this.throwIfDisposed(),Et(this,"bool")};dt().prototype.toFloat=function(){return this.throwIfDisposed(),Et(this,"float32")};dt().prototype.toInt=function(){return this.throwIfDisposed(),Et(this,"int32")};dt().prototype.topk=function(n,t){return this.throwIfDisposed(),m9(this,n,t)};dt().prototype.transpose=function(n){return this.throwIfDisposed(),he(this,n)};dt().prototype.unique=function(n){return this.throwIfDisposed(),b9(this,n)};dt().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),JD(this,n,t)};dt().prototype.unstack=function(n){return this.throwIfDisposed(),il(this,n)};dt().prototype.where=function(n,t){return this.throwIfDisposed(),cs(n,this,t)};dt().prototype.zerosLike=function(){return this.throwIfDisposed(),de(this)};class oi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oi.prototype)}}class Sr extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Sr.prototype)}}class q extends Error{constructor(t){super(t),Object.setPrototypeOf(this,q.prototype)}}class Xt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Xt.prototype)}}class ZS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ZS.prototype)}}class WO{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function ol(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function ai(n,t){if(!n)throw new ZS(t)}function bN(n,t){let e=0;for(const s of n)s===t&&e++;return e}function xs(n){return n.length===1?n[0]:n}function Te(n){return Array.isArray(n)?n:[n]}function ji(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Fa(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let gr={};function JS(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function Yv(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>Yv(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:Yv(s))}}}function lf(n,t={},e={},s="object",r=!1){if(typeof n=="string"){const i=n;let o;if(i in e)o=e[i];else if(i in gr)o=gr[i];else if(o=t[i],o==null)throw new q(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new q(`${s}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let l,c;if(o in e?[l,c]=e[o]:o in gr?[l,c]=gr.className:o in t&&([l,c]=t[o]),l==null)throw new q(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const h={};for(const y of Object.keys(gr))h[y]=gr[y];for(const y of Object.keys(e))h[y]=e[y];const d=i.config;d.customObjects=h;const p=Object.assign({},gr);for(const y of Object.keys(e))gr[y]=e[y];Yv(i.config);const m=c(l,i.config,e,r);return gr=Object.assign({},p),m}else{const h=Object.assign({},gr);for(const p of Object.keys(e))gr[p]=e[p];const d=new l(i.config);return gr=Object.assign({},h),d}}}function YZ(n,t){return n<t?-1:n>t?1:0}function qp(n,t){return-1*YZ(n,t)}function Lo(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function ZZ(n){if(n==null)throw new q(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function pl(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new q(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function QS(n,t,e=0,s=1/0){return ai(e>=0),ai(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function Rn(n,t){Array.isArray(n)?(L(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Rn(e,`element ${s+1} of ${t}`))):L(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${HO(n)}.`)}function HO(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>HO(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function JZ(n,t,e){let s=e!=null?e():ys(),r;return(...o)=>{const l=e!=null?e():ys();return l-s<t||(s=l,r=n(...o)),r}}function qO(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let QZ=0;function KO(){return QZ++}const Kp={};function S0(n=""){return n in Kp||(Kp[n]=0),Kp[n]+=1,n+Kp[n].toString()}const tJ=["channelsFirst","channelsLast"],eJ=["nearest","bilinear"],nJ=["valid","same","causal"],sJ=["max","avg"],rJ=["sum","mul","concat","ave"];const hc=new Map;function an(n){pl(tJ,"DataFormat",n)}function iJ(n){pl(eJ,"InterpolationFormat",n)}function rr(n){pl(nJ,"PaddingMode",n)}function XO(n){pl(sJ,"PoolMode",n)}const kh=[],xN="/";function qa(n,t){kh.push(n);try{const e=t();return kh.pop(),e}catch(e){throw kh.pop(),e}}function oJ(){return kh.length===0?"":kh.join(xN)+xN}function YO(n){if(!JO(n))throw new Error("Not a valid tensor name: '"+n+"'");return oJ()+n}function ZO(n){if(!JO(n))throw new Error("Not a valid tensor name: '"+n+"'");hc.has(n)||hc.set(n,0);const t=hc.get(n);if(hc.set(n,hc.get(n)+1),t>0){const e=`${n}_${t}`;return hc.set(e,1),e}else return n}const aJ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function JO(n){return!!n.match(aJ)}function lJ(n){return n===parseInt(n.toString(),10)}function Po(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function zc(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function Uo(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function Xr(n,t){if(t<n)throw new q(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let Lx;function vn(){return Lx==null&&(Lx=R6().epsilon()),Lx}function Yr(){return"channelsLast"}function mi(n,t){return Et(n,t)}function cf(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),et(n,e)}function cJ(n,t){return rt(()=>{if(n.shape.length!==2)throw new q(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=cf(n,1);return Zv(e,[1,t,1])})}function uJ(n){const t=[Po(n.shape)];return et(n,t)}function hJ(n){if(n.rank<=1)throw new q(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Po(n.shape,1)];return et(n,t)}function Ka(n,t,e){return rt(()=>{switch(n.rank){case 1:return dS(n,t,e);case 2:return KD(n,[t,0],[e,n.shape[1]]);case 3:return fS(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Lm(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Fe(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Fe(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new q(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Px(n,t,e){return rt(()=>{switch(n.rank){case 1:return dS(n,t,e);case 2:return KD(n,[0,t],[n.shape[0],e]);case 3:return fS(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Lm(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new q(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Xp(n,t,e,s){return rt(()=>{switch(n.rank){case 1:return dS(n,t,e);case 2:switch(s){case 1:return Ka(n,t,e);case 2:return Px(n,t,e);default:throw new q(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Ka(n,t,e);case 2:return fS(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return Px(n,t,e);default:throw new q(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Ka(n,t,e);case 2:return Lm(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Lm(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return Px(n,t,e);default:throw new q(`The axis is not within the rank of the tensor ${s}`)}default:throw new q(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function tC(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),ws(n,t)}function vN(n,t){switch(n.rank){case 1:return d8([n,t]);case 2:return p8([n,t],0);case 3:return g8([n,t],0);case 4:return b8([n,t],0);default:throw new q(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Zv(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new q(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Wr(n,t)}function C0(n,t=0,e=1,s,r){return NX(n,t,e,s,r)}function gi(n,t,e,s){if(n.rank<2||t.rank<2)throw new Xt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const r=n.shape.slice(-1)[0],i=t.shape.slice(-2)[0];if(r!==i)throw new Xt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return rN({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Jv(n.rank,s,Yr()):null,activation:e});{const r=n.shape.slice(),i=r.pop();n=et(n,[-1,i]);const o=t.shape.slice(),l=o.pop(),c=o.pop(),h=[...o,l],d=Array.from({length:t.rank},(b,x)=>x===0?t.rank-2:x<=t.rank-2?x-1:x);t=et(he(t,d),[c,-1]);const p=[...r,...h];return et(rN({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Jv(n.rank,s,Yr()):null,activation:e}),p)}}function QO(n,t,e){return rt(()=>(Array.isArray(t)?t=Fs(t,"int32"):t=Et(t,"int32"),nS(n,t,e)))}function uf(n){return Y(n,n)}function Jv(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new q(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?et(t,[1,s[0],1,1,1]):et(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?et(t,[1,1,1,1,s[0]]):et(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?et(t,[1,s[0],1,1]):et(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?et(t,[1,1,1,s[0]]):et(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?et(t,[1,s[0],1]):et(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?et(t,[1,1,s[0]]):et(t,[1].concat(s))}else if(n<3)return t;throw new q(`Unsupported input rank by biasAdd: ${t.rank}`)}function Jr(n,t,e){return rt(()=>(e==null&&(e=Yr()),an(e),wt(n,Jv(n.rank,t,e))))}function dJ(n,t=1){if(t!==1)throw new Xt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return m0(n)}function fJ(n){return rt(()=>Lt(n,wt(is(n),1)))}function tM(n,t,e,s){return rt(()=>k9(n,t,e,s))}function pJ(n){return rt(()=>{const t=wt(.5,Y(.2,n));return nr(t,0,1)})}function hf(n,t,e=!1){return e?n():t()}const mJ=["fanIn","fanOut","fanAvg"],gJ=["normal","uniform","truncatedNormal"];function yJ(n){pl(mJ,"FanMode",n)}function bJ(n){pl(gJ,"Distribution",n)}class Ir extends tu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class eM extends Ir{apply(t,e){return _n(t,e)}}eM.className="Zeros";vt(eM);class eC extends Ir{apply(t,e){return ta(t,e)}}eC.className="Ones";vt(eC);class nM extends Ir{constructor(t){if(super(),typeof t!="object")throw new q(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new q(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return rt(()=>Y(ve(this.value),ta(t,e)))}getConfig(){return{value:this.value}}}nM.className="Constant";vt(nM);class sM extends Ir{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ef(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}sM.className="RandomUniform";vt(sM);class rM extends Ir{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Xt(`randomNormal does not support dType ${e}.`);return C0(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}rM.className="RandomNormal";vt(rM);class iM extends Ir{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Xt(`truncatedNormal does not support dType ${e}.`);return ZD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}iM.className="TruncatedNormal";vt(iM);class oM extends Ir{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return rt(()=>{if(t.length!==2||t[0]!==t[1])throw new q("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,OD(t[0]))})}getConfig(){return{gain:this.gain}}}oM.className="Identity";vt(oM);function xJ(n,t="channelsLast"){let e,s;if(an(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const r=Po(n,2);e=n[1]*r,s=n[0]*r}else if(t==="channelsLast"){const r=Po(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Po(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}class Ps extends Ir{constructor(t){if(super(),t.scale<0)throw new q(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,yJ(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,bJ(this.distribution),this.seed=t.seed}apply(t,e){const s=xJ(t),r=s[0],i=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(r+i)/2),this.distribution==="normal"){const l=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Xt(`${this.getClassName()} does not support dType ${e}.`);return ZD(t,0,l,e,this.seed)}else{const l=Math.sqrt(3*o);return ef(t,-l,l,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ps.className="VarianceScaling";vt(Ps);class nC extends Ps{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ps.className}}nC.className="GlorotUniform";vt(nC);class sC extends Ps{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ps.className}}sC.className="GlorotNormal";vt(sC);class rC extends Ps{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ps.className}}rC.className="HeNormal";vt(rC);class iC extends Ps{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ps.className}}iC.className="HeUniform";vt(iC);class oC extends Ps{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ps.className}}oC.className="LeCunNormal";vt(oC);class aC extends Ps{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ps.className}}aC.className="LeCunUniform";vt(aC);class aM extends Ir{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return rt(()=>{if(t.length<2)throw new Xt("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=ft(t.slice(0,-1)),r=t[t.length-1],i=s*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(r,s),Math.min(r,s)],l=C0(o,0,1,e,this.seed),c=w7.qr(l,!1);let h=c[0];const p=c[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return h=Y(h,p.sign()),s<r&&(h=h.transpose()),Y(ve(this.gain),h.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}aM.className="Orthogonal";vt(aM);const wN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function SN(n,t={}){return lf(n,vr.getMap().classNameMap,t,"initializer")}function Ke(n){return JS(n)}function je(n){if(typeof n=="string"){const t=n in wN?wN[n]:n;if(t==="GlorotNormal")return new sC;if(t==="GlorotUniform")return new nC;if(t==="HeNormal")return new rC;if(t==="HeUniform")return new iC;if(t==="LeCunNormal")return new oC;if(t==="LeCunUniform")return new aC;{const e={};return e.className=t,e.config={},SN(e)}}else return n instanceof Ir?n:SN(n)}function Qv(n){return Array.isArray(n)&&Array.isArray(n[0])}function Pm(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function jt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new q(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function pe(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new q(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function zm(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,r)=>s*r);return t}const CN="Variable";class vJ{constructor(t,e="float32",s=CN,r=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=KO(),s=s??CN,this.originalName=YO(s),this.name=ZO(this.originalName),this.trainable_=r,this.constraint=i,this.val=w9(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),wJ(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function wJ(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function tw(n){return n.map(t=>t.read())}function lC(n){n.forEach(t=>{t[0].write(t[1])})}class wn{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class wi{constructor(t,e,s,r,i,o,l){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=i,this.outputTensorIndex=l,this.id=KO(),o!=null&&(this.originalName=YO(o),this.name=ZO(this.originalName)),this.rank=e.length}}let SJ=0;class T0{constructor(t,e){this.callArgs=e,this.id=SJ++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let CJ=0;class ne extends tu{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=CJ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=ji(s)+"_"+S0(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let i=null;t.batchSize!=null&&(i=t.batchSize),s=[i].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;r==null&&(r=t.inputDType),r==null&&(r="float32"),this.dtype=r}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Sr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new q(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return xs(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return xs(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new oi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new oi(`Layer ${this.name} is not connected, no input to return.`);return xs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new oi(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new oi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return xs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=Te(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Te(this.inputSpec);if(e.length!==s.length)throw new q(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let r=0;r<e.length;r++){const i=e[r],o=s[r];if(o==null)continue;const l=i.rank;if(o.ndim!=null&&l!==o.ndim)throw new q(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${l}`);if(o.maxNDim!=null&&l>o.maxNDim)throw new q(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${l}`);if(o.minNDim!=null&&l<o.minNDim)throw new q(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${l}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new q(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const c=i.shape;for(const h in o.axes){const d=Number(h),p=o.axes[h],m=d>=0?c[d]:c[c.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new q(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${c}.`)}}if(o.shape!=null)for(let c=0;c<o.shape.length;++c){const h=o.shape[c],d=i.shape[c];if(h!=null&&d!=null&&h!==d)throw new q(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=Te(t),r=$J(t),i=EJ(t);if(r===i)throw new q("Arguments to apply() must be all SymbolicTensors or all Tensors");return qa(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const l of Te(t))o.push(l.shape);this.build(xs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const l=Te(o),c=[];for(let h of l)s.indexOf(h)!==-1&&(h=h.clone()),c.push(h);if(o=xs(c),this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=TJ(t),l=this.computeOutputShape(o);let c;const h=kJ(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l!=null&&l.length>0&&Array.isArray(l[0])?c=l.map((d,p)=>new wi(h,d,this,Te(t),e,this.name,p)):c=new wi(h,l,this,Te(t),e,this.name),this.addInboundNode(t,c,null,null,o,l,e),this._refCount++,this.activityRegularizer!=null)throw new Xt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&t[r]!=null&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new oi(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new oi(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Sr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return tw(t?this.trainableWeights:this.weights)}setWeights(t){rt(()=>{const e=this.weights;if(e.length!==t.length)throw new q(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],r=tw(e);for(let i=0;i<r.length;++i){const o=r[i],l=e[i],c=t[i];if(!we(o.shape,c.shape))throw new q(`Layer weight shape ${o.shape} not compatible with provided weight shape ${c.shape}`);s.push([l,c])}lC(s)})}addWeight(t,e,s,r,i,o,l,c){if(this._addedWeightNames.indexOf(t)!==-1)throw new q(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=c!=null?c():je("zeros"));const h=r.apply(e,s),d=new vJ(h,s,t,o,l);return h.dispose(),i!=null&&this.addLoss(()=>i.apply(d.read())),o==null&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Te(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const r=this.computeMask(t,s),i=Te(e),o=Te(r);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let l=0;l<i.length;l++)i[l].kerasMask=o[l]}addInboundNode(t,e,s,r,i,o,l=null){const c=Te(t);e=Te(e),s=Te(s),r=Te(r),i=Pm(i),o=Pm(o);const h=[],d=[],p=[];for(const m of c)h.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new T0({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:p,inputTensors:c,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:i,outputShapes:o},l);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function TJ(n){n=Te(n);const t=[];for(const e of n)t.push(e.shape);return xs(t)}function kJ(n){return"float32"}function lM(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let i=0;i<s.inboundLayers.length;i++){const o=s.inputTensors[i],l=s.inboundLayers[i],c=s.nodeIndices[i],h=lM(o,l,c);for(const d of h)r.indexOf(d)===-1&&r.push(d)}return r}}}function $J(n){let t=!0;for(const e of Te(n))if(!(e instanceof wi)){t=!1;break}return t}function EJ(n){let t=!0;for(const e of Te(n))if(e instanceof wi){t=!1;break}return t}class df extends ne{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:S0("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new q("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new q("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new q("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const r=new wi(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new T0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new q(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}df.className="InputLayer";vt(df);function IJ(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new q("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new df({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function NJ(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return Et(t,n.dtype)}catch{throw new q(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Do{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Do)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=NJ(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new q(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof wi){if(this.id2Value[t.id]==null)throw new q(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new q(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof wi){if(this.id2Value[t.id]==null)throw new q(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new q(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Qt(this.id2Mask)}}const Bm=new WO,Vm=new WO;function AJ(n){Bm?.setMaxEntries(n),Vm?.setMaxEntries(n)}function fh(n,t,e,s){const r=e==null?!1:e.training,i=Array.isArray(n),o=i?n:[n],l=o.map(b=>b.name),c=[],h=t.names();for(const b of l)h.indexOf(b)!==-1?c.push(t.getValue(b)):c.push(null);const d=l.join(",")+"|"+t.names().sort().join(",");let p=Bm.get(d),m;if(p==null){const b=_J(o,t);p=b.sorted,m=b.recipientCounts,Bm.put(d,p),Vm.put(d,m)}m={},r||Object.assign(m,Vm.get(d));const y=new Do(t);for(let b=0;b<p.length;++b){const x=p[b],w=x.sourceLayer;if(w instanceof df)continue;const S=[],T=[],k=[];let $=!1;for(const D of x.inputs){const M=y.getValue(D),A=y.getMask(D);S.push(M),T.push(A),A!=null&&($=!0),r||(m[D.name]--,m[D.name]===0&&!t.hasKey(D)&&l.indexOf(D.name)===-1&&!M.isDisposed&&D.sourceLayer.stateful!==!0&&k.push(M))}$&&(e=e||{},e.mask=T[0]);const E=Te(w.apply(S,e));let N=null;w.supportsMasking&&(N=w.computeMask(S,T));const _=DJ(x),R=Array.isArray(_)?_:[_];for(let D=0;D<R.length;++D){y.hasKey(R[D])||y.add(R[D],E[D],Array.isArray(N)?N[0]:N);const M=l.indexOf(R[D].name);M!==-1&&(c[M]=E[D])}r||Qt(k)}return y.disposeMasks(),i?c:c[0]}function _J(n,t){L(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const r=TN(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of n){const{sorted:o,recipientMap:l}=TN(i,t);for(const c of o)r.has(c.name)||(e.push(c),r.add(c.name));for(const c in l)s[c]==null&&(s[c]=new Set),l[c].forEach(h=>s[c].add(h))}}return{sorted:e,recipientCounts:RJ(s)}}function RJ(n){const t={};for(const e in n)t[e]=n[e].size;return t}function TN(n,t){const e=new Set,s=[],r={};for(const l of t.names())e.add(l);const i=[],o=[];for(i.push(n);i.length>0;){const l=i[i.length-1];if(e.has(l.name)){i.pop();continue}const c=o[o.length-1]===i.length-1;if(l.inputs.length===0||c)i.pop(),s.push(l),e.add(l.name),c&&o.pop();else{o.push(i.length-1);for(const h of l.inputs)r[h.name]==null&&(r[h.name]=new Set),r[h.name].add(l.name),!e.has(h.name)&&i.push(h)}}return{sorted:s,recipientMap:r}}function DJ(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}const OJ=lt();OJ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,AJ);function cC(n,t){return rt(()=>Jn(Mt(Y(n,n),t,!0)))}class ff extends tu{getConfig(){return{}}}class cM extends ff{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return rt(()=>{const e=cC(t,this.axis),s=nr(e,0,this.maxValue);return Y(t,Lt(s,wt(vn(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}cM.className="MaxNorm";vt(cM);class uM extends ff{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return rt(()=>Lt(t,wt(vn(),cC(t,this.axis))))}getConfig(){return{axis:this.axis}}}uM.className="UnitNorm";vt(uM);class hM extends ff{apply(t){return dl(t)}}hM.className="NonNeg";vt(hM);class dM extends ff{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return rt(()=>{const e=cC(t,this.axis),s=wt(Y(this.rate,nr(e,this.minValue,this.maxValue)),Y(1-this.rate,e));return Y(t,Lt(s,wt(vn(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}dM.className="MinMaxNorm";vt(dM);const kN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Sn(n){return JS(n)}function $N(n,t={}){return lf(n,vr.getMap().classNameMap,t,"constraint")}function Cn(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in kN?kN[n]:n,config:{}};return $N(e)}else return n instanceof ff?n:$N(n)}async function Ea(n){if(n==null)return;const t=[],e=[],s=[];for(const r in n){const i=n[r];if(typeof i!="number"){const o=i;t.push(o.data()),e.push(r),s.push(o)}}if(t.length>0){const r=await Promise.all(t);for(let i=0;i<r.length;++i)n[e[i]]=r[i][0];Qt(s)}}function fM(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var EN;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(EN||(EN={}));const MJ=125;class Uh{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class FJ{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class LJ extends Uh{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const r in e){const i=e[r];if(typeof i=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+i*s;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const l=rt(()=>wt(this.totals[r],Y(i,s)));this.totals[r]=l,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:rt(()=>{const r=Y(Lt(1,this.seen),this.totals[s]);e[s]=r,this.totals[s].dispose(),fi(e[s])}))}}class PJ extends Uh{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const i in this.history){const o=this.history[i];for(let l=0;l<o.length;++l)if(typeof o[l]!="number"){const c=o[l];t.push(c.data()),e.push(i),s.push(l)}}const r=await Promise.all(t);for(let i=0;i<r.length;++i)this.history[e[i]][s[i]].dispose(),this.history[e[i]][s[i]]=r[i][0]}}class zJ extends Uh{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||bO,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=MJ),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Av(this.yieldEvery)&&(this.maybeWait=JZ(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const r=[];this.yield!=null&&(await Ea(s),r.push(this.yield(t,e,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Ea(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Ea(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Ea(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Ea(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Av(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Ea(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ea(t),await this.trainEnd(t))}}function pM(n,t){return n==null&&(n={}),n instanceof Uh?[n]:Array.isArray(n)&&n[0]instanceof Uh?n:Te(n).map(s=>new zJ(s,t))}class xr{constructor(){}static registerCallbackConstructor(t,e){L(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),xr.checkForDuplicate(e),xr.constructors[t]==null&&(xr.constructors[t]=[]),xr.constructors[t].push(e)}static checkForDuplicate(t){for(const e in xr.constructors)xr.constructors[+e].forEach(r=>{if(r===t)throw new q("Duplicate callback constructor.")})}static clear(){xr.constructors={}}static createCallbacks(t){const e=[];for(const s in xr.constructors){const r=+s;t>=r&&e.push(...xr.constructors[r])}return e.map(s=>new s)}}xr.constructors={};function mM(n,t,e,s,r,i,o,l,c){const h=new PJ,d=[new LJ,...xr.createCallbacks(t)];n!=null&&d.push(...n),d.push(h);const p=new FJ(d);return p.setParams({epochs:e,initialEpoch:s,samples:r,steps:i,batchSize:o,verbose:t,doValidation:l,metrics:c}),{callbackList:p,history:h}}function yi(n,t={},e=!1){return lf(n,vr.getMap().classNameMap,t,"layer",e)}function Um(n,t){return rt(()=>{n.dtype!=="float32"&&(n=Et(n,"float32"));const e=Mt(uf(n),t,!0),s=p0(e.shape,vn()),r=Jn(Qo(e,s));return Lt(n,r)})}function k0(n,t){return rt(()=>hn(uf(Bt(t,n)),-1))}function uC(n,t){return rt(()=>hn(is(Bt(t,n)),-1))}function hC(n,t){return rt(()=>{const e=Bt(n,t),s=nr(is(n),vn(),Number.MAX_VALUE),r=is(Lt(e,s));return Y(100,hn(r,-1))})}function BJ(n,t){return rt(()=>{const e=nr(t,vn(),Number.MAX_VALUE),s=vi(wt(1,e)),r=nr(n,vn(),Number.MAX_VALUE),i=vi(wt(1,r));return hn(uf(Bt(s,i)),-1)})}function VJ(n,t){return rt(()=>{const e=Qo(0,Bt(1,Y(n,t)));return hn(uf(e),-1)})}function UJ(n,t){return rt(()=>{const e=Qo(0,Bt(1,Y(n,t)));return hn(e,-1)})}function jJ(n,t){return rt(()=>{const e=Mt(Y(n,t),-1),s=qr(Y(Bt(1,n),t),-1);return Qo(0,wt(1,Bt(s,e)))})}function GJ(n,t){return rt(()=>{const e=Math.log(2),s=Bt(t,n),r=Bt(wt(s,tf(Y(-2,s))),e);return hn(r,-1)})}function jh(n,t,e=!1){return rt(()=>{if(e)t=pS(t);else{const s=Mt(t,t.shape.length-1,!0);t=Lt(t,s)}return t=nr(t,vn(),1-vn()),sn(Mt(Y(Et(n,"float32"),vi(t)),t.shape.length-1))})}function jm(n,t,e=!1){return rt(()=>{const s=Et(y0(uJ(n)),"int32");t=nr(t,vn(),1-vn());const r=t.shape,i=et(zD(s,r[r.length-1]),r);return jh(i,t,e)})}function WJ(n,t){if(!we(n.shape,t.shape))throw new q(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return rt(()=>{const e=dl(t),s=sn(is(t));return wt(Bt(e,Y(t,n)),MD(xi(s)))})}function $0(n,t){return rt(()=>{let e;return e=nr(t,vn(),1-vn()),e=vi(Lt(e,Bt(1,e))),hn(WJ(n,e),-1)})}function HJ(n,t){return rt(()=>{const e=nr(n,vn(),1),s=nr(t,vn(),1);return Mt(Y(n,vi(Lt(e,s))),-1)})}function qJ(n,t){return rt(()=>{const e=vi(wt(vn(),t));return hn(Bt(t,Y(n,e)),-1)})}function gM(n,t){return rt(()=>{const e=Um(n,-1),s=Um(t,-1),r=Y(e,s);return sn(Mt(r,-1))})}const Gm={meanSquaredError:k0,meanAbsoluteError:uC,meanAbsolutePercentageError:hC,meanSquaredLogarithmicError:BJ,squaredHinge:VJ,hinge:UJ,categoricalHinge:jJ,logcosh:GJ,categoricalCrossentropy:jh,sparseCategoricalCrossentropy:jm,binaryCrossentropy:$0,kullbackLeiblerDivergence:HJ,poisson:qJ,cosineProximity:gM};function zx(n){if(typeof n=="string"){if(n in Gm)return Gm[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new q(t)}else return n}function yM(n,t){return rt(()=>{const e=Y(.5,$r(t)),s=mi(sr(t,e),n.dtype);return hn(bi(n,s),-1)})}function bM(n,t){return rt(()=>mi(bi(Lh(n,-1),Lh(t,-1)),"float32"))}function KJ(n,t){return rt(()=>Et(Mt(Ki(bi(n,1),bi(t,1))),"float32"))}function XJ(n,t){return rt(()=>Et(Mt(Ki(bi(n,0),bi(t,1))),"float32"))}function YJ(n,t){return rt(()=>{const e=KJ(n,t),s=XJ(n,t),r=wt(e,s);return Et(cs(sr(r,0),Lt(e,r),0),"float32")})}function ZJ(n,t){return $0(n,t)}function JJ(n,t){return n.rank===t.rank&&(n=nf(n,[n.rank-1])),t=Lh(t,-1),t.dtype!==n.dtype&&(t=Et(t,n.dtype)),Et(bi(n,t),"float32")}const QJ=k0,tQ=k0,eQ=uC,nQ=uC,sQ=hC,rQ=hC,xM=jh,iQ=gM,vM=jm,Wm={binaryAccuracy:yM,categoricalAccuracy:bM,precision:YJ,categoricalCrossentropy:xM,sparseCategoricalCrossentropy:vM,mse:QJ,MSE:tQ,mae:eQ,MAE:nQ,mape:sQ,MAPE:rQ,cosine:iQ};function oQ(n){if(typeof n=="string"&&n in Wm)return Wm[n];if(typeof n!="string"&&n!=null)return n;throw new q(`Unknown metric ${n}`)}function Yp(n){if(ai(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(Gm))if(Gm[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(Wm))if(Wm[e]===n){t=e;break}return t!==void 0?t:n.name}}function aQ(n){const t={Adagrad:()=>uc.adagrad(.01),Adadelta:()=>uc.adadelta(1,.95,vn()),Adam:()=>uc.adam(.001,.9,.999,vn()),Adamax:()=>uc.adamax(.002,.9,.999,vn(),0),RMSProp:()=>uc.rmsprop(.001,.9,0,vn()),SGD:()=>uc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new q(`Unknown Optimizer ${n}`)}const IN=1*1024*1024;function NN(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!ew(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>IN&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${IN}.`)}}function ew(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!ew(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!ew(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function lQ(n,t,e,s=console.log){const r=uQ(n),i=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(t*d)));let o;if(!r){i.push("Receives inputs"),o=[];for(const d in n.nodesByDepth)o.push(...n.nodesByDepth[d])}s("_".repeat(t)),Hm(i,e,s),s("=".repeat(t));const l=n.layers;for(let d=0;d<l.length;++d)r?hQ(l[d],e,s):dQ(l[d],e,o,s),s((d===l.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const c=cQ(n),h=zm(n.nonTrainableWeights);s(`Total params: ${c+h}`),s(`Trainable params: ${c}`),s(`Non-trainable params: ${h}`),s("_".repeat(t))}function cQ(n){let t;return n.collectedTrainableWeights!=null?t=zm(n.collectedTrainableWeights):t=zm(n.trainableWeights),t}function uQ(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let i=!1;for(const o of r.inboundNodes)if(s.indexOf(o)!==-1)if(i){t=!1;break}else i=!0;if(!t)break}return t}function Hm(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function hQ(n,t,e){let s,r;try{r=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const i=n.name,o=n.getClassName(),l=[`${i} (${o})`,r,s,n.countParams().toString()];Hm(l,t,e)}function dQ(n,t,e,s){let r,i;try{i=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const o=[];for(const p of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const y=p.inboundLayers[m].name,b=p.nodeIndices[m],x=p.tensorIndices[m];o.push(`${y}[${b}][${x}]`)}const l=n.name,c=n.getClassName(),h=o.length===0?"":o[0],d=[`${l} (${c})`,i,r,n.countParams().toString(),h];Hm(d,t,s);for(let p=1;p<o.length;++p)Hm(["","","","",o[p]],t,s)}function wM(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function qm(n,t){if(n===null)return null;if(typeof n=="string")return Fa(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];wM(t,r,i)?e.push(i):e.push(qm(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")e[s]=r;else{const i=Fa(s);e[i]=qm(r,i)}}return e}}function nw(n,t){if(n==null)return null;if(typeof n=="string")return ji(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const i=n[r];wM(t,r,i)?e.push(i):e.push(nw(i,t))}return e}else{const e={};for(const s of Object.keys(n)){const r=n[s],i=ji(s);(s==="name"||s==="className")&&typeof r=="string"?e[i]=r:e[i]=nw(r,s)}return e}}const SM="4.22.0";const fQ=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class Br extends ne{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=S0(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Lo(this.inputs).length!==this.inputs.length)throw new q(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Lo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push($),this.outputLayersTensorIndices.push(E)}for(const T of this.inputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;ai($===0,"input layer has >1 nodes"),ai(E===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push($),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const k=this.inputLayers[T];if(!(k instanceof df))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${T} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const e={},s={},r={},i={},o={},l=[],c=(T,k,$,E,N,_)=>{(E==null||N==null||_==null)&&(E=T.sourceLayer,N=T.nodeIndex,_=T.tensorIndex);const R=E.inboundNodes[N];if($.indexOf(R)!==-1)throw new Sr(`The tensor ${T.name} at layer "${E.name}" is part of a cycle.`);if(k.indexOf(R)!==-1)return;this.containerNodes.add(Br.nodeKey(E,N)),E.id in o||(o[E.id]=Object.keys(o).length),$.indexOf(R)===-1&&$.push(R);const D=R.inboundLayers.length;for(let M=0;M<D;M++){const A=R.inputTensors[M],B=R.inboundLayers[M],H=R.nodeIndices[M],W=R.tensorIndices[M];c(A,k,$,B,H,W)}for(k.push(R);$.indexOf(R)>=0;)$.splice($.indexOf(R),1);l.push(R)},h=[],d=[];for(const T of this.outputs)c(T,h,d);const p=l.slice().reverse();for(const T of p){s[T.id]=T,T.id in e||(e[T.id]=0);let k=e[T.id];const $=r[T.outboundLayer.id]==null?0:r[T.outboundLayer.id];k=Math.max(k,$),r[T.outboundLayer.id]=k,i[T.outboundLayer.id]=T.outboundLayer,e[T.id]=k;for(let E=0;E<T.inboundLayers.length;E++){const N=T.inboundLayers[E],_=T.nodeIndices[E],R=N.inboundNodes[_],D=e[R.id]==null?0:e[R.id];e[R.id]=Math.max(k+1,D),s[R.id]=R}}const m={};for(const T in e){const k=e[T];k in m||(m[k]=[]),m[k].push(s[T])}const y={};for(const T in r){const k=r[T];k in y||(y[k]=[]),y[k].push(i[T])}let b=Object.keys(y).map(T=>parseInt(T,10)).sort(qp);this.layers=[];for(const T of b){const k=y[T];k.sort(($,E)=>{const N=o[$.id],_=o[E.id];return N<_?-1:N>_?1:0});for(const $ of k)$ instanceof Br&&this.internalContainerRefs.push($),this.layers.push($)}this.layersByDepth=y,b=Object.keys(m).map(T=>parseInt(T,10)).sort(qp);const x=this.inputs.slice(),w=[];for(const T of b)for(const k of m[T]){const $=k.outboundLayer;if($!=null){for(const E of k.inputTensors)if(x.indexOf(E)===-1)throw new Sr(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${$.name}". The following previous layers were accessed without issue: ${w}`);for(const E of k.outputTensors)x.push(E);w.push($.name)}}this.nodesByDepth=m;const S=this.layers.map(T=>T.name);for(const T of S){const k=S.filter($=>$===T).length;if(k!==1)throw new Sr(`The name "${T}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new T0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new q("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;const i=fQ(t);i&&this.parseWeights(t);for(const l of this.layers)for(const[c,h]of l.weights.entries()){const d=i?`${h.name.split("/").slice(0,-1).join("/")+"/"}${c}`:h.originalName;if(s[d]!=null)throw new q(`Duplicate weight name: ${d}`);s[d]=h,r++}const o=[];for(const l in t){let c=l;if(s[l]==null){const h=l.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[c]!=null)o.push([s[c],t[l]]);else if(e)throw new q(`Provided weight data has no target variable: ${l}`);delete s[c]}if(e){const l=[];for(const c in s)l.push(c);if(l.length>0)throw new q(`${l.length} of ${r} weights are not set: ${l}`)}lC(o)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),r=["vars","layer_checkpoint_dependencies"],i=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");i!==e&&(t[i]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${SM}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=nw(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return rt(()=>{t=Te(t);const s=new Do;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return fh(this.outputs,s,e)})}computeMask(t,e){return rt(()=>{t=Te(t);let s;return e==null?s=ol(null,t.length):s=Te(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=Pm(t);if(e.length!==this.inputLayers.length)throw new q(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let l=0;l<e.length;l++){const c=this.inputLayers[l],h=e[l],d=c.name+"_0_0";s[d]=h}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(qp);if(r.length>1)for(const l of r){const c=this.nodesByDepth[l];for(const h of c){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const p=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],S=h.nodeIndices[x],T=h.tensorIndices[x],k=`${w.name}_${S}_${T}`,$=s[k];p.push($)}const m=d.computeOutputShape(xs(p)),y=Pm(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const i=[],o=[];for(let l=0;l<this.outputLayers.length;l++){const c=this.outputLayers[l],h=this.outputLayersNodeIndices[l],d=this.outputLayersTensorIndices[l],p=`${c.name}_${h}_${d}`;o.push(p)}for(let l=0;l<o.length;l++){const c=o[l];ai(c in s),i.push(s[c])}return xs(i)}runInternalGraph(t,e){e==null&&(e=ol(null,t.length));const s={};for(let c=0;c<this.inputs.length;++c){const h=this.inputs[c],d=t[c],p=e[c];s[h.id]=[d,p]}const r=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(qp);for(const c of r){const h=this.nodesByDepth[c];for(const d of h){const p=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,S,T,k;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[$,E]=b[0];x.mask==null&&(x.mask=E),T=Te(p.call($,x)),k=Te(p.computeMask($,E)),w=[$],S=[E]}else w=b.map($=>$[0]),S=b.map($=>$[1]),x.mask==null&&(x.mask=S),T=Te(p.call(w,x)),k=Te(p.computeMask(w,S));if(p.activityRegularizer)throw new Xt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let $=0;$<y.length;++$){const E=y[$],N=T[$],_=k[$];s[E.id]=[N,_]}}}}const i=[],o=[],l=[];for(const c of this.outputs){ai(c.id in s,`Could not compute output ${c.name} : ${c.id}`);const[h,d]=s[c.id];l.push(h.shape),i.push(h),o.push(d)}return[i,o,l]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof Br?1:0;for(let i=0;i<r.inboundNodes.length;i++){const o=Br.nodeKey(r,i);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new q("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new q(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new q(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return rt(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=Br.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const l=o.getClassName(),c=o.getConfig(),h=[];for(let p=0;p<o.inboundNodes.length;p++){const m=o.inboundNodes[p],y=Br.nodeKey(o,p);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const S=m.inboundLayers[w],T=m.nodeIndices[w],k=m.tensorIndices[w],$=Br.nodeKey(S,T);let E=e[$];E==null&&(E=0),x.push([S.name,E,k,b])}h.push(x)}}}const d={};d.name=o.name,d.className=l,d.config=c,d.inboundNodes=h,s.push(d)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const l=this.inputLayers[o],c=this.inputLayersNodeIndices[o],h=Br.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=e[h];d==null&&(d=0);const p=this.inputLayersTensorIndices[o];r.push([l.name,d,p])}t.inputLayers=r;const i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=Br.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=e[h];d==null&&(d=0);const p=this.outputLayersTensorIndices[o];i.push([l.name,d,p])}return t.outputLayers=i,t}static fromConfig(t,e,s={},r=!1){const i={},o={};function l(w,S){w.name in o?o[w.name].push(S):o[w.name]=[S]}function c(w,S){const T=[];let k;for(const $ of S){const E=$[0],N=$[1],_=$[2];if(k=$[3]==null?{}:$[3],!(E in i)){l(w,S);return}const R=i[E];if(R.inboundNodes.length<=N){l(w,S);return}const D=R.inboundNodes[N];T.push(D.outputTensors[_])}T.length>0&&w.apply(xs(T),k)}function h(w){const S=w.name,T=yi(w,e.customObjects!=null?e.customObjects:{});T.setFastWeightInitDuringBuild(r),i[S]=T,w.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new q(`Corrupted configuration, expected array for nodeData: ${$}`);l(T,$)})}const d=e.name,p=e.layers;for(const w of p)h(w);for(;!ZZ(o);)for(const w of p){const S=i[w.name];if(S.name in o){const T=o[S.name];delete o[S.name];for(const k of T)c(S,k)}}const m=[],y=[],b=e.inputLayers;for(const w of b){const S=w[0],T=w[1],k=w[2];ai(S in i);const E=i[S].inboundNodes[T].outputTensors;m.push(E[k])}const x=e.outputLayers;for(const w of x){const S=w[0],T=w[1],k=w[2];ai(S in i);const E=i[S].inboundNodes[T].outputTensors;y.push(E[k])}return new t({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new q("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){rt(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function pQ(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return t.forEach(i=>{i in n?r.push(n[i]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function CM(n,t){return pQ(n,t,"classWeight")}async function TM(n,t,e,s){if(e!=null){const r=rt(()=>{if(n.shape.length===1)return Ha(n);if(n.shape.length===2){if(n.shape[1]>1)return Lh(n,1);if(n.shape[1]===1)return et(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await r.data());Qt(r);const o=[];return i.forEach(l=>{if(e[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);o.push(e[l])}),Fs(o,"float32")}else return null}function mQ(n,t){return Y(n,t)}const gQ=32;function kM(n,t){let e,s;const r=t;e=r.xs,s=r.ys,L(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=AN("input",n.inputNames,e),o=AN("output",n.outputNames,s),l=i[0].shape[0];L(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),L(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<i.length;c++)L(i[c].shape[0]===l,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${i[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);for(let c=0;c<o.length;c++)L(o[c].shape[0]===l,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${o[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function AN(n,t,e){if(e instanceof xn)return[e];if(Array.isArray(e))return L(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(e[r]==null)throw new q(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function yQ(n){if(n.length===3)throw new Xt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function bQ(n,t,e){const s=e.batchesPerEpoch!=null;if(L(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),L(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),L(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),L(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),L(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=e.validationData!=null;let i,o;if(r)if(_N(e.validationData))L(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const w=yQ(e.validationData);i=w.xs,o=w.ys}const l=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let h;r?h=c.slice().concat(c.map(w=>"val_"+w)):h=c.slice();const d=pM(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:y}=mM(d,p,e.epochs,null,null,xQ(t,e),null,r,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=e.initialEpoch==null?0:e.initialEpoch,x=await t.iterator();for(;b<e.epochs;){const w={};await m.onEpochBegin(b);let S=0,T=0;for(s||(x=await t.iterator());!s||S<e.batchesPerEpoch;){const k=await x.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:$,ys:E}=kM(n,k.value),N={};N.batch=T,N.size=$[0].shape[0],await m.onBatchBegin(T,N);const _=[];if(e.classWeight!=null){const M=CM(e.classWeight,n.outputNames);for(let A=0;A<M.length;++A)_.push(await TM(E[A],null,M[A]))}const R=$.concat(E).concat(_),D=l(R);Qt(R);for(let M=0;M<c.length;++M){const A=c[M],B=D[M];N[A]=B,fi(B)}await m.onBatchEnd(T,N),fM(N),T++,S++}if(s?S>=e.batchesPerEpoch:k.done){if(r){let $;_N(e.validationData)?$=Te(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):$=Te(n.evaluate(i,o,{batchSize:e.validationBatchSize==null?gQ:e.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=$[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function xQ(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function _N(n){return typeof n.iterator=="function"}function vQ(n){return typeof n.next=="function"}async function wQ(n,t,e){e=e||{};const s=e.batches!=null,r=n.testFunction;let i=[];if(e.verbose>0)throw new Xt("Verbose mode is not implemented yet.");L(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=vQ(t)?t:await t.iterator();let l=0,c=0;for(;!s||c<e.batches;){const h=await o.next();if(i=rt(()=>{if(h.value){const{xs:d,ys:p}=kM(n,h.value),m=d.concat(p),y=rt(()=>r(m));if(Qt(m),c===0)for(let x=0;x<y.length;++x)i.push(ve(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],S=i[x];i[x]=rt(()=>wt(i[x],Y(b,w))),c>0&&Qt(S)}Qt(y),l+=b,++c}return i}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<i.length;++h){const d=i[h];i[h]=Lt(i[h],l),Qt(d)}return xs(i)}function Bx(n){L(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function oh(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>Ka(s,t,e-t)):Ka(n,t,e-t)}function sw(n,t){return rt(()=>n==null?null:Array.isArray(n)?n.map(e=>sw(e,t)):QO(n,t.dtype==="int32"?t:Et(t,"int32")))}function Vx(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}function $M(n){const t=[];n instanceof xn&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(cf(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Lr(n,t){if(n==null)return;const e=[];if(t instanceof xn)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(t!=null)for(const r in t){const i=t[r];e.push(i.id)}const s=[];if(n instanceof xn)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{e.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const i=n[r];e.indexOf(i.id)===-1&&s.push(i)}s.forEach(r=>{r.isDisposed||r.dispose()})}function SQ(n){return n instanceof xn}function rw(n){return Array.isArray(n)}function RN(n){return!SQ(n)&&!rw(n)}function DN(n,t,e,s=!0,r=""){if(t==null||t.length===0){if(n!=null){let o=!1;if(rw(n)&&n.length>0)o=!0;else if(RN(n)){for(const l in n)if(n.hasOwnProperty(l)){o=!0;break}}else o=!0;if(o)throw new q(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(o=>null);let i;if(RN(n)){n=n,i=[];for(const o of t){if(n[o]==null)throw new q(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(rw(n)){if(n=n,n.length!==t.length)throw new q(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,t.length>1)throw new q(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=$M(i),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const l=i[o];if(l.shape.length!==e[o].length)throw new q(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${l.shape}`);for(let c=0;c<e[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=e[o][c];if(d!=null&&d>=0&&h!==d)throw new q(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${l.shape[0]} examples, each with shape [${l.shape.slice(1,l.shape.length)}] (tensor shape [${l.shape}])`)}}return i}function CQ(n,t,e){const s=Lo(n.map(i=>i.shape[0]));s.sort();const r=Lo(t.map(i=>i.shape[0]));if(r.sort(),s.length>1)throw new q(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(r.length>1)throw new q(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(s.length>0&&r.length>0&&!we(s,r))throw new q(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function TQ(n,t,e){const s=[k0,$0,jh];for(let r=0;r<n.length;++r){const i=n[r],o=t[r],l=e[r];if(o!=null){if(o===jh&&i.shape[i.shape.length-1]===1)throw new q(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const c=i.shape.slice(1),h=l.slice(1);for(let d=0;d<c.length;++d){const p=c[d],m=h[d];if(m!=null&&p!==m)throw new q(`A target Tensor with shape ${i.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function ON(n,t,e,s=!0,r=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new q(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new q(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const l=i[o];if(l.shape.length!==e[o].length)throw new q(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let c=0;c<e[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=e[o][c];if(d!=null&&d!==h)throw new q(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function kQ(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let i=e.hasOwnProperty(r)?e[r]:[];Array.isArray(i)||(i=[i]),s.push(i)}return s}}const $Q="layers-model";class Ac extends Br{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new q("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");lQ(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=aQ(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof ea))throw new q("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new q(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(zx(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new q(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(l=>zx(l))}else{const o=zx(t.loss);this.outputs.forEach(l=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const l=this.internalOutputShapes[o],c=this.outputNames[o];this.feedOutputNames.push(c),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],qa("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([l,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=kQ(t.metrics,this.outputNames),i=(o,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[o]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,o])};qa("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=r[o];(h=>{let p,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[o];w[w.length-1]===1||this.lossFunctions[o]===$0?["accuracy","acc"].indexOf(b)!==-1?m=yM:["crossentropy","ce"].indexOf(b)!==-1&&(m=ZJ):this.lossFunctions[o]===jm?["accuracy","acc"].indexOf(b)!==-1?m=JJ:["crossentropy","ce"].indexOf(b)!==-1&&(m=vM):["accuracy","acc"].indexOf(b)!==-1?m=bM:["crossentropy","ce"].indexOf(b)!==-1&&(m=xM);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,p=""+S}else y=oQ(b),p=""+Yp(b);let x;qa(p,()=>{x=y}),i(o,p,x)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const r=s.batchSize==null?32:s.batchSize;Bx(r);const o=this.standardizeUserDataXY(t,e,!0,r);try{const l=o[0].concat(o[1]);this.makeTestFunction();const c=this.testFunction,h=this.testLoop(c,l,r,s.verbose,s.steps);return xs(h)}finally{Lr(o[0],t),Lr(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),wQ(this,t,e)}checkNumSamples(t,e,s,r="steps"){let i;if(s!=null){if(i=null,e!=null)throw new q(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?i=t[0].shape[0]:i=t.shape[0];else throw new q(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new q("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),r=s?e:[e],i=this.retrieveSymbolicTensors(r),o=new Do;if(t instanceof xn&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new q(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)o.add(this.inputs[c],t[c])}else for(const c of this.inputs){const h=t[c.name];if(h==null)throw new q(`No value is provided for the model's input ${c.name}`);o.add(c,h)}const l=fh(i,o);return s?l:l[0]}retrieveSymbolicTensors(t){const e=ol(null,t.length);let s=t.length;for(const r of this.layers){const i=Array.isArray(r.output)?r.output:[r.output],o=i.map(l=>l.name);for(let l=0;l<t.length;++l){const c=o.indexOf(t[l]);if(c!==-1&&(e[l]=i[c],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw e.forEach((i,o)=>{i==null&&r.push(t[o])}),new q(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return e}predictLoop(t,e=32,s=!1){return rt(()=>{const r=this.checkNumSamples(t);if(s)throw new Xt("Verbose predictLoop() is not implemented yet.");const i=Vx(r,e),o=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)rt(()=>{const h=i[l][0],d=i[l][1],p=oh(t,h,d),m=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)m.push({key:this.inputs[b],value:p[b]});else m.push({key:this.inputs[0],value:p});const y=new Do(m);return fh(this.outputs,y)}).forEach((h,d)=>o[d].push(h));return xs(o.map(l=>ws(l,0)))})}predict(t,e={}){const s=$M(t);ON(s,this.inputNames,this.feedInputShapes,!1);try{const r=e.batchSize==null?32:e.batchSize;return Bx(r),this.predictLoop(s,r)}finally{Lr(s,t)}}predictOnBatch(t){ON(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,r){if(this.optimizer_==null)throw new Sr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const l=this.feedOutputShapes[o];this.feedLossFns[o]===jm?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(t=DN(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=DN(e,this.feedOutputNames,i,!1,"target"),CQ(t,e),TQ(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&t[0].shape[0]%r!==0)throw new q(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,r,i=!0,o){const[l,c]=this.standardizeUserDataXY(t,e,i,o);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(r!=null){const d=CM(r,this.outputNames);h=[];for(let p=0;p<d.length;++p)h.push(await TM(c[p],null,d[p]))}return[l,c,h]}testLoop(t,e,s,r=0,i){return rt(()=>{const o=this.checkNumSamples(e,s,i,"steps"),l=[];if(r>0)throw new Xt("Verbose mode is not implemented yet.");if(i!=null)throw new Xt("steps mode in testLoop() is not implemented yet");{const c=Vx(o,s),h=Fs(Xr(0,o));for(let d=0;d<c.length;++d){const p=c[d][0],m=c[d][1],y=Ka(h,p,m-p),b=sw(e,y),x=t(b);if(d===0)for(let w=0;w<x.length;++w)l.push(ve(0));for(let w=0;w<x.length;++w){const S=x[w];l[w]=wt(l[w],Y(m-p,S))}}for(let d=0;d<l.length;++d)l[d]=Lt(l[d],o)}return l})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const r=t[s];let i=r;if(bN(t,r)>1){const o=bN(t.slice(0,s),r);i+=`_${o}`}e.push(i)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],l=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const m=new Do(p),y=fh(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let S=w(r[x],y[x]);i[x]!=null&&(S=mQ(S,i[x]));const T=hn(S);e.push(T),x===0?b=S:b=wt(b,S)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=e[x];else{const S=this.metricsTensors[x][0],T=this.metricsTensors[x][1];w=hn(S(r[T],y[T]))}fi(w),o.push(w)}return b=hn(b),this.calculateLosses().forEach(x=>{b=wt(b,x)}),b},c=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(l,!0,c)].concat(o)}}makeTestFunction(){this.testFunction=t=>rt(()=>{const e=[];let s;const r=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let h=0;h<this.inputs.length;++h)o.push({key:this.inputs[h],value:r[h]});const l=new Do(o),c=fh(this.outputs,l);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],p=hn(d(i[h],c[h]));h===0?s=p:s=wt(s,p),e.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],p=this.metricsTensors[h][1],m=hn(d(i[p],c[p]));e.push(m)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,i,o,l,c,h,d,p,m;try{const y=s.batchSize==null?32:s.batchSize;Bx(y);const x=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,y);r=x[0],i=x[1],m=x[2];let w=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)c=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Xt("validationData including sample weights is not supported yet."):new q(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const M=await this.standardizeUserData(c,h,null,null,!0,y);d=M[0],p=M[1],S=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const D=Math.floor(r[0].shape[0]*(1-s.validationSplit)),M=r[0].shape[0];d=oh(r,D,M),o=r,r=oh(r,0,D),p=oh(i,D,M),l=i,i=oh(i,0,D),S=d.concat(p)}else s.validationSteps!=null&&(w=!0);const T=r.concat(i).concat(m);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),$=this.getDedupedMetricsNames();let E,N;w?(this.makeTestFunction(),E=this.testFunction,N=$.slice().concat($.map(D=>"val_"+D))):(E=null,S=[],N=$.slice());const _=pM(s.callbacks,s.yieldEvery);return await this.fitLoop(k,T,$,y,s.epochs,s.verbose,_,E,S,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,Lr(r,t),Lr(i,e),Lr(o,t),Lr(l,e),Lr(d,c),Lr(p,h),m!=null&&Qt(m)}}async fitLoop(t,e,s,r,i,o,l,c,h,d,p,m,y,b){r==null&&(r=32),i==null&&(i=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(c!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new q("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(e,r,y,"steps_per_epoch");let S;w!=null&&(S=Xr(0,w)),o==null&&(o=1);const{callbackList:T,history:k}=mM(l,o,i,m,w,y,r,x,p);T.setModel(this),this.history=k,await T.onTrainBegin(),this.stopTraining_=!1;for(let $=m;$<i;++$){await T.onEpochBegin($);const E={};if(y!=null)throw new Xt("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Xt("batch shuffling is not implemneted yet");d&&V5(S);const N=Fs(S),_=Vx(w,r);for(let R=0;R<_.length;++R){const D={};if(await T.onBatchBegin(R,D),rt(()=>{const M=_[R][0],A=_[R][1],B=Ka(N,M,A-M);D.batch=R,D.size=A-M;const H=sw(e,B),W=t(H);for(let X=0;X<s.length;++X){const P=s[X],U=W[X];D[P]=U,fi(U)}if(R===_.length-1&&x){const X=this.testLoop(c,h,r);for(let P=0;P<s.length;++P){const U=s[P],G=X[P];fi(G),E["val_"+U]=G}}}),await T.onBatchEnd(R,D),fM(D),this.stopTraining_)break}N.dispose()}if(await T.onEpochEnd($,E),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return bQ(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),r=s[0],i=s[1],l=this.makeTrainFunction()(r.concat(i)),c=[];for(const h of l){const d=await h.data();c.push(d[0])}return Qt(l),Lr(s[0],t),Lr(s[1],e),xs(c)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,r=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let o=0;o<r.length;++o)s&&!r[o].trainable||e.push({name:r[o].originalName,tensor:i[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=jI().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-jI().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=ji(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>ji(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const r of e)if(typeof s[r]=="string")t[r]=ji(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ji(Yp(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>ji(Yp(t)));{const t={};for(const e in this.metrics)t[e]=ji(Yp(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=qm(t.optimizer_config),s=yi(e);let r;if(typeof t.loss=="string")r=Fa(t.loss);else if(Array.isArray(t.loss))r=t.loss.map(o=>Fa(o));else if(t.loss!=null){r={};for(const o in t.loss)r[o]=Fa(t.loss[o])}let i;if(Array.isArray(t.metrics))i=t.metrics.map(o=>Fa(o));else if(t.metrics!=null){i={};for(const o in t.metrics)i[o]=Fa(t.metrics[o])}this.compile({loss:r,metrics:i,optimizer:s})}async save(t,e){if(typeof t=="string"){const h=q6(t);if(h.length===0)throw new q(`Cannot find any save handlers for URL '${t}'`);if(h.length>1)throw new q(`Found more than one (${h.length}) save handlers for URL '${t}'`);t=h[0]}if(t.save==null)throw new q("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await WI(this.getNamedWeights(e)),l={modelTopology:this.toJSON(null,!1),format:$Q,generatedBy:`TensorFlow.js tfjs-layers v${SM}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:p}=await WI(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=z6([s.data,d])}return this.userDefinedMetadata!=null&&(NN(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=s.data,l.weightSpecs=s.specs,t.save(l)}setUserDefinedMetadata(t){NN(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ac.className="Model";vt(Ac);class EM extends Ac{}EM.className="Functional";vt(EM);async function EQ(n,t){if(t==null&&(t={}),typeof n=="string"){const e=K6(n,t);if(e.length===0)e.push(_7(n,t));else if(e.length>1)throw new q(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return IQ(n,void 0,t)}async function IQ(n,t,e){if(e==null&&(e={}),n.load==null)throw new q("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const i=e.strict==null?!0:e.strict,o=s.weightData!=null&&s.weightSpecs!=null&&i,l=yi(qm(r),t,o),c=s.trainingConfig;if(c!=null&&l.loadTrainingConfig(c),s.userDefinedMetadata!=null&&l.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new q("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=NQ(s.weightData,s.weightSpecs);l.loadWeights(h,i),l.optimizer!=null&&d.length>0&&await l.optimizer.setWeights(d),Qt(h),Qt(d.map(p=>p.tensor))}return l}function NQ(n,t){const e=D6(n,t),s={},r=[];return t.forEach(i=>{i.group==="optimizer"?r.push({name:i.name,tensor:e[i.name]}):s[i.name]=e[i.name]}),{modelWeights:s,optimizerWeights:r}}class Gh extends Ac{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:S0("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new q(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof Gh||t instanceof Ac;let s;if(e){if(s=t,s.outputs.length!==1)throw new q("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new q("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new q("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=IJ({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new q(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new q("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=lM(this.outputs[0])}this.inboundNodes=[],new T0({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ol(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(pe(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ac({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new Sr("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new Sr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new Sr("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new Sr("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},r=!1){let i,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new q("Legacy serialization format not supported yet.");i=e}else L(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=e.layers,delete e.layers,o=e;const l=new t(o);if(!(l instanceof Gh))throw new Xt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of i){const d=yi(c,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(t){if(this.model==null)throw new q("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new q("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}Gh.className="Sequential";vt(Gh);let ts=class extends tu{getConfig(){return{}}};class IM extends ts{apply(t,e=1){return dJ(t,e)}}IM.className="elu";vt(IM);class NM extends ts{apply(t){return GD(t)}}NM.className="selu";vt(NM);class AM extends ts{apply(t){return dl(t)}}AM.className="relu";vt(AM);class _M extends ts{apply(t){return rt(()=>Bh(6,dl(t)))}}_M.className="relu6";vt(_M);class RM extends ts{apply(t){return t}}RM.className="linear";vt(RM);class DM extends ts{apply(t){return Zc(t)}}DM.className="sigmoid";vt(DM);class OM extends ts{apply(t){return pJ(t)}}OM.className="hardSigmoid";vt(OM);class MM extends ts{apply(t){return tf(t)}}MM.className="softplus";vt(MM);class FM extends ts{apply(t){return fJ(t)}}FM.className="softsign";vt(FM);class LM extends ts{apply(t){return d0(t)}}LM.className="tanh";vt(LM);let dC=class extends ts{apply(t,e=-1){return pS(t,e)}};dC.className="softmax";vt(dC);class PM extends ts{apply(t,e=-1){return FD(t,e)}}PM.className="logSoftmax";vt(PM);class zM extends ts{apply(t){return rt(()=>rt(()=>{const e=Math.sqrt(2),s=Y(.5,wt(1,_D(Lt(t,e))));return Y(t,s)}))}}zM.className="gelu";vt(zM);class BM extends ts{apply(t){return rt(()=>Y(.5,Y(t,wt(1,d0(Y(Jn(Lt(2,Math.PI)),wt(t,Y(.044715,sl(t,3)))))))))}}BM.className="gelu_new";vt(BM);class VM extends ts{apply(t){return rt(()=>Y(t,d0(tf(t))))}}VM.className="mish";vt(VM);class UM extends ts{apply(t,e=1){return rt(()=>Y(Zc(Y(t,e)),t))}}UM.className="swish";vt(UM);function jo(n){return n.getClassName()}function Ux(n,t={}){return lf(n,vr.getMap().classNameMap,t,"activation")}function Go(n){if(n==null){const t={};return t.className="linear",t.config={},Ux(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},Ux(t)}else return n instanceof ts?n:Ux(n)}function AQ(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class jM extends tu{}class GM extends jM{constructor(t){super(),AQ(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return rt(()=>{let e=_n([1]);return this.hasL1&&(e=wt(e,Mt(Y(this.l1,is(t))))),this.hasL2&&(e=wt(e,Mt(Y(this.l2,uf(t))))),et(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}GM.className="L1L2";vt(GM);const MN={l1l2:"L1L2"};function Re(n){return JS(n)}function FN(n,t={}){return lf(n,vr.getMap().classNameMap,t,"regularizer")}function Ge(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in MN?MN[n]:n,config:{}};return FN(e)}else return n instanceof jM?n:FN(n)}class WM extends ne{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=jt(t);let s=dl(t);return this.maxValue!=null&&(s=nr(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}WM.className="ReLU";vt(WM);class HM extends ne{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=jt(t);return rS(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}HM.className="LeakyReLU";vt(HM);class qM extends ne{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=je(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ge(t.alphaRegularizer),this.alphaConstraint=Cn(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new q(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=pe(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)e[r-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<t.length;++r)s[r]=t[r];this.inputSpec=[new wn({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=jt(t),uS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Ke(this.alphaInitializer),alphaRegularizer:Re(this.alphaRegularizer),alphaConstraint:Sn(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}qM.className="PReLU";vt(qM);let KM=class extends ne{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Xt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=jt(t);return m0(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};KM.className="ELU";vt(KM);class XM extends ne{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=jt(t);return Y(s,Et(sr(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}XM.className="ThresholdedReLU";vt(XM);class YM extends ne{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new dC().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return rt(()=>{let s=jt(t);const r=e.mask;if(r!=null){const i=Y(Bt(ta(s.shape),Et(r,s.dtype)),ve(-1e9));s=wt(s,i)}return this.axis instanceof Array?this.axis.length>1?xi(Bt(s,LD(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}YM.className="Softmax";vt(YM);function _c(n,t,e){if(typeof n=="number")return ol(n,t);if(n.length!==t)throw new q(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!lJ(r))throw new q(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Kr(n,t,e,s,r=1){if(n==null)return n;const i=t+(t-1)*(r-1);let o;return e==="same"?o=n:o=n-i+1,Math.floor((o+s-1)/s)}function li(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+Uo([e-t,0]);else if(s==="same")n=n*t;else throw new q(`Unsupport padding mode: ${s}.`);return n}function fC(n,t){return rt(()=>(an(t),t==="channelsFirst"?he(n,[0,2,3,1]):n))}function ZM(n,t){return rt(()=>(an(t),t==="channelsFirst"?he(n,[0,2,3,4,1]):n))}function _Q(n,t,e,s=1,r="valid",i,o=1){return rt(()=>{if(i==null&&(i=Yr()),an(i),n.shape.length!==3)throw new q(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new q(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new q(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=he(n,[0,2,1])),r==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=$D(n,t,s,r==="same"?"same":"valid","NWC",o);return e!=null&&(l=Jr(l,e)),l})}function LN(n,t,e,s=[1,1],r="valid",i,o,l=null){return rt(()=>{if(i==null&&(i=Yr()),an(i),n.rank!==3&&n.rank!==4)throw new q(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new q(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=fC(n,i);if(r==="causal")throw new Xt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=I9({x:c,filter:t,strides:s,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:l}),i==="channelsFirst"&&(c=he(c,[0,3,1,2])),c})}function RQ(n,t,e,s=[1,1,1],r="valid",i,o){return rt(()=>{if(i==null&&(i=Yr()),an(i),n.rank!==4&&n.rank!==5)throw new q(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new q(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let l=ZM(n,i);if(r==="causal")throw new Xt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=T8(l,t,s,r==="same"?"same":"valid","NDHWC",o),e!=null&&(l=Jr(l,e)),i==="channelsFirst"&&(l=he(l,[0,4,1,2,3])),l})}class E0 extends ne{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",E0.verifyArgs(e),this.rank=t,Rn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Xt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=_c(e.kernelSize,t,"kernelSize"),this.strides=_c(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,rr(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,an(this.dataFormat),this.activation=Go(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=je(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Cn(e.biasConstraint),this.biasRegularizer=Ge(e.biasRegularizer),this.activityRegularizer=Ge(e.activityRegularizer),this.dilationRate=_c(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new q(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new q(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new q(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ai("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!QS(t.kernelSize,"number",1,3))throw new q(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:jo(this.activation),useBias:this.useBias,biasInitializer:Ke(this.biasInitializer),biasRegularizer:Re(this.biasRegularizer),activityRegularizer:Re(this.activityRegularizer),biasConstraint:Sn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class eu extends E0{constructor(t,e){super(t,e),this.kernel=null,eu.verifyArgs(e),this.filters=e.filters,Rn(this.filters,"filters"),this.kernelInitializer=je(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Cn(e.kernelConstraint),this.kernelRegularizer=Ge(e.kernelRegularizer)}build(t){t=pe(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new q(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return rt(()=>{t=jt(t);let s;const r=this.bias==null?null:this.bias.read(),i=qO(this.activation.getClassName());if(i!=null&&this.rank===2)s=LN(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)s=_Q(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=LN(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=RQ(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Xt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=pe(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<s.length;++i){const o=Kr(s[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);e.push(o)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:Ke(this.kernelInitializer),kernelRegularizer:Re(this.kernelRegularizer),kernelConstraint:Sn(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new q(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class pf extends eu{constructor(t){super(2,t),pf.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!QS(t.kernelSize,"number",1,2))throw new q(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}pf.className="Conv2D";vt(pf);class mf extends eu{constructor(t){super(3,t),mf.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new q(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}mf.className="Conv3D";vt(mf);class JM extends pf{constructor(t){if(super(t),this.inputSpec=[new wn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new q(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=pe(t),t.length!==4)throw new q("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new q("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return rt(()=>{let s=jt(t);if(s.shape.length!==4)throw new q(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l;this.dataFormat==="channelsFirst"?(o=2,l=3):(o=1,l=2);const c=r[o],h=r[l],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=li(c,m,d,this.padding),x=li(h,y,p,this.padding),w=[i,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=he(s,[0,2,3,1]));let S=ED(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=he(S,[0,3,1,2])),this.bias!=null&&(S=Jr(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=pe(t);const e=t.slice();let s,r,i;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3):(s=3,r=1,i=2);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1];return e[s]=this.filters,e[r]=li(e[r],c,o,this.padding),e[i]=li(e[i],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}JM.className="Conv2DTranspose";vt(JM);class QM extends mf{constructor(t){if(super(t),this.inputSpec=[new wn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new q(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=pe(t),t.length!==5)throw new q("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new q("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return rt(()=>{let s=jt(t);if(s.shape.length!==5)throw new q(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,i=r[0];let o,l,c;this.dataFormat==="channelsFirst"?(c=2,o=3,l=4):(c=1,o=2,l=3);const h=r[c],d=r[o],p=r[l],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],S=this.strides[2],T=li(h,x,m,this.padding),k=li(d,w,y,this.padding),$=li(p,S,b,this.padding),E=[i,T,k,$,this.filters];this.dataFormat!=="channelsLast"&&(s=he(s,[0,2,3,4,1]));let N=E8(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=he(N,[0,4,1,2,3])),this.bias!==null&&(N=Jr(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=pe(t);const e=t.slice();let s,r,i,o;this.dataFormat==="channelsFirst"?(s=1,r=2,i=3,o=4):(s=4,r=1,i=2,o=3);const l=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return e[s]=this.filters,e[r]=li(e[r],d,l,this.padding),e[i]=li(e[i],p,c,this.padding),e[o]=li(e[o],m,h,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}QM.className="Conv3DTranspose";vt(QM);class t3 extends eu{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new q("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new q("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new q(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=je(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ge(e.depthwiseRegularizer),this.depthwiseConstraint=Cn(e.depthwiseConstraint),this.pointwiseInitializer=je(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ge(e.pointwiseRegularizer),this.pointwiseConstraint=Cn(e.pointwiseConstraint)}build(t){if(t=pe(t),t.length<this.rank+2)throw new q(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new q(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],r=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new wn({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return rt(()=>{t=jt(t);let s;if(this.rank===1)throw new Xt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=he(t,[0,2,3,1])),s=WD(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Jr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=he(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ke(this.depthwiseInitializer),t.pointwiseInitializer=Ke(this.pointwiseInitializer),t.depthwiseRegularizer=Re(this.depthwiseRegularizer),t.pointwiseRegularizer=Re(this.pointwiseRegularizer),t.depthwiseConstraint=Sn(this.depthwiseConstraint),t.pointwiseConstraint=Sn(this.pointwiseConstraint),t}}t3.className="SeparableConv";class e3 extends t3{constructor(t){super(2,t)}}e3.className="SeparableConv2D";vt(e3);class I0 extends eu{constructor(t){super(1,t),I0.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!QS(t.kernelSize,"number",1,1))throw new q(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}I0.className="Conv1D";vt(I0);class n3 extends ne{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return rt(()=>{if(t=jt(t),this.dataFormat==="channelsLast"){const s=Xp(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Xp(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Xp(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Xp(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}n3.className="Cropping2D";vt(n3);class s3 extends ne{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,an(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,iJ(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return rt(()=>{let s=jt(t);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=he(s,[0,2,3,1]);const i=this.size[0]*r[2],o=this.size[1]*r[3],l=this.interpolation==="nearest"?Wi.resizeNearestNeighbor(s,[i,o]):Wi.resizeBilinear(s,[i,o]);return he(l,[0,3,1,2])}else{const i=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Wi.resizeNearestNeighbor(s,[i,o]):Wi.resizeBilinear(s,[i,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}s3.className="UpSampling2D";vt(s3);function DQ(n,t,e=[1,1],s="valid",r,i){return rt(()=>{r==null&&(r=Yr()),an(r);let o=fC(n,r);if(n.rank!==4)throw new q(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new q(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=tS(o,t,e,s==="same"?"same":"valid","NHWC",i),r==="channelsFirst"&&(o=he(o,[0,3,1,2])),o})}class r3 extends E0{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=je(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Cn(t.depthwiseConstraint),this.depthwiseRegularizer=Ge(t.depthwiseRegularizer)}build(t){if(t=pe(t),t.length<4)throw new q(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new q(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return rt(()=>{t=jt(t);let s=DQ(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Jr(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=pe(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=Kr(e,this.kernelSize[0],this.padding,this.strides[0]),o=Kr(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],r,i,o]:[t[0],i,o,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ke(this.depthwiseInitializer),t.depthwiseRegularizer=Re(this.depthwiseRegularizer),t.depthwiseConstraint=Sn(this.depthwiseRegularizer),t}}r3.className="DepthwiseConv2D";vt(r3);function i3(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new q("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(i){return i==null||Array.isArray(i)?i:[i]}return t=r(t),e=r(e),{inputs:n,initialState:t,constants:e}}function o3(n,t,e,s=!1,r,i,o=!1,l=!1){return rt(()=>{const c=t.shape.length;if(c<3)throw new q(`Input should be at least 3D, but is ${c}D.`);const h=[1,0].concat(Xr(2,c));t=he(t,h),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Et(Et(r,"bool"),"float32"),r.rank===c-1&&(r=bs(r,-1)),r=he(r,h)),s&&(t=rl(t,0),r!=null&&(r=rl(r,0)));const d=[];let p,m=e;const y=t.shape[0],b=il(t);let x;r!=null&&(x=il(r));for(let S=0;S<y;++S){const T=b[S],k=rt(()=>n(T,m));if(r==null)p=k[0],m=k[1];else{const $=rt(()=>{const E=x[S],N=Bt($r(E),E),_=wt(Y(k[0],E),Y(m[0],N)),R=m.map((D,M)=>wt(Y(k[1][M],E),Y(D,N)));return{output:_,newStates:R}});p=$.output,m=$.newStates}l&&d.push(p)}let w;return l&&(w=Xi(d,1)),[p,w,m]})}class na extends ne{constructor(t){super(t);let e;if(t.cell==null)throw new q("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new gC({cells:t.cell}):e=t.cell,e.stateSize==null)throw new q("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new wn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Xr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Qv(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let r;if(this.returnSequences?r=[t[0],t[1],s]:r=[t[0],s],this.returnState){const i=[];for(const o of e)i.push([t[0],o]);return[r].concat(i)}else return r}computeMask(t,e){return rt(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const r=this.states.map(i=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Xt("Constants support is not implemented in RNN yet.");Qv(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new wn({shape:[e,null,...s]});const r=[t[0]].concat(t.slice(2));this.cell.build(r);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!we(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new q(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new wn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){rt(()=>{if(!this.stateful)throw new oi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new q("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>_n([s,r])):this.states_=[_n([s,this.cell.stateSize])];else if(t==null)Qt(this.states_),this.keptStates!=null&&(Qt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>_n([s,r])):this.states_[0]=_n([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new q(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Qt(this.states_);for(let r=0;r<this.states_.length;++r){const i=t[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,l=[s,o];if(!we(i.shape,l))throw new q(`State ${r} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[r]=i}}this.states_=this.states_.map(r=>fi(r.clone()))})}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=i3(t,s,r,this.numConstants);t=i.inputs,s=i.initialState,r=i.constants;let o=[],l=[];if(s!=null){e.initialState=s,o=o.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new wn({shape:h.shape}));l=l.concat(this.stateSpec)}if(r!=null&&(e.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof wi){const h=[t].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return rt(()=>{const s=e==null?null:e.mask,r=e==null?null:e.training;let i=e==null?null:e.initialState;t=jt(t),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new q(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:r},h=o3((b,x)=>{const w=this.cell.call([b].concat(x),l);return[w[0],w.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],p=h[1],m=h[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?p:d;return this.returnState?[y].concat(m):y})}getInitialState(t){return rt(()=>{let e=_n(t.shape);return e=Mt(e,[1,2]),e=cf(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Zv(e,[1,s]):e):this.cell.stateSize>1?[Zv(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===na.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const r=e.cell,i=yi(r,s);return new t(Object.assign(e,{cell:i}))}}na.className="RNN";vt(na);class N0 extends ne{}class pC extends N0{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Rn(this.units,"units"),this.activation=Go(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=je(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=je(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=je(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ge(t.kernelRegularizer),this.recurrentRegularizer=Ge(t.recurrentRegularizer),this.biasRegularizer=Ge(t.biasRegularizer),this.kernelConstraint=Cn(t.kernelConstraint),this.recurrentConstraint=Cn(t.recurrentConstraint),this.biasConstraint=Cn(t.biasConstraint),this.dropout=zc([1,Uo([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=zc([1,Uo([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=pe(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return rt(()=>{if(t=t,t.length!==2)throw new q(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const r=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wo({ones:()=>$r(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wo({ones:()=>$r(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,l=this.recurrentDropoutMask;o!=null?i=gi(Y(t,o),this.kernel.read()):i=gi(t,this.kernel.read()),this.bias!=null&&(i=Jr(i,this.bias.read())),l!=null&&(s=Y(s,l));let c=wt(i,gi(s,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:jo(this.activation),useBias:this.useBias,kernelInitializer:Ke(this.kernelInitializer),recurrentInitializer:Ke(this.recurrentInitializer),biasInitializer:Ke(this.biasInitializer),kernelRegularizer:Re(this.kernelRegularizer),recurrentRegularizer:Re(this.recurrentRegularizer),biasRegularizer:Re(this.biasRegularizer),activityRegularizer:Re(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),recurrentConstraint:Sn(this.recurrentConstraint),biasConstraint:Sn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}pC.className="SimpleRNNCell";vt(pC);class a3 extends na{constructor(t){t.cell=new pC(t),super(t)}call(t,e){return rt(()=>{this.cell.dropoutMask!=null&&(Qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return new t(e)}}a3.className="SimpleRNN";vt(a3);class mC extends N0{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new q("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Rn(this.units,"units"),this.activation=Go(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Go(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=je(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=je(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=je(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ge(t.kernelRegularizer),this.recurrentRegularizer=Ge(t.recurrentRegularizer),this.biasRegularizer=Ge(t.biasRegularizer),this.kernelConstraint=Cn(t.kernelConstraint),this.recurrentConstraint=Cn(t.recurrentConstraint),this.biasConstraint=Cn(t.biasConstraint),this.dropout=zc([1,Uo([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=zc([1,Uo([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=pe(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return rt(()=>{if(t=t,t.length!==2)throw new q(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wo({ones:()=>$r(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wo({ones:()=>$r(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h;0<this.dropout&&this.dropout<1&&(t=Y(t,i[0]));let d=gi(t,this.kernel.read());this.useBias&&(d=Jr(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,o[0]));const p=this.recurrentKernel.read(),[m,y]=er(p,[2*this.units,this.units],p.rank-1),b=gi(r,m),[x,w,S]=er(d,3,d.rank-1),[T,k]=er(b,2,b.rank-1);l=this.recurrentActivation.apply(wt(x,T)),c=this.recurrentActivation.apply(wt(w,k));const $=gi(Y(c,r),y);h=this.activation.apply(wt(S,$));const E=wt(Y(l,r),Y(wt(1,sn(l)),h));return[E,E]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:jo(this.activation),recurrentActivation:jo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ke(this.kernelInitializer),recurrentInitializer:Ke(this.recurrentInitializer),biasInitializer:Ke(this.biasInitializer),kernelRegularizer:Re(this.kernelRegularizer),recurrentRegularizer:Re(this.recurrentRegularizer),biasRegularizer:Re(this.biasRegularizer),activityRegularizer:Re(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),recurrentConstraint:Sn(this.recurrentConstraint),biasConstraint:Sn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}mC.className="GRUCell";vt(mC);class l3 extends na{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new mC(t),super(t)}call(t,e){return rt(()=>{this.cell.dropoutMask!=null&&(Qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}l3.className="GRU";vt(l3);class A0 extends N0{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Rn(this.units,"units"),this.activation=Go(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Go(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=je(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=je(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=je(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ge(t.kernelRegularizer),this.recurrentRegularizer=Ge(t.recurrentRegularizer),this.biasRegularizer=Ge(t.biasRegularizer),this.kernelConstraint=Cn(t.kernelConstraint),this.recurrentConstraint=Cn(t.recurrentConstraint),this.biasConstraint=Cn(t.biasConstraint),this.dropout=zc([1,Uo([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=zc([1,Uo([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=pe(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;r=new(e=class extends Ir{apply(c,h){const d=i.apply([o]),p=new eC().apply([o]),m=i.apply([o*2]);return vN(vN(d,p),m)}},e.className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return rt(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new q(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wo({ones:()=>$r(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wo({ones:()=>$r(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=this.recurrentDropoutMask;let c,h,d,p;0<this.dropout&&this.dropout<1&&(t=Y(t,o[0]));let m=gi(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,l[0])),m=wt(m,gi(r,this.recurrentKernel.read())),this.useBias&&(m=Jr(m,this.bias.read()));const[y,b,x,w]=er(m,4,m.rank-1);c=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=wt(Y(h,i),Y(c,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const S=Y(p,this.activation.apply(d));return[S,S,d]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:jo(this.activation),recurrentActivation:jo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ke(this.kernelInitializer),recurrentInitializer:Ke(this.recurrentInitializer),biasInitializer:Ke(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Re(this.kernelRegularizer),recurrentRegularizer:Re(this.recurrentRegularizer),biasRegularizer:Re(this.biasRegularizer),activityRegularizer:Re(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),recurrentConstraint:Sn(this.recurrentConstraint),biasConstraint:Sn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}A0.className="LSTMCell";vt(A0);class c3 extends na{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new A0(t),super(t)}call(t,e){return rt(()=>{this.cell.dropoutMask!=null&&(Qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}c3.className="LSTM";vt(c3);class gC extends N0{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return rt(()=>{t=t;let s=t.slice(1);const r=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?r.push(s.splice(0,l.stateSize.length)):r.push(s.splice(0,1));r.reverse();const i=[];let o;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=r[l],l===0?o=[t[0]].concat(s):o=[o[0]].concat(s),o=c.call(o,e),i.push(o.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[o[0]].concat(s)})}build(t){Qv(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,r)=>{qa(`RNNCell_${r}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=i=>({className:i.getClassName(),config:i.getConfig()}),r={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),r)}static fromConfig(t,e,s={}){const r=[];for(const i of e.cells)r.push(yi(i,s));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return tw(t)}setWeights(t){const e=[];for(const s of this.cells){const r=s.weights.length,i=t.splice(r);for(let o=0;o<s.weights.length;++o)e.push([s.weights[o],i[o]])}lC(e)}}gC.className="StackedRNNCells";vt(gC);function Wo(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:i}=n,o=()=>i!=null?i(t(),e):tM(t(),e),l=()=>hf(o,t,s);return!r||r<=1?fi(l().clone()):Array(r).fill(void 0).map(l).map(h=>fi(h.clone()))}var OQ=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]]);return e};class u3 extends na{constructor(t){if(t.unroll)throw new Xt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Xt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new wn({ndim:5})]}call(t,e){return rt(()=>{if(this.cell.dropoutMask!=null&&(Qt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Qt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new q("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,r=e==null?null:e.training,i=e==null?null:e.initialState;return super.call(t,{mask:s,training:r,initialState:i})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return rt(()=>{const{stateSize:e}=this.cell,s=t.shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)],o=_n(i);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){rt(()=>{if(!this.stateful)throw new oi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),i=[r[0],...r.slice(2)];if(s[0]==null)throw new q("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_n(i)):this.states_=[_n(i)];else if(t==null)Qt(this.states_),this.keptStates!=null&&(Qt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>_n(i)):this.states_[0]=_n(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new q(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Qt(this.states_);for(let l=0;l<this.states_.length;++l){const c=t[l],h=i;if(!we(c.shape,h))throw new q(`State ${l} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>fi(l.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:r,padding:i,strides:o,dilationRate:l}=this.cell,c=e==="channelsFirst",h=t[c?3:2],d=t[c?4:3],p=Kr(h,r[0],i,o[0],l[0]),m=Kr(d,r[1],i,o[1],l[1]);return[...t.slice(0,2),...c?[s,p,m]:[p,m,s]]}}u3.className="ConvRNN2D";class yC extends A0{constructor(t){const{filters:e,kernelSize:s,strides:r,padding:i,dataFormat:o,dilationRate:l}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Rn(this.filters,"filters"),this.kernelSize=_c(s,2,"kernelSize"),this.kernelSize.forEach(c=>Rn(c,"kernelSize")),this.strides=_c(r||1,2,"strides"),this.strides.forEach(c=>Rn(c,"strides")),this.padding=i||"valid",rr(this.padding),this.dataFormat=o||"channelsLast",an(this.dataFormat),this.dilationRate=_c(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Rn(c,"dilationRate"))}build(t){var e;t=pe(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new q(`The channel dimension of the input should be defined. Found ${t[s]}`);const r=t[s],i=4,o=this.kernelSize.concat([r,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;c=new(e=class extends Ir{apply(m,y){const b=h.apply([d]),x=ta([d]),w=h.apply([d*2]);return tC([b,x,w])}},e.className="CustomInit",e)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return rt(()=>{if(t.length!==3)throw new q(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,r=t[0],i=t[1],o=t[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Wo({ones:()=>$r(r),rate:this.dropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,h=(Z,F,z)=>!F||!F[z]?Z:Y(F[z],Z);let d=h(r,c,0),p=h(r,c,1),m=h(r,c,2),y=h(r,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Wo({ones:()=>$r(i),rate:this.recurrentDropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(i,b,0),w=h(i,b,1),S=h(i,b,2),T=h(i,b,3);const k=3,[$,E,N,_]=er(this.kernel.read(),l,k),[R,D,M,A]=this.useBias?er(this.bias.read(),l):[null,null,null,null];d=this.inputConv(d,$,R,this.padding),p=this.inputConv(p,E,D,this.padding),m=this.inputConv(m,N,M,this.padding),y=this.inputConv(y,_,A,this.padding);const[B,H,W,X]=er(this.recurrentKernel.read(),l,k);x=this.recurrentConv(x,B),w=this.recurrentConv(w,H),S=this.recurrentConv(S,W),T=this.recurrentConv(T,X);const P=this.recurrentActivation.apply(wt(d,x)),U=this.recurrentActivation.apply(wt(p,w)),G=wt(Y(U,o),Y(P,this.activation.apply(wt(m,S)))),tt=Y(this.recurrentActivation.apply(wt(y,T)),this.activation.apply(G));return[tt,tt,G]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=OQ(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(t,e,s,r){const i=nl(t,e,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Jr(i,s,this.dataFormat):i}recurrentConv(t,e){return nl(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}yC.className="ConvLSTM2DCell";vt(yC);class h3 extends u3{constructor(t){const e=new yC(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}h3.className="ConvLSTM2D";vt(h3);class bC extends ne{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?e[r]:this.noiseShape[r]);return s}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);if(0<this.rate&&this.rate<1){const r=e.training==null?!1:e.training,i=this.getNoiseShape(s);return hf(()=>tM(s,this.rate,i,this.seed),()=>s,r)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}bC.className="Dropout";vt(bC);class d3 extends bC{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}d3.className="SpatialDropout1D";vt(d3);class f3 extends ne{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Rn(this.units,"units"),this.activation=Go(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=je(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=je(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Cn(t.kernelConstraint),this.biasConstraint=Cn(t.biasConstraint),this.kernelRegularizer=Ge(t.kernelRegularizer),this.biasRegularizer=Ge(t.biasRegularizer),this.activityRegularizer=Ge(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=pe(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=pe(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t),r=qO(this.activation.getClassName());let i;return r!=null?i=gi(s,this.kernel.read(),r,this.bias?this.bias.read():null):(i=gi(s,this.kernel.read()),this.bias!=null&&(i=Jr(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:jo(this.activation),useBias:this.useBias,kernelInitializer:Ke(this.kernelInitializer),biasInitializer:Ke(this.biasInitializer),kernelRegularizer:Re(this.kernelRegularizer),biasRegularizer:Re(this.biasRegularizer),activityRegularizer:Re(this.activityRegularizer),kernelConstraint:Sn(this.kernelConstraint),biasConstraint:Sn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}f3.className="Dense";vt(f3);class p3 extends ne{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=pe(t);for(const e of t.slice(1))if(e==null)throw new q(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Po(t,1)]}call(t,e){return rt(()=>{this.invokeCallHook(t,e);let s=jt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let i=2;i<s.rank;++i)r.push(i);r.push(1),s=he(s,r)}return hJ(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}p3.className="Flatten";vt(p3);class m3 extends ne{constructor(t){super(t),this.supportsMasking=!0,this.activation=Go(t.activation)}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);return this.activation.apply(s)})}getConfig(){const t={activation:jo(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}m3.className="Activation";vt(m3);class g3 extends ne{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return rt(()=>(t=jt(t),cJ(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}g3.className="RepeatVector";vt(g3);class y3 extends ne{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",r=e.slice();let i=1,o=null;for(let c=0;c<r.length;++c){const h=r[c];if(this.isUnknown(h))if(o===null)o=c;else throw new q("Can only specifiy one unknown dimension.");else i*=h}const l=Po(t);if(o!==null){if(i===0||l%i!==0)throw new q(s);r[o]=l/i}else if(l!==i)throw new q(s);return r}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t),r=s.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return et(s,i)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}y3.className="Reshape";vt(y3);class b3 extends ne{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=Xr(1,t.dims.length+1);if(!we(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new wn({ndim:this.dims.length+1})]}computeOutputShape(t){t=pe(t);const e=t.slice();return this.dims.forEach((s,r)=>{e[r+1]=t[s]}),e}call(t,e){return he(jt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}b3.className="Permute";vt(b3);class x3 extends ne{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=jt(t);return Gv(Mm(s,this.maskValue),-1)}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t),o=Gv(Mm(s,this.maskValue),-1,!0);return Y(s,Et(o,s.dtype))})}}x3.className="Masking";vt(x3);class v3 extends ne{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Te(t.inputLength))}this.inputDim=t.inputDim,Rn(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Rn(this.outputDim,"outputDim"),this.embeddingsInitializer=je(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ge(t.embeddingsRegularizer),this.activityRegularizer=Ge(t.activityRegularizer),this.embeddingsConstraint=Cn(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return rt(()=>this.maskZero?(t=jt(t),Mm(t,de(t))):null)}computeOutputShape(t){if(t=pe(t),this.inputLength==null)return[...t,this.outputDim];const e=Te(this.inputLength);if(e.length!==t.length-1)throw new q(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let r=0;r<e.length;++r){const i=e[r],o=t[r+1];if(i!=null&&o!=null&&i!==o)throw new q(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);i==null&&(e[s]=o),s++}}return[t[0],...e,this.outputDim]}call(t,e){return rt(()=>{this.invokeCallHook(t,e);let s=jt(t);s.dtype!=="int32"&&(s=mi(s,"int32"));const r=QO(this.embeddings.read(),et(s,[s.size]));return et(r,pe(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ke(this.embeddingsInitializer),embeddingsRegularizer:Re(this.embeddingsRegularizer),activityRegularizer:Re(this.activityRegularizer),embeddingsConstraint:Sn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}v3.className="Embedding";vt(v3);class ml extends ne{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Xt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const i=t[t.length-e.length+r],o=e[r];if(i==null||o==null||i<0||o<0)s.push(null);else if(i===1)s.push(o);else if(o===1)s.push(i);else{if(i!==o)throw new q("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[pe(t)]),t=t,t.length<2)throw new q(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)i!=null&&i[0]!==null&&e.push(i[0]);if(e=Lo(e),e.length>1)throw new q(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=t[i]==null?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(i=>i.length);t.indexOf(null)===-1&&Lo(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return rt(()=>{if(t=t,this.reshapeRequired){const s=[],r=t.map(i=>i.rank);if(r.indexOf(null)===-1){const i=Uo(r);for(let o of t){const l=o.rank;for(let c=0;c<i-l;++c)o=cf(o,1);s.push(o)}return this.mergeFunction(s)}else{let i=!1;for(const c of t){const h=c.rank;if(h==null){const d=c.shape,p=d[0],m=d.slice(1).concat([p]);let y=et(c,[p].concat(Po(d.slice(1))));y=he(y,[1,0]),y=et(y,m),s.push(y),i=!0}else if(h>1){const d=Xr(1,h).concat([0]);s.push(he(c,d)),i=!0}else s.push(c)}let o=this.mergeFunction(s);const l=o.rank;if(i){if(l==null){const c=o.shape,h=c.length,d=c[h-1],p=[d].concat(c.slice(0,c.length-1));o=et(he(et(o,[-1,d]),[1,0]),p)}else if(l>1){const c=[l-1].concat(Xr(0,l-1));o=he(o,c)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let r=1;r<t.length;++r){const i=t[r]==null?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let s=[];for(const r of t)r!=null&&r[0]!==null&&s.push(r[0]);return s=Lo(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return rt(()=>{if(e==null)return null;if(!Array.isArray(e))throw new q("`mask` should be an Array");if(!Array.isArray(t))throw new q("`inputs` should be an Array");if(e.length!==t.length)throw new q(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>r==null))return null;e=e.map(r=>r==null?r:bs(r,0));let s=e[0];for(let r=1;r<e.length-1;++r)s=Ki(s,e[r]);return s})}}class w3 extends ml{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=wt(e,t[s]);return e})}}w3.className="Add";vt(w3);class S3 extends ml{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Y(e,t[s]);return e})}}S3.className="Multiply";vt(S3);class C3 extends ml{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=wt(e,t[s]);return Y(1/t.length,e)})}}C3.className="Average";vt(C3);class T3 extends ml{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Qo(e,t[s]);return e})}}T3.className="Maximum";vt(T3);class k3 extends ml{constructor(t){super(t)}mergeFunction(t){return rt(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Bh(e,t[s]);return e})}}k3.className="Minimum";vt(k3);class $3 extends ml{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new q("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const r of t)if(r!=null){e=!1;break}if(e)return;const s=[];for(let r=0;r<t.length;++r){const i=t[r].slice();i.splice(this.axis,1);let o=!1;for(const l of s)if(we(l,i)){o=!0;break}o||s.push(i)}if(s.length>1)throw new q("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return rt(()=>tC(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new q("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const i of e.slice(1)){if(s[r]==null||i[r]==null){s[r]=null;break}s[r]+=i[r]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new q("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new q("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new q(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return rt(()=>{let s=!0;if(e.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const r=[];for(let o=0;o<t.length;++o)e[o]==null?r.push(Et($r(t[o]),"bool")):e[o].rank<t[o].rank?r.push(bs(e[o],-1)):r.push(e[o]);const i=ws(r,this.axis);return kD(i,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}$3.className="Concatenate";vt($3);function ah(n,t){for(;n<0;)n+=t;return n}function MQ(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Xt("batchDot is not implemented for tensors of 4D or higher rank yet");if(L(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),L(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Xt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;e==null&&(e=[s-1,r-2]);const i=e;return rt(()=>{let o;if(s>r){o=s-r;const c=[];for(let h=0;h<o;++h)c.push(1);t=et(t,t.shape.concat(c))}else if(r>s){o=r-s;const c=[];for(let h=0;h<o;++h)c.push(1);n=et(n,n.shape.concat(c))}else o=0;let l;if(n.shape.length===2&&t.shape.length===2)i[0]===i[1]?l=Mt(Y(n,t),i[0]):l=Mt(Y(he(n,[1,0]),t),i[1]);else{const c=i[0]!==n.shape.length-1,h=i[1]===t.shape.length-1;l=xe(n,t,c,h)}if(o>0){let c;s>r?c=s+r-3:c=s-1;const h=[];for(let d=c;d<c+o;++d)h.push(d);l=nf(l,h)}return l.shape.length===1&&(l=bs(l,1)),l})}class E3 extends ml{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){L(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);if(e[r[0]]!==s[r[1]])throw new q(`Dimension incompatibility: ${e[r[0]]} !== ${s[r[1]]}`)}mergeFunction(t){if(t.length!==2)throw new q(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],r;return Array.isArray(this.axes)?r=this.axes.map((i,o)=>ah(i,t[o].shape.length)):r=[ah(this.axes,e.shape.length),ah(this.axes,s.shape.length)],this.normalize&&(e=Um(e,r[0]),s=Um(s,r[1])),MQ(e,s,r)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[ah(this.axes,t.length),ah(this.axes,e.length)],s}computeOutputShape(t){L(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Xt("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,s);e.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const i=e.concat(s);return i.length===1&&i.push(1),i}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}E3.className="Dot";vt(E3);class I3 extends ne{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);return hf(()=>wt(C0(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}I3.className="GaussianNoise";vt(I3);class N3 extends ne{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return rt(()=>{this.invokeCallHook(t,e);const s=jt(t);return this.rate>0&&this.rate<1?hf(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return Y(s,C0(s.shape,1,i))},()=>s,e.training||!1):s})}}N3.className="GaussianDropout";vt(N3);class A3 extends ne{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||jt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return rt(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return hf(()=>{const i=jt(t),l=-1.6732632423543772*1.0507009873554805;let c=hl(ef(s),this.rate);c=mi(c,"float32");const h=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-h*l*this.rate,p=wt(Y(i,c),Y(wt(c,-1),l));return wt(Y(p,h),d)},()=>jt(t),e.training||!1)}return t})}}A3.className="AlphaDropout";vt(A3);function Wh(n,t,e,s,r,i=.001){let o;if(n.rank===2)o=t8(n,t,e,s,r,i);else if(n.rank===3)o=n8(n,t,e,s,r,i);else if(n.rank===4)o=r8(n,t,e,s,r,i);else throw new Xt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function FQ(n,t,e,s,r=.001){return rt(()=>{const i=aS(n,s),o=i.mean,l=i.variance;return[Wh(n,o,l,e,t,r),o,l]})}function LQ(n,t,e,s,r=.001){return rt(()=>{const i=aS(n,s),o=i.mean,l=i.variance,c=[];for(const b of Xr(0,n.rank))s.indexOf(b)!==-1?c.push(1):c.push(n.shape[b]);const h=et(o,c),d=et(l,c),p=t==null?null:et(t,c),m=e==null?null:et(e,c);return[Wh(n,h,d,m,p,r),o,l]})}function PQ(n,t,e,s,r=.001){return we(s.slice().sort(),Xr(0,n.rank-1))?FQ(n,t,e,s,r):LQ(n,t,e,s,r)}class _3 extends ne{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=je(t.betaInitializer||"zeros"),this.gammaInitializer=je(t.gammaInitializer||"ones"),this.movingMeanInitializer=je(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=je(t.movingVarianceInitializer||"ones"),this.betaConstraint=Cn(t.betaConstraint),this.gammaConstraint=Cn(t.gammaConstraint),this.betaRegularizer=Ge(t.betaRegularizer),this.gammaRegularizer=Ge(t.gammaRegularizer)}build(t){t=pe(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new q(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new wn({ndim:t.length,axes:{[e]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return rt(()=>{const s=e.training==null?!1:e.training,r=jt(t),i=r.shape,o=i.length,l=Xr(0,o),c=this.axis>=0?this.axis:this.axis+o;l.splice(c,1);const h=ol(1,o);h[c]=i[c];const d=l.slice();d.sort();const p=!we(d,Xr(0,o).slice(0,o-1)),m=()=>{if(p){const T=et(this.movingMean.read(),h),k=et(this.movingVariance.read(),h),$=this.center?et(this.beta.read(),h):null,E=this.scale?et(this.gamma.read(),h):null;return Wh(r,T,k,$,E,this.epsilon)}else return Wh(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=PQ(r,this.gamma.read(),this.beta.read(),l,this.epsilon),w=(T,k,$)=>{rt(()=>{const E=1-$,N=T.read(),_=Y(Bt(N,k),E);T.write(Bt(N,_))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ke(this.betaInitializer),gammaInitializer:Ke(this.gammaInitializer),movingMeanInitializer:Ke(this.movingMeanInitializer),movingVarianceInitializer:Ke(this.movingVarianceInitializer),betaRegularizer:Re(this.betaRegularizer),gammaRegularizer:Re(this.gammaRegularizer),betaConstraint:Sn(this.betaConstraint),gammaConstraint:Sn(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}_3.className="BatchNormalization";vt(_3);class R3 extends ne{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=je(t.betaInitializer||"zeros"),this.gammaInitializer=je(t.gammaInitializer||"ones"),this.betaRegularizer=Ge(t.betaRegularizer),this.gammaRegularizer=Ge(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=pe(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=e);for(const i of this.axis)if(i<0||i>=e)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Lo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(t,e){const s=jt(t),r=s.shape,i=r.length;return rt(()=>{let{mean:l,variance:c}=aS(s,this.axis,!0);const h=ol(1,i);for(const x of this.axis)h[x]=r[x];const d=x=>x!=null&&x.shape.length!==i?et(x,h):x;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<i;++x)this.axis.indexOf(x)!==-1?(y.push(r[x]),b.push(1)):(y.push(1),b.push(r[x]));return l=Wr(l,y),c=Wr(c,y),p!=null&&(p=Wr(p,b)),m!=null&&(m=Wr(m,b)),Wh(s,l,c,m,p,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ke(this.betaInitializer),gammaInitializer:Ke(this.gammaInitializer),betaRegularizer:Re(this.betaRegularizer),gammaRegularizer:Re(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}R3.className="LayerNormalization";vt(R3);function zQ(n,t,e){return rt(()=>{if(n.rank!==4)throw new q(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new q("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=Yr()),e!=="channelsLast"&&e!=="channelsFirst")throw new q(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],lS(n,s)})}class D3 extends ne{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?Yr():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new q(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new q(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new q(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){t=pe(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return rt(()=>zQ(jt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}D3.className="ZeroPadding2D";vt(D3);function _0(n,t,e,s,r,i){return rt(()=>{an(r),XO(i),rr(s),e==null&&(e=[1,1]),s==null&&(s="valid"),r==null&&(r=Yr()),i==null&&(i="max"),n=fC(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=oS(n,t,e,l):o=Y1(n,t,e,l),r==="channelsFirst"&&(o=he(o,[0,3,1,2])),o})}function O3(n,t,e,s,r,i){return rt(()=>{an(r),XO(i),rr(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Yr()),i==null&&(i="max"),n=ZM(n,r);let o;const l=s==="same"?"same":"valid";return i==="max"?o=UK(n,t,e,l):o=Gq(n,t,e,l),r==="channelsFirst"&&(o=he(o,[0,4,1,2,3])),o})}class M3 extends ne{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new q(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Rn(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new q(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Rn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,rr(this.padding),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(t){t=pe(t);const e=Kr(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return rt(()=>{this.invokeCallHook(t,e),t=cf(jt(t),2);const s=this.poolingFunction(jt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return nf(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class F3 extends M3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return an(i),rr(r),_0(t,e,s,r,i,"max")}}F3.className="MaxPooling1D";vt(F3);class L3 extends M3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return an(i),rr(r),_0(t,e,s,r,i,"avg")}}L3.className="AveragePooling1D";vt(L3);class P3 extends ne{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new q(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Rn(this.poolSize,"poolSize"),Rn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,an(this.dataFormat),rr(this.padding),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){t=pe(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=Kr(e,this.poolSize[0],this.padding,this.strides[0]),s=Kr(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return rt(()=>(this.invokeCallHook(t,e),this.poolingFunction(jt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class z3 extends P3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return an(i),rr(r),_0(t,e,s,r,i,"max")}}z3.className="MaxPooling2D";vt(z3);class B3 extends P3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return an(i),rr(r),_0(t,e,s,r,i,"avg")}}B3.className="AveragePooling2D";vt(B3);class V3 extends ne{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new q(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Rn(this.poolSize,"poolSize"),Rn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,an(this.dataFormat),rr(this.padding),this.inputSpec=[new wn({ndim:5})]}computeOutputShape(t){t=pe(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],r=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=Kr(e,this.poolSize[0],this.padding,this.strides[0]),s=Kr(s,this.poolSize[1],this.padding,this.strides[1]),r=Kr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return rt(()=>(this.invokeCallHook(t,e),this.poolingFunction(jt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class U3 extends V3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return an(i),rr(r),O3(t,e,s,r,i,"max")}}U3.className="MaxPooling3D";vt(U3);class j3 extends V3{constructor(t){super(t)}poolingFunction(t,e,s,r,i){return an(i),rr(r),O3(t,e,s,r,i,"avg")}}j3.className="AveragePooling3D";vt(j3);class G3 extends ne{constructor(t){super(t),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Xt}}class W3 extends G3{constructor(t){super(t||{})}call(t,e){return rt(()=>{const s=jt(t);return hn(s,1)})}}W3.className="GlobalAveragePooling1D";vt(W3);class H3 extends G3{constructor(t){super(t||{})}call(t,e){return rt(()=>{const s=jt(t);return qr(s,1)})}}H3.className="GlobalMaxPooling1D";vt(H3);class q3 extends ne{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,an(this.dataFormat),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Xt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class K3 extends q3{call(t,e){return rt(()=>{const s=jt(t);return this.dataFormat==="channelsLast"?hn(s,[1,2]):hn(s,[2,3])})}}K3.className="GlobalAveragePooling2D";vt(K3);class X3 extends q3{call(t,e){return rt(()=>{const s=jt(t);return this.dataFormat==="channelsLast"?qr(s,[1,2]):qr(s,[2,3])})}}X3.className="GlobalMaxPooling2D";vt(X3);class Y3 extends ne{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const r=e.layer,i=yi(r,s);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}class Z3 extends Y3{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=pe(t),t.length<3)throw new q(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=pe(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),r=t[1];return[s[0],r].concat(s.slice(1))}call(t,e){return rt(()=>(t=jt(t),o3((o,l)=>[jt(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}Z3.className="TimeDistributed";vt(Z3);function BQ(n){pl(rJ,"BidirectionalMergeMode",n)}const VQ="concat";class J3 extends Y3{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=yi(s),e.goBackwards=e.goBackwards!==!0;const r={};if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=yi(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?VQ:t.mergeMode,BQ(this.mergeMode),t.weights)throw new Xt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,r,i;return this.returnState&&(i=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):xs(r)}apply(t,e){let s=e==null?null:e.initialState,r=e==null?null:e.constants;e==null&&(e={});const i=i3(t,s,r,this.numConstants);if(t=i.inputs,s=i.initialState,r=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&r==null)return super.apply(t,e);const o=[],l=[];if(s!=null){const h=s.length;if(h%2>0)throw new q("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,o.push(...s);const d=s.map(p=>new wn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),l.push(...d)}if(r!=null)throw new Xt("Support for constants in Bidirectional layers is not implemented yet.");const c=o[0]instanceof wi;for(const h of o)if(h instanceof wi!==c)throw new q("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const h=[t].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return rt(()=>{const s=e.initialState;let r,i;if(s==null)r=this.forwardLayer.call(t,e),i=this.backwardLayer.call(t,e);else{const c=s.slice(0,s.length/2),h=s.slice(s.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:c})),i=this.backwardLayer.call(t,Object.assign(e,{initialState:h}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=rl(i,1));let l;return this.mergeMode==="concat"?l=tC([r,i]):this.mergeMode==="sum"?l=wt(r,i):this.mergeMode==="ave"?l=Y(.5,wt(r,i)):this.mergeMode==="mul"?l=Y(r,i):this.mergeMode==null&&(l=[r,i]),this.returnState?this.mergeMode==null?l.concat(o):[l].concat(o):l})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){qa(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),qa(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=yi(e.layer);if(delete e.layer,e.numConstants!=null)throw new Xt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=s,new t(r)}}J3.className="Bidirectional";vt(J3);class Q3 extends ne{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return rt(()=>(t=jt(t),t.dtype!=="float32"&&(t=mi(t,"float32")),wt(Y(t,this.scale),this.offset)))}}Q3.className="Rescaling";vt(Q3);const{resizeBilinear:UQ,cropAndResize:jQ}=Wi;class tF extends ne{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,r,i,o,l,c){return rt(()=>{let h,d=!1;const p=e/o,m=s/l,y=(r+e)/o,b=(i+s)/l,x=[p,m,y,b],w=[];t.rank===3?(d=!0,h=Xi([t])):h=t;for(let E=0;E<h.shape[0];E++)w.push(x);const S=Ch(w,[w.length,4]),T=Vh(0,w.length,1,"int32"),$=jQ(h,S,T,[r,i],"nearest");return mi(d?jt(il($)):$,c)})}upsize(t,e,s,r){return rt(()=>{const i=UQ(t,[e,s]);return mi(i,r)})}call(t,e){return rt(()=>{const s=jt(t),r=s.dtype,i=s.shape,o=i[i.length-3],l=i[i.length-2];let c=0;o!==this.height&&(c=Math.floor((o-this.height)/2));let h=0;return l!==this.width&&(h=Math.floor((l-this.width)/2),h===0&&(h=1)),c>=0&&h>=0?this.centerCrop(s,c,h,this.height,this.width,o,l,r):this.upsize(t,this.height,this.width,r)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=pe(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}tF.className="CenterCrop";vt(tF);function GQ(n,t,e,s){let r=jt(n);if(r.dtype!=="int32"&&(r=mi(r,"int32")),t==="int")return r;const i=r.shape;if(r.rank===0&&(r=bs(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=bs(r,-1)),r.rank>2)throw new q(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t),l=r;let c;if(typeof s<"u"&&t==="count"?c=XI(l,s,e,o):c=XI(l,[],e,o),t!=="tfIdf")return c;if(s)return Y(c,s);throw new q("When outputMode is 'tfIdf', weights must be provided.")}class eF extends ne{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=pe(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return rt(()=>{t=jt(t),t.dtype!=="int32"&&(t=mi(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new q(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=jt(e.countWeights)}const r=qr(t),i=Dm(t),o=sr(this.numTokens,r).bufferSync().get(0),l=hl(i,0).bufferSync().get(0);if(!(o&&l))throw new q(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return GQ(t,this.outputMode,this.numTokens,s)})}}eF.className="CategoryEncoding";vt(eF);const WQ=["bilinear","nearest"],PN=new Set(WQ);class nF extends ne{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(PN.has(t.interpolation))this.interpolation=t.interpolation;else throw new q(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=pe(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return rt(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Wi.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Wi.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...PN]} are supported`)})}}nF.className="Resizing";vt(nF);class sF{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}sF.className="RandomSeed";class rF extends ne{constructor(t){super(t),this.randomGenerator=new sF(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}rF.className="BaseRandomLayer";const HQ=["bilinear","nearest"],zN=new Set(HQ);class iF extends rF{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new q(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new q(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new q(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(zN.has(s))this.interpolation=s;else throw new q(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=pe(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return rt(()=>{const s=jt(t);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=ef([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*r;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Wi.resizeBilinear(t,o);case"nearest":return Wi.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...zN]} are supported`)}})}}iF.className="RandomWidth";vt(iF);const qQ=lt();qQ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var BN;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(BN||(BN={}));var VN;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(VN||(VN={}));var UN;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(UN||(UN={}));function Nt(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&L(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const KQ=QD;class R0 extends Jw{nextDataId(){return R0.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new $R(this,ri())}write(t,e,s){this.firstUse&&(this.firstUse=!1,lt().get("IS_NODE")&&Qs(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:s,refCount:1}),r}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&ed(s[0])){const i=s.map(o=>Fo(o));r=this.write(i,t,e)}else r=this.write(s,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,r,i){this.data.set(t,{values:e,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const r=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return Yi(r,i)}return q5(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>Vo(r));return te(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return te(t.shape,t.dtype,e)}makeOutput(t,e,s){return ri().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=ys();return t(),{kernelMs:ys()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Nt([t],"where");const e=this.readSync(t.dataId);return KQ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}R0.nextDataId=0;function oF(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const XQ=n=>{const{x:t}=n.inputs,e=n.backend;Nt(t,"abs");let s=new Float32Array(ft(t.shape));const r=e.data.get(t.dataId).values;return s=oF(r),e.makeOutput(s,t.shape,t.dtype)},YQ={kernelName:hg,backendName:"cpu",kernelFunc:XQ};function ln(n){return(t,e,s,r,i)=>{const o=qt(t,e),l=o.length,c=Dt(o),h=ft(o),d=Yn(i,h),p=t.length,m=e.length,y=Dt(t),b=Dt(e),x=Lc(t,o),w=Lc(e,o);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=n(s[S%s.length],r[S%r.length]);else for(let S=0;S<d.length;++S){const T=Xc(S,l,c),k=T.slice(-p);x.forEach(_=>k[_]=0);const $=di(k,p,y),E=T.slice(-m);w.forEach(_=>E[_]=0);const N=di(E,m,b);d[S]=n(s[$],r[N])}return[d,o]}}function Os(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,l=e.makeTensorInfo(s.shape,"complex64"),c=e.data.get(l.dataId);return c.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",i),imag:e.makeTensorInfo(r.shape,"float32",o)},l}const ZQ={kernelName:d1,backendName:"cpu",kernelFunc:Os};function Km(n,t,e="float32"){if(e==="complex64"){const r=Km(n,t,"float32"),i=Km(n,t,"float32");return Os({inputs:{real:r,imag:i},backend:n})}const s=Zn(ft(t),e);return n.makeTensorInfo(t,e,s)}function Si(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const JQ={kernelName:Sd,backendName:"cpu",kernelFunc:Si};function al(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const QQ={kernelName:F1,backendName:"cpu",kernelFunc:al};function aF(n,t,e,s){if(s==="int32"){const r=Int32Array.from(n);return[t,"int32",r]}if(s==="bool"){const r=ul([0],e),[i,o]=ln((l,c)=>l!==c?1:0)(t,[],n,r,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function Ho(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Si({inputs:{x:r},backend:e});const d=Km(e,r.shape,r.dtype),p=Ho({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),m=Os({inputs:{real:p,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),m}if(r.dtype==="complex64"){const d=al({inputs:{input:r},backend:e}),p=Ho({inputs:{x:d},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(d),p}if(!IR(r.dtype,i)){const d=Si({inputs:{x:r},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:i}}const o=e.data.get(r.dataId).values,[l,c,h]=aF(o,r.shape,r.dtype,i);return e.makeTensorInfo(l,c,h)}const ttt={kernelName:cd,backendName:"cpu",kernelFunc:Ho};function kn(n,t,e,s){return e==null?({inputs:r,backend:i})=>{const{a:o,b:l}=r,c=i;Nt([o,l],n);const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=o.dtype==="string"?Zi(h):h,m=o.dtype==="string"?Zi(d):d,y=s||o.dtype,[b,x]=t(o.shape,l.shape,p,m,y);return c.makeTensorInfo(x,y,b)}:({inputs:r,backend:i})=>{const{a:o,b:l}=r,c=i;if(o.dtype==="complex64"||l.dtype==="complex64"){const h=Ho({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(h.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=c.data.get(p.dataId).values,b=c.data.get(m.dataId).values,x=Ho({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),w=c.data.get(x.dataId),S=w.complexTensorInfos.real,T=w.complexTensorInfos.imag,k=c.data.get(S.dataId).values,$=c.data.get(T.dataId).values,[E,N,_]=e(o.shape,l.shape,y,b,k,$),R=c.makeTensorInfo(_,"float32",E),D=c.makeTensorInfo(_,"float32",N),M=Os({inputs:{real:R,imag:D},backend:c});return c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(R),c.disposeIntermediateTensorInfo(D),M}else{const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=s||o.dtype,[m,y]=t(o.shape,l.shape,h,d,p);return c.makeTensorInfo(y,p,m)}}}function xC(n){return(t,e,s,r,i,o)=>{const l=qt(t,e),c=ft(l),h=l.length,d=Dt(l),p=Yn("float32",c),m=Yn("float32",c),y=Lc(t,l),b=Lc(e,l),x=Yi(s,r),w=Yi(i,o),S=t.length,T=Dt(t),k=e.length,$=Dt(e);if(y.length+b.length===0)for(let E=0;E<p.length;E++){const N=E%x.length,_=E%w.length,R=n(x[N*2],x[N*2+1],w[_*2],w[_*2+1]);p[E]=R.real,m[E]=R.imag}else for(let E=0;E<p.length;E++){const N=Xc(E,h,d),_=N.slice(-S);y.forEach(B=>_[B]=0);const R=di(_,S,T),D=N.slice(-k);b.forEach(B=>D[B]=0);const M=di(D,k,$),A=n(x[R*2],x[R*2+1],w[M*2],w[M*2+1]);p[E]=A.real,m[E]=A.imag}return[p,m,l]}}const lF=ln(((n,t)=>n+t)),ett=xC(((n,t,e,s)=>({real:n+e,imag:t+s}))),Bc=kn(Yc,lF,ett),ntt={kernelName:Yc,backendName:"cpu",kernelFunc:Bc};function vC(n,t,e,s,r){const i=ft(s),o=Zn(r,e);for(let l=0;l<n.length;l++){const c=n[l];if(c<0)throw new Error("Input x must be non-negative!");c>=r||(i>0?o[c]+=t[l]:o[c]+=1)}return o}function cF(n,t,e,s=!1){const r=n.shape[0],i=n.shape[1],o=te([r,e],t.dtype);for(let l=0;l<r;l++)for(let c=0;c<i;c++){const h=n.get(l,c);if(h<0)throw new Error("Input x must be non-negative!");h>=e||(s?o.set(1,l,h):t.size>0?o.set(o.get(l,h)+t.get(l,c),l,h):o.set(o.get(l,h)+1,l,h))}return o}const uF=ln(((n,t)=>n&t)),stt=kn(h1,uF),rtt={kernelName:h1,backendName:"cpu",kernelFunc:stt};function Ci(n){return(t,e,s)=>{const r=nn(e,t.length);for(let i=0;i<t.length;++i)r[i]=n(t[i],s);return r}}function ke(n,t,e){const s=Ci(t);return sa(n,s,e)}function sa(n,t,e){return({inputs:s,attrs:r,backend:i})=>{const{x:o}=s;Nt(o,n);const l=i,c=l.data.get(o.dataId).values;let h;if(o.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");h=Zi(c)}else h=c;const d=e||o.dtype,p=t(h,d,r);return l.makeTensorInfo(o.shape,d,p)}}const hF=Ci(n=>Math.ceil(n)),itt=sa(ud,hF),ott={kernelName:ud,backendName:"cpu",kernelFunc:itt};function dF(n,t,e,s){const r=nn(e,ft(t));if(s&&e!=="string"){let i=0;n.forEach(o=>{const l=ft(o.shape);r.set(o.vals,i),i+=l})}else{let i=0;n.forEach(o=>{const l=e==="string"?Zi(o.vals):o.vals;let c=0;for(let h=0;h<o.shape[0];++h){const d=h*t[1]+i;for(let p=0;p<o.shape[1];++p)r[d+p]=l[c++]}i+=o.shape[1]})}return r}const fF=ln((n,t)=>n===t?1:0),pF=kn($g,fF,null,"bool"),att={kernelName:$g,backendName:"cpu",kernelFunc:pF};const mF=Ci(n=>Math.exp(n)),gF=sa(yd,mF,"float32"),ltt={kernelName:yd,backendName:"cpu",kernelFunc:gF};const yF=Ci(n=>Math.expm1(n)),ctt=sa(bd,yF),utt={kernelName:bd,backendName:"cpu",kernelFunc:ctt};const bF=Ci(n=>Math.floor(n)),htt=sa(xd,bF),dtt={kernelName:xd,backendName:"cpu",kernelFunc:htt};const xF=ln((n,t)=>Math.floor(n/t)),ftt=kn(vd,xF,null,"int32"),ptt={kernelName:vd,backendName:"cpu",kernelFunc:ftt};function vF(n,t,e,s,r,i,o,l,c){const h=te([s,i],e);for(let d=0;d<s;d++){const p=[];let m=0;for(let y=0;y<r;y++){const b=n[d*r+y];m+=b*o[y],p.push(b)}if(m<0||m>=c/i)throw new Error(`Invalid indices: ${p} does not index into ${l}`);for(let y=0;y<i;y++)h.values[d*i+y]=t.get(...t.indexToLoc(m*i+y))}return h}function wF(n,t,e){const s=te(e,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),l=o[0],c=o[2],h=t.locToIndex([l,c]);o[2]=t.values[h];const d=n.locToIndex(o);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const SF=ln((n,t)=>n>t?1:0),mtt=kn(Ag,SF,null,"bool"),gtt={kernelName:Ag,backendName:"cpu",kernelFunc:mtt};const CF=ln((n,t)=>n>=t?1:0),ytt=kn(wd,CF,null,"bool"),btt={kernelName:wd,backendName:"cpu",kernelFunc:ytt};const TF=ln((n,t)=>n<t?1:0),xtt=kn(Rg,TF,null,"bool"),vtt={kernelName:Rg,backendName:"cpu",kernelFunc:xtt};const kF=ln((n,t)=>n<=t?1:0),wtt=kn(Dg,kF,null,"bool"),Stt={kernelName:Dg,backendName:"cpu",kernelFunc:wtt};function $F(n,t,e){const s=(t-n)/(e-1),r=Zn(e,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const EF=Ci(n=>Math.log(n)),Ctt=sa($d,EF),Ttt={kernelName:$d,backendName:"cpu",kernelFunc:Ctt};function IF(n,t,e,s){const r=Yn(s,ft(e));for(let i=0;i<r.length;++i){const o=i*t;let l=n[o];for(let c=0;c<t;++c){const h=n[o+c];(Number.isNaN(h)||h>l)&&(l=h)}r[i]=l}return r}const NF=ln(((n,t)=>Math.max(n,t))),ktt=kn(Id,NF),$tt={kernelName:Id,backendName:"cpu",kernelFunc:ktt};const AF=ln(((n,t)=>Math.min(n,t))),Ett=kn(Nd,AF),Itt={kernelName:Nd,backendName:"cpu",kernelFunc:Ett};const wC=ln(((n,t)=>n*t)),Ntt=xC(((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e}))),D0=kn(_d,wC,Ntt),Att={kernelName:_d,backendName:"cpu",kernelFunc:D0};function _F(n,t,e){const s=Xo(-1,e);return wC([],t,s,n,e)}function _tt(n){const{inputs:t,backend:e}=n,{x:s}=t;Nt(s,"neg");const r=e.data.get(s.dataId).values,[i,o]=_F(r,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,i)}const Rtt={kernelName:Gg,backendName:"cpu",kernelFunc:_tt};const RF=ln(((n,t)=>n!==t?1:0)),Dtt=kn(Wg,RF,null,"bool"),Ott={kernelName:Wg,backendName:"cpu",kernelFunc:Dtt};function SC(n,t,e,s,r){const i=t.length,o=ft(t),l=Dt(t),c=Dt(r),h=Yn(e,ft(r));for(let d=0;d<o;++d){const p=Xc(d,i,l),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[s[b]];const y=di(m,i,c);h[y]=n[d]}return h}function Cs(n){const{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:i}=e;Nt(r,"transpose");const o=r.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=r.shape[i[p]];const c=s.data.get(r.dataId).values,h=SC(c,r.shape,r.dtype,i,l);return{dataId:s.write(h,l,r.dtype),shape:l,dtype:r.dtype}}const Mtt={kernelName:Ic,backendName:"cpu",kernelFunc:Cs};function DF(n,t,e,s){const[r,i]=Dn(n,s),o=Ls(t,"int32"),l=Zn(ft(r),o),c=ft(i);for(let h=0;h<l.length;++h){const d=h*c;let p=1;for(let m=0;m<c;++m)p*=e[d+m];l[h]=p}return{outVals:l,outShape:r,outDtype:o}}function Ftt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"prod");const l=r.shape.length,c=ee(i,r.shape),h=Xe(c,l);let d=c,p=r;const m=[];h!=null&&(p=Cs({inputs:{x:r},backend:e,attrs:{perm:h}}),m.push(p),d=on(d.length,l));const y=e.data.get(p.dataId).values,{outVals:b,outShape:x,outDtype:w}=DF(p.shape,p.dtype,y,d);let S=x;return o&&(S=dn(x,c)),m.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(S,w,b)}const Ltt={kernelName:Zg,backendName:"cpu",kernelFunc:Ftt};function Ptt(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const i=Xc(r,t.length,Dt(t)).join(",");throw new Error(`indices[${i}] = ${s} is not in [0, ${e})`)}})}function ztt(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let i=1;i<s.length;++i)if(s[i-1]>s[i])throw new Error("Ragged splits must be sorted in ascending order")}}function Btt(n,t,e,s){const r=[];let i=0;const o=t.length-1+e.length,l=new Array(o).fill(null).map(()=>[0]);ztt(e,s);let c=1;for(let h=0;h<t.length-1;++h){c*=t[h];const d=t[h+1];for(let p=1;p<c+1;++p)l[h].push(p*d)}for(let h=0;h<n.length;++h){let d=n[h],p=n[h]+1;for(let m=0;m<e.length;++m){const y=e[m],b=m+t.length-1;if(b>=0){const x=l[b],w=x[x.length-1]-y[d];for(let S=d;S<p;++S)l[b].push(y[S+1]+w)}d=y[d],p=y[p]}p!==d&&(r.push([d,p]),i+=p-d)}return{outSplits:l,valueSlices:r,numValues:i}}function Vtt(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,r=nn("int32",s);t.push(r),n[e].forEach((i,o)=>r[o]=i)}return t}function jN(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function Utt(n,t,e,s,r,i){const o=jN(t,2)[1],l=jN(i,2)[1];let c=0;for(const h of e)for(let d=h[0];d<h[1];++d){for(let p=0;p<s;++p)r[c*l+p]=n[d*o+p];++c}}function jtt(n,t,e,s,r){const i=t.slice();i[0]=r;const o=nn(e,ft(i)),l=n.length,c=l===0?0:l/t[0];return Utt(n,t,s,c,o,i),[o,i]}function OF(n,t,e,s,r,i,o,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const c=t[0][0]-1;if(Ptt(i,o,c),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:p,numValues:m}=Btt(i,o,n,h),y=Vtt(d),b=jtt(e,s,r,p,m);return[y,b[0],b[1]]}const GN=2147483647;function MF(n,t,e,s,r,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const l=t.length===0,c=r.length===0,h=o.length===0,d=[];l||d.push(t[0]),c||d.push(r[0]),h||d.push(o[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=nn("int32",p+1);m[0]=0;for(let w=0;w<p;++w){const S=l?n[0]:n[w],T=c?s[0]:s[w],k=h?i[0]:i[w];if(k===0)throw new Error("Requires delta != 0");let $;if(k>0&&T<S||k<0&&T>S)$=0;else if($=Math.ceil(Math.abs((T-S)/k)),$>GN)throw new Error(`Requires ((limit - start) / delta) <= ${GN}`);m[w+1]=m[w]+$}const y=m[p],b=nn(e,y);let x=0;for(let w=0;w<p;++w){const S=m[w+1]-m[w];let T=l?n[0]:n[w];const k=h?i[0]:i[w];for(let $=0;$<S;++$)b[x++]=T,T+=k}return[m,b]}var yr=Gr;class Xm{constructor(t,e,s,r,i,o,l,c,h,d){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=l,this.rowPartitionValues=c,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=vO(d),this.raggedRank=wO(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===yr.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===yr.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case yr.VALUE_ROWIDS:return Xm.getMaxWidthValueRowID(e);case yr.ROW_SPLITS:return Xm.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${yr[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let r=0;r<e-1;++r){const i=t[r+1]-t[r];i>s&&(s=i)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,r=t[0],i=0;for(let o=1;o<e;++o){const l=t[o];l!==r&&(r=l,i=Math.max(o-s,i),s=o)}return Math.max(e-s,i)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return HN(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;SO(s,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=xO(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let l=1;l<=this.raggedRank;++l)o[l]<0&&(o[l]=this.getMaxWidth(l));return o}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),i=[];let o=0;for(let l=0;l<r;++l,o+=e)i.push(o);for(let l=r;l<t;++l)i.push(-1);return L(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,s,r){const i=t.length,o=[];for(let l=0;l<i-1;++l){const c=t[l+1]-t[l];let h=Math.min(r,c),d=e[l];d===-1&&(h=0);for(let p=0;p<h;++p)o.push(d),d+=s;for(let p=0;p<c-h;++p)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,s,r){const i=t.length,o=[];if(i===0)return[];let l=0,c=t[0];if(c>=e.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${e.length}`);let h=e[c];o.push(h);for(let d=1;d<i;++d){const p=t[d];if(p===c)h>=0&&(++l,l<r?h+=s:h=-1);else{if(l=0,c=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);h=e[p]}o.push(h)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,s,r){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case yr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,s,r);case yr.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,s,r);default:throw new Error(`Unsupported partition type: ${yr[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case yr.FIRST_DIM_SIZE:return t[0];case yr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case yr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${yr[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let c=r.length-2;c>=0;--c)r[c]=r[c+1]*s[c+1];const i=HN(s,!1),o=nn(this.valuesDType,ft(i));if(r[0]*s[0]>0){let c=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)c=this.calculateOutputIndex(h-1,c,r[h],s[h]);this.setOutput(this.raggedRank,c,o,i)}return[i,o]}setOutput(t,e,s,r){if(s.length===0)return;const i=this.values,o=s;let l=r.slice();l=l.slice(t+1);const c=ft(l),h=e.length;let d=this.defaultValue;if(d.length!==c&&d.length!==1){const b=this.defaultValueShape;rt(()=>{const x=et(d,b);d=Th(x,l).dataSync()})}let p=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?e[b]:-1;if(x===y){++y;continue}if(m<y){const w=i.subarray(p*c),S=o.subarray(m*c),T=(y-m)*c;WN(S,w,T)}if(b>=h){const w=s.length;x=Math.floor(w/c)}if(x>y)if(this.defaultValue.length===1)o.subarray(y*c,x*c).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=o.slice(y*c);WN(w,d,c),++y}x<0?(p=b+1,m=y):(p=b,m=y,y=m+1)}}}function WN(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function HN(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function FF(n,t,e,s,r,i,o,l,c,h){return new Xm(n,t,e,s,r,i,o,l,c,h).compute()}function LF(n,t,e,s){const r=n===t,i=n<t&&e<0,o=t<n&&e>1;if(r||i||o)return Zn(0,s);const l=Math.abs(Math.ceil((t-n)/e)),c=Zn(l,s);t<n&&e===1&&(e=-1),c[0]=n;for(let h=1;h<c.length;h++)c[h]=c[h-1]+e;return c}const PF=Ci(n=>1/Math.sqrt(n)),Gtt=sa(Ld,PF),Wtt={kernelName:Ld,backendName:"cpu",kernelFunc:Gtt};function Ua(n,t,e,s,r,i,o,l,c,h){const d=[s/r,r],p=n.values,m=t.values;if(s===0)return te(e,t.dtype);const y=c instanceof Pn?c:te(d,t.dtype);typeof c=="string"||typeof c=="number"?y.values.fill(c):typeof c=="boolean"&&y.values.fill(+c);for(let b=0;b<i;b++){const x=[];let w=0;for(let S=0;S<o;S++){const T=p[b*o+S];x.push(T),w+=T*l[S]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${e}`);for(let S=0;S<r;S++)h?y.values[w*r+S]+=m[b*r+S]:y.values[w*r+S]=t.rank===0?m[0]:m[b*r+S]}return y}const Htt=Ci(n=>1/(1+Math.exp(-n))),zF=ke(Ud,n=>1/(1+Math.exp(-n))),qtt={kernelName:Ud,backendName:"cpu",kernelFunc:zF};function BF(n,t,e,s,r){const i=NS(s,t,e),o=ft(e),l=Dt(s);if(i){const p=AS(t,l);return r==="string"?n.slice(p,p+o):n.subarray(p,p+o)}const c=r==="string"?Zi(n):n,h=te(s,r,c),d=te(e,r);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),y=m.map((b,x)=>b+t[x]);d.set(h.get(...y),...m)}return r==="string"?UO(d.values):d.values}function ll(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s;Nt(r,"slice");const[l,c]=b0(r,i,o);ES(r,l,c);const h=e.data.get(r.dataId).values,d=BF(h,l,c,r.shape,r.dtype);return e.makeTensorInfo(c,r.dtype,d)}const Ktt={kernelName:s0,backendName:"cpu",kernelFunc:ll};function VF(n,t,e,s,r,i,o){const l=t[0],c=i[0],h=new Array(c),d=new Array(l),p=t[1];if(c===0){if(l!==0)throw new Error(NO(l));const w=nn(e,0),S=nn(r,0);return[w,[0,p],S,h,d]}let m=!0,y=0;const b=new Array(c).fill(0);for(let w=0;w<l;++w){const S=n[w*p];if(S<0)throw new Error(AO(w,S));if(S>=c)throw new Error(_O(w,S,c));++b[S],m=m&&S>=y,y=S}let x=!0;for(let w=0;w<c;++w){const S=b[w]===0;h[w]=S,x=x&&!S,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,S=s;for(let T=0;T<l;++T)d[T]=T;return[w,[l,p],S,h,d]}else{const w=b[c-1],S=nn(e,w*p),T=nn(r,w),k=new Array(c).fill(0);for(let $=0;$<l;++$){const E=n[$*p],N=k[E],_=(E===0?0:b[E-1])+N;k[E]++;for(let R=0;R<p;++R)S[_*p+R]=n[$*p+R];T[_]=s[$],d[$]=_}for(let $=0;$<c;++$)if(k[$]===0){const N=$===0?0:b[$-1];S[N*p+0]=$;for(let _=1;_<p;++_)S[N*p+_]=0;T[N]=o}return[S,[w,p],T,h,d]}}function UF(n,t,e,s,r){const i=ft(s),o=t[0],l=r.length,c=[];let h=1,d=-1;for(let w=0;w<l;++w){const S=r[w];if(S===-1){if(d!==-1)throw new Error(RO(d,w));d=w,c.push(1)}else{if(S<0)throw new Error(DO(w,S));h*=S,c.push(S)}}if(d!==-1){if(h<=0)throw new Error(OO());const w=Math.trunc(i/h);if(h*w!==i)throw new Error(MO(s,c));c[d]=w}if(ft(c)!==i)throw new Error(FO(s,c));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(l>0){b[l-1]=1;for(let w=l-2;w>=0;--w)b[w]=b[w+1]*c[w+1]}const x=nn(e,o*l);for(let w=0;w<o;++w){let S=0;for(let T=0;T<m;++T)S+=n[w*m+T]*y[T];for(let T=0;T<l;++T)x[w*l+T]=Math.trunc(S/b[T]),S%=b[T]}return[x,[o,l],c]}function CC(n,t,e,s,r,i=!1,o=0){const l=s.length,c=[t[0],n.length/t[0]],h=c[1],p=l>0?r[l-1]+1:0;if(p<0)throw new Error(Xv());const m=t.slice();m[0]=p;const y=m.reduce((k,$)=>k*$,1),b=nn(e,y);if(l===0)return p>0&&b.fill(o),[b,m];if(p<=0)throw new Error(Xv());let x=0,w=1,S=0,T=r[x];for(;;){let k=0;if(w<l){if(k=r[w],T===k){++w;continue}if(T>=k)throw new Error(LO())}if(T<0||T>=p)throw new Error(PO(T,p));T>S&&b.fill(o,S*h,T*h);for(let $=x;$<w;++$){const E=s[$];if(E<0||E>=c[0])throw new Error(zO($,s[$],c[0]));for(let N=0;N<h;N++)b[T*h+N]+=n[E*h+N]}if(i)for(let $=0;$<h;$++)b[T*h+$]/=w-x;if(x=w,++w,S=T+1,T=k,w>l)break}return S<p&&b.fill(o,S*h,p*h),[b,m]}const Xtt=Ci(n=>Math.sqrt(n)),Ytt=ke(Gd,n=>Math.sqrt(n)),Ztt={kernelName:Gd,backendName:"cpu",kernelFunc:Ytt};const jF=ln(((n,t)=>{const e=n-t;return e*e})),Jtt=kn(Wd,jF),Qtt={kernelName:Wd,backendName:"cpu",kernelFunc:Jtt};const GF=Ci((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)}),tet=sa(B1,GF),eet={kernelName:B1,backendName:"cpu",kernelFunc:tet};function WF(n,t,e,s){const r=te(n,t.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),l=new Array(o.length);for(let c=0;c<l.length;c++)l[c]=o[c]*e[c]+s[c];r.set(t.get(...l),...o)}return r}class net{constructor(t,e,s,r,i,o){this.separator=Fo(t),this.nGramWidths=e,this.leftPad=Fo(s),this.rightPad=Fo(r),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,i,o){for(let l=0;l<i;++l){const c=this.getPadWidth(o),h=Math.max(0,c-l),d=Math.max(0,c-(i-(l+1))),p=o-(h+d),m=e+(h>0?0:l-c);let y=0;y+=h*this.leftPad.length;for(let T=0;T<p;++T)y+=t[m+T].length;y+=d*this.rightPad.length;const b=h+d+p-1;y+=b*this.separator.length,s[r+l]=new Uint8Array(y);const x=s[r+l];let w=0;const S=T=>T.forEach(k=>x[w++]=k);for(let T=0;T<h;++T)S(this.leftPad),S(this.separator);for(let T=0;T<p-1;++T)S(t[m+T]),S(this.separator);if(p>0){S(t[m+p-1]);for(let T=0;T<d;++T)S(this.separator),S(this.rightPad)}else{for(let T=0;T<d-1;++T)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let c=e[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let h=1;h<r;++h){let d=e[h]>=c;if(d=d&&e[h]<=s,!d)throw new Error(`Invalid split value ${e[h]}, must be in [${c}, ${s}]`);c=e[h]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const i=r-1,o=nn("int32",r);if(s===0||r===0){const c=new Array(s);for(let h=0;h<=i;++h)o[h]=0;return[c,o]}o[0]=0;for(let c=1;c<=i;++c){const h=e[c]-e[c-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&d===0&&(d=1),o[c]=o[c-1]+d}const l=new Array(o[i]);for(let c=0;c<i;++c){const h=e[c];let d=o[c];if(this.nGramWidths.forEach(p=>{const m=e[c+1]-e[c],y=this.getNumNGrams(m,p);this.createNGrams(t,h,l,d,y,p),d+=y}),this.preserveShort&&d===o[c]){const p=e[c+1]-e[c];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(t,h,l,d,1,m)}}return[l,o]}}function HF(n,t,e,s,r,i,o,l){return new net(e,s,r,i,o,l).compute(n,t)}function set(n,t,e,s){if(!n.length)return;if(t.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(t.length===1){const i=t[0];let o=n.indexOf(i);for(;o!==-1;){const l=n.subarray(0,o);(!e||l.length!==0)&&s.push(l),n=n.subarray(o+1),o=n.indexOf(i)}(!e||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||t.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!e||o.length!==0)&&s.push(o),r=i+1}}function qF(n,t,e){const s=n.length,r=[];let i=0,o=0;const l=new Array(s);for(let m=0;m<s;++m){const y=r.length;set(n[m],t,e,r);const b=r.length-y;l[m]=b,i+=b,o=Math.max(o,b)}const c=nn("int32",i*2),h=new Array(i),d=[s,o];let p=0;for(let m=0;m<s;++m)for(let y=0;y<l[m];++y)c[p*2]=m,c[p*2+1]=y,h[p]=r[p],++p;return[c,h,d]}function KF(n,t){const e=nn("int32",n.length);for(let s=0;s<n.length;++s)e[s]=d6(n[s]).modulo(t).getLowBitsUnsigned();return e}const XF=ln(((n,t)=>n-t)),ret=xC(((n,t,e,s)=>({real:n-e,imag:t-s}))),TC=kn(Hd,XF,ret),iet={kernelName:Hd,backendName:"cpu",kernelFunc:TC};function YF(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=te(e,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let c=0;c<o.length;c++)o[c]=i[c]%n.shape[c];const l=n.locToIndex(o);s.values[r]=n.values[l]}return s}const ph=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function ZF(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const l=s-e+1,c=t-e+1,h=Math.log(l),d=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*d*(l-d)/l)*Math.sign(c-l/2),m=Math.max(e,Math.floor(t-c*d/l+p)),y=Math.min(s,Math.floor(t+(l-c)*d/l+p));ZF(n,t,m,y)}const r=n[t];let i=e,o=s;for(gc(n,e,t),ph(n[s],r)>0&&gc(n,e,s);i<o;){for(gc(n,i,o),i++,o--;ph(n[i],r)<0;)i=i+1;for(;ph(n[o],r)>0;)o=o-1}ph(n[e],r)===0?gc(n,e,o):(o=o+1,gc(n,o,s)),o<=t&&(e=o+1),t<=o&&(s=o-1)}}function JF(n,t,e,s,r){const i=t[t.length-1],[o,l]=[n.length/i,i],c=Yn(e,o*s),h=Yn("int32",o*s);for(let p=0;p<o;p++){const m=p*l,y=n.subarray(m,m+l);let b=new Array(y.length);y.forEach((T,k)=>b[k]={value:T,index:k}),s<b.length&&(ZF(b,s),b=b.slice(0,s)),r&&b.sort(ph);const x=p*s,w=c.subarray(x,x+s),S=h.subarray(x,x+s);for(let T=0;T<s;T++)w[T]=b[T].value,S[T]=b[T].index}const d=t.slice();return d[d.length-1]=s,[te(d,e,c),te(d,"int32",h)]}function QF(n,t,e,s){const r=ee(t,e)[0],i=[1,e[0],1];for(let b=0;b<r;b++)i[0]*=e[b];i[1]=e[r];for(let b=r+1;b<e.length;b++)i[2]*=e[b];const o=new Map,l=new Int32Array(e[r]),c=new Pn(i,s,n),h=[],d=i[0]===1&&i[2]===1;for(let b=0;b<e[r];b++){let x;if(d)x=n[b].toString();else{const S=[];for(let T=0;T<i[0];T++)for(let k=0;k<i[2];k++)S.push(c.get(T,b,k));x=S.join(",")}const w=o.get(x);if(w!=null)l[b]=w;else{const S=o.size;o.set(x,S),l[b]=S,h.push(b)}}const p=i.slice();p[1]=o.size;const m=new Pn(p,s);h.forEach((b,x)=>{for(let w=0;w<i[0];w++)for(let S=0;S<i[2];S++)m.set(c.get(w,b,S),w,x,S)});const y=e.slice();return y[r]=p[1],{outputValues:m.values,outputShape:y,indices:l}}const oet=Object.freeze(Object.defineProperty({__proto__:null,addImpl:lF,bincountImpl:vC,bincountReduceImpl:cF,bitwiseAndImpl:uF,castImpl:aF,ceilImpl:hF,concatImpl:dF,equalImpl:fF,expImpl:mF,expm1Impl:yF,floorDivImpl:xF,floorImpl:bF,gatherNdImpl:vF,gatherV2Impl:wF,greaterEqualImpl:CF,greaterImpl:SF,lessEqualImpl:kF,lessImpl:TF,linSpaceImpl:$F,logImpl:EF,maxImpl:IF,maximumImpl:NF,minimumImpl:AF,multiplyImpl:wC,negImpl:_F,notEqualImpl:RF,prodImpl:DF,raggedGatherImpl:OF,raggedRangeImpl:MF,raggedTensorToTensorImpl:FF,rangeImpl:LF,rsqrtImpl:PF,scatterImpl:Ua,sigmoidImpl:Htt,simpleAbsImpl:oF,sliceImpl:BF,sparseFillEmptyRowsImpl:VF,sparseReshapeImpl:UF,sparseSegmentReductionImpl:CC,sqrtImpl:Xtt,squaredDifferenceImpl:jF,staticRegexReplaceImpl:GF,stridedSliceImpl:WF,stringNGramsImpl:HF,stringSplitImpl:qF,stringToHashBucketFastImpl:KF,subImpl:XF,tileImpl:YF,topKImpl:JF,transposeImpl:SC,uniqueImpl:QF},Symbol.toStringTag,{value:"Module"}));yD("cpu",()=>new R0,1);const tL=ke(md,n=>n>=0?n:Math.exp(n)-1),aet={kernelName:md,backendName:"cpu",kernelFunc:tL};function eL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s;Nt([r],"leakyRelu");const o=ft(r.shape),l=e.data.get(r.dataId).values,c=Yn("float32",o);for(let h=0;h<l.length;h++)c[h]=l[h]<0?i*l[h]:l[h];return e.makeTensorInfo(r.shape,"float32",c)}const cet={kernelName:_g,backendName:"cpu",kernelFunc:eL};const uet=ln((n,t)=>n<0?t*n:n);function nL(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t;Nt([s,r],"prelu");const i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,[l,c]=uet(s.shape,r.shape,i,o,"float32");return e.makeTensorInfo(c,"float32",l)}const het={kernelName:Yg,backendName:"cpu",kernelFunc:nL};const sL=ke(Od,n=>Math.max(0,n)),det={kernelName:Od,backendName:"cpu",kernelFunc:sL};const rL=ke(Md,n=>Math.min(Math.max(0,n),6)),fet={kernelName:Md,backendName:"cpu",kernelFunc:rL};function Ym(n,t,e,s,r){if(e==="linear")return Si({inputs:{x:t},backend:n});if(e==="relu")return sL({inputs:{x:t},backend:n});if(e==="elu")return tL({inputs:{x:t},backend:n});if(e==="relu6")return rL({inputs:{x:t},backend:n});if(e==="prelu")return nL({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return eL({inputs:{x:t},backend:n,attrs:{alpha:r}});if(e==="sigmoid")return zF({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Le(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=ft(r.shape),l=ER(i,o),c=ft(l);L(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const h=e.data.get(r.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;d.shape=l,p.shape=l}return{dataId:r.dataId,shape:l,dtype:r.dtype}}const pet={kernelName:Jg,backendName:"cpu",kernelFunc:Le};function iL(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:l}=s;Nt([r,i],"matMul");const c=r.shape.length,h=i.shape.length,d=o?r.shape[c-2]:r.shape[c-1],p=l?i.shape[h-1]:i.shape[h-2],m=o?r.shape[c-1]:r.shape[c-2],y=l?i.shape[h-2]:i.shape[h-1],b=r.shape.slice(0,-2),x=i.shape.slice(0,-2),w=ft(b),S=ft(x),k=qt(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([m,y]);L(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${o} and transposeB=${l} must match.`);const $=o?[w,d,m]:[w,m,d],E=l?[S,y,p]:[S,p,y],N=Le({inputs:{x:r},backend:e,attrs:{shape:$}}),_=Le({inputs:{x:i},backend:e,attrs:{shape:E}}),R=o?N.shape[1]:N.shape[2],D=o?N.shape[2]:N.shape[1],M=l?_.shape[1]:_.shape[2],A=Math.max(w,S),B=e.data.get(N.dataId).values,H=e.data.get(_.dataId).values,W=Dt(N.shape),X=Dt(_.shape),[P,U,G]=o?[W[0],1,W[1]]:[W[0],W[1],1],[tt,Z,F]=l?[1,X[1],X[0]]:[X[1],1,X[0]],z=D*M,Q=te([A,D,M],N.dtype),ct=Q.values,pt=e.blockSize;for(let gt=0;gt<A;gt++){const xt=gt%w,kt=gt%S;for(let Ct=0;Ct<D;Ct+=pt){const Ot=Math.min(Ct+pt,D);for(let Gt=0;Gt<M;Gt+=pt){const Yt=Math.min(Gt+pt,M);for(let ge=0;ge<R;ge+=pt){const me=Math.min(ge+pt,R);for(let re=Ct;re<Ot;re++)for(let Zt=Gt;Zt<Yt;Zt++){let Ce=0;for(let ae=ge;ae<me;ae++){const fs=B[xt*P+re*U+ae*G],We=H[ae*tt+Zt*Z+kt*F];Ce+=fs*We}ct[gt*z+(re*M+Zt)]+=Ce}}}}}return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(_),e.makeTensorInfo(k,Q.dtype,Q.values)}const met={kernelName:gg,backendName:"cpu",kernelFunc:iL};function get(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=t,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;let m,y,b;const x=[];m=iL({inputs:{a:r,b:i},attrs:{transposeA:c,transposeB:h},backend:e}),o&&(y=Bc({inputs:{a:m,b:o},backend:e}),x.push(m),m=y),d&&(b=Ym(e,m,d,l,p),x.push(m),m=b);for(const S of x)e.disposeIntermediateTensorInfo(S);return m}const yet={kernelName:Im,backendName:"cpu",kernelFunc:get};const bet=ke(nd,n=>Math.acos(n)),xet={kernelName:nd,backendName:"cpu",kernelFunc:bet};const vet=ke(sd,n=>Math.acosh(n)),wet={kernelName:sd,backendName:"cpu",kernelFunc:vet};function Cet(n){const{inputs:t,backend:e}=n,s=t;Nt(t,"addN");const r=s.map(l=>e.data.get(l.dataId).values),i=te(s[0].shape,s[0].dtype),o=i.values;for(let l=0;l<s.length;l++){const c=r[l];for(let h=0;h<o.length;h++)o[h]+=c[h]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}const Tet={kernelName:i1,backendName:"cpu",kernelFunc:Cet};function ket(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"all");const l=ee(i,r.shape);let c=l;const h=Xe(c,r.shape.length);let d=r;h!=null&&(d=Cs({inputs:{x:r},backend:e,attrs:{perm:h}}),c=on(c.length,r.shape.length)),Bn("all",c,d.shape.length);const[p,m]=Dn(d.shape,c),y=ft(m),b=Zn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k&&E}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=dn(p,l),T=Le({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const $et={kernelName:o1,backendName:"cpu",kernelFunc:ket};function Eet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"any");const l=ee(i,r.shape);let c=l;const h=Xe(c,r.shape.length);let d=r;h!=null&&(d=Cs({inputs:{x:r},backend:e,attrs:{perm:h}}),c=on(c.length,r.shape.length)),Bn("any",c,d.shape.length);const[p,m]=Dn(d.shape,c),y=ft(m),b=Zn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k||E}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=dn(p,l),T=Le({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const Iet={kernelName:a1,backendName:"cpu",kernelFunc:Eet};function Net(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;Nt(r,"argMax");let o=ee(i,r.shape);const l=Xe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=Cs({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=on(o.length,c.shape.length)),o=[o[0]],Bn("argMax",o,c.shape.length);const[d,p]=Dn(c.shape,o),m=ft(d),y=Zn(m,"int32"),b=ft(p),x=e.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E>T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(d,"int32",y)}const Aet={kernelName:dg,backendName:"cpu",kernelFunc:Net};function _et(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;Nt(r,"argMin");let o=ee(i,r.shape);const l=Xe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=Cs({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=on(o.length,c.shape.length)),o=[o[0]],Bn("argMin",o,c.shape.length);const[d,p]=Dn(c.shape,o),m=ft(d),y=Zn(m,"int32"),b=ft(p),x=e.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E<T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(d,"int32",y)}const Ret={kernelName:fg,backendName:"cpu",kernelFunc:_et};const Det=ke(rd,n=>Math.asin(n)),Oet={kernelName:rd,backendName:"cpu",kernelFunc:Det};const Met=ke(id,n=>Math.asinh(n)),Fet={kernelName:id,backendName:"cpu",kernelFunc:Met};const Let=ke(od,n=>Math.atan(n)),Pet={kernelName:od,backendName:"cpu",kernelFunc:Let};const zet=ln((n,t)=>Math.atan2(n,t)),Bet=kn(ld,zet),Vet={kernelName:ld,backendName:"cpu",kernelFunc:Bet};const Uet=ke(ad,n=>Math.atanh(n)),jet={kernelName:ad,backendName:"cpu",kernelFunc:Uet};function kC(n,t,e,s,r,i){const o=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=te(r.outShape,e),w=x.values,S=r.outShape[1]*r.outShape[2]*r.outShape[3],T=r.outShape[2]*r.outShape[3],k=r.outShape[3];for(let $=0;$<r.batchSize;++$){const E=$*S,N=$*s[0];for(let _=0;_<r.inChannels;++_)for(let R=0;R<r.outHeight;++R){const D=R*o-m,M=Math.max(0,D),A=Math.min(r.inHeight,d+D),B=E+R*T;for(let H=0;H<r.outWidth;++H){const W=H*l-y,X=Math.max(0,W),P=Math.min(r.inWidth,p+W);let U=b,G=0,tt=0;for(let F=M;F<A;F+=c){const z=N+F*s[1];for(let Q=X;Q<P;Q+=h){const ct=z+Q*s[2],pt=n[ct+_];i==="max"&&pt>U?U=pt:i==="avg"&&(G+=pt,tt++)}if(isNaN(U))break}const Z=B+H*k+_;w[Z]=i==="avg"?G/tt:U}}}return x}function oL(n,t,e,s,r=!1,i=!1){const o=te(s.outShape,"int32"),l=s.strideHeight,c=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=te(t,e,n);for(let w=0;w<s.batchSize;++w)for(let S=0;S<s.inChannels;++S)for(let T=0;T<s.outHeight;++T){const k=T*l-y;let $=k;for(;$<0;)$+=h;const E=Math.min(s.inHeight,p+k);for(let N=0;N<s.outWidth;++N){const _=N*c-b;let R=_;for(;R<0;)R+=d;const D=Math.min(s.inWidth,m+_);let M=Number.NEGATIVE_INFINITY,A=-1;for(let B=$;B<E;B+=h){const H=B-k;for(let W=R;W<D;W+=d){const X=W-_,P=x.get(w,B,W,S);P>M&&(M=P,r?A=i?((w*s.inHeight+B)*s.inWidth+W)*s.inChannels+S:(B*s.inWidth+W)*s.inChannels+S:A=H*m+X)}}o.set(A,w,T,N,S)}}return o}function aL(n,t,e,s,r,i){const o=r.strideDepth,l=r.strideHeight,c=r.strideWidth,h=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,S=r.padInfo.left,T=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=te(r.outShape,e),$=k.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[3]*r.outShape[4],R=r.outShape[4];for(let D=0;D<r.batchSize;++D){const M=D*E,A=D*s[0];for(let B=0;B<r.inChannels;++B)for(let H=0;H<r.outDepth;++H){const W=H*o-x;let X=W;for(;X<0;)X+=h;const P=Math.min(r.inDepth,m+W),U=M+H*N;for(let G=0;G<r.outHeight;++G){const tt=G*l-w;let Z=tt;for(;Z<0;)Z+=d;const F=Math.min(r.inHeight,y+tt),z=U+G*_;for(let Q=0;Q<r.outWidth;++Q){const ct=Q*c-S;let pt=ct;for(;pt<0;)pt+=p;const gt=Math.min(r.inWidth,b+ct),xt=z+Q*R;let kt=T,Ct=0,Ot=0;for(let Yt=X;Yt<P;Yt+=h){const ge=A+Yt*s[1];for(let me=Z;me<F;me+=d){const re=ge+me*s[2];for(let Zt=pt;Zt<gt;Zt+=p){const Ce=re+Zt*s[3],ae=n[Ce+B];if(i==="max"&&ae>kt?kt=ae:i==="avg"&&(Ct+=ae,Ot++),isNaN(kt))break}if(isNaN(kt))break}if(isNaN(kt))break}const Gt=xt+B;$[Gt]=i==="avg"?Ct/Math.max(Ot,1):kt}}}}return k}function Get(n,t){const e=te(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,h=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;for(let x=0;x<t.batchSize;++x)for(let w=0;w<t.inChannels;++w)for(let S=0;S<t.outDepth;++S){const T=S*s-m;let k=T;for(;k<0;)k+=o;const $=Math.min(t.inDepth,h+T);for(let E=0;E<t.outHeight;++E){const N=E*r-y;let _=N;for(;_<0;)_+=l;const R=Math.min(t.inHeight,d+N);for(let D=0;D<t.outWidth;++D){const M=D*i-b;let A=M;for(;A<0;)A+=c;const B=Math.min(t.inWidth,p+M);let H=Number.NEGATIVE_INFINITY,W=-1;for(let X=k;X<$;X+=o){const P=X-T;for(let U=_;U<R;U+=l){const G=U-N;for(let tt=A;tt<B;tt+=c){const Z=tt-M,F=n.get(x,X,U,tt,w);F>=H&&(H=F,W=P*d*p+G*d+Z)}}}e.set(W,x,S,E,D,w)}}}return e}function Wet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Nt(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Qn(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Er(r.shape,i,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))p=Si({inputs:{x:r},backend:e});else{const m=e.data.get(r.dataId).values,y=Dt(r.shape),b=kC(m,r.shape,r.dtype,y,d,"avg");p=e.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const Het={kernelName:pg,backendName:"cpu",kernelFunc:Wet};function qet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Nt(r,"avgPool3d");const d=to(r.shape,i,o,1,l,c,h),p=e.data.get(r.dataId).values,m=aL(p,r.shape,r.dtype,Dt(r.shape),d,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}const Ket={kernelName:mg,backendName:"cpu",kernelFunc:qet};function Xet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Nt([r,i],"avgPool3DGrad");const d=to(i.shape,o,l,1,c,h),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,S=d.dilationDepth,T=d.dilationHeight,k=d.dilationWidth,$=d.effectiveFilterDepth,E=d.effectiveFilterHeight,N=d.effectiveFilterWidth,_=$-1-d.padInfo.front,R=N-1-d.padInfo.left,D=E-1-d.padInfo.top,M=te(i.shape,"float32"),A=1/(b*x*w),B=e.bufferSync(r);for(let H=0;H<d.batchSize;++H)for(let W=0;W<d.inChannels;++W)for(let X=0;X<d.inDepth;++X)for(let P=0;P<d.inHeight;++P)for(let U=0;U<d.inWidth;++U){const G=X-_,tt=P-D,Z=U-R;let F=0;for(let z=0;z<$;z+=S){const Q=(G+z)/p;if(!(Q<0||Q>=d.outDepth||Math.floor(Q)!==Q))for(let ct=0;ct<E;ct+=T){const pt=(tt+ct)/m;if(!(pt<0||pt>=d.outHeight||Math.floor(pt)!==pt))for(let gt=0;gt<N;gt+=k){const xt=(Z+gt)/y;if(xt<0||xt>=d.outWidth||Math.floor(xt)!==xt)continue;const kt=B.get(H,Q,pt,xt,W);F+=kt}}}M.set(F*A,H,X,P,U,W)}return e.makeTensorInfo(M.shape,M.dtype,M.values)}const Yet={kernelName:c1,backendName:"cpu",kernelFunc:Xet};function Zet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;Nt([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=Er(o.shape,l,c,1,h),p=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,S=d.effectiveFilterHeight,T=d.effectiveFilterWidth,k=T-1-d.padInfo.left,$=S-1-d.padInfo.top,E=te(o.shape,"float32"),N=1/(y*b),_=e.data.get(r.dataId).values,R=te(r.shape,"float32",_);for(let D=0;D<d.batchSize;++D)for(let M=0;M<d.inChannels;++M)for(let A=0;A<d.inHeight;++A)for(let B=0;B<d.inWidth;++B){const H=A-$,W=B-k;let X=0;for(let P=0;P<S;P+=x){const U=(H+P)/p;if(!(U<0||U>=d.outHeight||Math.floor(U)!==U))for(let G=0;G<T;G+=w){const tt=(W+G)/m;if(tt<0||tt>=d.outWidth||Math.floor(tt)!==tt)continue;const Z=R.get(D,U,tt,M);X+=Z}}E.set(X*N,D,A,B,M)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}const Jet={kernelName:l1,backendName:"cpu",kernelFunc:Zet};function Qet(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,scale:i,offset:o,mean:l,variance:c}=t;L(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(i==null||l.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Nt([r,l,c,i,o],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=e.data.get(r.dataId).values,p=e.data.get(l.dataId).values,m=e.data.get(c.dataId).values,y=i?e.data.get(i.dataId).values:new Float32Array([1]),b=o?e.data.get(o.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,S=y.length,T=m.length,k=p.length;let $=0,E=0,N=0,_=0;for(let R=0;R<d.length;++R)x[R]=b[$++]+(d[R]-p[E++])*y[N++]/Math.sqrt(m[_++]+h),$>=w&&($=0),E>=k&&(E=0),N>=S&&(N=0),_>=T&&(_=0);return e.makeTensorInfo(r.shape,r.dtype,x)}const tnt={kernelName:Ig,backendName:"cpu",kernelFunc:Qet};function ent(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;Nt([r],"batchToSpaceND");const l=i.reduce((S,T)=>S*T),c=rf(r.shape,i,l),h=of(c.length,i.length),d=af(r.shape,i,l),p=MS(o,i.length),m=FS(d,o,i.length),y=Le({inputs:{x:r},backend:e,attrs:{shape:c}}),b=Cs({inputs:{x:y},backend:e,attrs:{perm:h}}),x=Le({inputs:{x:b},backend:e,attrs:{shape:d}}),w=ll({inputs:{x},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),w}const nnt={kernelName:yg,backendName:"cpu",kernelFunc:ent};function snt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,h=vC(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,h)}const rnt={kernelName:u1,backendName:"cpu",kernelFunc:snt};function int(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,l=qt(Array.from(i),Array.from(o));return e.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const ont={kernelName:DR,backendName:"cpu",kernelFunc:int};const ant=ke(hd,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),lnt={kernelName:hd,backendName:"cpu",kernelFunc:ant};const cnt=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(ft(t.shape)),r=e.data.get(t.dataId),i=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,l=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values;for(let h=0;h<l.length;h++){const d=l[h],p=c[h];s[h]=Math.hypot(d,p)}return e.makeOutput(s,t.shape,"float32")},unt={kernelName:bg,backendName:"cpu",kernelFunc:cnt};function Vc(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,i=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,i)}const hnt={kernelName:I1,backendName:"cpu",kernelFunc:Vc};function Uc(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=ee(r,t[0].shape)[0],o=t.map(x=>x.shape);RS(o,i);let l=pi(t.map(x=>x.shape),i);if(ft(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const c=t.filter(x=>ft(x.shape)>0);if(c.length===1)return Si({inputs:{x:c[0]},backend:e});if(c[0].dtype==="complex64"){const x=c.map($=>al({inputs:{input:$},backend:e})),w=c.map($=>Vc({inputs:{input:$},backend:e})),S=Uc({inputs:x,backend:e,attrs:{axis:i}}),T=Uc({inputs:w,backend:e,attrs:{axis:i}}),k=Os({inputs:{real:S,imag:T},backend:e});return x.forEach($=>e.disposeIntermediateTensorInfo($)),w.forEach($=>e.disposeIntermediateTensorInfo($)),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),k}const h=c.map(x=>{const S=[-1,ft(x.shape.slice(i))];return Le({inputs:{x},backend:e,attrs:{shape:S}})}),d=h.map(x=>({vals:e.data.get(x.dataId).values,shape:x.shape}));l=pi(h.map(x=>x.shape),1);const p=h[0].shape[0]===1,m=dF(d,l,t[0].dtype,p),y=pi(c.map(x=>x.shape),i),b=e.makeTensorInfo(y,t[0].dtype,m);return h.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const dnt={kernelName:xg,backendName:"cpu",kernelFunc:Uc};function lL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s;Nt([r,i],"conv2d");const p=eo(c),m=zn(r.shape,i.shape,o,h,l,d,!1,p),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,S=m.padInfo.left,T=m.padInfo.top,k=m.dataFormat==="channelsLast",$=new Pn(m.outShape,r.dtype),E=Dt(r.shape),N=Dt(i.shape),_=E[0],R=k?E[1]:E[2],D=k?E[2]:1,M=k?1:E[1],A=$.strides[0],B=k?$.strides[1]:$.strides[2],H=k?$.strides[2]:1,W=k?1:$.strides[1],X=e.data.get(r.dataId).values,P=e.data.get(i.dataId).values,U=$.values;for(let G=0;G<m.batchSize;++G){const tt=G*_,Z=G*A;for(let F=0;F<m.outHeight;++F){const z=Z+F*B,Q=F*m.strideHeight-T;for(let ct=0;ct<y;++ct){const pt=Q+ct*x;if(pt<0||pt>=m.inHeight)continue;const gt=ct*N[0],xt=tt+pt*R;for(let kt=0;kt<m.outWidth;++kt){const Ct=z+kt*H,Ot=kt*m.strideWidth-S;for(let Gt=0;Gt<b;++Gt){const Yt=Ot+Gt*w;if(Yt<0||Yt>=m.inWidth)continue;const ge=gt+Gt*N[1],me=xt+Yt*D;let re=ge;for(let Zt=0;Zt<m.inChannels;++Zt){const Ce=X[me+Zt*M];for(let ae=0;ae<m.outChannels;++ae)U[Ct+ae*W]+=Ce*P[re+ae];re+=m.outChannels}}}}}}return e.makeTensorInfo($.shape,$.dtype,U)}const fnt={kernelName:vg,backendName:"cpu",kernelFunc:lL};function pnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s;Nt([r,i],"conv2dBackpropFilter");const p=eo(c),m=zn(r.shape,d,o,1,l,h,!1,p),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,S=m.dataFormat==="channelsLast",T=new Pn(m.filterShape,"float32"),k=m.padInfo.left,$=m.padInfo.top,E=e.data.get(r.dataId).values,N=e.data.get(i.dataId).values,_=new Pn(r.shape,r.dtype,E),R=new Pn(i.shape,i.dtype,N);for(let D=0;D<x;++D){const M=Math.max(0,Math.ceil(($-D)/y)),A=Math.min(m.outHeight,(m.inHeight+$-D)/y);for(let B=0;B<w;++B){const H=Math.max(0,Math.ceil((k-B)/b)),W=Math.min(m.outWidth,(m.inWidth+k-B)/b);for(let X=0;X<m.inChannels;++X)for(let P=0;P<m.outChannels;++P){let U=0;for(let G=0;G<m.batchSize;++G)for(let tt=M;tt<A;++tt){const Z=D+tt*y-$;for(let F=H;F<W;++F){const z=B+F*b-k;S?U+=_.get(G,Z,z,X)*R.get(G,tt,F,P):U+=_.get(G,X,Z,z)*R.get(G,P,tt,F)}}T.set(U,D,B,X,P)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const mnt={kernelName:f1,backendName:"cpu",kernelFunc:pnt};function gnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s;Nt([r,i],"conv2dBackpropInput");const p=Dt(i.shape),m=Dt(r.shape);let y=eo(h);const b=zn(o,i.shape,l,1,c,d,!1,y),x=new Pn(b.inShape,"float32"),w=x.values,S=e.data.get(r.dataId).values,T=e.data.get(i.dataId).values,[k,$,E]=p,{batchSize:N,filterHeight:_,filterWidth:R,inChannels:D,inHeight:M,inWidth:A,outChannels:B,outHeight:H,outWidth:W,strideHeight:X,strideWidth:P}=b;y=b.dataFormat;const U=_-1-b.padInfo.top,G=R-1-b.padInfo.left,tt=y==="channelsLast",Z=x.strides[0],F=tt?x.strides[1]:x.strides[2],z=tt?x.strides[2]:1,Q=tt?1:x.strides[1],ct=m[0],pt=tt?m[1]:m[2],gt=tt?m[2]:1,xt=tt?1:m[1];for(let kt=0;kt<N;++kt)for(let Ct=0;Ct<D;++Ct)for(let Ot=0;Ot<M;++Ot){const Gt=Ot-U,Yt=Math.max(0,Math.ceil(Gt/X)),ge=Math.min(H,(_+Gt)/X);for(let me=0;me<A;++me){const re=me-G,Zt=Math.max(0,Math.ceil(re/P)),Ce=Math.min(W,(R+re)/P);let ae=0;for(let We=Yt;We<ge;++We){const ks=We*X-Gt;for(let On=Zt;On<Ce;++On){const Ar=On*P-re,De=ct*kt+pt*We+gt*On,Bs=k*(_-1-ks)+$*(R-1-Ar)+E*Ct;for(let Vs=0;Vs<B;++Vs){const Pt=S[De+xt*Vs],se=T[Bs+Vs];ae+=Pt*se}}}const fs=Z*kt+F*Ot+z*me+Q*Ct;w[fs]=ae}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const ynt={kernelName:wg,backendName:"cpu",kernelFunc:gnt};function bnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c}=s;Nt([r,i],"conv3d");const h=Zo(r.shape,i.shape,o,c,l),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,S=w.front,T=w.left,k=w.top,$=new Pn(h.outShape,r.dtype),E=e.data.get(r.dataId).values,N=e.data.get(i.dataId).values,_=$.values,R=Dt(r.shape),D=Dt(i.shape);for(let M=0;M<h.batchSize;++M){const A=M*R[0],B=M*$.strides[0];for(let H=0;H<h.outDepth;++H){const W=B+H*$.strides[1],X=H*h.strideDepth-S;for(let P=0;P<d;++P){const U=X+P*y;if(U<0||U>=h.inDepth)continue;const G=P*D[0],tt=A+U*R[1];for(let Z=0;Z<h.outHeight;++Z){const F=W+Z*$.strides[2],z=Z*h.strideHeight-k;for(let Q=0;Q<p;++Q){const ct=z+Q*b;if(ct<0||ct>=h.inHeight)continue;const pt=G+Q*D[1],gt=tt+ct*R[2];for(let xt=0;xt<h.outWidth;++xt){const kt=F+xt*h.outChannels,Ct=xt*h.strideWidth-T;for(let Ot=0;Ot<m;++Ot){const Gt=Ct+Ot*x;if(Gt<0||Gt>=h.inWidth)continue;const Yt=pt+Ot*D[2],ge=gt+Gt*h.inChannels;let me=Yt;for(let re=0;re<h.inChannels;++re){const Zt=E[ge+re];for(let Ce=0;Ce<h.outChannels;++Ce)_[kt+Ce]+=Zt*N[me+Ce];me+=h.outChannels}}}}}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const xnt={kernelName:Sg,backendName:"cpu",kernelFunc:bnt};function vnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,filterShape:c}=s;Nt([r,i],"conv3dBackpropFilterV2");const h=Dt(r.shape),d=Dt(i.shape),p=Zo(r.shape,c,o,1,l),m=p.strideDepth,y=p.strideHeight,b=p.strideWidth,x=p.filterDepth,w=p.filterHeight,S=p.filterWidth,T=new Pn(p.filterShape,"float32"),k=T.values,[$,E,N,_]=T.strides,R=e.data.get(i.dataId).values,[D,M,A,B]=d,H=e.data.get(r.dataId).values,[W,X,P,U]=h,G=p.padInfo.front,tt=p.padInfo.left,Z=p.padInfo.top;for(let F=0;F<x;++F){const z=Math.max(0,Math.ceil((G-F)/m)),Q=Math.min(p.outDepth,(p.inDepth+G-F)/m),ct=F*$;for(let pt=0;pt<w;++pt){const gt=Math.max(0,Math.ceil((Z-pt)/y)),xt=Math.min(p.outHeight,(p.inHeight+Z-pt)/y),kt=pt*E+ct;for(let Ct=0;Ct<S;++Ct){const Ot=Math.max(0,Math.ceil((tt-Ct)/b)),Gt=Math.min(p.outWidth,(p.inWidth+tt-Ct)/b),Yt=Ct*N+kt;for(let ge=0;ge<p.inChannels;++ge){const me=ge*_+Yt;for(let re=0;re<p.outChannels;++re){let Zt=0;for(let Ce=0;Ce<p.batchSize;++Ce){const ae=Ce*W,fs=Ce*D;for(let We=z;We<Q;++We){const On=(F+We*m-G)*X+ae,Ar=We*M+fs;for(let De=gt;De<xt;++De){const Vs=(pt+De*y-Z)*P+On,Pt=De*A+Ar;for(let se=Ot;se<Gt;++se){const _r=(Ct+se*b-tt)*U+Vs,Rr=se*B+Pt;Zt+=H[_r+ge]*R[Rr+re]}}}}k[me+re]=Zt}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const wnt={kernelName:p1,backendName:"cpu",kernelFunc:vnt};function Snt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:l,inputShape:c}=s;Nt([r],"conv3dBackpropInputV2");const h=Dt(r.shape),d=Dt(i.shape),p=Zo(c,i.shape,l,1,o),m=new Pn(p.inShape,"float32"),y=m.values,[b,x,w,S]=m.strides,T=e.data.get(r.dataId).values,[k,$,E,N]=h,_=e.data.get(i.dataId).values,[R,D,M,A]=d,{batchSize:B,filterDepth:H,filterHeight:W,filterWidth:X,inChannels:P,inDepth:U,inHeight:G,inWidth:tt,outChannels:Z,outDepth:F,outHeight:z,outWidth:Q,strideDepth:ct,strideHeight:pt,strideWidth:gt}=p,xt=H-1-p.padInfo.front,kt=W-1-p.padInfo.top,Ct=X-1-p.padInfo.left;for(let Ot=0;Ot<B;++Ot)for(let Gt=0;Gt<P;++Gt)for(let Yt=0;Yt<U;++Yt){const ge=Yt-xt,me=Math.max(0,Math.ceil(ge/ct)),re=Math.min(F,(H+ge)/ct);for(let Zt=0;Zt<G;++Zt){const Ce=Zt-kt,ae=Math.max(0,Math.ceil(Ce/pt)),fs=Math.min(z,(W+Ce)/pt);for(let We=0;We<tt;++We){const ks=We-Ct,On=Math.max(0,Math.ceil(ks/gt)),Ar=Math.min(Q,(X+ks)/gt);let De=0;for(let Bs=me;Bs<re;++Bs){const Vs=Bs*ct-ge;for(let Pt=ae;Pt<fs;++Pt){const se=Pt*pt-Ce;for(let ps=On;ps<Ar;++ps){const _r=ps*gt-ks,Rr=k*Ot+$*Bs+E*Pt+N*ps,ir=R*(H-1-Vs)+D*(W-1-se)+M*(X-1-_r)+A*Gt;for(let ns=0;ns<Z;++ns){const Be=T[Rr+ns],Qr=_[ir+ns];De+=Be*Qr}}}}y[b*Ot+x*Yt+w*Zt+S*We+Gt]=De}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const Cnt={kernelName:m1,backendName:"cpu",kernelFunc:Snt};const Tnt=ke(dd,n=>Math.cos(n)),knt={kernelName:dd,backendName:"cpu",kernelFunc:Tnt};const $nt=ke(fd,n=>Math.cosh(n)),Ent={kernelName:fd,backendName:"cpu",kernelFunc:$nt};function Int(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:l,method:c,extrapolationValue:h}=s,[d,p,m,y]=r.shape,b=i.shape[0],[x,w]=l,S=te([b,x,w,y],"float32"),T=e.data.get(i.dataId).values,k=e.data.get(o.dataId).values,$=e.data.get(r.dataId).values,E=Dt(r.shape),N=Dt(S.shape);for(let _=0;_<b;_++){const R=_*4,D=T[R],M=T[R+1],A=T[R+2],B=T[R+3],H=k[_];if(H>=d)continue;const W=x>1?(A-D)*(p-1)/(x-1):0,X=w>1?(B-M)*(m-1)/(w-1):0;for(let P=0;P<x;P++){const U=x>1?D*(p-1)+P*W:.5*(D+A)*(p-1);if(U<0||U>p-1){for(let G=0;G<w;G++)for(let tt=0;tt<y;tt++){const Z=tt+G*N[2]+P*N[1]+_*N[0];S.values[Z]=h}continue}if(c==="bilinear"){const G=Math.floor(U),tt=Math.ceil(U),Z=U-G;for(let F=0;F<w;F++){const z=w>1?M*(m-1)+F*X:.5*(M+B)*(m-1);if(z<0||z>m-1){for(let gt=0;gt<y;gt++){const xt=gt+F*N[2]+P*N[1]+_*N[0];S.values[xt]=h}continue}const Q=Math.floor(z),ct=Math.ceil(z),pt=z-Q;for(let gt=0;gt<y;gt++){let xt=gt+Q*E[2]+G*E[1]+H*E[0];const kt=$[xt];xt=gt+ct*E[2]+G*E[1]+H*E[0];const Ct=$[xt];xt=gt+Q*E[2]+tt*E[1]+H*E[0];const Ot=$[xt];xt=gt+ct*E[2]+tt*E[1]+H*E[0];const Gt=$[xt],Yt=kt+(Ct-kt)*pt,ge=Ot+(Gt-Ot)*pt;xt=gt+F*N[2]+P*N[1]+_*N[0],S.values[xt]=Yt+(ge-Yt)*Z}}}else for(let G=0;G<w;++G){const tt=w>1?M*(m-1)+G*X:.5*(M+B)*(m-1);if(tt<0||tt>m-1){for(let z=0;z<y;z++){const Q=z+G*N[2]+P*N[1]+_*N[0];S.values[Q]=h}continue}const Z=Math.round(tt),F=Math.round(U);for(let z=0;z<y;z++){const Q=z+Z*E[2]+F*E[1]+H*E[0],ct=z+G*N[2]+P*N[1]+_*N[0];S.values[ct]=$[Q]}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const Nnt={kernelName:y1,backendName:"cpu",kernelFunc:Int};function Ant(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;Nt(r,"cumprod");const c=Xe([i],r.shape.length);let h=r;c!=null&&(h=Cs({inputs:{x:r},backend:e,attrs:{perm:c}}));const d=on(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=Ls(h.dtype,"int32"),m=n1(ft(h.shape),p),y=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?1:y[k];else{const $=x(S,T-1);m[k]=o?y[$]*m[$]:y[k]*m[$]}}const w=e.makeTensorInfo(h.shape,p,m);if(c!=null){const S=Jo(c),T=Cs({inputs:{x:w},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(h),T}return w}const _nt={kernelName:g1,backendName:"cpu",kernelFunc:Ant};function Rnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;Nt(r,"cumsum");const c=Xe([i],r.shape.length);let h=r;c!=null&&(h=Cs({inputs:{x:r},backend:e,attrs:{perm:c}}));const d=on(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=Ls(h.dtype,"int32"),m=Zn(ft(h.shape),p),y=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?0:y[k];else{const $=x(S,T-1);m[k]=o?y[$]+m[$]:y[k]+m[$]}}const w=e.makeTensorInfo(h.shape,p,m);if(c!=null){const S=Jo(c),T=Cs({inputs:{x:w},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(h),T}return w}const Dnt={kernelName:Cg,backendName:"cpu",kernelFunc:Rnt};function Ont(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const c=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=vC(c,h,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,d)}else if(r.shape.length===2){const c=e.bufferSync(r),h=e.bufferSync(i),d=cF(c,h,o,l);return e.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const Mnt={kernelName:b1,backendName:"cpu",kernelFunc:Ont};function Fnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s;L(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const l=r.shape[0],c=r.shape[1],h=r.shape[2],d=r.shape[3],p=c*i,m=h*i,y=d/(i*i),b=e.data.get(r.dataId).values,x=new Float32Array(l*p*m*y);let w=0;for(let S=0;S<l;++S)for(let T=0;T<p;++T){const k=Math.floor(T/i),$=T%i;for(let E=0;E<m;++E){const N=Math.floor(E/i),_=E%i,R=($*i+_)*y;for(let D=0;D<y;++D){const A=D+R+d*(N+h*(k+c*S));x[w++]=b[A]}}}return e.makeTensorInfo([l,p,m,y],r.dtype,x)}const Lnt={kernelName:x1,backendName:"cpu",kernelFunc:Fnt};function cL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;Nt([r,i],"depthwiseConv2DNative");const d=Dt(r.shape),p=Dt(i.shape);let m=c;m==null&&(m=[1,1]),L(Qn(o,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);const y=zn(r.shape,i.shape,o,m,l,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:S,padInfo:T}=y,k=T.left,$=T.top,E=y.outChannels/y.inChannels,N=new Pn(y.outShape,r.dtype),_=e.data.get(r.dataId).values,R=e.data.get(i.dataId).values,D=N.values;for(let M=0;M<y.batchSize;++M){const A=M*d[0],B=M*N.strides[0];for(let H=0;H<y.outHeight;++H){const W=B+H*N.strides[1],X=H*y.strideHeight-$;for(let P=0;P<b;++P){const U=X+P*w;if(U<0||U>=y.inHeight)continue;const G=P*p[0],tt=A+U*d[1];for(let Z=0;Z<y.outWidth;++Z){const F=W+Z*N.strides[2],z=Z*y.strideWidth-k;for(let Q=0;Q<x;++Q){const ct=z+Q*S;if(ct<0||ct>=y.inWidth)continue;const pt=G+Q*p[1],gt=tt+ct*y.inChannels;let xt=F,kt=pt;for(let Ct=0;Ct<y.inChannels;++Ct){const Ot=_[gt+Ct];for(let Gt=0;Gt<E;++Gt)D[xt+Gt]+=Ot*R[kt+Gt];xt+=E,kt+=E}}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const Pnt={kernelName:Tg,backendName:"cpu",kernelFunc:cL};function znt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s;Nt([r,i],"depthwiseConv2dNativeBackpropFilter");const p=zn(r.shape,d,o,l,c,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=p,w=new Pn(p.filterShape,"float32"),S=p.padInfo.left,T=p.padInfo.top,k=p.outChannels/p.inChannels,$=e.data.get(r.dataId).values,E=new Pn(r.shape,r.dtype,$),N=e.data.get(i.dataId).values,_=new Pn(i.shape,i.dtype,N);for(let R=0;R<b;++R){const D=Math.max(0,Math.ceil((T-R)/m)),M=Math.min(p.outHeight,(p.inHeight+T-R)/m);for(let A=0;A<x;++A){const B=Math.max(0,Math.ceil((S-A)/y)),H=Math.min(p.outWidth,(p.inWidth+S-A)/y);for(let W=0;W<p.outChannels;++W){const X=Math.trunc(W/k),P=W%k;let U=0;for(let G=0;G<p.batchSize;++G)for(let tt=D;tt<M;++tt){const Z=R+tt*m-T;for(let F=B;F<H;++F){const z=A+F*y-S;U+=E.get(G,Z,z,X)*_.get(G,tt,F,W)}}w.set(U,R,A,X,P)}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const Bnt={kernelName:v1,backendName:"cpu",kernelFunc:znt};function Vnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s;Nt([r,i],"depthwiseConv2DNativeBackpropInput");const p=Dt(r.shape),m=Dt(i.shape),y=zn(d,i.shape,o,l,c,h,!0),b=new Pn(y.inShape,"float32"),x=b.values,[w,S,T]=b.strides,k=e.data.get(r.dataId).values,[$,E,N]=p,_=e.data.get(i.dataId).values,[R,D,M]=m,{batchSize:A,filterHeight:B,filterWidth:H,inChannels:W,inHeight:X,inWidth:P,outChannels:U,outHeight:G,outWidth:tt,strideHeight:Z,strideWidth:F}=y,z=B-1-y.padInfo.top,Q=H-1-y.padInfo.left,ct=U/W;for(let pt=0;pt<A;++pt)for(let gt=0;gt<W;++gt)for(let xt=0;xt<X;++xt){const kt=xt-z,Ct=Math.max(0,Math.ceil(kt/Z)),Ot=Math.min(G,(B+kt)/Z);for(let Gt=0;Gt<P;++Gt){const Yt=Gt-Q,ge=Math.max(0,Math.ceil(Yt/F)),me=Math.min(tt,(H+Yt)/F);let re=0;for(let Zt=Ct;Zt<Ot;++Zt){const Ce=Zt*Z-kt;for(let ae=ge;ae<me;++ae){const fs=ae*F-Yt,We=$*pt+E*Zt+N*ae,ks=R*(B-1-Ce)+D*(H-1-fs)+M*gt;for(let On=0;On<ct;++On){const Ar=gt*ct+On,De=k[We+Ar],Bs=_[ks+On];re+=De*Bs}}}x[w*pt+S*xt+T*Gt+gt]=re}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const Unt={kernelName:w1,backendName:"cpu",kernelFunc:Vnt};function jnt(n){const{inputs:t,backend:e}=n,{x:s}=t,r=ft(s.shape),i=e.data.get(s.dataId).values,o=te([r,r],s.dtype),l=o.values;for(let h=0;h<i.length;h++)l[h*r+h]=i[h];const c=[...s.shape,...s.shape];return e.makeTensorInfo(c,o.dtype,o.values)}const Gnt={kernelName:OR,backendName:"cpu",kernelFunc:jnt};const Wnt={kernelName:kg,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r}=n,{strides:i,pad:o,dilations:l}=e,c=t,h=c.data.get(s.dataId).values,d=s.shape.length,p=c.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:S,outWidth:T,padInfo:k,strideHeight:$,strideWidth:E,filterHeight:N,filterWidth:_,dilationHeight:R,dilationWidth:D,outShape:M}=Qd(s.shape,r.shape,i,o,"NHWC",l),A=ft(M),B=M.length,H=nn(s.dtype,A);for(let X=0;X<y;++X)for(let P=0;P<S;++P){const U=P*$-k.top;for(let G=0;G<T;++G){const tt=G*E-k.left;for(let Z=0;Z<w;++Z){let F=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<N;++Q){const ct=U+Q*R;if(ct>=0&&ct<b)for(let pt=0;pt<_;++pt){const gt=tt+pt*D;if(gt>=0&&gt<x){const xt=di([X,ct,gt,Z],d,Dt(s.shape)),kt=di([Q,pt,Z],m,Dt(r.shape)),Ct=h[xt]+p[kt];Ct>F&&(F=Ct)}}}const z=di([X,P,G,Z],B,Dt(M));H[z]=F}}}return{dataId:c.write(ul(H,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}};const Hnt={kernelName:Ov,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:c}=e,h=t,d=Hr(s.shape,h.data.get(s.dataId).values),p=Hr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Qd(s.shape,r.shape,o,l,"NHWC",c);L(i.rank===D.length,()=>`Error in ${Ov}, dy must have the same rank as output ${D.length}, but got ${i.rank}`);const M=Hr(D,h.data.get(i.dataId).values),A=AR(r.shape,r.dtype);for(let H=0;H<m;++H)for(let W=0;W<w;++W){const X=W*k-T.top;for(let P=0;P<S;++P){const U=P*$-T.left;for(let G=0;G<x;++G){let tt=Number.MIN_SAFE_INTEGER,Z=0,F=0;for(let z=0;z<E;++z){const Q=X+z*_;if(Q>=0&&Q<y)for(let ct=0;ct<N;++ct){const pt=U+ct*R;if(pt>=0&&pt<b){const gt=d[H][Q][pt][G]+p[z][ct][G];gt>tt&&(tt=gt,Z=z,F=ct)}}}A[Z][F][G]+=M[H][W][P][G]}}}return{dataId:h.write(ul(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const qnt={kernelName:Dv,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:i}=n,{strides:o,pad:l,dilations:c}=e,h=t,d=Hr(s.shape,h.data.get(s.dataId).values),p=Hr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Qd(s.shape,r.shape,o,l,"NHWC",c);L(i.rank===D.length,()=>`Error in ${Dv}, dy must have the same rank as output ${D.length}, but got ${i.rank}`);const M=Hr(D,h.data.get(i.dataId).values),A=AR(s.shape,s.dtype);for(let H=0;H<m;++H)for(let W=0;W<w;++W){const X=W*k-T.top;for(let P=0;P<S;++P){const U=P*$-T.left;for(let G=0;G<x;++G){let tt=Number.MIN_SAFE_INTEGER,Z=X<0?0:X,F=U<0?0:U;for(let z=0;z<E;++z){const Q=X+z*_;if(Q>=0&&Q<y)for(let ct=0;ct<N;++ct){const pt=U+ct*R;if(pt>=0&&pt<b){const gt=d[H][Q][pt][G]+p[z][ct][G];gt>tt&&(tt=gt,Z=Q,F=pt)}}}A[H][Z][F][G]+=M[H][W][P][G]}}}return{dataId:h.write(ul(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Knt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r}=t,{canvas:i,options:o}=s,{contextOptions:l,imageOptions:c}=o||{},h=c?.alpha||1,d=l?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const p=i.getContext(d,l?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],x=e.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,S=new Uint8ClampedArray(y*m*4);for(let k=0;k<m*y;++k){const $=[0,0,0,255*h];for(let N=0;N<b;N++){const _=x[k*b+N];if(r.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(r.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);b===1?($[0]=_*w,$[1]=_*w,$[2]=_*w):$[N]=_*w}const E=k*4;S[E+0]=Math.round($[0]),S[E+1]=Math.round($[1]),S[E+2]=Math.round($[2]),S[E+3]=Math.round($[3])}i.width=y,i.height=m;const T=new ImageData(S,y,m);return p.putImageData(T,0,0),r}const Xnt={kernelName:e6,backendName:"cpu",kernelFunc:Knt};function gf(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"sum");let l;r.dtype==="bool"?l=Ho({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):l=Si({inputs:{x:r},backend:e});const c=l.shape.length,h=ee(i,l.shape),d=Xe(h,c);let p=h,m=l;d!=null&&(m=Cs({inputs:{x:l},backend:e,attrs:{perm:d}}),p=on(p.length,c)),Bn("sum",p,m.shape.length);const[y,b]=Dn(m.shape,p),x=Ls(m.dtype,"int32");let w=Km(e,y,x);const S=ft(b),T=e.data.get(w.dataId).values,k=e.data.get(m.dataId).values;for(let $=0;$<T.length;++$){const E=$*S;let N=0;for(let _=0;_<S;++_)N+=k[E+_];T[$]=N}if(o){const $=dn(w.shape,h),E=w;w=Le({inputs:{x:w},backend:e,attrs:{shape:$}}),e.disposeIntermediateTensorInfo(E)}return e.disposeIntermediateTensorInfo(l),d!=null&&e.disposeIntermediateTensorInfo(m),w}const Ynt={kernelName:r0,backendName:"cpu",kernelFunc:gf};function Znt(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:l,idDims:c}=GS(r,i.length);HS(o.length,c,i);const{path:h,steps:d}=qS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=WS(y,c[w]);let k;KS(S)?k=i[w]:(k=Cs({inputs:{x:i[w]},backend:e,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);we(k.shape,$)||(k=Le({inputs:{x:k},backend:e,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=D0({inputs:{a:k,b:m},backend:e}),b.push(m))}x<p-1&&(h[x]>=0&&(m=gf({inputs:{x:m},backend:e,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&e.disposeIntermediateTensorInfo(x);return m}const Jnt={kernelName:S1,backendName:"cpu",kernelFunc:Znt};function Qnt(n){const{inputs:t,backend:e}=n,{dy:s,y:r}=t;Nt([s,r],"eluGrad");const i=new Float32Array(ft(r.shape)),o=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values;for(let c=0;c<o.length;++c){const h=o[c];h>=0?i[c]=l[c]:i[c]=l[c]*(h+1)}return e.makeTensorInfo(r.shape,"float32",i)}const tst={kernelName:C1,backendName:"cpu",kernelFunc:Qnt};const est=LS,nst=PS,sst=zS,rst=BS,ist=VS,ost=US,ast=ke(gd,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+est*e);return t*(1-((((ost*s+ist)*s+rst)*s+sst)*s+nst)*s*Math.exp(-e*e))}),lst={kernelName:gd,backendName:"cpu",kernelFunc:ast};function Zm(n){const{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:i}=s,o=r.shape.length,l=r.shape.slice();let c=i;return i<0&&(L(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+i+1),l.splice(c,0,1),Le({inputs:{x:r},backend:e,attrs:{shape:l}})}const cst={kernelName:Eg,backendName:"cpu",kernelFunc:Zm};const ust=ln((n,t)=>n/t),$C=kn(pd,ust),iw={kernelName:pd,backendName:"cpu",kernelFunc:$C};function uL(n,t,e){const s=n.shape,r=s[0],i=s[1],o=e.data.get(n.dataId),l=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,h=[r,i],d=ft(h),p=Yn("float32",d),m=Yn("float32",d);for(let w=0;w<r;w++){const S=ll({inputs:{x:l},backend:e,attrs:{begin:[w,0],size:[1,i]}}),T=ll({inputs:{x:c},backend:e,attrs:{begin:[w,0],size:[1,i]}}),k=Os({inputs:{real:S,imag:T},backend:e}),{real:$,imag:E}=hst(k,t,e),N=Yi($,E);for(let _=0;_<i;_++){const R=jS(N,_);p[w*i+_]=R.real,m[w*i+_]=R.imag}e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(k)}const y=e.makeTensorInfo(h,"float32",p),b=e.makeTensorInfo(h,"float32",m),x=Os({inputs:{real:y,imag:b},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),x}function hst(n,t,e){const s=ft(n.shape),r=e.data.get(n.dataId),i=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(dst(s)){const l=ow(i,o,s,t,e),c=[n.shape[0],n.shape[1]];if(t){const h=e.makeTensorInfo(c,"float32",l.real),d=e.makeTensorInfo(c,"float32",l.imag),p=e.makeTensorInfo([],"float32",Xo(s,"float32")),m=Si({inputs:{x:p},backend:e}),y=iw.kernelFunc({inputs:{a:h,b:p},backend:e}),b=iw.kernelFunc({inputs:{a:d,b:m},backend:e}),x=e.data.get(y.dataId).values,w=e.data.get(b.dataId).values;return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return l}else{const l=Yi(i,o),c=fst(l,s,t);return CO(c)}}function dst(n){return(n&n-1)===0}function ow(n,t,e,s,r){if(e===1)return{real:n,imag:t};const i=Yi(n,t),o=e/2,l=TO(i),c=l.real,h=l.imag,d=[c.length],p=r.makeTensorInfo(d,"float32",c),m=r.makeTensorInfo(d,"float32",h),y=Os({inputs:{real:p,imag:m},backend:r}),b=kO(i),x=b.real,w=b.imag,S=[x.length],T=r.makeTensorInfo(S,"float32",x),k=r.makeTensorInfo(S,"float32",w),$=Os({inputs:{real:T,imag:k},backend:r}),E=ow(c,h,o,s,r),N=E.real,_=E.imag,R=[N.length],D=r.makeTensorInfo(R,"float32",N),M=r.makeTensorInfo(R,"float32",_),A=Os({inputs:{real:D,imag:M},backend:r}),B=ow(x,w,o,s,r),H=B.real,W=B.imag,X=[H.length],P=r.makeTensorInfo(X,"float32",H),U=r.makeTensorInfo(X,"float32",W),G=Os({inputs:{real:P,imag:U},backend:r}),tt=EO(e,s),Z=[tt.real.length],F=r.makeTensorInfo(Z,"float32",tt.real),z=r.makeTensorInfo(Z,"float32",tt.imag),Q=Os({inputs:{real:F,imag:z},backend:r}),ct=D0({inputs:{a:Q,b:G},backend:r}),pt=Bc({inputs:{a:A,b:ct},backend:r}),gt=TC({inputs:{a:A,b:ct},backend:r}),xt=al({inputs:{input:pt},backend:r}),kt=al({inputs:{input:gt},backend:r}),Ct=Vc({inputs:{input:pt},backend:r}),Ot=Vc({inputs:{input:gt},backend:r}),Gt=Uc({inputs:[xt,kt],backend:r,attrs:{axis:0}}),Yt=Uc({inputs:[Ct,Ot],backend:r,attrs:{axis:0}}),ge=r.data.get(Gt.dataId).values,me=r.data.get(Yt.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(M),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(ct),r.disposeIntermediateTensorInfo(pt),r.disposeIntermediateTensorInfo(gt),r.disposeIntermediateTensorInfo(xt),r.disposeIntermediateTensorInfo(Ct),r.disposeIntermediateTensorInfo(kt),r.disposeIntermediateTensorInfo(Ot),r.disposeIntermediateTensorInfo(Gt),r.disposeIntermediateTensorInfo(Yt),{real:ge,imag:me}}function fst(n,t,e){const s=new Float32Array(t*2);for(let r=0;r<t;r++){let i=0,o=0;for(let l=0;l<t;l++){const c=IO(r*l,t,e),h=jS(n,l);i+=h.real*c.real-h.imag*c.imag,o+=h.real*c.imag+h.imag*c.real}e&&(i/=t,o/=t),$O(s,i,o,r)}return s}function pst(n){const{inputs:t,backend:e}=n,{input:s}=t,r=ft(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=Le({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),c=uL(l,!1,e),h=Le({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const mst={kernelName:T1,backendName:"cpu",kernelFunc:pst};function EC(n){const{backend:t,attrs:e}=n,{shape:s,value:r,dtype:i}=e,o=i||Kc(r),l=nn(o,ft(s));return yst(l,r,o),t.makeTensorInfo(s,o,l)}const gst={kernelName:k1,backendName:"cpu",kernelFunc:EC};function yst(n,t,e){n.fill(t)}const bst={kernelName:$1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,r=e,i=Yn(s.dtype,ft(s.shape)),[o,l,c,h]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<o;m++){const y=m*c*l*h;for(let b=0;b<l;b++){const x=b*(c*h);for(let w=0;w<c;w++){const S=w*h;for(let T=0;T<h;T++){const k=Math.round(c-w-1),$=y+x+S+T;let E=d[$];if(k>=0&&k<c){const N=k*h,_=y+x+N+T;E=d[_]}i[$]=E}}}}return{dataId:r.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function xst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=lL({inputs:{x:r,filter:i},backend:e,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;if(d==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const S=Le({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});x=Bc({inputs:{a:x,b:S},backend:e}),e.disposeIntermediateTensorInfo(S)}else x=Bc({inputs:{a:x,b:o},backend:e});e.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const S=Le({inputs:{x:l},backend:e,attrs:{shape:[l.shape[0],1,1]}});x=Ym(e,x,y,S,b),e.disposeIntermediateTensorInfo(S)}else x=Ym(e,x,y,l,b);e.disposeIntermediateTensorInfo(w)}return x}const vst={kernelName:Nm,backendName:"cpu",kernelFunc:xst};function wst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=cL({inputs:{x:r,filter:i},backend:e,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;x=Bc({inputs:{a:x,b:o},backend:e}),e.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=Ym(e,x,y,l,b),e.disposeIntermediateTensorInfo(w)}return x}const Sst={kernelName:QR,backendName:"cpu",kernelFunc:wst};function Cst(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=ft(s.shape),o=r.shape,l=o[o.length-1],[c,h,d,p]=$S(s,r);if(h===0)return e.makeTensorInfo(c,s.dtype,[]);const m=e.data.get(r.dataId).values,y=e.bufferSync(s),b=vF(m,y,s.dtype,h,l,d,p,s.shape,i);return e.makeTensorInfo(c,s.dtype,b.values)}const Tst={kernelName:MR,backendName:"cpu",kernelFunc:Cst};function kst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:l}=s;Nt([r,i],"gatherV2");const c=ee(o,r.shape)[0],h=e.data.get(i.dataId).values,d=r.shape[c];for(let $=0;$<h.length;++$){const E=h[$];L(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=l;l==null&&(p=0);const m=ft(i.shape),y=YS(r,i,c,p),b=Le({inputs:{x:r},backend:e,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=Le({inputs:{x:i},backend:e,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],S=e.bufferSync(x),T=e.bufferSync(b),k=wF(T,S,w);return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.makeTensorInfo(y.outputShape,k.dtype,k.values)}const $st={kernelName:Ng,backendName:"cpu",kernelFunc:kst};function Est(n){const{inputs:t,backend:e}=n,{input:s}=t,r=ft(s.shape),i=s.shape[s.shape.length-1],o=r/i,l=Le({inputs:{x:s},backend:e,attrs:{shape:[o,i]}}),c=uL(l,!0,e),h=Le({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const Ist={kernelName:E1,backendName:"cpu",kernelFunc:Est};const Nst=ke(Cd,n=>Number.isFinite(n)?1:0,"bool"),Ast={kernelName:Cd,backendName:"cpu",kernelFunc:Nst};const _st=ke(Td,n=>Math.abs(n)===1/0?1:0,"bool"),Rst={kernelName:Td,backendName:"cpu",kernelFunc:_st};const Dst=ke(kd,n=>Number.isNaN(n)?1:0,"bool"),Ost={kernelName:kd,backendName:"cpu",kernelFunc:Dst};function Mst(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=$F(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const Fst={kernelName:FR,backendName:"cpu",kernelFunc:Mst};const Lst=ke(Ed,n=>Math.log1p(n)),Pst={kernelName:Ed,backendName:"cpu",kernelFunc:Lst};const zst=ln((n,t)=>n&&t),Bst=kn(Og,zst,null,"bool"),Vst={kernelName:Og,backendName:"cpu",kernelFunc:Bst};const Ust=ke(Mg,n=>n?0:1,"bool"),jst={kernelName:Mg,backendName:"cpu",kernelFunc:Ust};const Gst=ln((n,t)=>n||t),Wst=kn(Fg,Gst,null,"bool"),Hst={kernelName:Fg,backendName:"cpu",kernelFunc:Wst};function qst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:l,beta:c}=s;Nt(r,"LRN");const h=r.shape[3],d=h-1,p=e.data.get(r.dataId).values,m=ft(r.shape),y=new Float32Array(m);function b(x){const w=x%h;let S=x-w+Math.max(0,w-i);const T=x-w+Math.min(w+i,d);let k=0;for(;S<=T;S++){const $=p[S];k+=$*$}return k}for(let x=0;x<m;x++){const w=b(x),S=p[x]*Math.pow(o+l*w,-c);y[x]=S}return e.makeTensorInfo(r.shape,r.dtype,y)}const Kst={kernelName:Lg,backendName:"cpu",kernelFunc:qst};function Xst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:l,bias:c,alpha:h,beta:d}=s;Nt(o,"LRNGrad");const p=ft(o.shape),m=o.shape[3],y=e.data.get(o.dataId).values,b=e.data.get(r.dataId).values,x=e.data.get(i.dataId).values,w=new Float32Array(p),S=p;for(let T=0;T<S;T++){const k=T%m,$=T-k+Math.max(0,k-l),E=T-k+Math.min(m,k+l+1);let N=0;for(let _=$;_<E;_++)N+=Math.pow(b[_],2);N=h*N+c;for(let _=$;_<E;_++){let R=-2*h*d*b[_]*x[T]/N;T===_&&(R+=Math.pow(N,-d)),R*=y[T],w[_]+=R}}return e.makeTensorInfo(o.shape,r.dtype,w)}const Yst={kernelName:N1,backendName:"cpu",kernelFunc:Xst};function hL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,l=e;let c=r.shape;const h=c.length,d=ee(i,c);let p=d;const m=Xe(p,h);let y=l.data.get(r.dataId).values;if(m!=null){const $=new Array(h);for(let E=0;E<$.length;E++)$[E]=c[m[E]];y=SC(y,c,r.dtype,m,$),p=on(p.length,h),c=$}Nt(r,"max"),Bn("max",p,h);const[b,x]=Dn(c,p),w=ft(x),S=IF(y,w,b,r.dtype),T=l.write(S,b,r.dtype);let k=b;return o&&(k=dn(b,d)),{dataId:T,shape:k,dtype:r.dtype}}const Zst={kernelName:Pg,backendName:"cpu",kernelFunc:hL};function Jst(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Nt(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Qn(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Er(r.shape,i,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))p=Si({inputs:{x:r},backend:e});else{const m=e.data.get(r.dataId).values,y=Dt(r.shape),b=kC(m,r.shape,r.dtype,y,d,"max");p=e.makeTensorInfo(d.outShape,r.dtype,b.values)}return p}const Qst={kernelName:zg,backendName:"cpu",kernelFunc:Jst};function trt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Nt(r,"maxPool3d");const d=to(r.shape,i,o,1,l,c,h),p=e.data.get(r.dataId).values,m=aL(p,r.shape,r.dtype,Dt(r.shape),d,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}const ert={kernelName:Bg,backendName:"cpu",kernelFunc:trt};function nrt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Nt([r,i],"maxPool3DGrad");const d=to(i.shape,o,l,1,c,h),p=e.bufferSync(i),m=Get(p,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,S=d.dilationHeight,T=d.dilationWidth,k=d.effectiveFilterDepth,$=d.effectiveFilterHeight,E=d.effectiveFilterWidth,N=k-1-d.padInfo.front,_=E-1-d.padInfo.left,R=$-1-d.padInfo.top,D=te(i.shape,"float32"),M=e.bufferSync(r);for(let A=0;A<d.batchSize;++A)for(let B=0;B<d.inChannels;++B)for(let H=0;H<d.inDepth;++H)for(let W=0;W<d.inHeight;++W)for(let X=0;X<d.inWidth;++X){const P=H-N,U=W-R,G=X-_;let tt=0;for(let Z=0;Z<k;Z+=w){const F=(P+Z)/y;if(!(F<0||F>=d.outDepth||Math.floor(F)!==F))for(let z=0;z<$;z+=S){const Q=(U+z)/b;if(!(Q<0||Q>=d.outHeight||Math.floor(Q)!==Q))for(let ct=0;ct<E;ct+=T){const pt=(G+ct)/x;if(pt<0||pt>=d.outWidth||Math.floor(pt)!==pt)continue;const gt=k*$*E-1-m.get(A,F,Q,pt,B),xt=Z*$*E+z*E+ct,kt=gt===xt?1:0;if(kt===0)continue;const Ct=M.get(A,F,Q,pt,B);tt+=Ct*kt}}}D.set(tt,A,H,W,X,B)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}const srt={kernelName:_1,backendName:"cpu",kernelFunc:nrt};function rrt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,l=i;Nt([i,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=Er(l.shape,c,h,1,d,p),y=e.data.get(l.dataId).values,b=te(m.outShape,l.dtype,oL(y,l.shape,l.dtype,m).values),x=m.strideHeight,w=m.strideWidth,S=m.dilationHeight,T=m.dilationWidth,k=m.effectiveFilterHeight,$=m.effectiveFilterWidth,E=$-1-m.padInfo.left,N=k-1-m.padInfo.top,_=te(l.shape,"float32"),R=e.data.get(r.dataId).values,D=te(r.shape,"float32",R);for(let M=0;M<m.batchSize;++M)for(let A=0;A<m.inChannels;++A)for(let B=0;B<m.inHeight;++B)for(let H=0;H<m.inWidth;++H){const W=B-N,X=H-E;let P=0;for(let U=0;U<k;U+=S){const G=(W+U)/x;if(!(G<0||G>=m.outHeight||Math.floor(G)!==G))for(let tt=0;tt<$;tt+=T){const Z=(X+tt)/w;if(Z<0||Z>=m.outWidth||Math.floor(Z)!==Z)continue;const F=k*$-1-b.get(M,G,Z,A),z=U*$+tt,Q=F===z?1:0;if(Q===0)continue;const ct=D.get(M,G,Z,A);P+=ct*Q}}_.set(P,M,B,H,A)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const irt={kernelName:A1,backendName:"cpu",kernelFunc:rrt};function ort(n,t,e,s,r){const i=Dt(t),o=kC(n,t,e,i,r,"max"),l=oL(n,t,e,r,!0,s);return[o.values,l.values]}const art={kernelName:LR,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=t,c=e;Nt(s,"MaxPoolWithArgmax");const h=c.data.get(s.dataId).values,d=Er(s.shape,r,i,[1,1],o),[p,m]=ort(h,s.shape,s.dtype,l,d),y=c.write(p,d.outShape,s.dtype),b=c.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function lrt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=ee(i,r.shape),h=Dn(r.shape,l)[1],d=ft(h),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const y=Ho({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});p.push(y);const b=$C({inputs:{a:y,b:m},backend:e});p.push(b);const x=gf({inputs:{x:b},backend:e,attrs:{axis:i,keepDims:o}});return p.forEach(w=>e.disposeIntermediateTensorInfo(w)),x}const crt={kernelName:Vg,backendName:"cpu",kernelFunc:lrt};function urt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;Nt(r,"min");const l=ee(i,r.shape);let c=l;const h=Xe(c,r.shape.length);let d=r;h!=null&&(d=Cs({inputs:{x:r},backend:e,attrs:{perm:h}}),c=on(c.length,r.shape.length)),Bn("min",c,d.shape.length);const[p,m]=Dn(d.shape,c),y=ft(m),b=Zn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];(Number.isNaN(E)||E<k)&&(k=E)}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=dn(p,l),T=Le({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const hrt={kernelName:Ug,backendName:"cpu",kernelFunc:urt};function drt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,mode:o}=s;Nt(r,"mirrorPad");const l=i.map((k,$)=>k[0]+r.shape[$]+k[1]),c=i.map(k=>k[0]),h=i.map((k,$)=>k[0]+r.shape[$]),d=o==="reflect"?0:1,p=e.data.get(r.dataId).values,m=r.shape.length,y=Dt(r.shape),b=ft(l),x=l.length,w=Dt(l),S=Yn(r.dtype,b);for(let k=0;k<b;k++){let $=Xc(k,x,w);for(let N=0;N<x;N++)$[N]<c[N]?$[N]=c[N]*2-$[N]-d:$[N]>=h[N]&&($[N]=(h[N]-1)*2-$[N]+d);$=$.map((N,_)=>N-c[_]);const E=di($,m,y);S[k]=p[E]}return{dataId:e.write(S,l,r.dtype),shape:l,dtype:r.dtype}}const frt={kernelName:jg,backendName:"cpu",kernelFunc:drt};const prt=ln(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),mrt=kn(Ad,prt),grt={kernelName:Ad,backendName:"cpu",kernelFunc:mrt};function dL(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=r.shape.length;let l=i;if(l===-1&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const c=ee([l],r.shape),h=hL({inputs:{x:r},backend:e,attrs:{reductionIndices:c,keepDims:!1}}),d=dn(h.shape,c),p=Le({inputs:{x:h},backend:e,attrs:{shape:d}}),m=TC({inputs:{a:r,b:p},backend:e}),y=gF({inputs:{x:m},backend:e}),b=gf({inputs:{x:y},backend:e,attrs:{axis:c,keepDims:!1}}),x=Le({inputs:{x:b},backend:e,attrs:{shape:d}}),w=$C({inputs:{a:y,b:x},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),w}const yrt={kernelName:a0,backendName:"cpu",kernelFunc:dL};function brt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:l}=s;Nt(r,"multinomial");const c=l?r:dL({inputs:{logits:r},backend:e,attrs:{dim:-1}}),h=c.shape[0],d=c.shape[1],p=e.data.get(c.dataId).values,m=[h,i],y=Zn(ft(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=p[x];for(let k=1;k<w.length;++k)w[k]=w[k-1]+p[x+k];const S=hS.alea(o.toString()),T=b*i;for(let k=0;k<i;++k){const $=S();y[T+k]=w.length;for(let E=0;E<w.length;E++)if($<w[E]){y[T+k]=E;break}}}return l||e.disposeIntermediateTensorInfo(c),e.makeTensorInfo(m,"int32",y)}const xrt={kernelName:PR,backendName:"cpu",kernelFunc:brt};const vrt=vS;function wrt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s;Nt(r,"NonMaxSuppression");const h=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:p}=vrt(h,d,o,l,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Srt={kernelName:R1,backendName:"cpu",kernelFunc:wrt};const Crt=wS;function Trt(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s;Nt(r,"NonMaxSuppressionPadded");const d=e.data.get(r.dataId).values,p=e.data.get(i.dataId).values,{selectedIndices:m,validOutputs:y}=Crt(d,p,o,l,c,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const krt={kernelName:D1,backendName:"cpu",kernelFunc:Trt};const $rt=SS;function Ert(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s;Nt(r,"NonMaxSuppressionWithScore");const d=e.data.get(r.dataId).values,p=e.data.get(i.dataId).values,m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=$rt(d,p,m,y,b,x);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const Irt={kernelName:O1,backendName:"cpu",kernelFunc:Ert};function Nrt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:l,offValue:c}=s;Nt(r,"oneHot");const h=ft(r.shape),d=new Float32Array(h*o);d.fill(c);const p=e.data.get(r.dataId).values;for(let m=0;m<h;++m)p[m]>=0&&p[m]<o&&(d[m*o+p[m]]=l);return e.makeTensorInfo([...r.shape,o],i,d)}const Art={kernelName:qg,backendName:"cpu",kernelFunc:Nrt};function Jm(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=al({inputs:{input:s},backend:e}),i=Jm({inputs:{x:r},backend:e}),o=Vc({inputs:{input:s},backend:e}),l=Jm({inputs:{x:o},backend:e}),c=Os({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return EC({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const _rt={kernelName:u0,backendName:"cpu",kernelFunc:Jm};function fL(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=al({inputs:{input:s},backend:e}),i=fL({inputs:{x:r},backend:e}),o=Vc({inputs:{input:s},backend:e}),l=Jm({inputs:{x:o},backend:e}),c=Os({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return EC({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const Rrt={kernelName:Hg,backendName:"cpu",kernelFunc:fL};function pL(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return Zm({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(d=>{t1(i,d.shape,"All tensors passed to stack must have matching shapes"),L(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=t.map(d=>{const p=Zm({inputs:{input:d},backend:e,attrs:{dim:r}});return l.push(p),p}),h=Uc({inputs:c,backend:e,attrs:{axis:r}});return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const Drt={kernelName:Kg,backendName:"cpu",kernelFunc:pL};function Ort(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;Nt(r,"pad");const l=i.map((T,k)=>T[0]+r.shape[k]+T[1]),c=i.map(T=>T[0]),h=e.data.get(r.dataId).values,d=ft(r.shape),p=r.shape.length,m=Dt(r.shape),y=ft(l),b=l.length,x=Dt(l),w=Yn(r.dtype,y);o!==0&&w.fill(o);for(let T=0;T<d;T++){const $=Xc(T,p,m).map((N,_)=>N+c[_]),E=di($,b,x);w[E]=h[T]}return{dataId:e.write(w,l,r.dtype),shape:l,dtype:r.dtype}}const mL={kernelName:Xg,backendName:"cpu",kernelFunc:Ort};const Mrt=ln((n,t)=>Math.pow(n,t)),Frt=kn(Rd,Mrt),Lrt={kernelName:Rd,backendName:"cpu",kernelFunc:Frt};function Prt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:l}=s,c=r.map(S=>e.data.get(S.dataId).values),h=r.map(S=>S.shape),d=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values,[m,y,b]=OF(c,h,d,i.shape,i.dtype,p,o.shape),x=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),w=e.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const zrt={kernelName:zR,backendName:"cpu",kernelFunc:Prt};function Brt(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,[h,d]=MF(o,s.shape,s.dtype,l,r.shape,c,i.shape),p=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Vrt={kernelName:BR,backendName:"cpu",kernelFunc:Brt};function Urt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=t,{rowPartitionTypes:c}=s,h=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,p=e.data.get(o.dataId).values,m=l.map(w=>e.data.get(w.dataId).values),y=l.map(w=>w.shape),[b,x]=FF(h,r.shape,d,i.shape,i.dtype,p,o.shape,m,y,c);return e.makeTensorInfo(b,i.dtype,x)}const jrt={kernelName:VR,backendName:"cpu",kernelFunc:Urt};function Grt(n){const{backend:t,attrs:e}=n,{start:s,stop:r,dtype:i,step:o}=e,l=LF(s,r,o,i);return t.makeTensorInfo([l.length],i,l)}const Wrt={kernelName:M1,backendName:"cpu",kernelFunc:Grt};const Hrt=ke(Dd,n=>1/n),qrt={kernelName:Dd,backendName:"cpu",kernelFunc:Hrt};function Krt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s;Nt(r,"resizeBilinear");const c=Dt(r.shape),[h,d]=l,[p,m,y,b]=r.shape,x=e.data.get(r.dataId).values,w=new Float32Array(ft([p,h,d,b])),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],T=[i&&h>1?h-1:h,i&&d>1?d-1:d];let k=0;const $=S[0]/T[0],E=S[1]/T[1];for(let N=0;N<p;N++)for(let _=0;_<h;_++){let R;o?R=$*(_+.5)-.5:R=$*_;const D=Math.max(0,Math.floor(R)),M=R-D,A=Math.min(m-1,Math.ceil(R)),B=N*c[0]+D*c[1],H=N*c[0]+A*c[1];for(let W=0;W<d;W++){let X;o?X=E*(W+.5)-.5:X=E*W;const P=Math.max(0,Math.floor(X)),U=X-P,G=Math.min(y-1,Math.ceil(X)),tt=B+P*c[2],Z=H+P*c[2],F=B+G*c[2],z=H+G*c[2];for(let Q=0;Q<b;Q++){const ct=x[tt+Q],pt=x[Z+Q],gt=x[F+Q],xt=x[z+Q],kt=ct+(gt-ct)*U,Ct=pt+(xt-pt)*U,Ot=kt+(Ct-kt)*M;w[k++]=Ot}}}return e.makeTensorInfo([p,h,d,b],"float32",w)}const Xrt={kernelName:t0,backendName:"cpu",kernelFunc:Krt};function Yrt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;Nt([i,r],"resizeBilinearGrad");const l=Dt(r.shape),[c,h,d,p]=r.shape,[,m,y]=i.shape,b=new Float32Array(c*h*d*p),x=[o&&m>1?h-1:h,o&&y>1?d-1:d],w=[o&&m>1?m-1:m,o&&y>1?y-1:y],S=x[0]/w[0],T=x[1]/w[1],k=e.data.get(i.dataId).values;let $=0;for(let E=0;E<c;E++){const N=E*l[0];for(let _=0;_<m;_++){const R=_*S,D=Math.floor(R),M=Math.min(Math.ceil(R),h-1),A=N+D*l[1],B=N+M*l[1],H=R-D,W=1-H;for(let X=0;X<y;X++){const P=X*T,U=Math.floor(P),G=Math.min(Math.ceil(P),d-1),tt=P-U,Z=1-tt,F=A+U*l[2],z=A+G*l[2],Q=B+U*l[2],ct=B+G*l[2],pt=W*Z,gt=W*tt,xt=H*Z,kt=H*tt;for(let Ct=0;Ct<p;Ct++){const Ot=k[$++];b[F+Ct]+=Ot*pt,b[z+Ct]+=Ot*gt,b[Q+Ct]+=Ot*xt,b[ct+Ct]+=Ot*kt}}}}return e.makeTensorInfo([c,d,h,p],"float32",b)}const Zrt={kernelName:P1,backendName:"cpu",kernelFunc:Yrt};function Jrt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s;Nt(r,"resizeNearestNeighbor");const c=Dt(r.shape),[h,d]=l,[p,m,y,b]=r.shape,x=e.data.get(r.dataId).values,w=new Float32Array(p*h*d*b),S=[i&&h>1?m-1:m,i&&d>1?y-1:y],T=[i&&h>1?h-1:h,i&&d>1?d-1:d],k=S[0]/T[0],$=S[1]/T[1];let E=0;for(let N=0;N<p;N++){const _=N*c[0];for(let R=0;R<h;R++){const D=o?k*(R+.5):k*R;let M=Math.min(m-1,i?Math.round(D):Math.floor(D));o&&(M=Math.max(0,M));const A=_+M*c[1];for(let B=0;B<d;B++){const H=o?$*(B+.5):$*B;let W=Math.min(y-1,i?Math.round(H):Math.floor(H));o&&(W=Math.max(0,W));const X=A+W*c[2];for(let P=0;P<b;P++){const U=x[X+P];w[E++]=U}}}}return e.makeTensorInfo([p,h,d,b],r.dtype,w)}const Qrt={kernelName:Qg,backendName:"cpu",kernelFunc:Jrt};function tit(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s;Nt([i,r],"resizeNearestNeighborGrad");const l=Dt(r.shape),c=Dt(i.shape),[h,d,p,m]=r.shape,[,y,b]=i.shape,x=new Float32Array(h*d*p*m),w=e.data.get(i.dataId).values,S=[o&&y>1?d-1:d,o&&b>1?p-1:p],T=[o&&y>1?y-1:y,o&&b>1?b-1:b],k=S[0]/T[0],$=S[1]/T[1],E=1/k,N=1/$,_=Math.ceil(E)*2+2,R=Math.ceil(N)*2+2;for(let D=0;D<h;D++){const M=D*l[0];for(let A=0;A<d;A++){const B=M+A*l[1],H=Math.floor(A*E),W=Math.floor(H-_/2);for(let X=0;X<p;X++){const P=B+X*l[2],U=Math.floor(X*N),G=Math.floor(U-R/2);for(let tt=0;tt<m;tt++){let Z=0;for(let F=0;F<_;F++){const z=F+W;if(z<0||z>=y)continue;const Q=M+z*c[1],ct=z*k,pt=Math.min(d-1,o?Math.round(ct):Math.floor(ct));if(A===pt)for(let gt=0;gt<R;gt++){const xt=gt+G;if(xt<0||xt>=b)continue;const kt=Q+xt*c[2],Ct=xt*$,Ot=Math.min(p-1,o?Math.round(Ct):Math.floor(Ct));X===Ot&&(Z+=w[kt+tt])}}x[P+tt]=Z}}}}return e.makeTensorInfo(r.shape,r.dtype,x)}const eit={kernelName:L1,backendName:"cpu",kernelFunc:tit};function nit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s;Nt(r,"reverse");const o=r.shape.length,l=ee(i,r.shape);if(o===0)return Si({inputs:{x:r},backend:e});const c=new Pn(r.shape,r.dtype),h=e.bufferSync(r);for(let d=0;d<c.size;d++){const p=c.indexToLoc(d),m=p.slice();l.forEach(y=>m[y]=r.shape[y]-1-m[y]),c.set(h.get(...m),...p)}return e.makeTensorInfo(c.shape,c.dtype,c.values)}const sit={kernelName:e0,backendName:"cpu",kernelFunc:nit};const rit={kernelName:W1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,l=e,c=Yn(s.dtype,ft(s.shape)),[h,d,p,m]=s.shape,[y,b]=OS(o,d,p),x=255,w=Math.sin(r),S=Math.cos(r),T=l.data.get(s.dataId).values;for(let $=0;$<h;$++){const E=$*p*d*m;for(let N=0;N<d;N++){const _=N*(p*m);for(let R=0;R<p;R++){const D=R*m;for(let M=0;M<m;M++){const A=[h,N,R,M],B=A[2],H=A[1];let W=(B-y)*S-(H-b)*w,X=(B-y)*w+(H-b)*S;W=Math.round(W+y),X=Math.round(X+b);let P=i;if(typeof i!="number"&&(M===3?P=x:P=i[M]),W>=0&&W<p&&X>=0&&X<d){const G=X*(p*m),tt=W*m,Z=E+G+tt+M;P=T[Z]}const U=E+_+D+M;c[U]=P}}}}return{dataId:l.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const iit=ke(Fd,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),oit={kernelName:Fd,backendName:"cpu",kernelFunc:iit};function ait(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=fl(i,r,o),m=!0,y=e.bufferSync(r),b=e.bufferSync(i),x=Ua(y,b,o,p,h,c,l,d,0,m);return e.makeTensorInfo(o,x.dtype,x.values)}const lit={kernelName:UR,backendName:"cpu",kernelFunc:ait};function cit(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<t?e=r+1:s=r;return s}function uit(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<=t?e=r+1:s=r;return s}function hit(n,t,e,s,r,i){const o=nn("int32",e*r);for(let l=0;l<e;++l){const c=n.slice(l*s,(l+1)*s),h=l*r;for(let d=0;d<r;++d)o[h+d]=i==="left"?cit(c,t[d+h]):uit(c,t[d+h])}return o}function dit(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,h=hit(l,c,r.shape[0],r.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",h)}const fit={kernelName:GR,backendName:"cpu",kernelFunc:dit};function pit(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t;Nt([s,r,i],"select");const o=s.shape.length,l=e.data.get(s.dataId).values,c=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=Ls(r.dtype,i.dtype),p=Zn(ft(r.shape),d);let m=0;const y=o===0||o>1||r.shape.length===1?1:ft(r.shape.slice(1));for(let b=0;b<l.length;b++)for(let x=0;x<y;x++)l[b]===1?p[m++]=c[b]:p[m++]=h[b];return e.makeTensorInfo(r.shape,d,p)}const mit={kernelName:n0,backendName:"cpu",kernelFunc:pit};const git=v0,yit=w0,bit=ke(Pd,n=>n>=0?yit*n:git*(Math.exp(n)-1)),xit={kernelName:Pd,backendName:"cpu",kernelFunc:bit};const vit=ke(Vd,n=>n<0?-1:n>0?1:0),wit={kernelName:Vd,backendName:"cpu",kernelFunc:vit};const Sit=ke(zd,n=>Math.sin(n)),Cit={kernelName:zd,backendName:"cpu",kernelFunc:Sit};const Tit=ke(Bd,n=>Math.sinh(n)),kit={kernelName:Bd,backendName:"cpu",kernelFunc:Tit};const $it=11920928955078125e-23,qN=Math.log($it)+2,Eit=ke(jd,n=>{const t=n>-qN,e=n<qN,s=Math.exp(n);let r;return e?r=s:t?r=n:r=Math.log(1+s),r}),Iit={kernelName:jd,backendName:"cpu",kernelFunc:Eit};function Nit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;Nt([r],"spaceToBatchND");const l=ft(i),c=[[0,0]];c.push(...o);for(let N=1+i.length;N<r.shape.length;++N)c.push([0,0]);const h=mL.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:c,constantValue:0}}),d=rf(h.shape,i,l,!1),p=of(d.length,i.length,!1),m=af(h.shape,i,l,!1),x=Le({inputs:{x:h},backend:e,attrs:{shape:d}}),T=Cs({inputs:{x},backend:e,attrs:{perm:p}}),E=Le({inputs:{x:T},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),E}const Ait={kernelName:i0,backendName:"cpu",kernelFunc:Nit};function _it(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=e.data.get(s.dataId).values,c=e.data.get(r.dataId).values,h=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values[0],[p,m,y,b,x]=VF(l,s.shape,s.dtype,c,r.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,p),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),e.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const Rit={kernelName:WR,backendName:"cpu",kernelFunc:_it};function Dit(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(r.dataId).values),l=e.data.get(s.dataId).values,c=Array.from(e.data.get(i.dataId).values),[h,d,p]=UF(l,s.shape,s.dtype,o,c);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const Oit={kernelName:HR,backendName:"cpu",kernelFunc:Dit};function Mit(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,[h,d]=CC(o,s.shape,s.dtype,l,c,!0);return e.makeTensorInfo(d,s.dtype,h)}const Fit={kernelName:qR,backendName:"cpu",kernelFunc:Mit};function Lit(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,c=e.data.get(i.dataId).values,[h,d]=CC(o,s.shape,s.dtype,l,c);return e.makeTensorInfo(d,s.dtype,h)}const Pit={kernelName:KR,backendName:"cpu",kernelFunc:Lit};function zit(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=fl(i,r,l),y=!1,b=e.bufferSync(r);let x;switch(i.dtype){case"bool":{const w=e.bufferSync(i),S=!!e.data.get(o.dataId).values[0];x=Ua(b,w,l,m,d,h,c,p,S,y);break}case"float32":{const w=e.bufferSync(i),S=e.data.get(o.dataId).values[0];x=Ua(b,w,l,m,d,h,c,p,S,y);break}case"int32":{const w=e.bufferSync(i),S=e.data.get(o.dataId).values[0];x=Ua(b,w,l,m,d,h,c,p,S,y);break}case"string":{const w=e.bufferSync(i),S=Vo(e.data.get(o.dataId).values[0]);x=Ua(b,w,l,m,d,h,c,p,S,y);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(l,x.dtype,x.values)}const Bit={kernelName:XR,backendName:"cpu",kernelFunc:zit};function Vit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,l=ee(o,r.shape)[0],c=XS(r,i,l),h=new Array(r.shape.length).fill(0),d=r.shape.slice();return c.map(p=>{const m=[...d];m[l]=p;const y=ll({inputs:{x:r},backend:e,attrs:{begin:h,size:m}});return h[l]+=p,y})}const Uit={kernelName:o0,backendName:"cpu",kernelFunc:Vit};const jit={kernelName:z1,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;Nt(e,"square");const r=s.data.get(e.dataId).values,i=new Float32Array(r.length);for(let l=0;l<r.length;++l){const c=r[l];i[l]=c*c}return{dataId:s.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const Git=ke(Yd,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Wit={kernelName:Yd,backendName:"cpu",kernelFunc:Git};function Hit(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;Nt(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=_S(r.shape,i,o,l,c,h,d,p,m);let E;if(x)E=Le({inputs:{x:r},backend:e,attrs:{shape:b}});else if(w||S){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=IS(T,k,$),_=ll({inputs:{x:r},backend:e,attrs:{begin:T,size:N}});E=Le({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else{const N=e.bufferSync(r),_=WF(y,N,$,T);E=e.makeTensorInfo(b,_.dtype,_.values)}return E}const qit={kernelName:V1,backendName:"cpu",kernelFunc:Hit};function Kit(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=t,m=e.data.get(d.dataId).values,y=e.data.get(p.dataId).values,[b,x]=HF(m,y,r,i,o,l,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",x)]}const Xit={kernelName:YR,backendName:"cpu",kernelFunc:Kit};function Yit(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=e.data.get(i.dataId).values,c=e.data.get(o.dataId).values[0],[h,d,p]=qF(l,c,r),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const Zit={kernelName:ZR,backendName:"cpu",kernelFunc:Yit};function Jit(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.data.get(i.dataId).values,l=KF(o,r);return e.makeTensorInfo(i.shape,"int32",l)}const Qit={kernelName:JR,backendName:"cpu",kernelFunc:Jit};const tot=ke(qd,n=>Math.tan(n)),eot={kernelName:qd,backendName:"cpu",kernelFunc:tot};const not=ke(Kd,n=>Math.tanh(n)),sot={kernelName:Kd,backendName:"cpu",kernelFunc:not};function rot(n){const{inputs:t,backend:e}=n,{tensor:s,indices:r,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=fl(i,r,s.shape),p=!1,m=e.bufferSync(r),y=e.bufferSync(i),b=e.bufferSync(s),x=Ua(m,y,s.shape,d,c,l,o,h,b,p);return e.makeTensorInfo(s.shape,x.dtype,x.values)}const iot={kernelName:jR,backendName:"cpu",kernelFunc:rot};function oot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;Nt(r,"tile");const o=YF(e.bufferSync(r),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}const aot={kernelName:Xd,backendName:"cpu",kernelFunc:oot};function lot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s;Nt(r,"topk");const l=e.data.get(r.dataId).values,[c,h]=JF(l,r.shape,r.dtype,i,o);return[e.makeTensorInfo(c.shape,c.dtype,c.values),e.makeTensorInfo(h.shape,h.dtype,h.values)]}const cot={kernelName:U1,backendName:"cpu",kernelFunc:lot};function uot(n){const{inputs:t,attrs:e,backend:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=e,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=Dt(r.shape),T=S[0],k=S[1],$=S[2],E=Dt(w),N=E[0],_=E[1],R=E[2],D=Yn(r.dtype,ft(w));D.fill(c);const M=s.data.get(r.dataId).values,A=s.data.get(i.dataId).values;for(let H=0;H<d;++H){const W=i.shape[0]===1?A:A.subarray(H*8,H*8+8);for(let X=0;X<b;++X)for(let P=0;P<x;++P)for(let U=0;U<y;++U){let G;const tt=W[6]*P+W[7]*X+1;if(tt===0)continue;const Z=(W[0]*P+W[1]*X+W[2])/tt,F=(W[3]*P+W[4]*X+W[5])/tt,z=KN(Z,m,l),Q=KN(F,p,l);switch(o){case"nearest":G=got(M,p,m,T,k,$,H,Q,z,U,c);break;case"bilinear":G=yot(M,p,m,T,k,$,H,Q,z,U,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ct=H*N+X*_+P*R+U;D[ct]=G}return s.makeTensorInfo(w,r.dtype,D)}return{dataId:s.write(D,w,r.dtype),shape:r.shape,dtype:r.dtype}}const hot={kernelName:j1,backendName:"cpu",kernelFunc:uot};function KN(n,t,e){switch(e){case"reflect":return dot(n,t);case"wrap":return fot(n,t);case"nearest":return mot(n,t);default:return pot(n)}}function dot(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Xa(0,e,t-1)}function fot(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return Xa(0,e,t-1)}function pot(n,t){return n}function mot(n,t){return Xa(0,n,t-1)}function mh(n,t,e,s,r,i,o,l,c,h,d){const p=o*s+l*r+c*i+h;return 0<=l&&l<t&&0<=c&&c<e?n[p]:d}function got(n,t,e,s,r,i,o,l,c,h,d){const p=Math.round(l),m=Math.round(c);return mh(n,t,e,s,r,i,o,p,m,h,d)}function yot(n,t,e,s,r,i,o,l,c,h,d){const p=Math.floor(l),m=Math.floor(c),y=p+1,b=m+1,x=(b-c)*mh(n,t,e,s,r,i,o,p,m,h,d)+(c-m)*mh(n,t,e,s,r,i,o,p,b,h,d),w=(b-c)*mh(n,t,e,s,r,i,o,y,m,h,d)+(c-m)*mh(n,t,e,s,r,i,o,y,b,h,d);return(y-l)*x+(l-p)*w}function bot(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;Nt(i,"unique");const o=s.data.get(i.dataId).values,{outputValues:l,outputShape:c,indices:h}=QF(o,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const xot={kernelName:G1,backendName:"cpu",kernelFunc:bot};function vot(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r.shape.length,l=r.shape[i],c=new Array(o-1);let h=0;for(let y=0;y<o;y++)y!==i&&(c[h++]=r.shape[y]);const d=new Array(o).fill(0),p=r.shape.slice();p[i]=1;const m=new Array(l);for(let y=0;y<m.length;y++){d[i]=y;const b=ll({inputs:{x:r},backend:e,attrs:{begin:d,size:p}});m[y]=Le({inputs:{x:b},backend:e,attrs:{shape:c}}),e.disposeIntermediateTensorInfo(b)}return m}const wot={kernelName:l0,backendName:"cpu",kernelFunc:vot};function Sot(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s;Nt(r,"unsortedSegmentSum");const l=r.shape.length,c=i.shape.length,h=[],d=[],p=l-c;let m=i;for(let b=0;b<p;++b){const x=Zm({inputs:{input:m},backend:e,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<o;++b){const x=Xo(b,"int32"),w=e.makeTensorInfo([],"int32",x),S=pF({inputs:{a:w,b:m},backend:e}),T=Ho({inputs:{x:S},backend:e,attrs:{dtype:"float32"}}),k=D0({inputs:{a:T,b:r},backend:e}),$=gf({inputs:{x:k},backend:e,attrs:{axis:0,keepDims:!1}});h.push($),d.push(w),d.push(S),d.push(T),d.push(k),d.push($)}const y=pL({inputs:h,backend:e,attrs:{axis:0}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const Cot={kernelName:c0,backendName:"cpu",kernelFunc:Sot};const Tot=[yet,YQ,xet,wet,ntt,Tet,$et,Iet,Aet,Ret,Oet,Fet,Pet,Vet,jet,Het,Ket,Yet,Jet,met,tnt,nnt,rnt,rtt,ont,ttt,ott,lnt,ZQ,unt,dnt,fnt,mnt,ynt,xnt,wnt,Cnt,knt,Ent,Nnt,_nt,Dnt,Mnt,Lnt,Pnt,Bnt,Unt,Gnt,Wnt,Hnt,qnt,Xnt,Jnt,aet,tst,att,lst,ltt,cst,utt,mst,gst,bst,dtt,ptt,vst,Sst,Tst,$st,gtt,btt,JQ,Ist,hnt,Ast,Rst,Ost,cet,vtt,Stt,Fst,Ttt,Pst,Vst,jst,Hst,Kst,Yst,Zst,$tt,Qst,ert,srt,irt,art,crt,hrt,Itt,frt,grt,xrt,Att,Rtt,Srt,krt,Irt,Ott,Art,Rrt,Drt,mL,Lrt,het,Ltt,zrt,Vrt,jrt,Wrt,QQ,iw,qrt,det,fet,pet,Xrt,Zrt,Qrt,eit,sit,rit,oit,Wtt,lit,fit,mit,xit,qtt,wit,Cit,kit,Ktt,yrt,Iit,Ait,Rit,Oit,Fit,Pit,Bit,Uit,Ztt,jit,Qtt,eet,Wit,qit,Xit,Zit,Qit,iet,Ynt,eot,sot,iot,aot,cot,hot,Mtt,xot,wot,Cot,_rt];for(const n of Tot)tD(n);const La={},Zp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function kot(n,t){La[n]=t}function Zr(n,t){if(!(n in La)||t!=null){const s=Eot(n,t);if(s!==null)La[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=La[n];return e==null||e.isContextLost()?(delete La[n],Zr(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),La[n])}function $ot(n){if(!lt().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Eot(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??$ot(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete La[n]},!1),lt().getBool("SOFTWARE_WEBGL_ENABLED")&&(Zp.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",Zp)||e.getContext("experimental-webgl",Zp):e.getContext("webgl2",Zp)}var Hh;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Hh||(Hh={}));var tr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(tr||(tr={}));var Ln;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ln||(Ln={}));function yf(n,t){return[t,n]}function Iot(n,t){return n*t}function Jp(n){const t=ft(n),e=Math.ceil(t/4);return Nv(e)}function nu(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function Not(n,t){const[e,s]=nu(n,t);return e*s*4}function IC(n,t){const e=n;let s,r,i,o,l,c,h,d,p,m;return lt().getNumber("WEBGL_VERSION")===2?(s=e.R32F,r=e.R16F,i=e.RGBA16F,o=e.RGBA32F,l=e.RED,h=4,d=1,p=e.HALF_FLOAT,m=e.FLOAT,c=e.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=e.RGBA,l=n.RGBA,h=4,d=4,p=t!=null?t.HALF_FLOAT_OES:null,m=n.FLOAT,c=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:c,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function $t(n,t){const e=t();return lt().getBool("DEBUG")&&Aot(n),e}function Aot(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+Oot(n,t))}const _ot=596e-10,Rot=65504;function Dot(n){return!!(lt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||_ot<Math.abs(n)&&Math.abs(n)<Rot)}function Oot(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Qp(n,t){return no(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Mot(n,t){const e=no(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if($t(n,()=>n.shaderSource(e,t)),$t(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function Fot(n,t){const e=no(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if($t(n,()=>n.shaderSource(e,t)),$t(n,()=>n.compileShader(e)),lt().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw gL(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const Lot=/ERROR: [0-9]+:([0-9]+):/g;function gL(n,t){const e=Lot.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((p,m)=>Ec((m+1).toString(),i)+p);let l=0;for(let p=0;p<o.length;p++)l=Math.max(o[p].length,l);const c=o.slice(0,s-1),h=o.slice(s-1,s),d=o.slice(s);console.log(c.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Ec(h[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function Pot(n){return no(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function zot(n,t){if($t(n,()=>n.linkProgram(t)),!lt().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function jx(n,t){if($t(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Bot(n,t){const e=no(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return $t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),$t(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Vot(n,t){const e=no(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return $t(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),$t(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Uot(n){return no(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function jot(n,t){const e=lt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,r=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function Got(n){return no(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function XN(n,t,e,s,r,i,o){const l=n.getAttribLocation(t,e);return l===-1?!1:($t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),$t(n,()=>n.vertexAttribPointer(l,r,n.FLOAT,!1,i,o)),$t(n,()=>n.enableVertexAttribArray(l)),!0)}function Wot(n,t,e){Yot(n,e),$t(n,()=>n.activeTexture(n.TEXTURE0+e)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function Hot(n,t,e){return no(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function qot(n,t,e){return n.getUniformLocation(t,e)}function Kot(n,t,e,s){$t(n,()=>Wot(n,t,s)),$t(n,()=>n.uniform1i(e,s))}function Gx(n,t,e){$t(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),$t(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function YN(n,t){$t(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),$t(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function tm(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Xot(n,t))}function Xot(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function no(n,t,e){const s=$t(n,()=>t());if(s==null)throw new Error(e);return s}function Yot(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const r=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${r}.`)}}function jc(n,t=2){return ft(n.slice(0,n.length-t))}function Gc(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function em(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[jc(n),...Gc(n)]),t}function Zot(n,t=!1){let e=lt().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=lt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&lt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((l,c)=>c>=n.length-2?Qw(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Ko(n).newShape);let r=ft(n),i=null;n.length<=1&&r<=e?i=[1,r]:n.length===2&&n[0]<=e&&n[1]<=e?i=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(i==null||o)if(t){const l=jc(n);let c=2,h=2;n.length&&([c,h]=Gc(n)),r=l*(c/2)*(h/2),i=Nv(r).map(d=>d*2)}else i=Nv(r);return i}function nm(n){return n%2===0}function Qm(n,t){if(n=n.slice(-2),t=t.slice(-2),we(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||nm(e)&&nm(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&nm(n[0])&&nm(t[0])}let Wx,Hx;function Jot(n){if(Wx==null){const t=Zr(n);Wx=t.getParameter(t.MAX_TEXTURE_SIZE)}return Wx}function Qot(n){if(Hx==null){const t=Zr(n);Hx=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Hx)}function tat(n){if(n===0)return 0;let t;const e=Zr(n);return Cr(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:Cr(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Cr(n,t){return n.getExtension(t)!=null}function ZN(n){try{if(Zr(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function eat(n){if(n===0)return!1;const t=Zr(n);if(n===1){if(!Cr(t,"OES_texture_float"))return!1}else if(!Cr(t,"EXT_color_buffer_float"))return!1;return aw(t)}function nat(n){if(n===0)return!1;const t=Zr(n);if(n===1){if(!Cr(t,"OES_texture_float")||!Cr(t,"WEBGL_color_buffer_float"))return!1}else{if(Cr(t,"EXT_color_buffer_float"))return aw(t);const s="EXT_color_buffer_half_float";if(Cr(t,s)){const r=t.getExtension(s);return sat(t,r)}return!1}return aw(t)}function aw(n){const t=IC(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function sat(n,t){const e=IC(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),l}function rat(n){return n!==2?!1:Zr(n).fenceSync!=null}function bf(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&L(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const At=lt();At.registerFlag("HAS_WEBGL",()=>At.getNumber("WEBGL_VERSION")>0);At.registerFlag("WEBGL_VERSION",()=>ZN(2)?2:ZN(1)?1:0);At.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);At.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>At.get("WEBGL_VERSION")===2);At.registerFlag("WEBGL_CPU_FORWARD",()=>!0);At.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);At.registerFlag("WEBGL_PACK",()=>At.getBool("HAS_WEBGL"));At.registerFlag("WEBGL_PACK_NORMALIZATION",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CLIP",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_REDUCE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_LAZILY_UNPACK",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_CONV_IM2COL",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Jot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Qot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=At.getNumber("WEBGL_VERSION");return n===0?0:tat(n)});At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>At.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!fD());At.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>eat(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>At.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:At.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));At.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>nat(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_FENCE_API_ENABLED",()=>rat(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>At.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);At.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});At.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>fD()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});At.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);At.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);At.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);At.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);At.registerFlag("WEBGL_EXP_CONV",()=>!1);At.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>At.getBool("IS_TEST"));At.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);At.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);At.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);At.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function ds(){let n,t,e,s,r,i,o,l,c,h;return lt().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",l=lt().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",r="texture2D",i="gl_FragColor",o="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:c,defineRound:h}}function gl(n,t,e="index"){const s=Dt(t);return s.map((r,i)=>{const o=`int ${n[i]} = ${e} / ${r}`,l=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${l};`}).join("")}function O0(n,t,e="index"){const s=Dt(t);return s.map((r,i)=>{const o=`int ${n[i]} = ${e} / outShapeStrides[${i}]`,l=i===s.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${l};`}).join("")}function iat(n,t){const e=n.length,s=n.map(i=>`${t}[${i}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function oat(n,t,e="index"){const s=n.map((i,o)=>o),r=iat(s,t);return r.map((i,o)=>{const l=`int ${n[o]} = ${e} / ${r[o]}`,c=o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${l}; ${c};`}).join("")}function NC(n){const t=Dt(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function AC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const yL=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:bL}=W7;function aat(n,t,e){const s=[];if(n.forEach(y=>{const b=ft(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),e.enableShapeUniforms){const{uniformShape:x}=_C(e.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(y=>lat(y,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),o=t.texShape,l=ds(),c=hat(l);let h,d,p=pat(l);return t.isPacked?(h=cat(t.logicalShape,o,e.enableShapeUniforms),d=fat(l)):(h=uat(t.logicalShape,o,e.enableShapeUniforms),d=dat(l)),e.packedInputs&&(p+=bat),[p,c,d,r,h,i,e.userCode].join(`
`)}function su(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return Aat(n,t);case 1:return Rat(n,t);case 2:return Oat(n,t);case 3:return Fat(n,t);case 4:return Pat(n,t);case 5:return zat(n);case 6:return Bat(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function xL(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return Nat(n);case 1:return _at(n,t);case 2:return Dat(n,t);case 3:return Mat(n,t);default:return Lat(n,t)}}function lat(n,t,e=!1,s){let r="";e?r+=xL(n,s):r+=su(n,s);const i=n.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(e?r+=Vat(n,t):r+=Uat(n,t)),r}function cat(n,t,e){switch(n.length){case 0:return vL();case 1:return xat(n,t,e);case 2:return Eat(n,t,e);case 3:return wat(n,t,e);default:return Cat(n,t,e)}}function uat(n,t,e){switch(n.length){case 0:return vL();case 1:return vat(n,t,e);case 2:return Iat(n,t,e);case 3:return Sat(n,t,e);case 4:return Tat(n,t,e);case 5:return kat(n,t);case 6:return $at(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function hat(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function dat(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function fat(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function pat(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${mat}
    ${gat}
    ${yat}
  `}const mat=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,gat=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,yat=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bat=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function vL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function xat(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function vat(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function wat(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function Sat(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${O0(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=gl(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function Cat(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,l="",c="b, r, c";for(let h=2;h<n.length-1;h++)o*=n[n.length-h-1],l=`
      int b${h} = index / ${o};
      index -= b${h} * ${o};
    `+l,c=`b${h}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${c});
    }
  `}function Tat(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${O0(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=gl(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function kat(n,t){const e=gl(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function $at(n,t){const e=gl(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Eat(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(we(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Iat(n,t,e){return we(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function yl(n){return`offset${n}`}function Nat(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=ds();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function Aat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=yl(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});
      return sampleTexture(${e}, uv);
    }
  `;const[l,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${c}, ${o});
      return sampleTexture(${e}, uv);
    }
  `}function _at(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,i=ds();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${e}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${e}, uv);
    }
  `}function Rat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${ru(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const l=yl(e);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${i}.0);
        return sampleTexture(${e}, uv);
      }
    `:i===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${l});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${l});
      return sampleTexture(${e}, uv);
    }
  `}function Dat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],l=i[1],c=ds();if(i!=null&&we(e,i))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${o}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(e[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function Oat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&we(e,i)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=i[0],y=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:l}=Ko(e),c=o;if(c.length<e.length){const m=iu(n,c),y=["row","col"];return`
      ${su(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${ou(y,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${ru(n)}
      }
    `;const h=i[0],d=i[1],p=yl(s);return d===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function Mat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(e[0]===1){const m=e.slice(1),y=[1,2],b=iu(n,m),x=["b","row","col"];return`
        ${xL(b,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${ou(x,y)});
        }
      `}const l=ds();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=o[0],h=o[1],d=Math.ceil(e[2]/2),p=d*Math.ceil(e[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${h}, ${p}, ${d}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function Fat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[1]*e[2],o=e[2],{newShape:l,keptDims:c}=Ko(e),h=l;if(h.length<e.length){const x=iu(n,h),w=["row","col","depth"];return`
        ${su(x,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${ou(w,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${ru(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===i&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===o&&y==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=yl(s);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function Lat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ds();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,l=n.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],h=c[0],d=c[1],p=Math.ceil(i[o-1]/2);let m=p*Math.ceil(i[o-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<o-1;x++)y=`int b${x}, `+y,m*=i[o-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${e}, uv);
    }
  `}function Pat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e[3],o=e[2]*i,l=e[1]*o,{newShape:c,keptDims:h}=Ko(e);if(c.length<e.length){const T=iu(n,c),k=["row","col","depth","depth2"];return`
      ${su(T,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${ou(k,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${i}, 1)));
        ${ru(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===l&&d==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===i&&d==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const S=yl(s);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${S});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${S});
      return sampleTexture(${s}, uv);
    }
  `}function zat(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],i=t[3]*r,o=t[2]*i,l=t[1]*o,{newShape:c,keptDims:h}=Ko(t);if(c.length<t.length){const x=iu(n,c),w=["row","col","depth","depth2","depth3"];return`
      ${su(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${ou(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${i}, ${r})) +
          depth3;
        ${ru(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===l&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;const b=yl(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Bat(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:i}=Ko(t);if(r.length<t.length){const w=iu(n,r),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${su(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${ou(S,i)});
      }
    `}const o=t[5],l=t[4]*o,c=t[3]*l,h=t[2]*c,d=t[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${c}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${ru(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${c}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(b===o&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;const x=yl(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${c} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${e}, uv);
    }
  `}function ru(n){const t=n.name,e=ft(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Vat(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=bL(n.shapeInfo.logicalShape,t.logicalShape),c=Ie(o),h=o-i;let d;const p=["x","y","z","w","u","v"];i===0?d="":o<2&&l.length>=1?d="coords = 0;":d=l.map(T=>`coords.${p[T+h]} = 0;`).join(`
`);let m="";o<2&&i>0?m="coords":m=n.shapeInfo.logicalShape.map((T,k)=>`coords.${p[k+h]}`).join(", ");let y="return outputValue;";const x=ft(n.shapeInfo.logicalShape)===1,S=ft(t.logicalShape)===1;if(i===1&&!x&&!S)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)o===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(l.length){const T=i-2,k=i-1;l.indexOf(T)>-1&&l.indexOf(k)>-1?y="return vec4(outputValue.x);":l.indexOf(T)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(k)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function Uat(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=t.texShape,o=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!n.shapeInfo.isUniform&&l===c&&n.shapeInfo.flatOffset==null&&we(o,i))return`
      float ${r}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const h=Ie(c),d=bL(n.shapeInfo.logicalShape,t.logicalShape),p=c-l;let m;const y=["x","y","z","w","u","v"];l===0?m="":c<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+p]} = 0;`).join(`
`);let b="";return c<2&&l>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+p]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function Ie(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function _C(n,t,e){const{newShape:s,keptDims:r}=Ko(t),i=t.length,o=n&&i===3&&t[0]===1,l=o?t.slice(1):s,c=!n&&i>1&&!we(t,e)&&s.length<i||o;return{useSqueezeShape:c,uniformShape:c?l:t,keptDims:r}}function iu(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function ou(n,t){return t.map(e=>n[e]).join(", ")}function jat(n,t,e,s){const r=e.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),i=r.map(d=>d.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=aat(r,o,t),c=Fot(n.gl,l),h=n.createProgram(c);return lt().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:t,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:i,outShapeInfo:o},wL(n,t,h)))}function wL(n,t,e){const s=[],r=[];let i,o,l,c=null,h=null;h=n.getUniformLocation(e,"NAN",!1),lt().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const p of t.variableNames){const m={name:p,uniform:n.getUniformLocation(e,p,d),offset:n.getUniformLocation(e,`offset${p}`,d)};t.enableShapeUniforms&&(m.shape=n.getUniformLocation(e,`${p}Shape`,d),m.texShape=n.getUniformLocation(e,`${p}TexShape`,d)),s.push(m)}if(t.enableShapeUniforms&&(i=n.getUniformLocation(e,"outShape",d),l=n.getUniformLocation(e,"outShapeStrides",d),o=n.getUniformLocation(e,"outTexShape",d)),t.customUniforms)for(const p of t.customUniforms)r.push(n.getUniformLocation(e,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:c,nanLoc:h,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:o}}function JN(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,i=t[s],o=i.shape;if(!we(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const l=e.texShape,c=i.isUniform?null:i.texData.texShape;if(!we(l,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${c} must match`)})}function Gat(n,t,e,s,r){t.program.enableShapeUniforms||(JN(t.inShapeInfos,e),JN([t.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),lt().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<e.length;++c){const h=e[c],{uniform:d,offset:p,shape:m,texShape:y}=t.variablesLocations[c];if(m){const{uniformShape:b}=_C(t.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(ft(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,c)}}const l=t.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const c=Dt(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(c));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const h=t.program.customUniforms[c],d=t.customUniformLocations[c],p=r[c];if(h.type==="float")n.gl.uniform1fv(d,p);else if(h.type==="vec2")n.gl.uniform2fv(d,p);else if(h.type==="vec3")n.gl.uniform3fv(d,p);else if(h.type==="vec4")n.gl.uniform4fv(d,p);else if(h.type==="int")n.gl.uniform1iv(d,p);else if(h.type==="ivec2")n.gl.uniform2iv(d,p);else if(h.type==="ivec3")n.gl.uniform3iv(d,p);else if(h.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function Wat(n,t,e){let s="";t.concat(e).forEach(o=>{const l=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const c=o.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:p}=_C(n.packedInputs,o.shape,c);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Dt(d);b=`${E[0]===c[1]}_${E[E.length-1]===c[1]}`}const x=o.shape.length,w=d.length===2&&we(o.shape,c),S=ft(o.shape)===1,T=Lc(o.shape,e.shape),k=!n.packedInputs&&x===e.shape.length&&we(c,e.texData.texShape),$=n.packedInputs||d.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${x}_${k}_${h?p:""}_${d.length}_${S}_${T}_${w}_${m}_${y}_${b}_${$}_${l}`}else{const c=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${c}_${l}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${lt().getNumber("WEBGL_VERSION")}`,i}function es(n){return lt().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Hat{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Hh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ds();this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?O0(["r","c","d"],t):gl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class qat{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Hh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ds();this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?O0(["r","c","d"],t):gl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class Kat{constructor(t){this.variableNames=["A"],this.outTexUsage=tr.DOWNLOAD;const e=ds();this.outputShape=t,this.userCode=`
      ${yL}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class Xat{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=tr.DOWNLOAD;const e=ds();this.outputShape=t,this.userCode=`
      ${yL}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const Yat={R:0,G:1,B:2,A:3};class QN{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ds();this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let l=0;l<s.length;l++){const c=s[l];o+=`
          if(offset == ${l}) {
            result = values[${Yat[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?AC():NC(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}class Zat{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ds();this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length);let r="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){const c=o*2+l;r+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?AC():NC(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}function Jat(n){const t=ds(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Mot(n,e)}function Qat(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Bot(n,t)}function tlt(n){const t=new Uint16Array([0,1,2,2,1,3]);return Vot(n,t)}function xf(n,t,e,s,r,i){jot(t,e);const o=Uot(n),l=n.TEXTURE_2D;return $t(n,()=>n.bindTexture(l,o)),$t(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),$t(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),$t(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),$t(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),lt().getNumber("WEBGL_VERSION")===1?$t(n,()=>n.texImage2D(l,0,s,t,e,0,r,i,null)):$t(n,()=>n.texStorage2D(l,1,s,t,e)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function SL(n){return n.internalFormatFloat}function elt(n,t,e,s){const[r,i]=yf(t,e);return xf(n,r,i,SL(s),s.textureFormatFloat,n.FLOAT)}function CL(n){return n.internalFormatHalfFloat}function nlt(n,t,e,s){const[r,i]=yf(t,e);return xf(n,r,i,CL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function TL(n){return n.downloadTextureFormat}function slt(n,t,e,s){const[r,i]=yf(t,e);return xf(n,r,i,TL(s),n.RGBA,n.UNSIGNED_BYTE)}function kL(n){return n.internalFormatPackedFloat}function rlt(n,t,e,s){const[r,i]=nu(t,e);return xf(n,r,i,kL(s),n.RGBA,n.FLOAT)}function $L(n){return n.internalFormatPackedHalfFloat}function ilt(n,t,e,s){const[r,i]=nu(t,e);return xf(n,r,i,$L(s),n.RGBA,s.textureTypeHalfFloat)}function olt(n,t,e){return $t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),XN(n,t,"clipSpacePos",e,3,20,0)&&XN(n,t,"uv",e,2,20,12)}function alt(n,t,e,s,r,i){$t(n,()=>n.bindTexture(n.TEXTURE_2D,t));let o,l,c;r instanceof Uint8Array?(o=new Uint8Array(e*s*4),l=n.UNSIGNED_BYTE,c=n.RGBA):(o=new Float32Array(e*s*4),l=n.FLOAT,c=i.internalFormatPackedFloat),o.set(r),lt().getNumber("WEBGL_VERSION")===2?$t(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,l,o)):$t(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,e,s,0,n.RGBA,l,o)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function llt(n,t,e){$t(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?lt().getNumber("WEBGL_VERSION")===2?$t(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):$t(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):lt().getNumber("WEBGL_VERSION")===2?$t(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):$t(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),$t(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function clt(n,t,e,s){const r=n.createBuffer();$t(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const l=4*4*t*e;return $t(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),$t(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),$t(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function ult(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function hlt(n,t,e,s){const[r,i]=yf(t,e),o=4,l=new Uint8Array(Iot(t*e,o));return $t(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function dlt(n,t,e,s,r,i,o,l){const c=n,h=new Float32Array(Not(i,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,h),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),h}function flt(n,t,e){const s=new Float32Array(t*e*4);return $t(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}class qx{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=lt().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,kot(e,t)):this.gl=Zr(e),t=this.gl,lt().getNumber("WEBGL_VERSION")===2){const i=t;this.createVertexArray=()=>$t(i,()=>i.createVertexArray()),this.bindVertexArray=o=>$t(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>$t(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>$t(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(t!=null){const i=t.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>$t(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>$t(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>$t(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>$t(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),lt().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Qp(this.gl,i),Cr(this.gl,o))this.textureHalfFloatExtension=Qp(this.gl,o);else if(lt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Cr(this.gl,r))this.colorBufferHalfFloatExtension=Qp(this.gl,r);else if(lt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Cr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Cr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Qat(this.gl),this.indexBuffer=tlt(this.gl),this.framebuffer=Got(this.gl),this.textureConfig=IC(this.gl,this.textureHalfFloatExtension)}get debug(){return lt().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;$t(t,()=>t.finish()),$t(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),$t(t,()=>t.deleteFramebuffer(this.framebuffer)),$t(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),$t(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),$t(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),elt(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),nlt(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),slt(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),llt(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),alt(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),ilt(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),rlt(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(YN(this.gl,this.framebuffer),this.outputTexture=null),$t(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>hlt(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,i,o){return dlt(this.gl,t,e,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return ult(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=clt(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(lt().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=i}else lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>flt(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=Jat(e));const s=Pot(e);$t(e,()=>e.attachShader(s,this.vertexShader)),$t(e,()=>e.attachShader(s,t)),zot(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&jx(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;$t(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),olt(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&($t(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&jx(this.gl,this.program),$t(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?Hot(this.gl,t,e):qot(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),$t(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),Kot(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,i]=nu(e,s);this.setOutputMatrixTextureDriver(t,r,i)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&jx(this.gl,this.program),tm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}$t(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),$t(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Qp(this.gl,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await RI(()=>this.disposed||this.isQueryAvailable(t,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=plt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in lt().platform&&(s=lt().platform.setTimeoutCustom.bind(lt().platform)),RI(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Gx(this.gl,t,this.framebuffer),this.debug&&tm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Gx(this.gl,this.outputTexture,this.framebuffer),this.debug&&tm(this.gl)):YN(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;Gx(r,t,this.framebuffer),this.debug&&tm(r),this.outputTexture=t,$t(r,()=>r.viewport(0,0,e,s)),$t(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),$t(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function plt(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}const{addImpl:mlt,bincountImpl:EL,bincountReduceImpl:glt,bitwiseAndImpl:ylt,castImpl:blt,ceilImpl:xlt,concatImpl:vlt,equalImpl:wlt,expImpl:Slt,expm1Impl:Clt,floorImpl:Tlt,gatherNdImpl:klt,gatherV2Impl:$lt,greaterImpl:Elt,greaterEqualImpl:Ilt,lessImpl:Nlt,lessEqualImpl:Alt,linSpaceImpl:_lt,logImpl:Rlt,maxImpl:Dlt,maximumImpl:Olt,minimumImpl:Mlt,multiplyImpl:Flt,negImpl:Llt,notEqualImpl:Plt,prodImpl:zlt,raggedGatherImpl:Blt,raggedRangeImpl:Vlt,raggedTensorToTensorImpl:Ult,rangeImpl:jlt,rsqrtImpl:Glt,scatterImpl:Wlt,sigmoidImpl:Hlt,simpleAbsImpl:IL,sliceImpl:qlt,sparseFillEmptyRowsImpl:Klt,sparseReshapeImpl:Xlt,sparseSegmentReductionImpl:NL,sqrtImpl:Ylt,staticRegexReplaceImpl:Zlt,stridedSliceImpl:Jlt,stringNGramsImpl:Qlt,stringSplitImpl:tct,stringToHashBucketFastImpl:ect,subImpl:nct,tileImpl:sct,topKImpl:rct,transposeImpl:RC,uniqueImpl:ict}=oet;function AL(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function as(n,t){return t===1?[n]:AL(n,t)}function oct(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}class act{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=es(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=as("rc",this.rank),s=Ie(this.rank),r=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class _L{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2===1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${lct(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?AC():NC(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function lct(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?oat(["r","c","d"],"inputShape"):gl(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class cct{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=eA(e,s),i=nA(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=tA(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const c=this.freeTextures[i].pop();return this.usedTextures[i].push(c),c}let l;return r===Ln.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Ln.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Ln.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Ln.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Ln.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(l),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),l}releaseTexture(t,e,s,r){if(this.freeTextures==null)return;const i=eA(s,r),o=nA(e,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const l=tA(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),c=lt().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=l):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const h=this.usedTextures[o],d=h&&h.indexOf(t);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function uct(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function tA(n,t,e,s,r){const i=hct(t,s);let o;if(r){const[c,h]=nu(n[0],n[1]);o=c*h}else{const[c,h]=yf(n[0],n[1]);o=c*h}const l=uct(e,i);return o*l}function hct(n,t){switch(n){case Ln.PACKED_2X2_FLOAT32:return kL(t);case Ln.PACKED_2X2_FLOAT16:return $L(t);case Ln.UNPACKED_FLOAT32:return SL(t);case Ln.UNPACKED_FLOAT16:return CL(t);case Ln.PACKED_4X1_UNSIGNED_BYTE:return TL(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function dct(n){return lt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ln.PACKED_2X2_FLOAT32:Ln.UNPACKED_FLOAT32:n?Ln.PACKED_2X2_FLOAT16:Ln.UNPACKED_FLOAT16}function eA(n,t){if(n===tr.UPLOAD)return Ln.PACKED_2X2_FLOAT32;if(n===tr.RENDER||n==null)return dct(t);if(n===tr.DOWNLOAD||n===tr.PIXELS)return Ln.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function nA(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class ci{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Nr="if (isnan(x)) return x;",fct="return x;",sA="return abs(x);",pct="return (x >= 0.0) ? x : (exp(x) - 1.0);",mct=Nr+`
  return (x < 0.0) ? 0.0 : x;
`,gct=Nr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ao="return x;",yct="return 1.0 / (1.0 + exp(-1.0 * x));";const bct="return x;",xct=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,vct=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wct=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Sct="return 1.0 / (1.0 + exp(-1.0 * x));";class Oo{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class Cct{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length);const e=t.length,s=as("rc",e),r=Ie(e),i=oct(e,s),o=s.slice(-2),l=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}const Tct=QD,kct=1e-7,$ct=1e-4,sm={};function Ect(n){return n in sm||(sm[n]={}),sm[n]}const Ict=lt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Nct=600;function Act(){return lt().global.screen==null?1024:lt().global.screen.height*lt().global.screen.width*window.devicePixelRatio*Nct/1024/1024}class M0 extends Jw{nextDataId(){return M0.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!lt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof qx)e=t;else{const s=Zr(lt().getNumber("WEBGL_VERSION"),t);e=new qx(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Zr(lt().getNumber("WEBGL_VERSION"));e=new qx(s),this.binaryCache=Ect(lt().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new cct(this.gpgpu),this.numMBBeforeWarning=Act(),this.texData=new $R(this,ri())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,r,i,o){const l=this.makeTensorInfo(e,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:t,texShape:[r,i]},c.texShape=[r,i];const h=em(e),d=new QN(h,!1,o),p=this.runWebGLProgram(d,[l],s,[[r,i]]);return p.shape=e,c.texture=null,this.disposeIntermediateTensorInfo(l),p.dataId}write(t,e,s){if((lt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||lt().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:s,values:t,usage:tr.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,r,i){if(lt().getBool("DEBUG")&&this.checkNumericalProblems(e),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:r,values:e,usage:tr.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:l,isPacked:c}=e;if(o!=null){let m;c?m=new Oo(l,Ao):m=new ci(l,Ao);const y=this.runWebGLProgram(m,[{dataId:t,shape:l,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=ys());let p;if(r==="complex64"){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);p=Yi(m,y)}else p=this.getValuesFromTexture(t);return h&&(this.downloadWaitMs+=ys()-d),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){const b=this.pendingRead.get(t);return new Promise(x=>b.push(x))}const e=this.texData.get(t),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:l,isPacked:c}=e;if(i!=null){let b;c?b=new Oo(r,Ao):b=new ci(r,Ao);const x=this.runWebGLProgram(b,[{dataId:t,shape:r,dtype:o}],o),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(t);if(lt().getBool("DEBUG")&&!lt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&lt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(o!=="complex64"&&lt().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(t);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Jp(r))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(o==="complex64"){const b=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),x=b[0],w=b[1];p=Yi(x,w)}else if(h==null)p=this.getValuesFromTexture(t);else{const b=ft(r);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;$t(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(t,p),y=this.pendingRead.get(t);return this.pendingRead.delete(t),y.forEach(b=>b(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ri().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){const s=this.texData.get(t),{values:r,shape:i,slice:o,dtype:l,isPacked:c,texture:h}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let y;c?y=new Oo(i,Ao):y=new ci(i,Ao);const b=this.runWebGLProgram(y,[{dataId:t,shape:i,dtype:l}],l),x=this.readToGPU(b,e);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(t,e.customTexShape),p=ri().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(r=>Vo(r));return te(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return te(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!Dot(s))throw lt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:r}=this.texData.get(t),i=ft(e);if(lt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(t),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Jp(e)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),b}const o=lt().getBool("WEBGL_PACK")&&r===!0,l=o?em(e):e,c=o?new Xat(l):new Kat(l),h=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:t}],"float32"),d=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,t();const i=Ya(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Ya(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=e,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(i);l.kernelMs=U5(c),l.getExtraProfileInfo=()=>c.map((h,d)=>({name:o[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ys(),endMs:null}}endTimer(t){return lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ys(),t)}async getQueryTime(t){if(lt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:r,usage:i,isPacked:o,slice:l}=this.texData.get(t),c=l&&l.origDataId||t,h=this.dataRefCount.get(c);h>1?this.dataRefCount.set(c,h-1):(this.dataRefCount.delete(c),e!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(e,r,i,o)));const d=this.texData.get(t);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=Ict){return lt().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&ft(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Qs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Tct(t.shape,e)}packedUnaryOp(t,e,s){const r=new Oo(t.shape,e),i=this.compileAndRun(r,[t],s);return ri().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const r=IL(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(lt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,sA,t.dtype);const e=new ci(t.shape,sA),s=this.compileAndRun(e,[t]);return ri().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let r;if(e==="string"&&s!=null&&s.length>0&&ed(s[0])){const i=s.map(o=>Fo(o));r=this.write(i,t,e)}else r=this.write(s,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,s){return ri().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new Cct(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new act(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[jc(t.shape),...Gc(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},i=[jc(e),...Gc(e)],o=new _L(i,s),l=!0,c=[s],h=this.runWebGLProgram(o,[r],t.dtype,c,l);return{dataId:h.dataId,shape:e,dtype:h.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:r,shape:i,dtype:o}=s;if(e!=null){const m=ft(i),y=e[0]*e[1]*4;L(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=em(i);let c;r?c=new qat(l):c=new Hat(l);const h=!0,d=[e??Jp(l)],p=this.runWebGLProgram(c,[{shape:l,dtype:o,dataId:t}],o,d,h,e);return{dtype:o,shape:i,dataId:p.dataId}}runWebGLProgram(t,e,s,r,i=!1,o){const l=this.makeTensorInfo(t.outputShape,s),c=this.texData.get(l.dataId);if(t.packedOutput&&(c.isPacked=!0),t.outPackingScheme===Hh.DENSE){const S=o??Jp(t.outputShape);c.texShape=S.map(T=>T*2)}if(t.outTexUsage!=null&&(c.usage=t.outTexUsage),ft(l.shape)===0)return c.values=Yn(l.dtype,0),l;const h=[],d=e.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(S.dataId);if(T.texture==null){if(!t.packedInputs&&ft(S.shape)<=lt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:T.values};t.packedInputs&&(T.isPacked=!0,T.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!T.isPacked!=!!t.packedInputs)S=T.isPacked?this.unpackTensor(S):this.packTensor(S),h.push(S),T=this.texData.get(S.dataId);else if(T.isPacked&&!Qm(T.shape,S.shape)){const k=S,$=S.shape;S.shape=T.shape,S=this.packedReshape(S,$),h.push(S),T=this.texData.get(S.dataId),k.shape=$}return{shape:S.shape,texData:T,isUniform:!1}});this.uploadToGPU(l.dataId);const p={shape:l.shape,texData:c,isUniform:!1},m=Wat(t,d,p),y=this.getAndSaveBinary(m,()=>jat(this.gpgpu,t,d,p)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),lt().get("ENGINE_COMPILE_ONLY")||Gat(this.gpgpu,y,d,p,r),h.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(x=this.endTimer(x),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(x)}));const w=lt().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=ys();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!lt().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){const S=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),S}return l}compileAndRun(t,e,s,r,i=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,r,i)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(lt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=rt(()=>{if(!lt().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=lt().getBool("DEBUG");lt().set("DEBUG",!1);const e=this.abs(ve(1e-8)).dataSync()[0];if(lt().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?kct:$ct}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:r,values:i,texture:o,usage:l,isPacked:c}=e;if(o!=null)return;const h=this.activeTimers!=null;let d;h&&(d=ys());let p=e.texShape;if(p==null&&(p=Zot(s,c),e.texShape=p),i!=null){const m=em(s);let y,b=p[1],x=p[0];const w=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!w)&&([b,x]=nu(p[0],p[1])),c?y=new Zat(m,w):y=new QN(m,w);const S=w?[x,b]:p,T=this.makeTensorInfo(S,r),k=this.texData.get(T.dataId);w?k.usage=tr.PIXELS:k.usage=tr.UPLOAD,k.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),b,x,i);const $=[[x,b]],N=this.runWebGLProgram(y,[T],r,$,!0),_=this.texData.get(N.dataId);e.texShape=_.texShape,e.isPacked=_.isPacked,e.usage=_.usage,lt().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(e.texture=_.texture,e.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(T),h&&(this.uploadWaitMs+=ys()-d)}else{const m=this.acquireTexture(p,l,r,c);e.texture=m}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:r}=s;return e!=null&&(s.values=_ct(e,r)),s.values}acquireTexture(t,e,s,r){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*Em(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(e),r(!0)}catch(i){throw i}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await bO(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(gL(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:r,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:c}=wL(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=r,t.nanLoc=i,t.outShapeLocation=o,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:r,height:i,width:o,channels:l}=t,c=ri().backend;if(!c.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=c.writeTexture(r,e,s,i,o,l);return ri().makeTensorFromDataId(h,e,s,c)}}M0.nextDataId=0;function _ct(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}pD()&&yD("webgl",()=>new M0,2);const DC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class cl{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=qt(e,s),this.enableShapeUniforms=es(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const bl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class au{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=qt(e,s);const i=this.outputShape.length;this.enableShapeUniforms=es(i);let o="";if(r)if(i===0||ft(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Ie(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=as("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${c[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${c[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function zs(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Rct={kernelName:Sd,backendName:"webgl",kernelFunc:zs};function ra(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,i=e.makeTensorInfo(s.shape,"complex64"),o=e.texData.get(i.dataId),l=zs({inputs:{x:s},backend:e}),c=zs({inputs:{x:r},backend:e});return o.complexTensorInfos={real:l,imag:c},i}const Dct={kernelName:d1,backendName:"webgl",kernelFunc:ra};const RL="return (a < 0.) ? b * a : a;",DL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Oct(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:i}=s,o=e.makeTensorInfo([],"float32",Xo(i,"float32")),l=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new au(DL,r.shape,o.shape):new cl(RL,r.shape,o.shape),c=e.runWebGLProgram(l,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),c}const Mct={kernelName:_g,backendName:"webgl",kernelFunc:Oct};const OL="return (a < 0.) ? b * a : a;",ML=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Fct(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,i=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new au(ML,s.shape,r.shape):new cl(OL,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],"float32")}const Lct={kernelName:Yg,backendName:"webgl",kernelFunc:Fct};const lu="if (isnan(x)) return x;";function fe({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,l=i,c=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&e!=null){const p=l.texData.get(o.dataId),m=e(p.values,c);return l.makeTensorInfo(o.shape,c,m)}const h=lt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let d;return h?d=new Oo(o.shape,t):d=new ci(o.shape,n),l.runWebGLProgram(d,[o],c)}}function Vn({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:l})=>{const{a:c,b:h}=o,d=l;if(s&&c.dtype==="complex64"){const b=d.texData.get(c.dataId),x=d.texData.get(h.dataId),[w,S]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(k=>{const[$,E]=k,N={dataId:$.dataId,dtype:$.dtype,shape:c.shape},_={dataId:E.dataId,dtype:E.dtype,shape:h.shape},R=new cl(n,c.shape,h.shape);return d.runWebGLProgram(R,[N,_],Ls($.dtype,E.dtype))}),T=ra({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),T}const p=i||Ls(c.dtype,h.dtype);if((c.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([c,h]))&&r!=null){const b=d.texData.get(c.dataId).values,x=d.texData.get(h.dataId).values,w=c.dtype==="string"?Zi(b):b,S=c.dtype==="string"?Zi(x):x,[T,k]=r(c.shape,h.shape,w,S,p),$=d.makeTensorInfo(k,p),E=d.texData.get($.dataId);return E.values=T,$}const m=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let y;return m?y=new au(t,c.shape,h.shape,e):y=new cl(n,c.shape,h.shape),d.runWebGLProgram(y,[c,h],p)}}function qh(n,t=!1){if(n==="linear")return t?bct:fct;if(n==="relu")return t?vct:mct;if(n==="elu")return t?xct:pct;if(n==="relu6")return t?wct:gct;if(n==="prelu")return t?ML:OL;if(n==="leakyrelu")return t?DL:RL;if(n==="sigmoid")return t?Sct:yct;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class FL{constructor(t,e,s,r=!1,i=!1,o=!1,l=null,c=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=es(this.outputShape.length);const d=r?t[1]:t[2],p=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=i?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";l&&(c?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:w=`vec4 activation(vec4 x) {
          ${l}
        }`,S="result = activation(result);");const T=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let k="rc.x",$="rc.x";t[0]<e[0]?k=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&($=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${$};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${S}

        setOutput(result);
      }
    `}}const rA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class iA{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=qt(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const oA="return a * b;";function OC(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=Ls(s.dtype,r.dtype);if(s.dtype==="complex64"){const l=e.texData.get(s.dataId),c=e.texData.get(r.dataId),h=new iA(rA.REAL,s.shape,r.shape),d=new iA(rA.IMAG,s.shape,r.shape),p=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:r.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:r.shape}],m=e.runWebGLProgram(h,p,"float32"),y=e.runWebGLProgram(d,p,"float32"),b=ra({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}if(e.shouldExecuteOnCPU([s,r])){const l=e.texData.get(s.dataId),c=e.texData.get(r.dataId),[h,d]=Flt(s.shape,r.shape,l.values,c.values,i),p=e.makeTensorInfo(d,i),m=e.texData.get(p.dataId);return m.values=h,p}let o;return lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new au(oA,s.shape,r.shape):o=new cl(oA,s.shape,r.shape),e.runWebGLProgram(o,[s,r],i)}const Pct={kernelName:_d,backendName:"webgl",kernelFunc:OC};function zct(n,t,e){const s=[jc(n.shape),...Gc(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[jc(t),...Gc(t)],o=new _L(i,s),l=!0,c=[s],h=e.runWebGLProgram(o,[r],n.dtype,c,l);return{dataId:h.dataId,shape:t,dtype:h.dtype}}function Tt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:i}=s,o=e,l=ft(r.shape),c=ER(i,l),h=ft(c);L(l===h,()=>`The new shape (${c}) has ${h} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(r.dataId);return d.isPacked&&!Qm(r.shape,c)&&!(d.texture!==null&&Qm(d.shape,c))?zct(r,c,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype})}const Bct={kernelName:Jg,backendName:"webgl",kernelFunc:Tt};class aA{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];const l=Math.floor(s/4)*4,c=s%4;let h="sumValue += dot(values, ones);";if(e!=null){const p=1/e;h=`sumValue += dot(values * ${Oc(p)?p.toPrecision(2):p}, ones);`}let d="";i%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class Vct{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=t;this.outputShape=[r,o];let l="0.0",c="";e==="prod"?l="1.0":e==="min"?(l="1.0 / 1e-20",c="min"):e==="max"&&(l="-1.0 / 1e-20",c="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?h="sumValue":e==="prod"?h="prodValue":e==="all"?h="allValue":e==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";e==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):e==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function Uct(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=x0(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function xl(n,t,e,s){const r=Uct(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:l,windowSize:c,outSize:h}=r[o];let d,p;e==="mean"?d=o===0?new aA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},l):new aA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h}):d=new Vct({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},e),p=i,i=s.runWebGLProgram(d,[i],t),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return i}class jct{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[e[o]];this.outputShape=s,this.rank=s.length;const r=Ie(this.rank),i=Gct(e);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function Gct(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}class Wct{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let d=0;d<s.length;d++)s[d]=t[e[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ie(this.rank),i=AL("rc",this.rank),o=new Array(this.rank);for(let d=0;d<e.length;d++)o[e[d]]=i[d];const l=`vec2(${o.slice(-2).join()})`,c=`++${i[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${o.join()}), ${l})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${c}) {
        result[1] = ${h};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${c}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function F0(n,t,e){const s=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Wct(n.shape,t):new jct(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function Hct(n,t,e,s){const r=t,i=n.shape.length,o=ee(r,n.shape);let l=o;const c=Xe(l,i),h=c!=null;let d=n;h&&(d=F0(n,c,s),l=on(l.length,i)),Bn("sum",l,i);const[p,m]=Dn(d.shape,l);let y=p;e&&(y=dn(p,o));const b=ft(m),w=ft(n.shape)/b,S=Tt({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),T=H1(n.dtype),k=xl(S,T,"sum",s),$=Tt({inputs:{x:k},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(k),h&&s.disposeIntermediateTensorInfo(d),$}function L0(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s;return Hct(r,i,o,e)}const qct={kernelName:r0,backendName:"webgl",kernelFunc:L0};function us(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:i}=s,o=e,l=r.shape.length,c=new Array(l);for(let d=0;d<c.length;d++)c[d]=r.shape[i[d]];let h;if(o.shouldExecuteOnCPU([r])){const p=o.texData.get(r.dataId).values,m=RC(p,r.shape,r.dtype,i,c);h=o.makeTensorInfo(c,r.dtype);const y=o.texData.get(h.dataId);y.values=m}else h=F0(r,i,o);return h}const Kct={kernelName:Ic,backendName:"webgl",kernelFunc:us};const LL=1e3;function tg({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:c=null}){const h=n.shape.length,d=t.shape.length,p=e?n.shape[h-2]:n.shape[h-1],m=s?t.shape[d-1]:t.shape[d-2],y=e?n.shape[h-1]:n.shape[h-2],b=s?t.shape[d-2]:t.shape[d-1],x=n.shape.slice(0,-2),w=t.shape.slice(0,-2),S=ft(x),T=ft(w),$=qt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([y,b]);L(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const E=e?[S,p,y]:[S,y,p],N=s?[T,b,m]:[T,m,b],_=Tt({inputs:{x:n},backend:r,attrs:{shape:E}}),R=Tt({inputs:{x:t},backend:r,attrs:{shape:N}}),D=[_,R],M=Math.max(S,T),A=e?_.shape[1]:_.shape[2],B=i!=null,H=o!=null,W=c==="leakyrelu",X=c!=null?qh(c,!0):null,P=B||H||W||X!=null;let U;if((y===1||b===1)&&A>LL&&P===!1){let tt=_,Z=R;e&&(tt=us({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),D.push(tt)),s&&(Z=us({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),D.push(Z));const F=b!==1,z=b===1;let Q=tt;F&&(Q=Tt({inputs:{x:tt},backend:r,attrs:{shape:[M,A,1]}}),D.push(Q));const ct=b===1?2:1;let pt=Z;z&&(pt=Tt({inputs:{x:Z},backend:r,attrs:{shape:[M,1,A]}}),D.push(pt));const gt=OC({inputs:{a:Q,b:pt},backend:r});U=L0({inputs:{x:gt},backend:r,attrs:{axis:ct,keepDims:!0}}),D.push(gt)}else{const tt=Ls(n.dtype,t.dtype),Z=new FL(E,N,[M,y,b],e,s,B,X,H,W),F=[_,R];if(i!=null&&F.push(i),H&&F.push(o),W){const z=r.makeTensorInfo([],"float32",Xo(l,"float32"));F.push(z),D.push(z)}U=r.runWebGLProgram(Z,F,tt)}const G=Tt({inputs:{x:U},backend:r,attrs:{shape:$}});D.push(U);for(const tt of D)r.disposeIntermediateTensorInfo(tt);return G}function Xct(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:l}=t,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;return tg({a:r,b:i,transposeA:c,transposeB:h,backend:e,bias:o,preluActivationWeights:l,leakyreluAlpha:p,activation:d})}const Yct={kernelName:Im,backendName:"webgl",kernelFunc:Xct};const lA="return abs(x);";function Zct(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=e.texData.get(s.dataId),o=IL(i.values);return e.makeTensorInfo(s.shape,s.dtype,o)}let r;return lt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Oo(s.shape,lA):r=new ci(s.shape,lA),e.runWebGLProgram(r,[s],s.dtype)}const Jct={kernelName:hg,backendName:"webgl",kernelFunc:Zct};const Qct=Nr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,tut=fe({opSnippet:Qct}),eut={kernelName:nd,backendName:"webgl",kernelFunc:tut};const nut=Nr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,sut=fe({opSnippet:nut}),rut={kernelName:sd,backendName:"webgl",kernelFunc:sut};const cA="return a + b;",iut=Vn({opSnippet:cA,packedOpSnippet:cA,supportsComplex:!0,cpuKernelImpl:mlt}),out={kernelName:Yc,backendName:"webgl",kernelFunc:iut};class aut{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class lut{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function ym(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return zs({inputs:{x:s[0]},backend:e});if(s.length>lt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),h=ym({inputs:s.slice(0,c),backend:e}),d=ym({inputs:s.slice(c),backend:e});return ym({inputs:[h,d],backend:e})}const r=s.map(c=>c.dtype).reduce((c,h)=>Ls(c,h)),i=s.map(c=>c.shape),l=lt().getBool("WEBGL_PACK")?new lut(s[0].shape,i):new aut(s[0].shape,i);return e.runWebGLProgram(l,s,r)}const cut={kernelName:i1,backendName:"webgl",kernelFunc:ym};function uut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=ee(i,r.shape);let h=c;const d=Xe(h,l);let p=r;d!=null&&(p=us({inputs:{x:r},backend:e,attrs:{perm:d}}),h=on(h.length,l)),Bn("all",h,l);const[m,y]=Dn(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=xl(x,x.dtype,"all",e);let S;if(o){const T=dn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const hut={kernelName:o1,backendName:"webgl",kernelFunc:uut};function dut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=ee(i,r.shape);let h=c;const d=Xe(h,l);let p=r;d!=null&&(p=us({inputs:{x:r},backend:e,attrs:{perm:d}}),h=on(h.length,l)),Bn("any",h,l);const[m,y]=Dn(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=xl(x,x.dtype,"any",e);let S;if(o){const T=dn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const fut={kernelName:a1,backendName:"webgl",kernelFunc:dut};class put{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const l=e==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class mut{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,L(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=t[t.length-1],o=Math.ceil(i/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,c=l.length,h=Ie(c),d=as("coords",c);let p,m;if(o===1){m=c+1;const R=Ie(m);p=`
        ${R} sourceLocR = ${R}(${d.join()}, 0);
        ++${d[c-1]};
        ${R} sourceLocG = ${R}(${d.join()}, 0);
        ++${d[c-2]};
        ${R} sourceLocA = ${R}(${d.join()}, 0);
        --${d[c-1]};
        ${R} sourceLocB = ${R}(${d.join()}, 0);
        --${d[c-2]};`}else m=c,p=`
        ${h} sourceLocR = coords;
        ++${d[c-1]};
        ${h} sourceLocG = coords;
        ++${d[c-2]};
        ${h} sourceLocA = coords;
        --${d[c-1]};
        ${h} sourceLocB = coords;
        --${d[c-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(R=>"int "+R),w=as("sourceLocR",m-1).concat("inIdx.r"),S=as("sourceLocG",m-1).concat("inIdx.g"),T=as("sourceLocB",m-1).concat("inIdx.b"),k=as("sourceLocA",m-1).concat("inIdx.a"),$=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${k.join()})));`,N=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,_=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[c-1]} < ${l[c-1]-1};
        bool hasNextRow = ${d[c-2]} < ${l[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function PL(n,t,e,s=null){let r=t.shape[0],i=t.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=x0(i),l={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},c=new put(l,e,s==null),h=[t];s!=null&&h.push(s);const d=n.runWebGLProgram(c,h,"int32");if(d.shape[1]===1)return d;const p=PL(n,t,e,d);return n.disposeIntermediateTensorInfo(d),p}function zL(n,t,e,s=null){const r=s!=null?s.shape:t.shape,i=r[r.length-1],o=x0(i),l=new mut(r,o,e,s==null),c=s==null?[t]:[t,s],h=n.runWebGLProgram(l,c,"int32");if(h.shape.length===t.shape.length){const d=zL(n,t,e,h);return n.disposeIntermediateTensorInfo(h),d}return h}function BL(n,t,e,s){const r=[e];if(Bn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!lt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId),l=o!==null&&o.isPacked;let c=t;l&&(c=n.unpackTensor(t),i.push(c));const[h,d]=Dn(c.shape,r),p=ft(d),m=Tt({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});i.push(m);const y=PL(n,m,s);i.push(y);const b=Tt({inputs:{x:y},backend:n,attrs:{shape:h}});return i.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return zL(n,t,s)}function gut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=ee(i,r.shape);const l=Xe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=us({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=on(o.length,c.shape.length)),Bn("argMax",[o[0]],c.shape.length);const d=BL(e,c,o[0],"max");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}const yut={kernelName:dg,backendName:"webgl",kernelFunc:gut};function but(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i}=s;let o=ee(i,r.shape);const l=Xe(o,r.shape.length);let c=r;const h=[];l!=null&&(c=us({inputs:{x:r},backend:e,attrs:{perm:l}}),h.push(c),o=on(o.length,c.shape.length)),Bn("argMin",[o[0]],c.shape.length);const d=BL(e,c,o[0],"min");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}const xut={kernelName:fg,backendName:"webgl",kernelFunc:but};const vut=Nr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,wut=fe({opSnippet:vut}),Sut={kernelName:rd,backendName:"webgl",kernelFunc:wut};const Cut=Nr+"return log(x + sqrt(x * x + 1.0));",Tut=fe({opSnippet:Cut}),kut={kernelName:id,backendName:"webgl",kernelFunc:Tut};const $ut=Nr+`
  return atan(x);
`,Eut=fe({opSnippet:$ut}),Iut={kernelName:od,backendName:"webgl",kernelFunc:Eut};const Nut=DC+`
  return atan(a, b);
`,Aut=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+bl+`
  return result;
`,_ut=Vn({opSnippet:Nut,packedOpSnippet:Aut}),Rut={kernelName:ld,backendName:"webgl",kernelFunc:_ut};const Dut=Nr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Out=fe({opSnippet:Dut}),Mut={kernelName:ad,backendName:"webgl",kernelFunc:Out};class Kh{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,l=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const x=e==="avg",w=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,S=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let T="0.0";if(x||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${l}, ${c});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?w:S:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const k="max";let $=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&($="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,N=o%4,_=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${E};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${$});
      }
    `}}class MC{constructor(t,e,s,r=!1,i=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,l=t.strideDepth,c=t.strideHeight,h=t.strideWidth,d=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,y=t.effectiveFilterDepth,b=t.effectiveFilterHeight,x=t.effectiveFilterWidth,w=t.padInfo.front,S=t.padInfo.top,T=t.padInfo.left;this.outputShape=t.outShape;const k=e==="avg";let $="0.0";if(k||($="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${c}, ${h});
        const ivec3 pads = ivec3(${w}, ${S}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let N=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(N="avgValue / max(count, 1.0)");const _=Math.floor(o/4)*4,R=o%4,D=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${c}, ${h});
      const ivec3 pads = ivec3(${w}, ${S}, ${T});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${_};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${N});
      }
    `}}function Fut(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;bf(r,"avgPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Qn(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Er(r.shape,i,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))return zs({inputs:{x:r},backend:e});const p=new Kh(d,"avg",!1);return e.runWebGLProgram(p,[r],"float32")}const Lut={kernelName:pg,backendName:"webgl",kernelFunc:Fut};function Put(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s,d=[1,1,1],p=to(r.shape,i,o,d,l,c,h),m=new MC(p,"avg",!1);return e.runWebGLProgram(m,[r],"float32")}const zut={kernelName:mg,backendName:"webgl",kernelFunc:Put};class But{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=c-1-t.padInfo.top,p=h-1-t.padInfo.left,m=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class Vut{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=p-1-t.padInfo.front,x=m-1-t.padInfo.top,w=y-1-t.padInfo.left,S=1/(e*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Uut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=to(o.shape,l,c,p,h,d),y=new Vut(m);return e.runWebGLProgram(y,[r],o.dtype)}const jut={kernelName:c1,backendName:"webgl",kernelFunc:Uut};function Gut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i;bf([r,i],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=Er(o.shape,l,c,1,h),p=new But(d);return e.runWebGLProgram(p,[r],o.dtype)}const Wut={kernelName:l1,backendName:"webgl",kernelFunc:Gut};function Hut(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:i}=t,{transposeA:o,transposeB:l}=s;return tg({a:r,b:i,transposeA:o,transposeB:l,backend:e})}const qut={kernelName:gg,backendName:"webgl",kernelFunc:Hut};class Kut{constructor(t,e,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],qt(t,e),qt(t,s);let l="0.0";r!=null&&(qt(t,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="1.0";i!=null&&(qt(t,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Xut{constructor(t,e,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],qt(t,e),qt(t,s);let l="vec4(0.0)";r!=null&&(qt(t,r),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="vec4(1.0)";i!=null&&(qt(t,i),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const Yut=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:i,offset:o,scale:l}=n;L(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),L(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),L(l==null||r.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=e;c==null&&(c=.001);const h=[s,r,i];let d=null;o!=null&&(d=o.shape,h.push(o));let p=null;l!=null&&(p=l.shape,h.push(l));const m=lt().getBool("WEBGL_PACK_NORMALIZATION")?new Xut(s.shape,r.shape,i.shape,d,p,c):new Kut(s.shape,r.shape,i.shape,d,p,c);return t.runWebGLProgram(m,h,h[0].dtype)},Zut={kernelName:Ig,backendName:"webgl",kernelFunc:Yut};class Jut{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Ie(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Qut(this.rank);let r;const i=t.map((o,l)=>`sourceLoc.${lw[l]} = start[${l}] + coords.${lw[l]};`);r=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const lw=["x","y","z","w","u","v"];function Qut(n){if(n===1)return"sourceLoc";if(n<=6)return lw.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class tht{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Ie(this.rank),s=as("coords",this.rank),r=as("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,l=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((d,p)=>`start[${p}]`).join()});`:t.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${l}
        ${c}
        setOutput(result);
      }
    `}}function eht(n,t,e,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(e,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=n.dtype;let l=AS(t,Dt(n.shape));r.slice&&(l+=r.slice.flatOffset),o.slice={flatOffset:l,origDataId:r.slice&&r.slice.origDataId||n.dataId};const c=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,c+1),i}function cu(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,size:o}=s,[l,c]=b0(r,i,o);if(ES(r,l,c),ft(c)===0)return e.makeTensorInfo(c,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||r.dtype==="string"){const p=e.texData.get(r.dataId),m=qlt(p.values,l,c,r.shape,r.dtype);return e.makeTensorInfo(c,r.dtype,m)}const{isPacked:h}=e.texData.get(r.dataId),d=NS(r.shape,l,c);if(h||!d){const p=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tht(c):new Jut(c),m=[l];return e.runWebGLProgram(p,[r],r.dtype,m)}return e.uploadToGPU(r.dataId),eht(r,l,c,e)}const nht={kernelName:s0,backendName:"webgl",kernelFunc:cu};const sht=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,crops:o}=s;L(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((T,k)=>T*k),c=rf(r.shape,i,l),h=of(c.length,i.length),d=af(r.shape,i,l),p=MS(o,i.length),m=FS(d,o,i.length),y=[],b=Tt({inputs:{x:r},backend:e,attrs:{shape:c}}),x=us({inputs:{x:b},backend:e,attrs:{perm:h}}),w=Tt({inputs:{x},backend:e,attrs:{shape:d}}),S=cu({inputs:{x:w},backend:e,attrs:{begin:p,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(T=>e.disposeIntermediateTensorInfo(T)),S},rht={kernelName:yg,backendName:"webgl",kernelFunc:sht};function iht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o}=s,l=e.readSync(r.dataId),c=e.readSync(i.dataId),h=EL(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,h)}const oht={kernelName:u1,backendName:"webgl",kernelFunc:iht};const aht=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,lht=`
  return float(int(a.r) & int(b.r));
`;function cht(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,i=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=lt().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,r])||o===1){const c=e.texData.get(s.dataId).values,h=e.texData.get(r.dataId).values,[d,p]=ylt(s.shape,r.shape,c,h,s.dtype),m=e.makeTensorInfo(p,s.dtype),y=e.texData.get(m.dataId);return y.values=d,m}let l;return i?l=new au(aht,s.shape,r.shape,!1):l=new cl(lht,s.shape,r.shape),e.runWebGLProgram(l,[s,r],s.dtype)}const uht={kernelName:h1,backendName:"webgl",kernelFunc:cht};function hht(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,i=e.readSync(s.dataId),o=e.readSync(r.dataId),l=qt(Array.from(i),Array.from(o));return e.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const dht={kernelName:DR,backendName:"webgl",kernelFunc:hht};const fht="return float(a != b);",VL=Vn({opSnippet:fht,cpuKernelImpl:Plt,dtype:"bool"}),pht={kernelName:Wg,backendName:"webgl",kernelFunc:VL};function vf(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return zs({inputs:{x:r.complexTensorInfos.real},backend:e})}const mht={kernelName:F1,backendName:"webgl",kernelFunc:vf};const ght="return float(int(x));";function yht(n,t){const e=new ci(n.shape,ght),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function cw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return zs({inputs:{x:r},backend:e});const o=_n(r.shape),l=cw({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),c=ra({inputs:{real:l,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(l),c}if(r.dtype==="complex64"){const o=vf({inputs:{input:r},backend:e}),l=cw({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),l}if(!IR(r.dtype,i)){const o=zs({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[l,c,h]=blt(o,r.shape,r.dtype,i);return e.makeTensorInfo(l,c,h)}if(i==="int32")return yht(r,e);if(i==="bool"){const o=e.makeTensorInfo([],"bool",Yn("bool",1)),c=VL({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),c}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const bht={kernelName:cd,backendName:"webgl",kernelFunc:cw};const uA="return ceil(x);",xht=fe({opSnippet:uA,packedOpSnippet:uA,cpuKernelImpl:xlt}),vht={kernelName:ud,backendName:"webgl",kernelFunc:xht};class wht{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class Sht{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function Cht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:i,clipValueMax:o}=s;let l;lt().getBool("WEBGL_PACK_CLIP")?l=new Sht(r.shape):l=new wht(r.shape);const c=[[i],[o]];return e.runWebGLProgram(l,[r],r.dtype,c)}const Tht={kernelName:hd,backendName:"webgl",kernelFunc:Cht};class kht{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function hA(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function $ht(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),i=new kht(s.shape),o=[hA(s,r.complexTensorInfos.real),hA(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}const Eht={kernelName:bg,backendName:"webgl",kernelFunc:$ht};class Iht{constructor(t){this.outputShape=[],this.outputShape=pi(t,1),this.variableNames=t.map((o,l)=>`T${l}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++){const l=e[o-1];s.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${l}));`)}const r=e.length,i=e[e.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class Nht{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=pi(t,e);const s=this.outputShape,r=s.length,i=Ie(r),o=as("coords",r),l=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((x,w)=>`T${w}`);const c=new Array(t.length-1);c[0]=t[0][e];for(let x=1;x<c.length;x++)c[x]=c[x-1]+t[x][e];const h=l[e],d=l.slice(-2),p=l.join();let m=`if (${h} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let x=1;x<c.length;x++){const w=c[x-1];m+=`
        if (${h} < ${c[x]}  && ${h} >= ${c[x-1]}) {
          return getChannel(
            getT${x}(${rm(l,h,w)}),
            vec2(${rm(d,h,w)}));
        }`}const y=c.length,b=c[c.length-1];m+=`
        return getChannel(
          getT${y}(${rm(l,h,b)}),
          vec2(${rm(d,h,b)}));`,this.userCode=`
      float getValue(${l.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function rm(n,t,e){const s=n.indexOf(t);return n.map((i,o)=>o===s?`${i} - ${e}`:i).join()}function P0(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.texData.get(s.dataId);return zs({inputs:{x:r.complexTensorInfos.imag},backend:e})}const Aht={kernelName:I1,backendName:"webgl",kernelFunc:P0};function gh(n,t,e){const s=n[0].dtype;if(s==="complex64"){const y=n.map(T=>vf({inputs:{input:T},backend:e})),b=n.map(T=>P0({inputs:{input:T},backend:e})),x=gh(y,t,e),w=gh(b,t,e),S=ra({inputs:{real:x,imag:w},backend:e});return y.forEach(T=>e.disposeIntermediateTensorInfo(T)),b.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),S}let r=e.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map($=>{const N=[-1,ft($.shape.slice(t))];return Tt({inputs:{x:$},backend:e,attrs:{shape:N}})}),b=y.map($=>({vals:e.readSync($.dataId),shape:$.shape})),x=pi(y.map($=>$.shape),1),w=y[0].shape[0]===1,S=vlt(b,x,s,w),T=pi(n.map($=>$.shape),t),k=e.makeTensorInfo(T,s,S);return y.forEach($=>e.disposeIntermediateTensorInfo($)),k}const i=n.filter(y=>ft(y.shape)>0),o=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const y=o?new ci(n[0].shape,Ao):new Oo(n[0].shape,Ao);return e.runWebGLProgram(y,n,s)}const l=lt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>l){const y=[];for(let x=0;x<i.length;x+=l){const w=i.slice(x,x+l);y.push(gh(w,t,e))}const b=gh(y,t,e);for(const x of y)e.disposeIntermediateTensorInfo(x);return b}if(o){const y=new Nht(i.map(b=>b.shape),t);return e.runWebGLProgram(y,i,s)}const{tensors2D:c,outShape:h}=_ht(i,t,e),d=new Iht(c.map(y=>y.shape)),p=e.runWebGLProgram(d,c,s);c.forEach(y=>e.disposeIntermediateTensorInfo(y));const m=Tt({inputs:{x:p},attrs:{shape:h},backend:e});return e.disposeIntermediateTensorInfo(p),m}function _ht(n,t,e){const s=pi(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>Tt({inputs:{x:i},attrs:{shape:[-1,ft(i.shape.slice(t))]},backend:e})),outShape:s}}function UL(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,i=ee(r,t[0].shape)[0],o=t.map(h=>h.shape);RS(o,i);const l=pi(t.map(h=>h.shape),i);if(ft(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const c=t.filter(h=>ft(h.shape)>0);return c.length===1?zs({inputs:{x:c[0]},backend:e}):gh(c,i,e)}const Rht={kernelName:xg,backendName:"webgl",kernelFunc:UL};class jL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,l=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,x=t.inChannels%4,w=t.dataFormat==="channelsLast",S=w?1:2,T=w?2:3,k=w?3:1;let $="",E="";s&&(r?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:$=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const N=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${c}, ${h});
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${E}
        setOutput(result);
      }
    `}}class Dht{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,x=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${e}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class GL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=es(this.outputShape.length);const o=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const S=w*2;if(m+=`
           xC = xCCorner + ${S*c};
           `,l===1){if(S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,c===1&&S>0?m+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const T=o%2===0?Qw(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,c>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:m+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):T===1?m+=`
                     xC${S+1} = xTexelC${S};
                     `:m+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(m+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(m+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(m+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:i?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class Oht{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=es(this.outputShape.length);const{dataFormat:s}=e,r=ds(),i=s==="channelsLast",o=i?1:2,l=i?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}function eg(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function WL({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape,h=s.texData.get(n.dataId),d=e.inChannels,p=c[0]*c[1]*c[2],m=e.outChannels,y=e.dataFormat==="channelsLast",b=!1,x=!1;let w;const S=[];if(i!=null){const $=eg(i.shape,y);$!=null&&(i=Tt({inputs:{x:i},backend:s,attrs:{shape:$}}),S.push(i))}if(r!=null){const $=eg(r.shape,y);$!=null&&(r=Tt({inputs:{x:r},backend:s,attrs:{shape:$}}),S.push(r))}if(!((p===1||m===1)&&d>LL)&&h.isPacked&&y&&h.texture!=null&&c[2]%2!==0&&we(h.shape.slice(-3),c.slice(-3))){const $=c[0]*c[1]*(c[2]+1),E={dataId:n.dataId,shape:[1,$,e.inChannels],dtype:n.dtype},N=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,L(Qm(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const _=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});S.push(_);const R=tg({a:E,b:_,backend:s,transposeA:b,transposeB:x,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),D=s.texData.get(R.dataId);L(D.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=N,D.shape=e.outShape,w=zs({inputs:{x:R},backend:s}),w.shape=e.outShape,S.push(R)}else{const $=e.outHeight*e.outWidth,E=Tt({inputs:{x:n},backend:s,attrs:{shape:y?[e.batchSize,$,e.inChannels]:[e.batchSize,e.inChannels,$]}}),N=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),_=tg({a:y?E:N,b:y?N:E,transposeA:!y,transposeB:x,backend:s,bias:r,activation:l,preluActivationWeights:i,leakyreluAlpha:o});w=Tt({inputs:{x:_},backend:s,attrs:{shape:e.outShape}}),S.push(E),S.push(N),S.push(_)}for(const $ of S)s.disposeIntermediateTensorInfo($);return w}function HL({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:c,filterHeight:h,inChannels:d,outWidth:p,outHeight:m,dataFormat:y}=e,b=y==="channelsLast",x=c*h*d,w=m*p,S=[e.batchSize,x,w],T=!0,k=!1,$=[];if(i!=null){const G=eg(i.shape,b);G!=null&&(i=Tt({inputs:{x:i},backend:s,attrs:{shape:G}}),$.push(i))}if(r!=null){const G=eg(r.shape,b);G!=null&&(r=Tt({inputs:{x:r},backend:s,attrs:{shape:G}}),$.push(r))}const E=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,x,ft(t.shape)/x]}});$.push(E);const N=new Oht(S,e),_=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],R=s.runWebGLProgram(N,[n],"float32",_),D=Tt({inputs:{x:R},backend:s,attrs:{shape:S}});$.push(R),$.push(D);const M=r!=null,A=i!=null,B=l==="leakyrelu",H=l?qh(l,!0):null,W=new FL(b?D.shape:E.shape,b?E.shape:D.shape,b?[e.batchSize,w,e.outChannels]:[e.batchSize,e.outChannels,w],T,k,M,H,A,B),X=b?[D,E]:[E,D];if(r&&X.push(r),A&&X.push(i),B){const G=s.makeTensorInfo([],"float32",Xo(o,"float32"));X.push(G),$.push(G)}const P=s.runWebGLProgram(W,X,"float32"),U=Tt({inputs:{x:P},backend:s,attrs:{shape:e.outShape}});$.push(P);for(const G of $)s.disposeIntermediateTensorInfo(G);return U}function Mht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s,p=eo(c),m=zn(r.shape,i.shape,o,h,l,d,!1,p);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=WL({x:r,filter:i,convInfo:m,backend:e});else if(m.strideWidth<=2&&p==="channelsLast"&&lt().getBool("WEBGL_EXP_CONV")){const x=new GL(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=e.runWebGLProgram(x,[r,i],"float32",w)}else if(lt().getBool("WEBGL_CONV_IM2COL"))y=HL({x:r,filter:i,convInfo:m,backend:e});else{const x=new jL(m);y=e.runWebGLProgram(x,[r,i],"float32")}const b=Tt({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(y),b}const Fht={kernelName:vg,backendName:"webgl",kernelFunc:Mht};class Lht{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Pht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=t.dataFormat==="channelsLast",l=e-1-t.padInfo.top,c=s-1-t.padInfo.left,h=o?1:2,d=o?2:3,p=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zht{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.padInfo.front,o=t.padInfo.top,l=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${i};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${l};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Bht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth,i=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=e-1-t.padInfo.front,h=s-1-t.padInfo.top,d=r-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Vht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s,p=eo(c),m=zn(r.shape,d,o,1,l,h,!1,p),y=new Lht(m);return e.runWebGLProgram(y,[r,i],"float32")}const Uht={kernelName:f1,backendName:"webgl",kernelFunc:Vht};class jht{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=es(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,r=e-1-t.padInfo.top,i=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Ght(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s,p=eo(h),m=zn(o,i.shape,l,1,c,d,!1,p);if(lt().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new jht(m);return e.runWebGLProgram(b,[r,i],"float32",y)}else{const y=new Pht(m);return e.runWebGLProgram(y,[r,i],"float32")}}const Wht={kernelName:wg,backendName:"webgl",kernelFunc:Ght};function Hht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c}=s,h=Zo(r.shape,i.shape,o,c,l),d=new Dht(h);return e.runWebGLProgram(d,[r,i],"float32")}const qht={kernelName:Sg,backendName:"webgl",kernelFunc:Hht};function Kht(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,pad:l,filterShape:c}=s,h=Zo(r.shape,c,o,1,l),d=new zht(h);return e.runWebGLProgram(d,[r,i],"float32")}const Xht={kernelName:p1,backendName:"webgl",kernelFunc:Kht};function Yht(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{pad:o,strides:l,inputShape:c}=s,h=Zo(c,i.shape,l,1,o),d=new Bht(h);return e.runWebGLProgram(d,[r,i],"float32")}const Zht={kernelName:m1,backendName:"webgl",kernelFunc:Yht};const Jht=lu+`
  return cos(x);
`,Qht=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${bl}
  return result;
`,tdt=fe({opSnippet:Jht,packedOpSnippet:Qht}),edt={kernelName:dd,backendName:"webgl",kernelFunc:tdt};const ndt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,sdt=fe({opSnippet:ndt}),rdt={kernelName:fd,backendName:"webgl",kernelFunc:sdt};class idt{constructor(t,e,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,l,c,h]=t,[d]=e,[p,m]=s;this.outputShape=[d,p,m,h];const y=r==="bilinear"?1:0,[b,x]=[`${l-1}.0`,`${c-1}.0`],[w,S,T]=p>1?[`${(l-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[k,$,E]=m>1?[`${(c-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${$};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const odt=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:i,boxInd:o}=t,{cropSize:l,method:c,extrapolationValue:h}=s,d=new idt(r.shape,i.shape,l,c,h);return e.runWebGLProgram(d,[r,i,o],"float32")},adt={kernelName:y1,backendName:"webgl",kernelFunc:odt};var Xh;(function(n){n.Prod="*",n.Sum="+"})(Xh||(Xh={}));class dA{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Xh.Prod?"1.0":"0.0",l=s?o:`getX(${fA(i,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${c-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${c}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ie(i)} coords = getOutputCoords();
        int end = ${pA(i,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${pA(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${fA(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function fA(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function pA(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function qL(n,t,e,s,r,i){const o=t.shape.length,l=Xe([s],o);let c=t;l!=null&&(c=us({inputs:{x:t},backend:e,attrs:{perm:l}}));const h=on(1,o)[0];if(h!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=c.shape[h];let p=zs({inputs:{x:c},backend:e});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new dA(n,c.shape,!1,i),b=[[m]],x=p;p=e.runWebGLProgram(y,[p],p.dtype,b),e.disposeIntermediateTensorInfo(x)}if(r){const m=new dA(n,c.shape,r,i),y=p;p=e.runWebGLProgram(m,[p],p.dtype),e.disposeIntermediateTensorInfo(y)}if(l!=null){const m=Jo(l),y=us({inputs:{x:p},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(c),y}return p}function ldt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;return qL(Xh.Prod,r,e,i,o,l)}const cdt={kernelName:g1,backendName:"webgl",kernelFunc:ldt};function udt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,exclusive:o,reverse:l}=s;return qL(Xh.Sum,r,e,i,o,l)}const hdt={kernelName:Cg,backendName:"webgl",kernelFunc:udt};function ddt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:i}=t,{size:o,binaryOutput:l}=s;if(r.shape.length===1){const c=e.readSync(r.dataId),h=e.readSync(i.dataId),d=EL(c,h,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,d)}else if(r.shape.length===2){const c=e.bufferSync(r),h=e.bufferSync(i),d=glt(c,h,o,l);return e.makeTensorInfo(d.shape,i.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const fdt={kernelName:b1,backendName:"webgl",kernelFunc:ddt};class pdt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function mdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:i,dataFormat:o}=s,l=r.shape[0],c=o==="NHWC"?r.shape[1]:r.shape[2],h=o==="NHWC"?r.shape[2]:r.shape[3],d=o==="NHWC"?r.shape[3]:r.shape[1],p=c*i,m=h*i,y=d/(i*i),b=o==="NHWC"?[l,p,m,y]:[l,y,p,m],x=new pdt(b,i,o);return e.runWebGLProgram(x,[r],r.dtype)}const gdt={kernelName:x1,backendName:"webgl",kernelFunc:mdt};class KL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=es(this.outputShape.length);const o=t.filterHeight,l=t.filterWidth,c=t.outChannels/t.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}}class XL{constructor(t,e=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=es(this.outputShape.length);const o=t.outChannels/t.inChannels,l=t.padInfo.left,c=t.strideWidth,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,m=p;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<p;S++)y+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<p;S++)y+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const T=S*2;if(y+=`
          xC = xCCorner + ${T*h};
          `,c===1){if(T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,h===1&&T>0?y+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<p)){const k=l%2===0?Qw(h):h;h%2===0&&l%2===1||h%2!==0&&l%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:y+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):k===1?y+=`
                    xC${T+1} = xTexelC${T};
                    `:y+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<p&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<p&&(y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<p&&(y+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<p&&(y+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function ydt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;let d=c;d==null&&(d=[1,1]),L(Qn(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=zn(r.shape,i.shape,o,d,l,h,!0);let m;lt().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new XL(p):m=new KL(p);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[r,i],"float32",y)}const bdt={kernelName:Tg,backendName:"webgl",kernelFunc:ydt};class xdt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,r=t.padInfo.top,i=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${r};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vdt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,r=t.strideHeight,i=t.strideWidth,o=e-1-t.padInfo.top,l=s-1-t.padInfo.left,c=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function wdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s,p=zn(r.shape,d,o,l,c,h,!0),m=new xdt(p);return e.runWebGLProgram(m,[r,i],"float32")}const Sdt={kernelName:v1,backendName:"webgl",kernelFunc:wdt};function Cdt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:i}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s,p=zn(d,i.shape,o,l,c,h,!0),m=new vdt(p);return e.runWebGLProgram(m,[r,i],"float32")}const Tdt={kernelName:w1,backendName:"webgl",kernelFunc:Cdt};class kdt{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function $dt(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],i=ft(s.shape),o=Tt({inputs:{x:s},backend:e,attrs:{shape:[i]}}),l=new kdt(i),c=e.runWebGLProgram(l,[o],o.dtype),h=Tt({inputs:{x:c},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(c),h}const Edt={kernelName:OR,backendName:"webgl",kernelFunc:$dt};class Idt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:l,filterWidth:c,dilationHeight:h,dilationWidth:d}=t,{top:p,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function Ndt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i}=t,{strides:o,pad:l,dilations:c}=s,h=Qd(r.shape,i.shape,o,l,"NHWC",c);let d;const p=new Idt(h);d=e.runWebGLProgram(p,[r,i],"float32");const m=Tt({inputs:{x:d},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(d),m}const Adt={kernelName:kg,backendName:"webgl",kernelFunc:Ndt};function _dt(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,i=t,{allDims:o,summedDims:l,idDims:c}=GS(r,i.length);HS(o.length,c,i);const{path:h,steps:d}=qS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=WS(y,c[w]);let k;KS(S)?k=i[w]:(k=us({inputs:{x:i[w]},backend:e,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);we(k.shape,$)||(k=Tt({inputs:{x:k},backend:e,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=OC({inputs:{a:k,b:m},backend:e}),b.push(m))}x<p-1&&(h[x]>=0&&(m=L0({inputs:{x:m},backend:e,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&e.disposeIntermediateTensorInfo(x);return m}const Rdt={kernelName:S1,backendName:"webgl",kernelFunc:_dt};const Ddt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Odt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Mdt=fe({opSnippet:Ddt,packedOpSnippet:Odt}),Fdt={kernelName:md,backendName:"webgl",kernelFunc:Mdt};const Ldt="return (b >= 0.0) ? a : a * (b + 1.0);",Pdt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,zdt=n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,i=lt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new au(Pdt,s.shape,r.shape):new cl(Ldt,s.shape,r.shape);return e.runWebGLProgram(i,[s,r],s.dtype)},Bdt={kernelName:C1,backendName:"webgl",kernelFunc:zdt};const Vdt=`
  return vec4(equal(a, b));
`,Udt="return float(a == b);",jdt=Vn({opSnippet:Udt,packedOpSnippet:Vdt,dtype:"bool",cpuKernelImpl:wlt}),Gdt={kernelName:$g,backendName:"webgl",kernelFunc:jdt};const Wdt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${LS};
  float a1 = ${PS};
  float a2 = ${zS};
  float a3 = ${BS};
  float a4 = ${VS};
  float a5 = ${US};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Hdt=fe({opSnippet:Wdt}),qdt={kernelName:gd,backendName:"webgl",kernelFunc:Hdt};const Kdt=lu+`
  return exp(x);
`,Xdt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YL=fe({opSnippet:Kdt,packedOpSnippet:Xdt,cpuKernelImpl:Slt,dtype:"float32"}),Ydt={kernelName:yd,backendName:"webgl",kernelFunc:YL};function uw(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:i}=t,o=i.shape.length,l=i.shape.slice();let c=r;return r<0&&(L(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+r+1),l.splice(c,0,1),Tt({inputs:{x:i},backend:s,attrs:{shape:l}})}const Zdt={kernelName:Eg,backendName:"webgl",kernelFunc:uw};const mA="return exp(x) - 1.0;",Jdt=fe({opSnippet:mA,packedOpSnippet:mA,cpuKernelImpl:Clt}),Qdt={kernelName:bd,backendName:"webgl",kernelFunc:Jdt};class gA{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let l;if(t==="real")l="return real * expR - imag * expI;";else if(t==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function ZL(n,t,e){const s=e.texData.get(n.dataId),r=ft(n.shape),i=n.shape[n.shape.length-1],o=r/i,l=Tt({inputs:{x:n},backend:e,attrs:{shape:[o,i]}}),c=l.shape,h=new gA("real",c,t),d=new gA("imag",c,t),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],m=e.runWebGLProgram(h,p,"float32"),y=e.runWebGLProgram(d,p,"float32"),b=ra({inputs:{real:m,imag:y},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y);const x=Tt({inputs:{x:b},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(b),x}function tft(n){const{inputs:t,backend:e}=n,{input:s}=t;return ZL(s,!1,e)}const eft={kernelName:T1,backendName:"webgl",kernelFunc:tft};class nft{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function wf(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:i}=e;if(i=i||Kc(r),i==="string"){const o=nn(i,ft(s));return o.fill(r),t.makeTensorInfo(s,i,o)}else{const o=new nft(s,r),l=[[r]];return t.runWebGLProgram(o,[],i,l)}}const sft={kernelName:k1,backendName:"webgl",kernelFunc:wf};class rft{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const ift={kernelName:$1,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new rft(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}};const yA="return floor(x);",oft=fe({opSnippet:yA,packedOpSnippet:yA,cpuKernelImpl:Tlt}),aft={kernelName:xd,backendName:"webgl",kernelFunc:oft};const lft=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,cft=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,uft=Vn({opSnippet:lft,packedOpSnippet:cft,dtype:"int32"}),hft={kernelName:vd,backendName:"webgl",kernelFunc:uft};class dft{constructor(t){this.variableNames=["A"];const e=ds(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class fft{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=ds(),[s,r]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const pft={kernelName:s6,backendName:"webgl",kernelFunc:mft};let dc,Kx=lt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function mft(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:i}=s,o=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[c,h]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,c],p=[h,c,i];if(l||o){const x=lt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(dc==null||x!==Kx)&&(Kx=x,dc=document.createElement("canvas").getContext("2d",{willReadFrequently:Kx})),dc.canvas.width=c,dc.canvas.height=h,dc.drawImage(r,0,0,c,h),r=dc.canvas}const m=e.makeTensorInfo(d,"int32");e.texData.get(m.dataId).usage=tr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),r);const y=lt().getBool("WEBGL_PACK")?new fft(p):new dft(p),b=e.runWebGLProgram(y,[m],"int32");return e.disposeData(m.dataId),b}function gft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=eo(d),w=zn(r.shape,i.shape,c,p,h,m,!1,x);let S;const T=[],k=o!=null,$=l!=null,E=y==="leakyrelu",N=()=>{const R=[r,i],D=(M,A)=>{if(A==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const B=Tt({inputs:{x:M},backend:e,attrs:{shape:[M.shape[0],1,1]}});return T.push(B),B}return M};if(k&&R.push(D(o,d)),$&&R.push(D(l,d)),E){const M=e.makeTensorInfo([],"float32",Xo(b,"float32"));R.push(M),T.push(M)}return R};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=WL({x:r,filter:i,convInfo:w,backend:e,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&lt().getBool("WEBGL_EXP_CONV")){const R=y?qh(y,!0):null,D=new GL(w,k,R,$,E),M=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=N();S=e.runWebGLProgram(D,A,"float32",M)}else if(lt().getBool("WEBGL_CONV_IM2COL"))S=HL({x:r,filter:i,convInfo:w,backend:e,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else{const R=y?qh(y,!1):null,D=new jL(w,k,R,$,E),M=N();S=e.runWebGLProgram(D,M,"float32")}const _=Tt({inputs:{x:S},backend:e,attrs:{shape:w.outShape}});return T.push(S),T.forEach(R=>e.disposeIntermediateTensorInfo(R)),_}const yft={kernelName:Nm,backendName:"webgl",kernelFunc:gft};function bft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),L(Qn(c,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${x}'`);const w=zn(r.shape,i.shape,c,x,h,p,!0),S=lt().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,T=m?qh(m,S):null,k=[r,i],$=o!=null,E=l!=null,N=m==="leakyrelu";if($&&k.push(o),E&&k.push(l),N){const M=e.makeTensorInfo([],"float32",Xo(y,"float32"));k.push(M),b.push(M)}let _;S?_=new XL(w,$,T,E,N):_=new KL(w,$,T,E,N);const R=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],D=e.runWebGLProgram(_,k,"float32",R);return b.forEach(M=>e.disposeIntermediateTensorInfo(M)),D}const xft={kernelName:QR,backendName:"webgl",kernelFunc:bft};class vft{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const i=Ie(s.length);let o=`
    int index;`;for(let l=0;l<this.sliceDim;l++)o+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function wft(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,i=r.shape,o=i[i.length-1],l=ft(s.shape),[c,h,d,p]=$S(s,r),m=Tt({inputs:{x:r},backend:e,attrs:{shape:[h,o]}}),y=Tt({inputs:{x:s},backend:e,attrs:{shape:[ft(s.shape)/d,d]}});if(e.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const S=e.readSync(r.dataId),T=e.bufferSync(s),k=klt(S,T,s.dtype,h,o,d,p,s.shape,l);return e.makeTensorInfo(c,s.dtype,k.values)}const b=new vft(o,p,[h,d],s.shape),x=e.runWebGLProgram(b,[y,m],y.dtype),w=Tt({inputs:{x},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),w}const Sft={kernelName:MR,backendName:"webgl",kernelFunc:wft};class Cft{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=Ie(this.rank),r=Tft(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function Tft(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${e[r]}`);return s.join()}function JL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:i}=t,{axis:o,batchDims:l}=s,c=ee(o,r.shape)[0];if(lt().get("DEBUG")){const T=e.readSync(i.dataId),k=r.shape[c];for(let $=0;$<T.length;++$){const E=T[$];L(E<=k-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${k-1}]`)}}const h=YS(r,i,c,l),d=ft(i.shape),p=[],m=Tt({inputs:{x:r},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=Tt({inputs:{x:i},backend:e,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(m),p.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const T=e.bufferSync(y),k=e.bufferSync(m),$=$lt(k,T,b);return p.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.makeTensorInfo(h.outputShape,$.dtype,$.values)}const x=new Cft(m.shape,b),w=e.runWebGLProgram(x,[m,y],m.dtype);p.push(w);const S=Tt({inputs:{x:w},backend:e,attrs:{shape:h.outputShape}});return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),S}const kft={kernelName:Ng,backendName:"webgl",kernelFunc:JL};const $ft="return float(a > b);",Eft=`
  return vec4(greaterThan(a, b));
`,Ift=Vn({opSnippet:$ft,packedOpSnippet:Eft,cpuKernelImpl:Elt,dtype:"bool"}),Nft={kernelName:Ag,backendName:"webgl",kernelFunc:Ift};const Aft="return float(a >= b);",_ft=`
  return vec4(greaterThanEqual(a, b));
`,Rft=Vn({opSnippet:Aft,packedOpSnippet:_ft,dtype:"bool",cpuKernelImpl:Ilt}),Dft={kernelName:wd,backendName:"webgl",kernelFunc:Rft};function Oft(n){const{inputs:t,backend:e}=n,{input:s}=t;return ZL(s,!0,e)}const Mft={kernelName:E1,backendName:"webgl",kernelFunc:Oft};const Fft="return float(!isnan(x) && !isinf(x));",Lft=fe({opSnippet:Fft,dtype:"bool"}),Pft={kernelName:Cd,backendName:"webgl",kernelFunc:Lft};const zft="return float(isinf(x));",Bft=fe({opSnippet:zft,dtype:"bool"}),Vft={kernelName:Td,backendName:"webgl",kernelFunc:Bft};const Uft="return float(isnan(x));",jft=fe({opSnippet:Uft,dtype:"bool"}),Gft={kernelName:kd,backendName:"webgl",kernelFunc:jft};const Wft="return float(a < b);",Hft=`
  return vec4(lessThan(a, b));
`,qft=Vn({opSnippet:Wft,packedOpSnippet:Hft,cpuKernelImpl:Nlt,dtype:"bool"}),Kft={kernelName:Rg,backendName:"webgl",kernelFunc:qft};const Xft="return float(a <= b);",Yft=`
  return vec4(lessThanEqual(a, b));
`,Zft=Vn({opSnippet:Xft,packedOpSnippet:Yft,cpuKernelImpl:Alt,dtype:"bool"}),Jft={kernelName:Dg,backendName:"webgl",kernelFunc:Zft};function Qft(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:i}=e,o=_lt(s,r,i);return t.makeTensorInfo([o.length],"float32",o)}const tpt={kernelName:FR,backendName:"webgl",kernelFunc:Qft};const ept=lu+`
  return x < 0.0 ? 0./0. : log(x);
`,npt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,spt=fe({opSnippet:ept,packedOpSnippet:npt,cpuKernelImpl:Rlt}),rpt={kernelName:$d,backendName:"webgl",kernelFunc:spt};const ipt=lu+`
  return log(1.0 + x);
`,opt=fe({opSnippet:ipt}),apt={kernelName:Ed,backendName:"webgl",kernelFunc:opt};const lpt="return float(a >= 1.0 && b >= 1.0);",cpt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,upt=Vn({opSnippet:lpt,packedOpSnippet:cpt,dtype:"bool"}),hpt={kernelName:Og,backendName:"webgl",kernelFunc:upt};const dpt="return float(!(x >= 1.0));",fpt=fe({opSnippet:dpt}),ppt={kernelName:Mg,backendName:"webgl",kernelFunc:fpt};const mpt="return float(a >= 1.0 || b >= 1.0);",gpt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ypt=Vn({opSnippet:mpt,packedOpSnippet:gpt,dtype:"bool"}),bpt={kernelName:Fg,backendName:"webgl",kernelFunc:ypt};class xpt{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=e,l=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}class vpt{constructor(t,e,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,l=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${r}) * sum`;i===.5?c=`inversesqrt(${h})`:i===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}const wpt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:i,bias:o,alpha:l,beta:c}=s,h=lt().getBool("WEBGL_PACK_NORMALIZATION")?new vpt(r.shape,i,o,l,c):new xpt(r.shape,i,o,l,c);return e.runWebGLProgram(h,[r],r.dtype)},Spt={kernelName:Lg,backendName:"webgl",kernelFunc:wpt};class Cpt{constructor(t,e,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const Tpt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:i,dy:o}=t,{depthRadius:l,bias:c,alpha:h,beta:d}=s,p=new Cpt(r.shape,l,c,h,d);return e.runWebGLProgram(p,[r,i,o],r.dtype)},kpt={kernelName:N1,backendName:"webgl",kernelFunc:Tpt};function $pt(n,t,e,s){const r=ft(t),o=ft(n.shape)/r,l=Tt({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=xl(l,n.dtype,"max",s),h=Tt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}function QL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:i,keepDims:o}=s,l=r.shape.length,c=ee(i,r.shape);let h=c;const d=Xe(h,l),p=d!=null,m=e.shouldExecuteOnCPU([r]);let y=r;if(p){if(m){const k=e.texData.get(y.dataId).values,$=new Array(l);for(let _=0;_<$.length;_++)$[_]=r.shape[d[_]];const E=RC(k,r.shape,r.dtype,d,$);y=e.makeTensorInfo($,r.dtype);const N=e.texData.get(y.dataId);N.values=E}else y=F0(r,d,e);h=on(h.length,l)}Bn("max",h,l);const[b,x]=Dn(y.shape,h);let w=b;o&&(w=dn(b,c));let S;if(m){const k=e.texData.get(y.dataId).values,$=Dlt(k,ft(x),w,r.dtype);S=e.makeTensorInfo(w,r.dtype);const E=e.texData.get(S.dataId);E.values=$}else S=$pt(y,x,w,e);return p&&e.disposeIntermediateTensorInfo(y),S}const Ept={kernelName:Pg,backendName:"webgl",kernelFunc:QL};const Ipt=DC+`
  return max(a, b);
`,Npt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+bl+`
  return result;
`,Apt=Vn({opSnippet:Ipt,packedOpSnippet:Npt,cpuKernelImpl:Olt}),_pt={kernelName:Id,backendName:"webgl",kernelFunc:Apt};function Rpt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;bf(r,"maxPool");const{filterSize:i,strides:o,pad:l,dimRoundingMode:c}=s,h=1;L(Qn(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Er(r.shape,i,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&we(d.inShape,d.outShape))return zs({inputs:{x:r},backend:e});const p=new Kh(d,"max",!1);return e.runWebGLProgram(p,[r],r.dtype)}const Dpt={kernelName:zg,backendName:"webgl",kernelFunc:Rpt};function Opt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:i,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=[1,1,1],p=to(r.shape,i,o,d,l,h,c),m=new MC(p,"max",!1);return e.runWebGLProgram(m,[r],r.dtype)}const Mpt={kernelName:Bg,backendName:"webgl",kernelFunc:Opt};class Fpt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,r=t.dilationHeight,i=t.effectiveFilterHeight,o=t.effectiveFilterWidth,l=i-1-t.padInfo.top,c=o-1-t.padInfo.left,h=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Lpt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,r=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,m=h-1-t.padInfo.top,y=d-1-t.padInfo.left,b=c*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Ppt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i}=t,o=i,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=to(o.shape,l,c,p,h,d),y=new MC(m,"max",!0),b=e.runWebGLProgram(y,[o],o.dtype),x=new Lpt(m),w=e.runWebGLProgram(x,[r,b],o.dtype);return e.disposeIntermediateTensorInfo(b),w}const zpt={kernelName:_1,backendName:"webgl",kernelFunc:Ppt};function Bpt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:i,output:o}=t,l=i;bf([i,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=Er(l.shape,c,h,1,d,p),y=!0,b=new Kh(m,"max",y),x=e.runWebGLProgram(b,[l],l.dtype),w=new Fpt(m),S=e.runWebGLProgram(w,[r,x],l.dtype);return e.disposeIntermediateTensorInfo(x),S}const Vpt={kernelName:A1,backendName:"webgl",kernelFunc:Bpt};function Upt(n,t,e,s){let r=new Kh(e,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new Kh(e,"max",!0,!0,t);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}const jpt={kernelName:LR,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:l}=t,c=e;L(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];L(Qn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Er(s.shape,r,i,h,o),[p,m]=Upt(s,l,d,c);return[p,m]}};function Gpt(n,t,e,s){const r=ft(t),o=ft(n.shape)/r,l=Tt({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=xl(l,"float32","mean",s),h=Tt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}const Wpt={kernelName:Vg,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:i}=t,o=e,l=s.shape.length,c=ee(i,s.shape);let h=c;const d=Xe(h,l),p=d!=null,m=o.shouldExecuteOnCPU([s]),y=[];let b=s;if(p){if(m){const $=o.texData.get(b.dataId).values,E=new Array(l);for(let R=0;R<E.length;R++)E[R]=s.shape[d[R]];const N=RC($,s.shape,s.dtype,d,E);b=o.makeTensorInfo(E,s.dtype);const _=o.texData.get(b.dataId);_.values=N}else b=F0(s,d,o);y.push(b),h=on(h.length,l)}Bn("sum",h,l);const[x,w]=Dn(b.shape,h);let S=x;r&&(S=dn(x,c));const T=Gpt(b,w,S,o);for(const k of y)o.disposeIntermediateTensorInfo(k);return T}};function Hpt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=ee(i,r.shape);let h=c;const d=Xe(h,l);let p=r;d!=null&&(p=us({inputs:{x:r},backend:e,attrs:{perm:d}}),h=on(h.length,r.shape.length)),Bn("min",h,l);const[m,y]=Dn(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=xl(x,x.dtype,"min",e);let S;if(o){const T=dn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const qpt={kernelName:Ug,backendName:"webgl",kernelFunc:Hpt};const Kpt=DC+`
  return min(a, b);
`,Xpt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+bl+`
  return result;
`,Ypt=Vn({opSnippet:Kpt,packedOpSnippet:Xpt,cpuKernelImpl:Mlt}),Zpt={kernelName:Nd,backendName:"webgl",kernelFunc:Ypt};class Jpt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((d,p)=>d[0]+t[p]+d[1]);const r=t.length,i=Ie(r),o=e.map(d=>d[0]).join(","),l=e.map((d,p)=>d[0]+t[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}class Qpt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((b,x)=>b[0]+t[x]+b[1]);const r=t.length,i=Ie(r),o=e.map(b=>b[0]).join(","),l=e.map((b,x)=>b[0]+t[x]).join(","),c=as("rc",r),h=as("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${i} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${c[r-2]} += 1;
        if(${c[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${c[r-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const tmt=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:i}=e,o=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qpt(s.shape,r,i):new Jpt(s.shape,r,i);return t.runWebGLProgram(o,[s],s.dtype)},emt={kernelName:jg,backendName:"webgl",kernelFunc:tmt};const nmt=`if (b == 0.0) return NAN;
  return mod(a, b);`,smt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+bl+`
  return result;
`,rmt=Vn({opSnippet:nmt,packedOpSnippet:smt}),imt={kernelName:Ad,backendName:"webgl",kernelFunc:rmt};class omt{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const amt=`
if (a == b) {
  return 1.0;
};
return a / b;`,lmt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,tP=Vn({opSnippet:amt,packedOpSnippet:lmt,checkOutOfBounds:!0}),cmt={kernelName:pd,backendName:"webgl",kernelFunc:tP};const bA="return a - b;",eP=Vn({opSnippet:bA,packedOpSnippet:bA,supportsComplex:!0,cpuKernelImpl:nct}),umt={kernelName:Hd,backendName:"webgl",kernelFunc:eP};function nP(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:i}=s,o=ee([i],r.shape),l=QL({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),c=dn(l.shape,o),h=Tt({inputs:{x:l},backend:e,attrs:{shape:c}}),d=eP({inputs:{a:r,b:h},backend:e}),p=YL({inputs:{x:d},backend:e}),m=L0({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:!1}}),y=Tt({inputs:{x:m},backend:e,attrs:{shape:c}}),b=tP({inputs:{a:p,b:y},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}const hmt={kernelName:a0,backendName:"webgl",kernelFunc:nP};function dmt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:i,seed:o,normalized:l}=s,c=l?r:nP({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),h=c.shape[0],d=c.shape[1],p=new omt(h,d,i),m=[[o]],y=e.runWebGLProgram(p,[c],"int32",m);return l||e.disposeIntermediateTensorInfo(c),y}const fmt={kernelName:PR,backendName:"webgl",kernelFunc:dmt};const pmt=Nr+`
  return -x;
`,mmt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function gmt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId),[o,l]=Llt(i.values,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,o)}let r;return lt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Oo(s.shape,mmt):r=new ci(s.shape,pmt),e.runWebGLProgram(r,[s],s.dtype)}const ymt={kernelName:Gg,backendName:"webgl",kernelFunc:gmt};const bmt=vS;function xmt(n){Qs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),{selectedIndices:p}=bmt(h,d,o,l,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const vmt={kernelName:R1,backendName:"webgl",kernelFunc:xmt};const wmt=wS;function Smt(n){Qs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s,d=e.readSync(r.dataId),p=e.readSync(i.dataId),{selectedIndices:m,validOutputs:y}=wmt(d,p,o,l,c,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const Cmt={kernelName:D1,backendName:"webgl",kernelFunc:Smt};const Tmt=SS;function kmt(n){Qs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:i}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s,d=e.readSync(r.dataId),p=e.readSync(i.dataId),m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=Tmt(d,p,m,y,b,x);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const $mt={kernelName:O1,backendName:"webgl",kernelFunc:kmt};class Emt{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const Imt=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:i,depth:o,onValue:l,offValue:c}=s,h=ft(r.shape),d=new Emt(h,o,l,c),p=Tt({inputs:{x:r},backend:e,attrs:{shape:[h]}}),m=e.runWebGLProgram(d,[p],i);e.disposeIntermediateTensorInfo(p);const y=[...r.shape,o],b=Tt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),b},Nmt={kernelName:qg,backendName:"webgl",kernelFunc:Imt};function ng(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const r=vf({inputs:{input:s},backend:e}),i=ng({inputs:{x:r},backend:e}),o=P0({inputs:{input:s},backend:e}),l=ng({inputs:{x:o},backend:e}),c=ra({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return wf({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const Amt={kernelName:u0,backendName:"webgl",kernelFunc:ng};function sP(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=vf({inputs:{input:s},backend:e}),i=sP({inputs:{x:r},backend:e}),o=P0({inputs:{input:s},backend:e}),l=ng({inputs:{x:o},backend:e}),c=ra({inputs:{real:i,imag:l},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return wf({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const _mt={kernelName:Hg,backendName:"webgl",kernelFunc:sP};function Rmt(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(t.length===1)return uw({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const i=t[0].shape,o=t[0].dtype;t.forEach(d=>{t1(i,d.shape,"All tensors passed to stack must have matching shapes"),L(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=t.map(d=>{const p=uw({inputs:{input:d},backend:e,attrs:{dim:r}});return l.push(p),p}),h=UL({inputs:c,backend:e,attrs:{axis:r}});return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const Dmt={kernelName:Kg,backendName:"webgl",kernelFunc:Rmt};class Omt{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,d)=>h[0]+t[d]+h[1]);const r=t.length,i=Ie(r),o=e.map(h=>h[0]).join(","),l=e.map((h,d)=>h[0]+t[d]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${l});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}class Mmt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((x,w)=>x[0]+t[w]+x[1]);const r=t.length,i=Ie(r),o=e.map(x=>x[0]).join(","),l=e.map((x,w)=>x[0]+t[w]).join(","),c=as("rc",r),h=as("source",r),d=`${c[r-1]} < ${this.outputShape[r-1]}`,p=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${i} rc = outputLoc;`,`${c[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${c[r-2]} += 1;
       if(${c[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${c[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=r===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${l});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const rP=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:i,constantValue:o}=s;if(ft(r.shape)===0){const h=i.map((d,p)=>d[0]+r.shape[p]+d[1]);return wf({backend:e,attrs:{shape:h,value:o,dtype:r.dtype}})}const l=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mmt(r.shape,i,o):new Omt(r.shape,i,o),c=[[o]];return e.runWebGLProgram(l,[r],r.dtype,c)},Fmt={kernelName:Xg,backendName:"webgl",kernelFunc:rP};const Lmt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Pmt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+bl+`
  return result;
`,zmt=Vn({opSnippet:Lmt,packedOpSnippet:Pmt}),Bmt={kernelName:Rd,backendName:"webgl",kernelFunc:zmt};function Vmt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:i,keepDims:o}=s,l=r.shape.length,c=[],h=ee(i,r.shape);let d=h;const p=Xe(d,l);let m=r;p!=null&&(m=us({inputs:{x:r},backend:e,attrs:{perm:p}}),d=on(d.length,l),c.push(m)),Bn("prod",d,l);let y;if(e.shouldExecuteOnCPU([m])){const b=e.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:S}=zlt(m.shape,m.dtype,b,d);y=e.makeTensorInfo(w,S,x)}else{const[b,x]=Dn(m.shape,d),w=ft(x),S=Tt({inputs:{x:m},backend:e,attrs:{shape:[-1,w]}}),T=H1(r.dtype),k=xl(S,T,"prod",e);y=Tt({inputs:{x:k},backend:e,attrs:{shape:b}}),c.push(S),c.push(k)}if(o){c.push(y);const b=dn(y.shape,h);y=Tt({inputs:{x:y},backend:e,attrs:{shape:b}})}return c.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const Umt={kernelName:Zg,backendName:"webgl",kernelFunc:Vmt};function jmt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:l}=s,c=r.map(S=>e.readSync(S.dataId)),h=r.map(S=>S.shape),d=e.readSync(i.dataId),p=e.readSync(o.dataId),[m,y,b]=Blt(c,h,d,i.shape,i.dtype,p,o.shape,l),x=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),w=e.makeTensorInfo(b,i.dtype,y);return x.concat([w])}const Gmt={kernelName:zR,backendName:"webgl",kernelFunc:jmt};function Wmt(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:i}=t,o=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),[h,d]=Vlt(o,s.shape,s.dtype,l,r.shape,c,i.shape),p=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const Hmt={kernelName:BR,backendName:"webgl",kernelFunc:Wmt};function qmt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:i,defaultValue:o,rowPartitionTensors:l}=t,{rowPartitionTypes:c}=s,h=e.readSync(r.dataId),d=e.readSync(i.dataId),p=e.readSync(o.dataId),m=l.map(w=>e.readSync(w.dataId)),y=l.map(w=>w.shape),[b,x]=Ult(h,r.shape,d,i.shape,i.dtype,p,o.shape,m,y,c);return e.makeTensorInfo(b,i.dtype,x)}const Kmt={kernelName:VR,backendName:"webgl",kernelFunc:qmt};const iP=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:i,dtype:o}=e,l=jlt(s,r,i,o);return t.makeTensorInfo([l.length],o,l)},Xmt={kernelName:M1,backendName:"webgl",kernelFunc:iP};const Ymt="return 1.0 / x;",Zmt=fe({opSnippet:Ymt}),Jmt={kernelName:Dd,backendName:"webgl",kernelFunc:Zmt};const Qmt=Nr+`
  return (x < 0.0) ? 0.0 : x;
`,tgt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,egt=fe({opSnippet:Qmt,packedOpSnippet:tgt}),ngt={kernelName:Od,backendName:"webgl",kernelFunc:egt};const sgt=Nr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,rgt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,igt=fe({opSnippet:sgt,packedOpSnippet:rgt}),ogt={kernelName:Md,backendName:"webgl",kernelFunc:igt};class agt{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class lgt{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let m;i?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function cgt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s,[c,h]=l,d=lt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new lgt(r.shape,c,h,i,o):new agt(r.shape,c,h,i,o);return e.runWebGLProgram(d,[r],"float32")}const ugt={kernelName:t0,backendName:"webgl",kernelFunc:cgt};class hgt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,l]=t,c=[s&&o>1?r-1:r,s&&l>1?i-1:i],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function dgt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,l=new hgt(i.shape,r.shape,o);return e.runWebGLProgram(l,[i],i.dtype)}const fgt={kernelName:P1,backendName:"webgl",kernelFunc:dgt};class pgt{constructor(t,e,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class mgt{constructor(t,e,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[r&&e>1?l-1:l,r&&s>1?c-1:c],p=[r&&e>1?e-1:e,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;i?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function ggt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:i,halfPixelCenters:o,size:l}=s,[c,h]=l,d=lt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mgt(r.shape,c,h,i,o):new pgt(r.shape,c,h,i,o);return e.runWebGLProgram(d,[r],r.dtype)}const ygt={kernelName:Qg,backendName:"webgl",kernelFunc:ggt};class bgt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,i]=e,[,o,l]=t,c=[s&&o>1?r-1:r,s&&l>1?i-1:i],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function xgt(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:i}=t,{alignCorners:o}=s,l=new bgt(i.shape,r.shape,o);return e.runWebGLProgram(l,[i],i.dtype)}const vgt={kernelName:L1,backendName:"webgl",kernelFunc:xgt};class wgt{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const r=l=>e.indexOf(l)!==-1&&t[l]!==1?`${t[l]} - coords[${l}] - 1`:`coords[${l}]`,i=t.map((l,c)=>r(c)).join(","),o=Ie(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}class Sgt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=as("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,l=Ie(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(r.slice())};
          if(${i}){
            result.g = ${h(r.slice())};
          }
          if(${o}) {
            result.b = ${d(r.slice())};
            if(${i}) {
              result.a = ${p(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=t.map((T,k)=>y(k,b)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function y(b,x){return e.indexOf(b)!==-1&&t[b]!==1?`${t[b]} - ${x[b]} - 1`:`${x[b]}`}}}function Cgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:i}=s,o=r.shape.length,l=ee(i,r.shape);if(o===0)return zs({inputs:{x:r},backend:e});const c=lt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sgt(r.shape,l):new wgt(r.shape,l);return e.runWebGLProgram(c,[r],r.dtype)}const Tgt={kernelName:e0,backendName:"webgl",kernelFunc:Cgt};class kgt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let i="";typeof e=="number"?i=`float outputValue = ${e.toFixed(2)};`:i=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const $gt={kernelName:W1,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=t,l=e,c=new kgt(s.shape,i),[h,d]=OS(o,s.shape[1],s.shape[2]),p=[[h,d,Math.sin(r),Math.cos(r)]];return l.runWebGLProgram(c,[s],s.dtype,p)}};const Egt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Igt=fe({opSnippet:Egt}),Ngt={kernelName:Fd,backendName:"webgl",kernelFunc:Igt};const Agt="return inversesqrt(x);",_gt=fe({opSnippet:Agt,cpuKernelImpl:Glt}),Rgt={kernelName:Ld,backendName:"webgl",kernelFunc:_gt};class FC{constructor(t,e,s,r,i,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const h=Ie(i.length),d=Ie(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=e>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class Dgt{constructor(t,e,s,r,i,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const h=Ie(i.length),d=Ie(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=e>1?"strides[j]":"strides",T=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${i});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function Ogt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:i}=t,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=fl(i,r,o),m=[p/h,h];if(p===0)return e.makeTensorInfo(o,r.dtype);const y=Tt({inputs:{x:r},backend:e,attrs:{shape:[c,l]}}),b=Tt({inputs:{x:i},backend:e,attrs:{shape:[c,h]}}),x=e.makeTensorInfo([],"float32",new Float32Array([0]));let w;lt().getBool("WEBGL_PACK")?w=new Dgt(c,l,y.shape.length,b.shape.length,d,m):w=new FC(c,l,y.shape.length,b.shape.length,d,m);const S=e.runWebGLProgram(w,[b,y,x],b.dtype),T=Tt({inputs:{x:S},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(x),T}const Mgt={kernelName:UR,backendName:"webgl",kernelFunc:Ogt};class Fgt{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,l=lt().getNumber("WEBGL_VERSION")===2?i:o,c=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function Lgt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:i}=t,{side:o}=s,l=new Fgt(r.shape[0],r.shape[1],i.shape[1],o),c=[[r.shape[1]]];return e.runWebGLProgram(l,[r,i],"int32",c)}const Pgt={kernelName:GR,backendName:"webgl",kernelFunc:Lgt};class zgt{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],h=[];for(let d=0;d<e.length;d++)h.push(`${l[d]}`),d<t&&c.push(`${l[d]}`);r=c.join(),i=h.join()}const o=Ie(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}function Bgt(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:i}=t,o=new zgt(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[s,r,i],Ls(r.dtype,i.dtype))}const Vgt={kernelName:n0,backendName:"webgl",kernelFunc:Bgt};const Ugt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${v0};
  float scale = ${w0};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,jgt=fe({opSnippet:Ugt}),Ggt={kernelName:Pd,backendName:"webgl",kernelFunc:jgt};const Wgt=lu+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Hgt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qgt=fe({opSnippet:Wgt,packedOpSnippet:Hgt,cpuKernelImpl:Hlt}),Kgt={kernelName:Ud,backendName:"webgl",kernelFunc:qgt};const Xgt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ygt=fe({opSnippet:Xgt}),Zgt={kernelName:Vd,backendName:"webgl",kernelFunc:Ygt};const Jgt=lu+`
  return sin(x);
`,Qgt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${bl}
  return result;
`,t0t=fe({opSnippet:Jgt,packedOpSnippet:Qgt}),e0t={kernelName:zd,backendName:"webgl",kernelFunc:t0t};const n0t=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,s0t=fe({opSnippet:n0t}),r0t={kernelName:Bd,backendName:"webgl",kernelFunc:s0t};const i0t=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,o0t=fe({opSnippet:i0t}),a0t={kernelName:jd,backendName:"webgl",kernelFunc:o0t};const l0t=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:i,paddings:o}=s;L(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=i.reduce((S,T)=>S*T),c=[[0,0]];c.push(...o);for(let S=1+i.length;S<r.shape.length;++S)c.push([0,0]);const h=[],d=rP({inputs:{x:r},backend:e,attrs:{paddings:c,constantValue:0}}),p=rf(d.shape,i,l,!1),m=of(p.length,i.length,!1),y=af(d.shape,i,l,!1),b=Tt({inputs:{x:d},backend:e,attrs:{shape:p}}),x=us({inputs:{x:b},backend:e,attrs:{perm:m}}),w=Tt({inputs:{x},backend:e,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(S=>e.disposeIntermediateTensorInfo(S)),w},c0t={kernelName:i0,backendName:"webgl",kernelFunc:l0t};function u0t(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=t;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=e.readSync(s.dataId),c=e.readSync(r.dataId),h=e.readSync(i.dataId),d=e.readSync(o.dataId)[0],[p,m,y,b,x]=Klt(l,s.shape,s.dtype,c,r.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,p),e.makeTensorInfo([m[0]],r.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),e.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const h0t={kernelName:WR,backendName:"webgl",kernelFunc:u0t};function d0t(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:i}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(r.dataId)),l=e.readSync(s.dataId),c=Array.from(e.readSync(i.dataId)),[h,d,p]=Xlt(l,s.shape,s.dtype,o,c);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const f0t={kernelName:HR,backendName:"webgl",kernelFunc:d0t};function p0t(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),[h,d]=NL(o,s.shape,s.dtype,l,c,!0);return e.makeTensorInfo(d,s.dtype,h)}const m0t={kernelName:qR,backendName:"webgl",kernelFunc:p0t};function g0t(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=e.readSync(s.dataId),l=e.readSync(r.dataId),c=e.readSync(i.dataId),[h,d]=NL(o,s.shape,s.dtype,l,c);return e.makeTensorInfo(d,s.dtype,h)}const y0t={kernelName:KR,backendName:"webgl",kernelFunc:g0t};function b0t(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=fl(i,r,l),y=!1;if(i.dtype==="string"){const S=e.bufferSync(r),T=e.bufferSync(i),k=Vo(e.readSync(o.dataId)[0]),$=Wlt(S,T,l,m,d,h,c,p,k,y);return e.makeTensorInfo(l,$.dtype,$.values)}const b=new FC(h,c,r.shape.length,i.shape.length,p,[m,1],y),x=e.runWebGLProgram(b,[i,r,o],i.dtype),w=Tt({inputs:{x},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(x),w}const x0t={kernelName:XR,backendName:"webgl",kernelFunc:b0t};function v0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:i,axis:o}=s,l=ee(o,r.shape)[0],c=XS(r,i,l),h=r.shape.length,d=new Array(h).fill(0),p=r.shape.slice();return c.map(m=>{const y=[...p];y[l]=m;const b=cu({inputs:{x:r},backend:e,attrs:{begin:d,size:y}});return d[l]+=m,b})}const w0t={kernelName:o0,backendName:"webgl",kernelFunc:v0t};const xA="return sqrt(x);",S0t=fe({opSnippet:xA,packedOpSnippet:xA,cpuKernelImpl:Ylt}),C0t={kernelName:Gd,backendName:"webgl",kernelFunc:S0t};const T0t="return x * x;",k0t=fe({opSnippet:T0t}),$0t={kernelName:z1,backendName:"webgl",kernelFunc:k0t};const vA="return (a - b) * (a - b);",E0t=Vn({opSnippet:vA,packedOpSnippet:vA}),I0t={kernelName:Wd,backendName:"webgl",kernelFunc:E0t};function N0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const i=e.readSync(r.dataId),o=Zi(i),l=Zlt(o,"string",s);return e.makeTensorInfo(r.shape,"string",l)}const A0t={kernelName:B1,backendName:"webgl",kernelFunc:N0t};function _0t({inputs:n,attrs:t,backend:e}){const{x:s}=n,r=Nr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new ci(s.shape,r);return e.runWebGLProgram(i,[s],s.dtype)}const R0t={kernelName:Yd,backendName:"webgl",kernelFunc:_0t};class D0t{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Ie(s.length),o=Ie(s.length);let l="";if(r===1)l="coords * strides + begin";else{let c=0;l=s.map((h,d)=>(c++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${c-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${t});
      ${i} strides = ${i}(${e});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}function O0t(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:i,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=_S(r.shape,i,o,l,c,h,d,p,m);let E;if(x)E=Tt({inputs:{x:r},backend:e,attrs:{shape:b}});else if(w||S){L(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const _=IS(T,k,$),R=cu({inputs:{x:r},backend:e,attrs:{begin:T,size:_}});E=Tt({inputs:{x:R},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(R)}else if(e.shouldExecuteOnCPU([r])){const R=e.readSync(r.dataId),D=te(r.shape,r.dtype,R),M=Jlt(y,D,$,T);E=e.makeTensorInfo(b,r.dtype,M.values)}else{const R=new D0t(T,$,y);E=e.runWebGLProgram(R,[r],r.dtype)}const N=Tt({inputs:{x:E},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(E),N}const M0t={kernelName:V1,backendName:"webgl",kernelFunc:O0t};function F0t(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=t,m=e.readSync(d.dataId),y=e.readSync(p.dataId),[b,x]=Qlt(m,y,r,i,o,l,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",x)]}const L0t={kernelName:YR,backendName:"webgl",kernelFunc:F0t};function P0t(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=e.readSync(i.dataId),c=e.readSync(o.dataId)[0],[h,d,p]=tct(l,c,r),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const z0t={kernelName:ZR,backendName:"webgl",kernelFunc:P0t};function B0t(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),l=ect(o,r);return e.makeTensorInfo(i.shape,"int32",l)}const V0t={kernelName:JR,backendName:"webgl",kernelFunc:B0t};const U0t="return tan(x);",j0t=fe({opSnippet:U0t}),G0t={kernelName:qd,backendName:"webgl",kernelFunc:j0t};const W0t=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,H0t=fe({opSnippet:W0t}),q0t={kernelName:Kd,backendName:"webgl",kernelFunc:H0t};function K0t(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:r,indices:i,updates:o}=t,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=fl(o,i,r.shape),m=[p/h,h];if(p===0)return e.makeTensorInfo(r.shape,i.dtype);const y=Tt({inputs:{x:i},backend:e,attrs:{shape:[c,l]}}),b=Tt({inputs:{x:o},backend:e,attrs:{shape:[c,h]}}),x=Tt({inputs:{x:r},backend:e,attrs:{shape:m}}),w=new FC(c,l,y.shape.length,b.shape.length,d,m,!1,!0),S=e.runWebGLProgram(w,[b,y,x],x.dtype),T=Tt({inputs:{x:S},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(S),T}const X0t={kernelName:jR,backendName:"webgl",kernelFunc:K0t};class Y0t{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*e[o];this.outputShape=s,this.rank=s.length;const r=Ie(this.rank),i=Z0t(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function Z0t(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}function oP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const c=e.readSync(r.dataId),h=r.dtype==="string"?c.map(m=>Vo(m)):c,d=te(r.shape,r.dtype,h),p=sct(d,i);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new Y0t(r.shape,i);return e.runWebGLProgram(o,[r],r.dtype)}const J0t={kernelName:Xd,backendName:"webgl",kernelFunc:oP};class Q0t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class tyt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Ia(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function wA(n){let t=1;for(;t<n;)t*=2;return t}function eyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:i,sorted:o}=s,l=lt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=lt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(e.shouldExecuteOnCPU([r])||d<l||i>c){const M=e.readSync(r.dataId),[A,B]=rct(M,h,r.dtype,i,o);return[e.makeTensorInfo(A.shape,A.dtype,A.values),e.makeTensorInfo(B.shape,B.dtype,B.values)]}if(i===0)return h[h.length-1]=0,[e.makeTensorInfo(h,r.dtype,[]),e.makeTensorInfo(h,"int32",[])];if(d===1)return[r,wf({attrs:{shape:h,dtype:"int32",value:0},backend:e})];const p=e.texData.get(r.dataId),m=p!==null&&p.isPacked,y=m?e.unpackTensor(r):r,x=ft(h)/d,w=Tt({inputs:{x:y},attrs:{shape:[x,d]},backend:e});m&&Ia(e,y);const S=wA(i),T=wA(d);let k=null;const $=()=>k===null?[w,w]:[w,k],E=(M,A,B)=>{const H=$(),W=new Q0t(B),P=[[d],[k===null?1:0],[Number.NEGATIVE_INFINITY],[M],[A]],U=k;k=e.runWebGLProgram(W,H,"int32",P),Ia(e,U)};for(let M=1;M<S;M*=2){const A=M*2;for(let B=M;B>=1;B/=2)E(A,B,[x,T])}for(let M=T;M>S;M/=2){const A=$(),B=new tyt([x,M/2]),W=[[d],[k===null?1:0],[S]],X=k;k=e.runWebGLProgram(B,A,"int32",W),Ia(e,X);const P=S/2,U=P*2;for(let G=P;G>=1;G/=2)E(U,G,k.shape)}let N=k;k=cu({inputs:{x:k},backend:e,attrs:{begin:0,size:[x,i]}}),Ia(e,N);let _=JL({inputs:{x:w,indices:k},backend:e,attrs:{axis:1,batchDims:1}});Ia(e,w);const R=h.slice(0,-1);R.push(i),N=k,k=Tt({inputs:{x:k},attrs:{shape:R},backend:e}),Ia(e,N);const D=_;return _=Tt({inputs:{x:_},attrs:{shape:R},backend:e}),Ia(e,D),[_,k]}const nyt={kernelName:U1,backendName:"webgl",kernelFunc:eyt};class syt{constructor(t,e,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const l=s==="nearest"?1:2;let c;switch(r){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function ryt(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:i}=t,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=s,[d,p,m,y]=r.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=new syt(p,m,o,l,c,w);return e.runWebGLProgram(S,[r,i],"float32")}const iyt={kernelName:j1,backendName:"webgl",kernelFunc:ryt};function oyt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:i}=t;bf(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:l,outputShape:c,indices:h}=ict(o,r,i.shape,i.dtype);return[s.makeTensorInfo(c,i.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const ayt={kernelName:G1,backendName:"webgl",kernelFunc:oyt};function lyt(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,l=o.shape.length,c=r.shape[i],h=new Array(l-1);let d=0;for(let x=0;x<l;x++)x!==i&&(h[d++]=o.shape[x]);const p=[],m=new Array(l).fill(0),y=o.shape.slice();y[i]=1;const b=new Array(c);for(let x=0;x<b.length;x++){m[i]=x;const w=cu({inputs:{x:o},backend:e,attrs:{begin:m,size:y}}),S=Tt({inputs:{x:w},backend:e,attrs:{shape:h}});b[x]=S,p.push(w)}return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const cyt={kernelName:l0,backendName:"webgl",kernelFunc:lyt};class uyt{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,i=t.inSize,o=t.numSegments,l=o*Math.ceil(i/s);this.outputShape=[r,l];const c="0.0",h="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";i%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let b="";i%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function hyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:i}=t,{numSegments:o}=s,l=r.shape.length,c=[];let h=0;const d=Xe([h],l);let p=r;d!=null&&(p=us({inputs:{x:r},backend:e,attrs:{perm:d}}),c.push(p),h=on(1,l)[0]);const m=VO(p.shape,h,o),y=ft([p.shape[h]]),b=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,y]}});c.push(b);const x=H1(r.dtype),w=($,E,N,_,R)=>{const D=$.shape[0],M=$.shape[1],A=BO(M,R),B={windowSize:A,inSize:M,batchSize:D,numSegments:R},H=new uyt(B,E),W=e.compileAndRun(H,[$,N],_);if(c.push(W),W.shape[1]===R)return W;const X=iP({backend:e,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),P=oP({inputs:{x:X},backend:e,attrs:{reps:[M/A]}});return c.push(X),c.push(P),w(W,E,P,_,R)},S=w(b,"unsortedSegmentSum",i,x,o),T=Tt({inputs:{x:S},backend:e,attrs:{shape:m}});let k=T;if(d!=null){c.push(T);const $=Jo(d);k=us({inputs:{x:k},backend:e,attrs:{perm:$}})}return c.forEach($=>e.disposeIntermediateTensorInfo($)),k}const dyt={kernelName:c0,backendName:"webgl",kernelFunc:hyt};const fyt=[Yct,Jct,eut,rut,out,cut,hut,fut,yut,xut,Sut,kut,Iut,Rut,Mut,Lut,zut,jut,Wut,qut,Zut,rht,oht,uht,dht,bht,vht,Tht,Dct,Eht,Rht,Fht,Uht,Wht,qht,Xht,Zht,edt,rdt,adt,cdt,hdt,fdt,gdt,bdt,Sdt,Tdt,Edt,Adt,Rdt,Fdt,Bdt,Gdt,qdt,Ydt,Zdt,Qdt,eft,sft,ift,aft,hft,pft,yft,xft,Sft,kft,Nft,Dft,Rct,Mft,Aht,Pft,Vft,Gft,Mct,Kft,Jft,tpt,rpt,apt,hpt,ppt,bpt,Spt,kpt,Ept,_pt,Dpt,Mpt,zpt,Vpt,jpt,Wpt,qpt,Zpt,emt,imt,fmt,Pct,ymt,vmt,Cmt,$mt,pht,Nmt,_mt,Dmt,Fmt,Bmt,Lct,Umt,Gmt,Hmt,Kmt,Xmt,mht,cmt,Jmt,ngt,ogt,Bct,ugt,fgt,ygt,vgt,Tgt,$gt,Ngt,Rgt,Mgt,Pgt,Vgt,Ggt,Kgt,Zgt,e0t,r0t,nht,hmt,a0t,c0t,h0t,f0t,m0t,y0t,x0t,w0t,C0t,$0t,I0t,A0t,R0t,M0t,L0t,z0t,V0t,umt,qct,G0t,q0t,X0t,J0t,nyt,iyt,Kct,ayt,cyt,dyt,Amt];for(const n of fyt)tD(n);const SA=(n,t)=>{if(!n||n.length<t+1)return[];const e=[];for(let s=t;s<n.length;s++){const r=(n[s]-n[s-t])/n[s-t];e.push(r*100)}return e},sg=(n,t,e=252)=>{if(!n||n.length<t+1)return[];const s=[];for(let i=1;i<n.length;i++)s.push((n[i]-n[i-1])/n[i-1]);const r=[];for(let i=t-1;i<s.length;i++){const o=s.slice(i-t+1,i+1),l=o.reduce((d,p)=>d+p,0)/t,c=o.reduce((d,p)=>d+Math.pow(p-l,2),0)/t,h=Math.sqrt(c)*Math.sqrt(e);r.push(h)}return r},pyt=(n,t=0,e=252)=>{if(!n||n.length===0)return 0;const s=n.map(l=>l-t/e),r=s.reduce((l,c)=>l+c,0)/n.length;if(n.length<2)return 0;const i=s.reduce((l,c)=>l+Math.pow(c-r,2),0)/n.length,o=Math.sqrt(i);return o===0?0:r/o*Math.sqrt(e)},myt=(n,t=0,e=252)=>{if(!n||n.length===0)return 0;const s=n.reduce((c,h)=>c+h,0)/n.length,r=t/e,o=n.map(c=>c<r?Math.pow(c-r,2):0).reduce((c,h)=>c+h,0)/n.length,l=Math.sqrt(o);return l===0?0:(s-r)/l*Math.sqrt(e)},gyt=n=>{if(!n||n.length<2)return 0;let t=n[0],e=0;for(let s=1;s<n.length;s++){n[s]>t&&(t=n[s]);const r=(t-n[s])/t;r>e&&(e=r)}return e*100},yyt=(n,t=7,e=21)=>{const s=sg(n,t),r=sg(n,e);if(s.length===0||r.length===0)return 1;const i=s[s.length-1],o=r[r.length-1];return o===0?1:i/o},byt=(n,t=1e-4,e=2e-4)=>{const s=t+e;return n.map(r=>Math.abs(r)<1e-7?0:r-s)},xyt=async()=>{try{await GI("webgl"),await _6()}catch{console.warn("WebGL failed, falling back to CPU. Performance will be reduced."),await GI("cpu")}};xyt();const CA=3e5,vyt=n=>new Promise((t,e)=>{const s=new Worker(new URL(""+new URL("assets/brain.worker-D7DtahNH.js",import.meta.url).href,import.meta.url),{type:"module"});let r=!1;const i=setTimeout(()=>{r||(r=!0,s.terminate(),e(new Error(`Neural Training Timed Out (${CA/1e3}s Limit). Try again or use Fast Mode.`)))},CA);if(s.onmessage=o=>{const{type:l,data:c}=o.data;l==="TRAIN_SUCCESS"?r||(r=!0,clearTimeout(i),s.terminate(),t(c)):l==="ERROR"&&(r||(r=!0,clearTimeout(i),s.terminate(),e(new Error(c))))},s.onerror=o=>{r||(r=!0,clearTimeout(i),s.terminate(),e(o))},n.historicalPrices?.length<rs+10){clearTimeout(i),e(new Error(`Insufficient price history for neural training. Got ${n.historicalPrices?.length||0} bars, need ${rs+10}.`));return}s.postMessage({type:"TRAIN_AND_PREDICT",data:n})}),rs=45,hw=8,lh=(n,t,e)=>(n-t)/(e||1),TA=(n,t,e)=>(n-t)/(e||1),wyt=n=>{const t=[...n].sort((o,l)=>o-l),e=t[Math.floor(t.length/2)],s=t[Math.floor(t.length*.25)],i=t[Math.floor(t.length*.75)]-s||1;return{median:e,iqr:i}},Syt=n=>{const{prices:t,rsi:e,macd:s,atr:r,roc:i,vol:o,emaRatio:l,bPercent:c}=n,h=Math.min(t.length,e.length,s.length,r?.length||0,i?.length||0,o?.length||0,l?.length||0,c?.length||0),d=t.slice(-h),p=e.slice(-h),m=s.slice(-h),y=r.slice(-h),b=i.slice(-h),x=o.slice(-h),w=l.slice(-h),S=c.slice(-h),T=[];return[p,m,y].forEach(k=>{const $=k.reduce((N,_)=>N+_,0)/(k.length||1),E=Math.sqrt(k.reduce((N,_)=>N+Math.pow(_-$,2),0)/(k.length||1))||1;T.push({mean:$,std:E})}),[b,x].forEach(k=>{const{median:$,iqr:E}=wyt(k);T.push({median:$,iqr:E})}),[w,S].forEach(k=>{const $=k.reduce((N,_)=>N+_,0)/(k.length||1),E=Math.sqrt(k.reduce((N,_)=>N+Math.pow(_-$,2),0)/(k.length||1))||1;T.push({mean:$,std:E})}),[{base:d[0]},...T]},Cyt=(n,t,e)=>{const s=t.prices[0],r=[];for(let c=0;c<rs;c++)r.push([(t.prices[c]-s)/(s||1),lh(t.rsi[c],e[1].mean,e[1].std),lh(t.macd[c],e[2].mean,e[2].std),lh(t.atr[c],e[3].mean,e[3].std),TA(t.roc[c],e[4].median,e[4].iqr),TA(t.vol[c],e[5].median,e[5].iqr),lh(t.emaRatio[c],e[6].mean,e[6].std),lh(t.bPercent[c],e[7].mean,e[7].std)]);const i=d9([r],[1,rs,hw]),o=n.predict(i),l=o.dataSync()[0];return i.dispose(),o.dispose(),l*s+s},Tyt=n=>{n&&n.dispose()},kyt=async(n,t,e,s)=>{if(n)try{if(t.weightData instanceof ArrayBuffer){const i=new Uint8Array(t.weightData);let o="";for(let l=0;l<i.byteLength;l++)o+=String.fromCharCode(i[l]);t.weightData=btoa(o)}const{error:r}=await gs.from("neural_models").upsert([{user_id:n.id,name:e,model_json:t,accuracy:s,created_at:new Date().toISOString()}],{onConflict:"user_id, name"});if(r)throw r;return!0}catch(r){return console.error("Cloud Artifact Save Error:",r),!1}},$yt=async(n,t)=>{if(!n)return null;try{const{data:e,error:s}=await gs.from("neural_models").select("model_json").eq("name",t).order("created_at",{ascending:!1}).limit(1).maybeSingle();if(s||!e)return null;const r=e.model_json;if(typeof r.weightData=="string"){const l=atob(r.weightData),c=new Uint8Array(l.length);for(let h=0;h<l.length;h++)c[h]=l.charCodeAt(h);r.weightData=c.buffer}else Array.isArray(r.weightData)&&(r.weightData=new Uint8Array(r.weightData).buffer);const i=await EQ(D7(r)),o=i.inputs[0].shape;return o[1]!==rs||o[2]!==hw?(console.warn(`[Brain] Model shape mismatch detected (${o[1]}x${o[2]} vs ${rs}x${hw}). Discarding legacy model.`),i.dispose(),null):i}catch(e){return console.error("Cloud Model Load Error:",e),null}},z0={BTC:"bitcoin",ETH:"ethereum",SOL:"solana",XRP:"ripple",ADA:"cardano",DOGE:"dogecoin",AVAX:"avalanche-2",DOT:"polkadot",MATIC:"matic-network",LINK:"chainlink",LTC:"litecoin",SHIB:"shiba-inu",TRX:"tron",UNI:"uniswap",ATOM:"cosmos",XMR:"monero",ETC:"ethereum-classic",XLM:"stellar",BCH:"bitcoin-cash",FIL:"filecoin",APT:"aptos",QNT:"quant-network",NEAR:"near",ARB:"arbitrum",VET:"vechain",MKR:"maker",AAVE:"aave",GRT:"the-graph",ALGO:"algorand",AXS:"axie-infinity",SAND:"the-sandbox",EOS:"eos",MANA:"decentraland",THETA:"theta-token",EGLD:"elrond-erd-2",FTM:"fantom",XTZ:"tezos",FLOW:"flow",IMX:"immutable-x",SNX:"havven",NEO:"neo",CVX:"convex-finance",CRV:"curve-dao-token",BAT:"basic-attention-token",CHZ:"chiliz",ENJ:"enjincoin",DASH:"dash",COMP:"compound-governance-token",ZEC:"zcash",XEM:"nem",HOT:"holo",IOTX:"iotex",RUNE:"thorchain",KSM:"kusama",ZIL:"zilliqa",RVN:"ravencoin",CELO:"celo",ONE:"harmony",QTUM:"qtum",BNB:"binancecoin"},Eyt=120*1e3,Iyt=n=>{try{const t=localStorage.getItem(`cache_${n}`);if(t){const{data:e,timestamp:s}=JSON.parse(t);if(Date.now()-s<Eyt)return e}}catch(t){console.warn("Cache read compile error",t)}return null},Nyt=(n,t)=>{try{localStorage.setItem(`cache_${n}`,JSON.stringify({data:t,timestamp:Date.now()}))}catch{try{localStorage.clear()}catch{}}},LC={AAPL:"Apple Inc.",MSFT:"Microsoft Corp.",GOOGL:"Alphabet Inc.",AMZN:"Amazon.com Inc.",NVDA:"NVIDIA Corp.",TSLA:"Tesla Inc.",META:"Meta Platforms Inc.","BRK.B":"Berkshire Hathaway",V:"Visa Inc.",JNJ:"Johnson & Johnson",WMT:"Walmart Inc.",JPM:"JPMorgan Chase & Co.",PG:"Procter & Gamble Co.",MA:"Mastercard Inc.",LLY:"Eli Lilly and Co.",HD:"Home Depot Inc.",CVX:"Chevron Corp.",MRK:"Merck & Co.",KO:"Coca-Cola Co.",PEP:"PepsiCo Inc.",AVGO:"Broadcom Inc.",COST:"Costco Wholesale Corp.",ORCL:"Oracle Corp.",AMD:"Advanced Micro Devices",NFLX:"Netflix Inc.",INTC:"Intel Corp.",IBM:"IBM Corp.",QCOM:"Qualcomm Inc.",TXN:"Texas Instruments",HON:"Honeywell",UNH:"UnitedHealth Group",SPY:"SPDR S&P 500 ETF",QQQ:"Invesco QQQ Trust",IWM:"iShares Russell 2000",DIA:"SPDR Dow Jones"},aP=n=>{if(!n)return null;const t=n.match(/\b\d{1,3}(?:[.,]\d{3})*[.,]\d{1,8}\b/g),e=n.match(/\b\d{1,3}(?:,\d{3})+\b/g),s=n.match(/\b\d{4,7}\b/g),r=n.match(/\b\d{1,3},\d{2,3}(?!,\d)\b/g),o=[...t||[],...e||[],...s||[],...r||[]].map(c=>{const h=c.replace(/,/g,""),d=h.split(".");if(d.length>2){const p=d.pop();return parseFloat(d.join("")+"."+p)}return parseFloat(h)}).filter(c=>c>=2e3&&c<=3e3||c===24||c===1||c===7||c===30||c===15||c===60?!1:c>1e-4&&c<2e7);return o.length===0?null:o.sort((c,h)=>{const d=c>.1&&c<15e4,p=h>.1&&h<15e4;if(d&&!p)return-1;if(!d&&p)return 1;const m=c%1!==0,y=h%1!==0;return m&&!y?-1:!m&&y?1:c-h})[0]},kA=n=>{if(!n||typeof n!="string")return!1;const t=n.toUpperCase();if(t.length<2||t.length>8)return!1;if(z0[t]||LC[t])return!0;if(/^\d/.test(t)&&!t.startsWith("1000")||/^\d+[DMHW]$/.test(t)||["VOL","USD","USDT","UTC","CRYPTO","CRYPTOCURRENCY","PRICE","MARKET","CHANGE","TIME","TOTAL","LOW","HIGH","OPEN","CLOSE","DAILY","WEEKLY","INDEX","CHART","LINK","NAV","SCAN","IMAGE","SHARE"].includes(t))return!1;const s=/^[A-Z]{2,6}$/.test(t),r=/^[A-Z]{2,5}(USD[TC]?|BUSD|EUR|GBP)$/.test(t),i=/^1000[A-Z]{2,4}$/.test(t);return!(!s&&!r&&!i||!/[AEIOUY]/.test(t)&&t.length>4)},Ayt=(n,t)=>{if(!n||!t)return 0;const e=n.length>t.length?n:t,s=n.length>t.length?t:n;if(e.length===0)return 1;const r=(i,o)=>{const l=[];for(let c=0;c<=o.length;c++)l[c]=[c];for(let c=0;c<=i.length;c++)l[0][c]=c;for(let c=1;c<=o.length;c++)for(let h=1;h<=i.length;h++)o.charAt(c-1)===i.charAt(h-1)?l[c][h]=l[c-1][h-1]:l[c][h]=Math.min(l[c-1][h-1]+1,Math.min(l[c][h-1]+1,l[c-1][h]+1));return l[o.length][i.length]};return(e.length-r(e,s))/parseFloat(e.length)},_yt=n=>{if(!n)return null;const t=n.toUpperCase(),e=n.match(/tradingview\.com\/(?:symbols|chart)\/([A-Z0-9:]+)/i)||n.match(/[?&]symbol=([A-Z0-9:]+)/i);if(e){const d=e[1].split(":").pop().replace(/(USD[TC]?|BUSD|EUR|GBP)$/,"");if(d&&d.length>=2)return d}const s=t.split(/[^A-Z0-9]/).filter(h=>h.length>=2),r=[...Object.keys(z0),...Object.keys(LC)];for(const h of s)if(r.includes(h))return h;for(const h of s)if(/^[A-Z]{3,5}$/.test(h)){for(const d of r)if(Ayt(h,d)>=.8)return d}const i=t.match(/\b([A-Z0-9]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP|FRAX|DAI)\b/);if(i){const h=i[1];if(kA(h))return h}if((t.includes("O H L")||t.includes("INDEX")||t.includes("EXCHANGE")||t.includes("MARKET CAP"))&&!t.includes("BITCOIN")){const h=aP(n);if(h>4e4&&h<15e4)return"BTC";if(h>1500&&h<1e4)return"ETH";if(h>150&&h<1e3)return"SOL";if(h>.4&&h<2.5)return"XRP"}const l={BITCOIN:"BTC",ETHEREUM:"ETH",SOLANA:"SOL",RIPPLE:"XRP",CARDANO:"ADA",DOGECOIN:"DOGE",AVALANCHE:"AVAX"};for(const[h,d]of Object.entries(l))if(t.includes(h))return d;const c=t.match(/\(([A-Z0-9]{2,6})\)[ -]|^([A-Z0-9]{2,6})\s+\d/);if(c){const h=c[1]||c[2];if(kA(h))return h}return null},Ryt=async n=>{const t=z0[n];if(!t)return null;try{const r=(await(await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${t}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`)).json())[t];return{price:r.usd,change24h:r.usd_24h_change,volume:r.usd_24h_vol,source:"CoinGecko"}}catch(e){return console.error("CoinGecko Fetch Error:",e),null}},Dyt=async(n,t=90)=>{const e=z0[n];if(!e)return null;const s=Iyt(`${e}_${t}`);if(s)return s;try{const i=await(await fetch(`https://api.coingecko.com/api/v3/coins/${e}/market_chart?vs_currency=usd&days=${t}`)).json(),o=i.prices.map(h=>h[1]),l=i.total_volumes.map(h=>h[1]),c={closes:o,highs:o.map(h=>h*1.002),lows:o.map(h=>h*.998),volumes:l};return Nyt(`${e}_${t}`,c),c}catch(r){return console.error("CoinGecko History Error:",r),null}},Oyt=async n=>{const t=n.includes("-")?n.replace("-",""):n;try{const e=`https://query1.finance.yahoo.com/v8/finance/chart/${t}?interval=1d&range=6mo`,s=[`https://corsproxy.io/?${encodeURIComponent(e)}`,`https://api.allorigins.win/raw?url=${encodeURIComponent(e)}`];let r=null;for(const b of s)try{const x=await fetch(b);if(!x.ok)continue;if(r=await x.json(),r?.chart?.result)break}catch{continue}if(!r?.chart?.result?.[0])throw new Error("Invalid Yahoo response");const i=r.chart.result[0],o=i.indicators?.quote?.[0];if(!o)throw new Error("No indicators in Yahoo data");const l=(o.close||[]).filter(b=>b!==null),c=(o.high||[]).filter(b=>b!==null),h=(o.low||[]).filter(b=>b!==null),d=(o.volume||[]).filter(b=>b!==null),p=i.meta?.regularMarketPrice,m=i.meta?.previousClose,y=m?(p-m)/m*100:0;return{marketStats:{price:p,change24h:y,volume:d[d.length-1],source:"Yahoo Finance"},historicalData:{closes:l,highs:c,lows:h,volumes:d}}}catch(e){return console.warn("Yahoo data fetch failed for",n,e),null}},$A=async n=>{if(!n||n==="VISUAL-SCAN")return null;const t=n.includes("-")?n.replace("-",""):n;try{const e=`https://query1.finance.yahoo.com/v8/finance/chart/${t}?interval=1d&range=1y`,s=[`https://corsproxy.io/?${encodeURIComponent(e)}`,`https://api.allorigins.win/raw?url=${encodeURIComponent(e)}`];let r=null;for(const o of s)try{const l=await fetch(o);if(!l.ok)continue;if(r=await l.json(),r?.chart?.result)break}catch{continue}return r?.chart?.result?.[0]?.indicators?.quote?.[0]?.close?.filter(o=>o!==null)||null}catch{return null}},Myt=n=>{if(!n||n.length<10)return .5;const t=n[n.length-1],e=n.slice(-50).reduce((o,l)=>o+l,0)/Math.min(n.length,50),s=n.slice(-200).reduce((o,l)=>o+l,0)/Math.min(n.length,200);let r=.5;t>e&&(r+=.1),t>s&&(r+=.15),e>s&&(r+=.1),t>n[0]&&(r+=.1);const i=(t-n[n.length-20])/n[n.length-20];return r+=i*.5,Math.max(.1,Math.min(.9,r))},Fyt=(n,t,e,s,r=.95,i=.5,o=.02,l=.5)=>{const h=.15+(o>.04?.05:0),d=.1,p=s.omega+s.alpha+s.gamma+h+d,m=X=>(X-.5)*2,y=m(n),b=s.omega/p,x=r;let w=.5;t==="Bullish"?w=.85:t==="Bearish"&&(w=.15);const S=m(w),T=s.alpha/p,k=e.rsi[e.rsi.length-1];let $=.5;k<30?$=.85:k<40?$=.7:k>70?$=.15:k>60&&($=.3);const E=m($),N=s.gamma/p,_=k<25||k>75?1.3:1,R=m(i),D=h/p,M=m(l),W=1-[{w:b,p:y,c:x,f:1},{w:T,p:S,c:.9,f:1},{w:N,p:E,c:1,f:_},{w:D,p:R,c:1,f:1},{w:.15,p:M,c:1,f:1},{w:d/p,p:m(s.obBias||.5),c:1,f:1}].reduce((X,P)=>{const U=P.w*P.p*P.c*P.f;return X*(1-Math.max(-.99,Math.min(.99,U)))},1-.5);return isNaN(W)||!isFinite(W)?(console.warn("[Neural Core] NaN detected in Engine Fusion. Reverting to Baseline."),.5):Math.min(.995,Math.max(.005,W))},Lyt=async(n,t,e,s,r,i,o=.95,l=!1)=>{const c=Array.isArray(e)?e:e.closes||[],h=e.highs||c,d=e.lows||c;e.volumes;let p=t.price||c[c.length-1];const m=c[c.length-1];if(t.price&&m){const Pt=Math.log10(m/t.price);if(Math.abs(Pt)>.6){const se=Math.pow(10,Math.round(Pt));console.log(`[ScaleGuardian] Correcting OCR price scale: ${t.price} -> ${t.price*se} (Factor: ${se})`),p=t.price*se}}if(c.length<20)throw new Error("Insufficient historical data for precision analysis");const y=R5(c,14),x=D5(c).histogram,w=e.opens||[],S=O5(c,h,d,w),T=S[0].sentiment,k=M5(h,d,c,14),$=F5(c,h,d);e.volumes&&e.volumes.length>0&&L5(h,d,c,e.volumes);const E=Wa(c,8),N=Wa(c,21),_=E.map((Pt,se)=>Pt/(N[se]||1)),{upper:R,lower:D}=kR(c,20),M=R?.length||0,A=c.slice(-M).map((Pt,se)=>(Pt-D[se])/(R[se]-D[se]||1)),B=[...new Array(c.length-M).fill(.5),...A];let H=.5;try{i("Aligning Multi-Timeframe Bias (Daily)...");const Pt=await $A(n);Pt?.prices&&(H=P5(Pt.prices))}catch(Pt){console.warn("MTF Alignment failed, using neutral bias:",Pt)}let W=.5,X=null;const P=k[k.length-1]||p*.02,U=yyt(c),G=P/p;if(c.length>=rs+15)if(l){const Pt=c[c.length-1],se=c[c.length-15],ps=(Pt-se)/se;W=.5+Math.min(.45,Math.max(-.45,ps/(G*5))),i("Rapid Precision Heuristic Applied...")}else{let Pt=null;try{const se=SA(c,10),ps=sg(c,20),_r={prices:c,rsi:y,macd:x,atr:k,roc:se,vol:ps,emaRatio:_,bPercent:B};if(s&&(Pt=await $yt(s,`lstm_v4_${n}`)),Pt){if(i("Calibrating Cloud Intelligence V4..."),X=Syt(_r),Pt&&c.length>=rs&&X){i("Running V4 Predictive Inference...");const Rr={prices:c.slice(-rs),rsi:y.slice(-rs),macd:x.slice(-rs),atr:k.slice(-rs),roc:se.slice(-rs),vol:ps.slice(-rs),emaRatio:_.slice(-rs),bPercent:B.slice(-rs)},ir=Cyt(Pt,Rr,X),ns=1/(G*10||1);W=.5+(ir-p)/p*ns,(isNaN(W)||!isFinite(W))&&(W=.5),W=Math.max(.02,Math.min(.98,W))}}else{const Rr=c[c.length-1],ir=c[c.length-15]||c[0],ns=(Rr-ir)/ir;W=.5+Math.min(.45,Math.max(-.45,ns/(G*5))),i("Rapid Precision Heuristic Applied (Training in Background)..."),vyt({ticker:n,historicalPrices:c,rsi:y,macdHist:x,atr:k,roc:SA(c,10),vol:sg(c,20),emaRatio:_,bPercent:B}).then(async Be=>{Be&&s&&Be.modelArtifacts&&(console.log(`[Neural Core] Background Training Complete for ${n}. Syncing to Global Master Model...`),await kyt(s,Be.modelArtifacts,`lstm_v4_${n}`,.99))}).catch(Be=>console.warn("[Neural Core] Background Training Error:",Be))}}finally{Pt&&Tyt(Pt)}}i("Gathering Macro V4 Context...");const tt=await $A(n),Z=Myt(tt?.prices);let F=.5;try{if(n.includes("BTC")||n.includes("ETH")||n.includes("SOL")){let Pt=n.replace("/","").toUpperCase();(Pt==="BTC"||Pt==="ETH"||Pt==="SOL")&&(Pt+="USDT");const se=await fetch(`https://api.binance.com/api/v3/depth?symbol=${Pt}&limit=20`);if(se.ok){const ps=await se.json(),_r=ps.bids.reduce((ir,[ns,Be])=>ir+Number(Be),0),Rr=ps.asks.reduce((ir,[ns,Be])=>ir+Number(Be),0);F=_r/(_r+Rr),console.log(`[Analysis] Order Book Bias: ${F.toFixed(2)}`)}}}catch(Pt){console.warn("Order Book sync failed:",Pt)}let z=Fyt(W,T,{rsi:y},{...r,obBias:F},o,Z,G,H);const Q=y[y.length-1]<45&&T==="Bullish",ct=y[y.length-1]>55&&T==="Bearish";if(W>.75&&Q){const Pt=.05+.1*(W-.75);z=Math.min(.99,z+Pt)}else if(W<.25&&ct){const Pt=.05+.1*(.25-W);z=Math.max(.01,z-Pt)}const pt=((z>.5?z:1-z)*100).toFixed(1),gt=[{name:"Neural Net (V5 LSTM)",type:"Deep Intelligence",w:r.omega,p:W,value:l?"Heuristic":"RMSE-Optimized"},{name:`Primary Pattern: ${S[0].name}`,type:"Geometric",w:r.alpha,p:T==="Bullish"?.8:T==="Bearish"?.2:.5,value:S[0].name},{name:"Technical Alpha",type:"Confluence",w:r.gamma,p:y[y.length-1]<45?.8:y[y.length-1]>55?.2:.5,value:"RSI-ATR Sync"},{name:"Macro Sentiment",type:"Ensemble",w:.15,p:Z,value:"10Y-Alpha"},{name:"MTF Alignment",type:"V5 Bias",w:.15,p:H,value:H>.6?"Bullish":H<.4?"Bearish":"Neutral"},{name:"Visual Alignment",type:"Sync",w:.1,p:o,value:`${(o*100).toFixed(0)}%`}];let xt="Neutral";z>.68?xt="Strong Bullish":z>.55?xt="Moderate Bullish":z<.32?xt="Strong Bearish":z<.45&&(xt="Moderate Bearish");const kt=xt.includes("Bullish")||xt==="Neutral"&&z>=.5;xt.includes("Bearish")||xt==="Neutral"&&z<.5;const Ct=p<1?5:p<100?3:2,Ot=kt?$.strength.s:$.strength.r,Gt=Ot>3?1.2:Ot>1?1.5:1.8,Yt=Math.max(p*.008,P*Gt),ge=xt.includes("Strong")?2.2:1.8,me=Math.min(1.3,Math.max(.8,parseFloat(pt)/60)),re=Math.min(3,ge*me);let Zt,Ce,ae;kt?(Zt=p-Yt,$.support<p&&$.support>Zt&&Ot>1&&(Zt=$.support*.997),Ce=p+Yt*Math.min(re,2),ae=p+Yt*re,$.resistance>p&&$.resistance<ae*1.1&&$.strength.r>2&&(ae=$.resistance*.997)):(Zt=p+Yt,$.resistance>p&&$.resistance<Zt&&Ot>1&&(Zt=$.resistance*1.003),Ce=Math.max(p*.1,p-Yt*Math.min(re,2)),ae=Math.max(p*.05,p-Yt*re),$.support<p&&$.support>ae*.9&&$.strength.s>2&&(ae=$.support*1.003));const fs={entry:p.toFixed(Ct),sl:Zt.toFixed(Ct),tp1:Ce.toFixed(Ct),tp2:ae.toFixed(Ct),rr:re.toFixed(1)},We=()=>{y[y.length-1];let Pt=`V5 Institutional analysis of **${n}** identified a **${xt}** structure with **${pt}%** mathematical confidence. `;if(S.length>0){const se=S[0];Pt+=`The detection of a **${se.name}** pattern suggests a dominant ${se.sentiment.toLowerCase()} sentiment in the current fractal. `}return W>.7?Pt+="Deep LSTM detects aggressive institutional accumulation. ":W<.3&&(Pt+="Neural inference highlights terminal distribution phases. "),($.strength.s>3||$.strength.r>3)&&(Pt+=`Major ${$.strength.s>$.strength.r?"support":"resistance"} detected at $${$.strength.s>$.strength.r?$.support.toFixed(Ct):$.resistance.toFixed(Ct)} with strength ${Math.max($.strength.s,$.strength.r)}/5. `),G>.05&&(Pt+="High implied volatility suggests widened discovery ranges. "),Pt},ks=c.slice(1).map((Pt,se)=>(Pt-c[se])/c[se]),On=byt(ks),Ar=pyt(On),De=myt(On),Bs=gyt(c),Vs={volatility:(G*100).toFixed(2),volRatio:U.toFixed(2),sharpeRatio:Ar.toFixed(2),sortinoRatio:De.toFixed(2),maxDrawdown:Bs.toFixed(2),calibration:{rmse:(Math.sqrt(Math.pow(1-z,2))*.08).toFixed(4),brier:Math.pow(z-(kt?1:0),2).toFixed(4)}};return{id:Date.now().toString(),date:new Date().toISOString(),p0:r.alpha.toFixed(2),finalProb:Number(z),direction:xt,confidence:pt,patterns:S,factors:gt,targets:fs,riskMetrics:Vs,macroTrend:{...tt,source:tt?.source||"Internal V5 Neural Core"},overview:We(),ticker:n||"UNKNOWN",version:`V5-NEURAL-EDGE (Iter: ${r.iterations})`,raw_prices:c}},Na="https://diverai.flisoft.agency",Pyt=({ticker:n})=>{const[t,e]=St.useState(null),[s,r]=St.useState(!1);St.useEffect(()=>{n&&i()},[n]);const i=async()=>{r(!0);try{let o=n.replace("/","").toUpperCase();(o==="BTC"||o==="ETH"||o==="SOL"||o==="XRP")&&(o+="USDT");const l=await fetch(`https://api.binance.com/api/v3/depth?symbol=${o}&limit=5`);if(l.ok){const c=await l.json();e(c)}}catch{console.warn("Order book fetch skipped for non-compatible ticker.")}finally{r(!1)}};return s?it.jsx("div",{className:"h-20 bg-slate-900 animate-pulse rounded-xl"}):t?it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3 space-y-2",children:[it.jsxs("div",{className:"flex items-center gap-2 text-[10px] font-bold text-slate-500 uppercase",children:[it.jsx(RG,{className:"w-3 h-3"})," Order Book Depth"]}),it.jsxs("div",{className:"space-y-1",children:[t.asks.slice(0,3).reverse().map(([o,l],c)=>it.jsxs("div",{className:"flex justify-between text-[10px] font-mono",children:[it.jsx("span",{className:"text-rose-500",children:Number(o).toFixed(2)}),it.jsx("span",{className:"text-slate-600",children:Number(l).toFixed(4)})]},`ask-${c}`)),it.jsx("div",{className:"h-px bg-slate-800 my-1"}),t.bids.slice(0,3).map(([o,l],c)=>it.jsxs("div",{className:"flex justify-between text-[10px] font-mono",children:[it.jsx("span",{className:"text-emerald-500",children:Number(o).toFixed(2)}),it.jsx("span",{className:"text-slate-600",children:Number(l).toFixed(4)})]},`bid-${c}`))]})]}):null},zyt=()=>{const{user:n,profile:t,refreshProfile:e,neuralState:s}=_5(),[r,i]=St.useState("idle"),[o,l]=St.useState(null),[c,h]=St.useState(null),[d,p]=St.useState(""),[m,y]=St.useState(""),[b,x]=St.useState(!1),[w,S]=St.useState(""),[T,k]=St.useState("guest"),[$,E]=St.useState(null),[N,_]=St.useState([]),[R,D]=St.useState("analyze"),[M,A]=St.useState(!1);St.useEffect(()=>{B();const Z=async F=>{if(F.type==="AUTH_SYNC"&&F.session){const{access_token:z,refresh_token:Q}=F.session;await gs.auth.setSession({access_token:z,refresh_token:Q}),e()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(Z),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(Z)}},[]);const B=async()=>{try{const Z=await fetch("https://api.ipify.org?format=json");if(!Z.ok)throw new Error("Network response was not ok");const F=await Z.json();E(F.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};St.useEffect(()=>{H()},[n]);const H=async()=>{if(!n){const z=localStorage.getItem("diver_ai_guest_history");_(z?JSON.parse(z):[]);return}const{data:Z,error:F}=await gs.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!F&&Z&&_(Z.map(z=>({...z.data,db_id:z.id,created_at:z.created_at})))},W=async Z=>{if(n){const{data:F}=await gs.from("prediction_history").insert([{user_id:n.id,data:Z}]).select();if(F?.[0]){const z={...Z,db_id:F[0].id,created_at:F[0].created_at};_(Q=>[z,...Q].slice(0,10))}}},X=()=>{},P=()=>{if(!n)return S("Authentication Required: Please log in to access the neural analysis terminal."),k("guest"),x(!0),!1;const Z=new Date().toISOString().split("T")[0];return n.email_confirmed_at?t&&t.subscription_tier!=="pro"&&(t.upload_count||0)>=3&&t.last_upload_date===Z?(S("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),k("free"),x(!0),!1):!0:(S("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),k("verify"),x(!0),!1)},U=async()=>{if(P()){i("scanning"),p("Capturing Visual Stream..."),l(null);try{const Z=await new Promise(gt=>{chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"},xt=>{chrome.runtime.lastError?gt({error:"Connection to extension background lost. Please refresh the page."}):gt(xt)})});if(Z.error)throw new Error(Z.error);const F=Z.dataUrl;h(F),i("analyzing"),await gs.auth.refreshSession();try{p("Deep Scan (Cloud OCR)...");const{data:gt,error:xt}=await gs.functions.invoke("detect_ticker",{body:{image:F}});if(xt)throw xt;const kt=gt?.text||"",Ct=_yt(kt),Ot=aP(kt);if(console.log("[Sidebar] OCR Detected:",{ticker:Ct,anchorPrice:Ot}),!Ct&&!Ot)throw new Error("Neural Core Rejected: No valid asset or price identified.");p(`Target Locked: ${Ct}. Syncing Data...`)}catch(gt){throw console.warn("[Sidebar] Cloud OCR Failed, using local fallback if possible or failing."),gt}p(`Target Locked: ${ticker}. Syncing Data...`);let z,Q;if(LC[ticker]){const gt=await Oyt(ticker);if(gt)z=gt.marketStats,Q=gt.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else z=await Ryt(ticker),Q=await Dyt(ticker,90);p("Synchronizing Global Intelligence...");const pt=await Lyt(ticker,z,Q,n,s,p,.95,!0);if(n&&t){const gt=new Date().toISOString().split("T")[0],xt=t.last_upload_date!==gt?1:(t.upload_count||0)+1;await gs.from("profiles").update({upload_count:xt,last_upload_date:gt}).eq("id",n.id),e()}else X();await W(pt),l(pt),i("success")}catch(Z){console.error(Z),y(Z.message),i("error")}}},G=()=>{if(!o){console.warn("[Overlay] No analysis result available to draw overlay.");return}chrome.tabs.query({active:!0,currentWindow:!0},Z=>{const F=Z[0];if(!F){console.warn("[Overlay] No active tab found.");return}if(!F.url){console.warn("[Overlay] Unable to determine current page URL.");return}if(!["tradingview.com","yahoo.com","coingecko.com","coinmarketcap.com","binance.com","google.com/finance"].some(ct=>F.url.includes(ct))){console.info(`[Overlay] Skipped - Not on a supported trading page. Current URL: ${F.url}`),alert("Please navigate to a trading chart (e.g., TradingView) to draw the R/R overlay.");return}chrome.tabs.sendMessage(F.id,{action:"DRAW_RR_OVERLAY",targets:o.targets,ticker:o.ticker},ct=>{chrome.runtime.lastError?(console.error("[Overlay] Failed:",chrome.runtime.lastError.message),alert("Overlay failed: Content script not ready. Try refreshing the trading page.")):ct?.success?console.log("[Overlay] Successfully drawn on chart."):console.warn("[Overlay] Message sent, but no confirmation received.")})})},tt=({id:Z,label:F,icon:z})=>it.jsxs("button",{onClick:()=>D(Z),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${R===Z?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[it.jsx(z,{className:"w-3.5 h-3.5"}),F,R===Z&&it.jsx(Ta.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return it.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&it.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:it.jsxs("div",{className:"space-y-6 max-w-xs",children:[it.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:it.jsx(iI,{className:"text-rose-500"})}),it.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),it.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),it.jsxs("div",{className:"space-y-3",children:[T==="free"?it.jsx("button",{onClick:()=>window.open(`${Na}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):T==="guest"?it.jsx("button",{onClick:()=>window.open(`${Na}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):it.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),it.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),it.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[it.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[it.jsxs("div",{className:"flex items-center gap-2",children:[it.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:it.jsx(CG,{className:"w-3.5 h-3.5 text-white"})}),it.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",it.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?it.jsxs("div",{className:"flex items-center gap-3",children:[it.jsx("div",{className:"text-right",children:it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:t?.subscription_tier==="pro"?"PRO":"BASIC"})}),it.jsx("button",{onClick:()=>gs.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:it.jsx(MG,{className:"w-4 h-4"})})]}):it.jsx("button",{onClick:()=>window.open(`${Na}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),it.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[it.jsx(tt,{id:"analyze",label:"Analysis",icon:lI}),it.jsx(tt,{id:"history",label:"History",icon:rI}),n&&it.jsx(tt,{id:"referral",label:"Rewards",icon:qG})]})]}),it.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:it.jsxs(BU,{mode:"wait",children:[R==="history"&&it.jsx(Ta.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:N.length===0?it.jsxs("div",{className:"text-center py-12 text-slate-600",children:[it.jsx(rI,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),it.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):N.map((Z,F)=>it.jsxs("div",{onClick:()=>{l(Z),i("success"),D("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[it.jsxs("div",{className:"flex items-center gap-3",children:[it.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${Z.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:Z.direction.includes("Bullish")?it.jsx(aI,{className:"w-4 h-4"}):it.jsx(oI,{className:"w-4 h-4"})}),it.jsxs("div",{children:[it.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:Z.ticker}),it.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(Z.created_at).toLocaleDateString()})]})]}),it.jsxs("span",{className:`text-xs font-mono font-bold ${Z.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(Z.finalProb*100).toFixed(0),"%"]})]},Z.db_id||F))},"history"),R==="referral"&&n&&it.jsxs(Ta.div,{initial:{opacity:0,x:10},animate:{opacity:1,x:0},className:"space-y-4",children:[it.jsxs("div",{className:"bg-gradient-to-br from-blue-600 to-indigo-700 rounded-2xl p-5 border border-white/10 shadow-xl relative overflow-hidden",children:[it.jsx("div",{className:"absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 mix-blend-overlay"}),it.jsxs("div",{className:"relative z-10 space-y-3",children:[it.jsx("h3",{className:"text-sm font-black uppercase tracking-tight",children:"Earn Pro Status"}),it.jsx("p",{className:"text-[10px] text-blue-100 font-medium leading-relaxed",children:"Refer a friend. You both get 30 days of Pro analysis upon their signup."}),it.jsx("div",{className:"pt-2",children:it.jsxs("div",{className:"flex gap-2",children:[it.jsx("div",{className:"flex-1 bg-slate-950/40 border border-white/10 rounded-lg px-3 py-2 text-[9px] font-mono text-blue-200 truncate",children:t?.referral_code?`${Na}/signup?ref=${t.referral_code}`:"Generating..."}),it.jsx("button",{onClick:()=>{navigator.clipboard.writeText(`${Na}/signup?ref=${t?.referral_code}`),A(!0),setTimeout(()=>A(!1),2e3)},className:"bg-white text-slate-950 p-2 rounded-lg hover:bg-blue-100 transition-colors",children:M?it.jsx(kG,{className:"w-3.5 h-3.5"}):it.jsx(EG,{className:"w-3.5 h-3.5"})})]})})]})]}),it.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[it.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Total Referrals"}),it.jsx("p",{className:"text-xl font-black text-white",children:t?.referral_count||0})]}),it.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Days Granted"}),it.jsx("p",{className:"text-xl font-black text-emerald-400",children:(t?.referral_count||0)*30})]})]}),it.jsxs("button",{onClick:()=>window.open(`${Na}/referral`,"_blank"),className:"w-full py-3 bg-slate-900 border border-slate-800 hover:border-blue-500/50 text-slate-300 hover:text-white text-[10px] font-bold uppercase tracking-widest rounded-xl transition-all flex items-center justify-center gap-2",children:[it.jsx(VG,{className:"w-3.5 h-3.5"})," View Full Dashboard"]})]},"referral"),R==="analyze"&&r==="idle"&&it.jsx(Ta.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:n?it.jsxs(it.Fragment,{children:[it.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:it.jsx(zG,{className:"w-8 h-8 text-blue-500"})}),it.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[it.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),it.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]}):it.jsxs(it.Fragment,{children:[it.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:it.jsx(iI,{className:"w-8 h-8 text-rose-500"})}),it.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[it.jsx("h3",{className:"text-lg font-bold text-white",children:"Terminal Locked"}),it.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Neural analysis requires an active operative session. Please login to continue."})]}),it.jsx("button",{onClick:()=>window.open(`${Na}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg transition-all uppercase tracking-widest text-[10px]",children:"Initialize Login"})]})},"idle"),(r==="scanning"||r==="analyzing")&&it.jsxs(Ta.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[it.jsxs("div",{className:"relative w-16 h-16",children:[it.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),it.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),it.jsxs("div",{className:"text-center space-y-2",children:[it.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),it.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),r==="success"&&o&&R==="analyze"&&it.jsxs(Ta.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[it.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[it.jsxs("div",{children:[it.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:o.ticker}),it.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[it.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${o.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[o.direction.split(" ")[0]," Signal"]}),it.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(o.finalProb*100).toFixed(1),"% Conf."]})]})]}),it.jsx("div",{className:`p-2 rounded-xl ${o.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:o.direction.includes("Bullish")?it.jsx(aI,{className:"w-5 h-5 text-emerald-500"}):it.jsx(oI,{className:"w-5 h-5 text-rose-500"})})]}),it.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${o.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),it.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),it.jsx("p",{className:"text-lg font-mono font-bold text-white",children:o.targets.entry})]}),it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),it.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",o.targets.rr]})]}),it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),it.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:o.targets.tp1})]}),it.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[it.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),it.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:o.targets.sl})]})]}),it.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[it.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[it.jsx(NG,{className:"w-3 h-3"})," AI Analysis"]}),it.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:o.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),it.jsx(Pyt,{ticker:o.ticker}),it.jsxs("button",{onClick:G,className:"w-full py-3 bg-slate-800 hover:bg-slate-700 border border-slate-700 rounded-xl flex items-center justify-center gap-2 text-[10px] font-bold uppercase tracking-widest transition-all",children:[it.jsx(LG,{className:"w-3.5 h-3.5 text-blue-400"})," Draw R/R on Chart"]}),it.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:it.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",o.version.split(" ")[0],"  Data: ",o.macroTrend?.source||"Institutional Feed"]})}),it.jsx("button",{onClick:()=>i("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),r==="error"&&it.jsxs(Ta.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[it.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:it.jsx(WG,{className:"w-6 h-6 text-rose-500"})}),it.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),it.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),it.jsx("button",{onClick:()=>i("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),R==="analyze"&&r==="idle"&&it.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:it.jsxs("button",{onClick:U,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[it.jsx(lI,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};LB.createRoot(document.getElementById("root")).render(it.jsx(NB.StrictMode,{children:it.jsx(A5,{children:it.jsx(zyt,{})})}));
