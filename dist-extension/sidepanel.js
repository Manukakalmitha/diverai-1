function yB(n,t){for(var e=0;e<t.length;e++){const s=t[e];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const r=Object.getOwnPropertyDescriptor(s,i);r&&Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=e(i);fetch(i.href,r)}})();function hw(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function bB(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function s(){var i=!1;try{i=this instanceof s}catch{}return i?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),e}var Yb={exports:{}},th={};var R$;function xB(){if(R$)return th;R$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(s,i,r){var o=null;if(r!==void 0&&(o=""+r),i.key!==void 0&&(o=""+i.key),"key"in i){r={};for(var l in i)l!=="key"&&(r[l]=i[l])}else r=i;return i=r.ref,{$$typeof:n,type:s,key:o,ref:i!==void 0?i:null,props:r}}return th.Fragment=t,th.jsx=e,th.jsxs=e,th}var D$;function vB(){return D$||(D$=1,Yb.exports=xB()),Yb.exports}var bt=vB(),Jb={exports:{}},Wt={};var O$;function wB(){if(O$)return Wt;O$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),o=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),m=Symbol.iterator;function y(L){return L===null||typeof L!="object"?null:(L=m&&L[m]||L["@@iterator"],typeof L=="function"?L:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function S(L,j,Q){this.props=L,this.context=j,this.refs=w,this.updater=Q||b}S.prototype.isReactComponent={},S.prototype.setState=function(L,j){if(typeof L!="object"&&typeof L!="function"&&L!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,L,j,"setState")},S.prototype.forceUpdate=function(L){this.updater.enqueueForceUpdate(this,L,"forceUpdate")};function T(){}T.prototype=S.prototype;function k(L,j,Q){this.props=L,this.context=j,this.refs=w,this.updater=Q||b}var $=k.prototype=new T;$.constructor=k,x($,S.prototype),$.isPureReactComponent=!0;var E=Array.isArray;function N(){}var _={H:null,A:null,T:null,S:null},R=Object.prototype.hasOwnProperty;function D(L,j,Q){var ct=Q.ref;return{$$typeof:n,type:L,key:j,ref:ct!==void 0?ct:null,props:Q}}function M(L,j){return D(L.type,j,L.props)}function A(L){return typeof L=="object"&&L!==null&&L.$$typeof===n}function B(L){var j={"=":"=0",":":"=2"};return"$"+L.replace(/[=:]/g,function(Q){return j[Q]})}var H=/\/+/g;function J(L,j){return typeof L=="object"&&L!==null&&L.key!=null?B(""+L.key):j.toString(36)}function X(L){switch(L.status){case"fulfilled":return L.value;case"rejected":throw L.reason;default:switch(typeof L.status=="string"?L.then(N,N):(L.status="pending",L.then(function(j){L.status==="pending"&&(L.status="fulfilled",L.value=j)},function(j){L.status==="pending"&&(L.status="rejected",L.reason=j)})),L.status){case"fulfilled":return L.value;case"rejected":throw L.reason}}throw L}function z(L,j,Q,ct,ut){var pt=typeof L;(pt==="undefined"||pt==="boolean")&&(L=null);var vt=!1;if(L===null)vt=!0;else switch(pt){case"bigint":case"string":case"number":vt=!0;break;case"object":switch(L.$$typeof){case n:case t:vt=!0;break;case d:return vt=L._init,z(vt(L._payload),j,Q,ct,ut)}}if(vt)return ut=ut(L),vt=ct===""?"."+J(L,0):ct,E(ut)?(Q="",vt!=null&&(Q=vt.replace(H,"$&/")+"/"),z(ut,j,Q,"",function(Rt){return Rt})):ut!=null&&(A(ut)&&(ut=M(ut,Q+(ut.key==null||L&&L.key===ut.key?"":(""+ut.key).replace(H,"$&/")+"/")+vt)),j.push(ut)),1;vt=0;var Et=ct===""?".":ct+":";if(E(L))for(var Ct=0;Ct<L.length;Ct++)ct=L[Ct],pt=Et+J(ct,Ct),vt+=z(ct,j,Q,pt,ut);else if(Ct=y(L),typeof Ct=="function")for(L=Ct.call(L),Ct=0;!(ct=L.next()).done;)ct=ct.value,pt=Et+J(ct,Ct++),vt+=z(ct,j,Q,pt,ut);else if(pt==="object"){if(typeof L.then=="function")return z(X(L),j,Q,ct,ut);throw j=String(L),Error("Objects are not valid as a React child (found: "+(j==="[object Object]"?"object with keys {"+Object.keys(L).join(", ")+"}":j)+"). If you meant to render a collection of children, use an array instead.")}return vt}function P(L,j,Q){if(L==null)return L;var ct=[],ut=0;return z(L,ct,"","",function(pt){return j.call(Q,pt,ut++)}),ct}function V(L){if(L._status===-1){var j=L._result;j=j(),j.then(function(Q){(L._status===0||L._status===-1)&&(L._status=1,L._result=Q)},function(Q){(L._status===0||L._status===-1)&&(L._status=2,L._result=Q)}),L._status===-1&&(L._status=0,L._result=j)}if(L._status===1)return L._result.default;throw L._result}var K=typeof reportError=="function"?reportError:function(L){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var j=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof L=="object"&&L!==null&&typeof L.message=="string"?String(L.message):String(L),error:L});if(!window.dispatchEvent(j))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",L);return}console.error(L)},st={map:P,forEach:function(L,j,Q){P(L,function(){j.apply(this,arguments)},Q)},count:function(L){var j=0;return P(L,function(){j++}),j},toArray:function(L){return P(L,function(j){return j})||[]},only:function(L){if(!A(L))throw Error("React.Children.only expected to receive a single React element child.");return L}};return Wt.Activity=p,Wt.Children=st,Wt.Component=S,Wt.Fragment=e,Wt.Profiler=i,Wt.PureComponent=k,Wt.StrictMode=s,Wt.Suspense=c,Wt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=_,Wt.__COMPILER_RUNTIME={__proto__:null,c:function(L){return _.H.useMemoCache(L)}},Wt.cache=function(L){return function(){return L.apply(null,arguments)}},Wt.cacheSignal=function(){return null},Wt.cloneElement=function(L,j,Q){if(L==null)throw Error("The argument must be a React element, but you passed "+L+".");var ct=x({},L.props),ut=L.key;if(j!=null)for(pt in j.key!==void 0&&(ut=""+j.key),j)!R.call(j,pt)||pt==="key"||pt==="__self"||pt==="__source"||pt==="ref"&&j.ref===void 0||(ct[pt]=j[pt]);var pt=arguments.length-2;if(pt===1)ct.children=Q;else if(1<pt){for(var vt=Array(pt),Et=0;Et<pt;Et++)vt[Et]=arguments[Et+2];ct.children=vt}return D(L.type,ut,ct)},Wt.createContext=function(L){return L={$$typeof:o,_currentValue:L,_currentValue2:L,_threadCount:0,Provider:null,Consumer:null},L.Provider=L,L.Consumer={$$typeof:r,_context:L},L},Wt.createElement=function(L,j,Q){var ct,ut={},pt=null;if(j!=null)for(ct in j.key!==void 0&&(pt=""+j.key),j)R.call(j,ct)&&ct!=="key"&&ct!=="__self"&&ct!=="__source"&&(ut[ct]=j[ct]);var vt=arguments.length-2;if(vt===1)ut.children=Q;else if(1<vt){for(var Et=Array(vt),Ct=0;Ct<vt;Ct++)Et[Ct]=arguments[Ct+2];ut.children=Et}if(L&&L.defaultProps)for(ct in vt=L.defaultProps,vt)ut[ct]===void 0&&(ut[ct]=vt[ct]);return D(L,pt,ut)},Wt.createRef=function(){return{current:null}},Wt.forwardRef=function(L){return{$$typeof:l,render:L}},Wt.isValidElement=A,Wt.lazy=function(L){return{$$typeof:d,_payload:{_status:-1,_result:L},_init:V}},Wt.memo=function(L,j){return{$$typeof:h,type:L,compare:j===void 0?null:j}},Wt.startTransition=function(L){var j=_.T,Q={};_.T=Q;try{var ct=L(),ut=_.S;ut!==null&&ut(Q,ct),typeof ct=="object"&&ct!==null&&typeof ct.then=="function"&&ct.then(N,K)}catch(pt){K(pt)}finally{j!==null&&Q.types!==null&&(j.types=Q.types),_.T=j}},Wt.unstable_useCacheRefresh=function(){return _.H.useCacheRefresh()},Wt.use=function(L){return _.H.use(L)},Wt.useActionState=function(L,j,Q){return _.H.useActionState(L,j,Q)},Wt.useCallback=function(L,j){return _.H.useCallback(L,j)},Wt.useContext=function(L){return _.H.useContext(L)},Wt.useDebugValue=function(){},Wt.useDeferredValue=function(L,j){return _.H.useDeferredValue(L,j)},Wt.useEffect=function(L,j){return _.H.useEffect(L,j)},Wt.useEffectEvent=function(L){return _.H.useEffectEvent(L)},Wt.useId=function(){return _.H.useId()},Wt.useImperativeHandle=function(L,j,Q){return _.H.useImperativeHandle(L,j,Q)},Wt.useInsertionEffect=function(L,j){return _.H.useInsertionEffect(L,j)},Wt.useLayoutEffect=function(L,j){return _.H.useLayoutEffect(L,j)},Wt.useMemo=function(L,j){return _.H.useMemo(L,j)},Wt.useOptimistic=function(L,j){return _.H.useOptimistic(L,j)},Wt.useReducer=function(L,j,Q){return _.H.useReducer(L,j,Q)},Wt.useRef=function(L){return _.H.useRef(L)},Wt.useState=function(L){return _.H.useState(L)},Wt.useSyncExternalStore=function(L,j,Q){return _.H.useSyncExternalStore(L,j,Q)},Wt.useTransition=function(){return _.H.useTransition()},Wt.version="19.2.3",Wt}var M$;function dw(){return M$||(M$=1,Jb.exports=wB()),Jb.exports}var St=dw();const SB=hw(St);var Zb={exports:{}},eh={},Qb={exports:{}},tx={};var F$;function CB(){return F$||(F$=1,(function(n){function t(z,P){var V=z.length;z.push(P);t:for(;0<V;){var K=V-1>>>1,st=z[K];if(0<i(st,P))z[K]=P,z[V]=st,V=K;else break t}}function e(z){return z.length===0?null:z[0]}function s(z){if(z.length===0)return null;var P=z[0],V=z.pop();if(V!==P){z[0]=V;t:for(var K=0,st=z.length,L=st>>>1;K<L;){var j=2*(K+1)-1,Q=z[j],ct=j+1,ut=z[ct];if(0>i(Q,V))ct<st&&0>i(ut,Q)?(z[K]=ut,z[ct]=V,K=ct):(z[K]=Q,z[j]=V,K=j);else if(ct<st&&0>i(ut,V))z[K]=ut,z[ct]=V,K=ct;else break t}}return P}function i(z,P){var V=z.sortIndex-P.sortIndex;return V!==0?V:z.id-P.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var o=Date,l=o.now();n.unstable_now=function(){return o.now()-l}}var c=[],h=[],d=1,p=null,m=3,y=!1,b=!1,x=!1,w=!1,S=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,k=typeof setImmediate<"u"?setImmediate:null;function $(z){for(var P=e(h);P!==null;){if(P.callback===null)s(h);else if(P.startTime<=z)s(h),P.sortIndex=P.expirationTime,t(c,P);else break;P=e(h)}}function E(z){if(x=!1,$(z),!b)if(e(c)!==null)b=!0,N||(N=!0,B());else{var P=e(h);P!==null&&X(E,P.startTime-z)}}var N=!1,_=-1,R=5,D=-1;function M(){return w?!0:!(n.unstable_now()-D<R)}function A(){if(w=!1,N){var z=n.unstable_now();D=z;var P=!0;try{t:{b=!1,x&&(x=!1,T(_),_=-1),y=!0;var V=m;try{e:{for($(z),p=e(c);p!==null&&!(p.expirationTime>z&&M());){var K=p.callback;if(typeof K=="function"){p.callback=null,m=p.priorityLevel;var st=K(p.expirationTime<=z);if(z=n.unstable_now(),typeof st=="function"){p.callback=st,$(z),P=!0;break e}p===e(c)&&s(c),$(z)}else s(c);p=e(c)}if(p!==null)P=!0;else{var L=e(h);L!==null&&X(E,L.startTime-z),P=!1}}break t}finally{p=null,m=V,y=!1}P=void 0}}finally{P?B():N=!1}}}var B;if(typeof k=="function")B=function(){k(A)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,J=H.port2;H.port1.onmessage=A,B=function(){J.postMessage(null)}}else B=function(){S(A,0)};function X(z,P){_=S(function(){z(n.unstable_now())},P)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(z){z.callback=null},n.unstable_forceFrameRate=function(z){0>z||125<z?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<z?Math.floor(1e3/z):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(z){switch(m){case 1:case 2:case 3:var P=3;break;default:P=m}var V=m;m=P;try{return z()}finally{m=V}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(z,P){switch(z){case 1:case 2:case 3:case 4:case 5:break;default:z=3}var V=m;m=z;try{return P()}finally{m=V}},n.unstable_scheduleCallback=function(z,P,V){var K=n.unstable_now();switch(typeof V=="object"&&V!==null?(V=V.delay,V=typeof V=="number"&&0<V?K+V:K):V=K,z){case 1:var st=-1;break;case 2:st=250;break;case 5:st=1073741823;break;case 4:st=1e4;break;default:st=5e3}return st=V+st,z={id:d++,callback:P,priorityLevel:z,startTime:V,expirationTime:st,sortIndex:-1},V>K?(z.sortIndex=V,t(h,z),e(c)===null&&z===e(h)&&(x?(T(_),_=-1):x=!0,X(E,V-K))):(z.sortIndex=st,t(c,z),b||y||(b=!0,N||(N=!0,B()))),z},n.unstable_shouldYield=M,n.unstable_wrapCallback=function(z){var P=m;return function(){var V=m;m=P;try{return z.apply(this,arguments)}finally{m=V}}}})(tx)),tx}var L$;function TB(){return L$||(L$=1,Qb.exports=CB()),Qb.exports}var ex={exports:{}},Zn={};var z$;function kB(){if(z$)return Zn;z$=1;var n=dw();function t(c){var h="https://react.dev/errors/"+c;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+c+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var s={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},i=Symbol.for("react.portal");function r(c,h,d){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:p==null?null:""+p,children:c,containerInfo:h,implementation:d}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function l(c,h){if(c==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return Zn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,Zn.createPortal=function(c,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(t(299));return r(c,h,null,d)},Zn.flushSync=function(c){var h=o.T,d=s.p;try{if(o.T=null,s.p=2,c)return c()}finally{o.T=h,s.p=d,s.d.f()}},Zn.preconnect=function(c,h){typeof c=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(c,h))},Zn.prefetchDNS=function(c){typeof c=="string"&&s.d.D(c)},Zn.preinit=function(c,h){if(typeof c=="string"&&h&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(c,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:p,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(c,{crossOrigin:p,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},Zn.preinitModule=function(c,h){if(typeof c=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=l(h.as,h.crossOrigin);s.d.M(c,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(c)},Zn.preload=function(c,h){if(typeof c=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,p=l(d,h.crossOrigin);s.d.L(c,d,{crossOrigin:p,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},Zn.preloadModule=function(c,h){if(typeof c=="string")if(h){var d=l(h.as,h.crossOrigin);s.d.m(c,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(c)},Zn.requestFormReset=function(c){s.d.r(c)},Zn.unstable_batchedUpdates=function(c,h){return c(h)},Zn.useFormState=function(c,h,d){return o.H.useFormState(c,h,d)},Zn.useFormStatus=function(){return o.H.useHostTransitionStatus()},Zn.version="19.2.3",Zn}var P$;function $B(){if(P$)return ex.exports;P$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),ex.exports=kB(),ex.exports}var B$;function EB(){if(B$)return eh;B$=1;var n=TB(),t=dw(),e=$B();function s(a){var u="https://react.dev/errors/"+a;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)u+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+a+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function r(a){var u=a,f=a;if(a.alternate)for(;u.return;)u=u.return;else{a=u;do u=a,(u.flags&4098)!==0&&(f=u.return),a=u.return;while(a)}return u.tag===3?f:null}function o(a){if(a.tag===13){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function l(a){if(a.tag===31){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function c(a){if(r(a)!==a)throw Error(s(188))}function h(a){var u=a.alternate;if(!u){if(u=r(a),u===null)throw Error(s(188));return u!==a?null:a}for(var f=a,g=u;;){var v=f.return;if(v===null)break;var C=v.alternate;if(C===null){if(g=v.return,g!==null){f=g;continue}break}if(v.child===C.child){for(C=v.child;C;){if(C===f)return c(v),a;if(C===g)return c(v),u;C=C.sibling}throw Error(s(188))}if(f.return!==g.return)f=v,g=C;else{for(var I=!1,O=v.child;O;){if(O===f){I=!0,f=v,g=C;break}if(O===g){I=!0,g=v,f=C;break}O=O.sibling}if(!I){for(O=C.child;O;){if(O===f){I=!0,f=C,g=v;break}if(O===g){I=!0,g=C,f=v;break}O=O.sibling}if(!I)throw Error(s(189))}}if(f.alternate!==g)throw Error(s(190))}if(f.tag!==3)throw Error(s(188));return f.stateNode.current===f?a:u}function d(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a;for(a=a.child;a!==null;){if(u=d(a),u!==null)return u;a=a.sibling}return null}var p=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),S=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),k=Symbol.for("react.context"),$=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),R=Symbol.for("react.lazy"),D=Symbol.for("react.activity"),M=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function B(a){return a===null||typeof a!="object"?null:(a=A&&a[A]||a["@@iterator"],typeof a=="function"?a:null)}var H=Symbol.for("react.client.reference");function J(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===H?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case x:return"Fragment";case S:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case N:return"SuspenseList";case D:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case b:return"Portal";case k:return a.displayName||"Context";case T:return(a._context.displayName||"Context")+".Consumer";case $:var u=a.render;return a=a.displayName,a||(a=u.displayName||u.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case _:return u=a.displayName||null,u!==null?u:J(a.type)||"Memo";case R:u=a._payload,a=a._init;try{return J(a(u))}catch{}}return null}var X=Array.isArray,z=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,P=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V={pending:!1,data:null,method:null,action:null},K=[],st=-1;function L(a){return{current:a}}function j(a){0>st||(a.current=K[st],K[st]=null,st--)}function Q(a,u){st++,K[st]=a.current,a.current=u}var ct=L(null),ut=L(null),pt=L(null),vt=L(null);function Et(a,u){switch(Q(pt,u),Q(ut,a),Q(ct,null),u.nodeType){case 9:case 11:a=(a=u.documentElement)&&(a=a.namespaceURI)?e$(a):0;break;default:if(a=u.tagName,u=u.namespaceURI)u=e$(u),a=n$(u,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}j(ct),Q(ct,a)}function Ct(){j(ct),j(ut),j(pt)}function Rt(a){a.memoizedState!==null&&Q(vt,a);var u=ct.current,f=n$(u,a.type);u!==f&&(Q(ut,a),Q(ct,f))}function zt(a){ut.current===a&&(j(ct),j(ut)),vt.current===a&&(j(vt),Yu._currentValue=V)}var ne,xe;function ge(a){if(ne===void 0)try{throw Error()}catch(f){var u=f.stack.trim().match(/\n( *(at )?)/);ne=u&&u[1]||"",xe=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ne+a+xe}var ye=!1;function ue(a,u){if(!a||ye)return"";ye=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(u){var yt=function(){throw Error()};if(Object.defineProperty(yt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(yt,[])}catch(ht){var lt=ht}Reflect.construct(a,[],yt)}else{try{yt.call()}catch(ht){lt=ht}a.call(yt.prototype)}}else{try{throw Error()}catch(ht){lt=ht}(yt=a())&&typeof yt.catch=="function"&&yt.catch(function(){})}}catch(ht){if(ht&&lt&&typeof ht.stack=="string")return[ht.stack,lt.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var v=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");v&&v.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var C=g.DetermineComponentFrameRoot(),I=C[0],O=C[1];if(I&&O){var G=I.split(`
`),ot=O.split(`
`);for(v=g=0;g<G.length&&!G[g].includes("DetermineComponentFrameRoot");)g++;for(;v<ot.length&&!ot[v].includes("DetermineComponentFrameRoot");)v++;if(g===G.length||v===ot.length)for(g=G.length-1,v=ot.length-1;1<=g&&0<=v&&G[g]!==ot[v];)v--;for(;1<=g&&0<=v;g--,v--)if(G[g]!==ot[v]){if(g!==1||v!==1)do if(g--,v--,0>v||G[g]!==ot[v]){var mt=`
`+G[g].replace(" at new "," at ");return a.displayName&&mt.includes("<anonymous>")&&(mt=mt.replace("<anonymous>",a.displayName)),mt}while(1<=g&&0<=v);break}}}finally{ye=!1,Error.prepareStackTrace=f}return(f=a?a.displayName||a.name:"")?ge(f):""}function Oe(a,u){switch(a.tag){case 26:case 27:case 5:return ge(a.type);case 16:return ge("Lazy");case 13:return a.child!==u&&u!==null?ge("Suspense Fallback"):ge("Suspense");case 19:return ge("SuspenseList");case 0:case 15:return ue(a.type,!1);case 11:return ue(a.type.render,!1);case 1:return ue(a.type,!0);case 31:return ge("Activity");default:return""}}function ke(a){try{var u="",f=null;do u+=Oe(a,f),f=a,a=a.return;while(a);return u}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var Rs=Object.prototype.hasOwnProperty,Ke=n.unstable_scheduleCallback,Js=n.unstable_cancelCallback,os=n.unstable_shouldYield,br=n.unstable_requestPaint,Le=n.unstable_now,Si=n.unstable_getCurrentPriorityLevel,Ci=n.unstable_ImmediatePriority,Ti=n.unstable_UserBlockingPriority,Ds=n.unstable_NormalPriority,ta=n.unstable_LowPriority,gl=n.unstable_IdlePriority,lu=n.log,Ly=n.unstable_setDisableYieldValue,Wi=null,as=null;function Hi(a){if(typeof lu=="function"&&Ly(a),as&&typeof as.setStrictMode=="function")try{as.setStrictMode(Wi,a)}catch{}}var Os=Math.clz32?Math.clz32:sz,ez=Math.log,nz=Math.LN2;function sz(a){return a>>>=0,a===0?32:31-(ez(a)/nz|0)|0}var wf=256,Sf=262144,Cf=4194304;function ea(a){var u=a&42;if(u!==0)return u;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function Tf(a,u,f){var g=a.pendingLanes;if(g===0)return 0;var v=0,C=a.suspendedLanes,I=a.pingedLanes;a=a.warmLanes;var O=g&134217727;return O!==0?(g=O&~C,g!==0?v=ea(g):(I&=O,I!==0?v=ea(I):f||(f=O&~a,f!==0&&(v=ea(f))))):(O=g&~C,O!==0?v=ea(O):I!==0?v=ea(I):f||(f=g&~a,f!==0&&(v=ea(f)))),v===0?0:u!==0&&u!==v&&(u&C)===0&&(C=v&-v,f=u&-u,C>=f||C===32&&(f&4194048)!==0)?u:v}function cu(a,u){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&u)===0}function iz(a,u){switch(a){case 1:case 2:case 4:case 8:case 64:return u+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function FC(){var a=Cf;return Cf<<=1,(Cf&62914560)===0&&(Cf=4194304),a}function zy(a){for(var u=[],f=0;31>f;f++)u.push(a);return u}function uu(a,u){a.pendingLanes|=u,u!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function rz(a,u,f,g,v,C){var I=a.pendingLanes;a.pendingLanes=f,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=f,a.entangledLanes&=f,a.errorRecoveryDisabledLanes&=f,a.shellSuspendCounter=0;var O=a.entanglements,G=a.expirationTimes,ot=a.hiddenUpdates;for(f=I&~f;0<f;){var mt=31-Os(f),yt=1<<mt;O[mt]=0,G[mt]=-1;var lt=ot[mt];if(lt!==null)for(ot[mt]=null,mt=0;mt<lt.length;mt++){var ht=lt[mt];ht!==null&&(ht.lane&=-536870913)}f&=~yt}g!==0&&LC(a,g,0),C!==0&&v===0&&a.tag!==0&&(a.suspendedLanes|=C&~(I&~u))}function LC(a,u,f){a.pendingLanes|=u,a.suspendedLanes&=~u;var g=31-Os(u);a.entangledLanes|=u,a.entanglements[g]=a.entanglements[g]|1073741824|f&261930}function zC(a,u){var f=a.entangledLanes|=u;for(a=a.entanglements;f;){var g=31-Os(f),v=1<<g;v&u|a[g]&u&&(a[g]|=u),f&=~v}}function PC(a,u){var f=u&-u;return f=(f&42)!==0?1:Py(f),(f&(a.suspendedLanes|u))!==0?0:f}function Py(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function By(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function BC(){var a=P.p;return a!==0?a:(a=window.event,a===void 0?32:k$(a.type))}function VC(a,u){var f=P.p;try{return P.p=a,u()}finally{P.p=f}}var Zr=Math.random().toString(36).slice(2),zn="__reactFiber$"+Zr,ys="__reactProps$"+Zr,yl="__reactContainer$"+Zr,Vy="__reactEvents$"+Zr,oz="__reactListeners$"+Zr,az="__reactHandles$"+Zr,UC="__reactResources$"+Zr,hu="__reactMarker$"+Zr;function Uy(a){delete a[zn],delete a[ys],delete a[Vy],delete a[oz],delete a[az]}function bl(a){var u=a[zn];if(u)return u;for(var f=a.parentNode;f;){if(u=f[yl]||f[zn]){if(f=u.alternate,u.child!==null||f!==null&&f.child!==null)for(a=c$(a);a!==null;){if(f=a[zn])return f;a=c$(a)}return u}a=f,f=a.parentNode}return null}function xl(a){if(a=a[zn]||a[yl]){var u=a.tag;if(u===5||u===6||u===13||u===31||u===26||u===27||u===3)return a}return null}function du(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a.stateNode;throw Error(s(33))}function vl(a){var u=a[UC];return u||(u=a[UC]={hoistableStyles:new Map,hoistableScripts:new Map}),u}function _n(a){a[hu]=!0}var jC=new Set,GC={};function na(a,u){wl(a,u),wl(a+"Capture",u)}function wl(a,u){for(GC[a]=u,a=0;a<u.length;a++)jC.add(u[a])}var lz=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),WC={},HC={};function cz(a){return Rs.call(HC,a)?!0:Rs.call(WC,a)?!1:lz.test(a)?HC[a]=!0:(WC[a]=!0,!1)}function kf(a,u,f){if(cz(u))if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":a.removeAttribute(u);return;case"boolean":var g=u.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){a.removeAttribute(u);return}}a.setAttribute(u,""+f)}}function $f(a,u,f){if(f===null)a.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(u);return}a.setAttribute(u,""+f)}}function xr(a,u,f,g){if(g===null)a.removeAttribute(f);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(f);return}a.setAttributeNS(u,f,""+g)}}function Zs(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function qC(a){var u=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(u==="checkbox"||u==="radio")}function uz(a,u,f){var g=Object.getOwnPropertyDescriptor(a.constructor.prototype,u);if(!a.hasOwnProperty(u)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var v=g.get,C=g.set;return Object.defineProperty(a,u,{configurable:!0,get:function(){return v.call(this)},set:function(I){f=""+I,C.call(this,I)}}),Object.defineProperty(a,u,{enumerable:g.enumerable}),{getValue:function(){return f},setValue:function(I){f=""+I},stopTracking:function(){a._valueTracker=null,delete a[u]}}}}function jy(a){if(!a._valueTracker){var u=qC(a)?"checked":"value";a._valueTracker=uz(a,u,""+a[u])}}function KC(a){if(!a)return!1;var u=a._valueTracker;if(!u)return!0;var f=u.getValue(),g="";return a&&(g=qC(a)?a.checked?"true":"false":a.value),a=g,a!==f?(u.setValue(a),!0):!1}function Ef(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var hz=/[\n"\\]/g;function Qs(a){return a.replace(hz,function(u){return"\\"+u.charCodeAt(0).toString(16)+" "})}function Gy(a,u,f,g,v,C,I,O){a.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?a.type=I:a.removeAttribute("type"),u!=null?I==="number"?(u===0&&a.value===""||a.value!=u)&&(a.value=""+Zs(u)):a.value!==""+Zs(u)&&(a.value=""+Zs(u)):I!=="submit"&&I!=="reset"||a.removeAttribute("value"),u!=null?Wy(a,I,Zs(u)):f!=null?Wy(a,I,Zs(f)):g!=null&&a.removeAttribute("value"),v==null&&C!=null&&(a.defaultChecked=!!C),v!=null&&(a.checked=v&&typeof v!="function"&&typeof v!="symbol"),O!=null&&typeof O!="function"&&typeof O!="symbol"&&typeof O!="boolean"?a.name=""+Zs(O):a.removeAttribute("name")}function XC(a,u,f,g,v,C,I,O){if(C!=null&&typeof C!="function"&&typeof C!="symbol"&&typeof C!="boolean"&&(a.type=C),u!=null||f!=null){if(!(C!=="submit"&&C!=="reset"||u!=null)){jy(a);return}f=f!=null?""+Zs(f):"",u=u!=null?""+Zs(u):f,O||u===a.value||(a.value=u),a.defaultValue=u}g=g??v,g=typeof g!="function"&&typeof g!="symbol"&&!!g,a.checked=O?a.checked:!!g,a.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(a.name=I),jy(a)}function Wy(a,u,f){u==="number"&&Ef(a.ownerDocument)===a||a.defaultValue===""+f||(a.defaultValue=""+f)}function Sl(a,u,f,g){if(a=a.options,u){u={};for(var v=0;v<f.length;v++)u["$"+f[v]]=!0;for(f=0;f<a.length;f++)v=u.hasOwnProperty("$"+a[f].value),a[f].selected!==v&&(a[f].selected=v),v&&g&&(a[f].defaultSelected=!0)}else{for(f=""+Zs(f),u=null,v=0;v<a.length;v++){if(a[v].value===f){a[v].selected=!0,g&&(a[v].defaultSelected=!0);return}u!==null||a[v].disabled||(u=a[v])}u!==null&&(u.selected=!0)}}function YC(a,u,f){if(u!=null&&(u=""+Zs(u),u!==a.value&&(a.value=u),f==null)){a.defaultValue!==u&&(a.defaultValue=u);return}a.defaultValue=f!=null?""+Zs(f):""}function JC(a,u,f,g){if(u==null){if(g!=null){if(f!=null)throw Error(s(92));if(X(g)){if(1<g.length)throw Error(s(93));g=g[0]}f=g}f==null&&(f=""),u=f}f=Zs(u),a.defaultValue=f,g=a.textContent,g===f&&g!==""&&g!==null&&(a.value=g),jy(a)}function Cl(a,u){if(u){var f=a.firstChild;if(f&&f===a.lastChild&&f.nodeType===3){f.nodeValue=u;return}}a.textContent=u}var dz=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function ZC(a,u,f){var g=u.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?g?a.setProperty(u,""):u==="float"?a.cssFloat="":a[u]="":g?a.setProperty(u,f):typeof f!="number"||f===0||dz.has(u)?u==="float"?a.cssFloat=f:a[u]=(""+f).trim():a[u]=f+"px"}function QC(a,u,f){if(u!=null&&typeof u!="object")throw Error(s(62));if(a=a.style,f!=null){for(var g in f)!f.hasOwnProperty(g)||u!=null&&u.hasOwnProperty(g)||(g.indexOf("--")===0?a.setProperty(g,""):g==="float"?a.cssFloat="":a[g]="");for(var v in u)g=u[v],u.hasOwnProperty(v)&&f[v]!==g&&ZC(a,v,g)}else for(var C in u)u.hasOwnProperty(C)&&ZC(a,C,u[C])}function Hy(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var fz=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),pz=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function If(a){return pz.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function vr(){}var qy=null;function Ky(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var Tl=null,kl=null;function tT(a){var u=xl(a);if(u&&(a=u.stateNode)){var f=a[ys]||null;t:switch(a=u.stateNode,u.type){case"input":if(Gy(a,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),u=f.name,f.type==="radio"&&u!=null){for(f=a;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+Qs(""+u)+'"][type="radio"]'),u=0;u<f.length;u++){var g=f[u];if(g!==a&&g.form===a.form){var v=g[ys]||null;if(!v)throw Error(s(90));Gy(g,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name)}}for(u=0;u<f.length;u++)g=f[u],g.form===a.form&&KC(g)}break t;case"textarea":YC(a,f.value,f.defaultValue);break t;case"select":u=f.value,u!=null&&Sl(a,!!f.multiple,u,!1)}}}var Xy=!1;function eT(a,u,f){if(Xy)return a(u,f);Xy=!0;try{var g=a(u);return g}finally{if(Xy=!1,(Tl!==null||kl!==null)&&(mp(),Tl&&(u=Tl,a=kl,kl=Tl=null,tT(u),a)))for(u=0;u<a.length;u++)tT(a[u])}}function fu(a,u){var f=a.stateNode;if(f===null)return null;var g=f[ys]||null;if(g===null)return null;f=g[u];t:switch(u){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(a=a.type,g=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!g;break t;default:a=!1}if(a)return null;if(f&&typeof f!="function")throw Error(s(231,u,typeof f));return f}var wr=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Yy=!1;if(wr)try{var pu={};Object.defineProperty(pu,"passive",{get:function(){Yy=!0}}),window.addEventListener("test",pu,pu),window.removeEventListener("test",pu,pu)}catch{Yy=!1}var Qr=null,Jy=null,Nf=null;function nT(){if(Nf)return Nf;var a,u=Jy,f=u.length,g,v="value"in Qr?Qr.value:Qr.textContent,C=v.length;for(a=0;a<f&&u[a]===v[a];a++);var I=f-a;for(g=1;g<=I&&u[f-g]===v[C-g];g++);return Nf=v.slice(a,1<g?1-g:void 0)}function Af(a){var u=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&u===13&&(a=13)):a=u,a===10&&(a=13),32<=a||a===13?a:0}function _f(){return!0}function sT(){return!1}function bs(a){function u(f,g,v,C,I){this._reactName=f,this._targetInst=v,this.type=g,this.nativeEvent=C,this.target=I,this.currentTarget=null;for(var O in a)a.hasOwnProperty(O)&&(f=a[O],this[O]=f?f(C):C[O]);return this.isDefaultPrevented=(C.defaultPrevented!=null?C.defaultPrevented:C.returnValue===!1)?_f:sT,this.isPropagationStopped=sT,this}return p(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=_f)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=_f)},persist:function(){},isPersistent:_f}),u}var sa={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Rf=bs(sa),mu=p({},sa,{view:0,detail:0}),mz=bs(mu),Zy,Qy,gu,Df=p({},mu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:e0,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==gu&&(gu&&a.type==="mousemove"?(Zy=a.screenX-gu.screenX,Qy=a.screenY-gu.screenY):Qy=Zy=0,gu=a),Zy)},movementY:function(a){return"movementY"in a?a.movementY:Qy}}),iT=bs(Df),gz=p({},Df,{dataTransfer:0}),yz=bs(gz),bz=p({},mu,{relatedTarget:0}),t0=bs(bz),xz=p({},sa,{animationName:0,elapsedTime:0,pseudoElement:0}),vz=bs(xz),wz=p({},sa,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Sz=bs(wz),Cz=p({},sa,{data:0}),rT=bs(Cz),Tz={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kz={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},$z={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Ez(a){var u=this.nativeEvent;return u.getModifierState?u.getModifierState(a):(a=$z[a])?!!u[a]:!1}function e0(){return Ez}var Iz=p({},mu,{key:function(a){if(a.key){var u=Tz[a.key]||a.key;if(u!=="Unidentified")return u}return a.type==="keypress"?(a=Af(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?kz[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:e0,charCode:function(a){return a.type==="keypress"?Af(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?Af(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),Nz=bs(Iz),Az=p({},Df,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),oT=bs(Az),_z=p({},mu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:e0}),Rz=bs(_z),Dz=p({},sa,{propertyName:0,elapsedTime:0,pseudoElement:0}),Oz=bs(Dz),Mz=p({},Df,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Fz=bs(Mz),Lz=p({},sa,{newState:0,oldState:0}),zz=bs(Lz),Pz=[9,13,27,32],n0=wr&&"CompositionEvent"in window,yu=null;wr&&"documentMode"in document&&(yu=document.documentMode);var Bz=wr&&"TextEvent"in window&&!yu,aT=wr&&(!n0||yu&&8<yu&&11>=yu),lT=" ",cT=!1;function uT(a,u){switch(a){case"keyup":return Pz.indexOf(u.keyCode)!==-1;case"keydown":return u.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function hT(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var $l=!1;function Vz(a,u){switch(a){case"compositionend":return hT(u);case"keypress":return u.which!==32?null:(cT=!0,lT);case"textInput":return a=u.data,a===lT&&cT?null:a;default:return null}}function Uz(a,u){if($l)return a==="compositionend"||!n0&&uT(a,u)?(a=nT(),Nf=Jy=Qr=null,$l=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(u.ctrlKey||u.altKey||u.metaKey)||u.ctrlKey&&u.altKey){if(u.char&&1<u.char.length)return u.char;if(u.which)return String.fromCharCode(u.which)}return null;case"compositionend":return aT&&u.locale!=="ko"?null:u.data;default:return null}}var jz={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function dT(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u==="input"?!!jz[a.type]:u==="textarea"}function fT(a,u,f,g){Tl?kl?kl.push(g):kl=[g]:Tl=g,u=Sp(u,"onChange"),0<u.length&&(f=new Rf("onChange","change",null,f,g),a.push({event:f,listeners:u}))}var bu=null,xu=null;function Gz(a){X2(a,0)}function Of(a){var u=du(a);if(KC(u))return a}function pT(a,u){if(a==="change")return u}var mT=!1;if(wr){var s0;if(wr){var i0="oninput"in document;if(!i0){var gT=document.createElement("div");gT.setAttribute("oninput","return;"),i0=typeof gT.oninput=="function"}s0=i0}else s0=!1;mT=s0&&(!document.documentMode||9<document.documentMode)}function yT(){bu&&(bu.detachEvent("onpropertychange",bT),xu=bu=null)}function bT(a){if(a.propertyName==="value"&&Of(xu)){var u=[];fT(u,xu,a,Ky(a)),eT(Gz,u)}}function Wz(a,u,f){a==="focusin"?(yT(),bu=u,xu=f,bu.attachEvent("onpropertychange",bT)):a==="focusout"&&yT()}function Hz(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Of(xu)}function qz(a,u){if(a==="click")return Of(u)}function Kz(a,u){if(a==="input"||a==="change")return Of(u)}function Xz(a,u){return a===u&&(a!==0||1/a===1/u)||a!==a&&u!==u}var Ms=typeof Object.is=="function"?Object.is:Xz;function vu(a,u){if(Ms(a,u))return!0;if(typeof a!="object"||a===null||typeof u!="object"||u===null)return!1;var f=Object.keys(a),g=Object.keys(u);if(f.length!==g.length)return!1;for(g=0;g<f.length;g++){var v=f[g];if(!Rs.call(u,v)||!Ms(a[v],u[v]))return!1}return!0}function xT(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function vT(a,u){var f=xT(a);a=0;for(var g;f;){if(f.nodeType===3){if(g=a+f.textContent.length,a<=u&&g>=u)return{node:f,offset:u-a};a=g}t:{for(;f;){if(f.nextSibling){f=f.nextSibling;break t}f=f.parentNode}f=void 0}f=xT(f)}}function wT(a,u){return a&&u?a===u?!0:a&&a.nodeType===3?!1:u&&u.nodeType===3?wT(a,u.parentNode):"contains"in a?a.contains(u):a.compareDocumentPosition?!!(a.compareDocumentPosition(u)&16):!1:!1}function ST(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var u=Ef(a.document);u instanceof a.HTMLIFrameElement;){try{var f=typeof u.contentWindow.location.href=="string"}catch{f=!1}if(f)a=u.contentWindow;else break;u=Ef(a.document)}return u}function r0(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u&&(u==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||u==="textarea"||a.contentEditable==="true")}var Yz=wr&&"documentMode"in document&&11>=document.documentMode,El=null,o0=null,wu=null,a0=!1;function CT(a,u,f){var g=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;a0||El==null||El!==Ef(g)||(g=El,"selectionStart"in g&&r0(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),wu&&vu(wu,g)||(wu=g,g=Sp(o0,"onSelect"),0<g.length&&(u=new Rf("onSelect","select",null,u,f),a.push({event:u,listeners:g}),u.target=El)))}function ia(a,u){var f={};return f[a.toLowerCase()]=u.toLowerCase(),f["Webkit"+a]="webkit"+u,f["Moz"+a]="moz"+u,f}var Il={animationend:ia("Animation","AnimationEnd"),animationiteration:ia("Animation","AnimationIteration"),animationstart:ia("Animation","AnimationStart"),transitionrun:ia("Transition","TransitionRun"),transitionstart:ia("Transition","TransitionStart"),transitioncancel:ia("Transition","TransitionCancel"),transitionend:ia("Transition","TransitionEnd")},l0={},TT={};wr&&(TT=document.createElement("div").style,"AnimationEvent"in window||(delete Il.animationend.animation,delete Il.animationiteration.animation,delete Il.animationstart.animation),"TransitionEvent"in window||delete Il.transitionend.transition);function ra(a){if(l0[a])return l0[a];if(!Il[a])return a;var u=Il[a],f;for(f in u)if(u.hasOwnProperty(f)&&f in TT)return l0[a]=u[f];return a}var kT=ra("animationend"),$T=ra("animationiteration"),ET=ra("animationstart"),Jz=ra("transitionrun"),Zz=ra("transitionstart"),Qz=ra("transitioncancel"),IT=ra("transitionend"),NT=new Map,c0="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");c0.push("scrollEnd");function ki(a,u){NT.set(a,u),na(u,[a])}var Mf=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var u=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(u))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},ti=[],Nl=0,u0=0;function Ff(){for(var a=Nl,u=u0=Nl=0;u<a;){var f=ti[u];ti[u++]=null;var g=ti[u];ti[u++]=null;var v=ti[u];ti[u++]=null;var C=ti[u];if(ti[u++]=null,g!==null&&v!==null){var I=g.pending;I===null?v.next=v:(v.next=I.next,I.next=v),g.pending=v}C!==0&&AT(f,v,C)}}function Lf(a,u,f,g){ti[Nl++]=a,ti[Nl++]=u,ti[Nl++]=f,ti[Nl++]=g,u0|=g,a.lanes|=g,a=a.alternate,a!==null&&(a.lanes|=g)}function h0(a,u,f,g){return Lf(a,u,f,g),zf(a)}function oa(a,u){return Lf(a,null,null,u),zf(a)}function AT(a,u,f){a.lanes|=f;var g=a.alternate;g!==null&&(g.lanes|=f);for(var v=!1,C=a.return;C!==null;)C.childLanes|=f,g=C.alternate,g!==null&&(g.childLanes|=f),C.tag===22&&(a=C.stateNode,a===null||a._visibility&1||(v=!0)),a=C,C=C.return;return a.tag===3?(C=a.stateNode,v&&u!==null&&(v=31-Os(f),a=C.hiddenUpdates,g=a[v],g===null?a[v]=[u]:g.push(u),u.lane=f|536870912),C):null}function zf(a){if(50<ju)throw ju=0,vb=null,Error(s(185));for(var u=a.return;u!==null;)a=u,u=a.return;return a.tag===3?a.stateNode:null}var Al={};function tP(a,u,f,g){this.tag=a,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=u,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Fs(a,u,f,g){return new tP(a,u,f,g)}function d0(a){return a=a.prototype,!(!a||!a.isReactComponent)}function Sr(a,u){var f=a.alternate;return f===null?(f=Fs(a.tag,u,a.key,a.mode),f.elementType=a.elementType,f.type=a.type,f.stateNode=a.stateNode,f.alternate=a,a.alternate=f):(f.pendingProps=u,f.type=a.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=a.flags&65011712,f.childLanes=a.childLanes,f.lanes=a.lanes,f.child=a.child,f.memoizedProps=a.memoizedProps,f.memoizedState=a.memoizedState,f.updateQueue=a.updateQueue,u=a.dependencies,f.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext},f.sibling=a.sibling,f.index=a.index,f.ref=a.ref,f.refCleanup=a.refCleanup,f}function _T(a,u){a.flags&=65011714;var f=a.alternate;return f===null?(a.childLanes=0,a.lanes=u,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=f.childLanes,a.lanes=f.lanes,a.child=f.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=f.memoizedProps,a.memoizedState=f.memoizedState,a.updateQueue=f.updateQueue,a.type=f.type,u=f.dependencies,a.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),a}function Pf(a,u,f,g,v,C){var I=0;if(g=a,typeof a=="function")d0(a)&&(I=1);else if(typeof a=="string")I=rB(a,f,ct.current)?26:a==="html"||a==="head"||a==="body"?27:5;else t:switch(a){case D:return a=Fs(31,f,u,v),a.elementType=D,a.lanes=C,a;case x:return aa(f.children,v,C,u);case w:I=8,v|=24;break;case S:return a=Fs(12,f,u,v|2),a.elementType=S,a.lanes=C,a;case E:return a=Fs(13,f,u,v),a.elementType=E,a.lanes=C,a;case N:return a=Fs(19,f,u,v),a.elementType=N,a.lanes=C,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case k:I=10;break t;case T:I=9;break t;case $:I=11;break t;case _:I=14;break t;case R:I=16,g=null;break t}I=29,f=Error(s(130,a===null?"null":typeof a,"")),g=null}return u=Fs(I,f,u,v),u.elementType=a,u.type=g,u.lanes=C,u}function aa(a,u,f,g){return a=Fs(7,a,g,u),a.lanes=f,a}function f0(a,u,f){return a=Fs(6,a,null,u),a.lanes=f,a}function RT(a){var u=Fs(18,null,null,0);return u.stateNode=a,u}function p0(a,u,f){return u=Fs(4,a.children!==null?a.children:[],a.key,u),u.lanes=f,u.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},u}var DT=new WeakMap;function ei(a,u){if(typeof a=="object"&&a!==null){var f=DT.get(a);return f!==void 0?f:(u={value:a,source:u,stack:ke(u)},DT.set(a,u),u)}return{value:a,source:u,stack:ke(u)}}var _l=[],Rl=0,Bf=null,Su=0,ni=[],si=0,to=null,qi=1,Ki="";function Cr(a,u){_l[Rl++]=Su,_l[Rl++]=Bf,Bf=a,Su=u}function OT(a,u,f){ni[si++]=qi,ni[si++]=Ki,ni[si++]=to,to=a;var g=qi;a=Ki;var v=32-Os(g)-1;g&=~(1<<v),f+=1;var C=32-Os(u)+v;if(30<C){var I=v-v%5;C=(g&(1<<I)-1).toString(32),g>>=I,v-=I,qi=1<<32-Os(u)+v|f<<v|g,Ki=C+a}else qi=1<<C|f<<v|g,Ki=a}function m0(a){a.return!==null&&(Cr(a,1),OT(a,1,0))}function g0(a){for(;a===Bf;)Bf=_l[--Rl],_l[Rl]=null,Su=_l[--Rl],_l[Rl]=null;for(;a===to;)to=ni[--si],ni[si]=null,Ki=ni[--si],ni[si]=null,qi=ni[--si],ni[si]=null}function MT(a,u){ni[si++]=qi,ni[si++]=Ki,ni[si++]=to,qi=u.id,Ki=u.overflow,to=a}var Pn=null,ze=null,re=!1,eo=null,ii=!1,y0=Error(s(519));function no(a){var u=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Cu(ei(u,a)),y0}function FT(a){var u=a.stateNode,f=a.type,g=a.memoizedProps;switch(u[zn]=a,u[ys]=g,f){case"dialog":ee("cancel",u),ee("close",u);break;case"iframe":case"object":case"embed":ee("load",u);break;case"video":case"audio":for(f=0;f<Wu.length;f++)ee(Wu[f],u);break;case"source":ee("error",u);break;case"img":case"image":case"link":ee("error",u),ee("load",u);break;case"details":ee("toggle",u);break;case"input":ee("invalid",u),XC(u,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":ee("invalid",u);break;case"textarea":ee("invalid",u),JC(u,g.value,g.defaultValue,g.children)}f=g.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||u.textContent===""+f||g.suppressHydrationWarning===!0||Q2(u.textContent,f)?(g.popover!=null&&(ee("beforetoggle",u),ee("toggle",u)),g.onScroll!=null&&ee("scroll",u),g.onScrollEnd!=null&&ee("scrollend",u),g.onClick!=null&&(u.onclick=vr),u=!0):u=!1,u||no(a,!0)}function LT(a){for(Pn=a.return;Pn;)switch(Pn.tag){case 5:case 31:case 13:ii=!1;return;case 27:case 3:ii=!0;return;default:Pn=Pn.return}}function Dl(a){if(a!==Pn)return!1;if(!re)return LT(a),re=!0,!1;var u=a.tag,f;if((f=u!==3&&u!==27)&&((f=u===5)&&(f=a.type,f=!(f!=="form"&&f!=="button")||Mb(a.type,a.memoizedProps)),f=!f),f&&ze&&no(a),LT(a),u===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));ze=l$(a)}else if(u===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(317));ze=l$(a)}else u===27?(u=ze,yo(a.type)?(a=Bb,Bb=null,ze=a):ze=u):ze=Pn?oi(a.stateNode.nextSibling):null;return!0}function la(){ze=Pn=null,re=!1}function b0(){var a=eo;return a!==null&&(Ss===null?Ss=a:Ss.push.apply(Ss,a),eo=null),a}function Cu(a){eo===null?eo=[a]:eo.push(a)}var x0=L(null),ca=null,Tr=null;function so(a,u,f){Q(x0,u._currentValue),u._currentValue=f}function kr(a){a._currentValue=x0.current,j(x0)}function v0(a,u,f){for(;a!==null;){var g=a.alternate;if((a.childLanes&u)!==u?(a.childLanes|=u,g!==null&&(g.childLanes|=u)):g!==null&&(g.childLanes&u)!==u&&(g.childLanes|=u),a===f)break;a=a.return}}function w0(a,u,f,g){var v=a.child;for(v!==null&&(v.return=a);v!==null;){var C=v.dependencies;if(C!==null){var I=v.child;C=C.firstContext;t:for(;C!==null;){var O=C;C=v;for(var G=0;G<u.length;G++)if(O.context===u[G]){C.lanes|=f,O=C.alternate,O!==null&&(O.lanes|=f),v0(C.return,f,a),g||(I=null);break t}C=O.next}}else if(v.tag===18){if(I=v.return,I===null)throw Error(s(341));I.lanes|=f,C=I.alternate,C!==null&&(C.lanes|=f),v0(I,f,a),I=null}else I=v.child;if(I!==null)I.return=v;else for(I=v;I!==null;){if(I===a){I=null;break}if(v=I.sibling,v!==null){v.return=I.return,I=v;break}I=I.return}v=I}}function Ol(a,u,f,g){a=null;for(var v=u,C=!1;v!==null;){if(!C){if((v.flags&524288)!==0)C=!0;else if((v.flags&262144)!==0)break}if(v.tag===10){var I=v.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var O=v.type;Ms(v.pendingProps.value,I.value)||(a!==null?a.push(O):a=[O])}}else if(v===vt.current){if(I=v.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==v.memoizedState.memoizedState&&(a!==null?a.push(Yu):a=[Yu])}v=v.return}a!==null&&w0(u,a,f,g),u.flags|=262144}function Vf(a){for(a=a.firstContext;a!==null;){if(!Ms(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function ua(a){ca=a,Tr=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function Bn(a){return zT(ca,a)}function Uf(a,u){return ca===null&&ua(a),zT(a,u)}function zT(a,u){var f=u._currentValue;if(u={context:u,memoizedValue:f,next:null},Tr===null){if(a===null)throw Error(s(308));Tr=u,a.dependencies={lanes:0,firstContext:u},a.flags|=524288}else Tr=Tr.next=u;return f}var eP=typeof AbortController<"u"?AbortController:function(){var a=[],u=this.signal={aborted:!1,addEventListener:function(f,g){a.push(g)}};this.abort=function(){u.aborted=!0,a.forEach(function(f){return f()})}},nP=n.unstable_scheduleCallback,sP=n.unstable_NormalPriority,un={$$typeof:k,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function S0(){return{controller:new eP,data:new Map,refCount:0}}function Tu(a){a.refCount--,a.refCount===0&&nP(sP,function(){a.controller.abort()})}var ku=null,C0=0,Ml=0,Fl=null;function iP(a,u){if(ku===null){var f=ku=[];C0=0,Ml=$b(),Fl={status:"pending",value:void 0,then:function(g){f.push(g)}}}return C0++,u.then(PT,PT),u}function PT(){if(--C0===0&&ku!==null){Fl!==null&&(Fl.status="fulfilled");var a=ku;ku=null,Ml=0,Fl=null;for(var u=0;u<a.length;u++)(0,a[u])()}}function rP(a,u){var f=[],g={status:"pending",value:null,reason:null,then:function(v){f.push(v)}};return a.then(function(){g.status="fulfilled",g.value=u;for(var v=0;v<f.length;v++)(0,f[v])(u)},function(v){for(g.status="rejected",g.reason=v,v=0;v<f.length;v++)(0,f[v])(void 0)}),g}var BT=z.S;z.S=function(a,u){C2=Le(),typeof u=="object"&&u!==null&&typeof u.then=="function"&&iP(a,u),BT!==null&&BT(a,u)};var ha=L(null);function T0(){var a=ha.current;return a!==null?a:Ae.pooledCache}function jf(a,u){u===null?Q(ha,ha.current):Q(ha,u.pool)}function VT(){var a=T0();return a===null?null:{parent:un._currentValue,pool:a}}var Ll=Error(s(460)),k0=Error(s(474)),Gf=Error(s(542)),Wf={then:function(){}};function UT(a){return a=a.status,a==="fulfilled"||a==="rejected"}function jT(a,u,f){switch(f=a[f],f===void 0?a.push(u):f!==u&&(u.then(vr,vr),u=f),u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,WT(a),a;default:if(typeof u.status=="string")u.then(vr,vr);else{if(a=Ae,a!==null&&100<a.shellSuspendCounter)throw Error(s(482));a=u,a.status="pending",a.then(function(g){if(u.status==="pending"){var v=u;v.status="fulfilled",v.value=g}},function(g){if(u.status==="pending"){var v=u;v.status="rejected",v.reason=g}})}switch(u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,WT(a),a}throw fa=u,Ll}}function da(a){try{var u=a._init;return u(a._payload)}catch(f){throw f!==null&&typeof f=="object"&&typeof f.then=="function"?(fa=f,Ll):f}}var fa=null;function GT(){if(fa===null)throw Error(s(459));var a=fa;return fa=null,a}function WT(a){if(a===Ll||a===Gf)throw Error(s(483))}var zl=null,$u=0;function Hf(a){var u=$u;return $u+=1,zl===null&&(zl=[]),jT(zl,a,u)}function Eu(a,u){u=u.props.ref,a.ref=u!==void 0?u:null}function qf(a,u){throw u.$$typeof===m?Error(s(525)):(a=Object.prototype.toString.call(u),Error(s(31,a==="[object Object]"?"object with keys {"+Object.keys(u).join(", ")+"}":a)))}function HT(a){function u(nt,q){if(a){var rt=nt.deletions;rt===null?(nt.deletions=[q],nt.flags|=16):rt.push(q)}}function f(nt,q){if(!a)return null;for(;q!==null;)u(nt,q),q=q.sibling;return null}function g(nt){for(var q=new Map;nt!==null;)nt.key!==null?q.set(nt.key,nt):q.set(nt.index,nt),nt=nt.sibling;return q}function v(nt,q){return nt=Sr(nt,q),nt.index=0,nt.sibling=null,nt}function C(nt,q,rt){return nt.index=rt,a?(rt=nt.alternate,rt!==null?(rt=rt.index,rt<q?(nt.flags|=67108866,q):rt):(nt.flags|=67108866,q)):(nt.flags|=1048576,q)}function I(nt){return a&&nt.alternate===null&&(nt.flags|=67108866),nt}function O(nt,q,rt,gt){return q===null||q.tag!==6?(q=f0(rt,nt.mode,gt),q.return=nt,q):(q=v(q,rt),q.return=nt,q)}function G(nt,q,rt,gt){var Ft=rt.type;return Ft===x?mt(nt,q,rt.props.children,gt,rt.key):q!==null&&(q.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===R&&da(Ft)===q.type)?(q=v(q,rt.props),Eu(q,rt),q.return=nt,q):(q=Pf(rt.type,rt.key,rt.props,null,nt.mode,gt),Eu(q,rt),q.return=nt,q)}function ot(nt,q,rt,gt){return q===null||q.tag!==4||q.stateNode.containerInfo!==rt.containerInfo||q.stateNode.implementation!==rt.implementation?(q=p0(rt,nt.mode,gt),q.return=nt,q):(q=v(q,rt.children||[]),q.return=nt,q)}function mt(nt,q,rt,gt,Ft){return q===null||q.tag!==7?(q=aa(rt,nt.mode,gt,Ft),q.return=nt,q):(q=v(q,rt),q.return=nt,q)}function yt(nt,q,rt){if(typeof q=="string"&&q!==""||typeof q=="number"||typeof q=="bigint")return q=f0(""+q,nt.mode,rt),q.return=nt,q;if(typeof q=="object"&&q!==null){switch(q.$$typeof){case y:return rt=Pf(q.type,q.key,q.props,null,nt.mode,rt),Eu(rt,q),rt.return=nt,rt;case b:return q=p0(q,nt.mode,rt),q.return=nt,q;case R:return q=da(q),yt(nt,q,rt)}if(X(q)||B(q))return q=aa(q,nt.mode,rt,null),q.return=nt,q;if(typeof q.then=="function")return yt(nt,Hf(q),rt);if(q.$$typeof===k)return yt(nt,Uf(nt,q),rt);qf(nt,q)}return null}function lt(nt,q,rt,gt){var Ft=q!==null?q.key:null;if(typeof rt=="string"&&rt!==""||typeof rt=="number"||typeof rt=="bigint")return Ft!==null?null:O(nt,q,""+rt,gt);if(typeof rt=="object"&&rt!==null){switch(rt.$$typeof){case y:return rt.key===Ft?G(nt,q,rt,gt):null;case b:return rt.key===Ft?ot(nt,q,rt,gt):null;case R:return rt=da(rt),lt(nt,q,rt,gt)}if(X(rt)||B(rt))return Ft!==null?null:mt(nt,q,rt,gt,null);if(typeof rt.then=="function")return lt(nt,q,Hf(rt),gt);if(rt.$$typeof===k)return lt(nt,q,Uf(nt,rt),gt);qf(nt,rt)}return null}function ht(nt,q,rt,gt,Ft){if(typeof gt=="string"&&gt!==""||typeof gt=="number"||typeof gt=="bigint")return nt=nt.get(rt)||null,O(q,nt,""+gt,Ft);if(typeof gt=="object"&&gt!==null){switch(gt.$$typeof){case y:return nt=nt.get(gt.key===null?rt:gt.key)||null,G(q,nt,gt,Ft);case b:return nt=nt.get(gt.key===null?rt:gt.key)||null,ot(q,nt,gt,Ft);case R:return gt=da(gt),ht(nt,q,rt,gt,Ft)}if(X(gt)||B(gt))return nt=nt.get(rt)||null,mt(q,nt,gt,Ft,null);if(typeof gt.then=="function")return ht(nt,q,rt,Hf(gt),Ft);if(gt.$$typeof===k)return ht(nt,q,rt,Uf(q,gt),Ft);qf(q,gt)}return null}function It(nt,q,rt,gt){for(var Ft=null,he=null,_t=q,Xt=q=0,ie=null;_t!==null&&Xt<rt.length;Xt++){_t.index>Xt?(ie=_t,_t=null):ie=_t.sibling;var de=lt(nt,_t,rt[Xt],gt);if(de===null){_t===null&&(_t=ie);break}a&&_t&&de.alternate===null&&u(nt,_t),q=C(de,q,Xt),he===null?Ft=de:he.sibling=de,he=de,_t=ie}if(Xt===rt.length)return f(nt,_t),re&&Cr(nt,Xt),Ft;if(_t===null){for(;Xt<rt.length;Xt++)_t=yt(nt,rt[Xt],gt),_t!==null&&(q=C(_t,q,Xt),he===null?Ft=_t:he.sibling=_t,he=_t);return re&&Cr(nt,Xt),Ft}for(_t=g(_t);Xt<rt.length;Xt++)ie=ht(_t,nt,Xt,rt[Xt],gt),ie!==null&&(a&&ie.alternate!==null&&_t.delete(ie.key===null?Xt:ie.key),q=C(ie,q,Xt),he===null?Ft=ie:he.sibling=ie,he=ie);return a&&_t.forEach(function(So){return u(nt,So)}),re&&Cr(nt,Xt),Ft}function Pt(nt,q,rt,gt){if(rt==null)throw Error(s(151));for(var Ft=null,he=null,_t=q,Xt=q=0,ie=null,de=rt.next();_t!==null&&!de.done;Xt++,de=rt.next()){_t.index>Xt?(ie=_t,_t=null):ie=_t.sibling;var So=lt(nt,_t,de.value,gt);if(So===null){_t===null&&(_t=ie);break}a&&_t&&So.alternate===null&&u(nt,_t),q=C(So,q,Xt),he===null?Ft=So:he.sibling=So,he=So,_t=ie}if(de.done)return f(nt,_t),re&&Cr(nt,Xt),Ft;if(_t===null){for(;!de.done;Xt++,de=rt.next())de=yt(nt,de.value,gt),de!==null&&(q=C(de,q,Xt),he===null?Ft=de:he.sibling=de,he=de);return re&&Cr(nt,Xt),Ft}for(_t=g(_t);!de.done;Xt++,de=rt.next())de=ht(_t,nt,Xt,de.value,gt),de!==null&&(a&&de.alternate!==null&&_t.delete(de.key===null?Xt:de.key),q=C(de,q,Xt),he===null?Ft=de:he.sibling=de,he=de);return a&&_t.forEach(function(gB){return u(nt,gB)}),re&&Cr(nt,Xt),Ft}function Ie(nt,q,rt,gt){if(typeof rt=="object"&&rt!==null&&rt.type===x&&rt.key===null&&(rt=rt.props.children),typeof rt=="object"&&rt!==null){switch(rt.$$typeof){case y:t:{for(var Ft=rt.key;q!==null;){if(q.key===Ft){if(Ft=rt.type,Ft===x){if(q.tag===7){f(nt,q.sibling),gt=v(q,rt.props.children),gt.return=nt,nt=gt;break t}}else if(q.elementType===Ft||typeof Ft=="object"&&Ft!==null&&Ft.$$typeof===R&&da(Ft)===q.type){f(nt,q.sibling),gt=v(q,rt.props),Eu(gt,rt),gt.return=nt,nt=gt;break t}f(nt,q);break}else u(nt,q);q=q.sibling}rt.type===x?(gt=aa(rt.props.children,nt.mode,gt,rt.key),gt.return=nt,nt=gt):(gt=Pf(rt.type,rt.key,rt.props,null,nt.mode,gt),Eu(gt,rt),gt.return=nt,nt=gt)}return I(nt);case b:t:{for(Ft=rt.key;q!==null;){if(q.key===Ft)if(q.tag===4&&q.stateNode.containerInfo===rt.containerInfo&&q.stateNode.implementation===rt.implementation){f(nt,q.sibling),gt=v(q,rt.children||[]),gt.return=nt,nt=gt;break t}else{f(nt,q);break}else u(nt,q);q=q.sibling}gt=p0(rt,nt.mode,gt),gt.return=nt,nt=gt}return I(nt);case R:return rt=da(rt),Ie(nt,q,rt,gt)}if(X(rt))return It(nt,q,rt,gt);if(B(rt)){if(Ft=B(rt),typeof Ft!="function")throw Error(s(150));return rt=Ft.call(rt),Pt(nt,q,rt,gt)}if(typeof rt.then=="function")return Ie(nt,q,Hf(rt),gt);if(rt.$$typeof===k)return Ie(nt,q,Uf(nt,rt),gt);qf(nt,rt)}return typeof rt=="string"&&rt!==""||typeof rt=="number"||typeof rt=="bigint"?(rt=""+rt,q!==null&&q.tag===6?(f(nt,q.sibling),gt=v(q,rt),gt.return=nt,nt=gt):(f(nt,q),gt=f0(rt,nt.mode,gt),gt.return=nt,nt=gt),I(nt)):f(nt,q)}return function(nt,q,rt,gt){try{$u=0;var Ft=Ie(nt,q,rt,gt);return zl=null,Ft}catch(_t){if(_t===Ll||_t===Gf)throw _t;var he=Fs(29,_t,null,nt.mode);return he.lanes=gt,he.return=nt,he}}}var pa=HT(!0),qT=HT(!1),io=!1;function $0(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function E0(a,u){a=a.updateQueue,u.updateQueue===a&&(u.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function ro(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function oo(a,u,f){var g=a.updateQueue;if(g===null)return null;if(g=g.shared,(be&2)!==0){var v=g.pending;return v===null?u.next=u:(u.next=v.next,v.next=u),g.pending=u,u=zf(a),AT(a,null,f),u}return Lf(a,g,u,f),zf(a)}function Iu(a,u,f){if(u=u.updateQueue,u!==null&&(u=u.shared,(f&4194048)!==0)){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,zC(a,f)}}function I0(a,u){var f=a.updateQueue,g=a.alternate;if(g!==null&&(g=g.updateQueue,f===g)){var v=null,C=null;if(f=f.firstBaseUpdate,f!==null){do{var I={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};C===null?v=C=I:C=C.next=I,f=f.next}while(f!==null);C===null?v=C=u:C=C.next=u}else v=C=u;f={baseState:g.baseState,firstBaseUpdate:v,lastBaseUpdate:C,shared:g.shared,callbacks:g.callbacks},a.updateQueue=f;return}a=f.lastBaseUpdate,a===null?f.firstBaseUpdate=u:a.next=u,f.lastBaseUpdate=u}var N0=!1;function Nu(){if(N0){var a=Fl;if(a!==null)throw a}}function Au(a,u,f,g){N0=!1;var v=a.updateQueue;io=!1;var C=v.firstBaseUpdate,I=v.lastBaseUpdate,O=v.shared.pending;if(O!==null){v.shared.pending=null;var G=O,ot=G.next;G.next=null,I===null?C=ot:I.next=ot,I=G;var mt=a.alternate;mt!==null&&(mt=mt.updateQueue,O=mt.lastBaseUpdate,O!==I&&(O===null?mt.firstBaseUpdate=ot:O.next=ot,mt.lastBaseUpdate=G))}if(C!==null){var yt=v.baseState;I=0,mt=ot=G=null,O=C;do{var lt=O.lane&-536870913,ht=lt!==O.lane;if(ht?(se&lt)===lt:(g&lt)===lt){lt!==0&&lt===Ml&&(N0=!0),mt!==null&&(mt=mt.next={lane:0,tag:O.tag,payload:O.payload,callback:null,next:null});t:{var It=a,Pt=O;lt=u;var Ie=f;switch(Pt.tag){case 1:if(It=Pt.payload,typeof It=="function"){yt=It.call(Ie,yt,lt);break t}yt=It;break t;case 3:It.flags=It.flags&-65537|128;case 0:if(It=Pt.payload,lt=typeof It=="function"?It.call(Ie,yt,lt):It,lt==null)break t;yt=p({},yt,lt);break t;case 2:io=!0}}lt=O.callback,lt!==null&&(a.flags|=64,ht&&(a.flags|=8192),ht=v.callbacks,ht===null?v.callbacks=[lt]:ht.push(lt))}else ht={lane:lt,tag:O.tag,payload:O.payload,callback:O.callback,next:null},mt===null?(ot=mt=ht,G=yt):mt=mt.next=ht,I|=lt;if(O=O.next,O===null){if(O=v.shared.pending,O===null)break;ht=O,O=ht.next,ht.next=null,v.lastBaseUpdate=ht,v.shared.pending=null}}while(!0);mt===null&&(G=yt),v.baseState=G,v.firstBaseUpdate=ot,v.lastBaseUpdate=mt,C===null&&(v.shared.lanes=0),ho|=I,a.lanes=I,a.memoizedState=yt}}function KT(a,u){if(typeof a!="function")throw Error(s(191,a));a.call(u)}function XT(a,u){var f=a.callbacks;if(f!==null)for(a.callbacks=null,a=0;a<f.length;a++)KT(f[a],u)}var Pl=L(null),Kf=L(0);function YT(a,u){a=Or,Q(Kf,a),Q(Pl,u),Or=a|u.baseLanes}function A0(){Q(Kf,Or),Q(Pl,Pl.current)}function _0(){Or=Kf.current,j(Pl),j(Kf)}var Ls=L(null),ri=null;function ao(a){var u=a.alternate;Q(on,on.current&1),Q(Ls,a),ri===null&&(u===null||Pl.current!==null||u.memoizedState!==null)&&(ri=a)}function R0(a){Q(on,on.current),Q(Ls,a),ri===null&&(ri=a)}function JT(a){a.tag===22?(Q(on,on.current),Q(Ls,a),ri===null&&(ri=a)):lo()}function lo(){Q(on,on.current),Q(Ls,Ls.current)}function zs(a){j(Ls),ri===a&&(ri=null),j(on)}var on=L(0);function Xf(a){for(var u=a;u!==null;){if(u.tag===13){var f=u.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||zb(f)||Pb(f)))return u}else if(u.tag===19&&(u.memoizedProps.revealOrder==="forwards"||u.memoizedProps.revealOrder==="backwards"||u.memoizedProps.revealOrder==="unstable_legacy-backwards"||u.memoizedProps.revealOrder==="together")){if((u.flags&128)!==0)return u}else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return null;u=u.return}u.sibling.return=u.return,u=u.sibling}return null}var $r=0,qt=null,$e=null,hn=null,Yf=!1,Bl=!1,ma=!1,Jf=0,_u=0,Vl=null,oP=0;function Xe(){throw Error(s(321))}function D0(a,u){if(u===null)return!1;for(var f=0;f<u.length&&f<a.length;f++)if(!Ms(a[f],u[f]))return!1;return!0}function O0(a,u,f,g,v,C){return $r=C,qt=u,u.memoizedState=null,u.updateQueue=null,u.lanes=0,z.H=a===null||a.memoizedState===null?Ok:X0,ma=!1,C=f(g,v),ma=!1,Bl&&(C=QT(u,f,g,v)),ZT(a),C}function ZT(a){z.H=Ou;var u=$e!==null&&$e.next!==null;if($r=0,hn=$e=qt=null,Yf=!1,_u=0,Vl=null,u)throw Error(s(300));a===null||dn||(a=a.dependencies,a!==null&&Vf(a)&&(dn=!0))}function QT(a,u,f,g){qt=a;var v=0;do{if(Bl&&(Vl=null),_u=0,Bl=!1,25<=v)throw Error(s(301));if(v+=1,hn=$e=null,a.updateQueue!=null){var C=a.updateQueue;C.lastEffect=null,C.events=null,C.stores=null,C.memoCache!=null&&(C.memoCache.index=0)}z.H=Mk,C=u(f,g)}while(Bl);return C}function aP(){var a=z.H,u=a.useState()[0];return u=typeof u.then=="function"?Ru(u):u,a=a.useState()[0],($e!==null?$e.memoizedState:null)!==a&&(qt.flags|=1024),u}function M0(){var a=Jf!==0;return Jf=0,a}function F0(a,u,f){u.updateQueue=a.updateQueue,u.flags&=-2053,a.lanes&=~f}function L0(a){if(Yf){for(a=a.memoizedState;a!==null;){var u=a.queue;u!==null&&(u.pending=null),a=a.next}Yf=!1}$r=0,hn=$e=qt=null,Bl=!1,_u=Jf=0,Vl=null}function ls(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return hn===null?qt.memoizedState=hn=a:hn=hn.next=a,hn}function an(){if($e===null){var a=qt.alternate;a=a!==null?a.memoizedState:null}else a=$e.next;var u=hn===null?qt.memoizedState:hn.next;if(u!==null)hn=u,$e=a;else{if(a===null)throw qt.alternate===null?Error(s(467)):Error(s(310));$e=a,a={memoizedState:$e.memoizedState,baseState:$e.baseState,baseQueue:$e.baseQueue,queue:$e.queue,next:null},hn===null?qt.memoizedState=hn=a:hn=hn.next=a}return hn}function Zf(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Ru(a){var u=_u;return _u+=1,Vl===null&&(Vl=[]),a=jT(Vl,a,u),u=qt,(hn===null?u.memoizedState:hn.next)===null&&(u=u.alternate,z.H=u===null||u.memoizedState===null?Ok:X0),a}function Qf(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return Ru(a);if(a.$$typeof===k)return Bn(a)}throw Error(s(438,String(a)))}function z0(a){var u=null,f=qt.updateQueue;if(f!==null&&(u=f.memoCache),u==null){var g=qt.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(u={data:g.data.map(function(v){return v.slice()}),index:0})))}if(u==null&&(u={data:[],index:0}),f===null&&(f=Zf(),qt.updateQueue=f),f.memoCache=u,f=u.data[u.index],f===void 0)for(f=u.data[u.index]=Array(a),g=0;g<a;g++)f[g]=M;return u.index++,f}function Er(a,u){return typeof u=="function"?u(a):u}function tp(a){var u=an();return P0(u,$e,a)}function P0(a,u,f){var g=a.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=f;var v=a.baseQueue,C=g.pending;if(C!==null){if(v!==null){var I=v.next;v.next=C.next,C.next=I}u.baseQueue=v=C,g.pending=null}if(C=a.baseState,v===null)a.memoizedState=C;else{u=v.next;var O=I=null,G=null,ot=u,mt=!1;do{var yt=ot.lane&-536870913;if(yt!==ot.lane?(se&yt)===yt:($r&yt)===yt){var lt=ot.revertLane;if(lt===0)G!==null&&(G=G.next={lane:0,revertLane:0,gesture:null,action:ot.action,hasEagerState:ot.hasEagerState,eagerState:ot.eagerState,next:null}),yt===Ml&&(mt=!0);else if(($r&lt)===lt){ot=ot.next,lt===Ml&&(mt=!0);continue}else yt={lane:0,revertLane:ot.revertLane,gesture:null,action:ot.action,hasEagerState:ot.hasEagerState,eagerState:ot.eagerState,next:null},G===null?(O=G=yt,I=C):G=G.next=yt,qt.lanes|=lt,ho|=lt;yt=ot.action,ma&&f(C,yt),C=ot.hasEagerState?ot.eagerState:f(C,yt)}else lt={lane:yt,revertLane:ot.revertLane,gesture:ot.gesture,action:ot.action,hasEagerState:ot.hasEagerState,eagerState:ot.eagerState,next:null},G===null?(O=G=lt,I=C):G=G.next=lt,qt.lanes|=yt,ho|=yt;ot=ot.next}while(ot!==null&&ot!==u);if(G===null?I=C:G.next=O,!Ms(C,a.memoizedState)&&(dn=!0,mt&&(f=Fl,f!==null)))throw f;a.memoizedState=C,a.baseState=I,a.baseQueue=G,g.lastRenderedState=C}return v===null&&(g.lanes=0),[a.memoizedState,g.dispatch]}function B0(a){var u=an(),f=u.queue;if(f===null)throw Error(s(311));f.lastRenderedReducer=a;var g=f.dispatch,v=f.pending,C=u.memoizedState;if(v!==null){f.pending=null;var I=v=v.next;do C=a(C,I.action),I=I.next;while(I!==v);Ms(C,u.memoizedState)||(dn=!0),u.memoizedState=C,u.baseQueue===null&&(u.baseState=C),f.lastRenderedState=C}return[C,g]}function tk(a,u,f){var g=qt,v=an(),C=re;if(C){if(f===void 0)throw Error(s(407));f=f()}else f=u();var I=!Ms(($e||v).memoizedState,f);if(I&&(v.memoizedState=f,dn=!0),v=v.queue,j0(sk.bind(null,g,v,a),[a]),v.getSnapshot!==u||I||hn!==null&&hn.memoizedState.tag&1){if(g.flags|=2048,Ul(9,{destroy:void 0},nk.bind(null,g,v,f,u),null),Ae===null)throw Error(s(349));C||($r&127)!==0||ek(g,u,f)}return f}function ek(a,u,f){a.flags|=16384,a={getSnapshot:u,value:f},u=qt.updateQueue,u===null?(u=Zf(),qt.updateQueue=u,u.stores=[a]):(f=u.stores,f===null?u.stores=[a]:f.push(a))}function nk(a,u,f,g){u.value=f,u.getSnapshot=g,ik(u)&&rk(a)}function sk(a,u,f){return f(function(){ik(u)&&rk(a)})}function ik(a){var u=a.getSnapshot;a=a.value;try{var f=u();return!Ms(a,f)}catch{return!0}}function rk(a){var u=oa(a,2);u!==null&&Cs(u,a,2)}function V0(a){var u=ls();if(typeof a=="function"){var f=a;if(a=f(),ma){Hi(!0);try{f()}finally{Hi(!1)}}}return u.memoizedState=u.baseState=a,u.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Er,lastRenderedState:a},u}function ok(a,u,f,g){return a.baseState=f,P0(a,$e,typeof g=="function"?g:Er)}function lP(a,u,f,g,v){if(sp(a))throw Error(s(485));if(a=u.action,a!==null){var C={payload:v,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){C.listeners.push(I)}};z.T!==null?f(!0):C.isTransition=!1,g(C),f=u.pending,f===null?(C.next=u.pending=C,ak(u,C)):(C.next=f.next,u.pending=f.next=C)}}function ak(a,u){var f=u.action,g=u.payload,v=a.state;if(u.isTransition){var C=z.T,I={};z.T=I;try{var O=f(v,g),G=z.S;G!==null&&G(I,O),lk(a,u,O)}catch(ot){U0(a,u,ot)}finally{C!==null&&I.types!==null&&(C.types=I.types),z.T=C}}else try{C=f(v,g),lk(a,u,C)}catch(ot){U0(a,u,ot)}}function lk(a,u,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(g){ck(a,u,g)},function(g){return U0(a,u,g)}):ck(a,u,f)}function ck(a,u,f){u.status="fulfilled",u.value=f,uk(u),a.state=f,u=a.pending,u!==null&&(f=u.next,f===u?a.pending=null:(f=f.next,u.next=f,ak(a,f)))}function U0(a,u,f){var g=a.pending;if(a.pending=null,g!==null){g=g.next;do u.status="rejected",u.reason=f,uk(u),u=u.next;while(u!==g)}a.action=null}function uk(a){a=a.listeners;for(var u=0;u<a.length;u++)(0,a[u])()}function hk(a,u){return u}function dk(a,u){if(re){var f=Ae.formState;if(f!==null){t:{var g=qt;if(re){if(ze){e:{for(var v=ze,C=ii;v.nodeType!==8;){if(!C){v=null;break e}if(v=oi(v.nextSibling),v===null){v=null;break e}}C=v.data,v=C==="F!"||C==="F"?v:null}if(v){ze=oi(v.nextSibling),g=v.data==="F!";break t}}no(g)}g=!1}g&&(u=f[0])}}return f=ls(),f.memoizedState=f.baseState=u,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:hk,lastRenderedState:u},f.queue=g,f=_k.bind(null,qt,g),g.dispatch=f,g=V0(!1),C=K0.bind(null,qt,!1,g.queue),g=ls(),v={state:u,dispatch:null,action:a,pending:null},g.queue=v,f=lP.bind(null,qt,v,C,f),v.dispatch=f,g.memoizedState=a,[u,f,!1]}function fk(a){var u=an();return pk(u,$e,a)}function pk(a,u,f){if(u=P0(a,u,hk)[0],a=tp(Er)[0],typeof u=="object"&&u!==null&&typeof u.then=="function")try{var g=Ru(u)}catch(I){throw I===Ll?Gf:I}else g=u;u=an();var v=u.queue,C=v.dispatch;return f!==u.memoizedState&&(qt.flags|=2048,Ul(9,{destroy:void 0},cP.bind(null,v,f),null)),[g,C,a]}function cP(a,u){a.action=u}function mk(a){var u=an(),f=$e;if(f!==null)return pk(u,f,a);an(),u=u.memoizedState,f=an();var g=f.queue.dispatch;return f.memoizedState=a,[u,g,!1]}function Ul(a,u,f,g){return a={tag:a,create:f,deps:g,inst:u,next:null},u=qt.updateQueue,u===null&&(u=Zf(),qt.updateQueue=u),f=u.lastEffect,f===null?u.lastEffect=a.next=a:(g=f.next,f.next=a,a.next=g,u.lastEffect=a),a}function gk(){return an().memoizedState}function ep(a,u,f,g){var v=ls();qt.flags|=a,v.memoizedState=Ul(1|u,{destroy:void 0},f,g===void 0?null:g)}function np(a,u,f,g){var v=an();g=g===void 0?null:g;var C=v.memoizedState.inst;$e!==null&&g!==null&&D0(g,$e.memoizedState.deps)?v.memoizedState=Ul(u,C,f,g):(qt.flags|=a,v.memoizedState=Ul(1|u,C,f,g))}function yk(a,u){ep(8390656,8,a,u)}function j0(a,u){np(2048,8,a,u)}function uP(a){qt.flags|=4;var u=qt.updateQueue;if(u===null)u=Zf(),qt.updateQueue=u,u.events=[a];else{var f=u.events;f===null?u.events=[a]:f.push(a)}}function bk(a){var u=an().memoizedState;return uP({ref:u,nextImpl:a}),function(){if((be&2)!==0)throw Error(s(440));return u.impl.apply(void 0,arguments)}}function xk(a,u){return np(4,2,a,u)}function vk(a,u){return np(4,4,a,u)}function wk(a,u){if(typeof u=="function"){a=a();var f=u(a);return function(){typeof f=="function"?f():u(null)}}if(u!=null)return a=a(),u.current=a,function(){u.current=null}}function Sk(a,u,f){f=f!=null?f.concat([a]):null,np(4,4,wk.bind(null,u,a),f)}function G0(){}function Ck(a,u){var f=an();u=u===void 0?null:u;var g=f.memoizedState;return u!==null&&D0(u,g[1])?g[0]:(f.memoizedState=[a,u],a)}function Tk(a,u){var f=an();u=u===void 0?null:u;var g=f.memoizedState;if(u!==null&&D0(u,g[1]))return g[0];if(g=a(),ma){Hi(!0);try{a()}finally{Hi(!1)}}return f.memoizedState=[g,u],g}function W0(a,u,f){return f===void 0||($r&1073741824)!==0&&(se&261930)===0?a.memoizedState=u:(a.memoizedState=f,a=k2(),qt.lanes|=a,ho|=a,f)}function kk(a,u,f,g){return Ms(f,u)?f:Pl.current!==null?(a=W0(a,f,g),Ms(a,u)||(dn=!0),a):($r&42)===0||($r&1073741824)!==0&&(se&261930)===0?(dn=!0,a.memoizedState=f):(a=k2(),qt.lanes|=a,ho|=a,u)}function $k(a,u,f,g,v){var C=P.p;P.p=C!==0&&8>C?C:8;var I=z.T,O={};z.T=O,K0(a,!1,u,f);try{var G=v(),ot=z.S;if(ot!==null&&ot(O,G),G!==null&&typeof G=="object"&&typeof G.then=="function"){var mt=rP(G,g);Du(a,u,mt,Vs(a))}else Du(a,u,g,Vs(a))}catch(yt){Du(a,u,{then:function(){},status:"rejected",reason:yt},Vs())}finally{P.p=C,I!==null&&O.types!==null&&(I.types=O.types),z.T=I}}function hP(){}function H0(a,u,f,g){if(a.tag!==5)throw Error(s(476));var v=Ek(a).queue;$k(a,v,u,V,f===null?hP:function(){return Ik(a),f(g)})}function Ek(a){var u=a.memoizedState;if(u!==null)return u;u={memoizedState:V,baseState:V,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Er,lastRenderedState:V},next:null};var f={};return u.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Er,lastRenderedState:f},next:null},a.memoizedState=u,a=a.alternate,a!==null&&(a.memoizedState=u),u}function Ik(a){var u=Ek(a);u.next===null&&(u=a.alternate.memoizedState),Du(a,u.next.queue,{},Vs())}function q0(){return Bn(Yu)}function Nk(){return an().memoizedState}function Ak(){return an().memoizedState}function dP(a){for(var u=a.return;u!==null;){switch(u.tag){case 24:case 3:var f=Vs();a=ro(f);var g=oo(u,a,f);g!==null&&(Cs(g,u,f),Iu(g,u,f)),u={cache:S0()},a.payload=u;return}u=u.return}}function fP(a,u,f){var g=Vs();f={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null},sp(a)?Rk(u,f):(f=h0(a,u,f,g),f!==null&&(Cs(f,a,g),Dk(f,u,g)))}function _k(a,u,f){var g=Vs();Du(a,u,f,g)}function Du(a,u,f,g){var v={lane:g,revertLane:0,gesture:null,action:f,hasEagerState:!1,eagerState:null,next:null};if(sp(a))Rk(u,v);else{var C=a.alternate;if(a.lanes===0&&(C===null||C.lanes===0)&&(C=u.lastRenderedReducer,C!==null))try{var I=u.lastRenderedState,O=C(I,f);if(v.hasEagerState=!0,v.eagerState=O,Ms(O,I))return Lf(a,u,v,0),Ae===null&&Ff(),!1}catch{}if(f=h0(a,u,v,g),f!==null)return Cs(f,a,g),Dk(f,u,g),!0}return!1}function K0(a,u,f,g){if(g={lane:2,revertLane:$b(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},sp(a)){if(u)throw Error(s(479))}else u=h0(a,f,g,2),u!==null&&Cs(u,a,2)}function sp(a){var u=a.alternate;return a===qt||u!==null&&u===qt}function Rk(a,u){Bl=Yf=!0;var f=a.pending;f===null?u.next=u:(u.next=f.next,f.next=u),a.pending=u}function Dk(a,u,f){if((f&4194048)!==0){var g=u.lanes;g&=a.pendingLanes,f|=g,u.lanes=f,zC(a,f)}}var Ou={readContext:Bn,use:Qf,useCallback:Xe,useContext:Xe,useEffect:Xe,useImperativeHandle:Xe,useLayoutEffect:Xe,useInsertionEffect:Xe,useMemo:Xe,useReducer:Xe,useRef:Xe,useState:Xe,useDebugValue:Xe,useDeferredValue:Xe,useTransition:Xe,useSyncExternalStore:Xe,useId:Xe,useHostTransitionStatus:Xe,useFormState:Xe,useActionState:Xe,useOptimistic:Xe,useMemoCache:Xe,useCacheRefresh:Xe};Ou.useEffectEvent=Xe;var Ok={readContext:Bn,use:Qf,useCallback:function(a,u){return ls().memoizedState=[a,u===void 0?null:u],a},useContext:Bn,useEffect:yk,useImperativeHandle:function(a,u,f){f=f!=null?f.concat([a]):null,ep(4194308,4,wk.bind(null,u,a),f)},useLayoutEffect:function(a,u){return ep(4194308,4,a,u)},useInsertionEffect:function(a,u){ep(4,2,a,u)},useMemo:function(a,u){var f=ls();u=u===void 0?null:u;var g=a();if(ma){Hi(!0);try{a()}finally{Hi(!1)}}return f.memoizedState=[g,u],g},useReducer:function(a,u,f){var g=ls();if(f!==void 0){var v=f(u);if(ma){Hi(!0);try{f(u)}finally{Hi(!1)}}}else v=u;return g.memoizedState=g.baseState=v,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:v},g.queue=a,a=a.dispatch=fP.bind(null,qt,a),[g.memoizedState,a]},useRef:function(a){var u=ls();return a={current:a},u.memoizedState=a},useState:function(a){a=V0(a);var u=a.queue,f=_k.bind(null,qt,u);return u.dispatch=f,[a.memoizedState,f]},useDebugValue:G0,useDeferredValue:function(a,u){var f=ls();return W0(f,a,u)},useTransition:function(){var a=V0(!1);return a=$k.bind(null,qt,a.queue,!0,!1),ls().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,u,f){var g=qt,v=ls();if(re){if(f===void 0)throw Error(s(407));f=f()}else{if(f=u(),Ae===null)throw Error(s(349));(se&127)!==0||ek(g,u,f)}v.memoizedState=f;var C={value:f,getSnapshot:u};return v.queue=C,yk(sk.bind(null,g,C,a),[a]),g.flags|=2048,Ul(9,{destroy:void 0},nk.bind(null,g,C,f,u),null),f},useId:function(){var a=ls(),u=Ae.identifierPrefix;if(re){var f=Ki,g=qi;f=(g&~(1<<32-Os(g)-1)).toString(32)+f,u="_"+u+"R_"+f,f=Jf++,0<f&&(u+="H"+f.toString(32)),u+="_"}else f=oP++,u="_"+u+"r_"+f.toString(32)+"_";return a.memoizedState=u},useHostTransitionStatus:q0,useFormState:dk,useActionState:dk,useOptimistic:function(a){var u=ls();u.memoizedState=u.baseState=a;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return u.queue=f,u=K0.bind(null,qt,!0,f),f.dispatch=u,[a,u]},useMemoCache:z0,useCacheRefresh:function(){return ls().memoizedState=dP.bind(null,qt)},useEffectEvent:function(a){var u=ls(),f={impl:a};return u.memoizedState=f,function(){if((be&2)!==0)throw Error(s(440));return f.impl.apply(void 0,arguments)}}},X0={readContext:Bn,use:Qf,useCallback:Ck,useContext:Bn,useEffect:j0,useImperativeHandle:Sk,useInsertionEffect:xk,useLayoutEffect:vk,useMemo:Tk,useReducer:tp,useRef:gk,useState:function(){return tp(Er)},useDebugValue:G0,useDeferredValue:function(a,u){var f=an();return kk(f,$e.memoizedState,a,u)},useTransition:function(){var a=tp(Er)[0],u=an().memoizedState;return[typeof a=="boolean"?a:Ru(a),u]},useSyncExternalStore:tk,useId:Nk,useHostTransitionStatus:q0,useFormState:fk,useActionState:fk,useOptimistic:function(a,u){var f=an();return ok(f,$e,a,u)},useMemoCache:z0,useCacheRefresh:Ak};X0.useEffectEvent=bk;var Mk={readContext:Bn,use:Qf,useCallback:Ck,useContext:Bn,useEffect:j0,useImperativeHandle:Sk,useInsertionEffect:xk,useLayoutEffect:vk,useMemo:Tk,useReducer:B0,useRef:gk,useState:function(){return B0(Er)},useDebugValue:G0,useDeferredValue:function(a,u){var f=an();return $e===null?W0(f,a,u):kk(f,$e.memoizedState,a,u)},useTransition:function(){var a=B0(Er)[0],u=an().memoizedState;return[typeof a=="boolean"?a:Ru(a),u]},useSyncExternalStore:tk,useId:Nk,useHostTransitionStatus:q0,useFormState:mk,useActionState:mk,useOptimistic:function(a,u){var f=an();return $e!==null?ok(f,$e,a,u):(f.baseState=a,[a,f.queue.dispatch])},useMemoCache:z0,useCacheRefresh:Ak};Mk.useEffectEvent=bk;function Y0(a,u,f,g){u=a.memoizedState,f=f(g,u),f=f==null?u:p({},u,f),a.memoizedState=f,a.lanes===0&&(a.updateQueue.baseState=f)}var J0={enqueueSetState:function(a,u,f){a=a._reactInternals;var g=Vs(),v=ro(g);v.payload=u,f!=null&&(v.callback=f),u=oo(a,v,g),u!==null&&(Cs(u,a,g),Iu(u,a,g))},enqueueReplaceState:function(a,u,f){a=a._reactInternals;var g=Vs(),v=ro(g);v.tag=1,v.payload=u,f!=null&&(v.callback=f),u=oo(a,v,g),u!==null&&(Cs(u,a,g),Iu(u,a,g))},enqueueForceUpdate:function(a,u){a=a._reactInternals;var f=Vs(),g=ro(f);g.tag=2,u!=null&&(g.callback=u),u=oo(a,g,f),u!==null&&(Cs(u,a,f),Iu(u,a,f))}};function Fk(a,u,f,g,v,C,I){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(g,C,I):u.prototype&&u.prototype.isPureReactComponent?!vu(f,g)||!vu(v,C):!0}function Lk(a,u,f,g){a=u.state,typeof u.componentWillReceiveProps=="function"&&u.componentWillReceiveProps(f,g),typeof u.UNSAFE_componentWillReceiveProps=="function"&&u.UNSAFE_componentWillReceiveProps(f,g),u.state!==a&&J0.enqueueReplaceState(u,u.state,null)}function ga(a,u){var f=u;if("ref"in u){f={};for(var g in u)g!=="ref"&&(f[g]=u[g])}if(a=a.defaultProps){f===u&&(f=p({},f));for(var v in a)f[v]===void 0&&(f[v]=a[v])}return f}function zk(a){Mf(a)}function Pk(a){console.error(a)}function Bk(a){Mf(a)}function ip(a,u){try{var f=a.onUncaughtError;f(u.value,{componentStack:u.stack})}catch(g){setTimeout(function(){throw g})}}function Vk(a,u,f){try{var g=a.onCaughtError;g(f.value,{componentStack:f.stack,errorBoundary:u.tag===1?u.stateNode:null})}catch(v){setTimeout(function(){throw v})}}function Z0(a,u,f){return f=ro(f),f.tag=3,f.payload={element:null},f.callback=function(){ip(a,u)},f}function Uk(a){return a=ro(a),a.tag=3,a}function jk(a,u,f,g){var v=f.type.getDerivedStateFromError;if(typeof v=="function"){var C=g.value;a.payload=function(){return v(C)},a.callback=function(){Vk(u,f,g)}}var I=f.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(a.callback=function(){Vk(u,f,g),typeof v!="function"&&(fo===null?fo=new Set([this]):fo.add(this));var O=g.stack;this.componentDidCatch(g.value,{componentStack:O!==null?O:""})})}function pP(a,u,f,g,v){if(f.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(u=f.alternate,u!==null&&Ol(u,f,v,!0),f=Ls.current,f!==null){switch(f.tag){case 31:case 13:return ri===null?gp():f.alternate===null&&Ye===0&&(Ye=3),f.flags&=-257,f.flags|=65536,f.lanes=v,g===Wf?f.flags|=16384:(u=f.updateQueue,u===null?f.updateQueue=new Set([g]):u.add(g),Cb(a,g,v)),!1;case 22:return f.flags|=65536,g===Wf?f.flags|=16384:(u=f.updateQueue,u===null?(u={transitions:null,markerInstances:null,retryQueue:new Set([g])},f.updateQueue=u):(f=u.retryQueue,f===null?u.retryQueue=new Set([g]):f.add(g)),Cb(a,g,v)),!1}throw Error(s(435,f.tag))}return Cb(a,g,v),gp(),!1}if(re)return u=Ls.current,u!==null?((u.flags&65536)===0&&(u.flags|=256),u.flags|=65536,u.lanes=v,g!==y0&&(a=Error(s(422),{cause:g}),Cu(ei(a,f)))):(g!==y0&&(u=Error(s(423),{cause:g}),Cu(ei(u,f))),a=a.current.alternate,a.flags|=65536,v&=-v,a.lanes|=v,g=ei(g,f),v=Z0(a.stateNode,g,v),I0(a,v),Ye!==4&&(Ye=2)),!1;var C=Error(s(520),{cause:g});if(C=ei(C,f),Uu===null?Uu=[C]:Uu.push(C),Ye!==4&&(Ye=2),u===null)return!0;g=ei(g,f),f=u;do{switch(f.tag){case 3:return f.flags|=65536,a=v&-v,f.lanes|=a,a=Z0(f.stateNode,g,a),I0(f,a),!1;case 1:if(u=f.type,C=f.stateNode,(f.flags&128)===0&&(typeof u.getDerivedStateFromError=="function"||C!==null&&typeof C.componentDidCatch=="function"&&(fo===null||!fo.has(C))))return f.flags|=65536,v&=-v,f.lanes|=v,v=Uk(v),jk(v,a,f,g),I0(f,v),!1}f=f.return}while(f!==null);return!1}var Q0=Error(s(461)),dn=!1;function Vn(a,u,f,g){u.child=a===null?qT(u,null,f,g):pa(u,a.child,f,g)}function Gk(a,u,f,g,v){f=f.render;var C=u.ref;if("ref"in g){var I={};for(var O in g)O!=="ref"&&(I[O]=g[O])}else I=g;return ua(u),g=O0(a,u,f,I,C,v),O=M0(),a!==null&&!dn?(F0(a,u,v),Ir(a,u,v)):(re&&O&&m0(u),u.flags|=1,Vn(a,u,g,v),u.child)}function Wk(a,u,f,g,v){if(a===null){var C=f.type;return typeof C=="function"&&!d0(C)&&C.defaultProps===void 0&&f.compare===null?(u.tag=15,u.type=C,Hk(a,u,C,g,v)):(a=Pf(f.type,null,g,u,u.mode,v),a.ref=u.ref,a.return=u,u.child=a)}if(C=a.child,!ab(a,v)){var I=C.memoizedProps;if(f=f.compare,f=f!==null?f:vu,f(I,g)&&a.ref===u.ref)return Ir(a,u,v)}return u.flags|=1,a=Sr(C,g),a.ref=u.ref,a.return=u,u.child=a}function Hk(a,u,f,g,v){if(a!==null){var C=a.memoizedProps;if(vu(C,g)&&a.ref===u.ref)if(dn=!1,u.pendingProps=g=C,ab(a,v))(a.flags&131072)!==0&&(dn=!0);else return u.lanes=a.lanes,Ir(a,u,v)}return tb(a,u,f,g,v)}function qk(a,u,f,g){var v=g.children,C=a!==null?a.memoizedState:null;if(a===null&&u.stateNode===null&&(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((u.flags&128)!==0){if(C=C!==null?C.baseLanes|f:f,a!==null){for(g=u.child=a.child,v=0;g!==null;)v=v|g.lanes|g.childLanes,g=g.sibling;g=v&~C}else g=0,u.child=null;return Kk(a,u,C,f,g)}if((f&536870912)!==0)u.memoizedState={baseLanes:0,cachePool:null},a!==null&&jf(u,C!==null?C.cachePool:null),C!==null?YT(u,C):A0(),JT(u);else return g=u.lanes=536870912,Kk(a,u,C!==null?C.baseLanes|f:f,f,g)}else C!==null?(jf(u,C.cachePool),YT(u,C),lo(),u.memoizedState=null):(a!==null&&jf(u,null),A0(),lo());return Vn(a,u,v,f),u.child}function Mu(a,u){return a!==null&&a.tag===22||u.stateNode!==null||(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),u.sibling}function Kk(a,u,f,g,v){var C=T0();return C=C===null?null:{parent:un._currentValue,pool:C},u.memoizedState={baseLanes:f,cachePool:C},a!==null&&jf(u,null),A0(),JT(u),a!==null&&Ol(a,u,g,!0),u.childLanes=v,null}function rp(a,u){return u=ap({mode:u.mode,children:u.children},a.mode),u.ref=a.ref,a.child=u,u.return=a,u}function Xk(a,u,f){return pa(u,a.child,null,f),a=rp(u,u.pendingProps),a.flags|=2,zs(u),u.memoizedState=null,a}function mP(a,u,f){var g=u.pendingProps,v=(u.flags&128)!==0;if(u.flags&=-129,a===null){if(re){if(g.mode==="hidden")return a=rp(u,g),u.lanes=536870912,Mu(null,a);if(R0(u),(a=ze)?(a=a$(a,ii),a=a!==null&&a.data==="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:to!==null?{id:qi,overflow:Ki}:null,retryLane:536870912,hydrationErrors:null},f=RT(a),f.return=u,u.child=f,Pn=u,ze=null)):a=null,a===null)throw no(u);return u.lanes=536870912,null}return rp(u,g)}var C=a.memoizedState;if(C!==null){var I=C.dehydrated;if(R0(u),v)if(u.flags&256)u.flags&=-257,u=Xk(a,u,f);else if(u.memoizedState!==null)u.child=a.child,u.flags|=128,u=null;else throw Error(s(558));else if(dn||Ol(a,u,f,!1),v=(f&a.childLanes)!==0,dn||v){if(g=Ae,g!==null&&(I=PC(g,f),I!==0&&I!==C.retryLane))throw C.retryLane=I,oa(a,I),Cs(g,a,I),Q0;gp(),u=Xk(a,u,f)}else a=C.treeContext,ze=oi(I.nextSibling),Pn=u,re=!0,eo=null,ii=!1,a!==null&&MT(u,a),u=rp(u,g),u.flags|=4096;return u}return a=Sr(a.child,{mode:g.mode,children:g.children}),a.ref=u.ref,u.child=a,a.return=u,a}function op(a,u){var f=u.ref;if(f===null)a!==null&&a.ref!==null&&(u.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(s(284));(a===null||a.ref!==f)&&(u.flags|=4194816)}}function tb(a,u,f,g,v){return ua(u),f=O0(a,u,f,g,void 0,v),g=M0(),a!==null&&!dn?(F0(a,u,v),Ir(a,u,v)):(re&&g&&m0(u),u.flags|=1,Vn(a,u,f,v),u.child)}function Yk(a,u,f,g,v,C){return ua(u),u.updateQueue=null,f=QT(u,g,f,v),ZT(a),g=M0(),a!==null&&!dn?(F0(a,u,C),Ir(a,u,C)):(re&&g&&m0(u),u.flags|=1,Vn(a,u,f,C),u.child)}function Jk(a,u,f,g,v){if(ua(u),u.stateNode===null){var C=Al,I=f.contextType;typeof I=="object"&&I!==null&&(C=Bn(I)),C=new f(g,C),u.memoizedState=C.state!==null&&C.state!==void 0?C.state:null,C.updater=J0,u.stateNode=C,C._reactInternals=u,C=u.stateNode,C.props=g,C.state=u.memoizedState,C.refs={},$0(u),I=f.contextType,C.context=typeof I=="object"&&I!==null?Bn(I):Al,C.state=u.memoizedState,I=f.getDerivedStateFromProps,typeof I=="function"&&(Y0(u,f,I,g),C.state=u.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof C.getSnapshotBeforeUpdate=="function"||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(I=C.state,typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount(),I!==C.state&&J0.enqueueReplaceState(C,C.state,null),Au(u,g,C,v),Nu(),C.state=u.memoizedState),typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!0}else if(a===null){C=u.stateNode;var O=u.memoizedProps,G=ga(f,O);C.props=G;var ot=C.context,mt=f.contextType;I=Al,typeof mt=="object"&&mt!==null&&(I=Bn(mt));var yt=f.getDerivedStateFromProps;mt=typeof yt=="function"||typeof C.getSnapshotBeforeUpdate=="function",O=u.pendingProps!==O,mt||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(O||ot!==I)&&Lk(u,C,g,I),io=!1;var lt=u.memoizedState;C.state=lt,Au(u,g,C,v),Nu(),ot=u.memoizedState,O||lt!==ot||io?(typeof yt=="function"&&(Y0(u,f,yt,g),ot=u.memoizedState),(G=io||Fk(u,f,G,g,lt,ot,I))?(mt||typeof C.UNSAFE_componentWillMount!="function"&&typeof C.componentWillMount!="function"||(typeof C.componentWillMount=="function"&&C.componentWillMount(),typeof C.UNSAFE_componentWillMount=="function"&&C.UNSAFE_componentWillMount()),typeof C.componentDidMount=="function"&&(u.flags|=4194308)):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),u.memoizedProps=g,u.memoizedState=ot),C.props=g,C.state=ot,C.context=I,g=G):(typeof C.componentDidMount=="function"&&(u.flags|=4194308),g=!1)}else{C=u.stateNode,E0(a,u),I=u.memoizedProps,mt=ga(f,I),C.props=mt,yt=u.pendingProps,lt=C.context,ot=f.contextType,G=Al,typeof ot=="object"&&ot!==null&&(G=Bn(ot)),O=f.getDerivedStateFromProps,(ot=typeof O=="function"||typeof C.getSnapshotBeforeUpdate=="function")||typeof C.UNSAFE_componentWillReceiveProps!="function"&&typeof C.componentWillReceiveProps!="function"||(I!==yt||lt!==G)&&Lk(u,C,g,G),io=!1,lt=u.memoizedState,C.state=lt,Au(u,g,C,v),Nu();var ht=u.memoizedState;I!==yt||lt!==ht||io||a!==null&&a.dependencies!==null&&Vf(a.dependencies)?(typeof O=="function"&&(Y0(u,f,O,g),ht=u.memoizedState),(mt=io||Fk(u,f,mt,g,lt,ht,G)||a!==null&&a.dependencies!==null&&Vf(a.dependencies))?(ot||typeof C.UNSAFE_componentWillUpdate!="function"&&typeof C.componentWillUpdate!="function"||(typeof C.componentWillUpdate=="function"&&C.componentWillUpdate(g,ht,G),typeof C.UNSAFE_componentWillUpdate=="function"&&C.UNSAFE_componentWillUpdate(g,ht,G)),typeof C.componentDidUpdate=="function"&&(u.flags|=4),typeof C.getSnapshotBeforeUpdate=="function"&&(u.flags|=1024)):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&lt===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&lt===a.memoizedState||(u.flags|=1024),u.memoizedProps=g,u.memoizedState=ht),C.props=g,C.state=ht,C.context=G,g=mt):(typeof C.componentDidUpdate!="function"||I===a.memoizedProps&&lt===a.memoizedState||(u.flags|=4),typeof C.getSnapshotBeforeUpdate!="function"||I===a.memoizedProps&&lt===a.memoizedState||(u.flags|=1024),g=!1)}return C=g,op(a,u),g=(u.flags&128)!==0,C||g?(C=u.stateNode,f=g&&typeof f.getDerivedStateFromError!="function"?null:C.render(),u.flags|=1,a!==null&&g?(u.child=pa(u,a.child,null,v),u.child=pa(u,null,f,v)):Vn(a,u,f,v),u.memoizedState=C.state,a=u.child):a=Ir(a,u,v),a}function Zk(a,u,f,g){return la(),u.flags|=256,Vn(a,u,f,g),u.child}var eb={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function nb(a){return{baseLanes:a,cachePool:VT()}}function sb(a,u,f){return a=a!==null?a.childLanes&~f:0,u&&(a|=Bs),a}function Qk(a,u,f){var g=u.pendingProps,v=!1,C=(u.flags&128)!==0,I;if((I=C)||(I=a!==null&&a.memoizedState===null?!1:(on.current&2)!==0),I&&(v=!0,u.flags&=-129),I=(u.flags&32)!==0,u.flags&=-33,a===null){if(re){if(v?ao(u):lo(),(a=ze)?(a=a$(a,ii),a=a!==null&&a.data!=="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:to!==null?{id:qi,overflow:Ki}:null,retryLane:536870912,hydrationErrors:null},f=RT(a),f.return=u,u.child=f,Pn=u,ze=null)):a=null,a===null)throw no(u);return Pb(a)?u.lanes=32:u.lanes=536870912,null}var O=g.children;return g=g.fallback,v?(lo(),v=u.mode,O=ap({mode:"hidden",children:O},v),g=aa(g,v,f,null),O.return=u,g.return=u,O.sibling=g,u.child=O,g=u.child,g.memoizedState=nb(f),g.childLanes=sb(a,I,f),u.memoizedState=eb,Mu(null,g)):(ao(u),ib(u,O))}var G=a.memoizedState;if(G!==null&&(O=G.dehydrated,O!==null)){if(C)u.flags&256?(ao(u),u.flags&=-257,u=rb(a,u,f)):u.memoizedState!==null?(lo(),u.child=a.child,u.flags|=128,u=null):(lo(),O=g.fallback,v=u.mode,g=ap({mode:"visible",children:g.children},v),O=aa(O,v,f,null),O.flags|=2,g.return=u,O.return=u,g.sibling=O,u.child=g,pa(u,a.child,null,f),g=u.child,g.memoizedState=nb(f),g.childLanes=sb(a,I,f),u.memoizedState=eb,u=Mu(null,g));else if(ao(u),Pb(O)){if(I=O.nextSibling&&O.nextSibling.dataset,I)var ot=I.dgst;I=ot,g=Error(s(419)),g.stack="",g.digest=I,Cu({value:g,source:null,stack:null}),u=rb(a,u,f)}else if(dn||Ol(a,u,f,!1),I=(f&a.childLanes)!==0,dn||I){if(I=Ae,I!==null&&(g=PC(I,f),g!==0&&g!==G.retryLane))throw G.retryLane=g,oa(a,g),Cs(I,a,g),Q0;zb(O)||gp(),u=rb(a,u,f)}else zb(O)?(u.flags|=192,u.child=a.child,u=null):(a=G.treeContext,ze=oi(O.nextSibling),Pn=u,re=!0,eo=null,ii=!1,a!==null&&MT(u,a),u=ib(u,g.children),u.flags|=4096);return u}return v?(lo(),O=g.fallback,v=u.mode,G=a.child,ot=G.sibling,g=Sr(G,{mode:"hidden",children:g.children}),g.subtreeFlags=G.subtreeFlags&65011712,ot!==null?O=Sr(ot,O):(O=aa(O,v,f,null),O.flags|=2),O.return=u,g.return=u,g.sibling=O,u.child=g,Mu(null,g),g=u.child,O=a.child.memoizedState,O===null?O=nb(f):(v=O.cachePool,v!==null?(G=un._currentValue,v=v.parent!==G?{parent:G,pool:G}:v):v=VT(),O={baseLanes:O.baseLanes|f,cachePool:v}),g.memoizedState=O,g.childLanes=sb(a,I,f),u.memoizedState=eb,Mu(a.child,g)):(ao(u),f=a.child,a=f.sibling,f=Sr(f,{mode:"visible",children:g.children}),f.return=u,f.sibling=null,a!==null&&(I=u.deletions,I===null?(u.deletions=[a],u.flags|=16):I.push(a)),u.child=f,u.memoizedState=null,f)}function ib(a,u){return u=ap({mode:"visible",children:u},a.mode),u.return=a,a.child=u}function ap(a,u){return a=Fs(22,a,null,u),a.lanes=0,a}function rb(a,u,f){return pa(u,a.child,null,f),a=ib(u,u.pendingProps.children),a.flags|=2,u.memoizedState=null,a}function t2(a,u,f){a.lanes|=u;var g=a.alternate;g!==null&&(g.lanes|=u),v0(a.return,u,f)}function ob(a,u,f,g,v,C){var I=a.memoizedState;I===null?a.memoizedState={isBackwards:u,rendering:null,renderingStartTime:0,last:g,tail:f,tailMode:v,treeForkCount:C}:(I.isBackwards=u,I.rendering=null,I.renderingStartTime=0,I.last=g,I.tail=f,I.tailMode=v,I.treeForkCount=C)}function e2(a,u,f){var g=u.pendingProps,v=g.revealOrder,C=g.tail;g=g.children;var I=on.current,O=(I&2)!==0;if(O?(I=I&1|2,u.flags|=128):I&=1,Q(on,I),Vn(a,u,g,f),g=re?Su:0,!O&&a!==null&&(a.flags&128)!==0)t:for(a=u.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&t2(a,f,u);else if(a.tag===19)t2(a,f,u);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===u)break t;for(;a.sibling===null;){if(a.return===null||a.return===u)break t;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(v){case"forwards":for(f=u.child,v=null;f!==null;)a=f.alternate,a!==null&&Xf(a)===null&&(v=f),f=f.sibling;f=v,f===null?(v=u.child,u.child=null):(v=f.sibling,f.sibling=null),ob(u,!1,v,f,C,g);break;case"backwards":case"unstable_legacy-backwards":for(f=null,v=u.child,u.child=null;v!==null;){if(a=v.alternate,a!==null&&Xf(a)===null){u.child=v;break}a=v.sibling,v.sibling=f,f=v,v=a}ob(u,!0,f,null,C,g);break;case"together":ob(u,!1,null,null,void 0,g);break;default:u.memoizedState=null}return u.child}function Ir(a,u,f){if(a!==null&&(u.dependencies=a.dependencies),ho|=u.lanes,(f&u.childLanes)===0)if(a!==null){if(Ol(a,u,f,!1),(f&u.childLanes)===0)return null}else return null;if(a!==null&&u.child!==a.child)throw Error(s(153));if(u.child!==null){for(a=u.child,f=Sr(a,a.pendingProps),u.child=f,f.return=u;a.sibling!==null;)a=a.sibling,f=f.sibling=Sr(a,a.pendingProps),f.return=u;f.sibling=null}return u.child}function ab(a,u){return(a.lanes&u)!==0?!0:(a=a.dependencies,!!(a!==null&&Vf(a)))}function gP(a,u,f){switch(u.tag){case 3:Et(u,u.stateNode.containerInfo),so(u,un,a.memoizedState.cache),la();break;case 27:case 5:Rt(u);break;case 4:Et(u,u.stateNode.containerInfo);break;case 10:so(u,u.type,u.memoizedProps.value);break;case 31:if(u.memoizedState!==null)return u.flags|=128,R0(u),null;break;case 13:var g=u.memoizedState;if(g!==null)return g.dehydrated!==null?(ao(u),u.flags|=128,null):(f&u.child.childLanes)!==0?Qk(a,u,f):(ao(u),a=Ir(a,u,f),a!==null?a.sibling:null);ao(u);break;case 19:var v=(a.flags&128)!==0;if(g=(f&u.childLanes)!==0,g||(Ol(a,u,f,!1),g=(f&u.childLanes)!==0),v){if(g)return e2(a,u,f);u.flags|=128}if(v=u.memoizedState,v!==null&&(v.rendering=null,v.tail=null,v.lastEffect=null),Q(on,on.current),g)break;return null;case 22:return u.lanes=0,qk(a,u,f,u.pendingProps);case 24:so(u,un,a.memoizedState.cache)}return Ir(a,u,f)}function n2(a,u,f){if(a!==null)if(a.memoizedProps!==u.pendingProps)dn=!0;else{if(!ab(a,f)&&(u.flags&128)===0)return dn=!1,gP(a,u,f);dn=(a.flags&131072)!==0}else dn=!1,re&&(u.flags&1048576)!==0&&OT(u,Su,u.index);switch(u.lanes=0,u.tag){case 16:t:{var g=u.pendingProps;if(a=da(u.elementType),u.type=a,typeof a=="function")d0(a)?(g=ga(a,g),u.tag=1,u=Jk(null,u,a,g,f)):(u.tag=0,u=tb(null,u,a,g,f));else{if(a!=null){var v=a.$$typeof;if(v===$){u.tag=11,u=Gk(null,u,a,g,f);break t}else if(v===_){u.tag=14,u=Wk(null,u,a,g,f);break t}}throw u=J(a)||a,Error(s(306,u,""))}}return u;case 0:return tb(a,u,u.type,u.pendingProps,f);case 1:return g=u.type,v=ga(g,u.pendingProps),Jk(a,u,g,v,f);case 3:t:{if(Et(u,u.stateNode.containerInfo),a===null)throw Error(s(387));g=u.pendingProps;var C=u.memoizedState;v=C.element,E0(a,u),Au(u,g,null,f);var I=u.memoizedState;if(g=I.cache,so(u,un,g),g!==C.cache&&w0(u,[un],f,!0),Nu(),g=I.element,C.isDehydrated)if(C={element:g,isDehydrated:!1,cache:I.cache},u.updateQueue.baseState=C,u.memoizedState=C,u.flags&256){u=Zk(a,u,g,f);break t}else if(g!==v){v=ei(Error(s(424)),u),Cu(v),u=Zk(a,u,g,f);break t}else for(a=u.stateNode.containerInfo,a.nodeType===9?a=a.body:a=a.nodeName==="HTML"?a.ownerDocument.body:a,ze=oi(a.firstChild),Pn=u,re=!0,eo=null,ii=!0,f=qT(u,null,g,f),u.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling;else{if(la(),g===v){u=Ir(a,u,f);break t}Vn(a,u,g,f)}u=u.child}return u;case 26:return op(a,u),a===null?(f=f$(u.type,null,u.pendingProps,null))?u.memoizedState=f:re||(f=u.type,a=u.pendingProps,g=Cp(pt.current).createElement(f),g[zn]=u,g[ys]=a,Un(g,f,a),_n(g),u.stateNode=g):u.memoizedState=f$(u.type,a.memoizedProps,u.pendingProps,a.memoizedState),null;case 27:return Rt(u),a===null&&re&&(g=u.stateNode=u$(u.type,u.pendingProps,pt.current),Pn=u,ii=!0,v=ze,yo(u.type)?(Bb=v,ze=oi(g.firstChild)):ze=v),Vn(a,u,u.pendingProps.children,f),op(a,u),a===null&&(u.flags|=4194304),u.child;case 5:return a===null&&re&&((v=g=ze)&&(g=HP(g,u.type,u.pendingProps,ii),g!==null?(u.stateNode=g,Pn=u,ze=oi(g.firstChild),ii=!1,v=!0):v=!1),v||no(u)),Rt(u),v=u.type,C=u.pendingProps,I=a!==null?a.memoizedProps:null,g=C.children,Mb(v,C)?g=null:I!==null&&Mb(v,I)&&(u.flags|=32),u.memoizedState!==null&&(v=O0(a,u,aP,null,null,f),Yu._currentValue=v),op(a,u),Vn(a,u,g,f),u.child;case 6:return a===null&&re&&((a=f=ze)&&(f=qP(f,u.pendingProps,ii),f!==null?(u.stateNode=f,Pn=u,ze=null,a=!0):a=!1),a||no(u)),null;case 13:return Qk(a,u,f);case 4:return Et(u,u.stateNode.containerInfo),g=u.pendingProps,a===null?u.child=pa(u,null,g,f):Vn(a,u,g,f),u.child;case 11:return Gk(a,u,u.type,u.pendingProps,f);case 7:return Vn(a,u,u.pendingProps,f),u.child;case 8:return Vn(a,u,u.pendingProps.children,f),u.child;case 12:return Vn(a,u,u.pendingProps.children,f),u.child;case 10:return g=u.pendingProps,so(u,u.type,g.value),Vn(a,u,g.children,f),u.child;case 9:return v=u.type._context,g=u.pendingProps.children,ua(u),v=Bn(v),g=g(v),u.flags|=1,Vn(a,u,g,f),u.child;case 14:return Wk(a,u,u.type,u.pendingProps,f);case 15:return Hk(a,u,u.type,u.pendingProps,f);case 19:return e2(a,u,f);case 31:return mP(a,u,f);case 22:return qk(a,u,f,u.pendingProps);case 24:return ua(u),g=Bn(un),a===null?(v=T0(),v===null&&(v=Ae,C=S0(),v.pooledCache=C,C.refCount++,C!==null&&(v.pooledCacheLanes|=f),v=C),u.memoizedState={parent:g,cache:v},$0(u),so(u,un,v)):((a.lanes&f)!==0&&(E0(a,u),Au(u,null,null,f),Nu()),v=a.memoizedState,C=u.memoizedState,v.parent!==g?(v={parent:g,cache:g},u.memoizedState=v,u.lanes===0&&(u.memoizedState=u.updateQueue.baseState=v),so(u,un,g)):(g=C.cache,so(u,un,g),g!==v.cache&&w0(u,[un],f,!0))),Vn(a,u,u.pendingProps.children,f),u.child;case 29:throw u.pendingProps}throw Error(s(156,u.tag))}function Nr(a){a.flags|=4}function lb(a,u,f,g,v){if((u=(a.mode&32)!==0)&&(u=!1),u){if(a.flags|=16777216,(v&335544128)===v)if(a.stateNode.complete)a.flags|=8192;else if(N2())a.flags|=8192;else throw fa=Wf,k0}else a.flags&=-16777217}function s2(a,u){if(u.type!=="stylesheet"||(u.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!b$(u))if(N2())a.flags|=8192;else throw fa=Wf,k0}function lp(a,u){u!==null&&(a.flags|=4),a.flags&16384&&(u=a.tag!==22?FC():536870912,a.lanes|=u,Hl|=u)}function Fu(a,u){if(!re)switch(a.tailMode){case"hidden":u=a.tail;for(var f=null;u!==null;)u.alternate!==null&&(f=u),u=u.sibling;f===null?a.tail=null:f.sibling=null;break;case"collapsed":f=a.tail;for(var g=null;f!==null;)f.alternate!==null&&(g=f),f=f.sibling;g===null?u||a.tail===null?a.tail=null:a.tail.sibling=null:g.sibling=null}}function Pe(a){var u=a.alternate!==null&&a.alternate.child===a.child,f=0,g=0;if(u)for(var v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags&65011712,g|=v.flags&65011712,v.return=a,v=v.sibling;else for(v=a.child;v!==null;)f|=v.lanes|v.childLanes,g|=v.subtreeFlags,g|=v.flags,v.return=a,v=v.sibling;return a.subtreeFlags|=g,a.childLanes=f,u}function yP(a,u,f){var g=u.pendingProps;switch(g0(u),u.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Pe(u),null;case 1:return Pe(u),null;case 3:return f=u.stateNode,g=null,a!==null&&(g=a.memoizedState.cache),u.memoizedState.cache!==g&&(u.flags|=2048),kr(un),Ct(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(a===null||a.child===null)&&(Dl(u)?Nr(u):a===null||a.memoizedState.isDehydrated&&(u.flags&256)===0||(u.flags|=1024,b0())),Pe(u),null;case 26:var v=u.type,C=u.memoizedState;return a===null?(Nr(u),C!==null?(Pe(u),s2(u,C)):(Pe(u),lb(u,v,null,g,f))):C?C!==a.memoizedState?(Nr(u),Pe(u),s2(u,C)):(Pe(u),u.flags&=-16777217):(a=a.memoizedProps,a!==g&&Nr(u),Pe(u),lb(u,v,a,g,f)),null;case 27:if(zt(u),f=pt.current,v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Nr(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return Pe(u),null}a=ct.current,Dl(u)?FT(u):(a=u$(v,g,f),u.stateNode=a,Nr(u))}return Pe(u),null;case 5:if(zt(u),v=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==g&&Nr(u);else{if(!g){if(u.stateNode===null)throw Error(s(166));return Pe(u),null}if(C=ct.current,Dl(u))FT(u);else{var I=Cp(pt.current);switch(C){case 1:C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":C=I.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":C=I.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":C=I.createElement("div"),C.innerHTML="<script><\/script>",C=C.removeChild(C.firstChild);break;case"select":C=typeof g.is=="string"?I.createElement("select",{is:g.is}):I.createElement("select"),g.multiple?C.multiple=!0:g.size&&(C.size=g.size);break;default:C=typeof g.is=="string"?I.createElement(v,{is:g.is}):I.createElement(v)}}C[zn]=u,C[ys]=g;t:for(I=u.child;I!==null;){if(I.tag===5||I.tag===6)C.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===u)break t;for(;I.sibling===null;){if(I.return===null||I.return===u)break t;I=I.return}I.sibling.return=I.return,I=I.sibling}u.stateNode=C;t:switch(Un(C,v,g),v){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break t;case"img":g=!0;break t;default:g=!1}g&&Nr(u)}}return Pe(u),lb(u,u.type,a===null?null:a.memoizedProps,u.pendingProps,f),null;case 6:if(a&&u.stateNode!=null)a.memoizedProps!==g&&Nr(u);else{if(typeof g!="string"&&u.stateNode===null)throw Error(s(166));if(a=pt.current,Dl(u)){if(a=u.stateNode,f=u.memoizedProps,g=null,v=Pn,v!==null)switch(v.tag){case 27:case 5:g=v.memoizedProps}a[zn]=u,a=!!(a.nodeValue===f||g!==null&&g.suppressHydrationWarning===!0||Q2(a.nodeValue,f)),a||no(u,!0)}else a=Cp(a).createTextNode(g),a[zn]=u,u.stateNode=a}return Pe(u),null;case 31:if(f=u.memoizedState,a===null||a.memoizedState!==null){if(g=Dl(u),f!==null){if(a===null){if(!g)throw Error(s(318));if(a=u.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(s(557));a[zn]=u}else la(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Pe(u),a=!1}else f=b0(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=f),a=!0;if(!a)return u.flags&256?(zs(u),u):(zs(u),null);if((u.flags&128)!==0)throw Error(s(558))}return Pe(u),null;case 13:if(g=u.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(v=Dl(u),g!==null&&g.dehydrated!==null){if(a===null){if(!v)throw Error(s(318));if(v=u.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(s(317));v[zn]=u}else la(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Pe(u),v=!1}else v=b0(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=v),v=!0;if(!v)return u.flags&256?(zs(u),u):(zs(u),null)}return zs(u),(u.flags&128)!==0?(u.lanes=f,u):(f=g!==null,a=a!==null&&a.memoizedState!==null,f&&(g=u.child,v=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(v=g.alternate.memoizedState.cachePool.pool),C=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(C=g.memoizedState.cachePool.pool),C!==v&&(g.flags|=2048)),f!==a&&f&&(u.child.flags|=8192),lp(u,u.updateQueue),Pe(u),null);case 4:return Ct(),a===null&&Ab(u.stateNode.containerInfo),Pe(u),null;case 10:return kr(u.type),Pe(u),null;case 19:if(j(on),g=u.memoizedState,g===null)return Pe(u),null;if(v=(u.flags&128)!==0,C=g.rendering,C===null)if(v)Fu(g,!1);else{if(Ye!==0||a!==null&&(a.flags&128)!==0)for(a=u.child;a!==null;){if(C=Xf(a),C!==null){for(u.flags|=128,Fu(g,!1),a=C.updateQueue,u.updateQueue=a,lp(u,a),u.subtreeFlags=0,a=f,f=u.child;f!==null;)_T(f,a),f=f.sibling;return Q(on,on.current&1|2),re&&Cr(u,g.treeForkCount),u.child}a=a.sibling}g.tail!==null&&Le()>fp&&(u.flags|=128,v=!0,Fu(g,!1),u.lanes=4194304)}else{if(!v)if(a=Xf(C),a!==null){if(u.flags|=128,v=!0,a=a.updateQueue,u.updateQueue=a,lp(u,a),Fu(g,!0),g.tail===null&&g.tailMode==="hidden"&&!C.alternate&&!re)return Pe(u),null}else 2*Le()-g.renderingStartTime>fp&&f!==536870912&&(u.flags|=128,v=!0,Fu(g,!1),u.lanes=4194304);g.isBackwards?(C.sibling=u.child,u.child=C):(a=g.last,a!==null?a.sibling=C:u.child=C,g.last=C)}return g.tail!==null?(a=g.tail,g.rendering=a,g.tail=a.sibling,g.renderingStartTime=Le(),a.sibling=null,f=on.current,Q(on,v?f&1|2:f&1),re&&Cr(u,g.treeForkCount),a):(Pe(u),null);case 22:case 23:return zs(u),_0(),g=u.memoizedState!==null,a!==null?a.memoizedState!==null!==g&&(u.flags|=8192):g&&(u.flags|=8192),g?(f&536870912)!==0&&(u.flags&128)===0&&(Pe(u),u.subtreeFlags&6&&(u.flags|=8192)):Pe(u),f=u.updateQueue,f!==null&&lp(u,f.retryQueue),f=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),g=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(g=u.memoizedState.cachePool.pool),g!==f&&(u.flags|=2048),a!==null&&j(ha),null;case 24:return f=null,a!==null&&(f=a.memoizedState.cache),u.memoizedState.cache!==f&&(u.flags|=2048),kr(un),Pe(u),null;case 25:return null;case 30:return null}throw Error(s(156,u.tag))}function bP(a,u){switch(g0(u),u.tag){case 1:return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 3:return kr(un),Ct(),a=u.flags,(a&65536)!==0&&(a&128)===0?(u.flags=a&-65537|128,u):null;case 26:case 27:case 5:return zt(u),null;case 31:if(u.memoizedState!==null){if(zs(u),u.alternate===null)throw Error(s(340));la()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 13:if(zs(u),a=u.memoizedState,a!==null&&a.dehydrated!==null){if(u.alternate===null)throw Error(s(340));la()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 19:return j(on),null;case 4:return Ct(),null;case 10:return kr(u.type),null;case 22:case 23:return zs(u),_0(),a!==null&&j(ha),a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 24:return kr(un),null;case 25:return null;default:return null}}function i2(a,u){switch(g0(u),u.tag){case 3:kr(un),Ct();break;case 26:case 27:case 5:zt(u);break;case 4:Ct();break;case 31:u.memoizedState!==null&&zs(u);break;case 13:zs(u);break;case 19:j(on);break;case 10:kr(u.type);break;case 22:case 23:zs(u),_0(),a!==null&&j(ha);break;case 24:kr(un)}}function Lu(a,u){try{var f=u.updateQueue,g=f!==null?f.lastEffect:null;if(g!==null){var v=g.next;f=v;do{if((f.tag&a)===a){g=void 0;var C=f.create,I=f.inst;g=C(),I.destroy=g}f=f.next}while(f!==v)}}catch(O){Ce(u,u.return,O)}}function co(a,u,f){try{var g=u.updateQueue,v=g!==null?g.lastEffect:null;if(v!==null){var C=v.next;g=C;do{if((g.tag&a)===a){var I=g.inst,O=I.destroy;if(O!==void 0){I.destroy=void 0,v=u;var G=f,ot=O;try{ot()}catch(mt){Ce(v,G,mt)}}}g=g.next}while(g!==C)}}catch(mt){Ce(u,u.return,mt)}}function r2(a){var u=a.updateQueue;if(u!==null){var f=a.stateNode;try{XT(u,f)}catch(g){Ce(a,a.return,g)}}}function o2(a,u,f){f.props=ga(a.type,a.memoizedProps),f.state=a.memoizedState;try{f.componentWillUnmount()}catch(g){Ce(a,u,g)}}function zu(a,u){try{var f=a.ref;if(f!==null){switch(a.tag){case 26:case 27:case 5:var g=a.stateNode;break;case 30:g=a.stateNode;break;default:g=a.stateNode}typeof f=="function"?a.refCleanup=f(g):f.current=g}}catch(v){Ce(a,u,v)}}function Xi(a,u){var f=a.ref,g=a.refCleanup;if(f!==null)if(typeof g=="function")try{g()}catch(v){Ce(a,u,v)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(v){Ce(a,u,v)}else f.current=null}function a2(a){var u=a.type,f=a.memoizedProps,g=a.stateNode;try{t:switch(u){case"button":case"input":case"select":case"textarea":f.autoFocus&&g.focus();break t;case"img":f.src?g.src=f.src:f.srcSet&&(g.srcset=f.srcSet)}}catch(v){Ce(a,a.return,v)}}function cb(a,u,f){try{var g=a.stateNode;BP(g,a.type,f,u),g[ys]=u}catch(v){Ce(a,a.return,v)}}function l2(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&yo(a.type)||a.tag===4}function ub(a){t:for(;;){for(;a.sibling===null;){if(a.return===null||l2(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&yo(a.type)||a.flags&2||a.child===null||a.tag===4)continue t;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function hb(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(a,u):(u=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,u.appendChild(a),f=f._reactRootContainer,f!=null||u.onclick!==null||(u.onclick=vr));else if(g!==4&&(g===27&&yo(a.type)&&(f=a.stateNode,u=null),a=a.child,a!==null))for(hb(a,u,f),a=a.sibling;a!==null;)hb(a,u,f),a=a.sibling}function cp(a,u,f){var g=a.tag;if(g===5||g===6)a=a.stateNode,u?f.insertBefore(a,u):f.appendChild(a);else if(g!==4&&(g===27&&yo(a.type)&&(f=a.stateNode),a=a.child,a!==null))for(cp(a,u,f),a=a.sibling;a!==null;)cp(a,u,f),a=a.sibling}function c2(a){var u=a.stateNode,f=a.memoizedProps;try{for(var g=a.type,v=u.attributes;v.length;)u.removeAttributeNode(v[0]);Un(u,g,f),u[zn]=a,u[ys]=f}catch(C){Ce(a,a.return,C)}}var Ar=!1,fn=!1,db=!1,u2=typeof WeakSet=="function"?WeakSet:Set,Rn=null;function xP(a,u){if(a=a.containerInfo,Db=Ap,a=ST(a),r0(a)){if("selectionStart"in a)var f={start:a.selectionStart,end:a.selectionEnd};else t:{f=(f=a.ownerDocument)&&f.defaultView||window;var g=f.getSelection&&f.getSelection();if(g&&g.rangeCount!==0){f=g.anchorNode;var v=g.anchorOffset,C=g.focusNode;g=g.focusOffset;try{f.nodeType,C.nodeType}catch{f=null;break t}var I=0,O=-1,G=-1,ot=0,mt=0,yt=a,lt=null;e:for(;;){for(var ht;yt!==f||v!==0&&yt.nodeType!==3||(O=I+v),yt!==C||g!==0&&yt.nodeType!==3||(G=I+g),yt.nodeType===3&&(I+=yt.nodeValue.length),(ht=yt.firstChild)!==null;)lt=yt,yt=ht;for(;;){if(yt===a)break e;if(lt===f&&++ot===v&&(O=I),lt===C&&++mt===g&&(G=I),(ht=yt.nextSibling)!==null)break;yt=lt,lt=yt.parentNode}yt=ht}f=O===-1||G===-1?null:{start:O,end:G}}else f=null}f=f||{start:0,end:0}}else f=null;for(Ob={focusedElem:a,selectionRange:f},Ap=!1,Rn=u;Rn!==null;)if(u=Rn,a=u.child,(u.subtreeFlags&1028)!==0&&a!==null)a.return=u,Rn=a;else for(;Rn!==null;){switch(u=Rn,C=u.alternate,a=u.flags,u.tag){case 0:if((a&4)!==0&&(a=u.updateQueue,a=a!==null?a.events:null,a!==null))for(f=0;f<a.length;f++)v=a[f],v.ref.impl=v.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&C!==null){a=void 0,f=u,v=C.memoizedProps,C=C.memoizedState,g=f.stateNode;try{var It=ga(f.type,v);a=g.getSnapshotBeforeUpdate(It,C),g.__reactInternalSnapshotBeforeUpdate=a}catch(Pt){Ce(f,f.return,Pt)}}break;case 3:if((a&1024)!==0){if(a=u.stateNode.containerInfo,f=a.nodeType,f===9)Lb(a);else if(f===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":Lb(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(s(163))}if(a=u.sibling,a!==null){a.return=u.return,Rn=a;break}Rn=u.return}}function h2(a,u,f){var g=f.flags;switch(f.tag){case 0:case 11:case 15:Rr(a,f),g&4&&Lu(5,f);break;case 1:if(Rr(a,f),g&4)if(a=f.stateNode,u===null)try{a.componentDidMount()}catch(I){Ce(f,f.return,I)}else{var v=ga(f.type,u.memoizedProps);u=u.memoizedState;try{a.componentDidUpdate(v,u,a.__reactInternalSnapshotBeforeUpdate)}catch(I){Ce(f,f.return,I)}}g&64&&r2(f),g&512&&zu(f,f.return);break;case 3:if(Rr(a,f),g&64&&(a=f.updateQueue,a!==null)){if(u=null,f.child!==null)switch(f.child.tag){case 27:case 5:u=f.child.stateNode;break;case 1:u=f.child.stateNode}try{XT(a,u)}catch(I){Ce(f,f.return,I)}}break;case 27:u===null&&g&4&&c2(f);case 26:case 5:Rr(a,f),u===null&&g&4&&a2(f),g&512&&zu(f,f.return);break;case 12:Rr(a,f);break;case 31:Rr(a,f),g&4&&p2(a,f);break;case 13:Rr(a,f),g&4&&m2(a,f),g&64&&(a=f.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(f=IP.bind(null,f),KP(a,f))));break;case 22:if(g=f.memoizedState!==null||Ar,!g){u=u!==null&&u.memoizedState!==null||fn,v=Ar;var C=fn;Ar=g,(fn=u)&&!C?Dr(a,f,(f.subtreeFlags&8772)!==0):Rr(a,f),Ar=v,fn=C}break;case 30:break;default:Rr(a,f)}}function d2(a){var u=a.alternate;u!==null&&(a.alternate=null,d2(u)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(u=a.stateNode,u!==null&&Uy(u)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var Ue=null,xs=!1;function _r(a,u,f){for(f=f.child;f!==null;)f2(a,u,f),f=f.sibling}function f2(a,u,f){if(as&&typeof as.onCommitFiberUnmount=="function")try{as.onCommitFiberUnmount(Wi,f)}catch{}switch(f.tag){case 26:fn||Xi(f,u),_r(a,u,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:fn||Xi(f,u);var g=Ue,v=xs;yo(f.type)&&(Ue=f.stateNode,xs=!1),_r(a,u,f),qu(f.stateNode),Ue=g,xs=v;break;case 5:fn||Xi(f,u);case 6:if(g=Ue,v=xs,Ue=null,_r(a,u,f),Ue=g,xs=v,Ue!==null)if(xs)try{(Ue.nodeType===9?Ue.body:Ue.nodeName==="HTML"?Ue.ownerDocument.body:Ue).removeChild(f.stateNode)}catch(C){Ce(f,u,C)}else try{Ue.removeChild(f.stateNode)}catch(C){Ce(f,u,C)}break;case 18:Ue!==null&&(xs?(a=Ue,r$(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,f.stateNode),tc(a)):r$(Ue,f.stateNode));break;case 4:g=Ue,v=xs,Ue=f.stateNode.containerInfo,xs=!0,_r(a,u,f),Ue=g,xs=v;break;case 0:case 11:case 14:case 15:co(2,f,u),fn||co(4,f,u),_r(a,u,f);break;case 1:fn||(Xi(f,u),g=f.stateNode,typeof g.componentWillUnmount=="function"&&o2(f,u,g)),_r(a,u,f);break;case 21:_r(a,u,f);break;case 22:fn=(g=fn)||f.memoizedState!==null,_r(a,u,f),fn=g;break;default:_r(a,u,f)}}function p2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{tc(a)}catch(f){Ce(u,u.return,f)}}}function m2(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{tc(a)}catch(f){Ce(u,u.return,f)}}function vP(a){switch(a.tag){case 31:case 13:case 19:var u=a.stateNode;return u===null&&(u=a.stateNode=new u2),u;case 22:return a=a.stateNode,u=a._retryCache,u===null&&(u=a._retryCache=new u2),u;default:throw Error(s(435,a.tag))}}function up(a,u){var f=vP(a);u.forEach(function(g){if(!f.has(g)){f.add(g);var v=NP.bind(null,a,g);g.then(v,v)}})}function vs(a,u){var f=u.deletions;if(f!==null)for(var g=0;g<f.length;g++){var v=f[g],C=a,I=u,O=I;t:for(;O!==null;){switch(O.tag){case 27:if(yo(O.type)){Ue=O.stateNode,xs=!1;break t}break;case 5:Ue=O.stateNode,xs=!1;break t;case 3:case 4:Ue=O.stateNode.containerInfo,xs=!0;break t}O=O.return}if(Ue===null)throw Error(s(160));f2(C,I,v),Ue=null,xs=!1,C=v.alternate,C!==null&&(C.return=null),v.return=null}if(u.subtreeFlags&13886)for(u=u.child;u!==null;)g2(u,a),u=u.sibling}var $i=null;function g2(a,u){var f=a.alternate,g=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:vs(u,a),ws(a),g&4&&(co(3,a,a.return),Lu(3,a),co(5,a,a.return));break;case 1:vs(u,a),ws(a),g&512&&(fn||f===null||Xi(f,f.return)),g&64&&Ar&&(a=a.updateQueue,a!==null&&(g=a.callbacks,g!==null&&(f=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=f===null?g:f.concat(g))));break;case 26:var v=$i;if(vs(u,a),ws(a),g&512&&(fn||f===null||Xi(f,f.return)),g&4){var C=f!==null?f.memoizedState:null;if(g=a.memoizedState,f===null)if(g===null)if(a.stateNode===null){t:{g=a.type,f=a.memoizedProps,v=v.ownerDocument||v;e:switch(g){case"title":C=v.getElementsByTagName("title")[0],(!C||C[hu]||C[zn]||C.namespaceURI==="http://www.w3.org/2000/svg"||C.hasAttribute("itemprop"))&&(C=v.createElement(g),v.head.insertBefore(C,v.querySelector("head > title"))),Un(C,g,f),C[zn]=a,_n(C),g=C;break t;case"link":var I=g$("link","href",v).get(g+(f.href||""));if(I){for(var O=0;O<I.length;O++)if(C=I[O],C.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&C.getAttribute("rel")===(f.rel==null?null:f.rel)&&C.getAttribute("title")===(f.title==null?null:f.title)&&C.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){I.splice(O,1);break e}}C=v.createElement(g),Un(C,g,f),v.head.appendChild(C);break;case"meta":if(I=g$("meta","content",v).get(g+(f.content||""))){for(O=0;O<I.length;O++)if(C=I[O],C.getAttribute("content")===(f.content==null?null:""+f.content)&&C.getAttribute("name")===(f.name==null?null:f.name)&&C.getAttribute("property")===(f.property==null?null:f.property)&&C.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&C.getAttribute("charset")===(f.charSet==null?null:f.charSet)){I.splice(O,1);break e}}C=v.createElement(g),Un(C,g,f),v.head.appendChild(C);break;default:throw Error(s(468,g))}C[zn]=a,_n(C),g=C}a.stateNode=g}else y$(v,a.type,a.stateNode);else a.stateNode=m$(v,g,a.memoizedProps);else C!==g?(C===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):C.count--,g===null?y$(v,a.type,a.stateNode):m$(v,g,a.memoizedProps)):g===null&&a.stateNode!==null&&cb(a,a.memoizedProps,f.memoizedProps)}break;case 27:vs(u,a),ws(a),g&512&&(fn||f===null||Xi(f,f.return)),f!==null&&g&4&&cb(a,a.memoizedProps,f.memoizedProps);break;case 5:if(vs(u,a),ws(a),g&512&&(fn||f===null||Xi(f,f.return)),a.flags&32){v=a.stateNode;try{Cl(v,"")}catch(It){Ce(a,a.return,It)}}g&4&&a.stateNode!=null&&(v=a.memoizedProps,cb(a,v,f!==null?f.memoizedProps:v)),g&1024&&(db=!0);break;case 6:if(vs(u,a),ws(a),g&4){if(a.stateNode===null)throw Error(s(162));g=a.memoizedProps,f=a.stateNode;try{f.nodeValue=g}catch(It){Ce(a,a.return,It)}}break;case 3:if($p=null,v=$i,$i=Tp(u.containerInfo),vs(u,a),$i=v,ws(a),g&4&&f!==null&&f.memoizedState.isDehydrated)try{tc(u.containerInfo)}catch(It){Ce(a,a.return,It)}db&&(db=!1,y2(a));break;case 4:g=$i,$i=Tp(a.stateNode.containerInfo),vs(u,a),ws(a),$i=g;break;case 12:vs(u,a),ws(a);break;case 31:vs(u,a),ws(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,up(a,g)));break;case 13:vs(u,a),ws(a),a.child.flags&8192&&a.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(dp=Le()),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,up(a,g)));break;case 22:v=a.memoizedState!==null;var G=f!==null&&f.memoizedState!==null,ot=Ar,mt=fn;if(Ar=ot||v,fn=mt||G,vs(u,a),fn=mt,Ar=ot,ws(a),g&8192)t:for(u=a.stateNode,u._visibility=v?u._visibility&-2:u._visibility|1,v&&(f===null||G||Ar||fn||ya(a)),f=null,u=a;;){if(u.tag===5||u.tag===26){if(f===null){G=f=u;try{if(C=G.stateNode,v)I=C.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{O=G.stateNode;var yt=G.memoizedProps.style,lt=yt!=null&&yt.hasOwnProperty("display")?yt.display:null;O.style.display=lt==null||typeof lt=="boolean"?"":(""+lt).trim()}}catch(It){Ce(G,G.return,It)}}}else if(u.tag===6){if(f===null){G=u;try{G.stateNode.nodeValue=v?"":G.memoizedProps}catch(It){Ce(G,G.return,It)}}}else if(u.tag===18){if(f===null){G=u;try{var ht=G.stateNode;v?o$(ht,!0):o$(G.stateNode,!1)}catch(It){Ce(G,G.return,It)}}}else if((u.tag!==22&&u.tag!==23||u.memoizedState===null||u===a)&&u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break t;for(;u.sibling===null;){if(u.return===null||u.return===a)break t;f===u&&(f=null),u=u.return}f===u&&(f=null),u.sibling.return=u.return,u=u.sibling}g&4&&(g=a.updateQueue,g!==null&&(f=g.retryQueue,f!==null&&(g.retryQueue=null,up(a,f))));break;case 19:vs(u,a),ws(a),g&4&&(g=a.updateQueue,g!==null&&(a.updateQueue=null,up(a,g)));break;case 30:break;case 21:break;default:vs(u,a),ws(a)}}function ws(a){var u=a.flags;if(u&2){try{for(var f,g=a.return;g!==null;){if(l2(g)){f=g;break}g=g.return}if(f==null)throw Error(s(160));switch(f.tag){case 27:var v=f.stateNode,C=ub(a);cp(a,C,v);break;case 5:var I=f.stateNode;f.flags&32&&(Cl(I,""),f.flags&=-33);var O=ub(a);cp(a,O,I);break;case 3:case 4:var G=f.stateNode.containerInfo,ot=ub(a);hb(a,ot,G);break;default:throw Error(s(161))}}catch(mt){Ce(a,a.return,mt)}a.flags&=-3}u&4096&&(a.flags&=-4097)}function y2(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var u=a;y2(u),u.tag===5&&u.flags&1024&&u.stateNode.reset(),a=a.sibling}}function Rr(a,u){if(u.subtreeFlags&8772)for(u=u.child;u!==null;)h2(a,u.alternate,u),u=u.sibling}function ya(a){for(a=a.child;a!==null;){var u=a;switch(u.tag){case 0:case 11:case 14:case 15:co(4,u,u.return),ya(u);break;case 1:Xi(u,u.return);var f=u.stateNode;typeof f.componentWillUnmount=="function"&&o2(u,u.return,f),ya(u);break;case 27:qu(u.stateNode);case 26:case 5:Xi(u,u.return),ya(u);break;case 22:u.memoizedState===null&&ya(u);break;case 30:ya(u);break;default:ya(u)}a=a.sibling}}function Dr(a,u,f){for(f=f&&(u.subtreeFlags&8772)!==0,u=u.child;u!==null;){var g=u.alternate,v=a,C=u,I=C.flags;switch(C.tag){case 0:case 11:case 15:Dr(v,C,f),Lu(4,C);break;case 1:if(Dr(v,C,f),g=C,v=g.stateNode,typeof v.componentDidMount=="function")try{v.componentDidMount()}catch(ot){Ce(g,g.return,ot)}if(g=C,v=g.updateQueue,v!==null){var O=g.stateNode;try{var G=v.shared.hiddenCallbacks;if(G!==null)for(v.shared.hiddenCallbacks=null,v=0;v<G.length;v++)KT(G[v],O)}catch(ot){Ce(g,g.return,ot)}}f&&I&64&&r2(C),zu(C,C.return);break;case 27:c2(C);case 26:case 5:Dr(v,C,f),f&&g===null&&I&4&&a2(C),zu(C,C.return);break;case 12:Dr(v,C,f);break;case 31:Dr(v,C,f),f&&I&4&&p2(v,C);break;case 13:Dr(v,C,f),f&&I&4&&m2(v,C);break;case 22:C.memoizedState===null&&Dr(v,C,f),zu(C,C.return);break;case 30:break;default:Dr(v,C,f)}u=u.sibling}}function fb(a,u){var f=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(f=a.memoizedState.cachePool.pool),a=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(a=u.memoizedState.cachePool.pool),a!==f&&(a!=null&&a.refCount++,f!=null&&Tu(f))}function pb(a,u){a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Tu(a))}function Ei(a,u,f,g){if(u.subtreeFlags&10256)for(u=u.child;u!==null;)b2(a,u,f,g),u=u.sibling}function b2(a,u,f,g){var v=u.flags;switch(u.tag){case 0:case 11:case 15:Ei(a,u,f,g),v&2048&&Lu(9,u);break;case 1:Ei(a,u,f,g);break;case 3:Ei(a,u,f,g),v&2048&&(a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Tu(a)));break;case 12:if(v&2048){Ei(a,u,f,g),a=u.stateNode;try{var C=u.memoizedProps,I=C.id,O=C.onPostCommit;typeof O=="function"&&O(I,u.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(G){Ce(u,u.return,G)}}else Ei(a,u,f,g);break;case 31:Ei(a,u,f,g);break;case 13:Ei(a,u,f,g);break;case 23:break;case 22:C=u.stateNode,I=u.alternate,u.memoizedState!==null?C._visibility&2?Ei(a,u,f,g):Pu(a,u):C._visibility&2?Ei(a,u,f,g):(C._visibility|=2,jl(a,u,f,g,(u.subtreeFlags&10256)!==0||!1)),v&2048&&fb(I,u);break;case 24:Ei(a,u,f,g),v&2048&&pb(u.alternate,u);break;default:Ei(a,u,f,g)}}function jl(a,u,f,g,v){for(v=v&&((u.subtreeFlags&10256)!==0||!1),u=u.child;u!==null;){var C=a,I=u,O=f,G=g,ot=I.flags;switch(I.tag){case 0:case 11:case 15:jl(C,I,O,G,v),Lu(8,I);break;case 23:break;case 22:var mt=I.stateNode;I.memoizedState!==null?mt._visibility&2?jl(C,I,O,G,v):Pu(C,I):(mt._visibility|=2,jl(C,I,O,G,v)),v&&ot&2048&&fb(I.alternate,I);break;case 24:jl(C,I,O,G,v),v&&ot&2048&&pb(I.alternate,I);break;default:jl(C,I,O,G,v)}u=u.sibling}}function Pu(a,u){if(u.subtreeFlags&10256)for(u=u.child;u!==null;){var f=a,g=u,v=g.flags;switch(g.tag){case 22:Pu(f,g),v&2048&&fb(g.alternate,g);break;case 24:Pu(f,g),v&2048&&pb(g.alternate,g);break;default:Pu(f,g)}u=u.sibling}}var Bu=8192;function Gl(a,u,f){if(a.subtreeFlags&Bu)for(a=a.child;a!==null;)x2(a,u,f),a=a.sibling}function x2(a,u,f){switch(a.tag){case 26:Gl(a,u,f),a.flags&Bu&&a.memoizedState!==null&&oB(f,$i,a.memoizedState,a.memoizedProps);break;case 5:Gl(a,u,f);break;case 3:case 4:var g=$i;$i=Tp(a.stateNode.containerInfo),Gl(a,u,f),$i=g;break;case 22:a.memoizedState===null&&(g=a.alternate,g!==null&&g.memoizedState!==null?(g=Bu,Bu=16777216,Gl(a,u,f),Bu=g):Gl(a,u,f));break;default:Gl(a,u,f)}}function v2(a){var u=a.alternate;if(u!==null&&(a=u.child,a!==null)){u.child=null;do u=a.sibling,a.sibling=null,a=u;while(a!==null)}}function Vu(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Rn=g,S2(g,a)}v2(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)w2(a),a=a.sibling}function w2(a){switch(a.tag){case 0:case 11:case 15:Vu(a),a.flags&2048&&co(9,a,a.return);break;case 3:Vu(a);break;case 12:Vu(a);break;case 22:var u=a.stateNode;a.memoizedState!==null&&u._visibility&2&&(a.return===null||a.return.tag!==13)?(u._visibility&=-3,hp(a)):Vu(a);break;default:Vu(a)}}function hp(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var g=u[f];Rn=g,S2(g,a)}v2(a)}for(a=a.child;a!==null;){switch(u=a,u.tag){case 0:case 11:case 15:co(8,u,u.return),hp(u);break;case 22:f=u.stateNode,f._visibility&2&&(f._visibility&=-3,hp(u));break;default:hp(u)}a=a.sibling}}function S2(a,u){for(;Rn!==null;){var f=Rn;switch(f.tag){case 0:case 11:case 15:co(8,f,u);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var g=f.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Tu(f.memoizedState.cache)}if(g=f.child,g!==null)g.return=f,Rn=g;else t:for(f=a;Rn!==null;){g=Rn;var v=g.sibling,C=g.return;if(d2(g),g===f){Rn=null;break t}if(v!==null){v.return=C,Rn=v;break t}Rn=C}}}var wP={getCacheForType:function(a){var u=Bn(un),f=u.data.get(a);return f===void 0&&(f=a(),u.data.set(a,f)),f},cacheSignal:function(){return Bn(un).controller.signal}},SP=typeof WeakMap=="function"?WeakMap:Map,be=0,Ae=null,te=null,se=0,Se=0,Ps=null,uo=!1,Wl=!1,mb=!1,Or=0,Ye=0,ho=0,ba=0,gb=0,Bs=0,Hl=0,Uu=null,Ss=null,yb=!1,dp=0,C2=0,fp=1/0,pp=null,fo=null,Cn=0,po=null,ql=null,Mr=0,bb=0,xb=null,T2=null,ju=0,vb=null;function Vs(){return(be&2)!==0&&se!==0?se&-se:z.T!==null?$b():BC()}function k2(){if(Bs===0)if((se&536870912)===0||re){var a=Sf;Sf<<=1,(Sf&3932160)===0&&(Sf=262144),Bs=a}else Bs=536870912;return a=Ls.current,a!==null&&(a.flags|=32),Bs}function Cs(a,u,f){(a===Ae&&(Se===2||Se===9)||a.cancelPendingCommit!==null)&&(Kl(a,0),mo(a,se,Bs,!1)),uu(a,f),((be&2)===0||a!==Ae)&&(a===Ae&&((be&2)===0&&(ba|=f),Ye===4&&mo(a,se,Bs,!1)),Yi(a))}function $2(a,u,f){if((be&6)!==0)throw Error(s(327));var g=!f&&(u&127)===0&&(u&a.expiredLanes)===0||cu(a,u),v=g?kP(a,u):Sb(a,u,!0),C=g;do{if(v===0){Wl&&!g&&mo(a,u,0,!1);break}else{if(f=a.current.alternate,C&&!CP(f)){v=Sb(a,u,!1),C=!1;continue}if(v===2){if(C=u,a.errorRecoveryDisabledLanes&C)var I=0;else I=a.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){u=I;t:{var O=a;v=Uu;var G=O.current.memoizedState.isDehydrated;if(G&&(Kl(O,I).flags|=256),I=Sb(O,I,!1),I!==2){if(mb&&!G){O.errorRecoveryDisabledLanes|=C,ba|=C,v=4;break t}C=Ss,Ss=v,C!==null&&(Ss===null?Ss=C:Ss.push.apply(Ss,C))}v=I}if(C=!1,v!==2)continue}}if(v===1){Kl(a,0),mo(a,u,0,!0);break}t:{switch(g=a,C=v,C){case 0:case 1:throw Error(s(345));case 4:if((u&4194048)!==u)break;case 6:mo(g,u,Bs,!uo);break t;case 2:Ss=null;break;case 3:case 5:break;default:throw Error(s(329))}if((u&62914560)===u&&(v=dp+300-Le(),10<v)){if(mo(g,u,Bs,!uo),Tf(g,0,!0)!==0)break t;Mr=u,g.timeoutHandle=s$(E2.bind(null,g,f,Ss,pp,yb,u,Bs,ba,Hl,uo,C,"Throttled",-0,0),v);break t}E2(g,f,Ss,pp,yb,u,Bs,ba,Hl,uo,C,null,-0,0)}}break}while(!0);Yi(a)}function E2(a,u,f,g,v,C,I,O,G,ot,mt,yt,lt,ht){if(a.timeoutHandle=-1,yt=u.subtreeFlags,yt&8192||(yt&16785408)===16785408){yt={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:vr},x2(u,C,yt);var It=(C&62914560)===C?dp-Le():(C&4194048)===C?C2-Le():0;if(It=aB(yt,It),It!==null){Mr=C,a.cancelPendingCommit=It(M2.bind(null,a,u,C,f,g,v,I,O,G,mt,yt,null,lt,ht)),mo(a,C,I,!ot);return}}M2(a,u,C,f,g,v,I,O,G)}function CP(a){for(var u=a;;){var f=u.tag;if((f===0||f===11||f===15)&&u.flags&16384&&(f=u.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var g=0;g<f.length;g++){var v=f[g],C=v.getSnapshot;v=v.value;try{if(!Ms(C(),v))return!1}catch{return!1}}if(f=u.child,u.subtreeFlags&16384&&f!==null)f.return=u,u=f;else{if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return!0;u=u.return}u.sibling.return=u.return,u=u.sibling}}return!0}function mo(a,u,f,g){u&=~gb,u&=~ba,a.suspendedLanes|=u,a.pingedLanes&=~u,g&&(a.warmLanes|=u),g=a.expirationTimes;for(var v=u;0<v;){var C=31-Os(v),I=1<<C;g[C]=-1,v&=~I}f!==0&&LC(a,f,u)}function mp(){return(be&6)===0?(Gu(0),!1):!0}function wb(){if(te!==null){if(Se===0)var a=te.return;else a=te,Tr=ca=null,L0(a),zl=null,$u=0,a=te;for(;a!==null;)i2(a.alternate,a),a=a.return;te=null}}function Kl(a,u){var f=a.timeoutHandle;f!==-1&&(a.timeoutHandle=-1,jP(f)),f=a.cancelPendingCommit,f!==null&&(a.cancelPendingCommit=null,f()),Mr=0,wb(),Ae=a,te=f=Sr(a.current,null),se=u,Se=0,Ps=null,uo=!1,Wl=cu(a,u),mb=!1,Hl=Bs=gb=ba=ho=Ye=0,Ss=Uu=null,yb=!1,(u&8)!==0&&(u|=u&32);var g=a.entangledLanes;if(g!==0)for(a=a.entanglements,g&=u;0<g;){var v=31-Os(g),C=1<<v;u|=a[v],g&=~C}return Or=u,Ff(),f}function I2(a,u){qt=null,z.H=Ou,u===Ll||u===Gf?(u=GT(),Se=3):u===k0?(u=GT(),Se=4):Se=u===Q0?8:u!==null&&typeof u=="object"&&typeof u.then=="function"?6:1,Ps=u,te===null&&(Ye=1,ip(a,ei(u,a.current)))}function N2(){var a=Ls.current;return a===null?!0:(se&4194048)===se?ri===null:(se&62914560)===se||(se&536870912)!==0?a===ri:!1}function A2(){var a=z.H;return z.H=Ou,a===null?Ou:a}function _2(){var a=z.A;return z.A=wP,a}function gp(){Ye=4,uo||(se&4194048)!==se&&Ls.current!==null||(Wl=!0),(ho&134217727)===0&&(ba&134217727)===0||Ae===null||mo(Ae,se,Bs,!1)}function Sb(a,u,f){var g=be;be|=2;var v=A2(),C=_2();(Ae!==a||se!==u)&&(pp=null,Kl(a,u)),u=!1;var I=Ye;t:do try{if(Se!==0&&te!==null){var O=te,G=Ps;switch(Se){case 8:wb(),I=6;break t;case 3:case 2:case 9:case 6:Ls.current===null&&(u=!0);var ot=Se;if(Se=0,Ps=null,Xl(a,O,G,ot),f&&Wl){I=0;break t}break;default:ot=Se,Se=0,Ps=null,Xl(a,O,G,ot)}}TP(),I=Ye;break}catch(mt){I2(a,mt)}while(!0);return u&&a.shellSuspendCounter++,Tr=ca=null,be=g,z.H=v,z.A=C,te===null&&(Ae=null,se=0,Ff()),I}function TP(){for(;te!==null;)R2(te)}function kP(a,u){var f=be;be|=2;var g=A2(),v=_2();Ae!==a||se!==u?(pp=null,fp=Le()+500,Kl(a,u)):Wl=cu(a,u);t:do try{if(Se!==0&&te!==null){u=te;var C=Ps;e:switch(Se){case 1:Se=0,Ps=null,Xl(a,u,C,1);break;case 2:case 9:if(UT(C)){Se=0,Ps=null,D2(u);break}u=function(){Se!==2&&Se!==9||Ae!==a||(Se=7),Yi(a)},C.then(u,u);break t;case 3:Se=7;break t;case 4:Se=5;break t;case 7:UT(C)?(Se=0,Ps=null,D2(u)):(Se=0,Ps=null,Xl(a,u,C,7));break;case 5:var I=null;switch(te.tag){case 26:I=te.memoizedState;case 5:case 27:var O=te;if(I?b$(I):O.stateNode.complete){Se=0,Ps=null;var G=O.sibling;if(G!==null)te=G;else{var ot=O.return;ot!==null?(te=ot,yp(ot)):te=null}break e}}Se=0,Ps=null,Xl(a,u,C,5);break;case 6:Se=0,Ps=null,Xl(a,u,C,6);break;case 8:wb(),Ye=6;break t;default:throw Error(s(462))}}$P();break}catch(mt){I2(a,mt)}while(!0);return Tr=ca=null,z.H=g,z.A=v,be=f,te!==null?0:(Ae=null,se=0,Ff(),Ye)}function $P(){for(;te!==null&&!os();)R2(te)}function R2(a){var u=n2(a.alternate,a,Or);a.memoizedProps=a.pendingProps,u===null?yp(a):te=u}function D2(a){var u=a,f=u.alternate;switch(u.tag){case 15:case 0:u=Yk(f,u,u.pendingProps,u.type,void 0,se);break;case 11:u=Yk(f,u,u.pendingProps,u.type.render,u.ref,se);break;case 5:L0(u);default:i2(f,u),u=te=_T(u,Or),u=n2(f,u,Or)}a.memoizedProps=a.pendingProps,u===null?yp(a):te=u}function Xl(a,u,f,g){Tr=ca=null,L0(u),zl=null,$u=0;var v=u.return;try{if(pP(a,v,u,f,se)){Ye=1,ip(a,ei(f,a.current)),te=null;return}}catch(C){if(v!==null)throw te=v,C;Ye=1,ip(a,ei(f,a.current)),te=null;return}u.flags&32768?(re||g===1?a=!0:Wl||(se&536870912)!==0?a=!1:(uo=a=!0,(g===2||g===9||g===3||g===6)&&(g=Ls.current,g!==null&&g.tag===13&&(g.flags|=16384))),O2(u,a)):yp(u)}function yp(a){var u=a;do{if((u.flags&32768)!==0){O2(u,uo);return}a=u.return;var f=yP(u.alternate,u,Or);if(f!==null){te=f;return}if(u=u.sibling,u!==null){te=u;return}te=u=a}while(u!==null);Ye===0&&(Ye=5)}function O2(a,u){do{var f=bP(a.alternate,a);if(f!==null){f.flags&=32767,te=f;return}if(f=a.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!u&&(a=a.sibling,a!==null)){te=a;return}te=a=f}while(a!==null);Ye=6,te=null}function M2(a,u,f,g,v,C,I,O,G){a.cancelPendingCommit=null;do bp();while(Cn!==0);if((be&6)!==0)throw Error(s(327));if(u!==null){if(u===a.current)throw Error(s(177));if(C=u.lanes|u.childLanes,C|=u0,rz(a,f,C,I,O,G),a===Ae&&(te=Ae=null,se=0),ql=u,po=a,Mr=f,bb=C,xb=v,T2=g,(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,AP(Ds,function(){return B2(),null})):(a.callbackNode=null,a.callbackPriority=0),g=(u.flags&13878)!==0,(u.subtreeFlags&13878)!==0||g){g=z.T,z.T=null,v=P.p,P.p=2,I=be,be|=4;try{xP(a,u,f)}finally{be=I,P.p=v,z.T=g}}Cn=1,F2(),L2(),z2()}}function F2(){if(Cn===1){Cn=0;var a=po,u=ql,f=(u.flags&13878)!==0;if((u.subtreeFlags&13878)!==0||f){f=z.T,z.T=null;var g=P.p;P.p=2;var v=be;be|=4;try{g2(u,a);var C=Ob,I=ST(a.containerInfo),O=C.focusedElem,G=C.selectionRange;if(I!==O&&O&&O.ownerDocument&&wT(O.ownerDocument.documentElement,O)){if(G!==null&&r0(O)){var ot=G.start,mt=G.end;if(mt===void 0&&(mt=ot),"selectionStart"in O)O.selectionStart=ot,O.selectionEnd=Math.min(mt,O.value.length);else{var yt=O.ownerDocument||document,lt=yt&&yt.defaultView||window;if(lt.getSelection){var ht=lt.getSelection(),It=O.textContent.length,Pt=Math.min(G.start,It),Ie=G.end===void 0?Pt:Math.min(G.end,It);!ht.extend&&Pt>Ie&&(I=Ie,Ie=Pt,Pt=I);var nt=vT(O,Pt),q=vT(O,Ie);if(nt&&q&&(ht.rangeCount!==1||ht.anchorNode!==nt.node||ht.anchorOffset!==nt.offset||ht.focusNode!==q.node||ht.focusOffset!==q.offset)){var rt=yt.createRange();rt.setStart(nt.node,nt.offset),ht.removeAllRanges(),Pt>Ie?(ht.addRange(rt),ht.extend(q.node,q.offset)):(rt.setEnd(q.node,q.offset),ht.addRange(rt))}}}}for(yt=[],ht=O;ht=ht.parentNode;)ht.nodeType===1&&yt.push({element:ht,left:ht.scrollLeft,top:ht.scrollTop});for(typeof O.focus=="function"&&O.focus(),O=0;O<yt.length;O++){var gt=yt[O];gt.element.scrollLeft=gt.left,gt.element.scrollTop=gt.top}}Ap=!!Db,Ob=Db=null}finally{be=v,P.p=g,z.T=f}}a.current=u,Cn=2}}function L2(){if(Cn===2){Cn=0;var a=po,u=ql,f=(u.flags&8772)!==0;if((u.subtreeFlags&8772)!==0||f){f=z.T,z.T=null;var g=P.p;P.p=2;var v=be;be|=4;try{h2(a,u.alternate,u)}finally{be=v,P.p=g,z.T=f}}Cn=3}}function z2(){if(Cn===4||Cn===3){Cn=0,br();var a=po,u=ql,f=Mr,g=T2;(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?Cn=5:(Cn=0,ql=po=null,P2(a,a.pendingLanes));var v=a.pendingLanes;if(v===0&&(fo=null),By(f),u=u.stateNode,as&&typeof as.onCommitFiberRoot=="function")try{as.onCommitFiberRoot(Wi,u,void 0,(u.current.flags&128)===128)}catch{}if(g!==null){u=z.T,v=P.p,P.p=2,z.T=null;try{for(var C=a.onRecoverableError,I=0;I<g.length;I++){var O=g[I];C(O.value,{componentStack:O.stack})}}finally{z.T=u,P.p=v}}(Mr&3)!==0&&bp(),Yi(a),v=a.pendingLanes,(f&261930)!==0&&(v&42)!==0?a===vb?ju++:(ju=0,vb=a):ju=0,Gu(0)}}function P2(a,u){(a.pooledCacheLanes&=u)===0&&(u=a.pooledCache,u!=null&&(a.pooledCache=null,Tu(u)))}function bp(){return F2(),L2(),z2(),B2()}function B2(){if(Cn!==5)return!1;var a=po,u=bb;bb=0;var f=By(Mr),g=z.T,v=P.p;try{P.p=32>f?32:f,z.T=null,f=xb,xb=null;var C=po,I=Mr;if(Cn=0,ql=po=null,Mr=0,(be&6)!==0)throw Error(s(331));var O=be;if(be|=4,w2(C.current),b2(C,C.current,I,f),be=O,Gu(0,!1),as&&typeof as.onPostCommitFiberRoot=="function")try{as.onPostCommitFiberRoot(Wi,C)}catch{}return!0}finally{P.p=v,z.T=g,P2(a,u)}}function V2(a,u,f){u=ei(f,u),u=Z0(a.stateNode,u,2),a=oo(a,u,2),a!==null&&(uu(a,2),Yi(a))}function Ce(a,u,f){if(a.tag===3)V2(a,a,f);else for(;u!==null;){if(u.tag===3){V2(u,a,f);break}else if(u.tag===1){var g=u.stateNode;if(typeof u.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(fo===null||!fo.has(g))){a=ei(f,a),f=Uk(2),g=oo(u,f,2),g!==null&&(jk(f,g,u,a),uu(g,2),Yi(g));break}}u=u.return}}function Cb(a,u,f){var g=a.pingCache;if(g===null){g=a.pingCache=new SP;var v=new Set;g.set(u,v)}else v=g.get(u),v===void 0&&(v=new Set,g.set(u,v));v.has(f)||(mb=!0,v.add(f),a=EP.bind(null,a,u,f),u.then(a,a))}function EP(a,u,f){var g=a.pingCache;g!==null&&g.delete(u),a.pingedLanes|=a.suspendedLanes&f,a.warmLanes&=~f,Ae===a&&(se&f)===f&&(Ye===4||Ye===3&&(se&62914560)===se&&300>Le()-dp?(be&2)===0&&Kl(a,0):gb|=f,Hl===se&&(Hl=0)),Yi(a)}function U2(a,u){u===0&&(u=FC()),a=oa(a,u),a!==null&&(uu(a,u),Yi(a))}function IP(a){var u=a.memoizedState,f=0;u!==null&&(f=u.retryLane),U2(a,f)}function NP(a,u){var f=0;switch(a.tag){case 31:case 13:var g=a.stateNode,v=a.memoizedState;v!==null&&(f=v.retryLane);break;case 19:g=a.stateNode;break;case 22:g=a.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(u),U2(a,f)}function AP(a,u){return Ke(a,u)}var xp=null,Yl=null,Tb=!1,vp=!1,kb=!1,go=0;function Yi(a){a!==Yl&&a.next===null&&(Yl===null?xp=Yl=a:Yl=Yl.next=a),vp=!0,Tb||(Tb=!0,RP())}function Gu(a,u){if(!kb&&vp){kb=!0;do for(var f=!1,g=xp;g!==null;){if(a!==0){var v=g.pendingLanes;if(v===0)var C=0;else{var I=g.suspendedLanes,O=g.pingedLanes;C=(1<<31-Os(42|a)+1)-1,C&=v&~(I&~O),C=C&201326741?C&201326741|1:C?C|2:0}C!==0&&(f=!0,H2(g,C))}else C=se,C=Tf(g,g===Ae?C:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(C&3)===0||cu(g,C)||(f=!0,H2(g,C));g=g.next}while(f);kb=!1}}function _P(){j2()}function j2(){vp=Tb=!1;var a=0;go!==0&&UP()&&(a=go);for(var u=Le(),f=null,g=xp;g!==null;){var v=g.next,C=G2(g,u);C===0?(g.next=null,f===null?xp=v:f.next=v,v===null&&(Yl=f)):(f=g,(a!==0||(C&3)!==0)&&(vp=!0)),g=v}Cn!==0&&Cn!==5||Gu(a),go!==0&&(go=0)}function G2(a,u){for(var f=a.suspendedLanes,g=a.pingedLanes,v=a.expirationTimes,C=a.pendingLanes&-62914561;0<C;){var I=31-Os(C),O=1<<I,G=v[I];G===-1?((O&f)===0||(O&g)!==0)&&(v[I]=iz(O,u)):G<=u&&(a.expiredLanes|=O),C&=~O}if(u=Ae,f=se,f=Tf(a,a===u?f:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g=a.callbackNode,f===0||a===u&&(Se===2||Se===9)||a.cancelPendingCommit!==null)return g!==null&&g!==null&&Js(g),a.callbackNode=null,a.callbackPriority=0;if((f&3)===0||cu(a,f)){if(u=f&-f,u===a.callbackPriority)return u;switch(g!==null&&Js(g),By(f)){case 2:case 8:f=Ti;break;case 32:f=Ds;break;case 268435456:f=gl;break;default:f=Ds}return g=W2.bind(null,a),f=Ke(f,g),a.callbackPriority=u,a.callbackNode=f,u}return g!==null&&g!==null&&Js(g),a.callbackPriority=2,a.callbackNode=null,2}function W2(a,u){if(Cn!==0&&Cn!==5)return a.callbackNode=null,a.callbackPriority=0,null;var f=a.callbackNode;if(bp()&&a.callbackNode!==f)return null;var g=se;return g=Tf(a,a===Ae?g:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),g===0?null:($2(a,g,u),G2(a,Le()),a.callbackNode!=null&&a.callbackNode===f?W2.bind(null,a):null)}function H2(a,u){if(bp())return null;$2(a,u,!0)}function RP(){GP(function(){(be&6)!==0?Ke(Ci,_P):j2()})}function $b(){if(go===0){var a=Ml;a===0&&(a=wf,wf<<=1,(wf&261888)===0&&(wf=256)),go=a}return go}function q2(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:If(""+a)}function K2(a,u){var f=u.ownerDocument.createElement("input");return f.name=u.name,f.value=u.value,a.id&&f.setAttribute("form",a.id),u.parentNode.insertBefore(f,u),a=new FormData(a),f.parentNode.removeChild(f),a}function DP(a,u,f,g,v){if(u==="submit"&&f&&f.stateNode===v){var C=q2((v[ys]||null).action),I=g.submitter;I&&(u=(u=I[ys]||null)?q2(u.formAction):I.getAttribute("formAction"),u!==null&&(C=u,I=null));var O=new Rf("action","action",null,g,v);a.push({event:O,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(go!==0){var G=I?K2(v,I):new FormData(v);H0(f,{pending:!0,data:G,method:v.method,action:C},null,G)}}else typeof C=="function"&&(O.preventDefault(),G=I?K2(v,I):new FormData(v),H0(f,{pending:!0,data:G,method:v.method,action:C},C,G))},currentTarget:v}]})}}for(var Eb=0;Eb<c0.length;Eb++){var Ib=c0[Eb],OP=Ib.toLowerCase(),MP=Ib[0].toUpperCase()+Ib.slice(1);ki(OP,"on"+MP)}ki(kT,"onAnimationEnd"),ki($T,"onAnimationIteration"),ki(ET,"onAnimationStart"),ki("dblclick","onDoubleClick"),ki("focusin","onFocus"),ki("focusout","onBlur"),ki(Jz,"onTransitionRun"),ki(Zz,"onTransitionStart"),ki(Qz,"onTransitionCancel"),ki(IT,"onTransitionEnd"),wl("onMouseEnter",["mouseout","mouseover"]),wl("onMouseLeave",["mouseout","mouseover"]),wl("onPointerEnter",["pointerout","pointerover"]),wl("onPointerLeave",["pointerout","pointerover"]),na("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),na("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),na("onBeforeInput",["compositionend","keypress","textInput","paste"]),na("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),na("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),na("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Wu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),FP=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Wu));function X2(a,u){u=(u&4)!==0;for(var f=0;f<a.length;f++){var g=a[f],v=g.event;g=g.listeners;t:{var C=void 0;if(u)for(var I=g.length-1;0<=I;I--){var O=g[I],G=O.instance,ot=O.currentTarget;if(O=O.listener,G!==C&&v.isPropagationStopped())break t;C=O,v.currentTarget=ot;try{C(v)}catch(mt){Mf(mt)}v.currentTarget=null,C=G}else for(I=0;I<g.length;I++){if(O=g[I],G=O.instance,ot=O.currentTarget,O=O.listener,G!==C&&v.isPropagationStopped())break t;C=O,v.currentTarget=ot;try{C(v)}catch(mt){Mf(mt)}v.currentTarget=null,C=G}}}}function ee(a,u){var f=u[Vy];f===void 0&&(f=u[Vy]=new Set);var g=a+"__bubble";f.has(g)||(Y2(u,a,2,!1),f.add(g))}function Nb(a,u,f){var g=0;u&&(g|=4),Y2(f,a,g,u)}var wp="_reactListening"+Math.random().toString(36).slice(2);function Ab(a){if(!a[wp]){a[wp]=!0,jC.forEach(function(f){f!=="selectionchange"&&(FP.has(f)||Nb(f,!1,a),Nb(f,!0,a))});var u=a.nodeType===9?a:a.ownerDocument;u===null||u[wp]||(u[wp]=!0,Nb("selectionchange",!1,u))}}function Y2(a,u,f,g){switch(k$(u)){case 2:var v=uB;break;case 8:v=hB;break;default:v=Wb}f=v.bind(null,u,f,a),v=void 0,!Yy||u!=="touchstart"&&u!=="touchmove"&&u!=="wheel"||(v=!0),g?v!==void 0?a.addEventListener(u,f,{capture:!0,passive:v}):a.addEventListener(u,f,!0):v!==void 0?a.addEventListener(u,f,{passive:v}):a.addEventListener(u,f,!1)}function _b(a,u,f,g,v){var C=g;if((u&1)===0&&(u&2)===0&&g!==null)t:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var O=g.stateNode.containerInfo;if(O===v)break;if(I===4)for(I=g.return;I!==null;){var G=I.tag;if((G===3||G===4)&&I.stateNode.containerInfo===v)return;I=I.return}for(;O!==null;){if(I=bl(O),I===null)return;if(G=I.tag,G===5||G===6||G===26||G===27){g=C=I;continue t}O=O.parentNode}}g=g.return}eT(function(){var ot=C,mt=Ky(f),yt=[];t:{var lt=NT.get(a);if(lt!==void 0){var ht=Rf,It=a;switch(a){case"keypress":if(Af(f)===0)break t;case"keydown":case"keyup":ht=Nz;break;case"focusin":It="focus",ht=t0;break;case"focusout":It="blur",ht=t0;break;case"beforeblur":case"afterblur":ht=t0;break;case"click":if(f.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ht=iT;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ht=yz;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ht=Rz;break;case kT:case $T:case ET:ht=vz;break;case IT:ht=Oz;break;case"scroll":case"scrollend":ht=mz;break;case"wheel":ht=Fz;break;case"copy":case"cut":case"paste":ht=Sz;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ht=oT;break;case"toggle":case"beforetoggle":ht=zz}var Pt=(u&4)!==0,Ie=!Pt&&(a==="scroll"||a==="scrollend"),nt=Pt?lt!==null?lt+"Capture":null:lt;Pt=[];for(var q=ot,rt;q!==null;){var gt=q;if(rt=gt.stateNode,gt=gt.tag,gt!==5&&gt!==26&&gt!==27||rt===null||nt===null||(gt=fu(q,nt),gt!=null&&Pt.push(Hu(q,gt,rt))),Ie)break;q=q.return}0<Pt.length&&(lt=new ht(lt,It,null,f,mt),yt.push({event:lt,listeners:Pt}))}}if((u&7)===0){t:{if(lt=a==="mouseover"||a==="pointerover",ht=a==="mouseout"||a==="pointerout",lt&&f!==qy&&(It=f.relatedTarget||f.fromElement)&&(bl(It)||It[yl]))break t;if((ht||lt)&&(lt=mt.window===mt?mt:(lt=mt.ownerDocument)?lt.defaultView||lt.parentWindow:window,ht?(It=f.relatedTarget||f.toElement,ht=ot,It=It?bl(It):null,It!==null&&(Ie=r(It),Pt=It.tag,It!==Ie||Pt!==5&&Pt!==27&&Pt!==6)&&(It=null)):(ht=null,It=ot),ht!==It)){if(Pt=iT,gt="onMouseLeave",nt="onMouseEnter",q="mouse",(a==="pointerout"||a==="pointerover")&&(Pt=oT,gt="onPointerLeave",nt="onPointerEnter",q="pointer"),Ie=ht==null?lt:du(ht),rt=It==null?lt:du(It),lt=new Pt(gt,q+"leave",ht,f,mt),lt.target=Ie,lt.relatedTarget=rt,gt=null,bl(mt)===ot&&(Pt=new Pt(nt,q+"enter",It,f,mt),Pt.target=rt,Pt.relatedTarget=Ie,gt=Pt),Ie=gt,ht&&It)e:{for(Pt=LP,nt=ht,q=It,rt=0,gt=nt;gt;gt=Pt(gt))rt++;gt=0;for(var Ft=q;Ft;Ft=Pt(Ft))gt++;for(;0<rt-gt;)nt=Pt(nt),rt--;for(;0<gt-rt;)q=Pt(q),gt--;for(;rt--;){if(nt===q||q!==null&&nt===q.alternate){Pt=nt;break e}nt=Pt(nt),q=Pt(q)}Pt=null}else Pt=null;ht!==null&&J2(yt,lt,ht,Pt,!1),It!==null&&Ie!==null&&J2(yt,Ie,It,Pt,!0)}}t:{if(lt=ot?du(ot):window,ht=lt.nodeName&&lt.nodeName.toLowerCase(),ht==="select"||ht==="input"&&lt.type==="file")var he=pT;else if(dT(lt))if(mT)he=Kz;else{he=Hz;var _t=Wz}else ht=lt.nodeName,!ht||ht.toLowerCase()!=="input"||lt.type!=="checkbox"&&lt.type!=="radio"?ot&&Hy(ot.elementType)&&(he=pT):he=qz;if(he&&(he=he(a,ot))){fT(yt,he,f,mt);break t}_t&&_t(a,lt,ot),a==="focusout"&&ot&&lt.type==="number"&&ot.memoizedProps.value!=null&&Wy(lt,"number",lt.value)}switch(_t=ot?du(ot):window,a){case"focusin":(dT(_t)||_t.contentEditable==="true")&&(El=_t,o0=ot,wu=null);break;case"focusout":wu=o0=El=null;break;case"mousedown":a0=!0;break;case"contextmenu":case"mouseup":case"dragend":a0=!1,CT(yt,f,mt);break;case"selectionchange":if(Yz)break;case"keydown":case"keyup":CT(yt,f,mt)}var Xt;if(n0)t:{switch(a){case"compositionstart":var ie="onCompositionStart";break t;case"compositionend":ie="onCompositionEnd";break t;case"compositionupdate":ie="onCompositionUpdate";break t}ie=void 0}else $l?uT(a,f)&&(ie="onCompositionEnd"):a==="keydown"&&f.keyCode===229&&(ie="onCompositionStart");ie&&(aT&&f.locale!=="ko"&&($l||ie!=="onCompositionStart"?ie==="onCompositionEnd"&&$l&&(Xt=nT()):(Qr=mt,Jy="value"in Qr?Qr.value:Qr.textContent,$l=!0)),_t=Sp(ot,ie),0<_t.length&&(ie=new rT(ie,a,null,f,mt),yt.push({event:ie,listeners:_t}),Xt?ie.data=Xt:(Xt=hT(f),Xt!==null&&(ie.data=Xt)))),(Xt=Bz?Vz(a,f):Uz(a,f))&&(ie=Sp(ot,"onBeforeInput"),0<ie.length&&(_t=new rT("onBeforeInput","beforeinput",null,f,mt),yt.push({event:_t,listeners:ie}),_t.data=Xt)),DP(yt,a,ot,f,mt)}X2(yt,u)})}function Hu(a,u,f){return{instance:a,listener:u,currentTarget:f}}function Sp(a,u){for(var f=u+"Capture",g=[];a!==null;){var v=a,C=v.stateNode;if(v=v.tag,v!==5&&v!==26&&v!==27||C===null||(v=fu(a,f),v!=null&&g.unshift(Hu(a,v,C)),v=fu(a,u),v!=null&&g.push(Hu(a,v,C))),a.tag===3)return g;a=a.return}return[]}function LP(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function J2(a,u,f,g,v){for(var C=u._reactName,I=[];f!==null&&f!==g;){var O=f,G=O.alternate,ot=O.stateNode;if(O=O.tag,G!==null&&G===g)break;O!==5&&O!==26&&O!==27||ot===null||(G=ot,v?(ot=fu(f,C),ot!=null&&I.unshift(Hu(f,ot,G))):v||(ot=fu(f,C),ot!=null&&I.push(Hu(f,ot,G)))),f=f.return}I.length!==0&&a.push({event:u,listeners:I})}var zP=/\r\n?/g,PP=/\u0000|\uFFFD/g;function Z2(a){return(typeof a=="string"?a:""+a).replace(zP,`
`).replace(PP,"")}function Q2(a,u){return u=Z2(u),Z2(a)===u}function Ee(a,u,f,g,v,C){switch(f){case"children":typeof g=="string"?u==="body"||u==="textarea"&&g===""||Cl(a,g):(typeof g=="number"||typeof g=="bigint")&&u!=="body"&&Cl(a,""+g);break;case"className":$f(a,"class",g);break;case"tabIndex":$f(a,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":$f(a,f,g);break;case"style":QC(a,g,C);break;case"data":if(u!=="object"){$f(a,"data",g);break}case"src":case"href":if(g===""&&(u!=="a"||f!=="href")){a.removeAttribute(f);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=If(""+g),a.setAttribute(f,g);break;case"action":case"formAction":if(typeof g=="function"){a.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof C=="function"&&(f==="formAction"?(u!=="input"&&Ee(a,u,"name",v.name,v,null),Ee(a,u,"formEncType",v.formEncType,v,null),Ee(a,u,"formMethod",v.formMethod,v,null),Ee(a,u,"formTarget",v.formTarget,v,null)):(Ee(a,u,"encType",v.encType,v,null),Ee(a,u,"method",v.method,v,null),Ee(a,u,"target",v.target,v,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){a.removeAttribute(f);break}g=If(""+g),a.setAttribute(f,g);break;case"onClick":g!=null&&(a.onclick=vr);break;case"onScroll":g!=null&&ee("scroll",a);break;case"onScrollEnd":g!=null&&ee("scrollend",a);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"multiple":a.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":a.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){a.removeAttribute("xlink:href");break}f=If(""+g),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""+g):a.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,""):a.removeAttribute(f);break;case"capture":case"download":g===!0?a.setAttribute(f,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?a.setAttribute(f,g):a.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?a.setAttribute(f,g):a.removeAttribute(f);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?a.removeAttribute(f):a.setAttribute(f,g);break;case"popover":ee("beforetoggle",a),ee("toggle",a),kf(a,"popover",g);break;case"xlinkActuate":xr(a,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":xr(a,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":xr(a,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":xr(a,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":xr(a,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":xr(a,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":xr(a,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":xr(a,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":xr(a,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":kf(a,"is",g);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=fz.get(f)||f,kf(a,f,g))}}function Rb(a,u,f,g,v,C){switch(f){case"style":QC(a,g,C);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(f=g.__html,f!=null){if(v.children!=null)throw Error(s(60));a.innerHTML=f}}break;case"children":typeof g=="string"?Cl(a,g):(typeof g=="number"||typeof g=="bigint")&&Cl(a,""+g);break;case"onScroll":g!=null&&ee("scroll",a);break;case"onScrollEnd":g!=null&&ee("scrollend",a);break;case"onClick":g!=null&&(a.onclick=vr);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!GC.hasOwnProperty(f))t:{if(f[0]==="o"&&f[1]==="n"&&(v=f.endsWith("Capture"),u=f.slice(2,v?f.length-7:void 0),C=a[ys]||null,C=C!=null?C[f]:null,typeof C=="function"&&a.removeEventListener(u,C,v),typeof g=="function")){typeof C!="function"&&C!==null&&(f in a?a[f]=null:a.hasAttribute(f)&&a.removeAttribute(f)),a.addEventListener(u,g,v);break t}f in a?a[f]=g:g===!0?a.setAttribute(f,""):kf(a,f,g)}}}function Un(a,u,f){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":ee("error",a),ee("load",a);var g=!1,v=!1,C;for(C in f)if(f.hasOwnProperty(C)){var I=f[C];if(I!=null)switch(C){case"src":g=!0;break;case"srcSet":v=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:Ee(a,u,C,I,f,null)}}v&&Ee(a,u,"srcSet",f.srcSet,f,null),g&&Ee(a,u,"src",f.src,f,null);return;case"input":ee("invalid",a);var O=C=I=v=null,G=null,ot=null;for(g in f)if(f.hasOwnProperty(g)){var mt=f[g];if(mt!=null)switch(g){case"name":v=mt;break;case"type":I=mt;break;case"checked":G=mt;break;case"defaultChecked":ot=mt;break;case"value":C=mt;break;case"defaultValue":O=mt;break;case"children":case"dangerouslySetInnerHTML":if(mt!=null)throw Error(s(137,u));break;default:Ee(a,u,g,mt,f,null)}}XC(a,C,O,G,ot,I,v,!1);return;case"select":ee("invalid",a),g=I=C=null;for(v in f)if(f.hasOwnProperty(v)&&(O=f[v],O!=null))switch(v){case"value":C=O;break;case"defaultValue":I=O;break;case"multiple":g=O;default:Ee(a,u,v,O,f,null)}u=C,f=I,a.multiple=!!g,u!=null?Sl(a,!!g,u,!1):f!=null&&Sl(a,!!g,f,!0);return;case"textarea":ee("invalid",a),C=v=g=null;for(I in f)if(f.hasOwnProperty(I)&&(O=f[I],O!=null))switch(I){case"value":g=O;break;case"defaultValue":v=O;break;case"children":C=O;break;case"dangerouslySetInnerHTML":if(O!=null)throw Error(s(91));break;default:Ee(a,u,I,O,f,null)}JC(a,g,v,C);return;case"option":for(G in f)f.hasOwnProperty(G)&&(g=f[G],g!=null)&&(G==="selected"?a.selected=g&&typeof g!="function"&&typeof g!="symbol":Ee(a,u,G,g,f,null));return;case"dialog":ee("beforetoggle",a),ee("toggle",a),ee("cancel",a),ee("close",a);break;case"iframe":case"object":ee("load",a);break;case"video":case"audio":for(g=0;g<Wu.length;g++)ee(Wu[g],a);break;case"image":ee("error",a),ee("load",a);break;case"details":ee("toggle",a);break;case"embed":case"source":case"link":ee("error",a),ee("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(ot in f)if(f.hasOwnProperty(ot)&&(g=f[ot],g!=null))switch(ot){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,u));default:Ee(a,u,ot,g,f,null)}return;default:if(Hy(u)){for(mt in f)f.hasOwnProperty(mt)&&(g=f[mt],g!==void 0&&Rb(a,u,mt,g,f,void 0));return}}for(O in f)f.hasOwnProperty(O)&&(g=f[O],g!=null&&Ee(a,u,O,g,f,null))}function BP(a,u,f,g){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var v=null,C=null,I=null,O=null,G=null,ot=null,mt=null;for(ht in f){var yt=f[ht];if(f.hasOwnProperty(ht)&&yt!=null)switch(ht){case"checked":break;case"value":break;case"defaultValue":G=yt;default:g.hasOwnProperty(ht)||Ee(a,u,ht,null,g,yt)}}for(var lt in g){var ht=g[lt];if(yt=f[lt],g.hasOwnProperty(lt)&&(ht!=null||yt!=null))switch(lt){case"type":C=ht;break;case"name":v=ht;break;case"checked":ot=ht;break;case"defaultChecked":mt=ht;break;case"value":I=ht;break;case"defaultValue":O=ht;break;case"children":case"dangerouslySetInnerHTML":if(ht!=null)throw Error(s(137,u));break;default:ht!==yt&&Ee(a,u,lt,ht,g,yt)}}Gy(a,I,O,G,ot,mt,C,v);return;case"select":ht=I=O=lt=null;for(C in f)if(G=f[C],f.hasOwnProperty(C)&&G!=null)switch(C){case"value":break;case"multiple":ht=G;default:g.hasOwnProperty(C)||Ee(a,u,C,null,g,G)}for(v in g)if(C=g[v],G=f[v],g.hasOwnProperty(v)&&(C!=null||G!=null))switch(v){case"value":lt=C;break;case"defaultValue":O=C;break;case"multiple":I=C;default:C!==G&&Ee(a,u,v,C,g,G)}u=O,f=I,g=ht,lt!=null?Sl(a,!!f,lt,!1):!!g!=!!f&&(u!=null?Sl(a,!!f,u,!0):Sl(a,!!f,f?[]:"",!1));return;case"textarea":ht=lt=null;for(O in f)if(v=f[O],f.hasOwnProperty(O)&&v!=null&&!g.hasOwnProperty(O))switch(O){case"value":break;case"children":break;default:Ee(a,u,O,null,g,v)}for(I in g)if(v=g[I],C=f[I],g.hasOwnProperty(I)&&(v!=null||C!=null))switch(I){case"value":lt=v;break;case"defaultValue":ht=v;break;case"children":break;case"dangerouslySetInnerHTML":if(v!=null)throw Error(s(91));break;default:v!==C&&Ee(a,u,I,v,g,C)}YC(a,lt,ht);return;case"option":for(var It in f)lt=f[It],f.hasOwnProperty(It)&&lt!=null&&!g.hasOwnProperty(It)&&(It==="selected"?a.selected=!1:Ee(a,u,It,null,g,lt));for(G in g)lt=g[G],ht=f[G],g.hasOwnProperty(G)&&lt!==ht&&(lt!=null||ht!=null)&&(G==="selected"?a.selected=lt&&typeof lt!="function"&&typeof lt!="symbol":Ee(a,u,G,lt,g,ht));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Pt in f)lt=f[Pt],f.hasOwnProperty(Pt)&&lt!=null&&!g.hasOwnProperty(Pt)&&Ee(a,u,Pt,null,g,lt);for(ot in g)if(lt=g[ot],ht=f[ot],g.hasOwnProperty(ot)&&lt!==ht&&(lt!=null||ht!=null))switch(ot){case"children":case"dangerouslySetInnerHTML":if(lt!=null)throw Error(s(137,u));break;default:Ee(a,u,ot,lt,g,ht)}return;default:if(Hy(u)){for(var Ie in f)lt=f[Ie],f.hasOwnProperty(Ie)&&lt!==void 0&&!g.hasOwnProperty(Ie)&&Rb(a,u,Ie,void 0,g,lt);for(mt in g)lt=g[mt],ht=f[mt],!g.hasOwnProperty(mt)||lt===ht||lt===void 0&&ht===void 0||Rb(a,u,mt,lt,g,ht);return}}for(var nt in f)lt=f[nt],f.hasOwnProperty(nt)&&lt!=null&&!g.hasOwnProperty(nt)&&Ee(a,u,nt,null,g,lt);for(yt in g)lt=g[yt],ht=f[yt],!g.hasOwnProperty(yt)||lt===ht||lt==null&&ht==null||Ee(a,u,yt,lt,g,ht)}function t$(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function VP(){if(typeof performance.getEntriesByType=="function"){for(var a=0,u=0,f=performance.getEntriesByType("resource"),g=0;g<f.length;g++){var v=f[g],C=v.transferSize,I=v.initiatorType,O=v.duration;if(C&&O&&t$(I)){for(I=0,O=v.responseEnd,g+=1;g<f.length;g++){var G=f[g],ot=G.startTime;if(ot>O)break;var mt=G.transferSize,yt=G.initiatorType;mt&&t$(yt)&&(G=G.responseEnd,I+=mt*(G<O?1:(O-ot)/(G-ot)))}if(--g,u+=8*(C+I)/(v.duration/1e3),a++,10<a)break}}if(0<a)return u/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var Db=null,Ob=null;function Cp(a){return a.nodeType===9?a:a.ownerDocument}function e$(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function n$(a,u){if(a===0)switch(u){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&u==="foreignObject"?0:a}function Mb(a,u){return a==="textarea"||a==="noscript"||typeof u.children=="string"||typeof u.children=="number"||typeof u.children=="bigint"||typeof u.dangerouslySetInnerHTML=="object"&&u.dangerouslySetInnerHTML!==null&&u.dangerouslySetInnerHTML.__html!=null}var Fb=null;function UP(){var a=window.event;return a&&a.type==="popstate"?a===Fb?!1:(Fb=a,!0):(Fb=null,!1)}var s$=typeof setTimeout=="function"?setTimeout:void 0,jP=typeof clearTimeout=="function"?clearTimeout:void 0,i$=typeof Promise=="function"?Promise:void 0,GP=typeof queueMicrotask=="function"?queueMicrotask:typeof i$<"u"?function(a){return i$.resolve(null).then(a).catch(WP)}:s$;function WP(a){setTimeout(function(){throw a})}function yo(a){return a==="head"}function r$(a,u){var f=u,g=0;do{var v=f.nextSibling;if(a.removeChild(f),v&&v.nodeType===8)if(f=v.data,f==="/$"||f==="/&"){if(g===0){a.removeChild(v),tc(u);return}g--}else if(f==="$"||f==="$?"||f==="$~"||f==="$!"||f==="&")g++;else if(f==="html")qu(a.ownerDocument.documentElement);else if(f==="head"){f=a.ownerDocument.head,qu(f);for(var C=f.firstChild;C;){var I=C.nextSibling,O=C.nodeName;C[hu]||O==="SCRIPT"||O==="STYLE"||O==="LINK"&&C.rel.toLowerCase()==="stylesheet"||f.removeChild(C),C=I}}else f==="body"&&qu(a.ownerDocument.body);f=v}while(f);tc(u)}function o$(a,u){var f=a;a=0;do{var g=f.nextSibling;if(f.nodeType===1?u?(f._stashedDisplay=f.style.display,f.style.display="none"):(f.style.display=f._stashedDisplay||"",f.getAttribute("style")===""&&f.removeAttribute("style")):f.nodeType===3&&(u?(f._stashedText=f.nodeValue,f.nodeValue=""):f.nodeValue=f._stashedText||""),g&&g.nodeType===8)if(f=g.data,f==="/$"){if(a===0)break;a--}else f!=="$"&&f!=="$?"&&f!=="$~"&&f!=="$!"||a++;f=g}while(f)}function Lb(a){var u=a.firstChild;for(u&&u.nodeType===10&&(u=u.nextSibling);u;){var f=u;switch(u=u.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":Lb(f),Uy(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}a.removeChild(f)}}function HP(a,u,f,g){for(;a.nodeType===1;){var v=f;if(a.nodeName.toLowerCase()!==u.toLowerCase()){if(!g&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(g){if(!a[hu])switch(u){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(C=a.getAttribute("rel"),C==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(C!==v.rel||a.getAttribute("href")!==(v.href==null||v.href===""?null:v.href)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin)||a.getAttribute("title")!==(v.title==null?null:v.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(C=a.getAttribute("src"),(C!==(v.src==null?null:v.src)||a.getAttribute("type")!==(v.type==null?null:v.type)||a.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin))&&C&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(u==="input"&&a.type==="hidden"){var C=v.name==null?null:""+v.name;if(v.type==="hidden"&&a.getAttribute("name")===C)return a}else return a;if(a=oi(a.nextSibling),a===null)break}return null}function qP(a,u,f){if(u==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!f||(a=oi(a.nextSibling),a===null))return null;return a}function a$(a,u){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!u||(a=oi(a.nextSibling),a===null))return null;return a}function zb(a){return a.data==="$?"||a.data==="$~"}function Pb(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function KP(a,u){var f=a.ownerDocument;if(a.data==="$~")a._reactRetry=u;else if(a.data!=="$?"||f.readyState!=="loading")u();else{var g=function(){u(),f.removeEventListener("DOMContentLoaded",g)};f.addEventListener("DOMContentLoaded",g),a._reactRetry=g}}function oi(a){for(;a!=null;a=a.nextSibling){var u=a.nodeType;if(u===1||u===3)break;if(u===8){if(u=a.data,u==="$"||u==="$!"||u==="$?"||u==="$~"||u==="&"||u==="F!"||u==="F")break;if(u==="/$"||u==="/&")return null}}return a}var Bb=null;function l$(a){a=a.nextSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="/$"||f==="/&"){if(u===0)return oi(a.nextSibling);u--}else f!=="$"&&f!=="$!"&&f!=="$?"&&f!=="$~"&&f!=="&"||u++}a=a.nextSibling}return null}function c$(a){a=a.previousSibling;for(var u=0;a;){if(a.nodeType===8){var f=a.data;if(f==="$"||f==="$!"||f==="$?"||f==="$~"||f==="&"){if(u===0)return a;u--}else f!=="/$"&&f!=="/&"||u++}a=a.previousSibling}return null}function u$(a,u,f){switch(u=Cp(f),a){case"html":if(a=u.documentElement,!a)throw Error(s(452));return a;case"head":if(a=u.head,!a)throw Error(s(453));return a;case"body":if(a=u.body,!a)throw Error(s(454));return a;default:throw Error(s(451))}}function qu(a){for(var u=a.attributes;u.length;)a.removeAttributeNode(u[0]);Uy(a)}var ai=new Map,h$=new Set;function Tp(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var Fr=P.d;P.d={f:XP,r:YP,D:JP,C:ZP,L:QP,m:tB,X:nB,S:eB,M:sB};function XP(){var a=Fr.f(),u=mp();return a||u}function YP(a){var u=xl(a);u!==null&&u.tag===5&&u.type==="form"?Ik(u):Fr.r(a)}var Jl=typeof document>"u"?null:document;function d$(a,u,f){var g=Jl;if(g&&typeof u=="string"&&u){var v=Qs(u);v='link[rel="'+a+'"][href="'+v+'"]',typeof f=="string"&&(v+='[crossorigin="'+f+'"]'),h$.has(v)||(h$.add(v),a={rel:a,crossOrigin:f,href:u},g.querySelector(v)===null&&(u=g.createElement("link"),Un(u,"link",a),_n(u),g.head.appendChild(u)))}}function JP(a){Fr.D(a),d$("dns-prefetch",a,null)}function ZP(a,u){Fr.C(a,u),d$("preconnect",a,u)}function QP(a,u,f){Fr.L(a,u,f);var g=Jl;if(g&&a&&u){var v='link[rel="preload"][as="'+Qs(u)+'"]';u==="image"&&f&&f.imageSrcSet?(v+='[imagesrcset="'+Qs(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(v+='[imagesizes="'+Qs(f.imageSizes)+'"]')):v+='[href="'+Qs(a)+'"]';var C=v;switch(u){case"style":C=Zl(a);break;case"script":C=Ql(a)}ai.has(C)||(a=p({rel:"preload",href:u==="image"&&f&&f.imageSrcSet?void 0:a,as:u},f),ai.set(C,a),g.querySelector(v)!==null||u==="style"&&g.querySelector(Ku(C))||u==="script"&&g.querySelector(Xu(C))||(u=g.createElement("link"),Un(u,"link",a),_n(u),g.head.appendChild(u)))}}function tB(a,u){Fr.m(a,u);var f=Jl;if(f&&a){var g=u&&typeof u.as=="string"?u.as:"script",v='link[rel="modulepreload"][as="'+Qs(g)+'"][href="'+Qs(a)+'"]',C=v;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":C=Ql(a)}if(!ai.has(C)&&(a=p({rel:"modulepreload",href:a},u),ai.set(C,a),f.querySelector(v)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(Xu(C)))return}g=f.createElement("link"),Un(g,"link",a),_n(g),f.head.appendChild(g)}}}function eB(a,u,f){Fr.S(a,u,f);var g=Jl;if(g&&a){var v=vl(g).hoistableStyles,C=Zl(a);u=u||"default";var I=v.get(C);if(!I){var O={loading:0,preload:null};if(I=g.querySelector(Ku(C)))O.loading=5;else{a=p({rel:"stylesheet",href:a,"data-precedence":u},f),(f=ai.get(C))&&Vb(a,f);var G=I=g.createElement("link");_n(G),Un(G,"link",a),G._p=new Promise(function(ot,mt){G.onload=ot,G.onerror=mt}),G.addEventListener("load",function(){O.loading|=1}),G.addEventListener("error",function(){O.loading|=2}),O.loading|=4,kp(I,u,g)}I={type:"stylesheet",instance:I,count:1,state:O},v.set(C,I)}}}function nB(a,u){Fr.X(a,u);var f=Jl;if(f&&a){var g=vl(f).hoistableScripts,v=Ql(a),C=g.get(v);C||(C=f.querySelector(Xu(v)),C||(a=p({src:a,async:!0},u),(u=ai.get(v))&&Ub(a,u),C=f.createElement("script"),_n(C),Un(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function sB(a,u){Fr.M(a,u);var f=Jl;if(f&&a){var g=vl(f).hoistableScripts,v=Ql(a),C=g.get(v);C||(C=f.querySelector(Xu(v)),C||(a=p({src:a,async:!0,type:"module"},u),(u=ai.get(v))&&Ub(a,u),C=f.createElement("script"),_n(C),Un(C,"link",a),f.head.appendChild(C)),C={type:"script",instance:C,count:1,state:null},g.set(v,C))}}function f$(a,u,f,g){var v=(v=pt.current)?Tp(v):null;if(!v)throw Error(s(446));switch(a){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(u=Zl(f.href),f=vl(v).hoistableStyles,g=f.get(u),g||(g={type:"style",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){a=Zl(f.href);var C=vl(v).hoistableStyles,I=C.get(a);if(I||(v=v.ownerDocument||v,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},C.set(a,I),(C=v.querySelector(Ku(a)))&&!C._p&&(I.instance=C,I.state.loading=5),ai.has(a)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},ai.set(a,f),C||iB(v,a,f,I.state))),u&&g===null)throw Error(s(528,""));return I}if(u&&g!==null)throw Error(s(529,""));return null;case"script":return u=f.async,f=f.src,typeof f=="string"&&u&&typeof u!="function"&&typeof u!="symbol"?(u=Ql(f),f=vl(v).hoistableScripts,g=f.get(u),g||(g={type:"script",instance:null,count:0,state:null},f.set(u,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,a))}}function Zl(a){return'href="'+Qs(a)+'"'}function Ku(a){return'link[rel="stylesheet"]['+a+"]"}function p$(a){return p({},a,{"data-precedence":a.precedence,precedence:null})}function iB(a,u,f,g){a.querySelector('link[rel="preload"][as="style"]['+u+"]")?g.loading=1:(u=a.createElement("link"),g.preload=u,u.addEventListener("load",function(){return g.loading|=1}),u.addEventListener("error",function(){return g.loading|=2}),Un(u,"link",f),_n(u),a.head.appendChild(u))}function Ql(a){return'[src="'+Qs(a)+'"]'}function Xu(a){return"script[async]"+a}function m$(a,u,f){if(u.count++,u.instance===null)switch(u.type){case"style":var g=a.querySelector('style[data-href~="'+Qs(f.href)+'"]');if(g)return u.instance=g,_n(g),g;var v=p({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return g=(a.ownerDocument||a).createElement("style"),_n(g),Un(g,"style",v),kp(g,f.precedence,a),u.instance=g;case"stylesheet":v=Zl(f.href);var C=a.querySelector(Ku(v));if(C)return u.state.loading|=4,u.instance=C,_n(C),C;g=p$(f),(v=ai.get(v))&&Vb(g,v),C=(a.ownerDocument||a).createElement("link"),_n(C);var I=C;return I._p=new Promise(function(O,G){I.onload=O,I.onerror=G}),Un(C,"link",g),u.state.loading|=4,kp(C,f.precedence,a),u.instance=C;case"script":return C=Ql(f.src),(v=a.querySelector(Xu(C)))?(u.instance=v,_n(v),v):(g=f,(v=ai.get(C))&&(g=p({},f),Ub(g,v)),a=a.ownerDocument||a,v=a.createElement("script"),_n(v),Un(v,"link",g),a.head.appendChild(v),u.instance=v);case"void":return null;default:throw Error(s(443,u.type))}else u.type==="stylesheet"&&(u.state.loading&4)===0&&(g=u.instance,u.state.loading|=4,kp(g,f.precedence,a));return u.instance}function kp(a,u,f){for(var g=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),v=g.length?g[g.length-1]:null,C=v,I=0;I<g.length;I++){var O=g[I];if(O.dataset.precedence===u)C=O;else if(C!==v)break}C?C.parentNode.insertBefore(a,C.nextSibling):(u=f.nodeType===9?f.head:f,u.insertBefore(a,u.firstChild))}function Vb(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.title==null&&(a.title=u.title)}function Ub(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.integrity==null&&(a.integrity=u.integrity)}var $p=null;function g$(a,u,f){if($p===null){var g=new Map,v=$p=new Map;v.set(f,g)}else v=$p,g=v.get(f),g||(g=new Map,v.set(f,g));if(g.has(a))return g;for(g.set(a,null),f=f.getElementsByTagName(a),v=0;v<f.length;v++){var C=f[v];if(!(C[hu]||C[zn]||a==="link"&&C.getAttribute("rel")==="stylesheet")&&C.namespaceURI!=="http://www.w3.org/2000/svg"){var I=C.getAttribute(u)||"";I=a+I;var O=g.get(I);O?O.push(C):g.set(I,[C])}}return g}function y$(a,u,f){a=a.ownerDocument||a,a.head.insertBefore(f,u==="title"?a.querySelector("head > title"):null)}function rB(a,u,f){if(f===1||u.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof u.precedence!="string"||typeof u.href!="string"||u.href==="")break;return!0;case"link":if(typeof u.rel!="string"||typeof u.href!="string"||u.href===""||u.onLoad||u.onError)break;return u.rel==="stylesheet"?(a=u.disabled,typeof u.precedence=="string"&&a==null):!0;case"script":if(u.async&&typeof u.async!="function"&&typeof u.async!="symbol"&&!u.onLoad&&!u.onError&&u.src&&typeof u.src=="string")return!0}return!1}function b$(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function oB(a,u,f,g){if(f.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(f.state.loading&4)===0){if(f.instance===null){var v=Zl(g.href),C=u.querySelector(Ku(v));if(C){u=C._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(a.count++,a=Ep.bind(a),u.then(a,a)),f.state.loading|=4,f.instance=C,_n(C);return}C=u.ownerDocument||u,g=p$(g),(v=ai.get(v))&&Vb(g,v),C=C.createElement("link"),_n(C);var I=C;I._p=new Promise(function(O,G){I.onload=O,I.onerror=G}),Un(C,"link",g),f.instance=C}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(f,u),(u=f.state.preload)&&(f.state.loading&3)===0&&(a.count++,f=Ep.bind(a),u.addEventListener("load",f),u.addEventListener("error",f))}}var jb=0;function aB(a,u){return a.stylesheets&&a.count===0&&Np(a,a.stylesheets),0<a.count||0<a.imgCount?function(f){var g=setTimeout(function(){if(a.stylesheets&&Np(a,a.stylesheets),a.unsuspend){var C=a.unsuspend;a.unsuspend=null,C()}},6e4+u);0<a.imgBytes&&jb===0&&(jb=62500*VP());var v=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&Np(a,a.stylesheets),a.unsuspend)){var C=a.unsuspend;a.unsuspend=null,C()}},(a.imgBytes>jb?50:800)+u);return a.unsuspend=f,function(){a.unsuspend=null,clearTimeout(g),clearTimeout(v)}}:null}function Ep(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)Np(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var Ip=null;function Np(a,u){a.stylesheets=null,a.unsuspend!==null&&(a.count++,Ip=new Map,u.forEach(lB,a),Ip=null,Ep.call(a))}function lB(a,u){if(!(u.state.loading&4)){var f=Ip.get(a);if(f)var g=f.get(null);else{f=new Map,Ip.set(a,f);for(var v=a.querySelectorAll("link[data-precedence],style[data-precedence]"),C=0;C<v.length;C++){var I=v[C];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(f.set(I.dataset.precedence,I),g=I)}g&&f.set(null,g)}v=u.instance,I=v.getAttribute("data-precedence"),C=f.get(I)||g,C===g&&f.set(null,v),f.set(I,v),this.count++,g=Ep.bind(this),v.addEventListener("load",g),v.addEventListener("error",g),C?C.parentNode.insertBefore(v,C.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(v,a.firstChild)),u.state.loading|=4}}var Yu={$$typeof:k,Provider:null,Consumer:null,_currentValue:V,_currentValue2:V,_threadCount:0};function cB(a,u,f,g,v,C,I,O,G){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=zy(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zy(0),this.hiddenUpdates=zy(null),this.identifierPrefix=g,this.onUncaughtError=v,this.onCaughtError=C,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=G,this.incompleteTransitions=new Map}function x$(a,u,f,g,v,C,I,O,G,ot,mt,yt){return a=new cB(a,u,f,I,G,ot,mt,yt,O),u=1,C===!0&&(u|=24),C=Fs(3,null,null,u),a.current=C,C.stateNode=a,u=S0(),u.refCount++,a.pooledCache=u,u.refCount++,C.memoizedState={element:g,isDehydrated:f,cache:u},$0(C),a}function v$(a){return a?(a=Al,a):Al}function w$(a,u,f,g,v,C){v=v$(v),g.context===null?g.context=v:g.pendingContext=v,g=ro(u),g.payload={element:f},C=C===void 0?null:C,C!==null&&(g.callback=C),f=oo(a,g,u),f!==null&&(Cs(f,a,u),Iu(f,a,u))}function S$(a,u){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var f=a.retryLane;a.retryLane=f!==0&&f<u?f:u}}function Gb(a,u){S$(a,u),(a=a.alternate)&&S$(a,u)}function C$(a){if(a.tag===13||a.tag===31){var u=oa(a,67108864);u!==null&&Cs(u,a,67108864),Gb(a,67108864)}}function T$(a){if(a.tag===13||a.tag===31){var u=Vs();u=Py(u);var f=oa(a,u);f!==null&&Cs(f,a,u),Gb(a,u)}}var Ap=!0;function uB(a,u,f,g){var v=z.T;z.T=null;var C=P.p;try{P.p=2,Wb(a,u,f,g)}finally{P.p=C,z.T=v}}function hB(a,u,f,g){var v=z.T;z.T=null;var C=P.p;try{P.p=8,Wb(a,u,f,g)}finally{P.p=C,z.T=v}}function Wb(a,u,f,g){if(Ap){var v=Hb(g);if(v===null)_b(a,u,g,_p,f),$$(a,g);else if(fB(v,a,u,f,g))g.stopPropagation();else if($$(a,g),u&4&&-1<dB.indexOf(a)){for(;v!==null;){var C=xl(v);if(C!==null)switch(C.tag){case 3:if(C=C.stateNode,C.current.memoizedState.isDehydrated){var I=ea(C.pendingLanes);if(I!==0){var O=C;for(O.pendingLanes|=2,O.entangledLanes|=2;I;){var G=1<<31-Os(I);O.entanglements[1]|=G,I&=~G}Yi(C),(be&6)===0&&(fp=Le()+500,Gu(0))}}break;case 31:case 13:O=oa(C,2),O!==null&&Cs(O,C,2),mp(),Gb(C,2)}if(C=Hb(g),C===null&&_b(a,u,g,_p,f),C===v)break;v=C}v!==null&&g.stopPropagation()}else _b(a,u,g,null,f)}}function Hb(a){return a=Ky(a),qb(a)}var _p=null;function qb(a){if(_p=null,a=bl(a),a!==null){var u=r(a);if(u===null)a=null;else{var f=u.tag;if(f===13){if(a=o(u),a!==null)return a;a=null}else if(f===31){if(a=l(u),a!==null)return a;a=null}else if(f===3){if(u.stateNode.current.memoizedState.isDehydrated)return u.tag===3?u.stateNode.containerInfo:null;a=null}else u!==a&&(a=null)}}return _p=a,null}function k$(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Si()){case Ci:return 2;case Ti:return 8;case Ds:case ta:return 32;case gl:return 268435456;default:return 32}default:return 32}}var Kb=!1,bo=null,xo=null,vo=null,Ju=new Map,Zu=new Map,wo=[],dB="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function $$(a,u){switch(a){case"focusin":case"focusout":bo=null;break;case"dragenter":case"dragleave":xo=null;break;case"mouseover":case"mouseout":vo=null;break;case"pointerover":case"pointerout":Ju.delete(u.pointerId);break;case"gotpointercapture":case"lostpointercapture":Zu.delete(u.pointerId)}}function Qu(a,u,f,g,v,C){return a===null||a.nativeEvent!==C?(a={blockedOn:u,domEventName:f,eventSystemFlags:g,nativeEvent:C,targetContainers:[v]},u!==null&&(u=xl(u),u!==null&&C$(u)),a):(a.eventSystemFlags|=g,u=a.targetContainers,v!==null&&u.indexOf(v)===-1&&u.push(v),a)}function fB(a,u,f,g,v){switch(u){case"focusin":return bo=Qu(bo,a,u,f,g,v),!0;case"dragenter":return xo=Qu(xo,a,u,f,g,v),!0;case"mouseover":return vo=Qu(vo,a,u,f,g,v),!0;case"pointerover":var C=v.pointerId;return Ju.set(C,Qu(Ju.get(C)||null,a,u,f,g,v)),!0;case"gotpointercapture":return C=v.pointerId,Zu.set(C,Qu(Zu.get(C)||null,a,u,f,g,v)),!0}return!1}function E$(a){var u=bl(a.target);if(u!==null){var f=r(u);if(f!==null){if(u=f.tag,u===13){if(u=o(f),u!==null){a.blockedOn=u,VC(a.priority,function(){T$(f)});return}}else if(u===31){if(u=l(f),u!==null){a.blockedOn=u,VC(a.priority,function(){T$(f)});return}}else if(u===3&&f.stateNode.current.memoizedState.isDehydrated){a.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Rp(a){if(a.blockedOn!==null)return!1;for(var u=a.targetContainers;0<u.length;){var f=Hb(a.nativeEvent);if(f===null){f=a.nativeEvent;var g=new f.constructor(f.type,f);qy=g,f.target.dispatchEvent(g),qy=null}else return u=xl(f),u!==null&&C$(u),a.blockedOn=f,!1;u.shift()}return!0}function I$(a,u,f){Rp(a)&&f.delete(u)}function pB(){Kb=!1,bo!==null&&Rp(bo)&&(bo=null),xo!==null&&Rp(xo)&&(xo=null),vo!==null&&Rp(vo)&&(vo=null),Ju.forEach(I$),Zu.forEach(I$)}function Dp(a,u){a.blockedOn===u&&(a.blockedOn=null,Kb||(Kb=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,pB)))}var Op=null;function N$(a){Op!==a&&(Op=a,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Op===a&&(Op=null);for(var u=0;u<a.length;u+=3){var f=a[u],g=a[u+1],v=a[u+2];if(typeof g!="function"){if(qb(g||f)===null)continue;break}var C=xl(f);C!==null&&(a.splice(u,3),u-=3,H0(C,{pending:!0,data:v,method:f.method,action:g},g,v))}}))}function tc(a){function u(G){return Dp(G,a)}bo!==null&&Dp(bo,a),xo!==null&&Dp(xo,a),vo!==null&&Dp(vo,a),Ju.forEach(u),Zu.forEach(u);for(var f=0;f<wo.length;f++){var g=wo[f];g.blockedOn===a&&(g.blockedOn=null)}for(;0<wo.length&&(f=wo[0],f.blockedOn===null);)E$(f),f.blockedOn===null&&wo.shift();if(f=(a.ownerDocument||a).$$reactFormReplay,f!=null)for(g=0;g<f.length;g+=3){var v=f[g],C=f[g+1],I=v[ys]||null;if(typeof C=="function")I||N$(f);else if(I){var O=null;if(C&&C.hasAttribute("formAction")){if(v=C,I=C[ys]||null)O=I.formAction;else if(qb(v)!==null)continue}else O=I.action;typeof O=="function"?f[g+1]=O:(f.splice(g,3),g-=3),N$(f)}}}function A$(){function a(C){C.canIntercept&&C.info==="react-transition"&&C.intercept({handler:function(){return new Promise(function(I){return v=I})},focusReset:"manual",scroll:"manual"})}function u(){v!==null&&(v(),v=null),g||setTimeout(f,20)}function f(){if(!g&&!navigation.transition){var C=navigation.currentEntry;C&&C.url!=null&&navigation.navigate(C.url,{state:C.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,v=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",u),navigation.addEventListener("navigateerror",u),setTimeout(f,100),function(){g=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",u),navigation.removeEventListener("navigateerror",u),v!==null&&(v(),v=null)}}}function Xb(a){this._internalRoot=a}Mp.prototype.render=Xb.prototype.render=function(a){var u=this._internalRoot;if(u===null)throw Error(s(409));var f=u.current,g=Vs();w$(f,g,a,u,null,null)},Mp.prototype.unmount=Xb.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var u=a.containerInfo;w$(a.current,2,null,a,null,null),mp(),u[yl]=null}};function Mp(a){this._internalRoot=a}Mp.prototype.unstable_scheduleHydration=function(a){if(a){var u=BC();a={blockedOn:null,target:a,priority:u};for(var f=0;f<wo.length&&u!==0&&u<wo[f].priority;f++);wo.splice(f,0,a),f===0&&E$(a)}};var _$=t.version;if(_$!=="19.2.3")throw Error(s(527,_$,"19.2.3"));P.findDOMNode=function(a){var u=a._reactInternals;if(u===void 0)throw typeof a.render=="function"?Error(s(188)):(a=Object.keys(a).join(","),Error(s(268,a)));return a=h(u),a=a!==null?d(a):null,a=a===null?null:a.stateNode,a};var mB={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:z,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Fp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Fp.isDisabled&&Fp.supportsFiber)try{Wi=Fp.inject(mB),as=Fp}catch{}}return eh.createRoot=function(a,u){if(!i(a))throw Error(s(299));var f=!1,g="",v=zk,C=Pk,I=Bk;return u!=null&&(u.unstable_strictMode===!0&&(f=!0),u.identifierPrefix!==void 0&&(g=u.identifierPrefix),u.onUncaughtError!==void 0&&(v=u.onUncaughtError),u.onCaughtError!==void 0&&(C=u.onCaughtError),u.onRecoverableError!==void 0&&(I=u.onRecoverableError)),u=x$(a,1,!1,null,null,f,g,null,v,C,I,A$),a[yl]=u.current,Ab(a),new Xb(u)},eh.hydrateRoot=function(a,u,f){if(!i(a))throw Error(s(299));var g=!1,v="",C=zk,I=Pk,O=Bk,G=null;return f!=null&&(f.unstable_strictMode===!0&&(g=!0),f.identifierPrefix!==void 0&&(v=f.identifierPrefix),f.onUncaughtError!==void 0&&(C=f.onUncaughtError),f.onCaughtError!==void 0&&(I=f.onCaughtError),f.onRecoverableError!==void 0&&(O=f.onRecoverableError),f.formState!==void 0&&(G=f.formState)),u=x$(a,1,!0,u,f??null,g,v,G,C,I,O,A$),u.context=v$(null),f=u.current,g=Vs(),g=Py(g),v=ro(g),v.callback=null,oo(f,v,g),f=g,u.current.lanes=f,uu(u,f),Yi(u),a[yl]=u.current,Ab(a),new Mp(u)},eh.version="19.2.3",eh}var V$;function IB(){if(V$)return Zb.exports;V$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),Zb.exports=EB(),Zb.exports}var NB=IB();const AB=hw(NB),fw=St.createContext({});function pw(n){const t=St.useRef(null);return t.current===null&&(t.current=n()),t.current}const mw=typeof window<"u",vA=mw?St.useLayoutEffect:St.useEffect,ng=St.createContext(null);function gw(n,t){n.indexOf(t)===-1&&n.push(t)}function yw(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}const Vr=(n,t,e)=>e>t?t:e<n?n:e;let bw=()=>{};const Ur={},wA=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function SA(n){return typeof n=="object"&&n!==null}const CA=n=>/^0[^.\s]+$/u.test(n);function xw(n){let t;return()=>(t===void 0&&(t=n()),t)}const gi=n=>n,_B=(n,t)=>e=>t(n(e)),Xh=(...n)=>n.reduce(_B),Th=(n,t,e)=>{const s=t-n;return s===0?1:(e-n)/s};class vw{constructor(){this.subscriptions=[]}add(t){return gw(this.subscriptions,t),()=>yw(this.subscriptions,t)}notify(t,e,s){const i=this.subscriptions.length;if(i)if(i===1)this.subscriptions[0](t,e,s);else for(let r=0;r<i;r++){const o=this.subscriptions[r];o&&o(t,e,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const sr=n=>n*1e3,fi=n=>n/1e3;function TA(n,t){return t?n*(1e3/t):0}const kA=(n,t,e)=>(((1-3*e+3*t)*n+(3*e-6*t))*n+3*t)*n,RB=1e-7,DB=12;function OB(n,t,e,s,i){let r,o,l=0;do o=t+(e-t)/2,r=kA(o,s,i)-n,r>0?e=o:t=o;while(Math.abs(r)>RB&&++l<DB);return o}function Yh(n,t,e,s){if(n===t&&e===s)return gi;const i=r=>OB(r,0,1,n,e);return r=>r===0||r===1?r:kA(i(r),t,s)}const $A=n=>t=>t<=.5?n(2*t)/2:(2-n(2*(1-t)))/2,EA=n=>t=>1-n(1-t),IA=Yh(.33,1.53,.69,.99),ww=EA(IA),NA=$A(ww),AA=n=>(n*=2)<1?.5*ww(n):.5*(2-Math.pow(2,-10*(n-1))),Sw=n=>1-Math.sin(Math.acos(n)),_A=EA(Sw),RA=$A(Sw),MB=Yh(.42,0,1,1),FB=Yh(0,0,.58,1),DA=Yh(.42,0,.58,1),LB=n=>Array.isArray(n)&&typeof n[0]!="number",OA=n=>Array.isArray(n)&&typeof n[0]=="number",zB={linear:gi,easeIn:MB,easeInOut:DA,easeOut:FB,circIn:Sw,circInOut:RA,circOut:_A,backIn:ww,backInOut:NA,backOut:IA,anticipate:AA},PB=n=>typeof n=="string",U$=n=>{if(OA(n)){bw(n.length===4);const[t,e,s,i]=n;return Yh(t,e,s,i)}else if(PB(n))return zB[n];return n},Lp=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function BB(n,t){let e=new Set,s=new Set,i=!1,r=!1;const o=new WeakSet;let l={delta:0,timestamp:0,isProcessing:!1};function c(d){o.has(d)&&(h.schedule(d),n()),d(l)}const h={schedule:(d,p=!1,m=!1)=>{const b=m&&i?e:s;return p&&o.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),o.delete(d)},process:d=>{if(l=d,i){r=!0;return}i=!0,[e,s]=[s,e],e.forEach(c),e.clear(),i=!1,r&&(r=!1,h.process(d))}};return h}const VB=40;function MA(n,t){let e=!1,s=!0;const i={delta:0,timestamp:0,isProcessing:!1},r=()=>e=!0,o=Lp.reduce((k,$)=>(k[$]=BB(r),k),{}),{setup:l,read:c,resolveKeyframes:h,preUpdate:d,update:p,preRender:m,render:y,postRender:b}=o,x=()=>{const k=Ur.useManualTiming?i.timestamp:performance.now();e=!1,Ur.useManualTiming||(i.delta=s?1e3/60:Math.max(Math.min(k-i.timestamp,VB),1)),i.timestamp=k,i.isProcessing=!0,l.process(i),c.process(i),h.process(i),d.process(i),p.process(i),m.process(i),y.process(i),b.process(i),i.isProcessing=!1,e&&t&&(s=!1,n(x))},w=()=>{e=!0,s=!0,i.isProcessing||n(x)};return{schedule:Lp.reduce((k,$)=>{const E=o[$];return k[$]=(N,_=!1,R=!1)=>(e||w(),E.schedule(N,_,R)),k},{}),cancel:k=>{for(let $=0;$<Lp.length;$++)o[Lp[$]].cancel(k)},state:i,steps:o}}const{schedule:je,cancel:Oo,state:Wn,steps:nx}=MA(typeof requestAnimationFrame<"u"?requestAnimationFrame:gi,!0);let im;function UB(){im=void 0}const Es={now:()=>(im===void 0&&Es.set(Wn.isProcessing||Ur.useManualTiming?Wn.timestamp:performance.now()),im),set:n=>{im=n,queueMicrotask(UB)}},FA=n=>t=>typeof t=="string"&&t.startsWith(n),LA=FA("--"),jB=FA("var(--"),Cw=n=>jB(n)?GB.test(n.split("/*")[0].trim()):!1,GB=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,jc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},kh={...jc,transform:n=>Vr(0,1,n)},zp={...jc,default:1},mh=n=>Math.round(n*1e5)/1e5,Tw=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function WB(n){return n==null}const HB=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,kw=(n,t)=>e=>!!(typeof e=="string"&&HB.test(e)&&e.startsWith(n)||t&&!WB(e)&&Object.prototype.hasOwnProperty.call(e,t)),zA=(n,t,e)=>s=>{if(typeof s!="string")return s;const[i,r,o,l]=s.match(Tw);return{[n]:parseFloat(i),[t]:parseFloat(r),[e]:parseFloat(o),alpha:l!==void 0?parseFloat(l):1}},qB=n=>Vr(0,255,n),sx={...jc,transform:n=>Math.round(qB(n))},Ra={test:kw("rgb","red"),parse:zA("red","green","blue"),transform:({red:n,green:t,blue:e,alpha:s=1})=>"rgba("+sx.transform(n)+", "+sx.transform(t)+", "+sx.transform(e)+", "+mh(kh.transform(s))+")"};function KB(n){let t="",e="",s="",i="";return n.length>5?(t=n.substring(1,3),e=n.substring(3,5),s=n.substring(5,7),i=n.substring(7,9)):(t=n.substring(1,2),e=n.substring(2,3),s=n.substring(3,4),i=n.substring(4,5),t+=t,e+=e,s+=s,i+=i),{red:parseInt(t,16),green:parseInt(e,16),blue:parseInt(s,16),alpha:i?parseInt(i,16)/255:1}}const Xx={test:kw("#"),parse:KB,transform:Ra.transform},Jh=n=>({test:t=>typeof t=="string"&&t.endsWith(n)&&t.split(" ").length===1,parse:parseFloat,transform:t=>`${t}${n}`}),Co=Jh("deg"),ir=Jh("%"),Gt=Jh("px"),XB=Jh("vh"),YB=Jh("vw"),j$={...ir,parse:n=>ir.parse(n)/100,transform:n=>ir.transform(n*100)},yc={test:kw("hsl","hue"),parse:zA("hue","saturation","lightness"),transform:({hue:n,saturation:t,lightness:e,alpha:s=1})=>"hsla("+Math.round(n)+", "+ir.transform(mh(t))+", "+ir.transform(mh(e))+", "+mh(kh.transform(s))+")"},mn={test:n=>Ra.test(n)||Xx.test(n)||yc.test(n),parse:n=>Ra.test(n)?Ra.parse(n):yc.test(n)?yc.parse(n):Xx.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?Ra.transform(n):yc.transform(n),getAnimatableNone:n=>{const t=mn.parse(n);return t.alpha=0,mn.transform(t)}},JB=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function ZB(n){return isNaN(n)&&typeof n=="string"&&(n.match(Tw)?.length||0)+(n.match(JB)?.length||0)>0}const PA="number",BA="color",QB="var",tV="var(",G$="${}",eV=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function $h(n){const t=n.toString(),e=[],s={color:[],number:[],var:[]},i=[];let r=0;const l=t.replace(eV,c=>(mn.test(c)?(s.color.push(r),i.push(BA),e.push(mn.parse(c))):c.startsWith(tV)?(s.var.push(r),i.push(QB),e.push(c)):(s.number.push(r),i.push(PA),e.push(parseFloat(c))),++r,G$)).split(G$);return{values:e,split:l,indexes:s,types:i}}function VA(n){return $h(n).values}function UA(n){const{split:t,types:e}=$h(n),s=t.length;return i=>{let r="";for(let o=0;o<s;o++)if(r+=t[o],i[o]!==void 0){const l=e[o];l===PA?r+=mh(i[o]):l===BA?r+=mn.transform(i[o]):r+=i[o]}return r}}const nV=n=>typeof n=="number"?0:mn.test(n)?mn.getAnimatableNone(n):n;function sV(n){const t=VA(n);return UA(n)(t.map(nV))}const Mo={test:ZB,parse:VA,createTransformer:UA,getAnimatableNone:sV};function ix(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+(t-n)*6*e:e<1/2?t:e<2/3?n+(t-n)*(2/3-e)*6:n}function iV({hue:n,saturation:t,lightness:e,alpha:s}){n/=360,t/=100,e/=100;let i=0,r=0,o=0;if(!t)i=r=o=e;else{const l=e<.5?e*(1+t):e+t-e*t,c=2*e-l;i=ix(c,l,n+1/3),r=ix(c,l,n),o=ix(c,l,n-1/3)}return{red:Math.round(i*255),green:Math.round(r*255),blue:Math.round(o*255),alpha:s}}function ym(n,t){return e=>e>0?t:n}const qe=(n,t,e)=>n+(t-n)*e,rx=(n,t,e)=>{const s=n*n,i=e*(t*t-s)+s;return i<0?0:Math.sqrt(i)},rV=[Xx,Ra,yc],oV=n=>rV.find(t=>t.test(n));function W$(n){const t=oV(n);if(!t)return!1;let e=t.parse(n);return t===yc&&(e=iV(e)),e}const H$=(n,t)=>{const e=W$(n),s=W$(t);if(!e||!s)return ym(n,t);const i={...e};return r=>(i.red=rx(e.red,s.red,r),i.green=rx(e.green,s.green,r),i.blue=rx(e.blue,s.blue,r),i.alpha=qe(e.alpha,s.alpha,r),Ra.transform(i))},Yx=new Set(["none","hidden"]);function aV(n,t){return Yx.has(n)?e=>e<=0?n:t:e=>e>=1?t:n}function lV(n,t){return e=>qe(n,t,e)}function $w(n){return typeof n=="number"?lV:typeof n=="string"?Cw(n)?ym:mn.test(n)?H$:hV:Array.isArray(n)?jA:typeof n=="object"?mn.test(n)?H$:cV:ym}function jA(n,t){const e=[...n],s=e.length,i=n.map((r,o)=>$w(r)(r,t[o]));return r=>{for(let o=0;o<s;o++)e[o]=i[o](r);return e}}function cV(n,t){const e={...n,...t},s={};for(const i in e)n[i]!==void 0&&t[i]!==void 0&&(s[i]=$w(n[i])(n[i],t[i]));return i=>{for(const r in s)e[r]=s[r](i);return e}}function uV(n,t){const e=[],s={color:0,var:0,number:0};for(let i=0;i<t.values.length;i++){const r=t.types[i],o=n.indexes[r][s[r]],l=n.values[o]??0;e[i]=l,s[r]++}return e}const hV=(n,t)=>{const e=Mo.createTransformer(t),s=$h(n),i=$h(t);return s.indexes.var.length===i.indexes.var.length&&s.indexes.color.length===i.indexes.color.length&&s.indexes.number.length>=i.indexes.number.length?Yx.has(n)&&!i.values.length||Yx.has(t)&&!s.values.length?aV(n,t):Xh(jA(uV(s,i),i.values),e):ym(n,t)};function GA(n,t,e){return typeof n=="number"&&typeof t=="number"&&typeof e=="number"?qe(n,t,e):$w(n)(n,t)}const dV=n=>{const t=({timestamp:e})=>n(e);return{start:(e=!0)=>je.update(t,e),stop:()=>Oo(t),now:()=>Wn.isProcessing?Wn.timestamp:Es.now()}},WA=(n,t,e=10)=>{let s="";const i=Math.max(Math.round(t/e),2);for(let r=0;r<i;r++)s+=Math.round(n(r/(i-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},bm=2e4;function Ew(n){let t=0;const e=50;let s=n.next(t);for(;!s.done&&t<bm;)t+=e,s=n.next(t);return t>=bm?1/0:t}function fV(n,t=100,e){const s=e({...n,keyframes:[0,t]}),i=Math.min(Ew(s),bm);return{type:"keyframes",ease:r=>s.next(i*r).value/t,duration:fi(i)}}const pV=5;function HA(n,t,e){const s=Math.max(t-pV,0);return TA(e-n(s),t-s)}const Ze={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},ox=.001;function mV({duration:n=Ze.duration,bounce:t=Ze.bounce,velocity:e=Ze.velocity,mass:s=Ze.mass}){let i,r,o=1-t;o=Vr(Ze.minDamping,Ze.maxDamping,o),n=Vr(Ze.minDuration,Ze.maxDuration,fi(n)),o<1?(i=h=>{const d=h*o,p=d*n,m=d-e,y=Jx(h,o),b=Math.exp(-p);return ox-m/y*b},r=h=>{const p=h*o*n,m=p*e+e,y=Math.pow(o,2)*Math.pow(h,2)*n,b=Math.exp(-p),x=Jx(Math.pow(h,2),o);return(-i(h)+ox>0?-1:1)*((m-y)*b)/x}):(i=h=>{const d=Math.exp(-h*n),p=(h-e)*n+1;return-ox+d*p},r=h=>{const d=Math.exp(-h*n),p=(e-h)*(n*n);return d*p});const l=5/n,c=yV(i,r,l);if(n=sr(n),isNaN(c))return{stiffness:Ze.stiffness,damping:Ze.damping,duration:n};{const h=Math.pow(c,2)*s;return{stiffness:h,damping:o*2*Math.sqrt(s*h),duration:n}}}const gV=12;function yV(n,t,e){let s=e;for(let i=1;i<gV;i++)s=s-n(s)/t(s);return s}function Jx(n,t){return n*Math.sqrt(1-t*t)}const bV=["duration","bounce"],xV=["stiffness","damping","mass"];function q$(n,t){return t.some(e=>n[e]!==void 0)}function vV(n){let t={velocity:Ze.velocity,stiffness:Ze.stiffness,damping:Ze.damping,mass:Ze.mass,isResolvedFromDuration:!1,...n};if(!q$(n,xV)&&q$(n,bV))if(n.visualDuration){const e=n.visualDuration,s=2*Math.PI/(e*1.2),i=s*s,r=2*Vr(.05,1,1-(n.bounce||0))*Math.sqrt(i);t={...t,mass:Ze.mass,stiffness:i,damping:r}}else{const e=mV(n);t={...t,...e,mass:Ze.mass},t.isResolvedFromDuration=!0}return t}function xm(n=Ze.visualDuration,t=Ze.bounce){const e=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:t}:n;let{restSpeed:s,restDelta:i}=e;const r=e.keyframes[0],o=e.keyframes[e.keyframes.length-1],l={done:!1,value:r},{stiffness:c,damping:h,mass:d,duration:p,velocity:m,isResolvedFromDuration:y}=vV({...e,velocity:-fi(e.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(c*d)),w=o-r,S=fi(Math.sqrt(c/d)),T=Math.abs(w)<5;s||(s=T?Ze.restSpeed.granular:Ze.restSpeed.default),i||(i=T?Ze.restDelta.granular:Ze.restDelta.default);let k;if(x<1){const E=Jx(S,x);k=N=>{const _=Math.exp(-x*S*N);return o-_*((b+x*S*w)/E*Math.sin(E*N)+w*Math.cos(E*N))}}else if(x===1)k=E=>o-Math.exp(-S*E)*(w+(b+S*w)*E);else{const E=S*Math.sqrt(x*x-1);k=N=>{const _=Math.exp(-x*S*N),R=Math.min(E*N,300);return o-_*((b+x*S*w)*Math.sinh(R)+E*w*Math.cosh(R))/E}}const $={calculatedDuration:y&&p||null,next:E=>{const N=k(E);if(y)l.done=E>=p;else{let _=E===0?b:0;x<1&&(_=E===0?sr(b):HA(k,E,N));const R=Math.abs(_)<=s,D=Math.abs(o-N)<=i;l.done=R&&D}return l.value=l.done?o:N,l},toString:()=>{const E=Math.min(Ew($),bm),N=WA(_=>$.next(E*_).value,E,30);return E+"ms "+N},toTransition:()=>{}};return $}xm.applyToOptions=n=>{const t=fV(n,100,xm);return n.ease=t.ease,n.duration=sr(t.duration),n.type="keyframes",n};function Zx({keyframes:n,velocity:t=0,power:e=.8,timeConstant:s=325,bounceDamping:i=10,bounceStiffness:r=500,modifyTarget:o,min:l,max:c,restDelta:h=.5,restSpeed:d}){const p=n[0],m={done:!1,value:p},y=R=>l!==void 0&&R<l||c!==void 0&&R>c,b=R=>l===void 0?c:c===void 0||Math.abs(l-R)<Math.abs(c-R)?l:c;let x=e*t;const w=p+x,S=o===void 0?w:o(w);S!==w&&(x=S-p);const T=R=>-x*Math.exp(-R/s),k=R=>S+T(R),$=R=>{const D=T(R),M=k(R);m.done=Math.abs(D)<=h,m.value=m.done?S:M};let E,N;const _=R=>{y(m.value)&&(E=R,N=xm({keyframes:[m.value,b(m.value)],velocity:HA(k,R,m.value),damping:i,stiffness:r,restDelta:h,restSpeed:d}))};return _(0),{calculatedDuration:null,next:R=>{let D=!1;return!N&&E===void 0&&(D=!0,$(R),_(R)),E!==void 0&&R>=E?N.next(R-E):(!D&&$(R),m)}}}function wV(n,t,e){const s=[],i=e||Ur.mix||GA,r=n.length-1;for(let o=0;o<r;o++){let l=i(n[o],n[o+1]);if(t){const c=Array.isArray(t)?t[o]||gi:t;l=Xh(c,l)}s.push(l)}return s}function SV(n,t,{clamp:e=!0,ease:s,mixer:i}={}){const r=n.length;if(bw(r===t.length),r===1)return()=>t[0];if(r===2&&t[0]===t[1])return()=>t[1];const o=n[0]===n[1];n[0]>n[r-1]&&(n=[...n].reverse(),t=[...t].reverse());const l=wV(t,s,i),c=l.length,h=d=>{if(o&&d<n[0])return t[0];let p=0;if(c>1)for(;p<n.length-2&&!(d<n[p+1]);p++);const m=Th(n[p],n[p+1],d);return l[p](m)};return e?d=>h(Vr(n[0],n[r-1],d)):h}function CV(n,t){const e=n[n.length-1];for(let s=1;s<=t;s++){const i=Th(0,t,s);n.push(qe(e,1,i))}}function TV(n){const t=[0];return CV(t,n.length-1),t}function kV(n,t){return n.map(e=>e*t)}function $V(n,t){return n.map(()=>t||DA).splice(0,n.length-1)}function gh({duration:n=300,keyframes:t,times:e,ease:s="easeInOut"}){const i=LB(s)?s.map(U$):U$(s),r={done:!1,value:t[0]},o=kV(e&&e.length===t.length?e:TV(t),n),l=SV(o,t,{ease:Array.isArray(i)?i:$V(t,i)});return{calculatedDuration:n,next:c=>(r.value=l(c),r.done=c>=n,r)}}const EV=n=>n!==null;function Iw(n,{repeat:t,repeatType:e="loop"},s,i=1){const r=n.filter(EV),l=i<0||t&&e!=="loop"&&t%2===1?0:r.length-1;return!l||s===void 0?r[l]:s}const IV={decay:Zx,inertia:Zx,tween:gh,keyframes:gh,spring:xm};function qA(n){typeof n.type=="string"&&(n.type=IV[n.type])}class Nw{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(t=>{this.resolve=t})}notifyFinished(){this.resolve()}then(t,e){return this.finished.then(t,e)}}const NV=n=>n/100;class Aw extends Nw{constructor(t){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:e}=this.options;e&&e.updatedAt!==Es.now()&&this.tick(Es.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=t,this.initAnimation(),this.play(),t.autoplay===!1&&this.pause()}initAnimation(){const{options:t}=this;qA(t);const{type:e=gh,repeat:s=0,repeatDelay:i=0,repeatType:r,velocity:o=0}=t;let{keyframes:l}=t;const c=e||gh;c!==gh&&typeof l[0]!="number"&&(this.mixKeyframes=Xh(NV,GA(l[0],l[1])),l=[0,100]);const h=c({...t,keyframes:l});r==="mirror"&&(this.mirroredGenerator=c({...t,keyframes:[...l].reverse(),velocity:-o})),h.calculatedDuration===null&&(h.calculatedDuration=Ew(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+i,this.totalDuration=this.resolvedDuration*(s+1)-i,this.generator=h}updateTime(t){const e=Math.round(t-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=e}tick(t,e=!1){const{generator:s,totalDuration:i,mixKeyframes:r,mirroredGenerator:o,resolvedDuration:l,calculatedDuration:c}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:p,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-i/this.speed,this.startTime)),e?this.currentTime=t:this.updateTime(t);const S=this.currentTime-h*(this.playbackSpeed>=0?1:-1),T=this.playbackSpeed>=0?S<0:S>i;this.currentTime=Math.max(S,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=i);let k=this.currentTime,$=s;if(p){const R=Math.min(this.currentTime,i)/l;let D=Math.floor(R),M=R%1;!M&&R>=1&&(M=1),M===1&&D--,D=Math.min(D,p+1),D%2&&(m==="reverse"?(M=1-M,y&&(M-=y/l)):m==="mirror"&&($=o)),k=Vr(0,1,M)*l}const E=T?{done:!1,value:d[0]}:$.next(k);r&&(E.value=r(E.value));let{done:N}=E;!T&&c!==null&&(N=this.playbackSpeed>=0?this.currentTime>=i:this.currentTime<=0);const _=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&N);return _&&b!==Zx&&(E.value=Iw(d,this.options,w,this.speed)),x&&x(E.value),_&&this.finish(),E}then(t,e){return this.finished.then(t,e)}get duration(){return fi(this.calculatedDuration)}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+fi(t)}get time(){return fi(this.currentTime)}set time(t){t=sr(t),this.currentTime=t,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(t){this.updateTime(Es.now());const e=this.playbackSpeed!==t;this.playbackSpeed=t,e&&(this.time=fi(this.currentTime))}play(){if(this.isStopped)return;const{driver:t=dV,startTime:e}=this.options;this.driver||(this.driver=t(i=>this.tick(i))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=e??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Es.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(t){return this.startTime=0,this.tick(t,!0)}attachTimeline(t){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),t.observe(this)}}function AV(n){for(let t=1;t<n.length;t++)n[t]??(n[t]=n[t-1])}const Da=n=>n*180/Math.PI,Qx=n=>{const t=Da(Math.atan2(n[1],n[0]));return tv(t)},_V={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:Qx,rotateZ:Qx,skewX:n=>Da(Math.atan(n[1])),skewY:n=>Da(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},tv=n=>(n=n%360,n<0&&(n+=360),n),K$=Qx,X$=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),Y$=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),RV={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:X$,scaleY:Y$,scale:n=>(X$(n)+Y$(n))/2,rotateX:n=>tv(Da(Math.atan2(n[6],n[5]))),rotateY:n=>tv(Da(Math.atan2(-n[2],n[0]))),rotateZ:K$,rotate:K$,skewX:n=>Da(Math.atan(n[4])),skewY:n=>Da(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function ev(n){return n.includes("scale")?1:0}function nv(n,t){if(!n||n==="none")return ev(t);const e=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,i;if(e)s=RV,i=e;else{const l=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=_V,i=l}if(!i)return ev(t);const r=s[t],o=i[1].split(",").map(OV);return typeof r=="function"?r(o):o[r]}const DV=(n,t)=>{const{transform:e="none"}=getComputedStyle(n);return nv(e,t)};function OV(n){return parseFloat(n.trim())}const Gc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Wc=new Set(Gc),J$=n=>n===jc||n===Gt,MV=new Set(["x","y","z"]),FV=Gc.filter(n=>!MV.has(n));function LV(n){const t=[];return FV.forEach(e=>{const s=n.getValue(e);s!==void 0&&(t.push([e,s.get()]),s.set(e.startsWith("scale")?1:0))}),t}const Pa={width:({x:n},{paddingLeft:t="0",paddingRight:e="0"})=>n.max-n.min-parseFloat(t)-parseFloat(e),height:({y:n},{paddingTop:t="0",paddingBottom:e="0"})=>n.max-n.min-parseFloat(t)-parseFloat(e),top:(n,{top:t})=>parseFloat(t),left:(n,{left:t})=>parseFloat(t),bottom:({y:n},{top:t})=>parseFloat(t)+(n.max-n.min),right:({x:n},{left:t})=>parseFloat(t)+(n.max-n.min),x:(n,{transform:t})=>nv(t,"x"),y:(n,{transform:t})=>nv(t,"y")};Pa.translateX=Pa.x;Pa.translateY=Pa.y;const Ba=new Set;let sv=!1,iv=!1,rv=!1;function KA(){if(iv){const n=Array.from(Ba).filter(s=>s.needsMeasurement),t=new Set(n.map(s=>s.element)),e=new Map;t.forEach(s=>{const i=LV(s);i.length&&(e.set(s,i),s.render())}),n.forEach(s=>s.measureInitialState()),t.forEach(s=>{s.render();const i=e.get(s);i&&i.forEach(([r,o])=>{s.getValue(r)?.set(o)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}iv=!1,sv=!1,Ba.forEach(n=>n.complete(rv)),Ba.clear()}function XA(){Ba.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(iv=!0)})}function zV(){rv=!0,XA(),KA(),rv=!1}class _w{constructor(t,e,s,i,r,o=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...t],this.onComplete=e,this.name=s,this.motionValue=i,this.element=r,this.isAsync=o}scheduleResolve(){this.state="scheduled",this.isAsync?(Ba.add(this),sv||(sv=!0,je.read(XA),je.resolveKeyframes(KA))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:s,motionValue:i}=this;if(t[0]===null){const r=i?.get(),o=t[t.length-1];if(r!==void 0)t[0]=r;else if(s&&e){const l=s.readValue(e,o);l!=null&&(t[0]=l)}t[0]===void 0&&(t[0]=o),i&&r===void 0&&i.set(t[0])}AV(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,t),Ba.delete(this)}cancel(){this.state==="scheduled"&&(Ba.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const PV=n=>n.startsWith("--");function BV(n,t,e){PV(t)?n.style.setProperty(t,e):n.style[t]=e}const VV=xw(()=>window.ScrollTimeline!==void 0),UV={};function jV(n,t){const e=xw(n);return()=>UV[t]??e()}const YA=jV(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),ah=([n,t,e,s])=>`cubic-bezier(${n}, ${t}, ${e}, ${s})`,Z$={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:ah([0,.65,.55,1]),circOut:ah([.55,0,1,.45]),backIn:ah([.31,.01,.66,-.59]),backOut:ah([.33,1.53,.69,.99])};function JA(n,t){if(n)return typeof n=="function"?YA()?WA(n,t):"ease-out":OA(n)?ah(n):Array.isArray(n)?n.map(e=>JA(e,t)||Z$.easeOut):Z$[n]}function GV(n,t,e,{delay:s=0,duration:i=300,repeat:r=0,repeatType:o="loop",ease:l="easeOut",times:c}={},h=void 0){const d={[t]:e};c&&(d.offset=c);const p=JA(l,i);Array.isArray(p)&&(d.easing=p);const m={delay:s,duration:i,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:r+1,direction:o==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function ZA(n){return typeof n=="function"&&"applyToOptions"in n}function WV({type:n,...t}){return ZA(n)&&YA()?n.applyToOptions(t):(t.duration??(t.duration=300),t.ease??(t.ease="easeOut"),t)}class HV extends Nw{constructor(t){if(super(),this.finishedTime=null,this.isStopped=!1,!t)return;const{element:e,name:s,keyframes:i,pseudoElement:r,allowFlatten:o=!1,finalKeyframe:l,onComplete:c}=t;this.isPseudoElement=!!r,this.allowFlatten=o,this.options=t,bw(typeof t.type!="string");const h=WV(t);this.animation=GV(e,s,i,h,r),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!r){const d=Iw(i,this.options,l,this.speed);this.updateMotionValue?this.updateMotionValue(d):BV(e,s,d),this.animation.cancel()}c?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:t}=this;t==="idle"||t==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const t=this.animation.effect?.getComputedTiming?.().duration||0;return fi(Number(t))}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+fi(t)}get time(){return fi(Number(this.animation.currentTime)||0)}set time(t){this.finishedTime=null,this.animation.currentTime=sr(t)}get speed(){return this.animation.playbackRate}set speed(t){t<0&&(this.finishedTime=null),this.animation.playbackRate=t}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(t){this.animation.startTime=t}attachTimeline({timeline:t,observe:e}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,t&&VV()?(this.animation.timeline=t,gi):e(this)}}const QA={anticipate:AA,backInOut:NA,circInOut:RA};function qV(n){return n in QA}function KV(n){typeof n.ease=="string"&&qV(n.ease)&&(n.ease=QA[n.ease])}const Q$=10;class XV extends HV{constructor(t){KV(t),qA(t),super(t),t.startTime&&(this.startTime=t.startTime),this.options=t}updateMotionValue(t){const{motionValue:e,onUpdate:s,onComplete:i,element:r,...o}=this.options;if(!e)return;if(t!==void 0){e.set(t);return}const l=new Aw({...o,autoplay:!1}),c=sr(this.finishedTime??this.time);e.setWithVelocity(l.sample(c-Q$).value,l.sample(c).value,Q$),l.stop()}}const tE=(n,t)=>t==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(Mo.test(n)||n==="0")&&!n.startsWith("url("));function YV(n){const t=n[0];if(n.length===1)return!0;for(let e=0;e<n.length;e++)if(n[e]!==t)return!0}function JV(n,t,e,s){const i=n[0];if(i===null)return!1;if(t==="display"||t==="visibility")return!0;const r=n[n.length-1],o=tE(i,t),l=tE(r,t);return!o||!l?!1:YV(n)||(e==="spring"||ZA(e))&&s}function ov(n){n.duration=0,n.type="keyframes"}const ZV=new Set(["opacity","clipPath","filter","transform"]),QV=xw(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function tU(n){const{motionValue:t,name:e,repeatDelay:s,repeatType:i,damping:r,type:o}=n;if(!(t?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:c,transformTemplate:h}=t.owner.getProps();return QV()&&e&&ZV.has(e)&&(e!=="transform"||!h)&&!c&&!s&&i!=="mirror"&&r!==0&&o!=="inertia"}const eU=40;class nU extends Nw{constructor({autoplay:t=!0,delay:e=0,type:s="keyframes",repeat:i=0,repeatDelay:r=0,repeatType:o="loop",keyframes:l,name:c,motionValue:h,element:d,...p}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Es.now();const m={autoplay:t,delay:e,type:s,repeat:i,repeatDelay:r,repeatType:o,name:c,motionValue:h,element:d,...p},y=d?.KeyframeResolver||_w;this.keyframeResolver=new y(l,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),c,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(t,e,s,i){this.keyframeResolver=void 0;const{name:r,type:o,velocity:l,delay:c,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Es.now(),JV(t,r,o,l)||((Ur.instantAnimations||!c)&&d?.(Iw(t,s,e)),t[0]=t[t.length-1],ov(s),s.repeat=0);const m={startTime:i?this.resolvedAt?this.resolvedAt-this.createdAt>eU?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:e,...s,keyframes:t},y=!h&&tU(m)?new XV({...m,element:m.motionValue.owner.current}):new Aw(m);y.finished.then(()=>this.notifyFinished()).catch(gi),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(t,e){return this.finished.finally(t).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),zV()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(t){this.animation.time=t}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(t){this.animation.speed=t}get startTime(){return this.animation.startTime}attachTimeline(t){return this._animation?this.stopTimeline=this.animation.attachTimeline(t):this.pendingTimeline=t,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const sU=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function iU(n){const t=sU.exec(n);if(!t)return[,];const[,e,s,i]=t;return[`--${e??s}`,i]}function t_(n,t,e=1){const[s,i]=iU(n);if(!s)return;const r=window.getComputedStyle(t).getPropertyValue(s);if(r){const o=r.trim();return wA(o)?parseFloat(o):o}return Cw(i)?t_(i,t,e+1):i}function Rw(n,t){return n?.[t]??n?.default??n}const e_=new Set(["width","height","top","left","right","bottom",...Gc]),rU={test:n=>n==="auto",parse:n=>n},n_=n=>t=>t.test(n),s_=[jc,Gt,ir,Co,YB,XB,rU],eE=n=>s_.find(n_(n));function oU(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||CA(n):!0}const aU=new Set(["brightness","contrast","saturate","opacity"]);function lU(n){const[t,e]=n.slice(0,-1).split("(");if(t==="drop-shadow")return n;const[s]=e.match(Tw)||[];if(!s)return n;const i=e.replace(s,"");let r=aU.has(t)?1:0;return s!==e&&(r*=100),t+"("+r+i+")"}const cU=/\b([a-z-]*)\(.*?\)/gu,av={...Mo,getAnimatableNone:n=>{const t=n.match(cU);return t?t.map(lU).join(" "):n}},nE={...jc,transform:Math.round},uU={rotate:Co,rotateX:Co,rotateY:Co,rotateZ:Co,scale:zp,scaleX:zp,scaleY:zp,scaleZ:zp,skew:Co,skewX:Co,skewY:Co,distance:Gt,translateX:Gt,translateY:Gt,translateZ:Gt,x:Gt,y:Gt,z:Gt,perspective:Gt,transformPerspective:Gt,opacity:kh,originX:j$,originY:j$,originZ:Gt},Dw={borderWidth:Gt,borderTopWidth:Gt,borderRightWidth:Gt,borderBottomWidth:Gt,borderLeftWidth:Gt,borderRadius:Gt,radius:Gt,borderTopLeftRadius:Gt,borderTopRightRadius:Gt,borderBottomRightRadius:Gt,borderBottomLeftRadius:Gt,width:Gt,maxWidth:Gt,height:Gt,maxHeight:Gt,top:Gt,right:Gt,bottom:Gt,left:Gt,padding:Gt,paddingTop:Gt,paddingRight:Gt,paddingBottom:Gt,paddingLeft:Gt,margin:Gt,marginTop:Gt,marginRight:Gt,marginBottom:Gt,marginLeft:Gt,backgroundPositionX:Gt,backgroundPositionY:Gt,...uU,zIndex:nE,fillOpacity:kh,strokeOpacity:kh,numOctaves:nE},hU={...Dw,color:mn,backgroundColor:mn,outlineColor:mn,fill:mn,stroke:mn,borderColor:mn,borderTopColor:mn,borderRightColor:mn,borderBottomColor:mn,borderLeftColor:mn,filter:av,WebkitFilter:av},i_=n=>hU[n];function r_(n,t){let e=i_(n);return e!==av&&(e=Mo),e.getAnimatableNone?e.getAnimatableNone(t):void 0}const dU=new Set(["auto","none","0"]);function fU(n,t,e){let s=0,i;for(;s<n.length&&!i;){const r=n[s];typeof r=="string"&&!dU.has(r)&&$h(r).values.length&&(i=n[s]),s++}if(i&&e)for(const r of t)n[r]=r_(e,i)}class pU extends _w{constructor(t,e,s,i,r){super(t,e,s,i,r,!0)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:s}=this;if(!e||!e.current)return;super.readKeyframes();for(let c=0;c<t.length;c++){let h=t[c];if(typeof h=="string"&&(h=h.trim(),Cw(h))){const d=t_(h,e.current);d!==void 0&&(t[c]=d),c===t.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!e_.has(s)||t.length!==2)return;const[i,r]=t,o=eE(i),l=eE(r);if(o!==l)if(J$(o)&&J$(l))for(let c=0;c<t.length;c++){const h=t[c];typeof h=="string"&&(t[c]=parseFloat(h))}else Pa[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this,s=[];for(let i=0;i<t.length;i++)(t[i]===null||oU(t[i]))&&s.push(i);s.length&&fU(t,s,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:s}=this;if(!t||!t.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=Pa[s](t.measureViewportBox(),window.getComputedStyle(t.current)),e[0]=this.measuredOrigin;const i=e[e.length-1];i!==void 0&&t.getValue(s,i).jump(i,!1)}measureEndState(){const{element:t,name:e,unresolvedKeyframes:s}=this;if(!t||!t.current)return;const i=t.getValue(e);i&&i.jump(this.measuredOrigin,!1);const r=s.length-1,o=s[r];s[r]=Pa[e](t.measureViewportBox(),window.getComputedStyle(t.current)),o!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=o),this.removedTransforms?.length&&this.removedTransforms.forEach(([l,c])=>{t.getValue(l).set(c)}),this.resolveNoneKeyframes()}}function mU(n,t,e){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const i=e?.[n]??s.querySelectorAll(n);return i?Array.from(i):[]}return Array.from(n)}const o_=(n,t)=>t&&typeof n=="number"?t.transform(n):n;function a_(n){return SA(n)&&"offsetHeight"in n}const sE=30,gU=n=>!isNaN(parseFloat(n));class yU{constructor(t,e={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const i=Es.now();if(this.updatedAt!==i&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const r of this.dependents)r.dirty()},this.hasAnimated=!1,this.setCurrent(t),this.owner=e.owner}setCurrent(t){this.current=t,this.updatedAt=Es.now(),this.canTrackVelocity===null&&t!==void 0&&(this.canTrackVelocity=gU(this.current))}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new vw);const s=this.events[t].add(e);return t==="change"?()=>{s(),je.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t,this.stopPassiveEffect=e}set(t){this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t)}setWithVelocity(t,e,s){this.set(e),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-s}jump(t,e=!0){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,e&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(t){this.dependents||(this.dependents=new Set),this.dependents.add(t)}removeDependent(t){this.dependents&&this.dependents.delete(t)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const t=Es.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||t-this.updatedAt>sE)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,sE);return TA(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}start(t){return this.stop(),new Promise(e=>{this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Ac(n,t){return new yU(n,t)}const{schedule:Ow}=MA(queueMicrotask,!1),_i={x:!1,y:!1};function l_(){return _i.x||_i.y}function bU(n){return n==="x"||n==="y"?_i[n]?null:(_i[n]=!0,()=>{_i[n]=!1}):_i.x||_i.y?null:(_i.x=_i.y=!0,()=>{_i.x=_i.y=!1})}function c_(n,t){const e=mU(n),s=new AbortController,i={passive:!0,...t,signal:s.signal};return[e,i,()=>s.abort()]}function iE(n){return!(n.pointerType==="touch"||l_())}function xU(n,t,e={}){const[s,i,r]=c_(n,e),o=l=>{if(!iE(l))return;const{target:c}=l,h=t(c,l);if(typeof h!="function"||!c)return;const d=p=>{iE(p)&&(h(p),c.removeEventListener("pointerleave",d))};c.addEventListener("pointerleave",d,i)};return s.forEach(l=>{l.addEventListener("pointerenter",o,i)}),r}const u_=(n,t)=>t?n===t?!0:u_(n,t.parentElement):!1,Mw=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,vU=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function wU(n){return vU.has(n.tagName)||n.tabIndex!==-1}const rm=new WeakSet;function rE(n){return t=>{t.key==="Enter"&&n(t)}}function ax(n,t){n.dispatchEvent(new PointerEvent("pointer"+t,{isPrimary:!0,bubbles:!0}))}const SU=(n,t)=>{const e=n.currentTarget;if(!e)return;const s=rE(()=>{if(rm.has(e))return;ax(e,"down");const i=rE(()=>{ax(e,"up")}),r=()=>ax(e,"cancel");e.addEventListener("keyup",i,t),e.addEventListener("blur",r,t)});e.addEventListener("keydown",s,t),e.addEventListener("blur",()=>e.removeEventListener("keydown",s),t)};function oE(n){return Mw(n)&&!l_()}function CU(n,t,e={}){const[s,i,r]=c_(n,e),o=l=>{const c=l.currentTarget;if(!oE(l))return;rm.add(c);const h=t(c,l),d=(y,b)=>{window.removeEventListener("pointerup",p),window.removeEventListener("pointercancel",m),rm.has(c)&&rm.delete(c),oE(y)&&typeof h=="function"&&h(y,{success:b})},p=y=>{d(y,c===window||c===document||e.useGlobalTarget||u_(c,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",p,i),window.addEventListener("pointercancel",m,i)};return s.forEach(l=>{(e.useGlobalTarget?window:l).addEventListener("pointerdown",o,i),a_(l)&&(l.addEventListener("focus",h=>SU(h,i)),!wU(l)&&!l.hasAttribute("tabindex")&&(l.tabIndex=0))}),r}function h_(n){return SA(n)&&"ownerSVGElement"in n}function TU(n){return h_(n)&&n.tagName==="svg"}const ns=n=>!!(n&&n.getVelocity),kU=[...s_,mn,Mo],$U=n=>kU.find(n_(n)),Fw=St.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function aE(n,t){if(typeof n=="function")return n(t);n!=null&&(n.current=t)}function EU(...n){return t=>{let e=!1;const s=n.map(i=>{const r=aE(i,t);return!e&&typeof r=="function"&&(e=!0),r});if(e)return()=>{for(let i=0;i<s.length;i++){const r=s[i];typeof r=="function"?r():aE(n[i],null)}}}}function IU(...n){return St.useCallback(EU(...n),n)}class NU extends St.Component{getSnapshotBeforeUpdate(t){const e=this.props.childRef.current;if(e&&t.isPresent&&!this.props.isPresent){const s=e.offsetParent,i=a_(s)&&s.offsetWidth||0,r=this.props.sizeRef.current;r.height=e.offsetHeight||0,r.width=e.offsetWidth||0,r.top=e.offsetTop,r.left=e.offsetLeft,r.right=i-r.width-r.left}return null}componentDidUpdate(){}render(){return this.props.children}}function AU({children:n,isPresent:t,anchorX:e,root:s}){const i=St.useId(),r=St.useRef(null),o=St.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:l}=St.useContext(Fw),c=IU(r,n?.ref);return St.useInsertionEffect(()=>{const{width:h,height:d,top:p,left:m,right:y}=o.current;if(t||!r.current||!h||!d)return;const b=e==="left"?`left: ${m}`:`right: ${y}`;r.current.dataset.motionPopId=i;const x=document.createElement("style");l&&(x.nonce=l);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${p}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[t]),bt.jsx(NU,{isPresent:t,childRef:r,sizeRef:o,children:St.cloneElement(n,{ref:c})})}const _U=({children:n,initial:t,isPresent:e,onExitComplete:s,custom:i,presenceAffectsLayout:r,mode:o,anchorX:l,root:c})=>{const h=pw(RU),d=St.useId();let p=!0,m=St.useMemo(()=>(p=!1,{id:d,initial:t,isPresent:e,custom:i,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[e,h,s]);return r&&p&&(m={...m}),St.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[e]),St.useEffect(()=>{!e&&!h.size&&s&&s()},[e]),o==="popLayout"&&(n=bt.jsx(AU,{isPresent:e,anchorX:l,root:c,children:n})),bt.jsx(ng.Provider,{value:m,children:n})};function RU(){return new Map}function d_(n=!0){const t=St.useContext(ng);if(t===null)return[!0,null];const{isPresent:e,onExitComplete:s,register:i}=t,r=St.useId();St.useEffect(()=>{if(n)return i(r)},[n]);const o=St.useCallback(()=>n&&s&&s(r),[r,s,n]);return!e&&s?[!1,o]:[!0]}const Pp=n=>n.key||"";function lE(n){const t=[];return St.Children.forEach(n,e=>{St.isValidElement(e)&&t.push(e)}),t}const DU=({children:n,custom:t,initial:e=!0,onExitComplete:s,presenceAffectsLayout:i=!0,mode:r="sync",propagate:o=!1,anchorX:l="left",root:c})=>{const[h,d]=d_(o),p=St.useMemo(()=>lE(n),[n]),m=o&&!h?[]:p.map(Pp),y=St.useRef(!0),b=St.useRef(p),x=pw(()=>new Map),[w,S]=St.useState(p),[T,k]=St.useState(p);vA(()=>{y.current=!1,b.current=p;for(let N=0;N<T.length;N++){const _=Pp(T[N]);m.includes(_)?x.delete(_):x.get(_)!==!0&&x.set(_,!1)}},[T,m.length,m.join("-")]);const $=[];if(p!==w){let N=[...p];for(let _=0;_<T.length;_++){const R=T[_],D=Pp(R);m.includes(D)||(N.splice(_,0,R),$.push(R))}return r==="wait"&&$.length&&(N=$),k(lE(N)),S(p),null}const{forceRender:E}=St.useContext(fw);return bt.jsx(bt.Fragment,{children:T.map(N=>{const _=Pp(N),R=o&&!h?!1:p===T||m.includes(_),D=()=>{if(x.has(_))x.set(_,!0);else return;let M=!0;x.forEach(A=>{A||(M=!1)}),M&&(E?.(),k(b.current),o&&d?.(),s&&s())};return bt.jsx(_U,{isPresent:R,initial:!y.current||e?void 0:!1,custom:t,presenceAffectsLayout:i,mode:r,root:c,onExitComplete:R?void 0:D,anchorX:l,children:N},_)})})},f_=St.createContext({strict:!1}),cE={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},_c={};for(const n in cE)_c[n]={isEnabled:t=>cE[n].some(e=>!!t[e])};function OU(n){for(const t in n)_c[t]={..._c[t],...n[t]}}const MU=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function vm(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||MU.has(n)}let p_=n=>!vm(n);function FU(n){typeof n=="function"&&(p_=t=>t.startsWith("on")?!vm(t):n(t))}try{FU(require("@emotion/is-prop-valid").default)}catch{}function LU(n,t,e){const s={};for(const i in n)i==="values"&&typeof n.values=="object"||(p_(i)||e===!0&&vm(i)||!t&&!vm(i)||n.draggable&&i.startsWith("onDrag"))&&(s[i]=n[i]);return s}const sg=St.createContext({});function ig(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function Eh(n){return typeof n=="string"||Array.isArray(n)}const Lw=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],zw=["initial",...Lw];function rg(n){return ig(n.animate)||zw.some(t=>Eh(n[t]))}function m_(n){return!!(rg(n)||n.variants)}function zU(n,t){if(rg(n)){const{initial:e,animate:s}=n;return{initial:e===!1||Eh(e)?e:void 0,animate:Eh(s)?s:void 0}}return n.inherit!==!1?t:{}}function PU(n){const{initial:t,animate:e}=zU(n,St.useContext(sg));return St.useMemo(()=>({initial:t,animate:e}),[uE(t),uE(e)])}function uE(n){return Array.isArray(n)?n.join(" "):n}function hE(n,t){return t.max===t.min?0:n/(t.max-t.min)*100}const nh={correct:(n,t)=>{if(!t.target)return n;if(typeof n=="string")if(Gt.test(n))n=parseFloat(n);else return n;const e=hE(n,t.target.x),s=hE(n,t.target.y);return`${e}% ${s}%`}},BU={correct:(n,{treeScale:t,projectionDelta:e})=>{const s=n,i=Mo.parse(n);if(i.length>5)return s;const r=Mo.createTransformer(n),o=typeof i[0]!="number"?1:0,l=e.x.scale*t.x,c=e.y.scale*t.y;i[0+o]/=l,i[1+o]/=c;const h=qe(l,c,.5);return typeof i[2+o]=="number"&&(i[2+o]/=h),typeof i[3+o]=="number"&&(i[3+o]/=h),r(i)}},lv={borderRadius:{...nh,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:nh,borderTopRightRadius:nh,borderBottomLeftRadius:nh,borderBottomRightRadius:nh,boxShadow:BU};function g_(n,{layout:t,layoutId:e}){return Wc.has(n)||n.startsWith("origin")||(t||e!==void 0)&&(!!lv[n]||n==="opacity")}const VU={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},UU=Gc.length;function jU(n,t,e){let s="",i=!0;for(let r=0;r<UU;r++){const o=Gc[r],l=n[o];if(l===void 0)continue;let c=!0;if(typeof l=="number"?c=l===(o.startsWith("scale")?1:0):c=parseFloat(l)===0,!c||e){const h=o_(l,Dw[o]);if(!c){i=!1;const d=VU[o]||o;s+=`${d}(${h}) `}e&&(t[o]=h)}}return s=s.trim(),e?s=e(t,i?"":s):i&&(s="none"),s}function Pw(n,t,e){const{style:s,vars:i,transformOrigin:r}=n;let o=!1,l=!1;for(const c in t){const h=t[c];if(Wc.has(c)){o=!0;continue}else if(LA(c)){i[c]=h;continue}else{const d=o_(h,Dw[c]);c.startsWith("origin")?(l=!0,r[c]=d):s[c]=d}}if(t.transform||(o||e?s.transform=jU(t,n.transform,e):s.transform&&(s.transform="none")),l){const{originX:c="50%",originY:h="50%",originZ:d=0}=r;s.transformOrigin=`${c} ${h} ${d}`}}const Bw=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function y_(n,t,e){for(const s in t)!ns(t[s])&&!g_(s,e)&&(n[s]=t[s])}function GU({transformTemplate:n},t){return St.useMemo(()=>{const e=Bw();return Pw(e,t,n),Object.assign({},e.vars,e.style)},[t])}function WU(n,t){const e=n.style||{},s={};return y_(s,e,n),Object.assign(s,GU(n,t)),s}function HU(n,t){const e={},s=WU(n,t);return n.drag&&n.dragListener!==!1&&(e.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(e.tabIndex=0),e.style=s,e}const qU={offset:"stroke-dashoffset",array:"stroke-dasharray"},KU={offset:"strokeDashoffset",array:"strokeDasharray"};function XU(n,t,e=1,s=0,i=!0){n.pathLength=1;const r=i?qU:KU;n[r.offset]=Gt.transform(-s);const o=Gt.transform(t),l=Gt.transform(e);n[r.array]=`${o} ${l}`}function b_(n,{attrX:t,attrY:e,attrScale:s,pathLength:i,pathSpacing:r=1,pathOffset:o=0,...l},c,h,d){if(Pw(n,l,h),c){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:p,style:m}=n;p.transform&&(m.transform=p.transform,delete p.transform),(m.transform||p.transformOrigin)&&(m.transformOrigin=p.transformOrigin??"50% 50%",delete p.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete p.transformBox),t!==void 0&&(p.x=t),e!==void 0&&(p.y=e),s!==void 0&&(p.scale=s),i!==void 0&&XU(p,i,r,o,!1)}const x_=()=>({...Bw(),attrs:{}}),v_=n=>typeof n=="string"&&n.toLowerCase()==="svg";function YU(n,t,e,s){const i=St.useMemo(()=>{const r=x_();return b_(r,t,v_(s),n.transformTemplate,n.style),{...r.attrs,style:{...r.style}}},[t]);if(n.style){const r={};y_(r,n.style,n),i.style={...r,...i.style}}return i}const JU=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function Vw(n){return typeof n!="string"||n.includes("-")?!1:!!(JU.indexOf(n)>-1||/[A-Z]/u.test(n))}function ZU(n,t,e,{latestValues:s},i,r=!1){const l=(Vw(n)?YU:HU)(t,s,i,n),c=LU(t,typeof n=="string",r),h=n!==St.Fragment?{...c,...l,ref:e}:{},{children:d}=t,p=St.useMemo(()=>ns(d)?d.get():d,[d]);return St.createElement(n,{...h,children:p})}function dE(n){const t=[{},{}];return n?.values.forEach((e,s)=>{t[0][s]=e.get(),t[1][s]=e.getVelocity()}),t}function Uw(n,t,e,s){if(typeof t=="function"){const[i,r]=dE(s);t=t(e!==void 0?e:n.custom,i,r)}if(typeof t=="string"&&(t=n.variants&&n.variants[t]),typeof t=="function"){const[i,r]=dE(s);t=t(e!==void 0?e:n.custom,i,r)}return t}function om(n){return ns(n)?n.get():n}function QU({scrapeMotionValuesFromProps:n,createRenderState:t},e,s,i){return{latestValues:t4(e,s,i,n),renderState:t()}}function t4(n,t,e,s){const i={},r=s(n,{});for(const m in r)i[m]=om(r[m]);let{initial:o,animate:l}=n;const c=rg(n),h=m_(n);t&&h&&!c&&n.inherit!==!1&&(o===void 0&&(o=t.initial),l===void 0&&(l=t.animate));let d=e?e.initial===!1:!1;d=d||o===!1;const p=d?l:o;if(p&&typeof p!="boolean"&&!ig(p)){const m=Array.isArray(p)?p:[p];for(let y=0;y<m.length;y++){const b=Uw(n,m[y]);if(b){const{transitionEnd:x,transition:w,...S}=b;for(const T in S){let k=S[T];if(Array.isArray(k)){const $=d?k.length-1:0;k=k[$]}k!==null&&(i[T]=k)}for(const T in x)i[T]=x[T]}}}return i}const w_=n=>(t,e)=>{const s=St.useContext(sg),i=St.useContext(ng),r=()=>QU(n,t,s,i);return e?r():pw(r)};function jw(n,t,e){const{style:s}=n,i={};for(const r in s)(ns(s[r])||t.style&&ns(t.style[r])||g_(r,n)||e?.getValue(r)?.liveStyle!==void 0)&&(i[r]=s[r]);return i}const e4=w_({scrapeMotionValuesFromProps:jw,createRenderState:Bw});function S_(n,t,e){const s=jw(n,t,e);for(const i in n)if(ns(n[i])||ns(t[i])){const r=Gc.indexOf(i)!==-1?"attr"+i.charAt(0).toUpperCase()+i.substring(1):i;s[r]=n[i]}return s}const n4=w_({scrapeMotionValuesFromProps:S_,createRenderState:x_}),s4=Symbol.for("motionComponentSymbol");function bc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function i4(n,t,e){return St.useCallback(s=>{s&&n.onMount&&n.onMount(s),t&&(s?t.mount(s):t.unmount()),e&&(typeof e=="function"?e(s):bc(e)&&(e.current=s))},[t])}const Gw=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),r4="framerAppearId",C_="data-"+Gw(r4),T_=St.createContext({});function o4(n,t,e,s,i){const{visualElement:r}=St.useContext(sg),o=St.useContext(f_),l=St.useContext(ng),c=St.useContext(Fw).reducedMotion,h=St.useRef(null);s=s||o.renderer,!h.current&&s&&(h.current=s(n,{visualState:t,parent:r,props:e,presenceContext:l,blockInitialAnimation:l?l.initial===!1:!1,reducedMotionConfig:c}));const d=h.current,p=St.useContext(T_);d&&!d.projection&&i&&(d.type==="html"||d.type==="svg")&&a4(h.current,e,i,p);const m=St.useRef(!1);St.useInsertionEffect(()=>{d&&m.current&&d.update(e,l)});const y=e[C_],b=St.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return vA(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),St.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function a4(n,t,e,s){const{layoutId:i,layout:r,drag:o,dragConstraints:l,layoutScroll:c,layoutRoot:h,layoutCrossfade:d}=t;n.projection=new e(n.latestValues,t["data-framer-portal-id"]?void 0:k_(n.parent)),n.projection.setOptions({layoutId:i,layout:r,alwaysMeasureLayout:!!o||l&&bc(l),visualElement:n,animationType:typeof r=="string"?r:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:c,layoutRoot:h})}function k_(n){if(n)return n.options.allowProjection!==!1?n.projection:k_(n.parent)}function lx(n,{forwardMotionProps:t=!1}={},e,s){e&&OU(e);const i=Vw(n)?n4:e4;function r(l,c){let h;const d={...St.useContext(Fw),...l,layoutId:l4(l)},{isStatic:p}=d,m=PU(l),y=i(l,p);if(!p&&mw){c4();const b=u4(d);h=b.MeasureLayout,m.visualElement=o4(n,y,d,s,b.ProjectionNode)}return bt.jsxs(sg.Provider,{value:m,children:[h&&m.visualElement?bt.jsx(h,{visualElement:m.visualElement,...d}):null,ZU(n,l,i4(y,m.visualElement,c),y,p,t)]})}r.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const o=St.forwardRef(r);return o[s4]=n,o}function l4({layoutId:n}){const t=St.useContext(fw).id;return t&&n!==void 0?t+"-"+n:n}function c4(n,t){St.useContext(f_).strict}function u4(n){const{drag:t,layout:e}=_c;if(!t&&!e)return{};const s={...t,...e};return{MeasureLayout:t?.isEnabled(n)||e?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function h4(n,t){if(typeof Proxy>"u")return lx;const e=new Map,s=(r,o)=>lx(r,o,n,t),i=(r,o)=>s(r,o);return new Proxy(i,{get:(r,o)=>o==="create"?s:(e.has(o)||e.set(o,lx(o,void 0,n,t)),e.get(o))})}function $_({top:n,left:t,right:e,bottom:s}){return{x:{min:t,max:e},y:{min:n,max:s}}}function d4({x:n,y:t}){return{top:t.min,right:n.max,bottom:t.max,left:n.min}}function f4(n,t){if(!t)return n;const e=t({x:n.left,y:n.top}),s=t({x:n.right,y:n.bottom});return{top:e.y,left:e.x,bottom:s.y,right:s.x}}function cx(n){return n===void 0||n===1}function cv({scale:n,scaleX:t,scaleY:e}){return!cx(n)||!cx(t)||!cx(e)}function Ta(n){return cv(n)||E_(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function E_(n){return fE(n.x)||fE(n.y)}function fE(n){return n&&n!=="0%"}function wm(n,t,e){const s=n-e,i=t*s;return e+i}function pE(n,t,e,s,i){return i!==void 0&&(n=wm(n,i,s)),wm(n,e,s)+t}function uv(n,t=0,e=1,s,i){n.min=pE(n.min,t,e,s,i),n.max=pE(n.max,t,e,s,i)}function I_(n,{x:t,y:e}){uv(n.x,t.translate,t.scale,t.originPoint),uv(n.y,e.translate,e.scale,e.originPoint)}const mE=.999999999999,gE=1.0000000000001;function p4(n,t,e,s=!1){const i=e.length;if(!i)return;t.x=t.y=1;let r,o;for(let l=0;l<i;l++){r=e[l],o=r.projectionDelta;const{visualElement:c}=r.options;c&&c.props.style&&c.props.style.display==="contents"||(s&&r.options.layoutScroll&&r.scroll&&r!==r.root&&vc(n,{x:-r.scroll.offset.x,y:-r.scroll.offset.y}),o&&(t.x*=o.x.scale,t.y*=o.y.scale,I_(n,o)),s&&Ta(r.latestValues)&&vc(n,r.latestValues))}t.x<gE&&t.x>mE&&(t.x=1),t.y<gE&&t.y>mE&&(t.y=1)}function xc(n,t){n.min=n.min+t,n.max=n.max+t}function yE(n,t,e,s,i=.5){const r=qe(n.min,n.max,i);uv(n,t,e,r,s)}function vc(n,t){yE(n.x,t.x,t.scaleX,t.scale,t.originX),yE(n.y,t.y,t.scaleY,t.scale,t.originY)}function N_(n,t){return $_(f4(n.getBoundingClientRect(),t))}function m4(n,t,e){const s=N_(n,e),{scroll:i}=t;return i&&(xc(s.x,i.offset.x),xc(s.y,i.offset.y)),s}const bE=()=>({translate:0,scale:1,origin:0,originPoint:0}),wc=()=>({x:bE(),y:bE()}),xE=()=>({min:0,max:0}),kn=()=>({x:xE(),y:xE()}),hv={current:null},A_={current:!1};function g4(){if(A_.current=!0,!!mw)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),t=()=>hv.current=n.matches;n.addEventListener("change",t),t()}else hv.current=!1}const y4=new WeakMap;function b4(n,t,e){for(const s in t){const i=t[s],r=e[s];if(ns(i))n.addValue(s,i);else if(ns(r))n.addValue(s,Ac(i,{owner:n}));else if(r!==i)if(n.hasValue(s)){const o=n.getValue(s);o.liveStyle===!0?o.jump(i):o.hasAnimated||o.set(i)}else{const o=n.getStaticValue(s);n.addValue(s,Ac(o!==void 0?o:i,{owner:n}))}}for(const s in e)t[s]===void 0&&n.removeValue(s);return t}const vE=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class x4{scrapeMotionValuesFromProps(t,e,s){return{}}constructor({parent:t,props:e,presenceContext:s,reducedMotionConfig:i,blockInitialAnimation:r,visualState:o},l={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=_w,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Es.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,je.render(this.render,!1,!0))};const{latestValues:c,renderState:h}=o;this.latestValues=c,this.baseTarget={...c},this.initialValues=e.initial?{...c}:{},this.renderState=h,this.parent=t,this.props=e,this.presenceContext=s,this.depth=t?t.depth+1:0,this.reducedMotionConfig=i,this.options=l,this.blockInitialAnimation=!!r,this.isControllingVariants=rg(e),this.isVariantNode=m_(e),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(t&&t.current);const{willChange:d,...p}=this.scrapeMotionValuesFromProps(e,{},this);for(const m in p){const y=p[m];c[m]!==void 0&&ns(y)&&y.set(c[m])}}mount(t){this.current=t,y4.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((e,s)=>this.bindToMotionValue(s,e)),A_.current||g4(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:hv.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),Oo(this.notifyUpdate),Oo(this.render),this.valueSubscriptions.forEach(t=>t()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const t in this.events)this.events[t].clear();for(const t in this.features){const e=this.features[t];e&&(e.unmount(),e.isMounted=!1)}this.current=null}addChild(t){this.children.add(t),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(t)}removeChild(t){this.children.delete(t),this.enteringChildren&&this.enteringChildren.delete(t)}bindToMotionValue(t,e){this.valueSubscriptions.has(t)&&this.valueSubscriptions.get(t)();const s=Wc.has(t);s&&this.onBindTransform&&this.onBindTransform();const i=e.on("change",o=>{this.latestValues[t]=o,this.props.onUpdate&&je.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let r;window.MotionCheckAppearSync&&(r=window.MotionCheckAppearSync(this,t,e)),this.valueSubscriptions.set(t,()=>{i(),r&&r(),e.owner&&e.stop()})}sortNodePosition(t){return!this.current||!this.sortInstanceNodePosition||this.type!==t.type?0:this.sortInstanceNodePosition(this.current,t.current)}updateFeatures(){let t="animation";for(t in _c){const e=_c[t];if(!e)continue;const{isEnabled:s,Feature:i}=e;if(!this.features[t]&&i&&s(this.props)&&(this.features[t]=new i(this)),this.features[t]){const r=this.features[t];r.isMounted?r.update():(r.mount(),r.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):kn()}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,e){this.latestValues[t]=e}update(t,e){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;for(let s=0;s<vE.length;s++){const i=vE[s];this.propEventSubscriptions[i]&&(this.propEventSubscriptions[i](),delete this.propEventSubscriptions[i]);const r="on"+i,o=t[r];o&&(this.propEventSubscriptions[i]=this.on(i,o))}this.prevMotionValues=b4(this,this.scrapeMotionValuesFromProps(t,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(t){const e=this.getClosestVariantNode();if(e)return e.variantChildren&&e.variantChildren.add(t),()=>e.variantChildren.delete(t)}addValue(t,e){const s=this.values.get(t);e!==s&&(s&&this.removeValue(t),this.bindToMotionValue(t,e),this.values.set(t,e),this.latestValues[t]=e.get())}removeValue(t){this.values.delete(t);const e=this.valueSubscriptions.get(t);e&&(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,e){if(this.props.values&&this.props.values[t])return this.props.values[t];let s=this.values.get(t);return s===void 0&&e!==void 0&&(s=Ac(e===null?void 0:e,{owner:this}),this.addValue(t,s)),s}readValue(t,e){let s=this.latestValues[t]!==void 0||!this.current?this.latestValues[t]:this.getBaseTargetFromProps(this.props,t)??this.readValueFromInstance(this.current,t,this.options);return s!=null&&(typeof s=="string"&&(wA(s)||CA(s))?s=parseFloat(s):!$U(s)&&Mo.test(e)&&(s=r_(t,e)),this.setBaseTarget(t,ns(s)?s.get():s)),ns(s)?s.get():s}setBaseTarget(t,e){this.baseTarget[t]=e}getBaseTarget(t){const{initial:e}=this.props;let s;if(typeof e=="string"||typeof e=="object"){const r=Uw(this.props,e,this.presenceContext?.custom);r&&(s=r[t])}if(e&&s!==void 0)return s;const i=this.getBaseTargetFromProps(this.props,t);return i!==void 0&&!ns(i)?i:this.initialValues[t]!==void 0&&s===void 0?void 0:this.baseTarget[t]}on(t,e){return this.events[t]||(this.events[t]=new vw),this.events[t].add(e)}notify(t,...e){this.events[t]&&this.events[t].notify(...e)}scheduleRenderMicrotask(){Ow.render(this.render)}}class __ extends x4{constructor(){super(...arguments),this.KeyframeResolver=pU}sortInstanceNodePosition(t,e){return t.compareDocumentPosition(e)&2?1:-1}getBaseTargetFromProps(t,e){return t.style?t.style[e]:void 0}removeValueFromRenderState(t,{vars:e,style:s}){delete e[t],delete s[t]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;ns(t)&&(this.childSubscription=t.on("change",e=>{this.current&&(this.current.textContent=`${e}`)}))}}function R_(n,{style:t,vars:e},s,i){const r=n.style;let o;for(o in t)r[o]=t[o];i?.applyProjectionStyles(r,s);for(o in e)r.setProperty(o,e[o])}function v4(n){return window.getComputedStyle(n)}class w4 extends __{constructor(){super(...arguments),this.type="html",this.renderInstance=R_}readValueFromInstance(t,e){if(Wc.has(e))return this.projection?.isProjecting?ev(e):DV(t,e);{const s=v4(t),i=(LA(e)?s.getPropertyValue(e):s[e])||0;return typeof i=="string"?i.trim():i}}measureInstanceViewportBox(t,{transformPagePoint:e}){return N_(t,e)}build(t,e,s){Pw(t,e,s.transformTemplate)}scrapeMotionValuesFromProps(t,e,s){return jw(t,e,s)}}const D_=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function S4(n,t,e,s){R_(n,t,void 0,s);for(const i in t.attrs)n.setAttribute(D_.has(i)?i:Gw(i),t.attrs[i])}class C4 extends __{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=kn}getBaseTargetFromProps(t,e){return t[e]}readValueFromInstance(t,e){if(Wc.has(e)){const s=i_(e);return s&&s.default||0}return e=D_.has(e)?e:Gw(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,s){return S_(t,e,s)}build(t,e,s){b_(t,e,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(t,e,s,i){S4(t,e,s,i)}mount(t){this.isSVGTag=v_(t.tagName),super.mount(t)}}const T4=(n,t)=>Vw(n)?new C4(t):new w4(t,{allowProjection:n!==St.Fragment});function Cc(n,t,e){const s=n.getProps();return Uw(s,t,e!==void 0?e:s.custom,n)}const dv=n=>Array.isArray(n);function k4(n,t,e){n.hasValue(t)?n.getValue(t).set(e):n.addValue(t,Ac(e))}function $4(n){return dv(n)?n[n.length-1]||0:n}function E4(n,t){const e=Cc(n,t);let{transitionEnd:s={},transition:i={},...r}=e||{};r={...r,...s};for(const o in r){const l=$4(r[o]);k4(n,o,l)}}function I4(n){return!!(ns(n)&&n.add)}function fv(n,t){const e=n.getValue("willChange");if(I4(e))return e.add(t);if(!e&&Ur.WillChange){const s=new Ur.WillChange("auto");n.addValue("willChange",s),s.add(t)}}function O_(n){return n.props[C_]}const N4=n=>n!==null;function A4(n,{repeat:t,repeatType:e="loop"},s){const i=n.filter(N4),r=t&&e!=="loop"&&t%2===1?0:i.length-1;return i[r]}const _4={type:"spring",stiffness:500,damping:25,restSpeed:10},R4=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),D4={type:"keyframes",duration:.8},O4={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},M4=(n,{keyframes:t})=>t.length>2?D4:Wc.has(n)?n.startsWith("scale")?R4(t[1]):_4:O4;function F4({when:n,delay:t,delayChildren:e,staggerChildren:s,staggerDirection:i,repeat:r,repeatType:o,repeatDelay:l,from:c,elapsed:h,...d}){return!!Object.keys(d).length}const Ww=(n,t,e,s={},i,r)=>o=>{const l=Rw(s,n)||{},c=l.delay||s.delay||0;let{elapsed:h=0}=s;h=h-sr(c);const d={keyframes:Array.isArray(e)?e:[null,e],ease:"easeOut",velocity:t.getVelocity(),...l,delay:-h,onUpdate:m=>{t.set(m),l.onUpdate&&l.onUpdate(m)},onComplete:()=>{o(),l.onComplete&&l.onComplete()},name:n,motionValue:t,element:r?void 0:i};F4(l)||Object.assign(d,M4(n,d)),d.duration&&(d.duration=sr(d.duration)),d.repeatDelay&&(d.repeatDelay=sr(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let p=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(ov(d),d.delay===0&&(p=!0)),(Ur.instantAnimations||Ur.skipAnimations)&&(p=!0,ov(d),d.delay=0),d.allowFlatten=!l.type&&!l.ease,p&&!r&&t.get()!==void 0){const m=A4(d.keyframes,l);if(m!==void 0){je.update(()=>{d.onUpdate(m),d.onComplete()});return}}return l.isSync?new Aw(d):new nU(d)};function L4({protectedKeys:n,needsAnimating:t},e){const s=n.hasOwnProperty(e)&&t[e]!==!0;return t[e]=!1,s}function M_(n,t,{delay:e=0,transitionOverride:s,type:i}={}){let{transition:r=n.getDefaultTransition(),transitionEnd:o,...l}=t;s&&(r=s);const c=[],h=i&&n.animationState&&n.animationState.getState()[i];for(const d in l){const p=n.getValue(d,n.latestValues[d]??null),m=l[d];if(m===void 0||h&&L4(h,d))continue;const y={delay:e,...Rw(r||{},d)},b=p.get();if(b!==void 0&&!p.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const S=O_(n);if(S){const T=window.MotionHandoffAnimation(S,d,je);T!==null&&(y.startTime=T,x=!0)}}fv(n,d),p.start(Ww(d,p,m,n.shouldReduceMotion&&e_.has(d)?{type:!1}:y,n,x));const w=p.animation;w&&c.push(w)}return o&&Promise.all(c).then(()=>{je.update(()=>{o&&E4(n,o)})}),c}function F_(n,t,e,s=0,i=1){const r=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(t),o=n.size,l=(o-1)*s;return typeof e=="function"?e(r,o):i===1?r*s:l-r*s}function pv(n,t,e={}){const s=Cc(n,t,e.type==="exit"?n.presenceContext?.custom:void 0);let{transition:i=n.getDefaultTransition()||{}}=s||{};e.transitionOverride&&(i=e.transitionOverride);const r=s?()=>Promise.all(M_(n,s,e)):()=>Promise.resolve(),o=n.variantChildren&&n.variantChildren.size?(c=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:p}=i;return z4(n,t,c,h,d,p,e)}:()=>Promise.resolve(),{when:l}=i;if(l){const[c,h]=l==="beforeChildren"?[r,o]:[o,r];return c().then(()=>h())}else return Promise.all([r(),o(e.delay)])}function z4(n,t,e=0,s=0,i=0,r=1,o){const l=[];for(const c of n.variantChildren)c.notify("AnimationStart",t),l.push(pv(c,t,{...o,delay:e+(typeof s=="function"?0:s)+F_(n.variantChildren,c,s,i,r)}).then(()=>c.notify("AnimationComplete",t)));return Promise.all(l)}function P4(n,t,e={}){n.notify("AnimationStart",t);let s;if(Array.isArray(t)){const i=t.map(r=>pv(n,r,e));s=Promise.all(i)}else if(typeof t=="string")s=pv(n,t,e);else{const i=typeof t=="function"?Cc(n,t,e.custom):t;s=Promise.all(M_(n,i,e))}return s.then(()=>{n.notify("AnimationComplete",t)})}function L_(n,t){if(!Array.isArray(t))return!1;const e=t.length;if(e!==n.length)return!1;for(let s=0;s<e;s++)if(t[s]!==n[s])return!1;return!0}const B4=zw.length;function z_(n){if(!n)return;if(!n.isControllingVariants){const e=n.parent?z_(n.parent)||{}:{};return n.props.initial!==void 0&&(e.initial=n.props.initial),e}const t={};for(let e=0;e<B4;e++){const s=zw[e],i=n.props[s];(Eh(i)||i===!1)&&(t[s]=i)}return t}const V4=[...Lw].reverse(),U4=Lw.length;function j4(n){return t=>Promise.all(t.map(({animation:e,options:s})=>P4(n,e,s)))}function G4(n){let t=j4(n),e=wE(),s=!0;const i=c=>(h,d)=>{const p=Cc(n,d,c==="exit"?n.presenceContext?.custom:void 0);if(p){const{transition:m,transitionEnd:y,...b}=p;h={...h,...b,...y}}return h};function r(c){t=c(n)}function o(c){const{props:h}=n,d=z_(n.parent)||{},p=[],m=new Set;let y={},b=1/0;for(let w=0;w<U4;w++){const S=V4[w],T=e[S],k=h[S]!==void 0?h[S]:d[S],$=Eh(k),E=S===c?T.isActive:null;E===!1&&(b=w);let N=k===d[S]&&k!==h[S]&&$;if(N&&s&&n.manuallyAnimateOnMount&&(N=!1),T.protectedKeys={...y},!T.isActive&&E===null||!k&&!T.prevProp||ig(k)||typeof k=="boolean")continue;const _=W4(T.prevProp,k);let R=_||S===c&&T.isActive&&!N&&$||w>b&&$,D=!1;const M=Array.isArray(k)?k:[k];let A=M.reduce(i(S),{});E===!1&&(A={});const{prevResolvedValues:B={}}=T,H={...B,...A},J=P=>{R=!0,m.has(P)&&(D=!0,m.delete(P)),T.needsAnimating[P]=!0;const V=n.getValue(P);V&&(V.liveStyle=!1)};for(const P in H){const V=A[P],K=B[P];if(y.hasOwnProperty(P))continue;let st=!1;dv(V)&&dv(K)?st=!L_(V,K):st=V!==K,st?V!=null?J(P):m.add(P):V!==void 0&&m.has(P)?J(P):T.protectedKeys[P]=!0}T.prevProp=k,T.prevResolvedValues=A,T.isActive&&(y={...y,...A}),s&&n.blockInitialAnimation&&(R=!1);const X=N&&_;R&&(!X||D)&&p.push(...M.map(P=>{const V={type:S};if(typeof P=="string"&&s&&!X&&n.manuallyAnimateOnMount&&n.parent){const{parent:K}=n,st=Cc(K,P);if(K.enteringChildren&&st){const{delayChildren:L}=st.transition||{};V.delay=F_(K.enteringChildren,n,L)}}return{animation:P,options:V}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const S=Cc(n,Array.isArray(h.initial)?h.initial[0]:h.initial);S&&S.transition&&(w.transition=S.transition)}m.forEach(S=>{const T=n.getBaseTarget(S),k=n.getValue(S);k&&(k.liveStyle=!0),w[S]=T??null}),p.push({animation:w})}let x=!!p.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?t(p):Promise.resolve()}function l(c,h){if(e[c].isActive===h)return Promise.resolve();n.variantChildren?.forEach(p=>p.animationState?.setActive(c,h)),e[c].isActive=h;const d=o(c);for(const p in e)e[p].protectedKeys={};return d}return{animateChanges:o,setActive:l,setAnimateFunction:r,getState:()=>e,reset:()=>{e=wE()}}}function W4(n,t){return typeof t=="string"?t!==n:Array.isArray(t)?!L_(t,n):!1}function xa(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function wE(){return{animate:xa(!0),whileInView:xa(),whileHover:xa(),whileTap:xa(),whileDrag:xa(),whileFocus:xa(),exit:xa()}}class Uo{constructor(t){this.isMounted=!1,this.node=t}update(){}}class H4 extends Uo{constructor(t){super(t),t.animationState||(t.animationState=G4(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();ig(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:e}=this.node.prevProps||{};t!==e&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let q4=0;class K4 extends Uo{constructor(){super(...arguments),this.id=q4++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:e}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===s)return;const i=this.node.animationState.setActive("exit",!t);e&&!t&&i.then(()=>{e(this.id)})}mount(){const{register:t,onExitComplete:e}=this.node.presenceContext||{};e&&e(this.id),t&&(this.unmount=t(this.id))}unmount(){}}const X4={animation:{Feature:H4},exit:{Feature:K4}};function Ih(n,t,e,s={passive:!0}){return n.addEventListener(t,e,s),()=>n.removeEventListener(t,e)}function Zh(n){return{point:{x:n.pageX,y:n.pageY}}}const Y4=n=>t=>Mw(t)&&n(t,Zh(t));function yh(n,t,e,s){return Ih(n,t,Y4(e),s)}const P_=1e-4,J4=1-P_,Z4=1+P_,B_=.01,Q4=0-B_,tj=0+B_;function ds(n){return n.max-n.min}function ej(n,t,e){return Math.abs(n-t)<=e}function SE(n,t,e,s=.5){n.origin=s,n.originPoint=qe(t.min,t.max,n.origin),n.scale=ds(e)/ds(t),n.translate=qe(e.min,e.max,n.origin)-n.originPoint,(n.scale>=J4&&n.scale<=Z4||isNaN(n.scale))&&(n.scale=1),(n.translate>=Q4&&n.translate<=tj||isNaN(n.translate))&&(n.translate=0)}function bh(n,t,e,s){SE(n.x,t.x,e.x,s?s.originX:void 0),SE(n.y,t.y,e.y,s?s.originY:void 0)}function CE(n,t,e){n.min=e.min+t.min,n.max=n.min+ds(t)}function nj(n,t,e){CE(n.x,t.x,e.x),CE(n.y,t.y,e.y)}function TE(n,t,e){n.min=t.min-e.min,n.max=n.min+ds(t)}function Sm(n,t,e){TE(n.x,t.x,e.x),TE(n.y,t.y,e.y)}function ui(n){return[n("x"),n("y")]}const V_=({current:n})=>n?n.ownerDocument.defaultView:null,kE=(n,t)=>Math.abs(n-t);function sj(n,t){const e=kE(n.x,t.x),s=kE(n.y,t.y);return Math.sqrt(e**2+s**2)}class U_{constructor(t,e,{transformPagePoint:s,contextWindow:i=window,dragSnapToOrigin:r=!1,distanceThreshold:o=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=hx(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=sj(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=Wn;this.history.push({...x,timestamp:w});const{onStart:S,onMove:T}=this.handlers;y||(S&&S(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),T&&T(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=ux(y,this.transformPagePoint),je.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const S=hx(m.type==="pointercancel"?this.lastMoveEventInfo:ux(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,S),x&&x(m,S)},!Mw(t))return;this.dragSnapToOrigin=r,this.handlers=e,this.transformPagePoint=s,this.distanceThreshold=o,this.contextWindow=i||window;const l=Zh(t),c=ux(l,this.transformPagePoint),{point:h}=c,{timestamp:d}=Wn;this.history=[{...h,timestamp:d}];const{onSessionStart:p}=e;p&&p(t,hx(c,this.history)),this.removeListeners=Xh(yh(this.contextWindow,"pointermove",this.handlePointerMove),yh(this.contextWindow,"pointerup",this.handlePointerUp),yh(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(t){this.handlers=t}end(){this.removeListeners&&this.removeListeners(),Oo(this.updatePoint)}}function ux(n,t){return t?{point:t(n.point)}:n}function $E(n,t){return{x:n.x-t.x,y:n.y-t.y}}function hx({point:n},t){return{point:n,delta:$E(n,j_(t)),offset:$E(n,ij(t)),velocity:rj(t,.1)}}function ij(n){return n[0]}function j_(n){return n[n.length-1]}function rj(n,t){if(n.length<2)return{x:0,y:0};let e=n.length-1,s=null;const i=j_(n);for(;e>=0&&(s=n[e],!(i.timestamp-s.timestamp>sr(t)));)e--;if(!s)return{x:0,y:0};const r=fi(i.timestamp-s.timestamp);if(r===0)return{x:0,y:0};const o={x:(i.x-s.x)/r,y:(i.y-s.y)/r};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}function oj(n,{min:t,max:e},s){return t!==void 0&&n<t?n=s?qe(t,n,s.min):Math.max(n,t):e!==void 0&&n>e&&(n=s?qe(e,n,s.max):Math.min(n,e)),n}function EE(n,t,e){return{min:t!==void 0?n.min+t:void 0,max:e!==void 0?n.max+e-(n.max-n.min):void 0}}function aj(n,{top:t,left:e,bottom:s,right:i}){return{x:EE(n.x,e,i),y:EE(n.y,t,s)}}function IE(n,t){let e=t.min-n.min,s=t.max-n.max;return t.max-t.min<n.max-n.min&&([e,s]=[s,e]),{min:e,max:s}}function lj(n,t){return{x:IE(n.x,t.x),y:IE(n.y,t.y)}}function cj(n,t){let e=.5;const s=ds(n),i=ds(t);return i>s?e=Th(t.min,t.max-s,n.min):s>i&&(e=Th(n.min,n.max-i,t.min)),Vr(0,1,e)}function uj(n,t){const e={};return t.min!==void 0&&(e.min=t.min-n.min),t.max!==void 0&&(e.max=t.max-n.min),e}const mv=.35;function hj(n=mv){return n===!1?n=0:n===!0&&(n=mv),{x:NE(n,"left","right"),y:NE(n,"top","bottom")}}function NE(n,t,e){return{min:AE(n,t),max:AE(n,e)}}function AE(n,t){return typeof n=="number"?n:n[t]||0}const dj=new WeakMap;class fj{constructor(t){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=kn(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=t}start(t,{snapToCursor:e=!1,distanceThreshold:s}={}){const{presenceContext:i}=this.visualElement;if(i&&i.isPresent===!1)return;const r=p=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),e&&this.snapToCursor(Zh(p).point)},o=(p,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=bU(y),!this.openDragLock))return;this.latestPointerEvent=p,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),ui(S=>{let T=this.getAxisMotionValue(S).get()||0;if(ir.test(T)){const{projection:k}=this.visualElement;if(k&&k.layout){const $=k.layout.layoutBox[S];$&&(T=ds($)*(parseFloat(T)/100))}}this.originPoint[S]=T}),x&&je.postRender(()=>x(p,m)),fv(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},l=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:S}=m;if(b&&this.currentDirection===null){this.currentDirection=pj(S),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,S),this.updateAxis("y",m.point,S),this.visualElement.render(),w&&w(p,m)},c=(p,m)=>{this.latestPointerEvent=p,this.latestPanInfo=m,this.stop(p,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>ui(p=>this.getAnimationState(p)==="paused"&&this.getAxisMotionValue(p).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new U_(t,{onSessionStart:r,onStart:o,onMove:l,onSessionEnd:c,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:V_(this.visualElement)})}stop(t,e){const s=t||this.latestPointerEvent,i=e||this.latestPanInfo,r=this.isDragging;if(this.cancel(),!r||!i||!s)return;const{velocity:o}=i;this.startAnimation(o);const{onDragEnd:l}=this.getProps();l&&je.postRender(()=>l(s,i))}cancel(){this.isDragging=!1;const{projection:t,animationState:e}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),e&&e.setActive("whileDrag",!1)}updateAxis(t,e,s){const{drag:i}=this.getProps();if(!s||!Bp(t,i,this.currentDirection))return;const r=this.getAxisMotionValue(t);let o=this.originPoint[t]+s[t];this.constraints&&this.constraints[t]&&(o=oj(o,this.constraints[t],this.elastic[t])),r.set(o)}resolveConstraints(){const{dragConstraints:t,dragElastic:e}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,i=this.constraints;t&&bc(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):t&&s?this.constraints=aj(s.layoutBox,t):this.constraints=!1,this.elastic=hj(e),i!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&ui(r=>{this.constraints!==!1&&this.getAxisMotionValue(r)&&(this.constraints[r]=uj(s.layoutBox[r],this.constraints[r]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:e}=this.getProps();if(!t||!bc(t))return!1;const s=t.current,{projection:i}=this.visualElement;if(!i||!i.layout)return!1;const r=m4(s,i.root,this.visualElement.getTransformPagePoint());let o=lj(i.layout.layoutBox,r);if(e){const l=e(d4(o));this.hasMutatedConstraints=!!l,l&&(o=$_(l))}return o}startAnimation(t){const{drag:e,dragMomentum:s,dragElastic:i,dragTransition:r,dragSnapToOrigin:o,onDragTransitionEnd:l}=this.getProps(),c=this.constraints||{},h=ui(d=>{if(!Bp(d,e,this.currentDirection))return;let p=c&&c[d]||{};o&&(p={min:0,max:0});const m=i?200:1e6,y=i?40:1e7,b={type:"inertia",velocity:s?t[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...r,...p};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(l)}startAxisValueAnimation(t,e){const s=this.getAxisMotionValue(t);return fv(this.visualElement,t),s.start(Ww(t,s,0,e,this.visualElement,!1))}stopAnimation(){ui(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){ui(t=>this.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){return this.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){const e=`_drag${t.toUpperCase()}`,s=this.visualElement.getProps(),i=s[e];return i||this.visualElement.getValue(t,(s.initial?s.initial[t]:void 0)||0)}snapToCursor(t){ui(e=>{const{drag:s}=this.getProps();if(!Bp(e,s,this.currentDirection))return;const{projection:i}=this.visualElement,r=this.getAxisMotionValue(e);if(i&&i.layout){const{min:o,max:l}=i.layout.layoutBox[e];r.set(t[e]-qe(o,l,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:e}=this.getProps(),{projection:s}=this.visualElement;if(!bc(e)||!s||!this.constraints)return;this.stopAnimation();const i={x:0,y:0};ui(o=>{const l=this.getAxisMotionValue(o);if(l&&this.constraints!==!1){const c=l.get();i[o]=cj({min:c,max:c},this.constraints[o])}});const{transformTemplate:r}=this.visualElement.getProps();this.visualElement.current.style.transform=r?r({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),ui(o=>{if(!Bp(o,t,null))return;const l=this.getAxisMotionValue(o),{min:c,max:h}=this.constraints[o];l.set(qe(c,h,i[o]))})}addListeners(){if(!this.visualElement.current)return;dj.set(this.visualElement,this);const t=this.visualElement.current,e=yh(t,"pointerdown",c=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(c)}),s=()=>{const{dragConstraints:c}=this.getProps();bc(c)&&c.current&&(this.constraints=this.resolveRefConstraints())},{projection:i}=this.visualElement,r=i.addEventListener("measure",s);i&&!i.layout&&(i.root&&i.root.updateScroll(),i.updateLayout()),je.read(s);const o=Ih(window,"resize",()=>this.scalePositionWithinConstraints()),l=i.addEventListener("didUpdate",(({delta:c,hasLayoutChanged:h})=>{this.isDragging&&h&&(ui(d=>{const p=this.getAxisMotionValue(d);p&&(this.originPoint[d]+=c[d].translate,p.set(p.get()+c[d].translate))}),this.visualElement.render())}));return()=>{o(),e(),r(),l&&l()}}getProps(){const t=this.visualElement.getProps(),{drag:e=!1,dragDirectionLock:s=!1,dragPropagation:i=!1,dragConstraints:r=!1,dragElastic:o=mv,dragMomentum:l=!0}=t;return{...t,drag:e,dragDirectionLock:s,dragPropagation:i,dragConstraints:r,dragElastic:o,dragMomentum:l}}}function Bp(n,t,e){return(t===!0||t===n)&&(e===null||e===n)}function pj(n,t=10){let e=null;return Math.abs(n.y)>t?e="y":Math.abs(n.x)>t&&(e="x"),e}class mj extends Uo{constructor(t){super(t),this.removeGroupControls=gi,this.removeListeners=gi,this.controls=new fj(t)}mount(){const{dragControls:t}=this.node.getProps();t&&(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||gi}unmount(){this.removeGroupControls(),this.removeListeners()}}const _E=n=>(t,e)=>{n&&je.postRender(()=>n(t,e))};class gj extends Uo{constructor(){super(...arguments),this.removePointerDownListener=gi}onPointerDown(t){this.session=new U_(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:V_(this.node)})}createPanHandlers(){const{onPanSessionStart:t,onPanStart:e,onPan:s,onPanEnd:i}=this.node.getProps();return{onSessionStart:_E(t),onStart:_E(e),onMove:s,onEnd:(r,o)=>{delete this.session,i&&je.postRender(()=>i(r,o))}}}mount(){this.removePointerDownListener=yh(this.node.current,"pointerdown",t=>this.onPointerDown(t))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const am={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let dx=!1;class yj extends St.Component{componentDidMount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:s,layoutId:i}=this.props,{projection:r}=t;r&&(e.group&&e.group.add(r),s&&s.register&&i&&s.register(r),dx&&r.root.didUpdate(),r.addEventListener("animationComplete",()=>{this.safeToRemove()}),r.setOptions({...r.options,onExitComplete:()=>this.safeToRemove()})),am.hasEverUpdated=!0}getSnapshotBeforeUpdate(t){const{layoutDependency:e,visualElement:s,drag:i,isPresent:r}=this.props,{projection:o}=s;return o&&(o.isPresent=r,dx=!0,i||t.layoutDependency!==e||e===void 0||t.isPresent!==r?o.willUpdate():this.safeToRemove(),t.isPresent!==r&&(r?o.promote():o.relegate()||je.postRender(()=>{const l=o.getStack();(!l||!l.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:t}=this.props.visualElement;t&&(t.root.didUpdate(),Ow.postRender(()=>{!t.currentAnimation&&t.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:s}=this.props,{projection:i}=t;dx=!0,i&&(i.scheduleCheckAfterUnmount(),e&&e.group&&e.group.remove(i),s&&s.deregister&&s.deregister(i))}safeToRemove(){const{safeToRemove:t}=this.props;t&&t()}render(){return null}}function G_(n){const[t,e]=d_(),s=St.useContext(fw);return bt.jsx(yj,{...n,layoutGroup:s,switchLayoutGroup:St.useContext(T_),isPresent:t,safeToRemove:e})}function bj(n,t,e){const s=ns(n)?n:Ac(n);return s.start(Ww("",s,t,e)),s.animation}const xj=(n,t)=>n.depth-t.depth;class vj{constructor(){this.children=[],this.isDirty=!1}add(t){gw(this.children,t),this.isDirty=!0}remove(t){yw(this.children,t),this.isDirty=!0}forEach(t){this.isDirty&&this.children.sort(xj),this.isDirty=!1,this.children.forEach(t)}}function wj(n,t){const e=Es.now(),s=({timestamp:i})=>{const r=i-e;r>=t&&(Oo(s),n(r-t))};return je.setup(s,!0),()=>Oo(s)}const W_=["TopLeft","TopRight","BottomLeft","BottomRight"],Sj=W_.length,RE=n=>typeof n=="string"?parseFloat(n):n,DE=n=>typeof n=="number"||Gt.test(n);function Cj(n,t,e,s,i,r){i?(n.opacity=qe(0,e.opacity??1,Tj(s)),n.opacityExit=qe(t.opacity??1,0,kj(s))):r&&(n.opacity=qe(t.opacity??1,e.opacity??1,s));for(let o=0;o<Sj;o++){const l=`border${W_[o]}Radius`;let c=OE(t,l),h=OE(e,l);if(c===void 0&&h===void 0)continue;c||(c=0),h||(h=0),c===0||h===0||DE(c)===DE(h)?(n[l]=Math.max(qe(RE(c),RE(h),s),0),(ir.test(h)||ir.test(c))&&(n[l]+="%")):n[l]=h}(t.rotate||e.rotate)&&(n.rotate=qe(t.rotate||0,e.rotate||0,s))}function OE(n,t){return n[t]!==void 0?n[t]:n.borderRadius}const Tj=H_(0,.5,_A),kj=H_(.5,.95,gi);function H_(n,t,e){return s=>s<n?0:s>t?1:e(Th(n,t,s))}function ME(n,t){n.min=t.min,n.max=t.max}function Ii(n,t){ME(n.x,t.x),ME(n.y,t.y)}function FE(n,t){n.translate=t.translate,n.scale=t.scale,n.originPoint=t.originPoint,n.origin=t.origin}function LE(n,t,e,s,i){return n-=t,n=wm(n,1/e,s),i!==void 0&&(n=wm(n,1/i,s)),n}function $j(n,t=0,e=1,s=.5,i,r=n,o=n){if(ir.test(t)&&(t=parseFloat(t),t=qe(o.min,o.max,t/100)-o.min),typeof t!="number")return;let l=qe(r.min,r.max,s);n===r&&(l-=t),n.min=LE(n.min,t,e,l,i),n.max=LE(n.max,t,e,l,i)}function zE(n,t,[e,s,i],r,o){$j(n,t[e],t[s],t[i],t.scale,r,o)}const Ej=["x","scaleX","originX"],Ij=["y","scaleY","originY"];function PE(n,t,e,s){zE(n.x,t,Ej,e?e.x:void 0,s?s.x:void 0),zE(n.y,t,Ij,e?e.y:void 0,s?s.y:void 0)}function BE(n){return n.translate===0&&n.scale===1}function q_(n){return BE(n.x)&&BE(n.y)}function VE(n,t){return n.min===t.min&&n.max===t.max}function Nj(n,t){return VE(n.x,t.x)&&VE(n.y,t.y)}function UE(n,t){return Math.round(n.min)===Math.round(t.min)&&Math.round(n.max)===Math.round(t.max)}function K_(n,t){return UE(n.x,t.x)&&UE(n.y,t.y)}function jE(n){return ds(n.x)/ds(n.y)}function GE(n,t){return n.translate===t.translate&&n.scale===t.scale&&n.originPoint===t.originPoint}class Aj{constructor(){this.members=[]}add(t){gw(this.members,t),t.scheduleRender()}remove(t){if(yw(this.members,t),t===this.prevLead&&(this.prevLead=void 0),t===this.lead){const e=this.members[this.members.length-1];e&&this.promote(e)}}relegate(t){const e=this.members.findIndex(i=>t===i);if(e===0)return!1;let s;for(let i=e;i>=0;i--){const r=this.members[i];if(r.isPresent!==!1){s=r;break}}return s?(this.promote(s),!0):!1}promote(t,e){const s=this.lead;if(t!==s&&(this.prevLead=s,this.lead=t,t.show(),s)){s.instance&&s.scheduleRender(),t.scheduleRender(),t.resumeFrom=s,e&&(t.resumeFrom.preserveOpacity=!0),s.snapshot&&(t.snapshot=s.snapshot,t.snapshot.latestValues=s.animationValues||s.latestValues),t.root&&t.root.isUpdating&&(t.isLayoutDirty=!0);const{crossfade:i}=t.options;i===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(t=>{const{options:e,resumingFrom:s}=t;e.onExitComplete&&e.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(t=>{t.instance&&t.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function _j(n,t,e){let s="";const i=n.x.translate/t.x,r=n.y.translate/t.y,o=e?.z||0;if((i||r||o)&&(s=`translate3d(${i}px, ${r}px, ${o}px) `),(t.x!==1||t.y!==1)&&(s+=`scale(${1/t.x}, ${1/t.y}) `),e){const{transformPerspective:h,rotate:d,rotateX:p,rotateY:m,skewX:y,skewY:b}=e;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),p&&(s+=`rotateX(${p}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const l=n.x.scale*t.x,c=n.y.scale*t.y;return(l!==1||c!==1)&&(s+=`scale(${l}, ${c})`),s||"none"}const fx=["","X","Y","Z"],Rj=1e3;let Dj=0;function px(n,t,e,s){const{latestValues:i}=t;i[n]&&(e[n]=i[n],t.setStaticValue(n,0),s&&(s[n]=0))}function X_(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:t}=n.options;if(!t)return;const e=O_(t);if(window.MotionHasOptimisedAnimation(e,"transform")){const{layout:i,layoutId:r}=n.options;window.MotionCancelOptimisedAnimation(e,"transform",je,!(i||r))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&X_(s)}function Y_({attachResizeListener:n,defaultParent:t,measureScroll:e,checkIsScrollRoot:s,resetTransform:i}){return class{constructor(o={},l=t?.()){this.id=Dj++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(Fj),this.nodes.forEach(Bj),this.nodes.forEach(Vj),this.nodes.forEach(Lj)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=l?l.root||l:this,this.path=l?[...l.path,l]:[],this.parent=l,this.depth=l?l.depth+1:0;for(let c=0;c<this.path.length;c++)this.path[c].shouldResetTransform=!0;this.root===this&&(this.nodes=new vj)}addEventListener(o,l){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new vw),this.eventHandlers.get(o).add(l)}notifyListeners(o,...l){const c=this.eventHandlers.get(o);c&&c.notify(...l)}hasListeners(o){return this.eventHandlers.has(o)}mount(o){if(this.instance)return;this.isSVG=h_(o)&&!TU(o),this.instance=o;const{layoutId:l,layout:c,visualElement:h}=this.options;if(h&&!h.current&&h.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(c||l)&&(this.isLayoutDirty=!0),n){let d,p=0;const m=()=>this.root.updateBlockedByResize=!1;je.read(()=>{p=window.innerWidth}),n(o,()=>{const y=window.innerWidth;y!==p&&(p=y,this.root.updateBlockedByResize=!0,d&&d(),d=wj(m,250),am.hasAnimatedSinceResize&&(am.hasAnimatedSinceResize=!1,this.nodes.forEach(qE)))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&h&&(l||c)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:p,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||Hj,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),S=!this.targetLayout||!K_(this.targetLayout,y),T=!p&&m;if(this.options.layoutRoot||this.resumeFrom||T||p&&(S||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const k={...Rw(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(k.delay=0,k.type=!1),this.startAnimation(k),this.setAnimationOrigin(d,T)}else p||qE(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),Oo(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(Uj),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&X_(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const p=this.path[d];p.shouldResetTransform=!0,p.updateScroll("snapshot"),p.options.layoutRoot&&p.willUpdate(!1)}const{layoutId:l,layout:c}=this.options;if(l===void 0&&!c)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(WE);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(HE);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(Pj),this.nodes.forEach(Oj),this.nodes.forEach(Mj)):this.nodes.forEach(HE),this.clearAllSnapshots();const l=Es.now();Wn.delta=Vr(0,1e3/60,l-Wn.timestamp),Wn.timestamp=l,Wn.isProcessing=!0,nx.update.process(Wn),nx.preRender.process(Wn),nx.render.process(Wn),Wn.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,Ow.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(zj),this.sharedNodes.forEach(jj)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,je.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){je.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!ds(this.snapshot.measuredBox.x)&&!ds(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let c=0;c<this.path.length;c++)this.path[c].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=kn(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:l}=this.options;l&&l.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let l=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(l=!1),l&&this.instance){const c=s(this.instance);this.scroll={animationId:this.root.animationId,phase:o,isRoot:c,offset:e(this.instance),wasRoot:this.scroll?this.scroll.isRoot:c}}}resetTransform(){if(!i)return;const o=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,l=this.projectionDelta&&!q_(this.projectionDelta),c=this.getTransformTemplate(),h=c?c(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;o&&this.instance&&(l||Ta(this.latestValues)||d)&&(i(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const l=this.measurePageBox();let c=this.removeElementScroll(l);return o&&(c=this.removeTransform(c)),qj(c),{animationId:this.root.animationId,measuredBox:l,layoutBox:c,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:o}=this.options;if(!o)return kn();const l=o.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(Kj))){const{scroll:h}=this.root;h&&(xc(l.x,h.offset.x),xc(l.y,h.offset.y))}return l}removeElementScroll(o){const l=kn();if(Ii(l,o),this.scroll?.wasRoot)return l;for(let c=0;c<this.path.length;c++){const h=this.path[c],{scroll:d,options:p}=h;h!==this.root&&d&&p.layoutScroll&&(d.wasRoot&&Ii(l,o),xc(l.x,d.offset.x),xc(l.y,d.offset.y))}return l}applyTransform(o,l=!1){const c=kn();Ii(c,o);for(let h=0;h<this.path.length;h++){const d=this.path[h];!l&&d.options.layoutScroll&&d.scroll&&d!==d.root&&vc(c,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),Ta(d.latestValues)&&vc(c,d.latestValues)}return Ta(this.latestValues)&&vc(c,this.latestValues),c}removeTransform(o){const l=kn();Ii(l,o);for(let c=0;c<this.path.length;c++){const h=this.path[c];if(!h.instance||!Ta(h.latestValues))continue;cv(h.latestValues)&&h.updateSnapshot();const d=kn(),p=h.measurePageBox();Ii(d,p),PE(l,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return Ta(this.latestValues)&&PE(l,this.latestValues),l}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==Wn.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const c=!!this.resumingFrom||this!==l;if(!(o||c&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:p}=this.options;if(!this.layout||!(d||p))return;this.resolvedRelativeTargetAt=Wn.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=kn(),this.targetWithTransforms=kn()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),nj(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Ii(this.target,this.layout.layoutBox),I_(this.target,this.targetDelta)):Ii(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||cv(this.parent.latestValues)||E_(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(o,l,c){this.relativeParent=o,this.linkedParentVersion=o.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=kn(),this.relativeTargetOrigin=kn(),Sm(this.relativeTargetOrigin,l,c),Ii(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const o=this.getLead(),l=!!this.resumingFrom||this!==o;let c=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(c=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(c=!1),this.resolvedRelativeTargetAt===Wn.timestamp&&(c=!1),c)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;Ii(this.layoutCorrected,this.layout.layoutBox);const p=this.treeScale.x,m=this.treeScale.y;p4(this.layoutCorrected,this.treeScale,this.path,l),o.layout&&!o.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(o.target=o.layout.layoutBox,o.targetWithTransforms=kn());const{target:y}=o;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(FE(this.prevProjectionDelta.x,this.projectionDelta.x),FE(this.prevProjectionDelta.y,this.projectionDelta.y)),bh(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==p||this.treeScale.y!==m||!GE(this.projectionDelta.x,this.prevProjectionDelta.x)||!GE(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){if(this.options.visualElement?.scheduleRender(),o){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=wc(),this.projectionDelta=wc(),this.projectionDeltaWithTransform=wc()}setAnimationOrigin(o,l=!1){const c=this.snapshot,h=c?c.latestValues:{},d={...this.latestValues},p=wc();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!l;const m=kn(),y=c?c.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),S=!w||w.members.length<=1,T=!!(x&&!S&&this.options.crossfade===!0&&!this.path.some(Wj));this.animationProgress=0;let k;this.mixTargetDelta=$=>{const E=$/1e3;KE(p.x,o.x,E),KE(p.y,o.y,E),this.setTargetDelta(p),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Sm(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),Gj(this.relativeTarget,this.relativeTargetOrigin,m,E),k&&Nj(this.relativeTarget,k)&&(this.isProjectionDirty=!1),k||(k=kn()),Ii(k,this.relativeTarget)),x&&(this.animationValues=d,Cj(d,h,this.latestValues,E,T,S)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(Oo(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=je.update(()=>{am.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Ac(0)),this.currentAnimation=bj(this.motionValue,[0,1e3],{...o,velocity:0,isSync:!0,onUpdate:l=>{this.mixTargetDelta(l),o.onUpdate&&o.onUpdate(l)},onStop:()=>{},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(Rj),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:l,target:c,layout:h,latestValues:d}=o;if(!(!l||!c||!h)){if(this!==o&&this.layout&&h&&J_(this.options.animationType,this.layout.layoutBox,h.layoutBox)){c=this.target||kn();const p=ds(this.layout.layoutBox.x);c.x.min=o.target.x.min,c.x.max=c.x.min+p;const m=ds(this.layout.layoutBox.y);c.y.min=o.target.y.min,c.y.max=c.y.min+m}Ii(l,c),vc(l,d),bh(this.projectionDeltaWithTransform,this.layoutCorrected,l,d)}}registerSharedNode(o,l){this.sharedNodes.has(o)||this.sharedNodes.set(o,new Aj),this.sharedNodes.get(o).add(l);const h=l.options.initialPromotionConfig;l.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(l):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){const{layoutId:o}=this.options;return o?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:o}=this.options;return o?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:l,preserveFollowOpacity:c}={}){const h=this.getStack();h&&h.promote(this,c),o&&(this.projectionDelta=void 0,this.needsReset=!0),l&&this.setOptions({transition:l})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetSkewAndRotation(){const{visualElement:o}=this.options;if(!o)return;let l=!1;const{latestValues:c}=o;if((c.z||c.rotate||c.rotateX||c.rotateY||c.rotateZ||c.skewX||c.skewY)&&(l=!0),!l)return;const h={};c.z&&px("z",o,h,this.animationValues);for(let d=0;d<fx.length;d++)px(`rotate${fx[d]}`,o,h,this.animationValues),px(`skew${fx[d]}`,o,h,this.animationValues);o.render();for(const d in h)o.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);o.scheduleRender()}applyProjectionStyles(o,l){if(!this.instance||this.isSVG)return;if(!this.isVisible){o.visibility="hidden";return}const c=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,o.visibility="",o.opacity="",o.pointerEvents=om(l?.pointerEvents)||"",o.transform=c?c(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(o.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,o.pointerEvents=om(l?.pointerEvents)||""),this.hasProjected&&!Ta(this.latestValues)&&(o.transform=c?c({},""):"none",this.hasProjected=!1);return}o.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let p=_j(this.projectionDeltaWithTransform,this.treeScale,d);c&&(p=c(d,p)),o.transform=p;const{x:m,y}=this.projectionDelta;o.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?o.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:o.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in lv){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:S}=lv[b],T=p==="none"?d[b]:x(d[b],h);if(w){const k=w.length;for(let $=0;$<k;$++)o[w[$]]=T}else S?this.options.visualElement.renderState.vars[b]=T:o[b]=T}this.options.layoutId&&(o.pointerEvents=h===this?om(l?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>o.currentAnimation?.stop()),this.root.nodes.forEach(WE),this.root.sharedNodes.clear()}}}function Oj(n){n.updateLayout()}function Mj(n){const t=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&t&&n.hasListeners("didUpdate")){const{layoutBox:e,measuredBox:s}=n.layout,{animationType:i}=n.options,r=t.source!==n.layout.source;i==="size"?ui(d=>{const p=r?t.measuredBox[d]:t.layoutBox[d],m=ds(p);p.min=e[d].min,p.max=p.min+m}):J_(i,t.layoutBox,e)&&ui(d=>{const p=r?t.measuredBox[d]:t.layoutBox[d],m=ds(e[d]);p.max=p.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const o=wc();bh(o,e,t.layoutBox);const l=wc();r?bh(l,n.applyTransform(s,!0),t.measuredBox):bh(l,e,t.layoutBox);const c=!q_(o);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:p,layout:m}=d;if(p&&m){const y=kn();Sm(y,t.layoutBox,p.layoutBox);const b=kn();Sm(b,e,m.layoutBox),K_(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:e,snapshot:t,delta:l,layoutDelta:o,hasLayoutChanged:c,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:e}=n.options;e&&e()}n.options.transition=void 0}function Fj(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Lj(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function zj(n){n.clearSnapshot()}function WE(n){n.clearMeasurements()}function HE(n){n.isLayoutDirty=!1}function Pj(n){const{visualElement:t}=n.options;t&&t.getProps().onBeforeLayoutMeasure&&t.notify("BeforeLayoutMeasure"),n.resetTransform()}function qE(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function Bj(n){n.resolveTargetDelta()}function Vj(n){n.calcProjection()}function Uj(n){n.resetSkewAndRotation()}function jj(n){n.removeLeadSnapshot()}function KE(n,t,e){n.translate=qe(t.translate,0,e),n.scale=qe(t.scale,1,e),n.origin=t.origin,n.originPoint=t.originPoint}function XE(n,t,e,s){n.min=qe(t.min,e.min,s),n.max=qe(t.max,e.max,s)}function Gj(n,t,e,s){XE(n.x,t.x,e.x,s),XE(n.y,t.y,e.y,s)}function Wj(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const Hj={duration:.45,ease:[.4,0,.1,1]},YE=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),JE=YE("applewebkit/")&&!YE("chrome/")?Math.round:gi;function ZE(n){n.min=JE(n.min),n.max=JE(n.max)}function qj(n){ZE(n.x),ZE(n.y)}function J_(n,t,e){return n==="position"||n==="preserve-aspect"&&!ej(jE(t),jE(e),.2)}function Kj(n){return n!==n.root&&n.scroll?.wasRoot}const Xj=Y_({attachResizeListener:(n,t)=>Ih(n,"resize",t),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),mx={current:void 0},Z_=Y_({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!mx.current){const n=new Xj({});n.mount(window),n.setOptions({layoutScroll:!0}),mx.current=n}return mx.current},resetTransform:(n,t)=>{n.style.transform=t!==void 0?t:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),Yj={pan:{Feature:gj},drag:{Feature:mj,ProjectionNode:Z_,MeasureLayout:G_}};function QE(n,t,e){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",e==="Start");const i="onHover"+e,r=s[i];r&&je.postRender(()=>r(t,Zh(t)))}class Jj extends Uo{mount(){const{current:t}=this.node;t&&(this.unmount=xU(t,(e,s)=>(QE(this.node,s,"Start"),i=>QE(this.node,i,"End"))))}unmount(){}}class Zj extends Uo{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch{t=!0}!t||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=Xh(Ih(this.node.current,"focus",()=>this.onFocus()),Ih(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function tI(n,t,e){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",e==="Start");const i="onTap"+(e==="End"?"":e),r=s[i];r&&je.postRender(()=>r(t,Zh(t)))}class Qj extends Uo{mount(){const{current:t}=this.node;t&&(this.unmount=CU(t,(e,s)=>(tI(this.node,s,"Start"),(i,{success:r})=>tI(this.node,i,r?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const gv=new WeakMap,gx=new WeakMap,tG=n=>{const t=gv.get(n.target);t&&t(n)},eG=n=>{n.forEach(tG)};function nG({root:n,...t}){const e=n||document;gx.has(e)||gx.set(e,{});const s=gx.get(e),i=JSON.stringify(t);return s[i]||(s[i]=new IntersectionObserver(eG,{root:n,...t})),s[i]}function sG(n,t,e){const s=nG(t);return gv.set(n,e),s.observe(n),()=>{gv.delete(n),s.unobserve(n)}}const iG={some:0,all:1};class rG extends Uo{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:e,margin:s,amount:i="some",once:r}=t,o={root:e?e.current:void 0,rootMargin:s,threshold:typeof i=="number"?i:iG[i]},l=c=>{const{isIntersecting:h}=c;if(this.isInView===h||(this.isInView=h,r&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:p}=this.node.getProps(),m=h?d:p;m&&m(c)};return sG(this.node.current,o,l)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:t,prevProps:e}=this.node;["amount","margin","root"].some(oG(t,e))&&this.startObserver()}unmount(){}}function oG({viewport:n={}},{viewport:t={}}={}){return e=>n[e]!==t[e]}const aG={inView:{Feature:rG},tap:{Feature:Qj},focus:{Feature:Zj},hover:{Feature:Jj}},lG={layout:{ProjectionNode:Z_,MeasureLayout:G_}},cG={...X4,...aG,...Yj,...lG},ec=h4(cG,T4);const uG=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),hG=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,e,s)=>s?s.toUpperCase():e.toLowerCase()),eI=n=>{const t=hG(n);return t.charAt(0).toUpperCase()+t.slice(1)},Q_=(...n)=>n.filter((t,e,s)=>!!t&&t.trim()!==""&&s.indexOf(t)===e).join(" ").trim(),dG=n=>{for(const t in n)if(t.startsWith("aria-")||t==="role"||t==="title")return!0};var fG={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const pG=St.forwardRef(({color:n="currentColor",size:t=24,strokeWidth:e=2,absoluteStrokeWidth:s,className:i="",children:r,iconNode:o,...l},c)=>St.createElement("svg",{ref:c,...fG,width:t,height:t,stroke:n,strokeWidth:s?Number(e)*24/Number(t):e,className:Q_("lucide",i),...!r&&!dG(l)&&{"aria-hidden":"true"},...l},[...o.map(([h,d])=>St.createElement(h,d)),...Array.isArray(r)?r:[r]]));const gr=(n,t)=>{const e=St.forwardRef(({className:s,...i},r)=>St.createElement(pG,{ref:r,iconNode:t,className:Q_(`lucide-${uG(eI(n))}`,`lucide-${n}`,s),...i}));return e.displayName=eI(n),e};const mG=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],gG=gr("activity",mG);const yG=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],bG=gr("cpu",yG);const xG=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],nI=gr("history",xG);const vG=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],wG=gr("lock",vG);const SG=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],CG=gr("log-out",SG);const TG=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],kG=gr("search",TG);const $G=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],sI=gr("trending-down",$G);const EG=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],iI=gr("trending-up",EG);const IG=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],NG=gr("triangle-alert",IG);const AG=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],rI=gr("zap",AG);function og(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)t.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(e[s[i]]=n[s[i]]);return e}function _G(n,t,e,s){function i(r){return r instanceof e?r:new e(function(o){o(r)})}return new(e||(e=Promise))(function(r,o){function l(d){try{h(s.next(d))}catch(p){o(p)}}function c(d){try{h(s.throw(d))}catch(p){o(p)}}function h(d){d.done?r(d.value):i(d.value).then(l,c)}h((s=s.apply(n,t||[])).next())})}const RG=n=>n?(...t)=>n(...t):(...t)=>fetch(...t);class Hw extends Error{constructor(t,e="FunctionsError",s){super(t),this.name=e,this.context=s}}class DG extends Hw{constructor(t){super("Failed to send a request to the Edge Function","FunctionsFetchError",t)}}class oI extends Hw{constructor(t){super("Relay Error invoking the Edge Function","FunctionsRelayError",t)}}class aI extends Hw{constructor(t){super("Edge Function returned a non-2xx status code","FunctionsHttpError",t)}}var yv;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(yv||(yv={}));class OG{constructor(t,{headers:e={},customFetch:s,region:i=yv.Any}={}){this.url=t,this.headers=e,this.region=i,this.fetch=RG(s)}setAuth(t){this.headers.Authorization=`Bearer ${t}`}invoke(t){return _G(this,arguments,void 0,function*(e,s={}){var i;let r,o;try{const{headers:l,method:c,body:h,signal:d,timeout:p}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${e}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(l&&!Object.prototype.hasOwnProperty.call(l,"Content-Type")||!l)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;p&&(o=new AbortController,r=setTimeout(()=>o.abort(),p),d?(w=o.signal,d.addEventListener("abort",()=>o.abort())):w=o.signal);const S=yield this.fetch(b.toString(),{method:c||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),l),body:x,signal:w}).catch(E=>{throw new DG(E)}),T=S.headers.get("x-relay-error");if(T&&T==="true")throw new oI(S);if(!S.ok)throw new aI(S);let k=((i=S.headers.get("Content-Type"))!==null&&i!==void 0?i:"text/plain").split(";")[0].trim(),$;return k==="application/json"?$=yield S.json():k==="application/octet-stream"||k==="application/pdf"?$=yield S.blob():k==="text/event-stream"?$=S:k==="multipart/form-data"?$=yield S.formData():$=yield S.text(),{data:$,error:null,response:S}}catch(l){return{data:null,error:l,response:l instanceof aI||l instanceof oI?l.context:void 0}}finally{r&&clearTimeout(r)}})}}var MG=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},FG=class{constructor(n){var t,e;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(t=n.shouldThrowOnError)!==null&&t!==void 0?t:!1,this.signal=n.signal,this.isMaybeSingle=(e=n.isMaybeSingle)!==null&&e!==void 0?e:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,t){return this.headers=new Headers(this.headers),this.headers.set(n,t),this}then(n,t){var e=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let i=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async r=>{let o=null,l=null,c=null,h=r.status,d=r.statusText;if(r.ok){var p,m;if(e.method!=="HEAD"){var y;const S=await r.text();S===""||(e.headers.get("Accept")==="text/csv"||e.headers.get("Accept")&&(!((y=e.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?l=S:l=JSON.parse(S))}const x=(p=e.headers.get("Prefer"))===null||p===void 0?void 0:p.match(/count=(exact|planned|estimated)/),w=(m=r.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(c=parseInt(w[1])),e.isMaybeSingle&&e.method==="GET"&&Array.isArray(l)&&(l.length>1?(o={code:"PGRST116",details:`Results contain ${l.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},l=null,c=null,h=406,d="Not Acceptable"):l.length===1?l=l[0]:l=null)}else{var b;const x=await r.text();try{o=JSON.parse(x),Array.isArray(o)&&r.status===404&&(l=[],o=null,h=200,d="OK")}catch{r.status===404&&x===""?(h=204,d="No Content"):o={message:x}}if(o&&e.isMaybeSingle&&(!(o==null||(b=o.details)===null||b===void 0)&&b.includes("0 rows"))&&(o=null,h=200,d="OK"),o&&e.shouldThrowOnError)throw new MG(o)}return{error:o,data:l,count:c,status:h,statusText:d}});return this.shouldThrowOnError||(i=i.catch(r=>{var o;let l="";const c=r?.cause;if(c){var h,d,p,m;const b=(h=c?.message)!==null&&h!==void 0?h:"",x=(d=c?.code)!==null&&d!==void 0?d:"";l=`${(p=r?.name)!==null&&p!==void 0?p:"FetchError"}: ${r?.message}`,l+=`

Caused by: ${(m=c?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(l+=` (${x})`),c?.stack&&(l+=`
${c.stack}`)}else{var y;l=(y=r?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(o=r?.name)!==null&&o!==void 0?o:"FetchError"}: ${r?.message}`,details:l,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),i.then(n,t)}returns(){return this}overrideTypes(){return this}},LG=class extends FG{select(n){let t=!1;const e=(n??"*").split("").map(s=>/\s/.test(s)&&!t?"":(s==='"'&&(t=!t),s)).join("");return this.url.searchParams.set("select",e),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:t=!0,nullsFirst:e,foreignTable:s,referencedTable:i=s}={}){const r=i?`${i}.order`:"order",o=this.url.searchParams.get(r);return this.url.searchParams.set(r,`${o?`${o},`:""}${n}.${t?"asc":"desc"}${e===void 0?"":e?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:t,referencedTable:e=t}={}){const s=typeof e>"u"?"limit":`${e}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,t,{foreignTable:e,referencedTable:s=e}={}){const i=typeof s>"u"?"offset":`${s}.offset`,r=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(i,`${n}`),this.url.searchParams.set(r,`${t-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:t=!1,settings:e=!1,buffers:s=!1,wal:i=!1,format:r="text"}={}){var o;const l=[n?"analyze":null,t?"verbose":null,e?"settings":null,s?"buffers":null,i?"wal":null].filter(Boolean).join("|"),c=(o=this.headers.get("Accept"))!==null&&o!==void 0?o:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${r}; for="${c}"; options=${l};`),r==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const lI=new RegExp("[,()]");var hc=class extends LG{eq(n,t){return this.url.searchParams.append(n,`eq.${t}`),this}neq(n,t){return this.url.searchParams.append(n,`neq.${t}`),this}gt(n,t){return this.url.searchParams.append(n,`gt.${t}`),this}gte(n,t){return this.url.searchParams.append(n,`gte.${t}`),this}lt(n,t){return this.url.searchParams.append(n,`lt.${t}`),this}lte(n,t){return this.url.searchParams.append(n,`lte.${t}`),this}like(n,t){return this.url.searchParams.append(n,`like.${t}`),this}likeAllOf(n,t){return this.url.searchParams.append(n,`like(all).{${t.join(",")}}`),this}likeAnyOf(n,t){return this.url.searchParams.append(n,`like(any).{${t.join(",")}}`),this}ilike(n,t){return this.url.searchParams.append(n,`ilike.${t}`),this}ilikeAllOf(n,t){return this.url.searchParams.append(n,`ilike(all).{${t.join(",")}}`),this}ilikeAnyOf(n,t){return this.url.searchParams.append(n,`ilike(any).{${t.join(",")}}`),this}regexMatch(n,t){return this.url.searchParams.append(n,`match.${t}`),this}regexIMatch(n,t){return this.url.searchParams.append(n,`imatch.${t}`),this}is(n,t){return this.url.searchParams.append(n,`is.${t}`),this}isDistinct(n,t){return this.url.searchParams.append(n,`isdistinct.${t}`),this}in(n,t){const e=Array.from(new Set(t)).map(s=>typeof s=="string"&&lI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${e})`),this}notIn(n,t){const e=Array.from(new Set(t)).map(s=>typeof s=="string"&&lI.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${e})`),this}contains(n,t){return typeof t=="string"?this.url.searchParams.append(n,`cs.${t}`):Array.isArray(t)?this.url.searchParams.append(n,`cs.{${t.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(t)}`),this}containedBy(n,t){return typeof t=="string"?this.url.searchParams.append(n,`cd.${t}`):Array.isArray(t)?this.url.searchParams.append(n,`cd.{${t.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(t)}`),this}rangeGt(n,t){return this.url.searchParams.append(n,`sr.${t}`),this}rangeGte(n,t){return this.url.searchParams.append(n,`nxl.${t}`),this}rangeLt(n,t){return this.url.searchParams.append(n,`sl.${t}`),this}rangeLte(n,t){return this.url.searchParams.append(n,`nxr.${t}`),this}rangeAdjacent(n,t){return this.url.searchParams.append(n,`adj.${t}`),this}overlaps(n,t){return typeof t=="string"?this.url.searchParams.append(n,`ov.${t}`):this.url.searchParams.append(n,`ov.{${t.join(",")}}`),this}textSearch(n,t,{config:e,type:s}={}){let i="";s==="plain"?i="pl":s==="phrase"?i="ph":s==="websearch"&&(i="w");const r=e===void 0?"":`(${e})`;return this.url.searchParams.append(n,`${i}fts${r}.${t}`),this}match(n){return Object.entries(n).forEach(([t,e])=>{this.url.searchParams.append(t,`eq.${e}`)}),this}not(n,t,e){return this.url.searchParams.append(n,`not.${t}.${e}`),this}or(n,{foreignTable:t,referencedTable:e=t}={}){const s=e?`${e}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,t,e){return this.url.searchParams.append(n,`${t}.${e}`),this}},zG=class{constructor(n,{headers:t={},schema:e,fetch:s}){this.url=n,this.headers=new Headers(t),this.schema=e,this.fetch=s}select(n,t){const{head:e=!1,count:s}=t??{},i=e?"HEAD":"GET";let r=!1;const o=(n??"*").split("").map(l=>/\s/.test(l)&&!r?"":(l==='"'&&(r=!r),l)).join("");return this.url.searchParams.set("select",o),s&&this.headers.append("Prefer",`count=${s}`),new hc({method:i,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:t,defaultToNull:e=!0}={}){var s;const i="POST";if(t&&this.headers.append("Prefer",`count=${t}`),e||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const r=n.reduce((o,l)=>o.concat(Object.keys(l)),[]);if(r.length>0){const o=[...new Set(r)].map(l=>`"${l}"`);this.url.searchParams.set("columns",o.join(","))}}return new hc({method:i,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:t,ignoreDuplicates:e=!1,count:s,defaultToNull:i=!0}={}){var r;const o="POST";if(this.headers.append("Prefer",`resolution=${e?"ignore":"merge"}-duplicates`),t!==void 0&&this.url.searchParams.set("on_conflict",t),s&&this.headers.append("Prefer",`count=${s}`),i||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const l=n.reduce((c,h)=>c.concat(Object.keys(h)),[]);if(l.length>0){const c=[...new Set(l)].map(h=>`"${h}"`);this.url.searchParams.set("columns",c.join(","))}}return new hc({method:o,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(r=this.fetch)!==null&&r!==void 0?r:fetch})}update(n,{count:t}={}){var e;const s="PATCH";return t&&this.headers.append("Prefer",`count=${t}`),new hc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}delete({count:n}={}){var t;const e="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new hc({method:e,url:this.url,headers:this.headers,schema:this.schema,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}},PG=class tR{constructor(t,{headers:e={},schema:s,fetch:i}={}){this.url=t,this.headers=new Headers(e),this.schemaName=s,this.fetch=i}from(t){if(!t||typeof t!="string"||t.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new zG(new URL(`${this.url}/${t}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(t){return new tR(this.url,{headers:this.headers,schema:t,fetch:this.fetch})}rpc(t,e={},{head:s=!1,get:i=!1,count:r}={}){var o;let l;const c=new URL(`${this.url}/rpc/${t}`);let h;s||i?(l=s?"HEAD":"GET",Object.entries(e).filter(([p,m])=>m!==void 0).map(([p,m])=>[p,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([p,m])=>{c.searchParams.append(p,m)})):(l="POST",h=e);const d=new Headers(this.headers);return r&&d.set("Prefer",`count=${r}`),new hc({method:l,url:c,headers:d,schema:this.schemaName,body:h,fetch:(o=this.fetch)!==null&&o!==void 0?o:fetch})}};class BG{constructor(){}static detectEnvironment(){var t;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((t=navigator.userAgent)===null||t===void 0)&&t.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const e=process.versions;if(e&&e.node){const s=e.node,i=parseInt(s.replace(/^v/,"").split(".")[0]);return i>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${i} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${i} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const t=this.detectEnvironment();if(t.constructor)return t.constructor;let e=t.error||"WebSocket not supported in this environment.";throw t.workaround&&(e+=`

Suggested solution: ${t.workaround}`),new Error(e)}static createWebSocket(t,e){const s=this.getWebSocketConstructor();return new s(t,e)}static isWebSocketSupported(){try{const t=this.detectEnvironment();return t.type==="native"||t.type==="ws"}catch{return!1}}}const VG="2.89.0",UG=`realtime-js/${VG}`,eR="1.0.0",jG="2.0.0",cI=eR,bv=1e4,GG=1e3,WG=100;var To;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(To||(To={}));var Tn;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(Tn||(Tn={}));var Oi;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(Oi||(Oi={}));var xv;(function(n){n.websocket="websocket"})(xv||(xv={}));var Ea;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(Ea||(Ea={}));class HG{constructor(t){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=t??[]}encode(t,e){if(t.event===this.BROADCAST_EVENT&&!(t.payload instanceof ArrayBuffer)&&typeof t.payload.event=="string")return e(this._binaryEncodeUserBroadcastPush(t));let s=[t.join_ref,t.ref,t.topic,t.event,t.payload];return e(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(t){var e;return this._isArrayBuffer((e=t.payload)===null||e===void 0?void 0:e.payload)?this._encodeBinaryUserBroadcastPush(t):this._encodeJsonUserBroadcastPush(t)}_encodeBinaryUserBroadcastPush(t){var e,s;const i=(s=(e=t.payload)===null||e===void 0?void 0:e.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(t,this.BINARY_ENCODING,i)}_encodeJsonUserBroadcastPush(t){var e,s;const i=(s=(e=t.payload)===null||e===void 0?void 0:e.payload)!==null&&s!==void 0?s:{},o=new TextEncoder().encode(JSON.stringify(i)).buffer;return this._encodeUserBroadcastPush(t,this.JSON_ENCODING,o)}_encodeUserBroadcastPush(t,e,s){var i,r;const o=t.topic,l=(i=t.ref)!==null&&i!==void 0?i:"",c=(r=t.join_ref)!==null&&r!==void 0?r:"",h=t.payload.event,d=this.allowedMetadataKeys?this._pick(t.payload,this.allowedMetadataKeys):{},p=Object.keys(d).length===0?"":JSON.stringify(d);if(c.length>255)throw new Error(`joinRef length ${c.length} exceeds maximum of 255`);if(l.length>255)throw new Error(`ref length ${l.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`topic length ${o.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(p.length>255)throw new Error(`metadata length ${p.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+c.length+l.length+o.length+h.length+p.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,c.length),b.setUint8(x++,l.length),b.setUint8(x++,o.length),b.setUint8(x++,h.length),b.setUint8(x++,p.length),b.setUint8(x++,e),Array.from(c,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(l,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(o,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(h,S=>b.setUint8(x++,S.charCodeAt(0))),Array.from(p,S=>b.setUint8(x++,S.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(t,e){if(this._isArrayBuffer(t)){let s=this._binaryDecode(t);return e(s)}if(typeof t=="string"){const s=JSON.parse(t),[i,r,o,l,c]=s;return e({join_ref:i,ref:r,topic:o,event:l,payload:c})}return e({})}_binaryDecode(t){const e=new DataView(t),s=e.getUint8(0),i=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(t,e,i)}_decodeUserBroadcast(t,e,s){const i=e.getUint8(1),r=e.getUint8(2),o=e.getUint8(3),l=e.getUint8(4);let c=this.HEADER_LENGTH+4;const h=s.decode(t.slice(c,c+i));c=c+i;const d=s.decode(t.slice(c,c+r));c=c+r;const p=s.decode(t.slice(c,c+o));c=c+o;const m=t.slice(c,t.byteLength),y=l===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return o>0&&(b.meta=JSON.parse(p)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(t){var e;return t instanceof ArrayBuffer||((e=t?.constructor)===null||e===void 0?void 0:e.name)==="ArrayBuffer"}_pick(t,e){return!t||typeof t!="object"?{}:Object.fromEntries(Object.entries(t).filter(([s])=>e.includes(s)))}}class nR{constructor(t,e){this.callback=t,this.timerCalc=e,this.timer=void 0,this.tries=0,this.callback=t,this.timerCalc=e}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Me;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Me||(Me={}));const uI=(n,t,e={})=>{var s;const i=(s=e.skipTypes)!==null&&s!==void 0?s:[];return t?Object.keys(t).reduce((r,o)=>(r[o]=qG(o,n,t,i),r),{}):{}},qG=(n,t,e,s)=>{const i=t.find(l=>l.name===n),r=i?.type,o=e[n];return r&&!s.includes(r)?sR(r,o):vv(o)},sR=(n,t)=>{if(n.charAt(0)==="_"){const e=n.slice(1,n.length);return JG(t,e)}switch(n){case Me.bool:return KG(t);case Me.float4:case Me.float8:case Me.int2:case Me.int4:case Me.int8:case Me.numeric:case Me.oid:return XG(t);case Me.json:case Me.jsonb:return YG(t);case Me.timestamp:return ZG(t);case Me.abstime:case Me.date:case Me.daterange:case Me.int4range:case Me.int8range:case Me.money:case Me.reltime:case Me.text:case Me.time:case Me.timestamptz:case Me.timetz:case Me.tsrange:case Me.tstzrange:return vv(t);default:return vv(t)}},vv=n=>n,KG=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},XG=n=>{if(typeof n=="string"){const t=parseFloat(n);if(!Number.isNaN(t))return t}return n},YG=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},JG=(n,t)=>{if(typeof n!="string")return n;const e=n.length-1,s=n[e];if(n[0]==="{"&&s==="}"){let r;const o=n.slice(1,e);try{r=JSON.parse("["+o+"]")}catch{r=o?o.split(","):[]}return r.map(l=>sR(t,l))}return n},ZG=n=>typeof n=="string"?n.replace(" ","T"):n,iR=n=>{const t=new URL(n);return t.protocol=t.protocol.replace(/^ws/i,"http"),t.pathname=t.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),t.pathname===""||t.pathname==="/"?t.pathname="/api/broadcast":t.pathname=t.pathname+"/api/broadcast",t.href};class yx{constructor(t,e,s={},i=bv){this.channel=t,this.event=e,this.payload=s,this.timeout=i,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(t){this.timeout=t,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(t){this.payload=Object.assign(Object.assign({},this.payload),t)}receive(t,e){var s;return this._hasReceived(t)&&e((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:t,callback:e}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const t=e=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=e,this._matchReceive(e)};this.channel._on(this.refEvent,{},t),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(t,e){this.refEvent&&this.channel._trigger(this.refEvent,{status:t,response:e})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:t,response:e}){this.recHooks.filter(s=>s.status===t).forEach(s=>s.callback(e))}_hasReceived(t){return this.receivedResp&&this.receivedResp.status===t}}var hI;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(hI||(hI={}));class xh{constructor(t,e){this.channel=t,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=e?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},i=>{const{onJoin:r,onLeave:o,onSync:l}=this.caller;this.joinRef=this.channel._joinRef(),this.state=xh.syncState(this.state,i,r,o),this.pendingDiffs.forEach(c=>{this.state=xh.syncDiff(this.state,c,r,o)}),this.pendingDiffs=[],l()}),this.channel._on(s.diff,{},i=>{const{onJoin:r,onLeave:o,onSync:l}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(i):(this.state=xh.syncDiff(this.state,i,r,o),l())}),this.onJoin((i,r,o)=>{this.channel._trigger("presence",{event:"join",key:i,currentPresences:r,newPresences:o})}),this.onLeave((i,r,o)=>{this.channel._trigger("presence",{event:"leave",key:i,currentPresences:r,leftPresences:o})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(t,e,s,i){const r=this.cloneDeep(t),o=this.transformState(e),l={},c={};return this.map(r,(h,d)=>{o[h]||(c[h]=d)}),this.map(o,(h,d)=>{const p=r[h];if(p){const m=d.map(w=>w.presence_ref),y=p.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=p.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(l[h]=b),x.length>0&&(c[h]=x)}else l[h]=d}),this.syncDiff(r,{joins:l,leaves:c},s,i)}static syncDiff(t,e,s,i){const{joins:r,leaves:o}={joins:this.transformState(e.joins),leaves:this.transformState(e.leaves)};return s||(s=()=>{}),i||(i=()=>{}),this.map(r,(l,c)=>{var h;const d=(h=t[l])!==null&&h!==void 0?h:[];if(t[l]=this.cloneDeep(c),d.length>0){const p=t[l].map(y=>y.presence_ref),m=d.filter(y=>p.indexOf(y.presence_ref)<0);t[l].unshift(...m)}s(l,d,c)}),this.map(o,(l,c)=>{let h=t[l];if(!h)return;const d=c.map(p=>p.presence_ref);h=h.filter(p=>d.indexOf(p.presence_ref)<0),t[l]=h,i(l,h,c),h.length===0&&delete t[l]}),t}static map(t,e){return Object.getOwnPropertyNames(t).map(s=>e(s,t[s]))}static transformState(t){return t=this.cloneDeep(t),Object.getOwnPropertyNames(t).reduce((e,s)=>{const i=t[s];return"metas"in i?e[s]=i.metas.map(r=>(r.presence_ref=r.phx_ref,delete r.phx_ref,delete r.phx_ref_prev,r)):e[s]=i,e},{})}static cloneDeep(t){return JSON.parse(JSON.stringify(t))}onJoin(t){this.caller.onJoin=t}onLeave(t){this.caller.onLeave=t}onSync(t){this.caller.onSync=t}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var dI;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(dI||(dI={}));var vh;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(vh||(vh={}));var Lr;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(Lr||(Lr={}));class Sc{constructor(t,e={config:{}},s){var i,r;if(this.topic=t,this.params=e,this.socket=s,this.bindings={},this.state=Tn.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=t.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},e.config),this.timeout=this.socket.timeout,this.joinPush=new yx(this,Oi.join,this.params,this.timeout),this.rejoinTimer=new nR(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Tn.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(o=>o.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=Tn.closed,this.socket._remove(this)}),this._onError(o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=Tn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Tn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",o=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,o),this.state=Tn.errored,this.rejoinTimer.scheduleTimeout())}),this._on(Oi.reply,{},(o,l)=>{this._trigger(this._replyEventName(l),o)}),this.presence=new xh(this),this.broadcastEndpointURL=iR(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((r=(i=this.params.config)===null||i===void 0?void 0:i.broadcast)===null||r===void 0)&&r.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(t,e=this.timeout){var s,i,r;if(this.socket.isConnected()||this.socket.connect(),this.state==Tn.closed){const{config:{broadcast:o,presence:l,private:c}}=this.params,h=(i=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&i!==void 0?i:[],d=!!this.bindings[vh.PRESENCE]&&this.bindings[vh.PRESENCE].length>0||((r=this.params.config.presence)===null||r===void 0?void 0:r.enabled)===!0,p={},m={broadcast:o,presence:Object.assign(Object.assign({},l),{enabled:d}),postgres_changes:h,private:c};this.socket.accessTokenValue&&(p.access_token=this.socket.accessTokenValue),this._onError(y=>t?.(Lr.CHANNEL_ERROR,y)),this._onClose(()=>t?.(Lr.CLOSED)),this.updateJoinPayload(Object.assign({config:m},p)),this.joinedOnce=!0,this._rejoin(e),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){t?.(Lr.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,S=[];for(let T=0;T<w;T++){const k=x[T],{filter:{event:$,schema:E,table:N,filter:_}}=k,R=y&&y[T];if(R&&R.event===$&&Sc.isFilterValueEqual(R.schema,E)&&Sc.isFilterValueEqual(R.table,N)&&Sc.isFilterValueEqual(R.filter,_))S.push(Object.assign(Object.assign({},k),{id:R.id}));else{this.unsubscribe(),this.state=Tn.errored,t?.(Lr.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=S,t&&t(Lr.SUBSCRIBED);return}}).receive("error",y=>{this.state=Tn.errored,t?.(Lr.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{t?.(Lr.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(t,e={}){return await this.send({type:"presence",event:"track",payload:t},e.timeout||this.timeout)}async untrack(t={}){return await this.send({type:"presence",event:"untrack"},t)}on(t,e,s){return this.state===Tn.joined&&t===vh.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(t,e,s)}async httpSend(t,e,s={}){var i;if(e==null)return Promise.reject("Payload is required for httpSend()");const r={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(r.Authorization=`Bearer ${this.socket.accessTokenValue}`);const o={method:"POST",headers:r,body:JSON.stringify({messages:[{topic:this.subTopic,event:t,payload:e,private:this.private}]})},l=await this._fetchWithTimeout(this.broadcastEndpointURL,o,(i=s.timeout)!==null&&i!==void 0?i:this.timeout);if(l.status===202)return{success:!0};let c=l.statusText;try{const h=await l.json();c=h.error||h.message||c}catch{}return Promise.reject(new Error(c))}async send(t,e={}){var s,i;if(!this._canPush()&&t.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:r,payload:o}=t,l={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(l.Authorization=`Bearer ${this.socket.accessTokenValue}`);const c={method:"POST",headers:l,body:JSON.stringify({messages:[{topic:this.subTopic,event:r,payload:o,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,c,(s=e.timeout)!==null&&s!==void 0?s:this.timeout);return await((i=h.body)===null||i===void 0?void 0:i.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(r=>{var o,l,c;const h=this._push(t.type,t,e.timeout||this.timeout);t.type==="broadcast"&&!(!((c=(l=(o=this.params)===null||o===void 0?void 0:o.config)===null||l===void 0?void 0:l.broadcast)===null||c===void 0)&&c.ack)&&r("ok"),h.receive("ok",()=>r("ok")),h.receive("error",()=>r("error")),h.receive("timeout",()=>r("timed out"))})}updateJoinPayload(t){this.joinPush.updatePayload(t)}unsubscribe(t=this.timeout){this.state=Tn.leaving;const e=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(Oi.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(i=>{s=new yx(this,Oi.leave,{},t),s.receive("ok",()=>{e(),i("ok")}).receive("timeout",()=>{e(),i("timed out")}).receive("error",()=>{i("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(t=>t.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=Tn.closed,this.bindings={}}async _fetchWithTimeout(t,e,s){const i=new AbortController,r=setTimeout(()=>i.abort(),s),o=await this.socket.fetch(t,Object.assign(Object.assign({},e),{signal:i.signal}));return clearTimeout(r),o}_push(t,e,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let i=new yx(this,t,e,s);return this._canPush()?i.send():this._addToPushBuffer(i),i}_addToPushBuffer(t){if(t.startTimeout(),this.pushBuffer.push(t),this.pushBuffer.length>WG){const e=this.pushBuffer.shift();e&&(e.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${e.event}`,e.payload))}}_onMessage(t,e,s){return e}_isMember(t){return this.topic===t}_joinRef(){return this.joinPush.ref}_trigger(t,e,s){var i,r;const o=t.toLocaleLowerCase(),{close:l,error:c,leave:h,join:d}=Oi;if(s&&[l,c,h,d].indexOf(o)>=0&&s!==this._joinRef())return;let m=this._onMessage(o,e,s);if(e&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(o)?(i=this.bindings.postgres_changes)===null||i===void 0||i.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===o}).map(y=>y.callback(m,s)):(r=this.bindings[o])===null||r===void 0||r.filter(y=>{var b,x,w,S,T,k;if(["broadcast","presence","postgres_changes"].includes(o))if("id"in y){const $=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return $&&((x=e.ids)===null||x===void 0?void 0:x.includes($))&&(E==="*"||E?.toLocaleLowerCase()===((w=e.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const $=(T=(S=y?.filter)===null||S===void 0?void 0:S.event)===null||T===void 0?void 0:T.toLocaleLowerCase();return $==="*"||$===((k=e?.event)===null||k===void 0?void 0:k.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===o}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:S,type:T,errors:k}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:S,eventType:T,new:{},old:{},errors:k}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===Tn.closed}_isJoined(){return this.state===Tn.joined}_isJoining(){return this.state===Tn.joining}_isLeaving(){return this.state===Tn.leaving}_replyEventName(t){return`chan_reply_${t}`}_on(t,e,s){const i=t.toLocaleLowerCase(),r={type:i,filter:e,callback:s};return this.bindings[i]?this.bindings[i].push(r):this.bindings[i]=[r],this}_off(t,e){const s=t.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(i=>{var r;return!(((r=i.type)===null||r===void 0?void 0:r.toLocaleLowerCase())===s&&Sc.isEqual(i.filter,e))})),this}static isEqual(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(const s in t)if(t[s]!==e[s])return!1;return!0}static isFilterValueEqual(t,e){return(t??void 0)===(e??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(t){this._on(Oi.close,{},t)}_onError(t){this._on(Oi.error,{},e=>t(e))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(t=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=Tn.joining,this.joinPush.resend(t))}_getPayloadRecords(t){const e={new:{},old:{}};return(t.type==="INSERT"||t.type==="UPDATE")&&(e.new=uI(t.columns,t.record)),(t.type==="UPDATE"||t.type==="DELETE")&&(e.old=uI(t.columns,t.old_record)),e}}const bx=()=>{},Vp={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},QG=[1e3,2e3,5e3,1e4],tW=1e4,eW=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class nW{constructor(t,e){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=bv,this.transport=null,this.heartbeatIntervalMs=Vp.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=bx,this.ref=0,this.reconnectTimer=null,this.vsn=cI,this.logger=bx,this.conn=null,this.sendBuffer=[],this.serializer=new HG,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=i=>i?(...r)=>i(...r):(...r)=>fetch(...r),!(!((s=e?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=e.params.apikey,this.endPoint=`${t}/${xv.websocket}`,this.httpEndpoint=iR(t),this._initializeOptions(e),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(e?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=BG.createWebSocket(this.endpointURL())}catch(t){this._setConnectionState("disconnected");const e=t.message;throw e.includes("Node.js")?new Error(`${e}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${e}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(t,e){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(t?this.conn.close(t,e??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(t){const e=await t.unsubscribe();return this.channels.length===0&&this.disconnect(),e}async removeAllChannels(){const t=await Promise.all(this.channels.map(e=>e.unsubscribe()));return this.channels=[],this.disconnect(),t}log(t,e,s){this.logger(t,e,s)}connectionState(){switch(this.conn&&this.conn.readyState){case To.connecting:return Ea.Connecting;case To.open:return Ea.Open;case To.closing:return Ea.Closing;default:return Ea.Closed}}isConnected(){return this.connectionState()===Ea.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(t,e={config:{}}){const s=`realtime:${t}`,i=this.getChannels().find(r=>r.topic===s);if(i)return i;{const r=new Sc(`realtime:${t}`,e,this);return this.channels.push(r),r}}push(t){const{topic:e,event:s,payload:i,ref:r}=t,o=()=>{this.encode(t,l=>{var c;(c=this.conn)===null||c===void 0||c.send(l)})};this.log("push",`${e} ${s} (${r})`,i),this.isConnected()?o():this.sendBuffer.push(o)}async setAuth(t=null){this._authPromise=this._performAuth(t);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var t;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(e){this.log("error","error in heartbeat callback",e)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(e){this.log("error","error in heartbeat callback",e)}this._wasManualDisconnect=!1,(t=this.conn)===null||t===void 0||t.close(GG,"heartbeat timeout"),setTimeout(()=>{var e;this.isConnected()||(e=this.reconnectTimer)===null||e===void 0||e.scheduleTimeout()},Vp.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(e){this.log("error","error in heartbeat callback",e)}this._setAuthSafely("heartbeat")}onHeartbeat(t){this.heartbeatCallback=t}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(t=>t()),this.sendBuffer=[])}_makeRef(){let t=this.ref+1;return t===this.ref?this.ref=0:this.ref=t,this.ref.toString()}_leaveOpenTopic(t){let e=this.channels.find(s=>s.topic===t&&(s._isJoined()||s._isJoining()));e&&(this.log("transport",`leaving duplicate topic "${t}"`),e.unsubscribe())}_remove(t){this.channels=this.channels.filter(e=>e.topic!==t.topic)}_onConnMessage(t){this.decode(t.data,e=>{if(e.topic==="phoenix"&&e.event==="phx_reply")try{this.heartbeatCallback(e.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}e.ref&&e.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:i,payload:r,ref:o}=e,l=o?`(${o})`:"",c=r.status||"";this.log("receive",`${c} ${s} ${i} ${l}`.trim(),r),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(i,r,o)),this._triggerStateCallbacks("message",e)})}_clearTimer(t){var e;t==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):t==="reconnect"&&((e=this.reconnectTimer)===null||e===void 0||e.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=t=>this._onConnError(t),this.conn.onmessage=t=>this._onConnMessage(t),this.conn.onclose=t=>this._onConnClose(t),this.conn.readyState===To.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===To.open||this.conn.readyState===To.connecting)try{this.conn.close()}catch(t){this.log("error","Error closing connection",t)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(t=>t.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(e=>{this.log("error","error waiting for auth on connect",e),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const t=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(t),this.workerRef.onerror=e=>{this.log("worker","worker error",e.message),this._terminateWorker()},this.workerRef.onmessage=e=>{e.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(t){var e;this._setConnectionState("disconnected"),this.log("transport","close",t),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(e=this.reconnectTimer)===null||e===void 0||e.scheduleTimeout(),this._triggerStateCallbacks("close",t)}_onConnError(t){this._setConnectionState("disconnected"),this.log("transport",`${t}`),this._triggerChanError(),this._triggerStateCallbacks("error",t)}_triggerChanError(){this.channels.forEach(t=>t._trigger(Oi.error))}_appendParams(t,e){if(Object.keys(e).length===0)return t;const s=t.match(/\?/)?"&":"?",i=new URLSearchParams(e);return`${t}${s}${i}`}_workerObjectUrl(t){let e;if(t)e=t;else{const s=new Blob([eW],{type:"application/javascript"});e=URL.createObjectURL(s)}return e}_setConnectionState(t,e=!1){this._connectionState=t,t==="connecting"?this._wasManualDisconnect=!1:t==="disconnecting"&&(this._wasManualDisconnect=e)}async _performAuth(t=null){let e,s=!1;if(t)e=t,s=!0;else if(this.accessToken)try{e=await this.accessToken()}catch(i){this.log("error","Error fetching access token from callback",i),e=this.accessTokenValue}else e=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=e&&(this.accessTokenValue=e,this.channels.forEach(i=>{const r={access_token:e,version:UG};e&&i.updateJoinPayload(r),i.joinedOnce&&i._isJoined()&&i._push(Oi.access_token,{access_token:e})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(t="general"){this._isManualToken()||this.setAuth().catch(e=>{this.log("error",`Error setting auth in ${t}`,e)})}_triggerStateCallbacks(t,e){try{this.stateChangeCallbacks[t].forEach(s=>{try{s(e)}catch(i){this.log("error",`error in ${t} callback`,i)}})}catch(s){this.log("error",`error triggering ${t} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new nR(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},Vp.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(t){var e,s,i,r,o,l,c,h,d,p,m,y;switch(this.transport=(e=t?.transport)!==null&&e!==void 0?e:null,this.timeout=(s=t?.timeout)!==null&&s!==void 0?s:bv,this.heartbeatIntervalMs=(i=t?.heartbeatIntervalMs)!==null&&i!==void 0?i:Vp.HEARTBEAT_INTERVAL,this.worker=(r=t?.worker)!==null&&r!==void 0?r:!1,this.accessToken=(o=t?.accessToken)!==null&&o!==void 0?o:null,this.heartbeatCallback=(l=t?.heartbeatCallback)!==null&&l!==void 0?l:bx,this.vsn=(c=t?.vsn)!==null&&c!==void 0?c:cI,t?.params&&(this.params=t.params),t?.logger&&(this.logger=t.logger),(t?.logLevel||t?.log_level)&&(this.logLevel=t.logLevel||t.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=t?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>QG[b-1]||tW),this.vsn){case eR:this.encode=(d=t?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(p=t?.decode)!==null&&p!==void 0?p:((b,x)=>x(JSON.parse(b)));break;case jG:this.encode=(m=t?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=t?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=t?.workerUrl}}}var Nh=class extends Error{constructor(n,t){super(n),this.name="IcebergError",this.status=t.status,this.icebergType=t.icebergType,this.icebergCode=t.icebergCode,this.details=t.details,this.isCommitStateUnknown=t.icebergType==="CommitStateUnknownException"||[500,502,504].includes(t.status)&&t.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function sW(n,t,e){const s=new URL(t,n);if(e)for(const[i,r]of Object.entries(e))r!==void 0&&s.searchParams.set(i,r);return s.toString()}async function iW(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function rW(n){const t=n.fetchImpl??globalThis.fetch;return{async request({method:e,path:s,query:i,body:r,headers:o}){const l=sW(n.baseUrl,s,i),c=await iW(n.auth),h=await t(l,{method:e,headers:{...r?{"Content-Type":"application/json"}:{},...c,...o},body:r?JSON.stringify(r):void 0}),d=await h.text(),p=(h.headers.get("content-type")||"").includes("application/json"),m=p&&d?JSON.parse(d):d;if(!h.ok){const y=p?m:void 0,b=y?.error;throw new Nh(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function Up(n){return n.join("")}var oW=class{constructor(n,t=""){this.client=n,this.prefix=t}async listNamespaces(n){const t=n?{parent:Up(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:t})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,t){const e={namespace:n.namespace,properties:t?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:e})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${Up(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${Up(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${Up(n.namespace)}`}),!0}catch(t){if(t instanceof Nh&&t.status===404)return!1;throw t}}async createNamespaceIfNotExists(n,t){try{return await this.createNamespace(n,t)}catch(e){if(e instanceof Nh&&e.status===409)return;throw e}}};function nc(n){return n.join("")}var aW=class{constructor(n,t="",e){this.client=n,this.prefix=t,this.accessDelegation=e}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${nc(n.namespace)}/tables`})).data.identifiers}async createTable(n,t){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${nc(n.namespace)}/tables`,body:t,headers:e})).data.metadata}async updateTable(n,t){const e=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${nc(n.namespace)}/tables/${n.name}`,body:t});return{"metadata-location":e.data["metadata-location"],metadata:e.data.metadata}}async dropTable(n,t){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${nc(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(t?.purge??!1)}})}async loadTable(n){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${nc(n.namespace)}/tables/${n.name}`,headers:t})).data.metadata}async tableExists(n){const t={};this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${nc(n.namespace)}/tables/${n.name}`,headers:t}),!0}catch(e){if(e instanceof Nh&&e.status===404)return!1;throw e}}async createTableIfNotExists(n,t){try{return await this.createTable(n,t)}catch(e){if(e instanceof Nh&&e.status===409)return await this.loadTable({namespace:n.namespace,name:t.name});throw e}}},lW=class{constructor(n){let t="v1";n.catalogName&&(t+=`/${n.catalogName}`);const e=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=rW({baseUrl:e,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new oW(this.client,t),this.tableOps=new aW(this.client,t,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,t){return this.namespaceOps.createNamespace(n,t)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,t){return this.tableOps.createTable(n,t)}async updateTable(n,t){return this.tableOps.updateTable(n,t)}async dropTable(n,t){await this.tableOps.dropTable(n,t)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,t){return this.namespaceOps.createNamespaceIfNotExists(n,t)}async createTableIfNotExists(n,t){return this.tableOps.createTableIfNotExists(n,t)}},ag=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function He(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var cW=class extends ag{constructor(n,t,e){super(n),this.name="StorageApiError",this.status=t,this.statusCode=e}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},wv=class extends ag{constructor(n,t){super(n),this.name="StorageUnknownError",this.originalError=t}};const qw=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),uW=()=>Response,Sv=n=>{if(Array.isArray(n))return n.map(e=>Sv(e));if(typeof n=="function"||n!==Object(n))return n;const t={};return Object.entries(n).forEach(([e,s])=>{const i=e.replace(/([-_][a-z])/gi,r=>r.toUpperCase().replace(/[-_]/g,""));t[i]=Sv(s)}),t},hW=n=>{if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},dW=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function Ah(n){"@babel/helpers - typeof";return Ah=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Ah(n)}function fW(n,t){if(Ah(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var s=e.call(n,t);if(Ah(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function pW(n){var t=fW(n,"string");return Ah(t)=="symbol"?t:t+""}function mW(n,t,e){return(t=pW(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function fI(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);t&&(s=s.filter(function(i){return Object.getOwnPropertyDescriptor(n,i).enumerable})),e.push.apply(e,s)}return e}function Ut(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?fI(Object(e),!0).forEach(function(s){mW(n,s,e[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):fI(Object(e)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(e,s))})}return n}const xx=n=>{var t;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(t=n.error)===null||t===void 0?void 0:t.message)||JSON.stringify(n)},gW=async(n,t,e)=>{n instanceof await uW()&&!e?.noResolveJson?n.json().then(s=>{const i=n.status||500,r=s?.statusCode||i+"";t(new cW(xx(s),i,r))}).catch(s=>{t(new wv(xx(s),s))}):t(new wv(xx(n),n))},yW=(n,t,e,s)=>{const i={method:n,headers:t?.headers||{}};return n==="GET"||!s?i:(hW(s)?(i.headers=Ut({"Content-Type":"application/json"},t?.headers),i.body=JSON.stringify(s)):i.body=s,t?.duplex&&(i.duplex=t.duplex),Ut(Ut({},i),e))};async function Qh(n,t,e,s,i,r){return new Promise((o,l)=>{n(e,yW(t,s,i,r)).then(c=>{if(!c.ok)throw c;return s?.noResolveJson?c:c.json()}).then(c=>o(c)).catch(c=>gW(c,l,s))})}async function _h(n,t,e,s){return Qh(n,"GET",t,e,s)}async function Di(n,t,e,s,i){return Qh(n,"POST",t,s,i,e)}async function Cv(n,t,e,s,i){return Qh(n,"PUT",t,s,i,e)}async function bW(n,t,e,s){return Qh(n,"HEAD",t,Ut(Ut({},e),{},{noResolveJson:!0}),s)}async function Kw(n,t,e,s,i){return Qh(n,"DELETE",t,s,i,e)}var xW=class{constructor(n,t){this.downloadFn=n,this.shouldThrowOnError=t}then(n,t){return this.execute().then(n,t)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(t){if(n.shouldThrowOnError)throw t;if(He(t))return{data:null,error:t};throw t}}};let rR;rR=Symbol.toStringTag;var vW=class{constructor(n,t){this.downloadFn=n,this.shouldThrowOnError=t,this[rR]="BlobDownloadBuilder",this.promise=null}asStream(){return new xW(this.downloadFn,this.shouldThrowOnError)}then(n,t){return this.getPromise().then(n,t)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(t){if(n.shouldThrowOnError)throw t;if(He(t))return{data:null,error:t};throw t}}};const wW={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},pI={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var SW=class{constructor(n,t={},e,s){this.shouldThrowOnError=!1,this.url=n,this.headers=t,this.bucketId=e,this.fetch=qw(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,t,e,s){var i=this;try{let r;const o=Ut(Ut({},pI),s);let l=Ut(Ut({},i.headers),n==="POST"&&{"x-upsert":String(o.upsert)});const c=o.metadata;typeof Blob<"u"&&e instanceof Blob?(r=new FormData,r.append("cacheControl",o.cacheControl),c&&r.append("metadata",i.encodeMetadata(c)),r.append("",e)):typeof FormData<"u"&&e instanceof FormData?(r=e,r.has("cacheControl")||r.append("cacheControl",o.cacheControl),c&&!r.has("metadata")&&r.append("metadata",i.encodeMetadata(c))):(r=e,l["cache-control"]=`max-age=${o.cacheControl}`,l["content-type"]=o.contentType,c&&(l["x-metadata"]=i.toBase64(i.encodeMetadata(c))),(typeof ReadableStream<"u"&&r instanceof ReadableStream||r&&typeof r=="object"&&"pipe"in r&&typeof r.pipe=="function")&&!o.duplex&&(o.duplex="half")),s?.headers&&(l=Ut(Ut({},l),s.headers));const h=i._removeEmptyFolders(t),d=i._getFinalPath(h),p=await(n=="PUT"?Cv:Di)(i.fetch,`${i.url}/object/${d}`,r,Ut({headers:l},o?.duplex?{duplex:o.duplex}:{}));return{data:{path:h,id:p.Id,fullPath:p.Key},error:null}}catch(r){if(i.shouldThrowOnError)throw r;if(He(r))return{data:null,error:r};throw r}}async upload(n,t,e){return this.uploadOrUpdate("POST",n,t,e)}async uploadToSignedUrl(n,t,e,s){var i=this;const r=i._removeEmptyFolders(n),o=i._getFinalPath(r),l=new URL(i.url+`/object/upload/sign/${o}`);l.searchParams.set("token",t);try{let c;const h=Ut({upsert:pI.upsert},s),d=Ut(Ut({},i.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&e instanceof Blob?(c=new FormData,c.append("cacheControl",h.cacheControl),c.append("",e)):typeof FormData<"u"&&e instanceof FormData?(c=e,c.append("cacheControl",h.cacheControl)):(c=e,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:r,fullPath:(await Cv(i.fetch,l.toString(),c,{headers:d})).Key},error:null}}catch(c){if(i.shouldThrowOnError)throw c;if(He(c))return{data:null,error:c};throw c}}async createSignedUploadUrl(n,t){var e=this;try{let s=e._getFinalPath(n);const i=Ut({},e.headers);t?.upsert&&(i["x-upsert"]="true");const r=await Di(e.fetch,`${e.url}/object/upload/sign/${s}`,{},{headers:i}),o=new URL(e.url+r.url),l=o.searchParams.get("token");if(!l)throw new ag("No token returned by API");return{data:{signedUrl:o.toString(),path:n,token:l},error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(He(s))return{data:null,error:s};throw s}}async update(n,t,e){return this.uploadOrUpdate("PUT",n,t,e)}async move(n,t,e){var s=this;try{return{data:await Di(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:t,destinationBucket:e?.destinationBucket},{headers:s.headers}),error:null}}catch(i){if(s.shouldThrowOnError)throw i;if(He(i))return{data:null,error:i};throw i}}async copy(n,t,e){var s=this;try{return{data:{path:(await Di(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:t,destinationBucket:e?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(i){if(s.shouldThrowOnError)throw i;if(He(i))return{data:null,error:i};throw i}}async createSignedUrl(n,t,e){var s=this;try{let i=s._getFinalPath(n),r=await Di(s.fetch,`${s.url}/object/sign/${i}`,Ut({expiresIn:t},e?.transform?{transform:e.transform}:{}),{headers:s.headers});const o=e?.download?`&download=${e.download===!0?"":e.download}`:"";return r={signedUrl:encodeURI(`${s.url}${r.signedURL}${o}`)},{data:r,error:null}}catch(i){if(s.shouldThrowOnError)throw i;if(He(i))return{data:null,error:i};throw i}}async createSignedUrls(n,t,e){var s=this;try{const i=await Di(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:t,paths:n},{headers:s.headers}),r=e?.download?`&download=${e.download===!0?"":e.download}`:"";return{data:i.map(o=>Ut(Ut({},o),{},{signedUrl:o.signedURL?encodeURI(`${s.url}${o.signedURL}${r}`):null})),error:null}}catch(i){if(s.shouldThrowOnError)throw i;if(He(i))return{data:null,error:i};throw i}}download(n,t){const e=typeof t?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(t?.transform||{}),i=s?`?${s}`:"",r=this._getFinalPath(n),o=()=>_h(this.fetch,`${this.url}/${e}/${r}${i}`,{headers:this.headers,noResolveJson:!0});return new vW(o,this.shouldThrowOnError)}async info(n){var t=this;const e=t._getFinalPath(n);try{return{data:Sv(await _h(t.fetch,`${t.url}/object/info/${e}`,{headers:t.headers})),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(He(s))return{data:null,error:s};throw s}}async exists(n){var t=this;const e=t._getFinalPath(n);try{return await bW(t.fetch,`${t.url}/object/${e}`,{headers:t.headers}),{data:!0,error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(He(s)&&s instanceof wv){const i=s.originalError;if([400,404].includes(i?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,t){const e=this._getFinalPath(n),s=[],i=t?.download?`download=${t.download===!0?"":t.download}`:"";i!==""&&s.push(i);const r=typeof t?.transform<"u"?"render/image":"object",o=this.transformOptsToQueryString(t?.transform||{});o!==""&&s.push(o);let l=s.join("&");return l!==""&&(l=`?${l}`),{data:{publicUrl:encodeURI(`${this.url}/${r}/public/${e}${l}`)}}}async remove(n){var t=this;try{return{data:await Kw(t.fetch,`${t.url}/object/${t.bucketId}`,{prefixes:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}async list(n,t,e){var s=this;try{const i=Ut(Ut(Ut({},wW),t),{},{prefix:n||""});return{data:await Di(s.fetch,`${s.url}/object/list/${s.bucketId}`,i,{headers:s.headers},e),error:null}}catch(i){if(s.shouldThrowOnError)throw i;if(He(i))return{data:null,error:i};throw i}}async listV2(n,t){var e=this;try{const s=Ut({},n);return{data:await Di(e.fetch,`${e.url}/object/list-v2/${e.bucketId}`,s,{headers:e.headers},t),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(He(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const t=[];return n.width&&t.push(`width=${n.width}`),n.height&&t.push(`height=${n.height}`),n.resize&&t.push(`resize=${n.resize}`),n.format&&t.push(`format=${n.format}`),n.quality&&t.push(`quality=${n.quality}`),t.join("&")}};const oR="2.89.0",aR={"X-Client-Info":`storage-js/${oR}`};var CW=class{constructor(n,t={},e,s){this.shouldThrowOnError=!1;const i=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(i.hostname)&&!i.hostname.includes("storage.supabase.")&&(i.hostname=i.hostname.replace("supabase.","storage.supabase.")),this.url=i.href.replace(/\/$/,""),this.headers=Ut(Ut({},aR),t),this.fetch=qw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var t=this;try{const e=t.listBucketOptionsToQueryString(n);return{data:await _h(t.fetch,`${t.url}/bucket${e}`,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}async getBucket(n){var t=this;try{return{data:await _h(t.fetch,`${t.url}/bucket/${n}`,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}async createBucket(n,t={public:!1}){var e=this;try{return{data:await Di(e.fetch,`${e.url}/bucket`,{id:n,name:n,type:t.type,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(He(s))return{data:null,error:s};throw s}}async updateBucket(n,t){var e=this;try{return{data:await Cv(e.fetch,`${e.url}/bucket/${n}`,{id:n,name:n,public:t.public,file_size_limit:t.fileSizeLimit,allowed_mime_types:t.allowedMimeTypes},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(He(s))return{data:null,error:s};throw s}}async emptyBucket(n){var t=this;try{return{data:await Di(t.fetch,`${t.url}/bucket/${n}/empty`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Kw(t.fetch,`${t.url}/bucket/${n}`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}listBucketOptionsToQueryString(n){const t={};return n&&("limit"in n&&(t.limit=String(n.limit)),"offset"in n&&(t.offset=String(n.offset)),n.search&&(t.search=n.search),n.sortColumn&&(t.sortColumn=n.sortColumn),n.sortOrder&&(t.sortOrder=n.sortOrder)),Object.keys(t).length>0?"?"+new URLSearchParams(t).toString():""}},TW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},aR),t),this.fetch=qw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var t=this;try{return{data:await Di(t.fetch,`${t.url}/bucket`,{name:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}async listBuckets(n){var t=this;try{const e=new URLSearchParams;n?.limit!==void 0&&e.set("limit",n.limit.toString()),n?.offset!==void 0&&e.set("offset",n.offset.toString()),n?.sortColumn&&e.set("sortColumn",n.sortColumn),n?.sortOrder&&e.set("sortOrder",n.sortOrder),n?.search&&e.set("search",n.search);const s=e.toString(),i=s?`${t.url}/bucket?${s}`:`${t.url}/bucket`;return{data:await _h(t.fetch,i,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Kw(t.fetch,`${t.url}/bucket/${n}`,{},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(He(e))return{data:null,error:e};throw e}}from(n){var t=this;if(!dW(n))throw new ag("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const e=new lW({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>t.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(e,{get(i,r){const o=i[r];return typeof o!="function"?o:async(...l)=>{try{return{data:await o.apply(i,l),error:null}}catch(c){if(s)throw c;return{data:null,error:c}}}}})}};const Xw={"X-Client-Info":`storage-js/${oR}`,"Content-Type":"application/json"};var lR=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function js(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var vx=class extends lR{constructor(n,t,e){super(n),this.name="StorageVectorsApiError",this.status=t,this.statusCode=e}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},kW=class extends lR{constructor(n,t){super(n),this.name="StorageVectorsUnknownError",this.originalError=t}};const Yw=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),$W=n=>{if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},mI=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),EW=async(n,t,e)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!e?.noResolveJson){const s=n.status||500,i=n;if(typeof i.json=="function")i.json().then(r=>{const o=r?.statusCode||r?.code||s+"";t(new vx(mI(r),s,o))}).catch(()=>{const r=s+"";t(new vx(i.statusText||`HTTP ${s} error`,s,r))});else{const r=s+"";t(new vx(i.statusText||`HTTP ${s} error`,s,r))}}else t(new kW(mI(n),n))},IW=(n,t,e,s)=>{const i={method:n,headers:t?.headers||{}};return s?($W(s)?(i.headers=Ut({"Content-Type":"application/json"},t?.headers),i.body=JSON.stringify(s)):i.body=s,Ut(Ut({},i),e)):i};async function NW(n,t,e,s,i,r){return new Promise((o,l)=>{n(e,IW(t,s,i,r)).then(c=>{if(!c.ok)throw c;if(s?.noResolveJson)return c;const h=c.headers.get("content-type");return!h||!h.includes("application/json")?{}:c.json()}).then(c=>o(c)).catch(c=>EW(c,l,s))})}async function Gs(n,t,e,s,i){return NW(n,"POST",t,s,i,e)}var AW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Xw),t),this.fetch=Yw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/CreateIndex`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async getIndex(n,t){var e=this;try{return{data:await Gs(e.fetch,`${e.url}/GetIndex`,{vectorBucketName:n,indexName:t},{headers:e.headers}),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(js(s))return{data:null,error:s};throw s}}async listIndexes(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/ListIndexes`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async deleteIndex(n,t){var e=this;try{return{data:await Gs(e.fetch,`${e.url}/DeleteIndex`,{vectorBucketName:n,indexName:t},{headers:e.headers})||{},error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(js(s))return{data:null,error:s};throw s}}},_W=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Xw),t),this.fetch=Yw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var t=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await Gs(t.fetch,`${t.url}/PutVectors`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async getVectors(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/GetVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async listVectors(n){var t=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await Gs(t.fetch,`${t.url}/ListVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async queryVectors(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/QueryVectors`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async deleteVectors(n){var t=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await Gs(t.fetch,`${t.url}/DeleteVectors`,n,{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}},RW=class{constructor(n,t={},e){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=Ut(Ut({},Xw),t),this.fetch=Yw(e)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async getBucket(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/GetVectorBucket`,{vectorBucketName:n},{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async listBuckets(n={}){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/ListVectorBuckets`,n,{headers:t.headers}),error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}async deleteBucket(n){var t=this;try{return{data:await Gs(t.fetch,`${t.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:t.headers})||{},error:null}}catch(e){if(t.shouldThrowOnError)throw e;if(js(e))return{data:null,error:e};throw e}}},DW=class extends RW{constructor(n,t={}){super(n,t.headers||{},t.fetch)}from(n){return new OW(this.url,this.headers,n,this.fetch)}async createBucket(n){var t=()=>super.createBucket,e=this;return t().call(e,n)}async getBucket(n){var t=()=>super.getBucket,e=this;return t().call(e,n)}async listBuckets(n={}){var t=()=>super.listBuckets,e=this;return t().call(e,n)}async deleteBucket(n){var t=()=>super.deleteBucket,e=this;return t().call(e,n)}},OW=class extends AW{constructor(n,t,e,s){super(n,t,s),this.vectorBucketName=e}async createIndex(n){var t=()=>super.createIndex,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName}))}async listIndexes(n={}){var t=()=>super.listIndexes,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName}))}async getIndex(n){var t=()=>super.getIndex,e=this;return t().call(e,e.vectorBucketName,n)}async deleteIndex(n){var t=()=>super.deleteIndex,e=this;return t().call(e,e.vectorBucketName,n)}index(n){return new MW(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},MW=class extends _W{constructor(n,t,e,s,i){super(n,t,i),this.vectorBucketName=e,this.indexName=s}async putVectors(n){var t=()=>super.putVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async getVectors(n){var t=()=>super.getVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async listVectors(n={}){var t=()=>super.listVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async queryVectors(n){var t=()=>super.queryVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}async deleteVectors(n){var t=()=>super.deleteVectors,e=this;return t().call(e,Ut(Ut({},n),{},{vectorBucketName:e.vectorBucketName,indexName:e.indexName}))}},FW=class extends CW{constructor(n,t={},e,s){super(n,t,e,s)}from(n){return new SW(this.url,this.headers,n,this.fetch)}get vectors(){return new DW(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new TW(this.url+"/iceberg",this.headers,this.fetch)}};const cR="2.89.0",dc=30*1e3,Tv=3,wx=Tv*dc,LW="http://localhost:9999",zW="supabase.auth.token",PW={"X-Client-Info":`gotrue-js/${cR}`},kv="X-Supabase-Api-Version",uR={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},BW=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,VW=600*1e3;class Rh extends Error{constructor(t,e,s){super(t),this.__isAuthError=!0,this.name="AuthError",this.status=e,this.code=s}}function Dt(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class UW extends Rh{constructor(t,e,s){super(t,e,s),this.name="AuthApiError",this.status=e,this.code=s}}function jW(n){return Dt(n)&&n.name==="AuthApiError"}class Ia extends Rh{constructor(t,e){super(t),this.name="AuthUnknownError",this.originalError=e}}class qr extends Rh{constructor(t,e,s,i){super(t,s,i),this.name=e,this.status=s}}class Us extends qr{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function GW(n){return Dt(n)&&n.name==="AuthSessionMissingError"}class sc extends qr{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class jp extends qr{constructor(t){super(t,"AuthInvalidCredentialsError",400,void 0)}}class Gp extends qr{constructor(t,e=null){super(t,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function WW(n){return Dt(n)&&n.name==="AuthImplicitGrantRedirectError"}class gI extends qr{constructor(t,e=null){super(t,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=e}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class HW extends qr{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class $v extends qr{constructor(t,e){super(t,"AuthRetryableFetchError",e,void 0)}}function Sx(n){return Dt(n)&&n.name==="AuthRetryableFetchError"}class yI extends qr{constructor(t,e,s){super(t,"AuthWeakPasswordError",e,"weak_password"),this.reasons=s}}class Ev extends qr{constructor(t){super(t,"AuthInvalidJwtError",400,"invalid_jwt")}}const Cm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),bI=` 	
\r=`.split(""),qW=(()=>{const n=new Array(128);for(let t=0;t<n.length;t+=1)n[t]=-1;for(let t=0;t<bI.length;t+=1)n[bI[t].charCodeAt(0)]=-2;for(let t=0;t<Cm.length;t+=1)n[Cm[t].charCodeAt(0)]=t;return n})();function xI(n,t,e){if(n!==null)for(t.queue=t.queue<<8|n,t.queuedBits+=8;t.queuedBits>=6;){const s=t.queue>>t.queuedBits-6&63;e(Cm[s]),t.queuedBits-=6}else if(t.queuedBits>0)for(t.queue=t.queue<<6-t.queuedBits,t.queuedBits=6;t.queuedBits>=6;){const s=t.queue>>t.queuedBits-6&63;e(Cm[s]),t.queuedBits-=6}}function hR(n,t,e){const s=qW[n];if(s>-1)for(t.queue=t.queue<<6|s,t.queuedBits+=6;t.queuedBits>=8;)e(t.queue>>t.queuedBits-8&255),t.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function vI(n){const t=[],e=o=>{t.push(String.fromCodePoint(o))},s={utf8seq:0,codepoint:0},i={queue:0,queuedBits:0},r=o=>{YW(o,s,e)};for(let o=0;o<n.length;o+=1)hR(n.charCodeAt(o),i,r);return t.join("")}function KW(n,t){if(n<=127){t(n);return}else if(n<=2047){t(192|n>>6),t(128|n&63);return}else if(n<=65535){t(224|n>>12),t(128|n>>6&63),t(128|n&63);return}else if(n<=1114111){t(240|n>>18),t(128|n>>12&63),t(128|n>>6&63),t(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function XW(n,t){for(let e=0;e<n.length;e+=1){let s=n.charCodeAt(e);if(s>55295&&s<=56319){const i=(s-55296)*1024&65535;s=(n.charCodeAt(e+1)-56320&65535|i)+65536,e+=1}KW(s,t)}}function YW(n,t,e){if(t.utf8seq===0){if(n<=127){e(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){t.utf8seq=s;break}if(t.utf8seq===2)t.codepoint=n&31;else if(t.utf8seq===3)t.codepoint=n&15;else if(t.utf8seq===4)t.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");t.utf8seq-=1}else if(t.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");t.codepoint=t.codepoint<<6|n&63,t.utf8seq-=1,t.utf8seq===0&&e(t.codepoint)}}function Tc(n){const t=[],e={queue:0,queuedBits:0},s=i=>{t.push(i)};for(let i=0;i<n.length;i+=1)hR(n.charCodeAt(i),e,s);return new Uint8Array(t)}function JW(n){const t=[];return XW(n,e=>t.push(e)),new Uint8Array(t)}function Oa(n){const t=[],e={queue:0,queuedBits:0},s=i=>{t.push(i)};return n.forEach(i=>xI(i,e,s)),xI(null,e,s),t.join("")}function ZW(n){return Math.round(Date.now()/1e3)+n}function QW(){return Symbol("auth-callback")}const Gn=()=>typeof window<"u"&&typeof document<"u",va={tested:!1,writable:!1},dR=()=>{if(!Gn())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(va.tested)return va.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),va.tested=!0,va.writable=!0}catch{va.tested=!0,va.writable=!1}return va.writable};function tH(n){const t={},e=new URL(n);if(e.hash&&e.hash[0]==="#")try{new URLSearchParams(e.hash.substring(1)).forEach((i,r)=>{t[r]=i})}catch{}return e.searchParams.forEach((s,i)=>{t[i]=s}),t}const fR=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),eH=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",fc=async(n,t,e)=>{await n.setItem(t,JSON.stringify(e))},wa=async(n,t)=>{const e=await n.getItem(t);if(!e)return null;try{return JSON.parse(e)}catch{return e}},jn=async(n,t)=>{await n.removeItem(t)};class lg{constructor(){this.promise=new lg.promiseConstructor((t,e)=>{this.resolve=t,this.reject=e})}}lg.promiseConstructor=Promise;function Cx(n){const t=n.split(".");if(t.length!==3)throw new Ev("Invalid JWT structure");for(let s=0;s<t.length;s++)if(!BW.test(t[s]))throw new Ev("JWT not in base64url format");return{header:JSON.parse(vI(t[0])),payload:JSON.parse(vI(t[1])),signature:Tc(t[2]),raw:{header:t[0],payload:t[1]}}}async function nH(n){return await new Promise(t=>{setTimeout(()=>t(null),n)})}function sH(n,t){return new Promise((s,i)=>{(async()=>{for(let r=0;r<1/0;r++)try{const o=await n(r);if(!t(r,null,o)){s(o);return}}catch(o){if(!t(r,o)){i(o);return}}})()})}function iH(n){return("0"+n.toString(16)).substr(-2)}function rH(){const t=new Uint32Array(56);if(typeof crypto>"u"){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=e.length;let i="";for(let r=0;r<56;r++)i+=e.charAt(Math.floor(Math.random()*s));return i}return crypto.getRandomValues(t),Array.from(t,iH).join("")}async function oH(n){const e=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",e),i=new Uint8Array(s);return Array.from(i).map(r=>String.fromCharCode(r)).join("")}async function aH(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const e=await oH(n);return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function ic(n,t,e=!1){const s=rH();let i=s;e&&(i+="/PASSWORD_RECOVERY"),await fc(n,`${t}-code-verifier`,i);const r=await aH(s);return[r,s===r?"plain":"s256"]}const lH=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function cH(n){const t=n.headers.get(kv);if(!t||!t.match(lH))return null;try{return new Date(`${t}T00:00:00.0Z`)}catch{return null}}function uH(n){if(!n)throw new Error("Missing exp claim");const t=Math.floor(Date.now()/1e3);if(n<=t)throw new Error("JWT has expired")}function hH(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const dH=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function rc(n){if(!dH.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function Tx(){const n={};return new Proxy(n,{get:(t,e)=>{if(e==="__isUserNotAvailableProxy")return!0;if(typeof e=="symbol"){const s=e.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${e}" property of the session object is not supported. Please use getUser() instead.`)},set:(t,e)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${e}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(t,e)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${e}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function fH(n,t){return new Proxy(n,{get:(e,s,i)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const r=s.toString();if(r==="Symbol(Symbol.toPrimitive)"||r==="Symbol(Symbol.toStringTag)"||r==="Symbol(util.inspect.custom)"||r==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(e,s,i)}return!t.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),t.value=!0),Reflect.get(e,s,i)}})}function wI(n){return JSON.parse(JSON.stringify(n))}const ka=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),pH=[502,503,504];async function SI(n){var t;if(!eH(n))throw new $v(ka(n),0);if(pH.includes(n.status))throw new $v(ka(n),n.status);let e;try{e=await n.json()}catch(r){throw new Ia(ka(r),r)}let s;const i=cH(n);if(i&&i.getTime()>=uR["2024-01-01"].timestamp&&typeof e=="object"&&e&&typeof e.code=="string"?s=e.code:typeof e=="object"&&e&&typeof e.error_code=="string"&&(s=e.error_code),s){if(s==="weak_password")throw new yI(ka(e),n.status,((t=e.weak_password)===null||t===void 0?void 0:t.reasons)||[]);if(s==="session_not_found")throw new Us}else if(typeof e=="object"&&e&&typeof e.weak_password=="object"&&e.weak_password&&Array.isArray(e.weak_password.reasons)&&e.weak_password.reasons.length&&e.weak_password.reasons.reduce((r,o)=>r&&typeof o=="string",!0))throw new yI(ka(e),n.status,e.weak_password.reasons);throw new UW(ka(e),n.status||500,s)}const mH=(n,t,e,s)=>{const i={method:n,headers:t?.headers||{}};return n==="GET"?i:(i.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},t?.headers),i.body=JSON.stringify(s),Object.assign(Object.assign({},i),e))};async function Vt(n,t,e,s){var i;const r=Object.assign({},s?.headers);r[kv]||(r[kv]=uR["2024-01-01"].name),s?.jwt&&(r.Authorization=`Bearer ${s.jwt}`);const o=(i=s?.query)!==null&&i!==void 0?i:{};s?.redirectTo&&(o.redirect_to=s.redirectTo);const l=Object.keys(o).length?"?"+new URLSearchParams(o).toString():"",c=await gH(n,t,e+l,{headers:r,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(c):{data:Object.assign({},c),error:null}}async function gH(n,t,e,s,i,r){const o=mH(t,s,i,r);let l;try{l=await n(e,Object.assign({},o))}catch(c){throw console.error(c),new $v(ka(c),0)}if(l.ok||await SI(l),s?.noResolveJson)return l;try{return await l.json()}catch(c){await SI(c)}}function Ai(n){var t;let e=null;xH(n)&&(e=Object.assign({},n),n.expires_at||(e.expires_at=ZW(n.expires_in)));const s=(t=n.user)!==null&&t!==void 0?t:n;return{data:{session:e,user:s},error:null}}function CI(n){const t=Ai(n);return!t.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((e,s)=>e&&typeof s=="string",!0)&&(t.data.weak_password=n.weak_password),t}function $o(n){var t;return{data:{user:(t=n.user)!==null&&t!==void 0?t:n},error:null}}function yH(n){return{data:n,error:null}}function bH(n){const{action_link:t,email_otp:e,hashed_token:s,redirect_to:i,verification_type:r}=n,o=og(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),l={action_link:t,email_otp:e,hashed_token:s,redirect_to:i,verification_type:r},c=Object.assign({},o);return{data:{properties:l,user:c},error:null}}function TI(n){return n}function xH(n){return n.access_token&&n.refresh_token&&n.expires_in}const kx=["global","local","others"];class vH{constructor({url:t="",headers:e={},fetch:s}){this.url=t,this.headers=e,this.fetch=fR(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(t,e=kx[0]){if(kx.indexOf(e)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${kx.join(", ")}`);try{return await Vt(this.fetch,"POST",`${this.url}/logout?scope=${e}`,{headers:this.headers,jwt:t,noResolveJson:!0}),{data:null,error:null}}catch(s){if(Dt(s))return{data:null,error:s};throw s}}async inviteUserByEmail(t,e={}){try{return await Vt(this.fetch,"POST",`${this.url}/invite`,{body:{email:t,data:e.data},headers:this.headers,redirectTo:e.redirectTo,xform:$o})}catch(s){if(Dt(s))return{data:{user:null},error:s};throw s}}async generateLink(t){try{const{options:e}=t,s=og(t,["options"]),i=Object.assign(Object.assign({},s),e);return"newEmail"in s&&(i.new_email=s?.newEmail,delete i.newEmail),await Vt(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:i,headers:this.headers,xform:bH,redirectTo:e?.redirectTo})}catch(e){if(Dt(e))return{data:{properties:null,user:null},error:e};throw e}}async createUser(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/users`,{body:t,headers:this.headers,xform:$o})}catch(e){if(Dt(e))return{data:{user:null},error:e};throw e}}async listUsers(t){var e,s,i,r,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Vt(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&s!==void 0?s:"",per_page:(r=(i=t?.perPage)===null||i===void 0?void 0:i.toString())!==null&&r!==void 0?r:""},xform:TI});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Dt(h))return{data:{users:[]},error:h};throw h}}async getUserById(t){rc(t);try{return await Vt(this.fetch,"GET",`${this.url}/admin/users/${t}`,{headers:this.headers,xform:$o})}catch(e){if(Dt(e))return{data:{user:null},error:e};throw e}}async updateUserById(t,e){rc(t);try{return await Vt(this.fetch,"PUT",`${this.url}/admin/users/${t}`,{body:e,headers:this.headers,xform:$o})}catch(s){if(Dt(s))return{data:{user:null},error:s};throw s}}async deleteUser(t,e=!1){rc(t);try{return await Vt(this.fetch,"DELETE",`${this.url}/admin/users/${t}`,{headers:this.headers,body:{should_soft_delete:e},xform:$o})}catch(s){if(Dt(s))return{data:{user:null},error:s};throw s}}async _listFactors(t){rc(t.userId);try{const{data:e,error:s}=await Vt(this.fetch,"GET",`${this.url}/admin/users/${t.userId}/factors`,{headers:this.headers,xform:i=>({data:{factors:i},error:null})});return{data:e,error:s}}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _deleteFactor(t){rc(t.userId),rc(t.id);try{return{data:await Vt(this.fetch,"DELETE",`${this.url}/admin/users/${t.userId}/factors/${t.id}`,{headers:this.headers}),error:null}}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _listOAuthClients(t){var e,s,i,r,o,l,c;try{const h={nextPage:null,lastPage:0,total:0},d=await Vt(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(e=t?.page)===null||e===void 0?void 0:e.toString())!==null&&s!==void 0?s:"",per_page:(r=(i=t?.perPage)===null||i===void 0?void 0:i.toString())!==null&&r!==void 0?r:""},xform:TI});if(d.error)throw d.error;const p=await d.json(),m=(o=d.headers.get("x-total-count"))!==null&&o!==void 0?o:0,y=(c=(l=d.headers.get("link"))===null||l===void 0?void 0:l.split(","))!==null&&c!==void 0?c:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},p),h),error:null}}catch(h){if(Dt(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:t,headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _getOAuthClient(t){try{return await Vt(this.fetch,"GET",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _updateOAuthClient(t,e){try{return await Vt(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${t}`,{body:e,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(Dt(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(t){try{return await Vt(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${t}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(e){if(Dt(e))return{data:null,error:e};throw e}}async _regenerateOAuthClientSecret(t){try{return await Vt(this.fetch,"POST",`${this.url}/admin/oauth/clients/${t}/regenerate_secret`,{headers:this.headers,xform:e=>({data:e,error:null})})}catch(e){if(Dt(e))return{data:null,error:e};throw e}}}function kI(n={}){return{getItem:t=>n[t]||null,setItem:(t,e)=>{n[t]=e},removeItem:t=>{delete n[t]}}}const oc={debug:!!(globalThis&&dR()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class pR extends Error{constructor(t){super(t),this.isAcquireTimeout=!0}}class wH extends pR{}async function SH(n,t,e){oc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,t);const s=new globalThis.AbortController;return t>0&&setTimeout(()=>{s.abort(),oc.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},t),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,t===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async i=>{if(i){oc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,i.name);try{return await e()}finally{oc.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,i.name)}}else{if(t===0)throw oc.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new wH(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(oc.debug)try{const r=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(r,null,"  "))}catch(r){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",r)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await e()}}))}function CH(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function mR(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function TH(n){return parseInt(n,16)}function kH(n){const t=new TextEncoder().encode(n);return"0x"+Array.from(t,s=>s.toString(16).padStart(2,"0")).join("")}function $H(n){var t;const{chainId:e,domain:s,expirationTime:i,issuedAt:r=new Date,nonce:o,notBefore:l,requestId:c,resources:h,scheme:d,uri:p,version:m}=n;{if(!Number.isInteger(e))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${e}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(o&&o.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);if(!p)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((t=n.statement)===null||t===void 0)&&t.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=mR(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let S=`URI: ${p}
Version: ${m}
Chain ID: ${e}${o?`
Nonce: ${o}`:""}
Issued At: ${r.toISOString()}`;if(i&&(S+=`
Expiration Time: ${i.toISOString()}`),l&&(S+=`
Not Before: ${l.toISOString()}`),c&&(S+=`
Request ID: ${c}`),h){let T=`
Resources:`;for(const k of h){if(!k||typeof k!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${k}`);T+=`
- ${k}`}S+=T}return`${w}
${S}`}class pn extends Error{constructor({message:t,code:e,cause:s,name:i}){var r;super(t,{cause:s}),this.__isWebAuthnError=!0,this.name=(r=i??(s instanceof Error?s.name:void 0))!==null&&r!==void 0?r:"Unknown Error",this.code=e}}class Tm extends pn{constructor(t,e){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e,message:t}),this.name="WebAuthnUnknownError",this.originalError=e}}function EH({error:n,options:t}){var e,s,i;const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(t.signal instanceof AbortSignal)return new pn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((e=r.authenticatorSelection)===null||e===void 0?void 0:e.requireResidentKey)===!0)return new pn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(t.mediation==="conditional"&&((s=r.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new pn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((i=r.authenticatorSelection)===null||i===void 0?void 0:i.userVerification)==="required")return new pn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new pn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new pn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return r.pubKeyCredParams.filter(l=>l.type==="public-key").length===0?new pn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new pn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const o=window.location.hostname;if(gR(o)){if(r.rp.id!==o)return new pn({message:`The RP ID "${r.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new pn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(r.user.id.byteLength<1||r.user.id.byteLength>64)return new pn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new pn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new pn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function IH({error:n,options:t}){const{publicKey:e}=t;if(!e)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(t.signal instanceof AbortSignal)return new pn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new pn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(gR(s)){if(e.rpId!==s)return new pn({message:`The RP ID "${e.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new pn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new pn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new pn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class NH{createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const AH=new NH;function _H(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:t,user:e,excludeCredentials:s}=n,i=og(n,["challenge","user","excludeCredentials"]),r=Tc(t).buffer,o=Object.assign(Object.assign({},e),{id:Tc(e.id).buffer}),l=Object.assign(Object.assign({},i),{challenge:r,user:o});if(s&&s.length>0){l.excludeCredentials=new Array(s.length);for(let c=0;c<s.length;c++){const h=s[c];l.excludeCredentials[c]=Object.assign(Object.assign({},h),{id:Tc(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return l}function RH(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:t,allowCredentials:e}=n,s=og(n,["challenge","allowCredentials"]),i=Tc(t).buffer,r=Object.assign(Object.assign({},s),{challenge:i});if(e&&e.length>0){r.allowCredentials=new Array(e.length);for(let o=0;o<e.length;o++){const l=e[o];r.allowCredentials[o]=Object.assign(Object.assign({},l),{id:Tc(l.id).buffer,type:l.type||"public-key",transports:l.transports})}}return r}function DH(n){var t;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const e=n;return{id:n.id,rawId:n.id,response:{attestationObject:Oa(new Uint8Array(n.response.attestationObject)),clientDataJSON:Oa(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(t=e.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function OH(n){var t;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const e=n,s=n.getClientExtensionResults(),i=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:Oa(new Uint8Array(i.authenticatorData)),clientDataJSON:Oa(new Uint8Array(i.clientDataJSON)),signature:Oa(new Uint8Array(i.signature)),userHandle:i.userHandle?Oa(new Uint8Array(i.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(t=e.authenticatorAttachment)!==null&&t!==void 0?t:void 0}}function gR(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function $I(){var n,t;return!!(Gn()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((t=navigator?.credentials)===null||t===void 0?void 0:t.get)=="function")}async function MH(n){try{const t=await navigator.credentials.create(n);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new Tm("Browser returned unexpected credential type",t)}:{data:null,error:new Tm("Empty credential response",t)}}catch(t){return{data:null,error:EH({error:t,options:n})}}}async function FH(n){try{const t=await navigator.credentials.get(n);return t?t instanceof PublicKeyCredential?{data:t,error:null}:{data:null,error:new Tm("Browser returned unexpected credential type",t)}:{data:null,error:new Tm("Empty credential response",t)}}catch(t){return{data:null,error:IH({error:t,options:n})}}}const LH={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},zH={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function km(...n){const t=i=>i!==null&&typeof i=="object"&&!Array.isArray(i),e=i=>i instanceof ArrayBuffer||ArrayBuffer.isView(i),s={};for(const i of n)if(i)for(const r in i){const o=i[r];if(o!==void 0)if(Array.isArray(o))s[r]=o;else if(e(o))s[r]=o;else if(t(o)){const l=s[r];t(l)?s[r]=km(l,o):s[r]=km(o)}else s[r]=o}return s}function PH(n,t){return km(LH,n,t||{})}function BH(n,t){return km(zH,n,t||{})}class VH{constructor(t){this.client=t,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(t){return this.client.mfa.enroll(Object.assign(Object.assign({},t),{factorType:"webauthn"}))}async _challenge({factorId:t,webauthn:e,friendlyName:s,signal:i},r){try{const{data:o,error:l}=await this.client.mfa.challenge({factorId:t,webauthn:e});if(!o)return{data:null,error:l};const c=i??AH.createNewAbortSignal();if(o.webauthn.type==="create"){const{user:h}=o.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(o.webauthn.type){case"create":{const h=PH(o.webauthn.credential_options.publicKey,r?.create),{data:d,error:p}=await MH({publicKey:h,signal:c});return d?{data:{factorId:t,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}case"request":{const h=BH(o.webauthn.credential_options.publicKey,r?.request),{data:d,error:p}=await FH(Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:h,signal:c}));return d?{data:{factorId:t,challengeId:o.id,webauthn:{type:o.webauthn.type,credential_response:d}},error:null}:{data:null,error:p}}}}catch(o){return Dt(o)?{data:null,error:o}:{data:null,error:new Ia("Unexpected error in challenge",o)}}}async _verify({challengeId:t,factorId:e,webauthn:s}){return this.client.mfa.verify({factorId:e,challengeId:t,webauthn:s})}async _authenticate({factorId:t,webauthn:{rpId:e=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:i}={}},r){if(!e)return{data:null,error:new Rh("rpId is required for WebAuthn authentication")};try{if(!$I())return{data:null,error:new Ia("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this.challenge({factorId:t,webauthn:{rpId:e,rpOrigins:s},signal:i},{request:r});if(!o)return{data:null,error:l};const{webauthn:c}=o;return this._verify({factorId:t,challengeId:o.challengeId,webauthn:{type:c.type,rpId:e,rpOrigins:s,credential_response:c.credential_response}})}catch(o){return Dt(o)?{data:null,error:o}:{data:null,error:new Ia("Unexpected error in authenticate",o)}}}async _register({friendlyName:t,webauthn:{rpId:e=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:i}={}},r){if(!e)return{data:null,error:new Rh("rpId is required for WebAuthn registration")};try{if(!$I())return{data:null,error:new Ia("Browser does not support WebAuthn",null)};const{data:o,error:l}=await this._enroll({friendlyName:t});if(!o)return await this.client.mfa.listFactors().then(d=>{var p;return(p=d.data)===null||p===void 0?void 0:p.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===t&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:l};const{data:c,error:h}=await this._challenge({factorId:o.id,friendlyName:o.friendly_name,webauthn:{rpId:e,rpOrigins:s},signal:i},{create:r});return c?this._verify({factorId:o.id,challengeId:c.challengeId,webauthn:{rpId:e,rpOrigins:s,type:c.webauthn.type,credential_response:c.webauthn.credential_response}}):{data:null,error:h}}catch(o){return Dt(o)?{data:null,error:o}:{data:null,error:new Ia("Unexpected error in register",o)}}}}CH();const UH={url:LW,storageKey:zW,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:PW,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function EI(n,t,e){return await e()}const ac={};class Dh{get jwks(){var t,e;return(e=(t=ac[this.storageKey])===null||t===void 0?void 0:t.jwks)!==null&&e!==void 0?e:{keys:[]}}set jwks(t){ac[this.storageKey]=Object.assign(Object.assign({},ac[this.storageKey]),{jwks:t})}get jwks_cached_at(){var t,e;return(e=(t=ac[this.storageKey])===null||t===void 0?void 0:t.cachedAt)!==null&&e!==void 0?e:Number.MIN_SAFE_INTEGER}set jwks_cached_at(t){ac[this.storageKey]=Object.assign(Object.assign({},ac[this.storageKey]),{cachedAt:t})}constructor(t){var e,s,i;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const r=Object.assign(Object.assign({},UH),t);if(this.storageKey=r.storageKey,this.instanceID=(e=Dh.nextInstanceID[this.storageKey])!==null&&e!==void 0?e:0,Dh.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!r.debug,typeof r.debug=="function"&&(this.logger=r.debug),this.instanceID>0&&Gn()){const o=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(o),this.logDebugMessages&&console.trace(o)}if(this.persistSession=r.persistSession,this.autoRefreshToken=r.autoRefreshToken,this.admin=new vH({url:r.url,headers:r.headers,fetch:r.fetch}),this.url=r.url,this.headers=r.headers,this.fetch=fR(r.fetch),this.lock=r.lock||EI,this.detectSessionInUrl=r.detectSessionInUrl,this.flowType=r.flowType,this.hasCustomAuthorizationHeader=r.hasCustomAuthorizationHeader,this.throwOnError=r.throwOnError,r.lock?this.lock=r.lock:this.persistSession&&Gn()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=SH:this.lock=EI,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new VH(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(r.storage?this.storage=r.storage:dR()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=kI(this.memoryStorage)),r.userStorage&&(this.userStorage=r.userStorage)):(this.memoryStorage={},this.storage=kI(this.memoryStorage)),Gn()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(o){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",o)}(i=this.broadcastChannel)===null||i===void 0||i.addEventListener("message",async o=>{this._debug("received broadcast notification from other tab or client",o),await this._notifyAllSubscribers(o.data.event,o.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(t){if(this.throwOnError&&t&&t.error)throw t.error;return t}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${cR}) ${new Date().toISOString()}`}_debug(...t){return this.logDebugMessages&&this.logger(this._logPrefix(),...t),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var t;try{let e={},s="none";if(Gn()&&(e=tH(window.location.href),this._isImplicitGrantCallback(e)?s="implicit":await this._isPKCECallback(e)&&(s="pkce")),Gn()&&this.detectSessionInUrl&&s!=="none"){const{data:i,error:r}=await this._getSessionFromURL(e,s);if(r){if(this._debug("#_initialize()","error detecting session from URL",r),WW(r)){const c=(t=r.details)===null||t===void 0?void 0:t.code;if(c==="identity_already_exists"||c==="identity_not_found"||c==="single_identity_not_deletable")return{error:r}}return await this._removeSession(),{error:r}}const{session:o,redirectType:l}=i;return this._debug("#_initialize()","detected session in URL",o,"redirect type",l),await this._saveSession(o),setTimeout(async()=>{l==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",o):await this._notifyAllSubscribers("SIGNED_IN",o)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(e){return Dt(e)?this._returnResult({error:e}):this._returnResult({error:new Ia("Unexpected error during initialization",e)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(t){var e,s,i;try{const r=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(e=t?.options)===null||e===void 0?void 0:e.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(i=t?.options)===null||i===void 0?void 0:i.captchaToken}},xform:Ai}),{data:o,error:l}=r;if(l||!o)return this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(r){if(Dt(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signUp(t){var e,s,i;try{let r;if("email"in t){const{email:d,password:p,options:m}=t;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await ic(this.storage,this.storageKey)),r=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:p,data:(e=m?.data)!==null&&e!==void 0?e:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:Ai})}else if("phone"in t){const{phone:d,password:p,options:m}=t;r=await Vt(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:p,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(i=m?.channel)!==null&&i!==void 0?i:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:Ai})}else throw new jp("You must provide either an email or phone number and a password");const{data:o,error:l}=r;if(l||!o)return await jn(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:l});const c=o.session,h=o.user;return o.session&&(await this._saveSession(o.session),await this._notifyAllSubscribers("SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(r){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithPassword(t){try{let e;if("email"in t){const{email:r,password:o,options:l}=t;e=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:r,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:CI})}else if("phone"in t){const{phone:r,password:o,options:l}=t;e=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:r,password:o,gotrue_meta_security:{captcha_token:l?.captchaToken}},xform:CI})}else throw new jp("You must provide either an email or phone number and a password");const{data:s,error:i}=e;if(i)return this._returnResult({data:{user:null,session:null},error:i});if(!s||!s.session||!s.user){const r=new sc;return this._returnResult({data:{user:null,session:null},error:r})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:i})}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async signInWithOAuth(t){var e,s,i,r;return await this._handleProviderSignIn(t.provider,{redirectTo:(e=t.options)===null||e===void 0?void 0:e.redirectTo,scopes:(s=t.options)===null||s===void 0?void 0:s.scopes,queryParams:(i=t.options)===null||i===void 0?void 0:i.queryParams,skipBrowserRedirect:(r=t.options)===null||r===void 0?void 0:r.skipBrowserRedirect})}async exchangeCodeForSession(t){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(t))}async signInWithWeb3(t){const{chain:e}=t;switch(e){case"ethereum":return await this.signInWithEthereum(t);case"solana":return await this.signInWithSolana(t);default:throw new Error(`@supabase/auth-js: Unsupported chain "${e}"`)}}async signInWithEthereum(t){var e,s,i,r,o,l,c,h,d,p,m;let y,b;if("message"in t)y=t.message,b=t.signature;else{const{chain:x,wallet:w,statement:S,options:T}=t;let k;if(Gn())if(typeof w=="object")k=w;else{const D=window;if("ethereum"in D&&typeof D.ethereum=="object"&&"request"in D.ethereum&&typeof D.ethereum.request=="function")k=D.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!T?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=w}const $=new URL((e=T?.url)!==null&&e!==void 0?e:window.location.href),E=await k.request({method:"eth_requestAccounts"}).then(D=>D).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const N=mR(E[0]);let _=(s=T?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!_){const D=await k.request({method:"eth_chainId"});_=TH(D)}const R={domain:$.host,address:N,statement:S,uri:$.href,version:"1",chainId:_,nonce:(i=T?.signInWithEthereum)===null||i===void 0?void 0:i.nonce,issuedAt:(o=(r=T?.signInWithEthereum)===null||r===void 0?void 0:r.issuedAt)!==null&&o!==void 0?o:new Date,expirationTime:(l=T?.signInWithEthereum)===null||l===void 0?void 0:l.expirationTime,notBefore:(c=T?.signInWithEthereum)===null||c===void 0?void 0:c.notBefore,requestId:(h=T?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=T?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=$H(R),b=await k.request({method:"personal_sign",params:[kH(y),N]})}try{const{data:x,error:w}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((p=t.options)===null||p===void 0)&&p.captchaToken?{gotrue_meta_security:{captcha_token:(m=t.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:Ai});if(w)throw w;if(!x||!x.session||!x.user){const S=new sc;return this._returnResult({data:{user:null,session:null},error:S})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(Dt(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(t){var e,s,i,r,o,l,c,h,d,p,m,y;let b,x;if("message"in t)b=t.message,x=t.signature;else{const{chain:w,wallet:S,statement:T,options:k}=t;let $;if(Gn())if(typeof S=="object")$=S;else{const N=window;if("solana"in N&&typeof N.solana=="object"&&("signIn"in N.solana&&typeof N.solana.signIn=="function"||"signMessage"in N.solana&&typeof N.solana.signMessage=="function"))$=N.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof S!="object"||!k?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");$=S}const E=new URL((e=k?.url)!==null&&e!==void 0?e:window.location.href);if("signIn"in $&&$.signIn){const N=await $.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},k?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),T?{statement:T}:null));let _;if(Array.isArray(N)&&N[0]&&typeof N[0]=="object")_=N[0];else if(N&&typeof N=="object"&&"signedMessage"in N&&"signature"in N)_=N;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in _&&"signature"in _&&(typeof _.signedMessage=="string"||_.signedMessage instanceof Uint8Array)&&_.signature instanceof Uint8Array)b=typeof _.signedMessage=="string"?_.signedMessage:new TextDecoder().decode(_.signedMessage),x=_.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in $)||typeof $.signMessage!="function"||!("publicKey"in $)||typeof $!="object"||!$.publicKey||!("toBase58"in $.publicKey)||typeof $.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,$.publicKey.toBase58(),...T?["",T,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(i=(s=k?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&i!==void 0?i:new Date().toISOString()}`,...!((r=k?.signInWithSolana)===null||r===void 0)&&r.notBefore?[`Not Before: ${k.signInWithSolana.notBefore}`]:[],...!((o=k?.signInWithSolana)===null||o===void 0)&&o.expirationTime?[`Expiration Time: ${k.signInWithSolana.expirationTime}`]:[],...!((l=k?.signInWithSolana)===null||l===void 0)&&l.chainId?[`Chain ID: ${k.signInWithSolana.chainId}`]:[],...!((c=k?.signInWithSolana)===null||c===void 0)&&c.nonce?[`Nonce: ${k.signInWithSolana.nonce}`]:[],...!((h=k?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${k.signInWithSolana.requestId}`]:[],...!((p=(d=k?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||p===void 0)&&p.length?["Resources",...k.signInWithSolana.resources.map(_=>`- ${_}`)]:[]].join(`
`);const N=await $.signMessage(new TextEncoder().encode(b),"utf8");if(!N||!(N instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=N}}try{const{data:w,error:S}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:Oa(x)},!((m=t.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=t.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:Ai});if(S)throw S;if(!w||!w.session||!w.user){const T=new sc;return this._returnResult({data:{user:null,session:null},error:T})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:S})}catch(w){if(Dt(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(t){const e=await wa(this.storage,`${this.storageKey}-code-verifier`),[s,i]=(e??"").split("/");try{if(!s&&this.flowType==="pkce")throw new HW;const{data:r,error:o}=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:t,code_verifier:s},xform:Ai});if(await jn(this.storage,`${this.storageKey}-code-verifier`),o)throw o;if(!r||!r.session||!r.user){const l=new sc;return this._returnResult({data:{user:null,session:null,redirectType:null},error:l})}return r.session&&(await this._saveSession(r.session),await this._notifyAllSubscribers("SIGNED_IN",r.session)),this._returnResult({data:Object.assign(Object.assign({},r),{redirectType:i??null}),error:o})}catch(r){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(r))return this._returnResult({data:{user:null,session:null,redirectType:null},error:r});throw r}}async signInWithIdToken(t){try{const{options:e,provider:s,token:i,access_token:r,nonce:o}=t,l=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:i,access_token:r,nonce:o,gotrue_meta_security:{captcha_token:e?.captchaToken}},xform:Ai}),{data:c,error:h}=l;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!c||!c.session||!c.user){const d=new sc;return this._returnResult({data:{user:null,session:null},error:d})}return c.session&&(await this._saveSession(c.session),await this._notifyAllSubscribers("SIGNED_IN",c.session)),this._returnResult({data:c,error:h})}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async signInWithOtp(t){var e,s,i,r,o;try{if("email"in t){const{email:l,options:c}=t;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await ic(this.storage,this.storageKey));const{error:p}=await Vt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:l,data:(e=c?.data)!==null&&e!==void 0?e:{},create_user:(s=c?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:c?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:p})}if("phone"in t){const{phone:l,options:c}=t,{data:h,error:d}=await Vt(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:l,data:(i=c?.data)!==null&&i!==void 0?i:{},create_user:(r=c?.shouldCreateUser)!==null&&r!==void 0?r:!0,gotrue_meta_security:{captcha_token:c?.captchaToken},channel:(o=c?.channel)!==null&&o!==void 0?o:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new jp("You must provide either an email or phone number.")}catch(l){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(l))return this._returnResult({data:{user:null,session:null},error:l});throw l}}async verifyOtp(t){var e,s;try{let i,r;"options"in t&&(i=(e=t.options)===null||e===void 0?void 0:e.redirectTo,r=(s=t.options)===null||s===void 0?void 0:s.captchaToken);const{data:o,error:l}=await Vt(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},t),{gotrue_meta_security:{captcha_token:r}}),redirectTo:i,xform:Ai});if(l)throw l;if(!o)throw new Error("An error occurred on token verification.");const c=o.session,h=o.user;return c?.access_token&&(await this._saveSession(c),await this._notifyAllSubscribers(t.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",c)),this._returnResult({data:{user:h,session:c},error:null})}catch(i){if(Dt(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}}async signInWithSSO(t){var e,s,i,r,o;try{let l=null,c=null;this.flowType==="pkce"&&([l,c]=await ic(this.storage,this.storageKey));const h=await Vt(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in t?{provider_id:t.providerId}:null),"domain"in t?{domain:t.domain}:null),{redirect_to:(s=(e=t.options)===null||e===void 0?void 0:e.redirectTo)!==null&&s!==void 0?s:void 0}),!((i=t?.options)===null||i===void 0)&&i.captchaToken?{gotrue_meta_security:{captcha_token:t.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:l,code_challenge_method:c}),headers:this.headers,xform:yH});return!((r=h.data)===null||r===void 0)&&r.url&&Gn()&&!(!((o=t.options)===null||o===void 0)&&o.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(l){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(l))return this._returnResult({data:null,error:l});throw l}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async t=>{const{data:{session:e},error:s}=t;if(s)throw s;if(!e)throw new Us;const{error:i}=await Vt(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:e.access_token});return this._returnResult({data:{user:null,session:null},error:i})})}catch(t){if(Dt(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async resend(t){try{const e=`${this.url}/resend`;if("email"in t){const{email:s,type:i,options:r}=t,{error:o}=await Vt(this.fetch,"POST",e,{headers:this.headers,body:{email:s,type:i,gotrue_meta_security:{captcha_token:r?.captchaToken}},redirectTo:r?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:o})}else if("phone"in t){const{phone:s,type:i,options:r}=t,{data:o,error:l}=await Vt(this.fetch,"POST",e,{headers:this.headers,body:{phone:s,type:i,gotrue_meta_security:{captcha_token:r?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:o?.message_id},error:l})}throw new jp("You must provide either an email or phone number and a type")}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async e=>e))}async _acquireLock(t,e){this._debug("#_acquireLock","begin",t);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),i=(async()=>(await s,await e()))();return this.pendingInLock.push((async()=>{try{await i}catch{}})()),i}return await this.lock(`lock:${this.storageKey}`,t,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=e();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const i=[...this.pendingInLock];await Promise.all(i),this.pendingInLock.splice(0,i.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(t){this._debug("#_useSession","begin");try{const e=await this.__loadSession();return await t(e)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let t=null;const e=await wa(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",e),e!==null&&(this._isValidSession(e)?t=e:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!t)return{data:{session:null},error:null};const s=t.expires_at?t.expires_at*1e3-Date.now()<wx:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",t.expires_at),!s){if(this.userStorage){const o=await wa(this.userStorage,this.storageKey+"-user");o?.user?t.user=o.user:t.user=Tx()}if(this.storage.isServer&&t.user&&!t.user.__isUserNotAvailableProxy){const o={value:this.suppressGetSessionWarning};t.user=fH(t.user,o),o.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:t},error:null}}const{data:i,error:r}=await this._callRefreshToken(t.refresh_token);return r?this._returnResult({data:{session:null},error:r}):this._returnResult({data:{session:i},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(t){if(t)return await this._getUser(t);await this.initializePromise;const e=await this._acquireLock(-1,async()=>await this._getUser());return e.data.user&&(this.suppressGetSessionWarning=!0),e}async _getUser(t){try{return t?await Vt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:t,xform:$o}):await this._useSession(async e=>{var s,i,r;const{data:o,error:l}=e;if(l)throw l;return!(!((s=o.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new Us}:await Vt(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(r=(i=o.session)===null||i===void 0?void 0:i.access_token)!==null&&r!==void 0?r:void 0,xform:$o})})}catch(e){if(Dt(e))return GW(e)&&(await this._removeSession(),await jn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:e});throw e}}async updateUser(t,e={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(t,e))}async _updateUser(t,e={}){try{return await this._useSession(async s=>{const{data:i,error:r}=s;if(r)throw r;if(!i.session)throw new Us;const o=i.session;let l=null,c=null;this.flowType==="pkce"&&t.email!=null&&([l,c]=await ic(this.storage,this.storageKey));const{data:h,error:d}=await Vt(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:e?.emailRedirectTo,body:Object.assign(Object.assign({},t),{code_challenge:l,code_challenge_method:c}),jwt:o.access_token,xform:$o});if(d)throw d;return o.user=h.user,await this._saveSession(o),await this._notifyAllSubscribers("USER_UPDATED",o),this._returnResult({data:{user:o.user},error:null})})}catch(s){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(t))}async _setSession(t){try{if(!t.access_token||!t.refresh_token)throw new Us;const e=Date.now()/1e3;let s=e,i=!0,r=null;const{payload:o}=Cx(t.access_token);if(o.exp&&(s=o.exp,i=s<=e),i){const{data:l,error:c}=await this._callRefreshToken(t.refresh_token);if(c)return this._returnResult({data:{user:null,session:null},error:c});if(!l)return{data:{user:null,session:null},error:null};r=l}else{const{data:l,error:c}=await this._getUser(t.access_token);if(c)throw c;r={access_token:t.access_token,refresh_token:t.refresh_token,user:l.user,token_type:"bearer",expires_in:s-e,expires_at:s},await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)}return this._returnResult({data:{user:r.user,session:r},error:null})}catch(e){if(Dt(e))return this._returnResult({data:{session:null,user:null},error:e});throw e}}async refreshSession(t){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(t))}async _refreshSession(t){try{return await this._useSession(async e=>{var s;if(!t){const{data:o,error:l}=e;if(l)throw l;t=(s=o.session)!==null&&s!==void 0?s:void 0}if(!t?.refresh_token)throw new Us;const{data:i,error:r}=await this._callRefreshToken(t.refresh_token);return r?this._returnResult({data:{user:null,session:null},error:r}):i?this._returnResult({data:{user:i.user,session:i},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(e){if(Dt(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async _getSessionFromURL(t,e){try{if(!Gn())throw new Gp("No browser detected.");if(t.error||t.error_description||t.error_code)throw new Gp(t.error_description||"Error in URL with unspecified error_description",{error:t.error||"unspecified_error",code:t.error_code||"unspecified_code"});switch(e){case"implicit":if(this.flowType==="pkce")throw new gI("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Gp("Not a valid implicit grant flow url.");break;default:}if(e==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!t.code)throw new gI("No code detected.");const{data:T,error:k}=await this._exchangeCodeForSession(t.code);if(k)throw k;const $=new URL(window.location.href);return $.searchParams.delete("code"),window.history.replaceState(window.history.state,"",$.toString()),{data:{session:T.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:i,access_token:r,refresh_token:o,expires_in:l,expires_at:c,token_type:h}=t;if(!r||!l||!o||!h)throw new Gp("No session defined in URL");const d=Math.round(Date.now()/1e3),p=parseInt(l);let m=d+p;c&&(m=parseInt(c));const y=m-d;y*1e3<=dc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${p}s`);const b=m-p;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(r);if(w)throw w;const S={provider_token:s,provider_refresh_token:i,access_token:r,expires_in:p,expires_at:m,refresh_token:o,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:S,redirectType:t.type},error:null})}catch(s){if(Dt(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(t){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),t):!!(t.access_token||t.error_description)}async _isPKCECallback(t){const e=await wa(this.storage,`${this.storageKey}-code-verifier`);return!!(t.code&&e)}async signOut(t={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(t))}async _signOut({scope:t}={scope:"global"}){return await this._useSession(async e=>{var s;const{data:i,error:r}=e;if(r)return this._returnResult({error:r});const o=(s=i.session)===null||s===void 0?void 0:s.access_token;if(o){const{error:l}=await this.admin.signOut(o,t);if(l&&!(jW(l)&&(l.status===404||l.status===401||l.status===403)))return this._returnResult({error:l})}return t!=="others"&&(await this._removeSession(),await jn(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(t){const e=QW(),s={id:e,callback:t,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",e),this.stateChangeEmitters.delete(e)}};return this._debug("#onAuthStateChange()","registered callback with id",e),this.stateChangeEmitters.set(e,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(e)})))(),{data:{subscription:s}}}async _emitInitialSession(t){return await this._useSession(async e=>{var s,i;try{const{data:{session:r},error:o}=e;if(o)throw o;await((s=this.stateChangeEmitters.get(t))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",r)),this._debug("INITIAL_SESSION","callback id",t,"session",r)}catch(r){await((i=this.stateChangeEmitters.get(t))===null||i===void 0?void 0:i.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",t,"error",r),console.error(r)}})}async resetPasswordForEmail(t,e={}){let s=null,i=null;this.flowType==="pkce"&&([s,i]=await ic(this.storage,this.storageKey,!0));try{return await Vt(this.fetch,"POST",`${this.url}/recover`,{body:{email:t,code_challenge:s,code_challenge_method:i,gotrue_meta_security:{captcha_token:e.captchaToken}},headers:this.headers,redirectTo:e.redirectTo})}catch(r){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(r))return this._returnResult({data:null,error:r});throw r}}async getUserIdentities(){var t;try{const{data:e,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(t=e.user.identities)!==null&&t!==void 0?t:[]},error:null})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async linkIdentity(t){return"token"in t?this.linkIdentityIdToken(t):this.linkIdentityOAuth(t)}async linkIdentityOAuth(t){var e;try{const{data:s,error:i}=await this._useSession(async r=>{var o,l,c,h,d;const{data:p,error:m}=r;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,t.provider,{redirectTo:(o=t.options)===null||o===void 0?void 0:o.redirectTo,scopes:(l=t.options)===null||l===void 0?void 0:l.scopes,queryParams:(c=t.options)===null||c===void 0?void 0:c.queryParams,skipBrowserRedirect:!0});return await Vt(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=p.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(i)throw i;return Gn()&&!(!((e=t.options)===null||e===void 0)&&e.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:t.provider,url:s?.url},error:null})}catch(s){if(Dt(s))return this._returnResult({data:{provider:t.provider,url:null},error:s});throw s}}async linkIdentityIdToken(t){return await this._useSession(async e=>{var s;try{const{error:i,data:{session:r}}=e;if(i)throw i;const{options:o,provider:l,token:c,access_token:h,nonce:d}=t,p=await Vt(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=r?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:l,id_token:c,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:Ai}),{data:m,error:y}=p;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new sc}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(i){if(await jn(this.storage,`${this.storageKey}-code-verifier`),Dt(i))return this._returnResult({data:{user:null,session:null},error:i});throw i}})}async unlinkIdentity(t){try{return await this._useSession(async e=>{var s,i;const{data:r,error:o}=e;if(o)throw o;return await Vt(this.fetch,"DELETE",`${this.url}/user/identities/${t.identity_id}`,{headers:this.headers,jwt:(i=(s=r.session)===null||s===void 0?void 0:s.access_token)!==null&&i!==void 0?i:void 0})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _refreshAccessToken(t){const e=`#_refreshAccessToken(${t.substring(0,5)}...)`;this._debug(e,"begin");try{const s=Date.now();return await sH(async i=>(i>0&&await nH(200*Math.pow(2,i-1)),this._debug(e,"refreshing attempt",i),await Vt(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:t},headers:this.headers,xform:Ai})),(i,r)=>{const o=200*Math.pow(2,i);return r&&Sx(r)&&Date.now()+o-s<dc})}catch(s){if(this._debug(e,"error",s),Dt(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(e,"end")}}_isValidSession(t){return typeof t=="object"&&t!==null&&"access_token"in t&&"refresh_token"in t&&"expires_at"in t}async _handleProviderSignIn(t,e){const s=await this._getUrlForProvider(`${this.url}/authorize`,t,{redirectTo:e.redirectTo,scopes:e.scopes,queryParams:e.queryParams});return this._debug("#_handleProviderSignIn()","provider",t,"options",e,"url",s),Gn()&&!e.skipBrowserRedirect&&window.location.assign(s),{data:{provider:t,url:s},error:null}}async _recoverAndRefresh(){var t,e;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const i=await wa(this.storage,this.storageKey);if(i&&this.userStorage){let o=await wa(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!o&&(o={user:i.user},await fc(this.userStorage,this.storageKey+"-user",o)),i.user=(t=o?.user)!==null&&t!==void 0?t:Tx()}else if(i&&!i.user&&!i.user){const o=await wa(this.storage,this.storageKey+"-user");o&&o?.user?(i.user=o.user,await jn(this.storage,this.storageKey+"-user"),await fc(this.storage,this.storageKey,i)):i.user=Tx()}if(this._debug(s,"session from storage",i),!this._isValidSession(i)){this._debug(s,"session is not valid"),i!==null&&await this._removeSession();return}const r=((e=i.expires_at)!==null&&e!==void 0?e:1/0)*1e3-Date.now()<wx;if(this._debug(s,`session has${r?"":" not"} expired with margin of ${wx}s`),r){if(this.autoRefreshToken&&i.refresh_token){const{error:o}=await this._callRefreshToken(i.refresh_token);o&&(console.error(o),Sx(o)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",o),await this._removeSession()))}}else if(i.user&&i.user.__isUserNotAvailableProxy===!0)try{const{data:o,error:l}=await this._getUser(i.access_token);!l&&o?.user?(i.user=o.user,await this._saveSession(i),await this._notifyAllSubscribers("SIGNED_IN",i)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(o){console.error("Error getting user data:",o),this._debug(s,"error getting user data, skipping SIGNED_IN notification",o)}else await this._notifyAllSubscribers("SIGNED_IN",i)}catch(i){this._debug(s,"error",i),console.error(i);return}finally{this._debug(s,"end")}}async _callRefreshToken(t){var e,s;if(!t)throw new Us;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const i=`#_callRefreshToken(${t.substring(0,5)}...)`;this._debug(i,"begin");try{this.refreshingDeferred=new lg;const{data:r,error:o}=await this._refreshAccessToken(t);if(o)throw o;if(!r.session)throw new Us;await this._saveSession(r.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",r.session);const l={data:r.session,error:null};return this.refreshingDeferred.resolve(l),l}catch(r){if(this._debug(i,"error",r),Dt(r)){const o={data:null,error:r};return Sx(r)||await this._removeSession(),(e=this.refreshingDeferred)===null||e===void 0||e.resolve(o),o}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(r),r}finally{this.refreshingDeferred=null,this._debug(i,"end")}}async _notifyAllSubscribers(t,e,s=!0){const i=`#_notifyAllSubscribers(${t})`;this._debug(i,"begin",e,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:t,session:e});const r=[],o=Array.from(this.stateChangeEmitters.values()).map(async l=>{try{await l.callback(t,e)}catch(c){r.push(c)}});if(await Promise.all(o),r.length>0){for(let l=0;l<r.length;l+=1)console.error(r[l]);throw r[0]}}finally{this._debug(i,"end")}}async _saveSession(t){this._debug("#_saveSession()",t),this.suppressGetSessionWarning=!0,await jn(this.storage,`${this.storageKey}-code-verifier`);const e=Object.assign({},t),s=e.user&&e.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&e.user&&await fc(this.userStorage,this.storageKey+"-user",{user:e.user});const i=Object.assign({},e);delete i.user;const r=wI(i);await fc(this.storage,this.storageKey,r)}else{const i=wI(e);await fc(this.storage,this.storageKey,i)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await jn(this.storage,this.storageKey),await jn(this.storage,this.storageKey+"-code-verifier"),await jn(this.storage,this.storageKey+"-user"),this.userStorage&&await jn(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const t=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{t&&Gn()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",t)}catch(e){console.error("removing visibilitychange callback failed",e)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const t=setInterval(()=>this._autoRefreshTokenTick(),dc);this.autoRefreshTicker=t,t&&typeof t=="object"&&typeof t.unref=="function"?t.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(t),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const t=this.autoRefreshTicker;this.autoRefreshTicker=null,t&&clearInterval(t)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const t=Date.now();try{return await this._useSession(async e=>{const{data:{session:s}}=e;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const i=Math.floor((s.expires_at*1e3-t)/dc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${i} ticks, a tick lasts ${dc}ms, refresh threshold is ${Tv} ticks`),i<=Tv&&await this._callRefreshToken(s.refresh_token)})}catch(e){console.error("Auto refresh tick failed with error. This is likely a transient error.",e)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(t){if(t.isAcquireTimeout||t instanceof pR)this._debug("auto refresh token tick lock not available");else throw t}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!Gn()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(t){console.error("_handleVisibilityChange",t)}}async _onVisibilityChanged(t){const e=`#_onVisibilityChanged(${t})`;this._debug(e,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),t||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(e,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(t,e,s){const i=[`provider=${encodeURIComponent(e)}`];if(s?.redirectTo&&i.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&i.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[r,o]=await ic(this.storage,this.storageKey),l=new URLSearchParams({code_challenge:`${encodeURIComponent(r)}`,code_challenge_method:`${encodeURIComponent(o)}`});i.push(l.toString())}if(s?.queryParams){const r=new URLSearchParams(s.queryParams);i.push(r.toString())}return s?.skipBrowserRedirect&&i.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${t}?${i.join("&")}`}async _unenroll(t){try{return await this._useSession(async e=>{var s;const{data:i,error:r}=e;return r?this._returnResult({data:null,error:r}):await Vt(this.fetch,"DELETE",`${this.url}/factors/${t.factorId}`,{headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _enroll(t){try{return await this._useSession(async e=>{var s,i;const{data:r,error:o}=e;if(o)return this._returnResult({data:null,error:o});const l=Object.assign({friendly_name:t.friendlyName,factor_type:t.factorType},t.factorType==="phone"?{phone:t.phone}:t.factorType==="totp"?{issuer:t.issuer}:{}),{data:c,error:h}=await Vt(this.fetch,"POST",`${this.url}/factors`,{body:l,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(t.factorType==="totp"&&c.type==="totp"&&(!((i=c?.totp)===null||i===void 0)&&i.qr_code)&&(c.totp.qr_code=`data:image/svg+xml;utf-8,${c.totp.qr_code}`),this._returnResult({data:c,error:null}))})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _verify(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async e=>{var s;const{data:i,error:r}=e;if(r)return this._returnResult({data:null,error:r});const o=Object.assign({challenge_id:t.challengeId},"webauthn"in t?{webauthn:Object.assign(Object.assign({},t.webauthn),{credential_response:t.webauthn.type==="create"?DH(t.webauthn.credential_response):OH(t.webauthn.credential_response)})}:{code:t.code}),{data:l,error:c}=await Vt(this.fetch,"POST",`${this.url}/factors/${t.factorId}/verify`,{body:o,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});return c?this._returnResult({data:null,error:c}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+l.expires_in},l)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",l),this._returnResult({data:l,error:c}))})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}})}async _challenge(t){return this._acquireLock(-1,async()=>{try{return await this._useSession(async e=>{var s;const{data:i,error:r}=e;if(r)return this._returnResult({data:null,error:r});const o=await Vt(this.fetch,"POST",`${this.url}/factors/${t.factorId}/challenge`,{body:t,headers:this.headers,jwt:(s=i?.session)===null||s===void 0?void 0:s.access_token});if(o.error)return o;const{data:l}=o;if(l.type!=="webauthn")return{data:l,error:null};switch(l.webauthn.type){case"create":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:_H(l.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},l),{webauthn:Object.assign(Object.assign({},l.webauthn),{credential_options:Object.assign(Object.assign({},l.webauthn.credential_options),{publicKey:RH(l.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}})}async _challengeAndVerify(t){const{data:e,error:s}=await this._challenge({factorId:t.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:t.factorId,challengeId:e.id,code:t.code})}async _listFactors(){var t;const{data:{user:e},error:s}=await this.getUser();if(s)return{data:null,error:s};const i={all:[],phone:[],totp:[],webauthn:[]};for(const r of(t=e?.factors)!==null&&t!==void 0?t:[])i.all.push(r),r.status==="verified"&&i[r.factor_type].push(r);return{data:i,error:null}}async _getAuthenticatorAssuranceLevel(){var t,e;const{data:{session:s},error:i}=await this.getSession();if(i)return this._returnResult({data:null,error:i});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:r}=Cx(s.access_token);let o=null;r.aal&&(o=r.aal);let l=o;((e=(t=s.user.factors)===null||t===void 0?void 0:t.filter(d=>d.status==="verified"))!==null&&e!==void 0?e:[]).length>0&&(l="aal2");const h=r.amr||[];return{data:{currentLevel:o,nextLevel:l,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(t){try{return await this._useSession(async e=>{const{data:{session:s},error:i}=e;return i?this._returnResult({data:null,error:i}):s?await Vt(this.fetch,"GET",`${this.url}/oauth/authorizations/${t}`,{headers:this.headers,jwt:s.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new Us})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async _approveAuthorization(t,e){try{return await this._useSession(async s=>{const{data:{session:i},error:r}=s;if(r)return this._returnResult({data:null,error:r});if(!i)return this._returnResult({data:null,error:new Us});const o=await Vt(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:i.access_token,body:{action:"approve"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Gn()&&!e?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(Dt(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(t,e){try{return await this._useSession(async s=>{const{data:{session:i},error:r}=s;if(r)return this._returnResult({data:null,error:r});if(!i)return this._returnResult({data:null,error:new Us});const o=await Vt(this.fetch,"POST",`${this.url}/oauth/authorizations/${t}/consent`,{headers:this.headers,jwt:i.access_token,body:{action:"deny"},xform:l=>({data:l,error:null})});return o.data&&o.data.redirect_url&&Gn()&&!e?.skipBrowserRedirect&&window.location.assign(o.data.redirect_url),o})}catch(s){if(Dt(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async t=>{const{data:{session:e},error:s}=t;return s?this._returnResult({data:null,error:s}):e?await Vt(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:e.access_token,xform:i=>({data:i,error:null})}):this._returnResult({data:null,error:new Us})})}catch(t){if(Dt(t))return this._returnResult({data:null,error:t});throw t}}async _revokeOAuthGrant(t){try{return await this._useSession(async e=>{const{data:{session:s},error:i}=e;return i?this._returnResult({data:null,error:i}):s?(await Vt(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:t.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new Us})})}catch(e){if(Dt(e))return this._returnResult({data:null,error:e});throw e}}async fetchJwk(t,e={keys:[]}){let s=e.keys.find(l=>l.kid===t);if(s)return s;const i=Date.now();if(s=this.jwks.keys.find(l=>l.kid===t),s&&this.jwks_cached_at+VW>i)return s;const{data:r,error:o}=await Vt(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(o)throw o;return!r.keys||r.keys.length===0||(this.jwks=r,this.jwks_cached_at=i,s=r.keys.find(l=>l.kid===t),!s)?null:s}async getClaims(t,e={}){try{let s=t;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:i,payload:r,signature:o,raw:{header:l,payload:c}}=Cx(s);e?.allowExpired||uH(r.exp);const h=!i.alg||i.alg.startsWith("HS")||!i.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(i.kid,e?.keys?{keys:e.keys}:e?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:r,header:i,signature:o},error:null}}const d=hH(i.alg),p=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,p,o,JW(`${l}.${c}`)))throw new Ev("Invalid JWT signature");return{data:{claims:r,header:i,signature:o},error:null}}catch(s){if(Dt(s))return this._returnResult({data:null,error:s});throw s}}}Dh.nextInstanceID={};const jH=Dh,GH="2.89.0";let lh="";typeof Deno<"u"?lh="deno":typeof document<"u"?lh="web":typeof navigator<"u"&&navigator.product==="ReactNative"?lh="react-native":lh="node";const WH={"X-Client-Info":`supabase-js-${lh}/${GH}`},HH={headers:WH},qH={schema:"public"},KH={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},XH={};function Oh(n){"@babel/helpers - typeof";return Oh=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Oh(n)}function YH(n,t){if(Oh(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var s=e.call(n,t);if(Oh(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function JH(n){var t=YH(n,"string");return Oh(t)=="symbol"?t:t+""}function ZH(n,t,e){return(t=JH(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function II(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);t&&(s=s.filter(function(i){return Object.getOwnPropertyDescriptor(n,i).enumerable})),e.push.apply(e,s)}return e}function Je(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?II(Object(e),!0).forEach(function(s){ZH(n,s,e[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):II(Object(e)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(e,s))})}return n}const QH=n=>n?(...t)=>n(...t):(...t)=>fetch(...t),t6=()=>Headers,e6=(n,t,e)=>{const s=QH(e),i=t6();return async(r,o)=>{var l;const c=(l=await t())!==null&&l!==void 0?l:n;let h=new i(o?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${c}`),s(r,Je(Je({},o),{},{headers:h}))}};function n6(n){return n.endsWith("/")?n:n+"/"}function s6(n,t){var e,s;const{db:i,auth:r,realtime:o,global:l}=n,{db:c,auth:h,realtime:d,global:p}=t,m={db:Je(Je({},c),i),auth:Je(Je({},h),r),realtime:Je(Je({},d),o),storage:{},global:Je(Je(Je({},p),l),{},{headers:Je(Je({},(e=p?.headers)!==null&&e!==void 0?e:{}),(s=l?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function i6(n){const t=n?.trim();if(!t)throw new Error("supabaseUrl is required.");if(!t.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(n6(t))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var r6=class extends jH{constructor(n){super(n)}},o6=class{constructor(n,t,e){var s,i;this.supabaseUrl=n,this.supabaseKey=t;const r=i6(n);if(!t)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",r),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",r),this.storageUrl=new URL("storage/v1",r),this.functionsUrl=new URL("functions/v1",r);const o=`sb-${r.hostname.split(".")[0]}-auth-token`,l={db:qH,realtime:XH,auth:Je(Je({},KH),{},{storageKey:o}),global:HH},c=s6(e??{},l);if(this.storageKey=(s=c.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(i=c.global.headers)!==null&&i!==void 0?i:{},c.accessToken)this.accessToken=c.accessToken,this.auth=new Proxy({},{get:(d,p)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(p)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=c.auth)!==null&&h!==void 0?h:{},this.headers,c.global.fetch)}this.fetch=e6(t,this._getAccessToken.bind(this),c.global.fetch),this.realtime=this._initRealtimeClient(Je({headers:this.headers,accessToken:this._getAccessToken.bind(this)},c.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new PG(new URL("rest/v1",r).href,{headers:this.headers,schema:c.db.schema,fetch:this.fetch}),this.storage=new FW(this.storageUrl.href,this.headers,this.fetch,e?.storage),c.accessToken||this._listenForAuthEvents()}get functions(){return new OG(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,t={},e={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,t,e)}channel(n,t={config:{}}){return this.realtime.channel(n,t)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,t,e;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(t=(e=s.session)===null||e===void 0?void 0:e.access_token)!==null&&t!==void 0?t:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:t,detectSessionInUrl:e,storage:s,userStorage:i,storageKey:r,flowType:o,lock:l,debug:c,throwOnError:h},d,p){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new r6({url:this.authUrl.href,headers:Je(Je({},m),d),storageKey:r,autoRefreshToken:n,persistSession:t,detectSessionInUrl:e,storage:s,userStorage:i,flowType:o,lock:l,debug:c,throwOnError:h,fetch:p,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new nW(this.realtimeUrl.href,Je(Je({},n),{},{params:Je(Je({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,t)=>{this._handleTokenChanged(n,"CLIENT",t?.access_token)})}_handleTokenChanged(n,t,e){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==e?(this.changedAccessToken=e,this.realtime.setAuth(e)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),t=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const a6=(n,t,e)=>new o6(n,t,e);function l6(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const t=n.match(/^v(\d+)\./);return t?parseInt(t[1],10)<=18:!1}l6()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const c6="https://brrjoheinakfhohesogc.supabase.co",u6="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",h6={getItem:n=>typeof chrome<"u"&&chrome.storage&&chrome.storage.local?new Promise(t=>{chrome.storage.local.get([n],e=>t(e[n]||null))}):localStorage.getItem(n),setItem:(n,t)=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.set({[n]:t}):localStorage.setItem(n,t)},removeItem:n=>{typeof chrome<"u"&&chrome.storage&&chrome.storage.local?chrome.storage.local.remove([n]):localStorage.removeItem(n)}},ks=a6(c6,u6,{auth:{storage:h6,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!1}}),yR=St.createContext(),d6=({children:n})=>{const[t,e]=St.useState(null),[s,i]=St.useState(null),[r,o]=St.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[l,c]=St.useState(!0);St.useEffect(()=>{p(),ks.auth.getSession().then(({data:{session:y}})=>{e(y?.user||null),y?.user?h(y.user.id,y.user.email):c(!1)});const{data:{subscription:m}}=ks.auth.onAuthStateChange((y,b)=>{e(b?.user||null),b?.user?h(b.user.id,b.user.email):(i(null),c(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await ks.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:S}=await ks.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();S||(b=w)}i(b)}catch(b){console.error("Profile fetch error:",b)}finally{c(!1)}},d=()=>{t&&h(t.id,t.email)},p=async()=>{try{const{data:m,error:y}=await ks.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&o(m)}catch(m){console.error("Neural state sync error:",m)}};return bt.jsx(yR.Provider,{value:{user:t,profile:s,neuralState:r,loading:l,refreshProfile:d,fetchNeuralState:p,setUser:e,setProfile:i,setNeuralState:o},children:n})},f6=()=>St.useContext(yR),Iv=(n,t)=>{if(n.length<t)return[];const e=[];for(let s=t-1;s<n.length;s++){const i=n.slice(s-t+1,s+1).reduce((r,o)=>r+o,0);e.push(i/t)}return e},$x=(n,t)=>{if(n.length<t)return[];const e=2/(t+1);let s=[n[0]];for(let i=1;i<n.length;i++)s.push(n[i]*e+s[i-1]*(1-e));return s},bR=(n,t=14)=>{if(n.length<t+1)return[];let e=0,s=0;for(let c=1;c<=t;c++){const h=n[c]-n[c-1];h>=0?e+=h:s+=Math.abs(h)}let i=e/t,r=s/t;const o=[];let l=r===0?100:i/r;o.push(100-100/(1+l));for(let c=t+1;c<n.length;c++){const h=n[c]-n[c-1];h>=0?(i=(i*(t-1)+h)/t,r=(r*(t-1)+0)/t):(i=(i*(t-1)+0)/t,r=(r*(t-1)+Math.abs(h))/t),l=r===0?100:i/r,o.push(100-100/(1+l))}return o},xR=(n,t=20,e=2)=>{if(n.length<t)return[];const s=[],i=[],r=Iv(n,t);for(let o=0;o<r.length;o++){const l=n.slice(o,o+t),c=r[o],d=l.map(m=>Math.pow(m-c,2)).reduce((m,y)=>m+y,0)/t,p=Math.sqrt(d);i.push(c+e*p),s.push(c-e*p)}return{basis:r,upper:i,lower:s}},p6=(n,t=12,e=26,s=9)=>{const i=$x(n,t),r=$x(n,e),o=[],l=Math.min(i.length,r.length);for(let d=0;d<l;d++)o.push(i[d]-r[d]);const c=$x(o,s),h=[];for(let d=0;d<Math.min(o.length,c.length);d++)h.push(o[d]-c[d]);return{macdLine:o,signalLine:c,histogram:h}},m6=n=>{if(n.length<50)return{name:"Insufficient Data",sentiment:"Neutral",confidence:0};n[n.length-1],n[n.length-2];const t=Iv(n.slice(-20),10),e=Iv(n.slice(-50),40),s=t[t.length-1]>e[e.length-1],{upper:i,lower:r}=xR(n,20),l=(i[i.length-1]-r[r.length-1])/n[n.length-1]<.05,c=bR(n,14),h=c[c.length-1],d=h<30,p=h>70;let m=[];return l&&m.push({name:"Volatility Squeeze",sentiment:"Neutral"}),s&&!p&&m.push({name:"Bullish Continuation",sentiment:"Bullish"}),!s&&!d&&m.push({name:"Bearish Continuation",sentiment:"Bearish"}),s&&p&&m.push({name:"Potential Reversal (Top)",sentiment:"Bearish"}),!s&&d&&m.push({name:"Potential Reversal (Bottom)",sentiment:"Bullish"}),m.length>0?m[0]:{name:"Consolidation",sentiment:"Neutral"}},g6=(n,t=14)=>{if(n.length<t+1)return[];let e=[];for(let o=1;o<n.length;o++){n[o];const l=n[o],c=n[o-1],h=Math.abs(l-c),d=l*.005,p=Math.max(h,d);e.push(p)}const s=[];let i=e.slice(0,t).reduce((o,l)=>o+l,0)/t;s.push(i);for(let o=t;o<e.length;o++){const l=(s[s.length-1]*(t-1)+e[o])/t;s.push(l)}return[...new Array(n.length-s.length).fill(null),...s]},y6=n=>{if(n.length<20)return{support:Math.min(...n),resistance:Math.max(...n)};const t=[],e=5;for(let o=e;o<n.length-e;o++){const l=n.slice(o-e,o+e+1),c=n[o],h=l.every(p=>p<=c),d=l.every(p=>p>=c);h&&t.push({price:c,type:"Resistance"}),d&&t.push({price:c,type:"Support"})}const s=n[n.length-1],i=t.filter(o=>o.type==="Support"&&o.price<s).sort((o,l)=>l.price-o.price),r=t.filter(o=>o.type==="Resistance"&&o.price>s).sort((o,l)=>o.price-l.price);return{support:i.length>0?i[0].price:Math.min(...n),resistance:r.length>0?r[0].price:Math.max(...n)}};const b6=1e-7,x6=1e-4;class vR{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Jw{refCount(t){return Ts("refCount")}incRef(t){return Ts("incRef")}timerAvailable(){return!0}time(t){return Ts("time")}read(t){return Ts("read")}readSync(t){return Ts("readSync")}readToGPU(t,e){return Ts("readToGPU")}numDataIds(){return Ts("numDataIds")}disposeData(t,e){return Ts("disposeData")}write(t,e,s){return Ts("write")}move(t,e,s,i,r){return Ts("move")}createTensorFromGPUData(t,e,s){return Ts("createTensorFromGPUData")}memory(){return Ts("memory")}floatPrecision(){return Ts("floatPrecision")}epsilon(){return this.floatPrecision()===32?b6:x6}dispose(){return Ts("dispose")}}function Ts(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function v6(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,pc(n,t,e)}function Wa(n,t,e){return Math.max(n,Math.min(t,e))}function Zw(n){return n%2===0?n:n+1}function pc(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function w6(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function F(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function Qw(n,t,e=""){F(me(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function t1(n){F(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ft(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function me(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Rc(n){return n%1===0}function Nv(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function kc(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function NI(n,t=i=>0,e,s){return new Promise((i,r)=>{let o=0;const l=()=>{if(n()){i();return}o++;const c=t(o);if(e!=null&&o>=e){r();return}s!=null?s(l,c):setTimeout(l,c)};l()})}function wR(n,t){let e=1,s=-1;for(let r=0;r<n.length;++r)if(n[r]>=0)e*=n[r];else if(n[r]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);s=r}else if(n[r]<0)throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);if(s===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const i=n.slice();return i[s]=t/e,i}function Zt(n,t){const e=t.length;return n=n==null?t.map((s,i)=>i):[].concat(n),F(n.every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),F(n.every(s=>Rc(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function jo(n,t){const e=[],s=[],i=t!=null&&Array.isArray(t)&&t.length===0,r=t==null||i?null:Zt(t,n).sort();let o=0;for(let l=0;l<n.length;++l){if(r!=null){if(r[o]===l&&n[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${n[l]}' is not 1`);(r[o]==null||r[o]>l)&&n[l]===1&&(e.push(n[l]),s.push(l)),r[o]<=l&&o++}n[l]!==1&&(e.push(n[l]),s.push(l))}return{newShape:e,keptDims:s}}function Hn(n,t){return Qe(n,t)}function Qe(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function S6(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function C6(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function SR(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function $m(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function T6(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function td(n){return typeof n=="string"||n instanceof String}function k6(n){return typeof n=="boolean"}function Av(n){return typeof n=="number"}function Hc(n){return Array.isArray(n)?Hc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Av(n)?"float32":td(n)?"string":k6(n)?"bool":"float32"}function _v(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Rv(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function Ot(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function CR(n,t,e,s=!1){const i=new Array;if(t.length===1){const r=t[0]*(s?2:1);for(let o=0;o<r;o++)i[o]=e[n+o]}else{const r=t[0],o=t.slice(1),l=o.reduce((c,h)=>c*h)*(s?2:1);for(let c=0;c<r;c++)i[c]=CR(n+c*l,o,e,s)}return i}function zi(n,t,e=!1){if(n.length===0)return t[0];const s=n.reduce((i,r)=>i*r)*(e?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return CR(0,n,t,e)}function $6(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function e1(n,t){const e=qn(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function qn(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function TR(n,t){const e=n.reduce((s,i)=>s*i,1);if(t==null||t==="float32")return zi(n,new Float32Array(e));if(t==="int32")return zi(n,new Int32Array(e));if(t==="bool")return zi(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Kr(n){n.forEach(t=>{F(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function rr(n,t,e){if(t===0)return 0;if(t===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=e[i]*n[i];return s}function qc(n,t,e){if(t===0)return[];if(t===1)return[n];const s=new Array(t);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/e[i]),n-=s[i]*e[i];return s[s.length-1]=n,s}function n1(n){return n&&n.then&&typeof n.then=="function"}const AI="tfjsflags";class E6{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=I6,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(at().getBool("IS_TEST")||at().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},this.urlFlags[t]!=null){const i=this.urlFlags[t];at().getBool("IS_TEST")||at().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${i}.`),this.set(t,i)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(n1(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);AI in t&&t[AI].split(",").forEach(s=>{const[i,r]=s.split(":");this.urlFlags[i]=A6(i,r)})}}function I6(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(N6(t,s[0],s[1]),s.join("="))),t}function N6(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function A6(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function at(){return kR}let kR=null;function _6(n){kR=n}let Ex;function $R(){if(Ex==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Ex=n}return Ex}function R6(){const n=$R();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function s1(n,t){const e=R6();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const cg="Abs",ed="Acos",nd="Acosh",Kc="Add",i1="AddN",r1="All",o1="Any",ug="ArgMax",hg="ArgMin",sd="Asin",id="Asinh",rd="Atan",od="Atanh",ad="Atan2",dg="AvgPool",a1="AvgPoolGrad",fg="AvgPool3D",l1="AvgPool3DGrad",pg="BatchMatMul",mg="BatchToSpaceND",c1="Bincount",u1="BitwiseAnd",D6="BroadcastTo",ER="BroadcastArgs",ld="Cast",cd="Ceil",ud="ClipByValue",h1="Complex",gg="ComplexAbs",yg="Concat",bg="Conv2D",d1="Conv2DBackpropFilter",xg="Conv2DBackpropInput",vg="Conv3D",f1="Conv3DBackpropFilterV2",p1="Conv3DBackpropInputV2",hd="Cos",dd="Cosh",m1="Cumprod",wg="Cumsum",g1="CropAndResize",y1="DenseBincount",b1="DepthToSpace",Sg="DepthwiseConv2dNative",x1="DepthwiseConv2dNativeBackpropFilter",v1="DepthwiseConv2dNativeBackpropInput",IR="Diag",Cg="Dilation2D",Dv="Dilation2DBackpropInput",Ov="Dilation2DBackpropFilter",O6="Draw",fd="RealDiv",w1="Einsum",pd="Elu",S1="EluGrad",md="Erf",Tg="Equal",gd="Exp",kg="ExpandDims",yd="Expm1",C1="FFT",T1="Fill",k1="FlipLeftRight",bd="Floor",xd="FloorDiv",$g="FusedBatchNorm",Eg="GatherV2",NR="GatherNd",Ig="Greater",vd="GreaterEqual",wd="Identity",$1="IFFT",E1="Imag",Sd="IsFinite",Cd="IsInf",Td="IsNan",Ng="LeakyRelu",Ag="Less",_g="LessEqual",AR="LinSpace",kd="Log",$d="Log1p",Rg="LogicalAnd",Dg="LogicalNot",Og="LogicalOr",M6="LogSoftmax",Mg="LRN",I1="LRNGrad",Fg="Max",Ed="Maximum",Lg="MaxPool",N1="MaxPoolGrad",zg="MaxPool3D",A1="MaxPool3DGrad",_R="MaxPoolWithArgmax",Pg="Mean",Bg="Min",Id="Minimum",Vg="MirrorPad",Nd="Mod",RR="Multinomial",Ad="Multiply",Ug="Neg",jg="NotEqual",_1="NonMaxSuppressionV3",R1="NonMaxSuppressionV4",D1="NonMaxSuppressionV5",Gg="OnesLike",Wg="OneHot",Hg="Pack",qg="PadV2",_d="Pow",Kg="Prelu",Xg="Prod",DR="RaggedGather",OR="RaggedRange",MR="RaggedTensorToTensor",O1="Range",M1="Real",Rd="Reciprocal",Dd="Relu",Yg="Reshape",Jg="ResizeNearestNeighbor",F1="ResizeNearestNeighborGrad",Zg="ResizeBilinear",L1="ResizeBilinearGrad",Od="Relu6",Qg="Reverse",Md="Round",Fd="Rsqrt",FR="ScatterNd",LR="TensorScatterUpdate",zR="SearchSorted",ty="Select",Ld="Selu",ey="Slice",zd="Sin",Pd="Sinh",Bd="Sign",Vd="Sigmoid",Ud="Softplus",jd="Sqrt",ny="Sum",sy="SpaceToBatchND",iy="SplitV",ry="Softmax",PR="SparseFillEmptyRows",BR="SparseReshape",VR="SparseSegmentMean",UR="SparseSegmentSum",jR="SparseToDense",Gd="SquaredDifference",z1="Square",P1="StaticRegexReplace",B1="StridedSlice",GR="StringNGrams",WR="StringSplit",HR="StringToHashBucketFast",Wd="Sub",Hd="Tan",qd="Tanh",Kd="Tile",V1="TopK",U1="Transform",$c="Transpose",j1="Unique",oy="Unpack",ay="UnsortedSegmentSum",ly="ZerosLike",Xd="Step",F6="FromPixels",G1="RotateWithOffset",Em="_FusedMatMul",Im="FusedConv2D",qR="FusedDepthwiseConv2D";function Ws(...n){at().getBool("IS_TEST")||at().getBool("PROD")||console.warn(...n)}function L6(...n){at().getBool("IS_TEST")||at().getBool("PROD")||console.log(...n)}const Nm=s1("kernelRegistry",()=>new Map),Mv=s1("gradRegistry",()=>new Map);function _I(n,t){const e=XR(n,t);return Nm.get(e)}function RI(n){return Mv.get(n)}function DI(n){const t=Nm.entries(),e=[];for(;;){const{done:s,value:i}=t.next();if(s)break;const[r,o]=i,[l]=r.split("_");l===n&&e.push(o)}return e}function KR(n){const{kernelName:t,backendName:e}=n,s=XR(t,e);Nm.has(s)&&Ws(`The kernel '${t}' for backend '${e}' is already registered`),Nm.set(s,n)}function z6(n){const{kernelName:t}=n;Mv.has(t)&&at().getBool("DEBUG")&&Ws(`Overriding the gradient for '${t}'`),Mv.set(t,n)}function XR(n,t){return`${t}_${n}`}function YR(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Ix,OI;function P6(){if(OI)return Ix;OI=1,Ix=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(M,A,B){this.low=M|0,this.high=A|0,this.unsigned=!!B}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(M){return(M&&M.__isLong__)===!0}t.isLong=e;var s={},i={};function r(M,A){var B,H,J;return A?(M>>>=0,(J=0<=M&&M<256)&&(H=i[M],H)?H:(B=l(M,(M|0)<0?-1:0,!0),J&&(i[M]=B),B)):(M|=0,(J=-128<=M&&M<128)&&(H=s[M],H)?H:(B=l(M,M<0?-1:0,!1),J&&(s[M]=B),B))}t.fromInt=r;function o(M,A){if(isNaN(M))return A?T:S;if(A){if(M<0)return T;if(M>=b)return _}else{if(M<=-x)return R;if(M+1>=x)return N}return M<0?o(-M,A).neg():l(M%y|0,M/y|0,A)}t.fromNumber=o;function l(M,A,B){return new t(M,A,B)}t.fromBits=l;var c=Math.pow;function h(M,A,B){if(M.length===0)throw Error("empty string");if(M==="NaN"||M==="Infinity"||M==="+Infinity"||M==="-Infinity")return S;if(typeof A=="number"?(B=A,A=!1):A=!!A,B=B||10,B<2||36<B)throw RangeError("radix");var H;if((H=M.indexOf("-"))>0)throw Error("interior hyphen");if(H===0)return h(M.substring(1),A,B).neg();for(var J=o(c(B,8)),X=S,z=0;z<M.length;z+=8){var P=Math.min(8,M.length-z),V=parseInt(M.substring(z,z+P),B);if(P<8){var K=o(c(B,P));X=X.mul(K).add(o(V))}else X=X.mul(J),X=X.add(o(V))}return X.unsigned=A,X}t.fromString=h;function d(M,A){return typeof M=="number"?o(M,A):typeof M=="string"?h(M,A):l(M.low,M.high,typeof A=="boolean"?A:M.unsigned)}t.fromValue=d;var p=65536,m=1<<24,y=p*p,b=y*y,x=b/2,w=r(m),S=r(0);t.ZERO=S;var T=r(0,!0);t.UZERO=T;var k=r(1);t.ONE=k;var $=r(1,!0);t.UONE=$;var E=r(-1);t.NEG_ONE=E;var N=l(-1,2147483647,!1);t.MAX_VALUE=N;var _=l(-1,-1,!0);t.MAX_UNSIGNED_VALUE=_;var R=l(0,-2147483648,!1);t.MIN_VALUE=R;var D=t.prototype;return D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},D.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var B=o(A),H=this.div(B),J=H.mul(B).sub(this);return H.toString(A)+J.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var X=o(c(A,6),this.unsigned),z=this,P="";;){var V=z.div(X),K=z.sub(V.mul(X)).toInt()>>>0,st=K.toString(A);if(z=V,z.isZero())return st+P;for(;st.length<6;)st="0"+st;P=""+st+P}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,B=31;B>0&&(A&1<<B)==0;B--);return this.high!=0?B+33:B+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(A){return e(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},D.eq=D.equals,D.notEquals=function(A){return!this.eq(A)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(A){return this.comp(A)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(A){return this.comp(A)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(A){return this.comp(A)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(A){return this.comp(A)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(A){if(e(A)||(A=d(A)),this.eq(A))return 0;var B=this.isNegative(),H=A.isNegative();return B&&!H?-1:!B&&H?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(k)},D.neg=D.negate,D.add=function(A){e(A)||(A=d(A));var B=this.high>>>16,H=this.high&65535,J=this.low>>>16,X=this.low&65535,z=A.high>>>16,P=A.high&65535,V=A.low>>>16,K=A.low&65535,st=0,L=0,j=0,Q=0;return Q+=X+K,j+=Q>>>16,Q&=65535,j+=J+V,L+=j>>>16,j&=65535,L+=H+P,st+=L>>>16,L&=65535,st+=B+z,st&=65535,l(j<<16|Q,st<<16|L,this.unsigned)},D.subtract=function(A){return e(A)||(A=d(A)),this.add(A.neg())},D.sub=D.subtract,D.multiply=function(A){if(this.isZero())return S;if(e(A)||(A=d(A)),n){var B=n.mul(this.low,this.high,A.low,A.high);return l(B,n.get_high(),this.unsigned)}if(A.isZero())return S;if(this.eq(R))return A.isOdd()?R:S;if(A.eq(R))return this.isOdd()?R:S;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return o(this.toNumber()*A.toNumber(),this.unsigned);var H=this.high>>>16,J=this.high&65535,X=this.low>>>16,z=this.low&65535,P=A.high>>>16,V=A.high&65535,K=A.low>>>16,st=A.low&65535,L=0,j=0,Q=0,ct=0;return ct+=z*st,Q+=ct>>>16,ct&=65535,Q+=X*st,j+=Q>>>16,Q&=65535,Q+=z*K,j+=Q>>>16,Q&=65535,j+=J*st,L+=j>>>16,j&=65535,j+=X*K,L+=j>>>16,j&=65535,j+=z*V,L+=j>>>16,j&=65535,L+=H*st+J*K+X*V+z*P,L&=65535,l(Q<<16|ct,L<<16|j,this.unsigned)},D.mul=D.multiply,D.divide=function(A){if(e(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var B=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return l(B,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:S;var H,J,X;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return T;if(A.gt(this.shru(1)))return $;X=T}else{if(this.eq(R)){if(A.eq(k)||A.eq(E))return R;if(A.eq(R))return k;var z=this.shr(1);return H=z.div(A).shl(1),H.eq(S)?A.isNegative()?k:E:(J=this.sub(A.mul(H)),X=H.add(J.div(A)),X)}else if(A.eq(R))return this.unsigned?T:S;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();X=S}for(J=this;J.gte(A);){H=Math.max(1,Math.floor(J.toNumber()/A.toNumber()));for(var P=Math.ceil(Math.log(H)/Math.LN2),V=P<=48?1:c(2,P-48),K=o(H),st=K.mul(A);st.isNegative()||st.gt(J);)H-=V,K=o(H,this.unsigned),st=K.mul(A);K.isZero()&&(K=k),X=X.add(K),J=J.sub(st)}return X},D.div=D.divide,D.modulo=function(A){if(e(A)||(A=d(A)),n){var B=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return l(B,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return l(~this.low,~this.high,this.unsigned)},D.and=function(A){return e(A)||(A=d(A)),l(this.low&A.low,this.high&A.high,this.unsigned)},D.or=function(A){return e(A)||(A=d(A)),l(this.low|A.low,this.high|A.high,this.unsigned)},D.xor=function(A){return e(A)||(A=d(A)),l(this.low^A.low,this.high^A.high,this.unsigned)},D.shiftLeft=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):l(0,this.low<<A-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?l(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):l(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(A){if(e(A)&&(A=A.toInt()),A&=63,A===0)return this;var B=this.high;if(A<32){var H=this.low;return l(H>>>A|B<<32-A,B>>>A,this.unsigned)}else return A===32?l(B,0,this.unsigned):l(B>>>A-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},D.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var A=this.high,B=this.low;return[B&255,B>>>8&255,B>>>16&255,B>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},D.toBytesBE=function(){var A=this.high,B=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,B>>>24,B>>>16&255,B>>>8&255,B&255]},t.fromBytes=function(A,B,H){return H?t.fromBytesLE(A,B):t.fromBytesBE(A,B)},t.fromBytesLE=function(A,B){return new t(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,B)},t.fromBytesBE=function(A,B){return new t(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],B)},Ix}var JR=P6();const ZR=hw(JR),B6=yB({__proto__:null,default:ZR},[JR]);const Na=ZR||B6;function cy(n){return Na.fromString(n,!0,16)}const QR=cy("c3a5c85c97cb3127"),$a=cy("b492b66fbe98f273"),ts=cy("9ae16a3b2f90404f");function Fv(n){return n.xor(n.shru(47))}function tD(n,t,e){const s=n.slice(t,t+e);return Na.fromBytes(Array.from(s),!0,!0)}function _e(n,t){return tD(n,t,8)}function MI(n,t){return tD(n,t,4)}function En(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Ao(n,t,e=cy("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let i=t.xor(s).mul(e);return i=i.xor(i.shru(47)),i=i.mul(e),i}function V6(n,t,e,s,i,r){i=i.add(n),r=En(r.add(i).add(s),21);const o=i;return i=i.add(t),i=i.add(e),r=r.add(En(i,44)),[i.add(s),r.add(o)]}function Wp(n,t,e,s){return V6(_e(n,t),_e(n,t+8),_e(n,t+16),_e(n,t+24),e,s)}function U6(n,t=n.length){if(t>=8){const e=ts.add(t*2),s=_e(n,0).add(ts),i=_e(n,t-8),r=En(i,37).mul(e).add(s),o=En(s,25).add(i).mul(e);return Ao(r,o,e)}if(t>=4){const e=ts.add(t*2),s=MI(n,0);return Ao(s.shl(3).add(t),MI(n,t-4),e)}if(t>0){const e=n[0],s=n[t>>1],i=n[t-1],r=e+(s<<8),o=t+(i<<2);return Fv(ts.mul(r).xor(QR.mul(o))).mul(ts)}return ts}function j6(n,t=n.length){const e=ts.add(t*2),s=_e(n,0).mul($a),i=_e(n,8),r=_e(n,t-8).mul(e),o=_e(n,t-16).mul(ts);return Ao(En(s.add(i),43).add(En(r,30)).add(o),s.add(En(i.add(ts),18)).add(r),e)}function G6(n,t=n.length){const e=ts.add(t*2),s=_e(n,0).mul(ts),i=_e(n,8),r=_e(n,t-8).mul(e),o=_e(n,t-16).mul(ts),l=En(s.add(i),43).add(En(r,30)).add(o),c=Ao(l,s.add(En(i.add(ts),18)).add(r),e),h=_e(n,16).mul(e),d=_e(n,24),p=l.add(_e(n,t-32)).mul(e),m=c.add(_e(n,t-24)).mul(e);return Ao(En(h.add(d),43).add(En(p,30)).add(m),h.add(En(d.add(s),18)).add(p),e)}function W6(n,t=n.length){const e=Na.fromNumber(81,!0);if(t<=32)return t<=16?U6(n,t):j6(n,t);if(t<=64)return G6(n,t);let s=e,i=e.mul($a).add(113),r=Fv(i.mul(ts).add(113)).mul(ts),o=[Na.UZERO,Na.UZERO],l=[Na.UZERO,Na.UZERO];s=s.mul(ts).add(_e(n,0));let c=0;const h=(t-1>>6)*64,d=h+(t-1&63)-63;do s=En(s.add(i).add(o[0]).add(_e(n,c+8)),37).mul($a),i=En(i.add(o[1]).add(_e(n,c+48)),42).mul($a),s=s.xor(l[1]),i=i.add(o[0]).add(_e(n,c+40)),r=En(r.add(l[0]),33).mul($a),o=Wp(n,c,o[1].mul($a),s.add(l[0])),l=Wp(n,c+32,r.add(l[1]),i.add(_e(n,c+16))),[r,s]=[s,r],c+=64;while(c!==h);const p=$a.add(r.and(255).shl(1));return c=d,l[0]=l[0].add(t-1&63),o[0]=o[0].add(l[0]),l[0]=l[0].add(o[0]),s=En(s.add(i).add(o[0]).add(_e(n,c+8)),37).mul(p),i=En(i.add(o[1]).add(_e(n,c+48)),42).mul(p),s=s.xor(l[1].mul(9)),i=i.add(o[0].mul(9).add(_e(n,c+40))),r=En(r.add(l[0]),33).mul(p),o=Wp(n,c,o[1].mul(p),s.add(l[0])),l=Wp(n,c+32,r.add(l[1]),i.add(_e(n,c+16))),[r,s]=[s,r],Ao(Ao(o[0],l[0],p).add(Fv(i).mul(QR)).add(r),Ao(o[1],l[1],p).add(s),p)}function Go(n,t){return t==="string"?_o(n):ol([n],t)}function H6(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function ol(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ha(n)),at().getBool("DEBUG")&&S6(n,t),H6(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)Math.round(n[s])!==0&&(e[s]=1);return e}else throw new Error(`Unknown data type ${t}`)}function cs(){return at().platform.now()}function _o(n,t="utf-8"){return t=t||"utf-8",at().platform.encode(n,t)}function Fo(n,t="utf-8"){return t=t||"utf-8",at().platform.decode(n,t)}function yi(n){return at().platform.isTypedArray!=null?at().platform.isTypedArray(n):YR(n)}function Ha(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||n1(n)||n==null||yi(n)&&e)t.push(n);else if(Array.isArray(n)||yi(n))for(let s=0;s<n.length;++s)Ha(n[s],t,e);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)Ha(n[i],t,e)}return t}class q6{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new X6)}profileKernel(t,e,s){let i;const r=()=>{i=s()};let o;const l=cs();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const h of i)h.dataSync();o=Promise.resolve({kernelMs:cs()-l})}if(at().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<i.length;h++){const d=i[h];d.data().then(p=>{K6(p,d.dtype,t)})}return{kernelName:t,outputs:i,inputs:e,timeMs:o.then(h=>h.kernelMs),extraInfo:o.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:i,inputs:r,extraInfo:o}=t;s.forEach(l=>{Promise.all([l.data(),i,o]).then(c=>{this.logger.logKernelProfile(e,l,c[0],c[1],r,c[2])})})}}function K6(n,t,e){if(t!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${e}'`),!0}return!1}class X6{logKernelProfile(t,e,s,i,r,o){const l=typeof i=="number"?kc(`${i}ms`,9):i.error,c=kc(t,25),h=e.rank,d=e.size,p=kc(e.shape.toString(),14);let m="";for(const y in r){const b=r[y];if(b!=null){const x=b.shape||e.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${c}	%c${l}	%c${h}D ${p}	%c${d}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Y6(n,t,e){const s={},i={};for(let c=0;c<t.length;c++)s[t[c].id]=!0;for(let c=0;c<n.length;c++){const h=n[c],d=h.inputs;for(const p in d){const m=d[p];let y=!1;for(let b=0;b<t.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,i[h.id]=!0;break}if(y)break}}const r={};r[e.id]=!0;const o={};for(let c=n.length-1;c>=0;c--){const h=n[c],d=h.inputs;for(let p=0;p<h.outputs.length;p++)if(r[h.outputs[p].id]){for(const m in d)r[d[m].id]=!0,o[h.id]=!0;break}}const l=[];for(let c=0;c<n.length;c++){const h=n[c];if(i[h.id]&&o[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const p=Object.assign({},h);p.inputs=d,p.outputs=h.outputs,l.push(p)}}return l}function J6(n,t,e,s){for(let i=t.length-1;i>=0;i--){const r=t[i],o=[];if(r.outputs.forEach(c=>{const h=n[c.id];h!=null?o.push(h):o.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const l=r.gradient(o);for(const c in r.inputs){if(!(c in l))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(l)}.`);const h=e(()=>l[c]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${h.dtype}'`);const d=r.inputs[c];if(!me(h.shape,d.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${c}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const p=n[d.id];n[d.id]=s(p,h),p.dispose()}}}}const FI=20,sh=3,Nx=7;function Z6(n,t,e,s){const i=Ot(t),r=Q6(n,t,e,i),o=t.length,l=lm(n,t,e,i,r),c=["Tensor"];return s&&(c.push(`  dtype: ${e}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map(h=>"    "+h).join(`
`)),c.join(`
`)}function Q6(n,t,e,s){const i=ft(t),r=s[s.length-1],o=new Array(r).fill(0),l=t.length,c=e==="complex64"?uh(n):n;if(l>1)for(let h=0;h<i/r;h++){const d=h*r;for(let p=0;p<r;p++)o[p]=Math.max(o[p],ch(c[d+p],0,e).length)}return o}function ch(n,t,e){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(Nx))} + ${parseFloat(n[1].toFixed(Nx))}j`:td(n)?s=`'${n}'`:e==="bool"?s=eD(n):s=parseFloat(n.toFixed(Nx)).toString(),kc(s,t)}function eD(n){return n===0?"false":"true"}function lm(n,t,e,s,i,r=!0){const o=e==="complex64"?2:1,l=t[0],c=t.length;if(c===0){if(e==="complex64"){const x=uh(n);return[ch(x[0],0,e)]}return e==="bool"?[eD(n[0])]:[n[0].toString()]}if(c===1){if(l>FI){const w=sh*o;let S=Array.from(n.slice(0,w)),T=Array.from(n.slice((l-sh)*o,l*o));return e==="complex64"&&(S=uh(S),T=uh(T)),["["+S.map((k,$)=>ch(k,i[$],e)).join(", ")+", ..., "+T.map((k,$)=>ch(k,i[l-sh+$],e)).join(", ")+"]"]}return["["+(e==="complex64"?uh(n):Array.from(n)).map((w,S)=>ch(w,i[S],e)).join(", ")+"]"]}const h=t.slice(1),d=s.slice(1),p=s[0]*o,m=[];if(l>FI){for(let x=0;x<sh;x++){const w=x*p,S=w+p;m.push(...lm(n.slice(w,S),h,e,d,i,!1))}m.push("...");for(let x=l-sh;x<l;x++){const w=x*p,S=w+p;m.push(...lm(n.slice(w,S),h,e,d,i,x===l-1))}}else for(let x=0;x<l;x++){const w=x*p,S=w+p;m.push(...lm(n.slice(w,S),h,e,d,i,x===l-1))}const y=c===2?",":"";m[0]="["+(l>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<c;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(r?"":b),m}function uh(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class On{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=ft(t),s!=null){const i=s.length;F(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Qe(e,this.size),this.strides=Ot(t)}set(t,...e){e.length===0&&(e=[0]),F(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const i of t){if(i<0||i>=this.shape[e]){const r=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(r)}e++}let s=t[t.length-1];for(let i=0;i<t.length-1;++i)s+=this.strides[i]*t[i];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Mi().makeTensor(this.values,this.shape,this.dtype)}}let Mi=null,mc=null;function t5(n){Mi=n}function e5(n){mc=n}class gn{constructor(t,e,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ft(t),this.strides=Ot(t),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return mc.buffer(this.shape,this.dtype,t)}bufferSync(){return mc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return zi(this.shape,t,this.dtype==="complex64")}arraySync(){return zi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Mi().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(s=>Fo(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Mi().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Mi().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Fo(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Mi().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Mi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return mc.print(this,t)}clone(){return this.throwIfDisposed(),mc.clone(this)}toString(t=!1){const e=this.dataSync();return Z6(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),mc.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),Mi().makeVariable(this,t,e,s)}}Object.defineProperty(gn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function dt(){return s1("Tensor",()=>gn)}dt();class Am extends gn{constructor(t,e,s,i){super(t.shape,t.dtype,t.dataId,i),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!me(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Mi().disposeTensor(this),this.dataId=t.dataId,Mi().incRef(this,null)}dispose(){Mi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Am,Symbol.hasInstance,{value:n=>n instanceof gn&&n.assign!=null&&n.assign instanceof Function});var LI;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(LI||(LI={}));var Lv;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Lv||(Lv={}));var zv;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(zv||(zv={}));var Pv;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Pv||(Pv={}));var Bv;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Bv||(Bv={}));const n5={float32:Pv,int32:Lv,bool:zv,complex64:Bv};function Ns(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return n5[n][t]}function W1(n){return Ns(n,"int32")}function nD(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function sD(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function en(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ns(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function iD(n){const t=[];return rD(n,t,new Set),t}function rD(n,t,e){if(n==null)return;if(n instanceof gn){t.push(n);return}if(!s5(n))return;const s=n;for(const i in s){const r=s[i];e.has(r)||(e.add(r),rD(r,t,e))}}function s5(n){return Array.isArray(n)||typeof n=="object"}function Ax(n){return n.kernelName!=null}class zI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Dc{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new zI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,s=1){return t in this.registryFactory?(Ws(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:s}=this.initializeBackend(t);if(!(s?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new q6(this.backendInstance),!0}setupRegisteredKernels(){DI(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){DI(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=e.factory();if(s&&!(s instanceof Jw)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(o=>i<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Ws(`Initialization of backend ${t} failed`),Ws(o.stack||o.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Ws(`Initialization of backend ${t} failed`),Ws(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const s=t[e],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const s=this.state.tensorInfo.get(e),i=s.backend,r=this.readSync(e),o=i.refCount(e);i.disposeData(e,!0),s.backend=t,t.move(e,r,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=e(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(t,e,s){t();try{const i=s();return e(),i}catch(i){throw e(),i}}nextTensorId(){return Dc.nextTensorId++}nextVariableId(){return Dc.nextVariableId++}clone(t){const e=Z.runKernel(wd,{x:t}),s={x:t},i=o=>({x:()=>{const l="float32",c={x:o},h={dtype:l};return Z.runKernel(ld,c,h)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[e],i,r,{}),e}runKernel(t,e,s){if(this.backendName==null&&this.backend,!(_I(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,s){const i=this.backend.numDataIds();let r=0;s.forEach(c=>{r+=c.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=i-e-r-o;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`)}runKernelFunc(t){let e,s=[];const i=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let c;const h=Ax(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ax(t)){const{kernelName:b,inputs:x,attrs:w}=t;this.backendName==null&&this.backend;const S=_I(b,this.backendName);F(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),l=()=>{const T=this.backend.numDataIds();c=S.kernelFunc({inputs:x,attrs:w,backend:this.backend});const k=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,T,k);const $=k.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(i){const E=this.getTensorsForGradient(b,x,$);s=this.saveTensorsForBackwardMode(E)}return $}}else{const{forwardFunc:b}=t,x=w=>{i&&(s=w.map(S=>this.keep(this.clone(S))))};l=()=>{const w=this.backend.numDataIds();c=this.tidy(()=>b(this.backend,x));const S=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,S),S}}const{inputs:d,attrs:p}=t,m=Ax(t)?null:t.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=l():(y=this.profiler.profileKernel(h,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),i&&this.addTapeNode(h,d,e,m,s,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:e.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(c)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,e,s){const i=RI(t);if(i!=null){const r=i.inputsToSave||[],o=i.outputsToSave||[];let l;i.saveAllInputs?(F(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(e).map(h=>e[h])):l=r.map(h=>e[h]);const c=s.filter((h,d)=>o[d]);return l.concat(c)}return[]}makeTensor(t,e,s,i){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=t;s==="string"&&td(t[0])&&(r=t.map(c=>_o(c)));const o=i.write(r,e,s),l=new gn(e,s,o,this.nextTensorId());if(this.trackTensor(l,i),s==="string"){const c=this.state.tensorInfo.get(o),h=T6(r);this.state.numBytes+=h-c.bytes,c.bytes=h}return l}makeTensorFromDataId(t,e,s,i){s=s||"float32";const r={dataId:t,shape:e,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(t,e){const{dataId:s,shape:i,dtype:r}=t,o=new gn(i,r,s,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==t.dtype&&(t=t.cast(i));const r=new Am(t,e,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*$m(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Am||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*$m(t.dtype);this.state.numBytes-=s}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,s,i,r,o){const l={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:s,saved:r},c=RI(t);c!=null&&(i=c.gradFunc),i!=null&&(l.gradient=h=>(h=h.map((d,p)=>{if(d==null){const m=s[p],y=qn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),i(h.length>1?h:h[0],r,o))),this.state.activeTape.push(l)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=iD(t),s=new Set(e.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const o=this.state.activeScope.track[r];!o.kept&&!s.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(t,e,s,i=!1){if(F(e.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));F(r instanceof gn,()=>"The result y returned by f() must be a tensor.");const o=Y6(this.state.activeTape,e,r);if(!i&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[r.id]=s??i5(r.shape),J6(l,o,h=>this.tidy(h),r5);const c=e.map(h=>l[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:r,grads:c}})}customGrad(t){return F(_v(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{F(e.every(l=>l instanceof gn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};e.forEach((l,c)=>{i[c]=l});const r=(l,c)=>(s=t(...e,c),F(s.value instanceof gn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),F(_v(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(l,c)=>{const h=s.gradFunc(l,c),d=Array.isArray(h)?h:[h];F(d.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),F(d.every(m=>m instanceof gn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return d.forEach((m,y)=>{p[y]=()=>m}),p};return this.runKernelFunc({forwardFunc:r,backwardsFunc:o,inputs:i})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=cs(),s=await this.backend.time(t);return s.wallMs=cs()-e,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new zI;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Dc.nextTensorId=0;Dc.nextVariableId=0;function i5(n){const t=e1(ft(n),"float32");return Z.makeTensor(t,n,"float32")}function oD(){const n=$R();if(n._tfengine==null){const t=new E6(n);n._tfengine=new Dc(t)}return _6(n._tfengine.ENV),t5(()=>n._tfengine),n._tfengine}const Z=oD();function r5(n,t){const e={a:n,b:t};return Z.runKernel(Kc,e)}function o5(){return typeof navigator<"u"&&navigator!=null}function aD(n){if(n||o5()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function lD(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const ps=at();ps.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ps.registerFlag("IS_BROWSER",()=>lD());ps.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ps.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ps.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ps.registerFlag("PROD",()=>!1);ps.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ps.getBool("DEBUG"));ps.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ps.registerFlag("IS_TEST",()=>!1);ps.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ps.getBool("DEBUG"));ps.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ps.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ps.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Yd(n,t){let e=n;if(yi(n))return t==="string"?[]:[n.length];if(nD(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(sD(n))return[n.buffer.size/(t==null?4:$m(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||yi(e)&&t!=="string";)s.push(e.length),e=e[0];return Array.isArray(n)&&at().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&cD(n,s,[]),s}function cD(n,t,e){if(e=e||[],!Array.isArray(n)&&!yi(n)){F(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}F(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),F(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let i=0;i<n.length;++i)cD(n[i],s,e.concat(i))}function PI(n,t,e,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function U(n,t,e,s="numeric"){if(n instanceof dt())return PI(s,n.dtype,t,e),n;let i=Hc(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),PI(s,i,t,e),n==null||!yi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${c}'`)}const r=Yd(n,i);!yi(n)&&!Array.isArray(n)&&(n=[n]);const l=i!=="string"?ol(n,i):Ha(n,[],!0);return Z.makeTensor(l,r,i)}function uD(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,o)=>U(r,`${t}[${o}]`,e,s))}const a5="__op";function et(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+a5;const i=(...r)=>{Z.startScope(e);try{const o=s(...r);return n1(o)&&console.error("Cannot return a Promise inside of tidy."),Z.endScope(o),o}catch(o){throw Z.endScope(null),o}};return Object.defineProperty(i,"name",{value:e,configurable:!0}),i}function l5(n,t){const e=U(n,"real","complex"),s=U(t,"imag","complex");Qw(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:e,imag:s};return Z.runKernel(h1,i)}const qa=et({complex_:l5});function Jd(n,t,e,s){if(s==null)s=Hc(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(sD(n)||nD(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Z.backend.createTensorFromGPUData(n,t||e,s)}if(!yi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Kr(t);const i=ft(t),r=ft(e);F(i===r,()=>`Based on the provided shape, [${t}], the tensor should have ${i} values but has ${r}`);for(let o=0;o<e.length;++o){const l=e[o],c=o===e.length-1?l!==ft(t.slice(o)):!0;F(e[o]===t[o]||!c,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!yi(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=s!=="string"?ol(n,s):Ha(n,[],!0),Z.makeTensor(n,t,s)}function wh(n,t,e){const s=Yd(n,e);return Jd(n,t,s,e)}const _m={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Wo{static join(t){return new Wo(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>yi(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const i=t[s];s!==t.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=e+i.byteLength;this.shards.push({buffer:i,start:e,end:r}),e=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const i=e-t,r=new ArrayBuffer(i),o=new Uint8Array(r);let l=0;for(let c=s;c<this.shards.length;c++){const h=this.shards[c],p=t+l-h.start,m=l,b=Math.min(e,h.end)-h.start,x=new Uint8Array(h.buffer,p,b-p);if(o.set(x,m),l+=x.length,e<h.end)break}return r}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(i){return t<i.start?-1:t>=i.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=c5(this.shards,e);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function c5(n,t){let e=0,s=n.length;for(;e<=s;){const i=Math.floor((s-e)/2)+e,r=t(n[i]);if(r===0)return i;r<0?s=i:e=i+1}return-1}function Ji(){return Z}function BI(){return Z.memory()}function it(n,t){return Z.tidy(n,t)}function Yt(n){iD(n).forEach(e=>e.dispose())}function or(n){return Z.keep(n)}function VI(n){return Z.setBackend(n)}function u5(){return Z.ready()}function hD(n,t,e=1){return Z.registerBackend(n,t,e)}function h5(){return Z.backend}const Oc=4;async function UI(n,t){const e=[],s=[],i=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<i.length;++o){const l=i[o],c=Array.isArray(n)?n[o].tensor:n[l];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${c.dtype}`);const h={name:l,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const d=new Promise(async p=>{const m=await c.bytes(),y=m.reduce((w,S)=>w+S.length,0)+Oc*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const S=m[w],T=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(T,x),x+=Oc,b.set(S,x),x+=S.length}p(b)});s.push(d)}else s.push(c.data());t!=null&&(h.group=t),e.push(h)}const r=await Promise.all(s);return{data:m5(r),specs:e}}function d5(n,t){const e=new Wo(n),s={};let i=0;for(const r of t){const o=f5(r,(l,c)=>e.slice(i+l,i+c));s[r.name]=p5(r,e.slice(i,i+o)),i+=o}return s}function f5(n,t){const e=ft(n.shape);let s;if("quantization"in n){const i=n.quantization;s=_m[i.dtype]}else if(n.dtype==="string"){let i=0;for(let r=0;r<e;r++)i+=Oc+new Uint32Array(t(i,i+Oc))[0];return i}else s=_m[n.dtype];return e*s}function p5(n,t){const e=n.name,s=n.dtype,i=n.shape,r=ft(i);let o,l=0;if("quantization"in n){const c=n.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${n.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=_m[c.dtype],d=c.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){o=new Float32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=m*c.scale+c.min}}else if(c.dtype==="float16")o=k5()(d);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(s==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);o=new Int32Array(d.length);for(let p=0;p<d.length;p++){const m=d[p];o[p]=Math.round(m*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);l+=r*h}else if(s==="string"){const c=ft(n.shape);o=[];for(let h=0;h<c;h++){const d=new Uint32Array(t.slice(l,l+Oc))[0];l+=Oc;const p=new Uint8Array(t.slice(l,l+d));o.push(p),l+=d}}else{const c=_m[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);const h=new Float32Array(o.length/2),d=new Float32Array(o.length/2);for(let b=0;b<h.length;b++)h[b]=o[b*2],d[b]=o[b*2+1];const p=wh(h,i,"float32"),m=wh(d,i,"float32"),y=qa(p,m);return p.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${e}': ${s}`);l+=r*c}return wh(o,i,s)}function m5(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(r=>{if(t+=r.byteLength,e.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(t);let i=0;return e.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const H1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function jI(n){return H1?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function g5(n){if(H1)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,i=t.length;s<i;s++)e+=String.fromCharCode(t[s]);return btoa(e)}function y5(n){if(H1){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}function b5(n){return Wo.join(n)}function x5(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function v5(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function w5(n,t){let e,s;return n.weightsManifest!=null&&([e,s]=await t(n.weightsManifest)),v5(n,e,s)}function q1(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:jI(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:jI(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Wo(n.weightData).byteLength}}function GI(n){const t=[];for(const e of n)t.push(...e.weights);return t}function S5(){const n=e=>{let s=e<<13,i=0;for(;(s&8388608)===0;)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function C5(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function T5(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function k5(){const n=S5(),t=C5(),e=T5();return s=>{const i=new ArrayBuffer(4*s.length),r=new Uint32Array(i);for(let o=0;o<s.length;o++){const l=s[o],c=n[e[l>>10]+(l&1023)]+t[l>>10];r[o]=c}return new Float32Array(i)}}class $n{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return $n.instance==null&&($n.instance=new $n),$n.instance}static registerSaveRouter(t){$n.getInstance().saveRouters.push(t)}static registerLoadRouter(t){$n.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return $n.getHandlers(t,"save")}static getLoadHandlers(t,e){return $n.getHandlers(t,"load",e)}static getHandlers(t,e,s){const i=[];return(e==="load"?$n.getInstance().loadRouters:$n.getInstance().saveRouters).forEach(o=>{const l=o(t,s);l!==null&&i.push(l)}),i}}const $5=n=>$n.getSaveHandlers(n),E5=(n,t)=>$n.getLoadHandlers(n,t);const Vv="tensorflowjs",Uv=1,Ma="models_store",Eo="model_info_store";function dD(){if(!at().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function jv(n){const t=n.result;t.createObjectStore(Ma,{keyPath:"modelPath"}),t.createObjectStore(Eo,{keyPath:"modelPath"})}class Ka{constructor(t){if(this.indexedDB=dD(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((s,i)=>{const r=this.indexedDB.open(Vv,Uv);r.onupgradeneeded=()=>jv(r),r.onsuccess=()=>{const o=r.result;if(e==null){const l=o.transaction(Ma,"readonly"),h=l.objectStore(Ma).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(o.close(),i(h.error)),l.oncomplete=()=>o.close()}else{e.weightData=Wo.join(e.weightData);const l=q1(e),c=o.transaction(Eo,"readwrite");let h=c.objectStore(Eo),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(m){return i(m)}let p;d.onsuccess=()=>{p=o.transaction(Ma,"readwrite");const m=p.objectStore(Ma);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:l})}catch(b){return i(b)}y.onsuccess=()=>s({modelArtifactsInfo:l}),y.onerror=b=>{h=c.objectStore(Eo);const x=h.delete(this.modelPath);x.onsuccess=()=>(o.close(),i(y.error)),x.onerror=w=>(o.close(),i(y.error))}},d.onerror=m=>(o.close(),i(d.error)),c.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}}},r.onerror=o=>i(r.error)})}}Ka.URL_SCHEME="indexeddb://";const fD=n=>at().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ka.URL_SCHEME)?I5(n.slice(Ka.URL_SCHEME.length)):null;$n.registerSaveRouter(fD);$n.registerLoadRouter(fD);function I5(n){return new Ka(n)}function N5(n){return n.startsWith(Ka.URL_SCHEME)?n.slice(Ka.URL_SCHEME.length):n}class A5{constructor(){this.indexedDB=dD()}async listModels(){return new Promise((t,e)=>{const s=this.indexedDB.open(Vv,Uv);s.onupgradeneeded=()=>jv(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(Eo,"readonly"),l=r.objectStore(Eo).getAll();l.onsuccess=()=>{const c={};for(const h of l.result)c[h.modelPath]=h.modelArtifactsInfo;t(c)},l.onerror=c=>(i.close(),e(l.error)),r.oncomplete=()=>i.close()},s.onerror=i=>e(s.error)})}async removeModel(t){return t=N5(t),new Promise((e,s)=>{const i=this.indexedDB.open(Vv,Uv);i.onupgradeneeded=()=>jv(i),i.onsuccess=()=>{const r=i.result,o=r.transaction(Eo,"readwrite"),l=o.objectStore(Eo),c=l.get(t);let h;c.onsuccess=()=>{if(c.result==null)return r.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),p=()=>{h=r.transaction(Ma,"readwrite");const y=h.objectStore(Ma).delete(t);y.onsuccess=()=>e(c.result.modelArtifactsInfo),y.onerror=b=>s(c.error)};d.onsuccess=p,d.onerror=m=>(p(),r.close(),s(c.error))}},c.onerror=d=>(r.close(),s(c.error)),o.oncomplete=()=>{h==null?r.close():h.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}}const Pr="/",gc="tensorflowjs_models",pD="info",_5="model_topology",R5="weight_specs",D5="weight_data",O5="model_metadata";function mD(n){return{info:[gc,n,pD].join(Pr),topology:[gc,n,_5].join(Pr),weightSpecs:[gc,n,R5].join(Pr),weightData:[gc,n,D5].join(Pr),modelMetadata:[gc,n,O5].join(Pr)}}function gD(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function M5(n){const t=n.split(Pr);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Pr)}function F5(n){return n.startsWith(Xa.URL_SCHEME)?n.slice(Xa.URL_SCHEME.length):n}class Xa{constructor(t){if(!at().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=mD(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),i=q1(t),r=Wo.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,g5(r));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:i}}catch{throw gD(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const l=JSON.parse(r);e.format=l.format,e.generatedBy=l.generatedBy,e.convertedBy=l.convertedBy,l.signature!=null&&(e.signature=l.signature),l.userDefinedMetadata!=null&&(e.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(e.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(e.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(e.trainingConfig=l.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=y5(o),e}}Xa.URL_SCHEME="localstorage://";const yD=n=>at().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xa.URL_SCHEME)?L5(n.slice(Xa.URL_SCHEME.length)):null;$n.registerSaveRouter(yD);$n.registerLoadRouter(yD);function L5(n){return new Xa(n)}class z5{constructor(){F(at().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),F(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=gc+Pr,s=Pr+pD;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(e)&&r.endsWith(s)){const o=M5(r);t[o]=JSON.parse(this.LS.getItem(r))}}return t}async removeModel(t){t=F5(t);const e=mD(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(e.info));return gD(e),s}}const WI="://";class Zi{constructor(){this.managers={}}static getInstance(){return Zi.instance==null&&(Zi.instance=new Zi),Zi.instance}static registerManager(t,e){F(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(WI)&&(t=t.slice(0,t.indexOf(WI))),F(t.length>0,()=>"scheme must not be an empty string.");const s=Zi.getInstance();F(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=Zi.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Zi.getInstance().managers)}}class P5{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!at().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return YR(t)}}if(at().get("IS_BROWSER")){at().setPlatform("browser",new P5);try{Zi.registerManager(Xa.URL_SCHEME,new z5)}catch{}try{Zi.registerManager(Ka.URL_SCHEME,new A5)}catch{}}const B5={importFetch:()=>require("node-fetch")};let _x;class V5{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return at().global.fetch!=null?at().global.fetch(t,e):(_x==null&&(_x=B5.importFetch()),_x(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}at().get("IS_NODE")&&!at().get("IS_BROWSER")&&at().setPlatform("node",new V5);function Jt(n,t="float32",e){return t=t||"float32",Kr(n),new On(n,t,e)}function U5(n,t){const e=U(n,"x","cast");if(!C6(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:e},i={dtype:t};return Z.runKernel(ld,s,i)}const $t=et({cast_:U5});function j5(n){const e={x:U(n,"x","clone","string_or_numeric")};return Z.runKernel(wd,e)}const Va=et({clone_:j5});function G5(n,t=!1){console.log(n.toString(t))}oD();const W5={buffer:Jt,cast:$t,clone:Va,print:G5};e5(W5);function H5(n,t){let e=U(n,"a","add"),s=U(t,"b","add");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(Kc,i)}const wt=et({add_:H5});function q5(n,t){let e=U(n,"a","floorDiv"),s=U(t,"b","floorDiv");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(xd,i)}const bD=et({floorDiv_:q5});function K5(n,t){let e=U(n,"a","div"),s=U(t,"b","div");if([e,s]=en(e,s),e.dtype==="int32"&&s.dtype==="int32")return bD(e,s);const i={a:e,b:s},r={};return Z.runKernel(fd,i,r)}const Lt=et({div_:K5});function X5(n,t){let e=U(n,"a","mul"),s=U(t,"b","mul");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(Ad,i)}const Y=et({mul_:X5});function Y5(n){const t=U(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return Z.runKernel(gg,e)}else{const e={x:t};return Z.runKernel(cg,e)}}const Qn=et({abs_:Y5});function J5(n){const e={x:U(n,"x","acos")};return Z.runKernel(ed,e)}const Z5=et({acos_:J5});function Q5(n){const e={x:U(n,"x","acosh")};return Z.runKernel(nd,e)}const tq=et({acosh_:Q5});function eq(n,t=null,e=!1){const i={x:U(n,"x","all","bool")},r={axis:t,keepDims:e};return Z.runKernel(r1,i,r)}const xD=et({all_:eq});function nq(n,t=null,e=!1){const i={x:U(n,"x","any","bool")},r={axis:t,keepDims:e};return Z.runKernel(o1,i,r)}const Gv=et({any_:nq});function sq(n,t=0){const s={x:U(n,"x","argMax")},i={axis:t};return Z.runKernel(ug,s,i)}const Mh=et({argMax_:sq});function iq(n,t=0){const s={x:U(n,"x","argMin")},i={axis:t};return Z.runKernel(hg,s,i)}const rq=et({argMin_:iq});function oq(n){const e={x:U(n,"x","asin")};return Z.runKernel(sd,e)}const aq=et({asin_:oq});function lq(n){const e={x:U(n,"x","asinh")};return Z.runKernel(id,e)}const cq=et({asinh_:lq});function uq(n){const e={x:U(n,"x","atan")};return Z.runKernel(rd,e)}const hq=et({atan_:uq});function dq(n,t){let e=U(n,"a","atan2"),s=U(t,"b","atan2");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(ad,i)}const fq=et({atan2_:dq});function pq(n){const e={x:U(n,"x","atanh")};return Z.runKernel(od,e)}const mq=et({atanh_:pq});function Zd(n,t,e,s,i="NHWC",r){const o=n[3],l=[...t,o],c=Yr(i);return Mn(n,l,e,r,s,null,null,c)}function xi(n,t,e,s,i,r,o="channelsLast"){const[l,c]=Fh(t);let h;if(o==="channelsLast")h=[l,c,n[3],n[3]];else if(o==="channelsFirst")h=[l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Mn(n,h,e,s,i,r,!1,o)}function Xr(n,t,e,s,i,r,o="NDHWC"){const[l,c,h]=Wv(t);let d,p;if(o==="NDHWC")p="channelsLast",d=[l,c,h,n[4],n[4]];else if(o==="NCDHW")p="channelsFirst",d=[l,c,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ho(n,d,e,s,i,!1,p,r)}function Mn(n,t,e,s,i,r,o=!1,l="channelsLast"){let[c,h,d,p]=[-1,-1,-1,-1];if(l==="channelsLast")[c,h,d,p]=n;else if(l==="channelsFirst")[c,p,h,d]=n;else throw new Error(`Unknown dataFormat ${l}`);const[m,y,,b]=t,[x,w]=Fh(e),[S,T]=Fh(s),k=Ec(m,S),$=Ec(y,T),{padInfo:E,outHeight:N,outWidth:_}=bq(i,h,d,x,w,k,$,r,l),R=o?b*p:b;let D;return l==="channelsFirst"?D=[c,R,N,_]:l==="channelsLast"&&(D=[c,N,_,R]),{batchSize:c,dataFormat:l,inHeight:h,inWidth:d,inChannels:p,outHeight:N,outWidth:_,outChannels:R,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:k,effectiveFilterWidth:$,dilationHeight:S,dilationWidth:T,inShape:n,outShape:D,filterShape:t}}function Ho(n,t,e,s,i,r=!1,o="channelsLast",l){let[c,h,d,p,m]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[c,h,d,p,m]=n;else if(o==="channelsFirst")[c,m,h,d,p]=n;else throw new Error(`Unknown dataFormat ${o}`);const[y,b,x,,w]=t,[S,T,k]=Wv(e),[$,E,N]=Wv(s),_=Ec(y,$),R=Ec(b,E),D=Ec(x,N),{padInfo:M,outDepth:A,outHeight:B,outWidth:H}=xq(i,h,d,p,S,T,k,_,R,D,l),J=r?w*m:w;let X;return o==="channelsFirst"?X=[c,J,A,B,H]:o==="channelsLast"&&(X=[c,A,B,H,J]),{batchSize:c,dataFormat:o,inDepth:h,inHeight:d,inWidth:p,inChannels:m,outDepth:A,outHeight:B,outWidth:H,outChannels:J,padInfo:M,strideDepth:S,strideHeight:T,strideWidth:k,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:_,effectiveFilterHeight:R,effectiveFilterWidth:D,dilationDepth:$,dilationHeight:E,dilationWidth:N,inShape:n,outShape:X,filterShape:t}}function gq(n,t,e,s,i){s==null&&(s=K1(n,t,e));const r=n[0],o=n[1],l=Lh((r-t+2*s)/e+1,i),c=Lh((o-t+2*s)/e+1,i);return[l,c]}function yq(n,t,e,s,i,r){i==null&&(i=K1(n,t[0],s[0]));const o=[0,0,0,e];for(let l=0;l<3;l++)n[l]+2*i>=t[l]&&(o[l]=Lh((n[l]-t[l]+2*i)/s[l]+1,r));return o}function K1(n,t,e,s=1){const i=Ec(t,s);return Math.floor((n[0]*(e-1)-e+i)/2)}function Fh(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Wv(n){return typeof n=="number"?[n,n,n]:n}function Ec(n,t){return t<=1?n:n+(n-1)*(t-1)}function bq(n,t,e,s,i,r,o,l,c){let h,d,p;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=gq([t,e],r,s,n,l);d=y[0],p=y[1]}else if(n==="same"){d=Math.ceil(t/s),p=Math.ceil(e/i);const m=Math.max(0,(d-1)*s+r-t),y=Math.max(0,(p-1)*i+o-e),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),S=y-w;h={top:b,bottom:x,left:w,right:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-r+1)/s),p=Math.ceil((e-o+1)/i);else if(typeof n=="object"){const m=c==="channelsLast"?n[1][0]:n[2][0],y=c==="channelsLast"?n[1][1]:n[2][1],b=c==="channelsLast"?n[2][0]:n[3][0],x=c==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=Lh((t-r+m+y)/s+1,l),p=Lh((e-o+b+x)/i+1,l)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:p}}function xq(n,t,e,s,i,r,o,l,c,h,d){let p,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=yq([t,e,s,1],[l,c,h],1,[i,r,o],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(t/i),y=Math.ceil(e/r),b=Math.ceil(s/o);const x=(m-1)*i+l-t,w=(y-1)*r+c-e,S=(b-1)*o+h-s,T=Math.floor(x/2),k=x-T,$=Math.floor(w/2),E=w-$,N=Math.floor(S/2),_=S-N;p={top:$,bottom:E,left:N,right:_,front:T,back:k,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:m,outHeight:y,outWidth:b}}function Lh(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ya(n){const[t,e,s]=Fh(n);return t===1&&e===1&&s===1}function Xn(n,t){return Ya(n)||Ya(t)}function Ja(n){return Fh(n).every(t=>t>0)}function Yr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function gs(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")F(Rc(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(i=>{F(Rc(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function vq(n,t){const s={x:U(n,"x","reshape","string_or_numeric")},i={shape:t};return Z.runKernel(Yg,s,i)}const tt=et({reshape_:vq});function wq(n,t,e,s,i){const r=U(n,"x","avgPool","float32"),o=1;F(Xn(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let l=r,c=!1;r.rank===3&&(c=!0,l=tt(r,[1,r.shape[0],r.shape[1],r.shape[2]])),F(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),gs("avgPool",s,i);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:i};let p=Z.runKernel(dg,h,d);return p=$t(p,r.dtype),c?tt(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const X1=et({avgPool_:wq});function Sq(n,t,e,s,i,r="NDHWC"){const o=U(n,"x","avgPool3d","float32");let l=o,c=!1;o.rank===4&&(c=!0,l=tt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),F(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),F(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),F(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),gs("avgPool3d",s,i);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:i,dataFormat:r};let p=Z.runKernel(fg,h,d);return p=$t(p,l.dtype),c?tt(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Cq=et({avgPool3d_:Sq});function Tq(n,t=0){F(n.length>=1,()=>"Pass at least one tensor to concat");const e=uD(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),e.length===1)return Va(e[0]);const s=e,i={axis:t};return Z.runKernel(yg,s,i)}const fs=et({concat_:Tq});function kq(n,t,e=!1,s=!1){let i=U(n,"a","matMul"),r=U(t,"b","matMul");[i,r]=en(i,r);const o={a:i,b:r},l={transposeA:e,transposeB:s};return Z.runKernel(pg,o,l)}const fe=et({matMul_:kq});function $q(n){const e={x:U(n,"x","sigmoid","float32")};return Z.runKernel(Vd,e)}const Xc=et({sigmoid_:$q});function Eq(n,t,e){const s=U(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:t,size:e};return Z.runKernel(ey,i,r)}const Re=et({slice_:Eq});function Iq(n){const e={x:U(n,"x","tanh","float32")};return Z.runKernel(qd,e)}const uy=et({tanh_:Iq});function Nq(n,t,e){const s=U(n,"x","batchToSpaceND"),i=t.reduce((l,c)=>l*c);F(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),F(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),F(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`);const r={x:s},o={blockShape:t,crops:e};return Z.runKernel(mg,r,o)}const Y1=et({batchToSpaceND_:Nq});function Aq(n){let t;return n.rank===0||n.rank===1?t=tt(n,[1,1,1,n.size]):n.rank===2?t=tt(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=tt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function _q(n,t,e,s,i,r){r==null&&(r=.001);const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;i!=null&&(h=U(i,"scale","batchNorm"));let d;s!=null&&(d=U(s,"offset","batchNorm")),F(l.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(d==null||l.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(h==null||l.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:Aq(o),scale:h,offset:d,mean:l,variance:c},y={varianceEpsilon:r},b=Z.runKernel($g,m,y);return tt(b,o.shape)}const hy=et({batchNorm_:_q});function Rq(n,t,e,s,i,r){const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;i!=null&&(h=U(i,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),F(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),F(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),F(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),h!=null&&F(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&F(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),hy(o,l,c,d,h,r)}const Dq=et({batchNorm2d_:Rq});function Oq(n,t,e,s,i,r){const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;i!=null&&(h=U(i,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),F(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),F(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),F(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),h!=null&&F(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&F(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),hy(o,l,c,d,h,r)}const Mq=et({batchNorm3d_:Oq});function Fq(n,t,e,s,i,r){const o=U(n,"x","batchNorm"),l=U(t,"mean","batchNorm"),c=U(e,"variance","batchNorm");let h;i!=null&&(h=U(i,"scale","batchNorm"));let d;return s!=null&&(d=U(s,"offset","batchNorm")),F(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),F(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),F(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),h!=null&&F(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&F(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),hy(o,l,c,d,h,r)}const Lq=et({batchNorm4d_:Fq});function zq(n,t,e){const s=U(n,"x","bincount"),i=U(t,"weights","bincount");F(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),F(e>=0,()=>`size must be non-negative, but got ${e}.`),F(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},o={size:e};return Z.runKernel(c1,r,o)}const Pq=et({bincount_:zq});function Bq(n,t){let e=U(n,"broadcastTo","x");const s=e.shape;if(Kr(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const h=e.shape.slice();for(;h.length<t.length;)h.unshift(1);e=tt(e,h)}const i=e.shape,r=Array.from(t);for(let h=t.length-1;h>=0;h--)if(i[h]===t[h])r[h]=1;else if(e.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(r.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Va(e);const l={x:e},c={reps:r};return Z.runKernel(Kd,l,c)}const Sh=et({broadcastTo_:Bq});function Vq(n){const e={x:U(n,"x","ceil","float32")};return Z.runKernel(cd,e)}const Uq=et({ceil_:Vq});function dy(n,t,e){Kr(n),e=e||Hc(t);const s={shape:n,value:t,dtype:e};return Z.runKernel(T1,{},s)}function jq(n,t,e){const s=U(n,"x","clipByValue");if(F(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return dy(s.shape,t,s.dtype);const i={x:s},r={clipValueMin:t,clipValueMax:e};return Z.runKernel(ud,i,r)}const Ks=et({clipByValue_:jq});function Gq(n){return fs(n,0)}const Wq=et({concat1d_:Gq});function Hq(n,t){return fs(n,t)}const qq=et({concat2d_:Hq});function Kq(n,t){return fs(n,t)}const Xq=et({concat3d_:Kq});function Yq(n,t){return fs(n,t)}const Jq=et({concat4d_:Yq});function Zq(n,t,e,s,i="NHWC",r=[1,1],o){const l=U(n,"x","conv2d","float32"),c=U(t,"filter","conv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=tt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),F(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),F(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),gs("conv2d",s,o);const p=i==="NHWC"?h.shape[3]:h.shape[1];F(p===c.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${c.shape[2]}.`),F(Xn(e,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),F(Ja(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),F(Ja(e),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:c},y={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},b=Z.runKernel(bg,m,y);return d?tt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Za=et({conv2d_:Zq});function Qq(n,t,e,s,i="NWC",r=1,o){const l=U(n,"x","conv1d"),c=U(t,"filter","conv1d");let h=l,d=!1;l.rank===2&&(d=!0,h=tt(l,[1,l.shape[0],l.shape[1]])),F(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),F(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),gs("conv1d",s,o),F(h.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${c.shape[1]}.`),F(Xn(e,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${r}'`),F(Ja(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),F(Ja(e),()=>"Error in conv1D: Stride should be larger than 0."),F(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const p=tt(c,[1,c.shape[0],c.shape[1],c.shape[2]]),m=tt(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=Za(m,p,[1,e],s,"NHWC",[1,r],o);return d?tt(w,[w.shape[2],w.shape[3]]):tt(w,[w.shape[0],w.shape[2],w.shape[3]])}const vD=et({conv1d_:Qq});function t8(n,t,e,s,i,r="NHWC",o){F(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let l=n,c=t,h=!1;t.rank===3&&(h=!0,c=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),l=[1,n[0],n[1],n[2]]),F(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),F(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),F(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const d=r==="NHWC"?l[3]:l[1],p=r==="NHWC"?c.shape[3]:c.shape[1];F(d===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${e.shape[2]}.`),F(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),gs("conv2dDerInput",i,o);const m={dy:c,filter:e},y={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,inputShape:l},b=Z.runKernel(xg,m,y);return h?tt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const J1=et({conv2DBackpropInput_:t8});function e8(n,t,e,s,i,r){const o=U(n,"x","conv2dTranspose"),l=U(t,"filter","conv2dTranspose");return J1(e,o,l,s,i,"NHWC",r)}const wD=et({conv2dTranspose_:e8});function n8(n,t,e,s,i="NDHWC",r=[1,1,1]){const o=U(n,"x","conv3d"),l=U(t,"filter","conv3d");let c=o,h=!1;o.rank===4&&(h=!0,c=tt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),F(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),F(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),F(c.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${l.shape[3]}.`),F(Xn(e,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`),F(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),F(Ja(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),F(Ja(e),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:e,pad:s,dataFormat:i,dilations:r},m=Z.runKernel(vg,d,p);return h?tt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const s8=et({conv3d_:n8});function i8(n,t,e,s,i){F(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let r=n,o=t,l=!1;t.rank===4&&(l=!0,o=tt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const c=r[4],h=o.shape[4];F(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),F(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),F(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),F(c===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[3]}.`),F(h===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${e.shape[4]}.`);const d={dy:o,filter:e},p={pad:i,strides:s,inputShape:r},m=Z.runKernel(p1,d,p);return l?tt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const SD=et({conv3DBackpropInput_:i8});function r8(n,t,e,s,i){const r=U(n,"x","conv3dTranspose"),o=U(t,"filter","conv3dTranspose");return SD(e,r,o,s,i)}const o8=et({conv3dTranspose_:r8});function a8(n){const e={x:U(n,"x","cos","float32")};return Z.runKernel(hd,e)}const Z1=et({cos_:a8});function l8(n){const e={x:U(n,"x","cosh","float32")};return Z.runKernel(dd,e)}const CD=et({cosh_:l8});function c8(n,t=0,e=!1,s=!1){const r={x:U(n,"x","cumprod")},o={axis:t,exclusive:e,reverse:s};return Z.runKernel(m1,r,o)}const Hv=et({cumprod_:c8});function u8(n,t=0,e=!1,s=!1){const r={x:U(n,"x","cumsum")},o={axis:t,exclusive:e,reverse:s};return Z.runKernel(wg,r,o)}const TD=et({cumsum_:u8});function h8(n,t,e,s=!1){const i=U(n,"x","denseBincount"),r=U(t,"weights","denseBincount");F(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),F(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),F(e>=0,()=>`size must be non-negative, but got ${e}.`),F(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const o={x:i,weights:r},l={size:e,binaryOutput:s};return Z.runKernel(y1,o,l)}const HI=et({denseBincount_:h8});function d8(n,t,e="NHWC"){const s=U(n,"x","depthToSpace","float32"),i=e==="NHWC"?s.shape[1]:s.shape[2],r=e==="NHWC"?s.shape[2]:s.shape[3],o=e==="NHWC"?s.shape[3]:s.shape[1];F(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),F(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${s.shape}`),F(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t} for depthToSpace with input shape
        ${s.shape}`),F(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const l={x:s},c={blockSize:t,dataFormat:e};return Z.runKernel(b1,l,c)}const f8=et({depthToSpace_:d8});function p8(n,t,e,s,i="NHWC",r=[1,1],o){const l=U(n,"x","depthwiseConv2d","float32"),c=U(t,"filter","depthwiseConv2d","float32");let h=l,d=!1;l.rank===3&&(d=!0,h=tt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),F(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),F(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const p=i==="NHWC"?h.shape[3]:h.shape[1];F(p===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${c.shape[2]}.`),gs("depthwiseConv2d",s,o);const m={x:h,filter:c},y={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},b=Z.runKernel(Sg,m,y);return d?tt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Q1=et({depthwiseConv2d_:p8});function m8(n,t,e,s,i=[1,1],r="NHWC"){const o=U(n,"x","dilation2d"),l=U(t,"filter","dilation2d");F(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),F(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),F(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let c=o,h=!1;o.rank===3&&(c=tt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),h=!0),F(c.shape[3]===l.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${l.shape[2]}`);const d={x:c,filter:l},p={strides:e,pad:s,dilations:i},m=Z.runKernel(Cg,d,p);return h?tt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const g8=et({dilation2d_:m8});function Mc(n,t){const e=n.length,s=[];for(let i=0;i<e;i++){const r=e-1-i,o=n[r]||1;(t[t.length-1-i]||1)>1&&o===1&&s.unshift(r)}return s}function wn(n,t){const e=[];for(let s=0;s<t.length;s++){const i=n[n.length-s-1],r=t.length-s-1,o=t[r];(i==null||i===1&&o>1)&&e.unshift(r)}return e}function Ht(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let i=0;i<e;i++){let r=n[n.length-i-1];r==null&&(r=1);let o=t[t.length-i-1];if(o==null&&(o=1),r===1)s[e-i-1]=o;else if(o===1)s[e-i-1]=r;else if(r!==o){const l=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(l)}else s[e-i-1]=r}return s}function y8(n,t){let e=U(n,"a","equal","string_or_numeric"),s=U(t,"b","equal","string_or_numeric");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Tg,i)}const hr=et({equal_:y8});function b8(n,t,e){const s=U(t,"a","where"),i=U(e,"b","where"),r=U(n,"condition","where","bool"),o=Ht(Ht(r.shape,s.shape),i.shape),l=Sh(r,o),c=Sh(s,o),h=Sh(i,o),d={condition:l,t:c,e:h};return Z.runKernel(ty,d)}const ss=et({where_:b8});function x8(n){const e={x:U(n,"x","zerosLike")};return Z.runKernel(ly,e)}const ae=et({zerosLike_:x8});function v8(n,t){let e=U(n,"a","div"),s=U(t,"b","div");[e,s]=en(e,s);const i=Lt(e,s),r=ae(i),o=hr(s,r);return ss(o,r,i)}const w8=et({divNoNan_:v8});function S8(n,t){const e=U(n,"t1","dot"),s=U(t,"t2","dot");F((e.rank===1||e.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const i=e.rank===1?e.size:e.shape[1],r=s.rank===1?s.size:s.shape[0];if(F(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),e.rank===1&&s.rank===1){const o=tt(e,[1,-1]),l=tt(s,[-1,1]),c=fe(o,l);return tt(c,[])}else if(e.rank===1&&s.rank===2){const o=tt(e,[1,-1]),l=tt(s,[s.shape[0],s.shape[1]]),c=fe(o,l);return tt(c,[c.size])}else if(e.rank===2&&s.rank===1){const o=tt(s,[-1,1]),l=fe(e,o);return tt(l,[l.size])}else{const o=tt(s,[s.shape[0],s.shape[1]]);return fe(e,o)}}const C8=et({dot_:S8});function T8(n,...t){const e=t.map((i,r)=>U(i,`tensors${r}`,"einsum")),s={equation:n};return Z.runKernel(w1,e,s)}const ih=et({einsum_:T8});function k8(n){const e={x:U(n,"x","elu","float32")};return Z.runKernel(pd,e)}const fy=et({elu_:k8});function $8(n){let t=U(n,"x","erf");F(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=$t(t,"float32"));const e={x:t};return Z.runKernel(md,e)}const kD=et({erf_:$8});function tS(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function $D(n,t,e){const s=n.length+t.length,i=[];let r=0,o=0;for(let l=0;l<s;l++)e.indexOf(l)===-1?i.push(n[r++]):i.push(t[o++]);return i}function An(n,t){const e=[],s=n.length;for(let r=0;r<s;r++)t.indexOf(r)===-1&&e.push(n[r]);const i=t.map(r=>n[r]);return[e,i]}function cn(n,t){const e=t.map(s=>1);return $D(n,e,t)}function Fn(n,t,e){F(tS(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function We(n,t){if(tS(n,t))return null;const e=[];for(let s=0;s<t;++s)n.indexOf(s)===-1&&e.push(s);return n.forEach(s=>e.push(s)),e}function qo(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function nn(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}function E8(n,t=null,e=!1){const i={x:U(n,"x","max")},r={reductionIndices:t,keepDims:e};return Z.runKernel(Fg,i,r)}const Pi=et({max_:E8});function I8(n,t=null,e=!1){const i={x:U(n,"x","min")},r={axis:t,keepDims:e};return Z.runKernel(Bg,i,r)}const Rm=et({min_:I8});function N8(n,t){let e=U(n,"base","pow"),s=U(t,"exp","pow");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(_d,i)}const Qa=et({pow_:N8});function pe(n,t){if((yi(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&yi(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Jd(n,[],[],t)}function A8(n){const e={x:U(n,"x","sqrt","float32")};return Z.runKernel(jd,e)}const Kn=et({sqrt_:A8});function _8(n){const t=U(n,"x","square"),e={};return Z.runKernel("Square",{x:t},e)}const Fe=et({square_:_8});function R8(n,t=null,e=!1){let s=U(n,"x","sum");s.dtype==="bool"&&(s=$t(s,"int32"));const i={x:s},r={axis:t,keepDims:e};return Z.runKernel(ny,i,r)}const Mt=et({sum_:R8});function D8(n,t="euclidean",e=null,s=!1){n=U(n,"x","norm");const i=ED(n,t,e);let r=i.shape;if(s){const o=Zt(e,n.shape);r=cn(i.shape,o)}return tt(i,r)}function ED(n,t,e=null){if(n.rank===0)return Qn(n);if(n.rank!==1&&e===null)return ED(tt(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return Mt(Qn(n),e);if(t===1/0)return Pi(Qn(n),e);if(t===-1/0)return Rm(Qn(n),e);if(t==="euclidean"||t===2)return Kn(Mt(Qa(Qn(n),pe(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Pi(Mt(Qn(n),e[0]),e[1]-1);if(t===1/0)return Pi(Mt(Qn(n),e[1]),e[0]);if(t===-1/0)return Rm(Mt(Qn(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Kn(Mt(Fe(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const py=et({norm_:D8});function O8(n,t=null,e=!1){return py(n,"euclidean",t,e)}const M8=et({euclideanNorm_:O8});function F8(n){const e={x:U(n,"x","exp")};return Z.runKernel(gd,e)}const dr=et({exp_:F8});function L8(n,t=0){const e=U(n,"x","expandDims","string_or_numeric");F(t<=e.rank,()=>"Axis must be <= rank of the tensor");const s={input:e},i={dim:t};return Z.runKernel(kg,s,i)}const us=et({expandDims_:L8});function z8(n){const e={x:U(n,"x","expm1")};return Z.runKernel(yd,e)}const P8=et({expm1_:z8});function B8(n,t){const e=U(n,"x","tile","string_or_numeric");F(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const s={x:e},i={reps:t};return Z.runKernel(Kd,s,i)}const Li=et({tile_:B8});function V8(n,t,e,s="float32"){t==null&&(t=n);const i=Jt([n,t],s),r=n<=t?n:t;for(let l=0;l<r;++l)i.set(1,l,l);const o=tt(i.toTensor(),[n,t]);if(e==null)return o;if(e.length===1)return Li(us(o,0),[e[0],1,1]);if(e.length===2)return Li(us(us(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return Li(us(us(us(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const ID=et({eye_:V8});function U8(n){const e={x:U(n,"x","floor","float32")};return Z.runKernel(bd,e)}const my=et({floor_:U8});function j8(n,t,e=0,s=0){const i=U(n,"x","gather"),r=U(t,"indices","gather","int32"),o={x:i,indices:r},l={axis:e,batchDims:s};return Z.runKernel(Eg,o,l)}const eS=et({gather_:j8});function G8(n,t){let e=U(n,"a","greater","string_or_numeric"),s=U(t,"b","greater","string_or_numeric");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Ig,i)}const Xs=et({greater_:G8});function W8(n,t){let e=U(n,"a","greaterEqual","string_or_numeric"),s=U(t,"b","greaterEqual","string_or_numeric");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(vd,i)}const al=et({greaterEqual_:W8});function H8(n){const e={input:U(n,"input","imag")};return Z.runKernel(E1,e)}const nS=et({imag_:H8});function q8(n){const e={x:U(n,"x","isFinite")};return Z.runKernel(Sd,e)}const K8=et({isFinite_:q8});function X8(n){const e={x:U(n,"x","isInf")};return Z.runKernel(Cd,e)}const Y8=et({isInf_:X8});function J8(n){const e={x:U(n,"x","isNaN")};return Z.runKernel(Td,e)}const Z8=et({isNaN_:J8});function Q8(n,t=.2){const s={x:U(n,"x","leakyRelu")},i={alpha:t};return Z.runKernel(Ng,s,i)}const sS=et({leakyRelu_:Q8});function tK(n,t){let e=U(n,"a","less","string_or_numeric"),s=U(t,"b","less","string_or_numeric");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Ag,i)}const Dm=et({less_:tK});function eK(n,t){let e=U(n,"a","lessEqual","string_or_numeric"),s=U(t,"b","lessEqual","string_or_numeric");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(_g,i)}const Yc=et({lessEqual_:eK});function nK(n,t=5,e=1,s=1,i=.5){const r=U(n,"x","localResponseNormalization");F(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),F(Rc(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=r,l=!1;r.rank===3&&(l=!0,o=tt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const c={x:o},h={depthRadius:t,bias:e,alpha:s,beta:i},d=Z.runKernel(Mg,c,h);return l?tt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const sK=et({localResponseNormalization_:nK});function iK(n){const e={x:U(n,"x","log","float32")};return Z.runKernel(kd,e)}const fr=et({log_:iK});function rK(n){const e={x:U(n,"x","log1p")};return Z.runKernel($d,e)}const ND=et({log1p_:rK});function oK(n,t){F(_v(n),()=>"The f passed in variableGrads(f) must be a function"),F(t==null||Array.isArray(t)&&t.every(h=>h instanceof Am),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const h in Z.registeredVariables)t.push(Z.registeredVariables[h])}const s=e?t.filter(h=>!h.trainable):null,i=t.length;t=t.filter(h=>h.trainable),F(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:o,grads:l}=Z.gradients(n,t,null,r);F(l.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),F(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const c={};return t.forEach((h,d)=>{l[d]!=null&&(c[h.name]=l[d])}),s?.forEach(h=>c[h.name]=null),{value:o,grads:c}}function Fc(n){return Z.customGrad(n)}function aK(n){const e={x:U(n,"x","neg")};return Z.runKernel(Ug,e)}const tn=et({neg_:aK});function lK(n){const e={x:U(n,"x","softplus")};return Z.runKernel(Ud,e)}const Qd=et({softplus_:lK});function cK(n){const t=U(n,"x","logSigmoid");return Fc(s=>({value:tn(Qd(tn(s))),gradFunc:o=>Y(o,Xc(tn(s)))}))(t)}const uK=et({logSigmoid_:cK});function hK(n,t){let e=U(n,"a","sub"),s=U(t,"b","sub");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(Wd,i)}const Bt=et({sub_:hK});function dK(n,t=-1){const e=U(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Fc((i,r)=>{const l=Pi(i,t,!0),c=Bt(i,l),h=Bt($t(c,"float32"),fr(Mt(dr(c),t,!0)));return r([h]),{value:h,gradFunc:(p,m)=>{const[y]=m,b=!0,x=dr(y);return Bt(p,Y(Mt(p,t,b),x))}}})(e)}const AD=et({logSoftmax_:dK});function fK(n,t=null,e=!1){const s=U(n,"x","logSumExp"),i=Zt(t,s.shape),r=Pi(s,i,!0),o=Bt(s,r),l=dr(o),c=Mt(l,i),h=fr(c),d=wt(tt(r,h.shape),h);if(e){const p=cn(d.shape,i);return tt(d,p)}return d}const _D=et({logSumExp_:fK});function pK(n,t){const e=U(n,"a","logicalAnd","bool"),s=U(t,"b","logicalAnd","bool");Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Rg,i)}const jr=et({logicalAnd_:pK});function mK(n){const e={x:U(n,"x","logicalNot","bool")};return Z.runKernel(Dg,e)}const iS=et({logicalNot_:mK});function gK(n,t){const e=U(n,"a","logicalOr","bool"),s=U(t,"b","logicalOr","bool");Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Og,i)}const RD=et({logicalOr_:gK});function yK(n,t){const e=U(n,"a","logicalXor","bool"),s=U(t,"b","logicalXor","bool");return Ht(e.shape,s.shape),jr(RD(n,t),iS(jr(n,t)))}const bK=et({logicalXor_:yK});function xK(n,t,e,s,i){const r=U(n,"x","maxPool"),o=1;let l=r,c=!1;r.rank===3&&(c=!0,l=tt(r,[1,r.shape[0],r.shape[1],r.shape[2]])),F(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),F(Xn(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),gs("maxPool",s,i);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:i},p=Z.runKernel(Lg,h,d);return c?tt(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const rS=et({maxPool_:xK});function vK(n,t=[1,1,1],e,s,i,r="NDHWC"){const o=U(n,"x","maxPool3d");let l=o,c=!1;o.rank===4&&(c=!0,l=tt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),F(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),F(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),gs("maxPool3d",s,i);const h={x:l},d={filterSize:t,strides:e,pad:s,dimRoundingMode:i,dataFormat:r},p=Z.runKernel(zg,h,d);return c?tt(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const wK=et({maxPool3d_:vK});function SK(n,t){let e=U(n,"a","maximum"),s=U(t,"b","maximum");[e,s]=en(e,s),e.dtype==="bool"&&(e=$t(e,"int32"),s=$t(s,"int32")),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Ed,i)}const Ko=et({maximum_:SK});function CK(n,t=null,e=!1){const i={x:U(n,"x","mean")},r={axis:t,keepDims:e};return Z.runKernel(Pg,i,r)}const ln=et({mean_:CK});function In(n,t="float32"){if(Kr(n),t==="complex64"){const s=In(n,"float32"),i=In(n,"float32");return qa(s,i)}const e=qn(ft(n),t);return Z.makeTensor(e,n,t)}function Xo(n,t="float32"){if(Kr(n),t==="complex64"){const s=Xo(n,"float32"),i=In(n,"float32");return qa(s,i)}const e=e1(ft(n),t);return Z.makeTensor(e,n,t)}function TK(n,t){let e=U(n,"a","minimum"),s=U(t,"b","minimum");[e,s]=en(e,s),e.dtype==="bool"&&(e=$t(e,"int32"),s=$t(s,"int32")),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(Id,i)}const zh=et({minimum_:TK});function kK(n,t,e){F(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=U(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");F(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const i=e==="reflect"?1:0;for(let l=0;l<s.rank;l++)F(t[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),F(t[l][0]>=0&&t[l][0]<=s.shape[l]-i&&t[l][1]>=0&&t[l][1]<=s.shape[l]-i,()=>`Padding in dimension ${l} cannot be greater than or equal to ${s.shape[l]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:t,mode:e},o={x:s};return Z.runKernel(Vg,o,r)}const $K=et({mirrorPad_:kK});function EK(n,t){let e=U(n,"a","mod"),s=U(t,"b","mod");[e,s]=en(e,s);const i={a:e,b:s};return Z.runKernel(Nd,i)}const IK=et({mod_:EK});function NK(n,t=null,e=!1){n=U(n,"x","moments");const s=Zt(t,n.shape),i=ln(n,s,e);let r=i.shape;e||(r=cn(i.shape,s));const o=Fe(Bt($t(n,"float32"),tt(i,r))),l=ln(o,s,e);return{mean:i,variance:l}}const oS=et({moments_:NK});function AK(n,t){let e=U(n,"a","notEqual","string_or_numeric"),s=U(t,"b","notEqual","string_or_numeric");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s};return Z.runKernel(jg,i)}const Om=et({notEqual_:AK});function _K(n,t,e=1,s=0,i="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:U(n,"indices","oneHot","int32")},l={dtype:i,depth:t,onValue:e,offValue:s};return Z.runKernel(Wg,o,l)}const DD=et({oneHot_:_K});function RK(n){const e={x:U(n,"x","onesLike")};return Z.runKernel(Gg,e)}const bi=et({onesLike_:RK});function DK(n,t,e=0){const s=U(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:e},r={x:s};return Z.runKernel(qg,r,i)}const aS=et({pad_:DK});function OK(n,t,e){const s=U(n,"x","spaceToBatchND");F(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),F(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),F(s.shape.reduce((o,l,c)=>c>0&&c<=t.length?o&&(l+e[c-1][0]+e[c-1][1])%t[c-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const i={x:s},r={blockShape:t,paddings:e};return Z.runKernel(sy,i,r)}const lS=et({spaceToBatchND_:OK});function MK(n,t,e,s,i,r,o){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const l=U(n,"x","maxPool");let c=l,h=!1;l.rank===3&&(h=!0,c=tt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),F(Xn(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const d=xi(c.shape,t,r,i,s),p=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=LK([d.filterHeight,d.filterWidth],p):m=[[0,0],[0,0]];const y=p[0]===1&&p[1]===1,[b,x]=FK([d.inHeight,d.inWidth],p,m),w=y?s:"valid",S=y?c:lS(c,p,b),k=(e==="avg"?()=>X1(S,t,r,w,o):()=>rS(S,t,r,w,o))(),$=y?k:Y1(k,p,x);return h?tt($,[$.shape[1],$.shape[2],$.shape[3]]):$}function FK(n,t,e){const s=e.map(d=>d[0]),i=e.map(d=>d[1]),r=n.concat(s,i),o=t.map((d,p)=>(d-r[p]%d)%d),l=i.map((d,p)=>d+o[p]),c=t.map((d,p)=>[s[p],l[p]]),h=t.map((d,p)=>[0,o[p]]);return[c,h]}function LK(n,t){const s=n.map((o,l)=>o+(o-1)*(t[l]-1)).map(o=>o-1),i=s.map(o=>Math.floor(o/2)),r=s.map((o,l)=>o-i[l]);return s.map((o,l)=>[i[l],r[l]])}const zK=et({pool_:MK});function PK(n,t){const e=U(n,"x","prelu"),s=U(t,"alpha","prelu"),i={x:e,alpha:s};return Z.runKernel(Kg,i)}const cS=et({prelu_:PK});function BK(n,t=null,e=!1){let s=U(n,"x","prod");s.dtype==="bool"&&(s=$t(s,"int32"));const i={x:s},r={axis:t,keepDims:e};return Z.runKernel(Xg,i,r)}const VK=et({prod_:BK});var cm={exports:{}},UK=cm.exports,qI;function jK(){return qI||(qI=1,(function(n){(function(t,e,s){function i(c){var h=this,d=l();h.next=function(){var p=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=p-(h.c=p|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(c),h.s0<0&&(h.s0+=1),h.s1-=d(c),h.s1<0&&(h.s1+=1),h.s2-=d(c),h.s2<0&&(h.s2+=1),d=null}function r(c,h){return h.c=c.c,h.s0=c.s0,h.s1=c.s1,h.s2=c.s2,h}function o(c,h){var d=new i(c),p=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&r(p,d),m.state=function(){return r(d,{})}),m}function l(){var c=4022871197,h=function(d){d=String(d);for(var p=0;p<d.length;p++){c+=d.charCodeAt(p);var m=.02519603282416938*c;c=m>>>0,m-=c,m*=c,c=m>>>0,m-=c,c+=m*4294967296}return(c>>>0)*23283064365386963e-26};return h}e&&e.exports?e.exports=o:this.alea=o})(UK,n)})(cm)),cm.exports}var um={exports:{}},GK=um.exports,KI;function WK(){return KI||(KI=1,(function(n){(function(t,e,s){function i(l){var c=this,h="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var p=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^p^p>>>8},l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,c.next()}function r(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c}function o(l,c){var h=new i(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&r(d,h),p.state=function(){return r(h,{})}),p}e&&e.exports?e.exports=o:this.xor128=o})(GK,n)})(um)),um.exports}var hm={exports:{}},HK=hm.exports,XI;function qK(){return XI||(XI=1,(function(n){(function(t,e,s){function i(l){var c=this,h="";c.next=function(){var p=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(p^p<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,l===(l|0)?c.x=l:h+=l;for(var d=0;d<h.length+64;d++)c.x^=h.charCodeAt(d)|0,d==h.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function r(l,c){return c.x=l.x,c.y=l.y,c.z=l.z,c.w=l.w,c.v=l.v,c.d=l.d,c}function o(l,c){var h=new i(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&r(d,h),p.state=function(){return r(h,{})}),p}e&&e.exports?e.exports=o:this.xorwow=o})(HK,n)})(hm)),hm.exports}var dm={exports:{}},KK=dm.exports,YI;function XK(){return YI||(YI=1,(function(n){(function(t,e,s){function i(l){var c=this;c.next=function(){var d=c.x,p=c.i,m,y;return m=d[p],m^=m>>>7,y=m^m<<24,m=d[p+1&7],y^=m^m>>>10,m=d[p+3&7],y^=m^m>>>3,m=d[p+4&7],y^=m^m<<7,m=d[p+7&7],m=m^m<<13,y^=m^m<<9,d[p]=y,c.i=p+1&7,y};function h(d,p){var m,y=[];if(p===(p|0))y[0]=p;else for(p=""+p,m=0;m<p.length;++m)y[m&7]=y[m&7]<<15^p.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(c,l)}function r(l,c){return c.x=l.x.slice(),c.i=l.i,c}function o(l,c){l==null&&(l=+new Date);var h=new i(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.x&&r(d,h),p.state=function(){return r(h,{})}),p}e&&e.exports?e.exports=o:this.xorshift7=o})(KK,n)})(dm)),dm.exports}var fm={exports:{}},YK=fm.exports,JI;function JK(){return JI||(JI=1,(function(n){(function(t,e,s){function i(l){var c=this;c.next=function(){var d=c.w,p=c.X,m=c.i,y,b;return c.w=d=d+1640531527|0,b=p[m+34&127],y=p[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=p[m]=b^y,c.i=m,b+(d^d>>>16)|0};function h(d,p){var m,y,b,x,w,S=[],T=128;for(p===(p|0)?(y=p,p=null):(p=p+"\0",y=0,T=Math.max(T,p.length)),b=0,x=-32;x<T;++x)p&&(y^=p.charCodeAt((x+32)%p.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=S[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(S[(p&&p.length||0)&127]=-1),b=127,x=512;x>0;--x)y=S[b+34&127],m=S[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,S[b]=y^m;d.w=w,d.X=S,d.i=b}h(c,l)}function r(l,c){return c.i=l.i,c.w=l.w,c.X=l.X.slice(),c}function o(l,c){l==null&&(l=+new Date);var h=new i(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(d.X&&r(d,h),p.state=function(){return r(h,{})}),p}e&&e.exports?e.exports=o:this.xor4096=o})(YK,n)})(fm)),fm.exports}var pm={exports:{}},ZK=pm.exports,ZI;function QK(){return ZI||(ZI=1,(function(n){(function(t,e,s){function i(l){var c=this,h="";c.next=function(){var p=c.b,m=c.c,y=c.d,b=c.a;return p=p<<25^p>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-p|0,c.b=p=p<<20^p>>>12^m,c.c=m=m-y|0,c.d=y<<16^m>>>16^b,c.a=b-p|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,l===Math.floor(l)?(c.a=l/4294967296|0,c.b=l|0):h+=l;for(var d=0;d<h.length+20;d++)c.b^=h.charCodeAt(d)|0,c.next()}function r(l,c){return c.a=l.a,c.b=l.b,c.c=l.c,c.d=l.d,c}function o(l,c){var h=new i(l),d=c&&c.state,p=function(){return(h.next()>>>0)/4294967296};return p.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},p.int32=h.next,p.quick=p,d&&(typeof d=="object"&&r(d,h),p.state=function(){return r(h,{})}),p}e&&e.exports?e.exports=o:this.tychei=o})(ZK,n)})(pm)),pm.exports}var mm={exports:{}};const tX={},eX=Object.freeze(Object.defineProperty({__proto__:null,default:tX},Symbol.toStringTag,{value:"Module"})),nX=bB(eX);var sX=mm.exports,QI;function iX(){return QI||(QI=1,(function(n){(function(t,e,s){var i=256,r=6,o=52,l="random",c=s.pow(i,r),h=s.pow(2,o),d=h*2,p=i-1,m;function y($,E,N){var _=[];E=E==!0?{entropy:!0}:E||{};var R=S(w(E.entropy?[$,k(e)]:$??T(),3),_),D=new b(_),M=function(){for(var A=D.g(r),B=c,H=0;A<h;)A=(A+H)*i,B*=i,H=D.g(1);for(;A>=d;)A/=2,B/=2,H>>>=1;return(A+H)/B};return M.int32=function(){return D.g(4)|0},M.quick=function(){return D.g(4)/4294967296},M.double=M,S(k(D.S),e),(E.pass||N||function(A,B,H,J){return J&&(J.S&&x(J,D),A.state=function(){return x(D,{})}),H?(s[l]=A,B):A})(M,R,"global"in E?E.global:this==s,E.state)}function b($){var E,N=$.length,_=this,R=0,D=_.i=_.j=0,M=_.S=[];for(N||($=[N++]);R<i;)M[R]=R++;for(R=0;R<i;R++)M[R]=M[D=p&D+$[R%N]+(E=M[R])],M[D]=E;(_.g=function(A){for(var B,H=0,J=_.i,X=_.j,z=_.S;A--;)B=z[J=p&J+1],H=H*i+z[p&(z[J]=z[X=p&X+B])+(z[X]=B)];return _.i=J,_.j=X,H})(i)}function x($,E){return E.i=$.i,E.j=$.j,E.S=$.S.slice(),E}function w($,E){var N=[],_=typeof $,R;if(E&&_=="object")for(R in $)try{N.push(w($[R],E-1))}catch{}return N.length?N:_=="string"?$:$+"\0"}function S($,E){for(var N=$+"",_,R=0;R<N.length;)E[p&R]=p&(_^=E[p&R]*19)+N.charCodeAt(R++);return k(E)}function T(){try{var $;return m&&($=m.randomBytes)?$=$(i):($=new Uint8Array(i),(t.crypto||t.msCrypto).getRandomValues($)),k($)}catch{var E=t.navigator,N=E&&E.plugins;return[+new Date,t,N,t.screen,k(e)]}}function k($){return String.fromCharCode.apply(0,$)}if(S(s.random(),e),n.exports){n.exports=y;try{m=nX}catch{}}else s["seed"+l]=y})(typeof self<"u"?self:sX,[],Math)})(mm)),mm.exports}var Rx,tN;function rX(){if(tN)return Rx;tN=1;var n=jK(),t=WK(),e=qK(),s=XK(),i=JK(),r=QK(),o=iX();return o.alea=n,o.xor128=t,o.xorwow=e,o.xorshift7=s,o.xor4096=i,o.tychei=r,Rx=o,Rx}var uS=rX();class OD{constructor(t,e,s,i,r){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=r||Math.random();this.random=uS.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let t,e,s=!1;for(;!s;){let i,r,o;do i=2*this.random()-1,r=2*this.random()-1,o=i*i+r*r;while(o>=1||o===0);const l=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*i*l,e=this.mean+this.stdDev*r*l,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class oX{constructor(t=0,e=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=uS.alea(i)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function aX(n,t=0,e=1,s,i){if(Kr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new OD(t,e,s,!1,i),o=Jt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=r.nextValue();return o.toTensor()}const lX=et({randomNormal_:aX});function cX(n,t=0,e=1,s="float32",i){Kr(n);const r=Jt(n,s),o=new oX(t,e,null,i);for(let l=0;l<r.values.length;l++)r.values[l]=o.nextValue();return r.toTensor()}const tf=et({randomUniform_:cX});function Ph(n,t,e=1,s="float32"){if(e===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:t,step:e,dtype:s};return Z.runKernel(O1,{},i)}function uX(n){const e={input:U(n,"input","real")};return Z.runKernel(M1,e)}const Mm=et({real_:uX});function hX(n){const e={x:U(n,"x","reciprocal")};return Z.runKernel(Rd,e)}const dX=et({reciprocal_:hX});function fX(n){const e={x:U(n,"x","relu")};return Z.runKernel(Dd,e)}const ll=et({relu_:fX});function pX(n){const e={x:U(n,"x","relu6")};return Z.runKernel(Od,e)}const MD=et({relu6_:pX});function mX(n,t){const s={x:U(n,"x","reverse")},i={dims:t};return Z.runKernel(Qg,s,i)}const tl=et({reverse_:mX});function gX(n){const e={x:U(n,"x","round")};return Z.runKernel(Md,e)}const FD=et({round_:gX});function yX(n){const e={x:U(n,"x","rsqrt","float32")};return Z.runKernel(Fd,e)}const LD=et({rsqrt_:yX});function bX(n){const e={x:U(n,"x","selu")};return Z.runKernel(Ld,e)}const zD=et({selu_:bX});function xX(n,t,e,s,i,r=[1,1],o="NHWC"){const l=U(n,"x","separableConv2d"),c=U(t,"depthwiseFilter","separableConv2d"),h=U(e,"pointwiseFilter","separableConv2d");let d=l,p=!1;if(l.rank===3&&(p=!0,d=tt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");F(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),F(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),F(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),F(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),F(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=c.shape[2],y=c.shape[3];F(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=Q1(d,c,s,i,o,r),w=Za(b,h,1,"valid",o);return p?tt(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const PD=et({separableConv2d_:xX});function vX(n){const e={x:U(n,"x","sign")};return Z.runKernel(Bd,e)}const wX=et({sign_:vX});function SX(n){const e={x:U(n,"x","sin","float32")};return Z.runKernel(zd,e)}const BD=et({sin_:SX});function CX(n){const e={x:U(n,"x","sinh")};return Z.runKernel(Pd,e)}const VD=et({sinh_:CX});function TX(n,t,e){const s=U(n,"x","slice1d");return F(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Re(s,[t],[e])}const hS=et({slice1d_:TX});function kX(n,t,e){const s=U(n,"x","slice2d");return F(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Re(s,t,e)}const UD=et({slice2d_:kX});function $X(n,t,e){const s=U(n,"x","slice3d");return F(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Re(s,t,e)}const dS=et({slice3d_:$X});function EX(n,t,e){const s=U(n,"x","slice4d");return F(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Re(s,t,e)}const Fm=et({slice4d_:EX});function IX(n,t=-1){const e=U(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const s={logits:e},i={dim:t};return Z.runKernel(ry,s,i)}const fS=et({softmax_:IX});function NX(n){F(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return Z.runKernel(C1,t)}const jD=et({fft_:NX});function AX(n){F(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return Z.runKernel($1,t)}const qv=et({ifft_:AX});function _X(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const i=tt(n,[e,t]);s=qv(i)}else{const i=[e,2*(t-1)],r=tt(Mm(n),[e,t]),o=tt(nS(n),[e,t]),l=tl(Re(r,[0,1],[e,t-2]),1),c=Y(tl(Re(o,[0,1],[e,t-2]),1),pe(-1)),h=fs([r,l],1),d=fs([o,c],1),p=tt(qa(h,d),[i[0],i[1]]);s=qv(p)}if(s=Mm(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=tt(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const RX=et({irfft_:_X});function DX(n,t,e=0){const i={x:U(n,"x","split")},r={numOrSizeSplits:t,axis:e};return Z.runKernel(iy,i,r)}const qs=et({split_:DX});function OX(n,t){F(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let i;if(t!=null&&t<e){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=t,i=Re(n,b,x),e=t}else if(t!=null&&t>e){const b=n.shape.map(x=>x);b[n.shape.length-1]=t-e,i=fs([n,In(b)],n.shape.length-1),e=t}else i=n;const r=ae(i),o=tt(qa(i,r),[s,e]),l=jD(o),c=Math.floor(e/2)+1,h=Mm(l),d=nS(l),p=qs(h,[c,e-c],h.shape.length-1),m=qs(d,[c,e-c],d.shape.length-1),y=i.shape.slice();return y[i.shape.length-1]=c,tt(qa(p[0],m[0]),y)}const MX=et({rfft_:OX});function FX(n,t){let e=U(n,"a","squaredDifference"),s=U(t,"b","squaredDifference");[e,s]=en(e,s),Ht(e.shape,s.shape);const i={a:e,b:s},r={};return Z.runKernel(Gd,i,r)}const LX=et({squaredDifference_:FX});function zX(n,t){const e=U(n,"x","squeeze","string_or_numeric");return tt(e,jo(e.shape,t).newShape)}const ef=et({squeeze_:zX});function PX(n,t=0){const e=uD(n,"tensors","stack","string_or_numeric");F(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&F(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const s=e,i={axis:t};return Z.runKernel(Hg,s,i)}const Gr=et({stack_:PX});function BX(n,t=0){const s={x:U(n,"x","step")},i={alpha:t};return Z.runKernel(Xd,s,i)}const nf=et({step_:BX});function VX(n,t,e,s,i=0,r=0,o=0,l=0,c=0){const d={x:U(n,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:s,beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};return Z.runKernel(B1,d,p)}const UX=et({stridedSlice_:VX});function jX(n){const e={x:U(n,"x","tan","float32")};return Z.runKernel(Hd,e)}const GX=et({tan_:jX});function Is(n,t){t1(n);const e=Yd(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Jd(n,null,e,t)}function Dx(n,t,e){if(t1(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Yd(n,e);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Jd(n,t,s,e)}function WX(n,t,e){if(t1(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Yd(n,e);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Jd(n,t,s,e)}function GD(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(e.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(e.rank-i))throw new Error(r+` Output shape length < ${s+(e.rank-i)}`);if(e.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let o=0;o<i;++o)if(e.shape[o]!==t.shape[o])throw new Error(r+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-i;++o)if(e.shape[o+i]!==n[o+s])throw new Error(r+` updates.shape[${o+i}] (${e.shape[o+i]}) != shape[${o+i}] (${n[o+i]})`)}function HX(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}GD(e,t,n)}function cl(n,t,e){const s=t.shape.length,i=s>1?t.shape[s-1]:1,r=e.length;let o=1;for(let p=i;p<r;++p)o*=e[p];const l=i<1?1:i,c=ft(t.shape)/l,h=[...Ot(e.slice(0,i)),1],d=ft(e);return{sliceRank:i,numUpdates:c,sliceSize:o,strides:h,outputSize:d}}function qX(n,t=1,e=!0){const s=U(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);const r={x:s},o={k:t,sorted:e},[l,c]=Z.runKernel(V1,r,o);return{values:l,indices:c}}const KX=et({topk_:qX});function XX(n,t=0,e=1,s,i){if(Kr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new OD(t,e,s,!0,i),o=Jt(n,s);for(let l=0;l<o.values.length;l++)o.values[l]=r.nextValue();return o.toTensor()}const WD=et({truncatedNormal_:XX});function YX(n,t=0){const e=U(n,"x","unique","string_or_numeric");F(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},i={axis:t},[r,o]=Z.runKernel(j1,s,i);return{values:r,indices:o}}const JX=et({unique_:YX});function ZX(n,t,e){const s=U(n,"x","unsortedSegmentSum"),i=U(t,"segmentIds","unsortedSegmentSum","int32");F(Rc(e),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},o={numSegments:e};return Z.runKernel(ay,r,o)}const HD=et({unsortedSegmentSum_:ZX});function QX(n,t=0){const e=U(n,"x","unstack","string_or_numeric");F(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const s={value:e},i={axis:t};return Z.runKernel(oy,s,i)}const el=et({unstack_:QX});function t9(n,t=!0,e,s){return Z.makeVariable(n,t,e,s)}function qD(n,t){const e=[];for(let r=0;r<t.length;r++)t[r]&&e.push(r);const s=Jt(n,"int32"),i=Jt([e.length,n.length],"int32");for(let r=0;r<e.length;r++){const o=s.indexToLoc(e[r]),l=r*n.length;i.values.set(o,l)}return i.toTensor()}function e9(n,t,e){const s=U(n,"x","transpose");if(t==null&&(t=s.shape.map((o,l)=>l).reverse()),F(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{F(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:t};return s.dtype==="complex64"?it(()=>{let o=Mm(s),l=nS(s);return o=Z.runKernel($c,{x:o},r),l=Z.runKernel($c,{x:l},r),e&&(l=tn(l)),qa(o,l)}):Z.runKernel($c,i,r)}const oe=et({transpose_:e9});function n9(n,t){if(t==null)return n.shape.slice();if(me(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)t[s]==null&&n.shape[s]!=null?e.push(n.shape[s]):e.push(t[s]);return e}return t}function s9(n,t,e,s){const i=U(n,"x","dropout");if(F(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),F(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof gn?i.clone():i;const r=n9(i,e),o=1-t,l=Lt(my(wt(tf(r,0,1,"float32",s),o)),o);return Y(i,l)}const i9=et({dropout_:s9});function r9(n,t,e,s,i,r="NHWC",o){let l=n;n.rank===3&&(l=tt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),F(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),F(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),F(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const h=r==="NHWC"?l.shape[3]:l.shape[1],d=r==="NHWC"?c.shape[3]:c.shape[1];F(h===e[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${e[2]}.`),F(d===e[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${e[3]}).`),gs("conv2dDerFilter",i,o);const p={x:l,dy:c},m={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,filterShape:e};return Z.runKernel(d1,p,m)}const pS=et({conv2DBackpropFilter_:r9});function mS(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return Y(n,nf(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function gS(n,t){let e=t;const s=wn(n.shape,t.shape);return s.length>0&&(e=Mt(e,s)),tt(e,n.shape)}function yS(n,t,e,s){if(t==="linear")return n;if(t==="relu")return ll(n);if(t==="elu")return fy(n);if(t==="relu6")return MD(n);if(t==="prelu")return cS(n,e);if(t==="leakyrelu")return sS(n,s);if(t==="sigmoid")return Xc(n);throw new Error(`Unknown fused activation ${t}.`)}const bS=(n,t)=>!(n>0)||t==="linear";function o9({x:n,filter:t,strides:e,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:o,bias:l,activation:c="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(c=c||"linear",bS(Z.state.gradientDepth,c)===!1){F(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=Za(n,t,e,s,i,r,o);return l!=null&&(N=wt(N,l)),yS(N,c,h,d)}const p=U(n,"x","conv2d","float32"),m=U(t,"filter","conv2d","float32");let y=p,b=!1;p.rank===3&&(b=!0,y=tt(p,[1,p.shape[0],p.shape[1],p.shape[2]])),F(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),F(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),gs("fused conv2d",s,o);const x=i==="NHWC"?y.shape[3]:y.shape[1];F(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),F(Xn(e,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${r}'`);const w=Mn(y.shape,m.shape,e,r,s,o);let S;l!=null&&(S=U(l,"bias","fused conv2d"),[S]=en(S,p),i==="NHWC"?Ht(w.outShape,S.shape):(F(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),F(S.shape.length===0||S.shape[0]===w.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let T;if(h!=null){const N=h.shape;if(F(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)F(N[0]===1||N[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${w.outChannels}).`);else if(N.length===3)try{Ht(N,w.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(R)}T=U(h,"prelu weights","fused conv2d")}const k=(N,_)=>{F(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[R,D,M,A]=_,B=mS(N,M,c);F(Ya(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const H=J1(D.shape,B,R,e,s),J=pS(D,B,R.shape,e,s),X=[H,J];if(A!=null){const z=gS(A,B);X.push(z)}return X},$={x:y,filter:m,bias:S,preluActivationWeights:T},E={strides:e,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o,activation:c,leakyreluAlpha:d};return l==null?Fc((_,R,D)=>{let M=Z.runKernel(Im,$,E);return D([R,_,M]),b&&(M=tt(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:k}})(y,m):Fc((_,R,D,M)=>{let A=Z.runKernel(Im,$,E);return M([R,_,A,D]),b&&(A=tt(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:k}})(y,m,S)}const a9=et({fusedConv2d_:o9});function l9(n,t,e,s,i,r=[1,1],o){let l=n;n.rank===3&&(l=tt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=t;c.rank===3&&(c=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:l,dy:c},d={strides:s,pad:i,dimRoundingMode:o,dilations:r,filterShape:e};return Z.runKernel(x1,h,d)}const c9=et({depthwiseConv2dNativeBackpropFilter_:l9});function u9(n,t,e,s,i,r=[1,1],o){let l=t,c=!1;t.rank===3&&(c=!0,l=tt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:l,filter:e},d={strides:s,pad:i,dimRoundingMode:o,dilations:r,inputShape:n},p=Z.runKernel(v1,h,d);return c?tt(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const h9=et({depthwiseConv2dNativeBackpropInput_:u9});function d9({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}){if(bS(Z.state.gradientDepth,r)===!1){let A=fe(n,t,e,s);return i!=null&&(A=wt(A,i)),yS(A,r,o,l)}let c=U(n,"a","fused matMul"),h=U(t,"b","fused matMul");[c,h]=en(c,h);const d=e?c.shape[c.rank-2]:c.shape[c.rank-1],p=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=e?c.shape[c.rank-1]:c.shape[c.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=c.shape.slice(0,-2),x=h.shape.slice(0,-2),w=ft(b),S=ft(x);F(d===p,()=>`Error in fused matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${c.shape} and ${h.shape} and transposeA=${e} and transposeB=${s} must match.`);const k=Ht(c.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),$=e?tt(c,[w,d,m]):tt(c,[w,m,d]),E=s?tt(h,[S,y,p]):tt(h,[S,p,y]);let N;i!=null&&(N=U(i,"bias","fused matMul"),[N]=en(N,c),Ht(k,N.shape));let _;o!=null&&(_=U(o,"prelu weights","fused matMul"));const R=(A,B)=>{const[H,J,X,z]=B,P=mS(tt(A,X.shape),X,r);let V,K;if(!e&&!s?(V=fe(P,J,!1,!0),K=fe(H,P,!0,!1)):!e&&s?(V=fe(P,J,!1,!1),K=fe(P,H,!0,!1)):e&&!s?(V=fe(J,P,!1,!0),K=fe(H,P,!1,!1)):(V=fe(J,P,!0,!0),K=fe(P,H,!0,!0)),i!=null){const st=gS(z,P);return[V,K,st]}else return[V,K]},D={a:$,b:E,bias:N,preluActivationWeights:_},M={transposeA:e,transposeB:s,activation:r,leakyreluAlpha:l};return i==null?Fc((B,H,J)=>{const X=Z.runKernel(Em,D,M);return J([B,H,X]),{value:tt(X,k),gradFunc:R}})($,E):Fc((B,H,J,X)=>{const z=Z.runKernel(Em,D,M);return X([B,H,z,J]),{value:tt(z,k),gradFunc:R}})($,E,N)}const eN=et({fusedMatMul_:d9});function f9(n,t,e,s,i="bilinear",r=0){const o=U(n,"image","cropAndResize"),l=U(t,"boxes","cropAndResize","float32"),c=U(e,"boxInd","cropAndResize","int32"),h=l.shape[0];F(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),F(l.rank===2&&l.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${l.shape}.`),F(c.rank===1&&c.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${l.shape}.`),F(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),F(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),F(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const d={image:o,boxes:l,boxInd:c},p={method:i,extrapolationValue:r,cropSize:s};return Z.runKernel(g1,d,p)}const p9=et({cropAndResize_:f9});function m9(n){const t=U(n,"image","flipLeftRight","float32");F(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return Z.runKernel(k1,e,{})}const g9=et({flipLeftRight_:m9});function y9(n){const t=U(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];F(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),F(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(t.rank);return i.fill(1,0,e),i[e]=3,Li(t,i)}const b9=et({grayscaleToRGB_:y9});function x9(n){const t=U(n,"image","RGBToGrayscale"),e=t.rank-1,s=t.shape[e];F(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),F(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=t.dtype,r=$t(t,"float32"),o=Is([.2989,.587,.114]);let l;switch(t.rank){case 2:l=ih("ij,j->i",r,o);break;case 3:l=ih("ijk,k->ij",r,o);break;case 4:l=ih("ijkl,l->ijk",r,o);break;case 5:l=ih("ijklm,m->ijkl",r,o);break;case 6:l=ih("ijklmn,n->ijklm",r,o);break;default:throw new Error("Not a valid tensor rank.")}return l=us(l,-1),$t(l,i)}const v9=et({rgbToGrayscale_:x9});function w9(n,t,e=0,s=.5){const i=U(n,"image","rotateWithOffset","float32");F(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},o={radians:t,fillValue:e,center:s};return Z.runKernel(G1,r,o)}const S9=et({rotateWithOffset_:w9});function Jc(n,t,e,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const o=n.shape[0];return e=Math.min(e,o),F(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),F(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),F(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),F(t.rank===1,()=>"scores must be a 1D tensor"),F(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),F(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}function C9(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY){const r=U(n,"boxes","nonMaxSuppression","float32"),o=U(t,"scores","nonMaxSuppression","float32"),l=Jc(r,o,e,s,i);e=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold;const c={maxOutputSize:e,iouThreshold:s,scoreThreshold:i};return Z.runKernel(_1,{boxes:r,scores:o},c)}const T9=et({nonMaxSuppression_:C9});function k9(n,t,e){const s=$9(n,t,e),i=s<0?-(s+1):s;n.splice(i,0,t)}function $9(n,t,e){return I9(n,t,e||E9)}function E9(n,t){return n>t?1:n<t?-1:0}function I9(n,t,e){let s=0,i=n.length,r=0,o=!1;for(;s<i;){r=s+(i-s>>>1);const l=e(t,n[r]);l>0?s=r+1:(i=r,o=!l)}return o?s:-s-1}function xS(n,t,e,s,i){return SS(n,t,e,s,i,0)}function vS(n,t,e,s,i,r){return SS(n,t,e,s,i,0,!1,r,!0)}function wS(n,t,e,s,i,r){return SS(n,t,e,s,i,r,!0)}function SS(n,t,e,s,i,r,o=!1,l=!1,c=!1){const h=[];for(let w=0;w<t.length;w++)t[w]>i&&h.push({score:t[w],boxIndex:w,suppressBeginIndex:0});h.sort(nN);const d=r>0?-.5/r:0,p=[],m=[];for(;p.length<e&&h.length>0;){const w=h.pop(),{score:S,boxIndex:T,suppressBeginIndex:k}=w;if(S<i)break;let $=!1;for(let E=p.length-1;E>=k;--E){const N=N9(n,T,p[E]);if(N>=s){$=!0;break}if(w.score=w.score*A9(s,d,N),w.score<=i)break}w.suppressBeginIndex=p.length,$||(w.score===S?(p.push(T),m.push(w.score)):w.score>i&&k9(h,w,nN))}const y=p.length,b=e-y;l&&b>0&&(p.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:p};return o&&(x.selectedScores=m),c&&(x.validOutputs=y),x}function N9(n,t,e){const s=n.subarray(t*4,t*4+4),i=n.subarray(e*4,e*4+4),r=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),l=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),h=Math.min(i[0],i[2]),d=Math.min(i[1],i[3]),p=Math.max(i[0],i[2]),m=Math.max(i[1],i[3]),y=(l-r)*(c-o),b=(p-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(r,h),w=Math.max(o,d),S=Math.min(l,p),T=Math.min(c,m),k=Math.max(S-x,0)*Math.max(T-w,0);return k/(y+b-k)}function A9(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function nN(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function _9(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY){const r=U(n,"boxes","nonMaxSuppressionAsync"),o=U(t,"scores","nonMaxSuppressionAsync"),l=Jc(r,o,e,s,i);e=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold;const c=await Promise.all([r.data(),o.data()]),h=c[0],d=c[1],{selectedIndices:p}=xS(h,d,e,s,i);return r!==n&&r.dispose(),o!==t&&o.dispose(),Is(p,"int32")}const R9=_9;function D9(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=U(n,"boxes","nonMaxSuppression"),l=U(t,"scores","nonMaxSuppression"),c=Jc(o,l,e,s,i,r);e=c.maxOutputSize,s=c.iouThreshold,i=c.scoreThreshold,r=c.softNmsSigma;const h={boxes:o,scores:l},d={maxOutputSize:e,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},p=Z.runKernel(D1,h,d);return{selectedIndices:p[0],selectedScores:p[1]}}const O9=et({nonMaxSuppressionWithScore_:D9});async function M9(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=U(n,"boxes","nonMaxSuppressionAsync"),l=U(t,"scores","nonMaxSuppressionAsync"),c=Jc(o,l,e,s,i,r);e=c.maxOutputSize,s=c.iouThreshold,i=c.scoreThreshold,r=c.softNmsSigma;const h=await Promise.all([o.data(),l.data()]),d=h[0],p=h[1],{selectedIndices:m,selectedScores:y}=wS(d,p,e,s,i,r);return o!==n&&o.dispose(),l!==t&&l.dispose(),{selectedIndices:Is(m,"int32"),selectedScores:Is(y)}}const F9=M9;function L9(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=U(n,"boxes","nonMaxSuppression"),l=U(t,"scores","nonMaxSuppression"),c=Jc(o,l,e,s,i,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,m={boxes:o,scores:l},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:r},b=Z.runKernel(R1,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const z9=et({nonMaxSuppressionPadded_:L9});async function P9(n,t,e,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=U(n,"boxes","nonMaxSuppressionAsync"),l=U(t,"scores","nonMaxSuppressionAsync"),c=Jc(o,l,e,s,i,null),h=c.maxOutputSize,d=c.iouThreshold,p=c.scoreThreshold,[m,y]=await Promise.all([o.data(),l.data()]),{selectedIndices:b,validOutputs:x}=vS(m,y,h,d,p,r);return o!==n&&o.dispose(),l!==t&&l.dispose(),{selectedIndices:Is(b,"int32"),validOutputs:pe(x,"int32")}}const B9=P9;function V9(n,t,e=!1,s=!1){const i=U(n,"images","resizeBilinear");F(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),F(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),F(s===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=tt(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={images:r},c={alignCorners:e,halfPixelCenters:s,size:t},h=Z.runKernel(Zg,l,c);return o?tt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const KD=et({resizeBilinear_:V9});function U9(n,t,e=!1,s=!1){const i=U(n,"images","resizeNearestNeighbor");F(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),F(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),F(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),F(s===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=tt(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={images:r},c={alignCorners:e,halfPixelCenters:s,size:t},h=Z.runKernel(Jg,l,c);return o?tt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const XD=et({resizeNearestNeighbor_:U9});function j9(n,t="binary",e=!1,s=.5){const i=U(n,"image","threshold"),r=.2989,o=.587,l=.114,c=i.shape[0]*i.shape[1];let h=Y(Is([s]),255),d,p,m,y;if(F(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),F(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),F(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),F(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),i.shape[2]===3){[d,p,m]=qs(i,[1,1,1],-1);const w=Y(d,r),S=Y(p,o),T=Y(m,l);y=wt(wt(w,S),T)}else y=n;if(t==="otsu"){const w=Pq($t(FD(y),"int32"),wh([]),256);h=G9(w,c)}const b=e?Yc(y,h):Xs(y,h);return $t(Y(b,255),"int32")}function G9(n,t){let e=Is([-1]),s=Is([0]),i=Is([0]),r,o,l,c,h,d;for(let p=0;p<n.size-1;p++){r=Re(n,0,p+1),o=Re(n,p+1),h=Lt(Mt(r),t),d=Lt(Mt(o),t);const m=Mt(Y(r,Ph(0,r.size)));l=Lt(m,Mt(r));const y=dy(o.shape,r.size),b=wt(Ph(0,o.size),y),x=Y(o,b);c=Lt(Mt(x),Mt(o));const w=Bt(l,c),S=Bt(l,c),T=Y(h,d);i=Y(Y(T,w),S);const k=Xs(i,s);s=ss(k,i,s),e=ss(k,Is([p]),e)}return e}const W9=et({threshold_:j9});function H9(n,t,e="nearest",s="constant",i=0,r){const o=U(n,"image","transform","float32"),l=U(t,"transforms","transform","float32");F(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),F(l.rank===2&&(l.shape[0]===o.shape[0]||l.shape[0]===1)&&l.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),F(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const c={image:o,transforms:l},h={interpolation:e,fillMode:s,fillValue:i,outputShape:r};return Z.runKernel(U1,c,h)}const q9=et({transform_:H9});function K9(n,t,e){const s=U(n,"a","bandPart");F(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,o]=s.shape.slice(-2);let l,c;typeof t=="number"?(F(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),F(t<=r,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${r}).`),l=U(t<0?r:t,"numLower","bandPart")):(F(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),l=ss(Dm(t,0),r,zh(t,r))),typeof e=="number"?(F(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),F(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),c=U(e<0?o:e,"numUpper","bandPart")):(F(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=ss(Dm(e,0),o,zh(e,o)));const h=tt(Ph(0,r,1,"int32"),[-1,1]),d=Ph(0,o,1,"int32"),p=Bt(h,d),m=jr(Yc(p,l),al(p,tn(c))),y=In([r,o],s.dtype);return tt(Gr(el(tt(s,[-1,r,o])).map(b=>ss(m,b,y))),i)}const X9=et({bandPart_:K9});function Y9(n){let t;if(Array.isArray(n)){t=!1,F(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)F(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else t=!0,n=qs(n,n.shape[0],0).map(i=>ef(i,[0]));F(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let i=0;i<n.length;++i)e.push(Z.tidy(()=>{let r=s[i];if(i>0)for(let o=0;o<i;++o){const l=Y(Mt(Y(e[o],r)),e[o]);r=Bt(r,l)}return Lt(r,py(r,"euclidean"))}));return t?Gr(e,0):e}const J9=et({gramSchmidt_:Y9});function Z9(n,t=!1){if(F(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return sN(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((c,h)=>c*h),s=el(tt(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(c=>{const[h,d]=sN(c,t);i.push(h),r.push(d)});const o=tt(Gr(i,0),n.shape),l=tt(Gr(r,0),n.shape);return[o,l]}}function sN(n,t=!1){return Z.tidy(()=>{F(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let i=ID(e),r=Va(n);const o=Dx([[1]],[1,1]);let l=Va(o);const c=e>=s?s:e;for(let h=0;h<c;++h){const d=r,p=l,m=i;[l,r,i]=Z.tidy(()=>{const y=Re(r,[h,h],[e-h,1]),b=py(y),x=Re(r,[h,h],[1,1]),w=ss(Xs(x,0),Dx([[-1]]),Dx([[1]])),S=Bt(x,Y(w,b)),T=Lt(y,S);T.shape[0]===1?l=Va(o):l=fs([o,Re(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);const k=tn(Lt(fe(w,S),b)),$=Re(r,[h,0],[e-h,s]),E=Y(k,l),N=oe(l);if(h===0)r=Bt($,fe(E,fe(N,$)));else{const D=Bt($,fe(E,fe(N,$)));r=fs([Re(r,[0,0],[h,s]),D],0)}const _=oe(E),R=Re(i,[0,h],[e,i.shape[1]-h]);if(h===0)i=Bt(R,fe(fe(R,l),_));else{const D=Bt(R,fe(fe(R,l),_));i=fs([Re(i,[0,0],[e,h]),D],1)}return[l,r,i]}),Yt([d,p,m])}return!t&&e>s&&(i=Re(i,[0,0],[e,s]),r=Re(r,[0,0],[s,s])),[i,r]})}const Q9=et({qr_:Z9});const Br={flipLeftRight:g9,grayscaleToRGB:b9,resizeNearestNeighbor:XD,resizeBilinear:KD,rgbToGrayscale:v9,rotateWithOffset:S9,cropAndResize:p9,nonMaxSuppression:T9,nonMaxSuppressionAsync:R9,nonMaxSuppressionWithScore:O9,nonMaxSuppressionWithScoreAsync:F9,nonMaxSuppressionPadded:z9,nonMaxSuppressionPaddedAsync:B9,threshold:W9,transform:q9},t7={bandPart:X9,gramSchmidt:J9,qr:Q9};const e7=new Map,n7=new Map;class Zc{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class di{constructor(){this.classNameMap={}}static getMap(){return di.instance==null&&(di.instance=new di),di.instance}static register(t){di.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function xt(n,t,e){F(n.className!=null,()=>"Class being registered does not have the static className property defined."),F(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),F(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const s=e,i=t+">"+s;return di.register(n),e7.set(i,n),n7.set(n,i),n}class Yo extends Zc{minimize(t,e=!1,s){const{value:i,grads:r}=this.computeGradients(t,s);if(s!=null){const o=s.map(l=>({name:l.name,tensor:r[l.name]}));this.applyGradients(o)}else this.applyGradients(r);return Yt(r),e?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return oK(t,e)}dispose(){this.iterations_!=null&&Yt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:pe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Yo,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class YD extends Yo{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Z.registeredVariables[s],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:it(()=>ae(r).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:it(()=>ae(r).variable(o))});const l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;const c=this.accumulatedGrads[i].variable,h=this.accumulatedUpdates[i].variable;it(()=>{const d=wt(Y(c,this.rho),Y(Fe(l),1-this.rho)),p=Y(Lt(Kn(wt(h,this.epsilon)),Kn(wt(c,this.epsilon))),l),m=wt(Y(h,this.rho),Y(Fe(p),1-this.rho));c.assign(d),h.assign(m);const y=wt(Y(p,-this.learningRate),r);r.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Yt(this.accumulatedGrads.map(t=>t.variable)),Yt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}class JD extends Yo{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Z.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:it(()=>dy(r.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[i].tensor:t[s];if(o==null)return;const l=this.accumulatedGrads[i].variable;it(()=>{const c=wt(l,Fe(o));l.assign(c);const h=wt(Y(Lt(o,Kn(wt(c,Z.backend.epsilon()))),-this.learningRate),r);r.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Yt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}class ZD extends Yo{static get className(){return"Adam"}constructor(t,e,s,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],it(()=>{this.accBeta1=pe(e).variable(),this.accBeta2=pe(s).variable()}),i==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);it(()=>{const s=Bt(1,this.accBeta1),i=Bt(1,this.accBeta2);e.forEach((r,o)=>{const l=Z.registeredVariables[r],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:it(()=>ae(l).variable(c))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${r}/v`,variable:it(()=>ae(l).variable(c))});const h=Array.isArray(t)?t[o].tensor:t[r];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedSecondMoment[o].variable,m=wt(Y(d,this.beta1),Y(h,1-this.beta1)),y=wt(Y(p,this.beta2),Y(Fe(h),1-this.beta2)),b=Lt(m,s),x=Lt(y,i);d.assign(m),p.assign(y);const w=wt(Y(Lt(b,wt(Kn(x),this.epsilon)),-this.learningRate),l);l.assign(w)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Yt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Yt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),it(()=>{this.accBeta1.assign(Qa(this.beta1,this.iterations_+1)),this.accBeta2.assign(Qa(this.beta2,this.iterations_+1))});const e=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}class QD extends Yo{static get className(){return"Adamax"}constructor(t,e,s,i=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],it(()=>{this.iteration=pe(0).variable(),this.accBeta1=pe(e).variable()}),i==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);it(()=>{const s=Bt(1,this.accBeta1),i=Lt(-this.learningRate,wt(Y(this.iteration,this.decay),1));e.forEach((r,o)=>{const l=Z.registeredVariables[r],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:ae(l).variable(c)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${r}/v`,variable:ae(l).variable(c)});const h=Array.isArray(t)?t[o].tensor:t[r];if(h==null)return;const d=this.accumulatedFirstMoment[o].variable,p=this.accumulatedWeightedInfNorm[o].variable,m=wt(Y(d,this.beta1),Y(h,1-this.beta1)),y=Y(p,this.beta2),b=Qn(h),x=Ko(y,b);d.assign(m),p.assign(x);const w=wt(Y(Lt(i,s),Lt(m,wt(x,this.epsilon))),l);l.assign(w)}),this.iteration.assign(wt(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Yt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Yt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class CS extends Yo{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Array.isArray(t)?t[i].tensor:t[s];if(r==null)return;const o=Z.registeredVariables[s];it(()=>{const l=wt(Y(this.c,r),o);o.assign(l)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=or(pe(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class tO extends CS{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=pe(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Z.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:it(()=>ae(r).variable(!1))});const o=this.accumulations[i].variable,l=Array.isArray(t)?t[i].tensor:t[s];l!=null&&it(()=>{let c;const h=wt(Y(this.m,o),l);this.useNesterov?c=wt(Y(this.c,wt(l,Y(h,this.m))),r):c=wt(Y(this.c,h),r),o.assign(h),r.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Yt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class eO extends Yo{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,i=null,r=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=Z.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,i)=>{const r=Z.registeredVariables[s],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:it(()=>ae(r).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:it(()=>ae(r).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:it(()=>ae(r).variable(o))});const l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;const c=this.accumulatedMeanSquares[i].variable,h=this.accumulatedMoments[i].variable;it(()=>{const d=wt(Y(c,this.decay),Y(Fe(l),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[i].variable,m=wt(Y(p,this.decay),Y(l,1-this.decay)),y=Lt(Y(l,this.learningRate),Kn(Bt(d,wt(Fe(m),this.epsilon)))),b=wt(Y(h,this.momentum),y);c.assign(d),p.assign(m),h.assign(b);const x=Bt(r,b);r.assign(x)}else{const p=wt(Y(c,this.decay),Y(Fe(l),1-this.decay)),m=wt(Y(h,this.momentum),Lt(Y(l,this.learningRate),Kn(wt(p,this.epsilon))));c.assign(p),h.assign(m);const y=Bt(r,m);r.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Yt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Yt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Yt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,e).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=t.slice(e,e*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const s7=[YD,JD,ZD,QD,tO,eO,CS];function i7(){for(const n of s7)xt(n)}function iN(n,t,e,s){o(n),e=e??0,s=s??1,l(e,s);let i=0;const r=c=>(c.then(h=>{const d=e+ ++i/n.length*(s-e);return t(d),h}),c);function o(c){F(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function l(c,h){F(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),F(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),F(h>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${h}`)}return Promise.all(n.map(r))}async function r7(n,t){t==null&&(t={});const e=t.fetchFunc==null?at().platform.fetch:t.fetchFunc,s=n.map(p=>e(p,t.requestInit,{isBinary:!0})),l=(t.onProgress==null?await Promise.all(s):await iN(s,t.onProgress,0,.5)).map(p=>p.arrayBuffer());return t.onProgress==null?await Promise.all(l):await iN(l,t.onProgress,.5,1)}function o7(n,t){var e;const s=t.fetchFunc==null?at().platform.fetch:t.fetchFunc;let i=0,r;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async o=>{for(var l;i<n.length;){r||(r=(await s(n[i],t.requestInit,{isBinary:!0})).body.getReader());const{done:c,value:h}=await r.read();if(c){i++,r=void 0,(l=t.onProgress)===null||l===void 0||l.call(t,i/n.length);continue}o.enqueue(h);return}o.close()}})}const a7="application/octet-stream",l7="application/json";class TS{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(F(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=at().platform.fetch,F(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&F(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],i=x5(t,s);if(e.body.append("model.json",new Blob([JSON.stringify(i)],{type:l7}),"model.json"),t.weightData!=null){const o=Wo.join(t.weightData);e.body.append("model.weights.bin",new Blob([o],{type:a7}),"model.weights.bin")}const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:q1(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=e.modelTopology,i=e.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return w5(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),s=GI(t.weightsManifest),i=()=>o7(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:i})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=c7(e),r=this.weightPathPrefix||s,o=[],l=[];for(const c of t)for(const h of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):o.push(r+h+i);return this.weightUrlConverter&&o.push(...await Promise.all(l)),o}async loadWeights(t){const e=await this.getWeightUrls(t),s=GI(t),i=await r7(e,this.loadOptions);return[s,i]}}TS.URL_SCHEME_REGEX=/^https?:\/\//;function c7(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),s=n.substring(0,t),i=e>t?n.substring(e):"";return[s+"/",i]}function rN(n){return n.match(TS.URL_SCHEME_REGEX)!=null}const nO=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(s=>rN(s)):e=rN(n),e)return sO(n,t)}return null};$n.registerSaveRouter(nO);$n.registerLoadRouter(nO);function sO(n,t){return new TS(n,t)}function u7(n,t){return sO(n,t)}class Ox{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class h7{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function d7(n,t,e,s){const i=arguments;return new h7(f7(...i))}function f7(n,t,e,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Ox(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ox({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ox({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:s}))}function kS(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(ft(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=t.shape,r=i[i.length-1];let o=1;for(let p=0;p<i.length-1;++p)o*=i[p];const l=n.shape,c=i.slice();c.pop();let h=1;for(let p=r;p<e;++p)h*=l[p],c.push(l[p]);const d=[...Ot(n.shape).map(p=>p/h),1].slice(0,r);return[c,o,h,d]}const Kv=-2,p7=-1;function $S(n,t,e){const s=n.shape.length;F(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),F(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)F(t[i]+e[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${t[i]+e[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function m7(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function ES(n,t,e){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((t[i]-n[i])/e[i]);return s}function iO(n,t,e,s){const i=[...n];for(let r=i.length;r<s.length;r++)i.push(1);for(let r=0;r<e;r++)r===0?i[t]=1:(i.splice(t,0,1),i.pop());return i}function rO(n,t,e){return e<=n?e:e-(t-1)}function oO(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function g7(n,t,e,s,i,r,o,l,c){const h=n.length;let d=new Array(h),p=new Array(h),m=new Array(h);if(t.length&&e>0){const y=t[0],b=e+1;d=aO(o,y,b,s,n),p=lO(l,y,b,i,n),m=iO(r,y,b,n)}else for(let y=0;y<h;y++)d[y]=uO(o,s,r,n,y,c),p[y]=hO(l,i,r,n,y,c),m[y]=cO(r,y,c);return{begin:d,end:p,strides:m}}function aO(n,t,e,s,i){const r=[...i],o=oO(e,t);for(let l=0;l<r.length;l++)if(o.indexOf(l)>-1)r[l]=0;else{const c=rO(t,e,l);let h=s[c];n&1<<c&&(h=0),r[l]=h}return r}function lO(n,t,e,s,i){const r=[...i],o=oO(e,t);for(let l=0;l<r.length;l++)if(o.indexOf(l)>-1)r[l]=Number.MAX_SAFE_INTEGER;else{const c=rO(t,e,l);let h=s[c];n&1<<c&&(h=Number.MAX_SAFE_INTEGER),r[l]=h}for(let l=0;l<r.length;l++){const c=i[l];r[l]<0&&(r[l]+=c),r[l]=Wa(0,r[l],i[l])}return r}function cO(n,t,e){let s=n[t];return(e&1<<t||s==null)&&(s=1),s}function uO(n,t,e,s,i,r){let o=t[i];const l=e[i]||1;(n&1<<i||r&1<<i||o==null)&&(l>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const c=s[i];return o<0&&(o+=c),o=Wa(0,o,c-1),o}function hO(n,t,e,s,i,r){let o=t[i];const l=e[i]||1;(n&1<<i||r&1<<i||o==null)&&(l>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const c=s[i];return o<0&&(o+=c),l>0?o=Wa(0,o,c):o=Wa(-1,o,c-1),o}function IS(n,t,e){let s=e.length;for(let i=0;i<e.length;i++)if(e[i]>1){s=i;break}for(let i=s+1;i<e.length;i++)if(t[i]>0||e[i]!==n[i])return!1;return!0}function NS(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function gy(n,t,e){let s;const i=n.shape.length;typeof t=="number"?s=[t,...new Array(i-1).fill(0)]:t.length<i?s=t.concat(new Array(i-t.length).fill(0)):s=t.slice(),s.forEach(o=>{F(o!==-1,()=>"slice() does not support negative begin indexing.")});let r;return e==null?r=new Array(i).fill(-1):typeof e=="number"?r=[e,...new Array(i-1).fill(-1)]:e.length<i?r=e.concat(new Array(i-e.length).fill(-1)):r=e,r=r.map((o,l)=>o>=0?o:(F(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${l}.`),n.shape[l]-s[l])),[s,r]}function AS(n,t,e,s,i,r,o,l,c){let h;if(s==null?(h=new Array(t.length),h.fill(1)):h=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:h.slice(),beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:l,shrinkAxisMask:c};for(let k=0;k<p.dims;k++)d&&(1<<k&l)!==0&&p.numAddAxisAfterEllipsis++,1<<k&o&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};y7(p,m);let y=!0,b=!0,x=!0;const w=[],S=[];for(let k=0;k<n.length;++k){if(m.strides[k]===0)throw Error(`strides[${k}] must be non-zero`);const $=!!(m.shrinkAxisMask&1<<k),E=n[k];if(E===-1){w.push($?1:-1);continue}const N=[m.beginMask&1<<k,m.endMask&1<<k],_=[m.strides[k]>0?0:-1,m.strides[k]>0?E:E-1];if($&&m.strides[k]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[k]===1;const R=!!(m.beginMask&1<<k&&m.endMask&1<<k);if(m.beginValid&&m.endValid){if($){const B=m.begin[k]<0?E+m.begin[k]:m.begin[k];if(m.begin[k]=B,m.end[k]=m.begin[k]+1,B<0||B>=E)throw Error(`slice index ${m.begin[k]} of dimension ${k} out of bounds.`)}else m.begin[k]=oN(m.begin[k],0,m.strides[k],E,N,_),m.end[k]=oN(m.end[k],1,m.strides[k],E,N,_);const A=m.strides[k]===1&&m.begin[k]===0&&m.end[k]===E;y=y&&A,b=b&&(k===0&&m.strides[k]===1||A)}else y=y&&m.strides[k]===1&&R,b=b&&(k===0&&m.strides[k]===1||R);let D,M=!1;if(m.beginValid&&m.endValid?(D=m.end[k]-m.begin[k],M=!0):$?(D=1,M=!0):R&&E>=0&&(m.strides[k]<0?D=-E:D=E,M=!0),M){let A;D===0||D<0!=m.strides[k]<0?A=0:A=Math.trunc(D/m.strides[k])+(D%m.strides[k]!==0?1:0),w.push(A)}else w.push(-1)}for(let k=0;k<m.finalShapeGatherIndices.length;++k){const $=m.finalShapeGatherIndices[k];$>=0?S.push(w[$]):$===Kv&&S.push(1)}return{finalShapeSparse:S.filter((k,$)=>m.finalShapeGatherIndices[$]!==Kv),finalShape:S,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function y7(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<i;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(Kv),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[s]),n.end!=null&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(p7),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}function oN(n,t,e,s,i,r){if(i[t])return e>0?r[t]:r[t+1&1];{const o=n<0?s+n:n;return o<r[0]?r[0]:o>r[1]?r[1]:o}}const b7=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:$S,computeFlatOffset:NS,computeOutShape:ES,getNormalizedAxes:g7,isSliceContinous:IS,maskToAxes:m7,parseSliceParams:gy,sliceInfo:AS,startForAxis:uO,startIndicesWithElidedDims:aO,stopForAxis:hO,stopIndicesWithElidedDims:lO,stridesForAxis:cO,stridesWithElidedDims:iO},Symbol.toStringTag,{value:"Module"}));class x7{static sgd(t){return new CS(t)}static momentum(t,e,s=!1){return new tO(t,e,s)}static rmsprop(t,e=.9,s=0,i=null,r=!1){return new eO(t,e,s,i,r)}static adam(t=.001,e=.9,s=.999,i=null){return new ZD(t,e,s,i)}static adadelta(t=.001,e=.95,s=null){return new YD(t,e,s)}static adamax(t=.002,e=.9,s=.999,i=null,r=0){return new QD(t,e,s,i,r)}static adagrad(t,e=.1){return new JD(t,e)}}const lc=x7;const v7=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function dO(){return new Promise(n=>v7(()=>n()))}function _S(n,t){const e=n[0].length;n.forEach((i,r)=>{F(i.length===e,()=>`Error in concat${e}D: rank of tensors[${r}] must be the same as the rank of the rest (${e})`)}),F(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((i,r)=>{for(let o=0;o<e;o++)F(o===t||i[o]===s[o],()=>`Error in concat${e}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function ar(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var Fi;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Fi||(Fi={}));function fO(n,t,e){let s=new Array;if(e==null&&t==null)return s;if(t==null)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(e==null)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let i=1;i<e.length;++i){const r=e[i],o=s[s.length-e.length+i],l=s[o];if(r>=0)if(l>=0){if(l!==r)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+n}] = ${r} but shape[${i+n}] = ${l}`)}else s[o]=r}return s}function pO(n){const t={FIRST_DIM_SIZE:Fi.FIRST_DIM_SIZE,VALUE_ROWIDS:Fi.VALUE_ROWIDS,ROW_LENGTHS:Fi.ROW_LENGTHS,ROW_SPLITS:Fi.ROW_SPLITS,ROW_LIMITS:Fi.ROW_LIMITS,ROW_STARTS:Fi.ROW_STARTS},e=[];for(const s of n)if(s in t)e.push(t[s]);else break;return e}function mO(n){return n.length===0?0:n[0]===Fi.FIRST_DIM_SIZE?n.length-1:n.length}function gO(n,t){if(n==null||t==null)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(e,s-1);++i){const r=n[i],o=t[i+1];if(r>=0&&o>=0&&r!==1&&r!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-n.length}] = ${r} but ragged tensor input.flatValues.shape[${i-n.length}] = ${o}`)}}const RS=30;function yy(n){return n<=RS?n:Rv(n,Math.floor(Math.sqrt(n)))}function DS(n,t,e){const s=e*(typeof n=="number"?n:n[0]),i=t*(typeof n=="number"?n:n[1]);return[s,i]}function sf(n,t,e,s=!0){let i=[];if(s)i=i.concat(t.slice(0)),i.push(n[0]/e),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const r=t.length;for(let o=0;o<r;++o)i=i.concat([n[o+1]/t[o],t[o]]);i=i.concat(n.slice(r+1))}return i}function rf(n,t,e=!0){const s=[];if(e){s.push(t);for(let i=t+1;i<n;++i)i<=2*t?(s.push(i),s.push(i-(t+1))):s.push(i)}else{const i=[],r=[];for(let o=1;o<n;++o)o>=t*2+1||o%2===1?r.push(o):i.push(o);s.push(...i),s.push(0),s.push(...r)}return s}function of(n,t,e,s=!0){const i=[];s?i.push(n[0]/e):i.push(n[0]*e);for(let r=1;r<n.length;++r)r<=t.length?s?i.push(t[r-1]*n[r]):i.push(n[r]/t[r-1]):i.push(n[r]);return i}function OS(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function MS(n,t,e){const s=n.slice(0,1);for(let i=0;i<e;++i)s.push(n[i+1]-t[i][0]-t[i][1]);return s}const by=1.7580993408473768,xy=1.0507009873554805;const FS=.3275911,LS=.254829592,zS=-.284496736,PS=1.421413741,BS=-1.453152027,VS=1.061405429;function Wr(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function yO(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function bO(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let i=0;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:e,imag:s}}function xO(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let i=2;i<n.length;i+=4)e[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:e,imag:s}}function US(n,t){const e=n[t*2],s=n[t*2+1];return{real:e,imag:s}}function vO(n,t,e,s){n[s*2]=t,n[s*2+1]=e}function wO(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const r=(t?2:-2)*Math.PI*(i/n);e[i]=Math.cos(r),s[i]=Math.sin(r)}return{real:e,imag:s}}function SO(n,t,e){const s=(e?2:-2)*Math.PI*(n/t),i=Math.cos(s),r=Math.sin(s);return{real:i,imag:r}}const Mx="->",w7=/->/g,aN=",",lN="...";function jS(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(w7,"").length)/Mx.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${Mx}").`);const[s,i]=n.split(Mx);F(s.indexOf(lN)===-1,()=>`The ellipsis notation ("${lN}") is not supported yet.`);const r=s.split(aN),o=r.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const l=[];for(let m=0;m<i.length;++m){const y=i[m];if(!r.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);l.indexOf(y)===-1&&l.push(y)}for(let m=0;m<s.length;++m){const y=s[m];l.indexOf(y)===-1&&y!==aN&&l.push(y)}const c=new Array(r.length);for(let m=0;m<o;++m){if(new Set(r[m].split("")).size!==r[m].length)throw new Error(`Found duplicate axes in input component ${r[m]}. Support for duplicate axes in input is not implemented yet.`);c[m]=[];for(let y=0;y<r[m].length;++y)c[m].push(l.indexOf(r[m][y]))}const h=l.length,d=i.length,p=[];for(let m=d;m<h;++m)p.push(m);return{allDims:l,summedDims:p,idDims:c}}function GS(n,t){let e=new Array(n);e.fill(-1);for(let i=0;i<t.length;++i)e[t[i]]=i;const s=[];for(let i=0;i<n;++i)e[i]===-1&&s.push(i);return e=e.filter(i=>i!==-1),{permutationIndices:e,expandDims:s}}function WS(n,t,e){const s=new Array(n);for(let i=0;i<e.length;++i){const r=e[i].shape;for(let o=0;o<t[i].length;++o)s[t[i][o]]===void 0?s[t[i][o]]=r[o]:F(s[t[i][o]]===r[o],()=>`Expected dimension ${s[t[i][o]]} at axis ${o} of input shaped ${JSON.stringify(r)}, but got dimension ${r[o]}`)}}function HS(n,t){const e=n,s=[];let i=0;n.length===0&&e.push(-1),i=n.length+1;for(let o=0;o<i;++o)s.push([]);const r=[];for(let o=0;o<e.length;++o){const l=e[o],c=S7(t,l);for(const h of c)r.indexOf(h)===-1&&(s[o].push(h),r.push(h))}return{path:e,steps:s}}function qS(n){return n.every((t,e)=>t===e)}function S7(n,t){const e=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(t)!==-1||t===-1)&&e.push(s);return e}function KS(n,t,e=0){let s=[];if(typeof t=="number")F(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{const i=t.reduce((o,l)=>(l===-1&&(o+=1),o),0);F(i<=1,()=>"There should be only one negative value in split array.");const r=t.indexOf(-1);if(r!==-1){const o=t.reduce((l,c)=>c>0?l+c:l);t[r]=n.shape[e]-o}F(n.shape[e]===t.reduce((o,l)=>o+l),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function CO(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function TO(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function kO(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function $O(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function EO(n,t){return`size ${n} must be non-negative, not ${t}`}function IO(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function NO(n,t){const e=ft(n),s=ft(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${t}`}function AO(n,t){const e=ft(n),s=ft(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${t}`}function Xv(){return"segment ids must be >= 0"}function _O(){return"segment ids are not increasing"}function RO(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function DO(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function OO(n,t){let e=!1,s;for(n<=RS?(s=n,e=!0):s=Rv(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=Rv(n,s+1);return s}function MO(n,t,e){const s=[],i=n.length;for(let r=0;r<i;r++)r!==t?s.push(n[r]):s.push(e);return s}function XS(n,t,e,s){const i=t.shape.length,r=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>r)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let p=0;p<s;++p)if(n.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);const o=n.shape[e],l=[];let c=1,h=1,d=1;for(let p=0;p<s;++p)l.push(n.shape[p]),c*=n.shape[p];for(let p=s;p<e;p++)l.push(n.shape[p]),h*=n.shape[p];for(let p=s;p<i;p++)l.push(t.shape[p]);for(let p=e+1;p<r;p++)l.push(n.shape[p]),d*=n.shape[p];return{batchSize:c,sliceSize:d,outerSize:h,dimSize:o,outputShape:l}}const C7=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:XS,computeOutShape:MO,segOpComputeOptimalWindowSize:OO},Symbol.toStringTag,{value:"Module"}));function Hr(n){try{return n.map(t=>Fo(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function FO(n){return n.map(t=>_o(t))}const T7=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:LS,ERF_A2:zS,ERF_A3:PS,ERF_A4:BS,ERF_A5:VS,ERF_P:FS,PARALLELIZE_THRESHOLD:RS,get RowPartitionType(){return Fi},SELU_SCALE:xy,SELU_SCALEALPHA:by,applyActivation:yS,assertAndGetBroadcastShape:Ht,assertAxesAreInnerMostDims:Fn,assertParamsConsistent:_S,assignToTypedArray:vO,axesAreInnerMostDims:tS,calculateShapes:cl,checkEinsumDimSizes:WS,checkPadOnDimRoundingMode:gs,combineLocations:$D,combineRaggedTensorToTensorShapes:fO,complexWithEvenIndex:bO,complexWithOddIndex:xO,computeConv2DInfo:Mn,computeConv3DInfo:Ho,computeDefaultPad:K1,computeDilation2DInfo:Zd,computeOptimalWindowSize:yy,computeOutAndReduceShapes:An,computeOutShape:ar,computePool2DInfo:xi,computePool3DInfo:Xr,convertConv2DDataFormat:Yr,decodeEinsumEquation:jS,eitherStridesOrDilationsAreOne:Xn,expandShapeToKeepDim:cn,exponent:SO,exponents:wO,fromStringArrayToUint8:FO,fromUint8ToStringArray:Hr,getAxesPermutation:We,getBroadcastDims:Mc,getComplexWithIndex:US,getEinsumComputePath:HS,getEinsumPermutation:GS,getFusedBiasGradient:gS,getFusedDyActivation:mS,getImageCenter:DS,getInnerMostAxes:nn,getPermuted:rf,getRaggedRank:mO,getReductionAxes:wn,getReshaped:sf,getReshapedPermuted:of,getRowPartitionTypesHelper:pO,getSliceBeginCoords:OS,getSliceSize:MS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:CO,getSparseFillEmptyRowsNegativeIndexErrorMessage:TO,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:kO,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:IO,getSparseReshapeInputOutputMismatchErrorMessage:AO,getSparseReshapeInputOutputMultipleErrorMessage:NO,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:$O,getSparseReshapeNegativeOutputDimErrorMessage:EO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:DO,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Xv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:_O,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:RO,getUndoAxesPermutation:qo,isIdentityPermutation:qS,log:L6,mergeRealAndImagArrays:Wr,prepareAndValidate:kS,prepareSplitSize:KS,segment_util:C7,shouldFuse:bS,slice_util:b7,splitRealAndImagArrays:yO,stridesOrDilationsArePositive:Ja,tupleValuesAreOne:Ya,upcastType:Ns,validateDefaultValueShape:gO,validateInput:HX,validateUpdateShape:GD,warn:Ws},Symbol.toStringTag,{value:"Module"}));i7();const LO={kernelName:cg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,nf($t(e,"float32"),-1))}}};const k7={kernelName:ed,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Fe($t(e,"float32")),i=Kn(Bt(pe(1),s));return tn(Lt(n,i))}}}};const $7={kernelName:nd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Kn(Bt(Fe($t(e,"float32")),1));return Lt(n,s)}}}};const E7={kernelName:Kc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{let l=n;const c=wn(e.shape,i);return c.length>0&&(l=Mt(l,c)),tt(l,e.shape)},b:()=>{let l=n;const c=wn(s.shape,i);return c.length>0&&(l=Mt(l,c)),tt(l,s.shape)}}}};const I7={kernelName:i1,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,i)=>{e[i]=()=>n.clone()}),e}};const N7={kernelName:ug,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ae(e)}}};const A7={kernelName:hg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>ae(e)}}};const _7={kernelName:sd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Kn(Bt(pe(1),Fe($t(e,"float32")))))}}};const R7={kernelName:id,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Kn(wt(pe(1),Fe($t(e,"float32"))));return Lt(n,s)}}}};const D7={kernelName:ad,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{const l=wt(Fe(e),Fe(s));let c=Y(n,Lt(s,l));const h=wn(e.shape,i);return h.length>0&&(c=Mt(c,h)),tt(c,e.shape)},b:()=>{const l=wt(Fe(e),Fe(s));let c=tn(Y(n,Lt(e,l)));const h=wn(s.shape,i);return h.length>0&&(c=Mt(c,h)),tt(c,s.shape)}}}};const O7={kernelName:rd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,wt(Fe($t(e,"float32")),1))}}};const M7={kernelName:od,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Bt(pe(1),Fe($t(e,"float32"))))}}};function F7(n,t,e,s,i,r){const o=U(n,"dy","avgPool3dGrad"),l=U(t,"input","avgPool3dGrad");let c=o,h=l,d=!1;l.rank===4&&(d=!0,c=tt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=tt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),F(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),F(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),gs("avgPool3dGrad",i,r);const p={dy:c,input:h},m={filterSize:e,strides:s,pad:i,dimRoundingMode:r},y=Z.runKernel(l1,p,m);return d?tt(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const L7=et({avgPool3dGrad_:F7});const z7={kernelName:fg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:r,pad:o,dimRoundingMode:l}=e;return{x:()=>L7(n,s,i,r,o,l)}}};function P7(n,t,e,s,i){const r=U(n,"dy","avgPoolGrad"),o=U(t,"input","avgPoolGrad");F(o.rank===r.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${r.rank})`);let l=o,c=r,h=!1;o.rank===3&&(h=!0,l=tt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=tt(r,[1,r.shape[0],r.shape[1],r.shape[2]])),F(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),F(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);const d={dy:c,input:l},p={filterSize:e,strides:s,pad:i},m=Z.runKernel(a1,d,p);return h?tt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const B7=et({avgPoolGrad_:P7});const V7={kernelName:dg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:i,strides:r,pad:o}=e;return{x:()=>B7(n,s,i,r,o)}}};const U7={kernelName:pg,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,i]=t,{transposeA:r,transposeB:o}=e;return!r&&!o?{a:()=>fe(n,i,!1,!0),b:()=>fe(s,n,!0,!1)}:!r&&o?{a:()=>fe(n,i,!1,!1),b:()=>fe(n,s,!0,!1)}:r&&!o?{a:()=>fe(i,n,!1,!0),b:()=>fe(s,n,!1,!1)}:{a:()=>fe(i,n,!0,!0),b:()=>fe(n,s,!0,!0)}}};const j7={kernelName:mg,gradFunc:(n,t,e)=>{const{blockShape:s,crops:i}=e;return{x:()=>lS(n,s,i)}}};const G7={kernelName:D6,gradFunc:(n,t,e)=>{const s=e,i=s.inputShape,r=s.shape,o=Array.from(r);for(let c=i.length-1;c>=0;c--)if(i[c]===r[c])o[c]=1;else if(i[c]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const l=[];for(let c=0;c<o.length;c++)o[c]>1&&l.push(c);return{x:()=>Mt(n,l,!0)}}};const W7={kernelName:ld,gradFunc:n=>({x:()=>n.clone()})};const H7={kernelName:cd,gradFunc:n=>({x:()=>ae(n)})};const q7={kernelName:ud,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:i,clipValueMax:r}=e;return{x:()=>ss(jr(al(s,i),Yc(s,r)),n,ae(n))}}};const K7={kernelName:gg,inputsToSave:["x"],gradFunc:LO.gradFunc};const X7={kernelName:yg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(c=>c.shape),{axis:i}=e,r=Zt(i,t[0].shape)[0],o=s.map(c=>c[r]);return qs(n,o,r).map(c=>()=>c)}};const Y7={kernelName:bg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{dilations:r,strides:o,pad:l,dataFormat:c}=e;return F(Ya(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>J1(s.shape,n,i,o,l,c),filter:()=>pS(s,n,i.shape,o,l,c)}}};const J7={kernelName:xg,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,{strides:r,pad:o,dataFormat:l,dimRoundingMode:c}=e;return{dy:()=>Za(n,i,r,o,l,1,c),filter:()=>pS(n,s,i.shape,r,o,l,c)}}};function Z7(n,t,e,s,i){let r=n;n.rank===4&&(r=tt(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;o.rank===4&&(o=tt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),F(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),F(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),F(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),F(r.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${e[3]}.`),F(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const l={x:r,dy:o},c={strides:s,pad:i,filterShape:e};return Z.runKernel(f1,l,c)}const Q7=et({conv3DBackpropFilter_:Z7});const tY={kernelName:vg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:r}=e;F(Ya(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,l]=t;return{x:()=>SD(o.shape,n,l,i,r),filter:()=>Q7(o,n,l.shape,i,r)}}};const eY={kernelName:hd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(tn(BD($t(e,"float32"))),n)}}};const nY={kernelName:dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(VD($t(e,"float32")),n)}}};const sY={kernelName:wg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i,exclusive:r,reverse:o}=e;return{x:()=>{const l=We([i],s.rank);let c=TD(n,i,r,!o);return l!=null&&(c=oe(c,l)),c}}}};const iY={kernelName:Sg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:i,pad:r,dimRoundingMode:o}=e,l=s??[1,1];F(Ya(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);const[c,h]=t;return F(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),F(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),F(c.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),F(Xn(i,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${l}'.`),gs("depthwiseConv2d",r,o),{x:()=>h9(c.shape,n,h,i,r,l,o),filter:()=>c9(c,n,h.shape,i,r,l,o)}}};const rY={kernelName:Cg,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,i]=t,r={x:s,filter:i,dy:n},o={x:s,filter:i,dy:n};return{x:()=>Z.runKernel(Dv,r,e),filter:()=>Z.runKernel(Ov,o,e)}}};const oY={kernelName:pd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>Z.runKernel(S1,s)}}};const aY={kernelName:md,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Y(dr(tn(Fe(e))),2/Math.sqrt(Math.PI));return{x:()=>Y(n,s)}}};const lY={kernelName:gd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,e)}}};const cY={kernelName:kg,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>tt(n,e.shape)}}};const uY={kernelName:yd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,dr(e))}}};const hY={kernelName:bd,gradFunc:n=>({x:()=>ae(n)})};const dY={kernelName:xd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{const l=Lt(n,$t(s,"float32")),c=wn(e.shape,i);return c.length>0?tt(Mt(l,c),e.shape):l},b:()=>{let l=Y(n,$t(e,"float32"));const c=wn(s.shape,i);c.length>0&&(l=tt(Mt(l,c),s.shape));const h=Fe(s);return tn(Lt(l,$t(h,"float32")))}}}};const fY={kernelName:$g,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[i,r,o,l]=t,c=l??pe(1),h=wn(r.shape,i.shape),d=[];if(r.rank===1){for(let $=0;$<i.shape.length-1;++$)d.push(i.shape[$]);d.push(1)}const p=Bt(i,r),m=Y(n,c),y=LD(wt(o,pe(s))),b=Y(Y(Y(y,y),y),pe(-.5));return{x:()=>r.rank===1?tt(Y(Y(n,Li(tt(y,[1,1,1,r.shape[0]]),d)),c),i.shape):tt(Y(Y(n,y),c),i.shape),mean:()=>{let $=Y(Y(y,pe(-1)),m);return r.rank===1&&($=Mt($,h)),tt($,r.shape)},variance:()=>{let $=Y(Y(b,p),m);return r.rank===1&&($=Mt($,h)),tt($,r.shape)},scale:()=>{const $=Y(p,y);let E=Y(n,$);return r.rank===1&&(E=Mt(E,h)),tt(E,r.shape)},offset:()=>{let $=n;return r.rank===1&&($=Mt($,h)),tt($,r.shape)}}}};const pY={kernelName:Eg,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,i]=t,{axis:r,batchDims:o}=e,l=Zt(r,s.shape)[0],c=(h,d,p)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,l),x=b.length,w=m.slice(r,m.length).slice(1),S=w.length,T=cN(0,x),k=cN(x+1,x+1+S),$=uN([b,[y],w]),E=tt(p,$),N=tt(d,[y]),_=uN([[x],T,k]),R=oe(E,_);let D=HD(R,N,h.shape[l]);const M=qo(_);return D=oe(D,M),D};if(o===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>Gr(d.map((y,b)=>c(y,i.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>i}}else return{x:c(s,i,n),indices:()=>i}}};function cN(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function uN(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const mY={kernelName:vd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>ae(e),b:()=>ae(s)}}};const gY={kernelName:wd,gradFunc:n=>({x:()=>$t(n,"float32")})};const yY={kernelName:Sd,gradFunc:n=>({x:()=>ae(n)})};const bY={kernelName:Cd,gradFunc:n=>({x:()=>ae(n)})};const xY={kernelName:Td,gradFunc:n=>({x:()=>ae(n)})};const vY={kernelName:Ng,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:i}=e,r=Xs(s,0);return{x:()=>ss(r,n,Y(n,i))}}};const wY={kernelName:$d,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,wt(e,1))}}};const SY={kernelName:kd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,$t(e,"float32"))}}};const CY={kernelName:M6,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;return{logits:()=>{const o=dr(s);return Bt(n,Y(Mt(n,i,!0),o))}}}};function TY(n,t,e,s=5,i=1,r=1,o=.5){const l={x:n,y:t,dy:e},c={depthRadius:s,bias:i,alpha:r,beta:o};return Z.runKernel(I1,l,c)}const kY=et({localResponseNormalizationBackprop_:TY});const $Y={kernelName:Mg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{depthRadius:r,bias:o,alpha:l,beta:c}=e;return{x:()=>kY(s,i,n,r,o,l,c)}}};function zO(n,t,e,s){return t.rank<e.rank&&(t=tt(t,cn(t.shape,s))),n.rank<e.rank&&(n=tt(n,cn(n.shape,s))),{x:()=>Y(n,$t(hr(e,t),n.dtype))}}const hN={kernelName:Fg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:i}=s,r=t[0],o=t[1],l=Zt(i,r.shape),c=zO(n,o,r,l);return{x:()=>c.x()}}};const EY={kernelName:Ed,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Y(n,$t(al(e,s),"float32")),b:()=>Y(n,$t(Dm(e,s),"float32"))}}};function IY(n,t,e,s,i,r,o){const l=U(n,"dy","maxPool3dGrad"),c=U(t,"input","maxPool3dGrad"),h=U(e,"output","maxPool3dGrad");let d=l,p=c,m=h,y=!1;c.rank===4&&(y=!0,d=tt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=tt(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),m=tt(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),F(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),F(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),F(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),gs("maxPool3dGrad",r,o);const b={dy:d,input:p,output:m},x={filterSize:s,strides:i,pad:r,dimRoundingMode:o},w=Z.runKernel(A1,b,x);return y?tt(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const NY=et({maxPool3dGrad_:IY});const AY={kernelName:zg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=e;return{x:()=>NY(n,s,i,r,o,l,c)}}};function _Y(n,t,e,s,i,r,o){const l=U(n,"dy","maxPoolGrad"),c=U(t,"input","maxPoolGrad"),h=U(e,"output","maxPoolGrad");F(c.rank===l.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${l.rank})`),F(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),F(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),gs("maxPoolGrad",r,o);const d={dy:l,input:c,output:h},p={filterSize:s,strides:i,pad:r,dimRoundingMode:o};return Z.runKernel(N1,d,p)}const RY=et({maxPoolGrad_:_Y});const DY={kernelName:Lg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,i]=t,{filterSize:r,strides:o,pad:l}=e;return{x:()=>RY(n,s,i,r,o,l)}}};const OY={kernelName:Pg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e,r=Zt(i,s.shape),l=An(s.shape,r)[1],c=ft(l);return{x:()=>{const d=s.shape.slice();r.forEach(y=>{d[y]=1});const p=tt(n,d);return Lt(Y(p,Xo(s.shape,"float32")),c)}}}};const MY={kernelName:Bg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:i}=s,[r,o]=t,l=Zt(i,r.shape),c=zO(n,o,r,l);return{x:()=>c.x()}}};const FY={kernelName:Id,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>Y(n,$t(Yc(e,s),"float32")),b:()=>Y(n,$t(Xs(e,s),"float32"))}}};const LY={kernelName:Vg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,r=i.map(o=>o[0]);return{x:()=>Re(n,r,s.shape)}}};const zY={kernelName:Nd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{const l=wn(e.shape,i);return l.length>0?tt(Mt(n,l),e.shape):n},b:()=>{const l=Y(n,tn(my(Lt(e,s)))),c=wn(s.shape,i);return c.length>0?tt(Mt(l,c),s.shape):l}}}};const PY={kernelName:Ad,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{const l=Y(n,$t(s,"float32")),c=wn(e.shape,i);return c.length>0?tt(Mt(l,c),e.shape):l},b:()=>{const l=Y(n,$t(e,"float32")),c=wn(s.shape,i);return c.length>0?tt(Mt(l,c),s.shape):l}}}};const BY={kernelName:Ug,gradFunc:n=>({x:()=>tn(n)})};const VY={kernelName:Wg,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>In(e.shape,"float32")}}};const UY={kernelName:Gg,gradFunc:n=>({x:()=>ae(n)})};const jY={kernelName:Hg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return el(n,s).map(r=>()=>r)}};const dN={kernelName:qg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:i}=e,r=i.map(o=>o[0]);return{x:()=>Re(n,r,s.shape)}}};const GY={kernelName:_d,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,i]=t,r=e,o=s,l=Ht(r.shape,o.shape);return{a:()=>{const d=$t(o,"float32");let p=Y(n,Y(d,Qa(r,Bt(d,pe(1)))));const m=wn(r.shape,l);return m.length>0&&(p=Mt(p,m)),tt(p,r.shape)},b:()=>{const d=Xs(r,0),p=ss(d,fr(r),ae(r));let m=Y(n,Y(i,p));const y=wn(o.shape,l);return y.length>0&&(m=Mt(m,y)),tt(m,o.shape)}}}};const WY={kernelName:Kg,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,i=Xs(e,0);return{x:()=>ss(i,n,Y(n,s)),alpha:()=>{let r=ss(i,ae(n),Y(n,e));const o=wn(s.shape,n.shape);return o.length>0&&(r=Mt(r,o)),tt(r,s.shape)}}}};function HY(n,t,e){const s=n.shape.slice();s[e]=1;const i=tt(t,s),r=Hv(n,e,!0,!1),o=Hv(n,e,!0,!0),l=Y(r,o);return Y(i,l)}function qY(n,t,e){const s=n.shape.length,i=s-e.length,r=We(e,s);let o=n;r!=null&&(o=oe(n,r));const l=o.shape.slice(),h=l.splice(s-e.length,e.length).reduce((m,y)=>m*y,1);l.push(h);const d=o.reshape(l);let p=HY(d,t,i);if(p=p.reshape(o.shape),r!=null){const m=qo(r);p=oe(p,m)}return p}const KY={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:i}=e;let r=[];return i==null?r=s.shape.map((o,l)=>l):typeof i=="number"?r=[i]:r=i,{x:()=>qY(s,n,r)}}};const XY={kernelName:fd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{const l=Lt(n,$t(s,"float32")),c=wn(e.shape,i);return c.length>0?tt(Mt(l,c),e.shape):l},b:()=>{let l=Y(n,$t(e,"float32"));const c=wn(s.shape,i);c.length>0&&(l=tt(Mt(l,c),s.shape));const h=Fe(s);return tn(Lt(l,$t(h,"float32")))}}}};const YY={kernelName:Rd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,tn(Fe(e)))}}};const JY={kernelName:Od,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=Y(Yc(e,6),nf(e));return{x:()=>Y(n,$t(s,"float32"))}}};const ZY={kernelName:Dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,$t(nf(e),"float32"))}}};const QY={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>tt(n,e.shape)}}};const tJ={kernelName:Zg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>Z.runKernel(L1,i,e)}}};const eJ={kernelName:Jg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,i={dy:n,images:s};return{images:()=>Z.runKernel(F1,i,e)}}};const nJ={kernelName:Qg,gradFunc:(n,t,e)=>{const{dims:s}=e,i=Zt(s,n.shape);return{x:()=>tl(n,i)}}};const sJ={kernelName:Md,gradFunc:n=>({x:()=>ae(n)})};const iJ={kernelName:Fd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>tn(Lt(n,Y(Qa(e,1.5),2)))}}};const rJ={kernelName:ty,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>$t(ae(e),"float32"),t:()=>Y(n,$t(e,n.dtype)),e:()=>Y(n,$t(iS(e),n.dtype))}}};const oJ={kernelName:Ld,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Xs(e,pe(0)),i=pe(by),r=pe(xy),o=Y(n,r),l=Y(Y(n,i),dr($t(e,"float32")));return ss(s,o,l)}}}};const aJ={kernelName:Vd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Y(e,Bt(pe(1),e)))}}};const lJ={kernelName:Bd,gradFunc:n=>({x:()=>ae(n)})};const cJ={kernelName:zd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(Z1($t(e,"float32")),n)}}};const uJ={kernelName:Pd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(CD($t(e,"float32")),n)}}};const hJ={kernelName:ey,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:i,size:r}=e,o=s.shape,[l,c]=gy(s,i,r),h=[];for(let d=0;d<n.rank;d++)h.push([l[d],o[d]-l[d]-c[d]]);return{x:()=>aS(n,h)}}};const dJ={kernelName:ry,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:i}=e,r=!0,o=Y(n,s);return{logits:()=>Bt(o,Y(Mt(o,[i],r),s))}}};const fJ={kernelName:Ud,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Xc(e))}}};const fN={kernelName:sy,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:i}=e;return{x:()=>Y1(n,s,i)}}};const pN={kernelName:iy,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>fs(n,s)}}};const pJ={kernelName:jd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Y(Kn($t(e,"float32")),2))}}};const mJ={kernelName:z1,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(n,Y($t(e,"float32"),2))}}};const gJ={kernelName:Gd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=pe(2);return{a:()=>Y(n,Y(i,Bt(e,s))),b:()=>Y(n,Y(i,Bt(s,e)))}}};const yJ={kernelName:Xd,gradFunc:n=>({x:()=>ae(n)})};const bJ={kernelName:Wd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,i=Ht(e.shape,s.shape);return{a:()=>{let l=n;const c=wn(e.shape,i);return c.length>0&&(l=Mt(l,c)),tt(l,e.shape)},b:()=>{let l=n;const c=wn(s.shape,i);return c.length>0&&(l=Mt(l,c)),tt(tn(l),s.shape)}}}};const xJ={kernelName:ny,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,i=s.shape.slice(),{axis:r}=e;Zt(r,s.shape).forEach(h=>{i[h]=1});const l=tt(n,i),c=Y(l,Xo(s.shape,"float32"));return{x:()=>c}}};const vJ={kernelName:Hd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Lt(n,Fe(Z1(e)))}}};const wJ={kernelName:qd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Y(Bt(pe(1),Fe(e)),n)}}};const SJ={kernelName:Kd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:i}=e;return{x:()=>{let o=ae(s);if(s.rank===1)for(let l=0;l<i[0];++l)o=wt(o,Re(n,[l*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let l=0;l<i[0];++l)for(let c=0;c<i[1];++c)o=wt(o,Re(n,[l*s.shape[0],c*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let l=0;l<i[0];++l)for(let c=0;c<i[1];++c)for(let h=0;h<i[2];++h)o=wt(o,Re(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let l=0;l<i[0];++l)for(let c=0;c<i[1];++c)for(let h=0;h<i[2];++h)for(let d=0;d<i[3];++d)o=wt(o,Re(n,[l*s.shape[0],c*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};const CJ={kernelName:$c,gradFunc:(n,t,e)=>{const s=e,{perm:i}=s,r=qo(i);return{x:()=>oe(n,r)}}};const TJ={kernelName:oy,gradFunc:(n,t,e)=>{const s=e,{axis:i}=s;return{value:()=>Gr(n,i)}}};const kJ={kernelName:ay,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$J(n,e)}}};function $J(n,t){const e=Ko(t,ae(t)),s=eS(n,e);let i=al(t,pe(0,"int32"));const r=s.rank-i.rank;for(let l=0;l<r;++l)i=us(i,l+1);i=jr(i,Xo(s.shape,"bool"));const o=ae(s);return ss(i,s,o)}const EJ={kernelName:ly,gradFunc:n=>({x:()=>ae(n)})};const IJ=[LO,k7,$7,E7,I7,N7,A7,_7,R7,D7,O7,M7,z7,V7,U7,j7,G7,W7,H7,q7,K7,X7,J7,Y7,tY,eY,nY,sY,iY,rY,XY,oY,aY,lY,cY,uY,dY,hY,fY,pY,mY,gY,yY,bY,xY,vY,wY,SY,CY,$Y,hN,hN,EY,AY,DY,OY,MY,FY,LY,zY,PY,BY,VY,UY,jY,dN,dN,GY,WY,KY,YY,JY,ZY,QY,tJ,eJ,nJ,sJ,iJ,rJ,oJ,aJ,lJ,cJ,uJ,hJ,dJ,fJ,fN,fN,pN,pN,pJ,gJ,mJ,yJ,bJ,xJ,vJ,wJ,SJ,CJ,TJ,kJ,EJ];for(const n of IJ)z6(n);dt().prototype.abs=function(){return this.throwIfDisposed(),Qn(this)};dt().prototype.acos=function(){return this.throwIfDisposed(),Z5(this)};dt().prototype.acosh=function(){return this.throwIfDisposed(),tq(this)};dt().prototype.add=function(n){return this.throwIfDisposed(),wt(this,n)};dt().prototype.all=function(n,t){return this.throwIfDisposed(),xD(this,n,t)};dt().prototype.any=function(n,t){return this.throwIfDisposed(),Gv(this,n,t)};dt().prototype.argMax=function(n){return this.throwIfDisposed(),Mh(this,n)};dt().prototype.argMin=function(n){return this.throwIfDisposed(),rq(this,n)};dt().prototype.asScalar=function(){return this.throwIfDisposed(),F(this.size===1,()=>"The array must have only 1 element."),tt(this,[])};dt().prototype.asType=function(n){return this.throwIfDisposed(),$t(this,n)};dt().prototype.as1D=function(){return this.throwIfDisposed(),tt(this,[this.size])};dt().prototype.as2D=function(n,t){return this.throwIfDisposed(),tt(this,[n,t])};dt().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),tt(this,[n,t,e])};dt().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),tt(this,[n,t,e,s])};dt().prototype.as5D=function(n,t,e,s,i){return this.throwIfDisposed(),tt(this,[n,t,e,s,i])};dt().prototype.asin=function(){return this.throwIfDisposed(),aq(this)};dt().prototype.asinh=function(){return this.throwIfDisposed(),cq(this)};dt().prototype.atan=function(){return this.throwIfDisposed(),hq(this)};dt().prototype.atan2=function(n){return this.throwIfDisposed(),fq(this,n)};dt().prototype.atanh=function(){return this.throwIfDisposed(),mq(this)};dt().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),X1(this,n,t,e,s)};dt().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Y1(this,n,t)};dt().prototype.batchNorm=function(n,t,e,s,i){return this.throwIfDisposed(),hy(this,n,t,e,s,i)};dt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Sh(this,n)};dt().prototype.cast=function(n){return this.throwIfDisposed(),$t(this,n)};dt().prototype.ceil=function(){return this.throwIfDisposed(),Uq(this)};dt().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Ks(this,n,t)};dt().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof gn&&(n=[n]),fs([this,...n],t)};dt().prototype.conv1d=function(n,t,e,s,i,r){return this.throwIfDisposed(),vD(this,n,t,e,s,i,r)};dt().prototype.conv2dTranspose=function(n,t,e,s,i){return this.throwIfDisposed(),wD(this,n,t,e,s,i)};dt().prototype.conv2d=function(n,t,e,s,i,r){return this.throwIfDisposed(),Za(this,n,t,e,s,i,r)};dt().prototype.cos=function(){return this.throwIfDisposed(),Z1(this)};dt().prototype.cosh=function(){return this.throwIfDisposed(),CD(this)};dt().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Hv(this,n,t,e)};dt().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),TD(this,n,t,e)};dt().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),f8(this,n,t)};dt().prototype.depthwiseConv2d=function(n,t,e,s,i,r){return this.throwIfDisposed(),Q1(this,n,t,e,s,i,r)};dt().prototype.dilation2d=function(n,t,e,s,i){return this.throwIfDisposed(),g8(this,n,t,e,s,i)};dt().prototype.divNoNan=function(n){return this.throwIfDisposed(),w8(this,n)};dt().prototype.div=function(n){return this.throwIfDisposed(),Lt(this,n)};dt().prototype.dot=function(n){return this.throwIfDisposed(),C8(this,n)};dt().prototype.elu=function(){return this.throwIfDisposed(),fy(this)};dt().prototype.equal=function(n){return this.throwIfDisposed(),hr(this,n)};dt().prototype.erf=function(){return this.throwIfDisposed(),kD(this)};dt().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),M8(this,n,t)};dt().prototype.exp=function(){return this.throwIfDisposed(),dr(this)};dt().prototype.expandDims=function(n){return this.throwIfDisposed(),us(this,n)};dt().prototype.expm1=function(){return this.throwIfDisposed(),P8(this)};dt().prototype.fft=function(){return this.throwIfDisposed(),jD(this)};dt().prototype.flatten=function(){return this.throwIfDisposed(),tt(this,[this.size])};dt().prototype.floor=function(){return this.throwIfDisposed(),my(this)};dt().prototype.floorDiv=function(n){return this.throwIfDisposed(),bD(this,n)};dt().prototype.gather=function(n,t,e){return this.throwIfDisposed(),eS(this,n,t,e)};dt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),al(this,n)};dt().prototype.greater=function(n){return this.throwIfDisposed(),Xs(this,n)};dt().prototype.ifft=function(){return this.throwIfDisposed(),qv(this)};dt().prototype.irfft=function(){return this.throwIfDisposed(),RX(this)};dt().prototype.isFinite=function(){return this.throwIfDisposed(),K8(this)};dt().prototype.isInf=function(){return this.throwIfDisposed(),Y8(this)};dt().prototype.isNaN=function(){return this.throwIfDisposed(),Z8(this)};dt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),sS(this,n)};dt().prototype.lessEqual=function(n){return this.throwIfDisposed(),Yc(this,n)};dt().prototype.less=function(n){return this.throwIfDisposed(),Dm(this,n)};dt().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),sK(this,n,t,e,s)};dt().prototype.logSigmoid=function(){return this.throwIfDisposed(),uK(this)};dt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),AD(this,n)};dt().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),_D(this,n,t)};dt().prototype.log=function(){return this.throwIfDisposed(),fr(this)};dt().prototype.log1p=function(){return this.throwIfDisposed(),ND(this)};dt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),jr(this,n)};dt().prototype.logicalNot=function(){return this.throwIfDisposed(),iS(this)};dt().prototype.logicalOr=function(n){return this.throwIfDisposed(),RD(this,n)};dt().prototype.logicalXor=function(n){return this.throwIfDisposed(),bK(this,n)};dt().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),fe(this,n,t,e)};dt().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),rS(this,n,t,e,s)};dt().prototype.max=function(n,t){return this.throwIfDisposed(),Pi(this,n,t)};dt().prototype.maximum=function(n){return this.throwIfDisposed(),Ko(this,n)};dt().prototype.mean=function(n,t){return this.throwIfDisposed(),ln(this,n,t)};dt().prototype.min=function(n,t){return this.throwIfDisposed(),Rm(this,n,t)};dt().prototype.minimum=function(n){return this.throwIfDisposed(),zh(this,n)};dt().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),$K(this,n,t)};dt().prototype.mod=function(n){return this.throwIfDisposed(),IK(this,n)};dt().prototype.mul=function(n){return this.throwIfDisposed(),Y(this,n)};dt().prototype.neg=function(){return this.throwIfDisposed(),tn(this)};dt().prototype.norm=function(n,t,e){return this.throwIfDisposed(),py(this,n,t,e)};dt().prototype.notEqual=function(n){return this.throwIfDisposed(),Om(this,n)};dt().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),DD(this,n,t,e)};dt().prototype.onesLike=function(){return this.throwIfDisposed(),bi(this)};dt().prototype.pad=function(n,t){return this.throwIfDisposed(),aS(this,n,t)};dt().prototype.pool=function(n,t,e,s,i,r){return this.throwIfDisposed(),zK(this,n,t,e,s,i,r)};dt().prototype.pow=function(n){return this.throwIfDisposed(),Qa(this,n)};dt().prototype.prelu=function(n){return this.throwIfDisposed(),cS(this,n)};dt().prototype.prod=function(n,t){return this.throwIfDisposed(),VK(this,n,t)};dt().prototype.reciprocal=function(){return this.throwIfDisposed(),dX(this)};dt().prototype.relu=function(){return this.throwIfDisposed(),ll(this)};dt().prototype.relu6=function(){return this.throwIfDisposed(),MD(this)};dt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),tt(this,n.shape)};dt().prototype.reshape=function(n){return this.throwIfDisposed(),tt(this,n)};dt().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),KD(this,n,t,e)};dt().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),XD(this,n,t,e)};dt().prototype.reverse=function(n){return this.throwIfDisposed(),tl(this,n)};dt().prototype.rfft=function(){return this.throwIfDisposed(),MX(this)};dt().prototype.round=function(){return this.throwIfDisposed(),FD(this)};dt().prototype.rsqrt=function(){return this.throwIfDisposed(),LD(this)};dt().prototype.selu=function(){return this.throwIfDisposed(),zD(this)};dt().prototype.separableConv2d=function(n,t,e,s,i,r){return this.throwIfDisposed(),PD(this,n,t,e,s,i,r)};dt().prototype.sigmoid=function(){return this.throwIfDisposed(),Xc(this)};dt().prototype.sign=function(){return this.throwIfDisposed(),wX(this)};dt().prototype.sin=function(){return this.throwIfDisposed(),BD(this)};dt().prototype.sinh=function(){return this.throwIfDisposed(),VD(this)};dt().prototype.slice=function(n,t){return this.throwIfDisposed(),Re(this,n,t)};dt().prototype.softmax=function(n){return this.throwIfDisposed(),fS(this,n)};dt().prototype.softplus=function(){return this.throwIfDisposed(),Qd(this)};dt().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),lS(this,n,t)};dt().prototype.split=function(n,t){return this.throwIfDisposed(),qs(this,n,t)};dt().prototype.sqrt=function(){return this.throwIfDisposed(),Kn(this)};dt().prototype.square=function(){return this.throwIfDisposed(),Fe(this)};dt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),LX(this,n)};dt().prototype.squeeze=function(n){return this.throwIfDisposed(),ef(this,n)};dt().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof gn?[this,n]:[this,...n];return Gr(e,t)};dt().prototype.step=function(n){return this.throwIfDisposed(),nf(this,n)};dt().prototype.stridedSlice=function(n,t,e,s,i,r,o,l){return this.throwIfDisposed(),UX(this,n,t,e,s,i,r,o,l)};dt().prototype.sub=function(n){return this.throwIfDisposed(),Bt(this,n)};dt().prototype.sum=function(n,t){return this.throwIfDisposed(),Mt(this,n,t)};dt().prototype.tan=function(){return this.throwIfDisposed(),GX(this)};dt().prototype.tanh=function(){return this.throwIfDisposed(),uy(this)};dt().prototype.tile=function(n){return this.throwIfDisposed(),Li(this,n)};dt().prototype.toBool=function(){return this.throwIfDisposed(),$t(this,"bool")};dt().prototype.toFloat=function(){return this.throwIfDisposed(),$t(this,"float32")};dt().prototype.toInt=function(){return this.throwIfDisposed(),$t(this,"int32")};dt().prototype.topk=function(n,t){return this.throwIfDisposed(),KX(this,n,t)};dt().prototype.transpose=function(n){return this.throwIfDisposed(),oe(this,n)};dt().prototype.unique=function(n){return this.throwIfDisposed(),JX(this,n)};dt().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),HD(this,n,t)};dt().prototype.unstack=function(n){return this.throwIfDisposed(),el(this,n)};dt().prototype.where=function(n,t){return this.throwIfDisposed(),ss(n,this,t)};dt().prototype.zerosLike=function(){return this.throwIfDisposed(),ae(this)};class Qi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Qi.prototype)}}class pi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,pi.prototype)}}class W extends Error{constructor(t){super(t),Object.setPrototypeOf(this,W.prototype)}}class Kt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Kt.prototype)}}class YS extends Error{constructor(t){super(t),Object.setPrototypeOf(this,YS.prototype)}}class PO{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function nl(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function tr(n,t){if(!n)throw new YS(t)}function mN(n,t){let e=0;for(const s of n)s===t&&e++;return e}function hs(n){return n.length===1?n[0]:n}function ve(n){return Array.isArray(n)?n:[n]}function zr(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Aa(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let li={};function JS(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function Yv(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>Yv(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[e]=s.value:Yv(s))}}}function af(n,t={},e={},s="object",i=!1){if(typeof n=="string"){const r=n;let o;if(r in e)o=e[r];else if(r in li)o=li[r];else if(o=t[r],o==null)throw new W(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const r=n;if(r.className==null||r.config==null)throw new W(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const o=r.className;let l,c;if(o in e?[l,c]=e[o]:o in li?[l,c]=li.className:o in t&&([l,c]=t[o]),l==null)throw new W(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const h={};for(const y of Object.keys(li))h[y]=li[y];for(const y of Object.keys(e))h[y]=e[y];const d=r.config;d.customObjects=h;const p=Object.assign({},li);for(const y of Object.keys(e))li[y]=e[y];Yv(r.config);const m=c(l,r.config,e,i);return li=Object.assign({},p),m}else{const h=Object.assign({},li);for(const p of Object.keys(e))li[p]=e[p];const d=new l(r.config);return li=Object.assign({},h),d}}}function NJ(n,t){return n<t?-1:n>t?1:0}function Hp(n,t){return-1*NJ(n,t)}function Ro(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function AJ(n){if(n==null)throw new W(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function ul(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new W(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function ZS(n,t,e=0,s=1/0){return tr(e>=0),tr(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(i=>typeof i===t)}function Nn(n,t){Array.isArray(n)?(F(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Nn(e,`element ${s+1} of ${t}`))):F(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${BO(n)}.`)}function BO(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>BO(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function _J(n,t,e){let s=e!=null?e():cs(),i;return(...o)=>{const l=e!=null?e():cs();return l-s<t||(s=l,i=n(...o)),i}}function VO(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let RJ=0;function UO(){return RJ++}const qp={};function vy(n=""){return n in qp||(qp[n]=0),qp[n]+=1,n+qp[n].toString()}const DJ=["channelsFirst","channelsLast"],OJ=["nearest","bilinear"],MJ=["valid","same","causal"],FJ=["max","avg"],LJ=["sum","mul","concat","ave"];const cc=new Map;function sn(n){ul(DJ,"DataFormat",n)}function zJ(n){ul(OJ,"InterpolationFormat",n)}function Ys(n){ul(MJ,"PaddingMode",n)}function jO(n){ul(FJ,"PoolMode",n)}const Ch=[],gN="/";function Ua(n,t){Ch.push(n);try{const e=t();return Ch.pop(),e}catch(e){throw Ch.pop(),e}}function PJ(){return Ch.length===0?"":Ch.join(gN)+gN}function GO(n){if(!HO(n))throw new Error("Not a valid tensor name: '"+n+"'");return PJ()+n}function WO(n){if(!HO(n))throw new Error("Not a valid tensor name: '"+n+"'");cc.has(n)||cc.set(n,0);const t=cc.get(n);if(cc.set(n,cc.get(n)+1),t>0){const e=`${n}_${t}`;return cc.set(e,1),e}else return n}const BJ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function HO(n){return!!n.match(BJ)}function VJ(n){return n===parseInt(n.toString(),10)}function Do(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let s=1;for(let i=t;i<e;++i)s*=n[i];return s}function Lc(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function Lo(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function Vi(n,t){if(t<n)throw new W(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let Fx;function yn(){return Fx==null&&(Fx=h5().epsilon()),Fx}function Ui(){return"channelsLast"}function lr(n,t){return $t(n,t)}function lf(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),tt(n,e)}function UJ(n,t){return it(()=>{if(n.shape.length!==2)throw new W(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=lf(n,1);return Jv(e,[1,t,1])})}function jJ(n){const t=[Do(n.shape)];return tt(n,t)}function GJ(n){if(n.rank<=1)throw new W(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Do(n.shape,1)];return tt(n,t)}function ja(n,t,e){return it(()=>{switch(n.rank){case 1:return hS(n,t,e);case 2:return UD(n,[t,0],[e,n.shape[1]]);case 3:return dS(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Fm(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Re(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Re(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new W(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Lx(n,t,e){return it(()=>{switch(n.rank){case 1:return hS(n,t,e);case 2:return UD(n,[0,t],[n.shape[0],e]);case 3:return dS(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Fm(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new W(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Kp(n,t,e,s){return it(()=>{switch(n.rank){case 1:return hS(n,t,e);case 2:switch(s){case 1:return ja(n,t,e);case 2:return Lx(n,t,e);default:throw new W(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return ja(n,t,e);case 2:return dS(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return Lx(n,t,e);default:throw new W(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return ja(n,t,e);case 2:return Fm(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Fm(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return Lx(n,t,e);default:throw new W(`The axis is not within the rank of the tensor ${s}`)}default:throw new W(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function QS(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),fs(n,t)}function yN(n,t){switch(n.rank){case 1:return Wq([n,t]);case 2:return qq([n,t],0);case 3:return Xq([n,t],0);case 4:return Jq([n,t],0);default:throw new W(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Jv(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new W(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Li(n,t)}function wy(n,t=0,e=1,s,i){return lX(n,t,e,s,i)}function cr(n,t,e,s){if(n.rank<2||t.rank<2)throw new Kt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const i=n.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(i!==r)throw new Kt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return eN({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Zv(n.rank,s,Ui()):null,activation:e});{const i=n.shape.slice(),r=i.pop();n=tt(n,[-1,r]);const o=t.shape.slice(),l=o.pop(),c=o.pop(),h=[...o,l],d=Array.from({length:t.rank},(b,x)=>x===0?t.rank-2:x<=t.rank-2?x-1:x);t=tt(oe(t,d),[c,-1]);const p=[...i,...h];return tt(eN({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Zv(n.rank,s,Ui()):null,activation:e}),p)}}function qO(n,t,e){return it(()=>(Array.isArray(t)?t=Is(t,"int32"):t=$t(t,"int32"),eS(n,t,e)))}function cf(n){return Y(n,n)}function Zv(n,t,e){const s=t.shape;if(t.rank!==1&&t.rank!==n)throw new W(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return s.length===1?tt(t,[1,s[0],1,1,1]):tt(t,[1,s[3],s[0],s[1],s[2]]);if(e==="channelsLast")return s.length===1?tt(t,[1,1,1,1,s[0]]):tt(t,[1].concat(s))}else if(n===4){if(e==="channelsFirst")return s.length===1?tt(t,[1,s[0],1,1]):tt(t,[1,s[2],s[0],s[1]]);if(e==="channelsLast")return s.length===1?tt(t,[1,1,1,s[0]]):tt(t,[1].concat(s))}else if(n===3){if(e==="channelsFirst")return s.length===1?tt(t,[1,s[0],1]):tt(t,[1,s[1],s[0]]);if(e==="channelsLast")return s.length===1?tt(t,[1,1,s[0]]):tt(t,[1].concat(s))}else if(n<3)return t;throw new W(`Unsupported input rank by biasAdd: ${t.rank}`)}function Gi(n,t,e){return it(()=>(e==null&&(e=Ui()),sn(e),wt(n,Zv(n.rank,t,e))))}function WJ(n,t=1){if(t!==1)throw new Kt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return fy(n)}function HJ(n){return it(()=>Lt(n,wt(Qn(n),1)))}function KO(n,t,e,s){return it(()=>i9(n,t,e,s))}function qJ(n){return it(()=>{const t=wt(.5,Y(.2,n));return Ks(t,0,1)})}function uf(n,t,e=!1){return e?n():t()}const KJ=["fanIn","fanOut","fanAvg"],XJ=["normal","uniform","truncatedNormal"];function YJ(n){ul(KJ,"FanMode",n)}function JJ(n){ul(XJ,"Distribution",n)}class vi extends Zc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class XO extends vi{apply(t,e){return In(t,e)}}XO.className="Zeros";xt(XO);class tC extends vi{apply(t,e){return Xo(t,e)}}tC.className="Ones";xt(tC);class YO extends vi{constructor(t){if(super(),typeof t!="object")throw new W(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new W(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return it(()=>Y(pe(this.value),Xo(t,e)))}getConfig(){return{value:this.value}}}YO.className="Constant";xt(YO);class JO extends vi{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return tf(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}JO.className="RandomUniform";xt(JO);class ZO extends vi{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Kt(`randomNormal does not support dType ${e}.`);return wy(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}ZO.className="RandomNormal";xt(ZO);class QO extends vi{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Kt(`truncatedNormal does not support dType ${e}.`);return WD(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}QO.className="TruncatedNormal";xt(QO);class tM extends vi{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return it(()=>{if(t.length!==2||t[0]!==t[1])throw new W("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,ID(t[0]))})}getConfig(){return{gain:this.gain}}}tM.className="Identity";xt(tM);function ZJ(n,t="channelsLast"){let e,s;if(sn(t),n.length===2)e=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const i=Do(n,2);e=n[1]*i,s=n[0]*i}else if(t==="channelsLast"){const i=Do(n,0,n.length-2);e=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=Do(n);e=Math.sqrt(i),s=Math.sqrt(i)}return[e,s]}class As extends vi{constructor(t){if(super(),t.scale<0)throw new W(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,YJ(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,JJ(this.distribution),this.seed=t.seed}apply(t,e){const s=ZJ(t),i=s[0],r=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,i):this.mode==="fanOut"?o/=Math.max(1,r):o/=Math.max(1,(i+r)/2),this.distribution==="normal"){const l=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Kt(`${this.getClassName()} does not support dType ${e}.`);return WD(t,0,l,e,this.seed)}else{const l=Math.sqrt(3*o);return tf(t,-l,l,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}As.className="VarianceScaling";xt(As);class eC extends As{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return As.className}}eC.className="GlorotUniform";xt(eC);class nC extends As{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return As.className}}nC.className="GlorotNormal";xt(nC);class sC extends As{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return As.className}}sC.className="HeNormal";xt(sC);class iC extends As{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return As.className}}iC.className="HeUniform";xt(iC);class rC extends As{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return As.className}}rC.className="LeCunNormal";xt(rC);class oC extends As{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return As.className}}oC.className="LeCunUniform";xt(oC);class eM extends vi{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return it(()=>{if(t.length<2)throw new Kt("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const s=ft(t.slice(0,-1)),i=t[t.length-1],r=s*i;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const o=[Math.max(i,s),Math.min(i,s)],l=wy(o,0,1,e,this.seed),c=t7.qr(l,!1);let h=c[0];const p=c[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return h=Y(h,p.sign()),s<i&&(h=h.transpose()),Y(pe(this.gain),h.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}eM.className="Orthogonal";xt(eM);const bN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function xN(n,t={}){return af(n,di.getMap().classNameMap,t,"initializer")}function Ge(n){return JS(n)}function Be(n){if(typeof n=="string"){const t=n in bN?bN[n]:n;if(t==="GlorotNormal")return new nC;if(t==="GlorotUniform")return new eC;if(t==="HeNormal")return new sC;if(t==="HeUniform")return new iC;if(t==="LeCunNormal")return new rC;if(t==="LeCunUniform")return new oC;{const e={};return e.className=t,e.config={},xN(e)}}else return n instanceof vi?n:xN(n)}function Qv(n){return Array.isArray(n)&&Array.isArray(n[0])}function Lm(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function jt(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new W(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function ce(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new W(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function zm(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((s,i)=>s*i);return t}const vN="Variable";class QJ{constructor(t,e="float32",s=vN,i=!0,r=null){this.dtype=e??"float32",this.shape=t.shape,this.id=UO(),s=s??vN,this.originalName=GO(s),this.name=WO(this.originalName),this.trainable_=i,this.constraint=r,this.val=t9(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),tZ(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function tZ(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function tw(n){return n.map(t=>t.read())}function aC(n){n.forEach(t=>{t[0].write(t[1])})}class bn{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class pr{constructor(t,e,s,i,r,o,l){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=i,this.callArgs=r,this.outputTensorIndex=l,this.id=UO(),o!=null&&(this.originalName=GO(o),this.name=WO(this.originalName)),this.rank=e.length}}let eZ=0;class Sy{constructor(t,e){this.callArgs=e,this.id=eZ++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let nZ=0;class Qt extends Zc{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=nZ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=zr(s)+"_"+vy(s)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let s;if(t.batchInputShape!=null)s=t.batchInputShape;else if(t.inputShape!=null){let r=null;t.batchSize!=null&&(r=t.batchSize),s=[r].concat(t.inputShape)}this.batchInputShape=s;let i=t.dtype;i==null&&(i=t.inputDType),i==null&&(i="float32"),this.dtype=i}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new pi(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new W(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return hs(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return hs(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Qi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Qi(`Layer ${this.name} is not connected, no input to return.`);return hs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Qi(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Qi(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return hs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=ve(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=ve(this.inputSpec);if(e.length!==s.length)throw new W(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let i=0;i<e.length;i++){const r=e[i],o=s[i];if(o==null)continue;const l=r.rank;if(o.ndim!=null&&l!==o.ndim)throw new W(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${l}`);if(o.maxNDim!=null&&l>o.maxNDim)throw new W(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${l}`);if(o.minNDim!=null&&l<o.minNDim)throw new W(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${l}.`);if(o.dtype!=null&&r.dtype!==o.dtype)throw new W(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${r.dtype}.`);if(o.axes){const c=r.shape;for(const h in o.axes){const d=Number(h),p=o.axes[h],m=d>=0?c[d]:c[c.length+d];if(p!=null&&[p,null].indexOf(m)===-1)throw new W(`Input ${i} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${p} but got shape ${c}.`)}}if(o.shape!=null)for(let c=0;c<o.shape.length;++c){const h=o.shape[c],d=r.shape[c];if(h!=null&&d!=null&&h!==d)throw new W(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=ve(t),i=rZ(t),r=oZ(t);if(i===r)throw new W("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ua(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const l of ve(t))o.push(l.shape);this.build(hs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(t),r){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const l=ve(o),c=[];for(let h of l)s.indexOf(h)!==-1&&(h=h.clone()),c.push(h);if(o=hs(c),this.activityRegularizer!=null)throw new Kt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=sZ(t),l=this.computeOutputShape(o);let c;const h=iZ(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l!=null&&l.length>0&&Array.isArray(l[0])?c=l.map((d,p)=>new pr(h,d,this,ve(t),e,this.name,p)):c=new pr(h,l,this,ve(t),e,this.name),this.addInboundNode(t,c,null,null,o,l,e),this._refCount++,this.activityRegularizer!=null)throw new Kt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&t[i]!=null&&t[i]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Qi(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);t.indexOf(s)===-1&&t.push(s)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Qi(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new pi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return tw(t?this.trainableWeights:this.weights)}setWeights(t){it(()=>{const e=this.weights;if(e.length!==t.length)throw new W(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const s=[],i=tw(e);for(let r=0;r<i.length;++r){const o=i[r],l=e[r],c=t[r];if(!me(o.shape,c.shape))throw new W(`Layer weight shape ${o.shape} not compatible with provided weight shape ${c.shape}`);s.push([l,c])}aC(s)})}addWeight(t,e,s,i,r,o,l,c){if(this._addedWeightNames.indexOf(t)!==-1)throw new W(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=c!=null?c():Be("zeros"));const h=i.apply(e,s),d=new QJ(h,s,t,o,l);return h.dispose(),r!=null&&this.addLoss(()=>r.apply(d.read())),o==null&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=ve(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const i=this.computeMask(t,s),r=ve(e),o=ve(i);if(r.length!==o.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let l=0;l<r.length;l++)r[l].kerasMask=o[l]}addInboundNode(t,e,s,i,r,o,l=null){const c=ve(t);e=ve(e),s=ve(s),i=ve(i),r=Lm(r),o=Lm(o);const h=[],d=[],p=[];for(const m of c)h.push(m.sourceLayer),d.push(m.nodeIndex),p.push(m.tensorIndex);new Sy({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:p,inputTensors:c,outputTensors:e,inputMasks:s,outputMasks:i,inputShapes:r,outputShapes:o},l);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function sZ(n){n=ve(n);const t=[];for(const e of n)t.push(e.shape);return hs(t)}function iZ(n){return"float32"}function nM(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const s=t.inboundNodes[e];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let r=0;r<s.inboundLayers.length;r++){const o=s.inputTensors[r],l=s.inboundLayers[r],c=s.nodeIndices[r],h=nM(o,l,c);for(const d of h)i.indexOf(d)===-1&&i.push(d)}return i}}}function rZ(n){let t=!0;for(const e of ve(n))if(!(e instanceof pr)){t=!1;break}return t}function oZ(n){let t=!0;for(const e of ve(n))if(e instanceof pr){t=!1;break}return t}class hf extends Qt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:vy("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new W("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new W("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new W("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=e,this.dtype=s,this.inputSpec=[{shape:e}];const i=new pr(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new Sy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new W(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}hf.className="InputLayer";xt(hf);function aZ(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new W("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new hf({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function lZ(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return $t(t,n.dtype)}catch{throw new W(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Io{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Io)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(this.id2Value[t.id]==null)this.id2Value[t.id]=lZ(t,e),this.name2Id[t.name]=t.id,s!=null&&(this.id2Mask[t.id]=s);else throw new W(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof pr){if(this.id2Value[t.id]==null)throw new W(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new W(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof pr){if(this.id2Value[t.id]==null)throw new W(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new W(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Yt(this.id2Mask)}}const Pm=new PO,Bm=new PO;function cZ(n){Pm?.setMaxEntries(n),Bm?.setMaxEntries(n)}function hh(n,t,e,s){const i=e==null?!1:e.training,r=Array.isArray(n),o=r?n:[n],l=o.map(b=>b.name),c=[],h=t.names();for(const b of l)h.indexOf(b)!==-1?c.push(t.getValue(b)):c.push(null);const d=l.join(",")+"|"+t.names().sort().join(",");let p=Pm.get(d),m;if(p==null){const b=uZ(o,t);p=b.sorted,m=b.recipientCounts,Pm.put(d,p),Bm.put(d,m)}m={},i||Object.assign(m,Bm.get(d));const y=new Io(t);for(let b=0;b<p.length;++b){const x=p[b],w=x.sourceLayer;if(w instanceof hf)continue;const S=[],T=[],k=[];let $=!1;for(const D of x.inputs){const M=y.getValue(D),A=y.getMask(D);S.push(M),T.push(A),A!=null&&($=!0),i||(m[D.name]--,m[D.name]===0&&!t.hasKey(D)&&l.indexOf(D.name)===-1&&!M.isDisposed&&D.sourceLayer.stateful!==!0&&k.push(M))}$&&(e=e||{},e.mask=T[0]);const E=ve(w.apply(S,e));let N=null;w.supportsMasking&&(N=w.computeMask(S,T));const _=dZ(x),R=Array.isArray(_)?_:[_];for(let D=0;D<R.length;++D){y.hasKey(R[D])||y.add(R[D],E[D],Array.isArray(N)?N[0]:N);const M=l.indexOf(R[D].name);M!==-1&&(c[M]=E[D])}i||Yt(k)}return y.disposeMasks(),r?c:c[0]}function uZ(n,t){F(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(n.length===1){const i=wN(n[0],t);e=i.sorted,s=i.recipientMap}else{const i=new Set;for(const r of n){const{sorted:o,recipientMap:l}=wN(r,t);for(const c of o)i.has(c.name)||(e.push(c),i.add(c.name));for(const c in l)s[c]==null&&(s[c]=new Set),l[c].forEach(h=>s[c].add(h))}}return{sorted:e,recipientCounts:hZ(s)}}function hZ(n){const t={};for(const e in n)t[e]=n[e].size;return t}function wN(n,t){const e=new Set,s=[],i={};for(const l of t.names())e.add(l);const r=[],o=[];for(r.push(n);r.length>0;){const l=r[r.length-1];if(e.has(l.name)){r.pop();continue}const c=o[o.length-1]===r.length-1;if(l.inputs.length===0||c)r.pop(),s.push(l),e.add(l.name),c&&o.pop();else{o.push(r.length-1);for(const h of l.inputs)i[h.name]==null&&(i[h.name]=new Set),i[h.name].add(l.name),!e.has(h.name)&&r.push(h)}}return{sorted:s,recipientMap:i}}function dZ(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}const fZ=at();fZ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,cZ);function lC(n,t){return it(()=>Kn(Mt(Y(n,n),t,!0)))}class df extends Zc{getConfig(){return{}}}class sM extends df{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return it(()=>{const e=lC(t,this.axis),s=Ks(e,0,this.maxValue);return Y(t,Lt(s,wt(yn(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}sM.className="MaxNorm";xt(sM);class iM extends df{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return it(()=>Lt(t,wt(yn(),lC(t,this.axis))))}getConfig(){return{axis:this.axis}}}iM.className="UnitNorm";xt(iM);class rM extends df{apply(t){return ll(t)}}rM.className="NonNeg";xt(rM);class oM extends df{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return it(()=>{const e=lC(t,this.axis),s=wt(Y(this.rate,Ks(e,this.minValue,this.maxValue)),Y(1-this.rate,e));return Y(t,Lt(s,wt(yn(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}oM.className="MinMaxNorm";xt(oM);const SN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function xn(n){return JS(n)}function CN(n,t={}){return af(n,di.getMap().classNameMap,t,"constraint")}function vn(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in SN?SN[n]:n,config:{}};return CN(e)}else return n instanceof df?n:CN(n)}async function Sa(n){if(n==null)return;const t=[],e=[],s=[];for(const i in n){const r=n[i];if(typeof r!="number"){const o=r;t.push(o.data()),e.push(i),s.push(o)}}if(t.length>0){const i=await Promise.all(t);for(let r=0;r<i.length;++r)n[e[r]]=i[r][0];Yt(s)}}function aM(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var TN;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(TN||(TN={}));const pZ=125;class Bh{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class mZ{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const s of this.callbacks)await s.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class gZ extends Bh{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const s=e.size==null?0:e.size;this.seen+=s;for(const i in e){const r=e[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*s;else{let o;i in this.totals?o=this.totals[i]:this.totals[i]=0;const l=it(()=>wt(this.totals[i],Y(r,s)));this.totals[i]=l,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?e[s]=this.totals[s]/this.seen:it(()=>{const i=Y(Lt(1,this.seen),this.totals[s]);e[s]=i,this.totals[s].dispose(),or(e[s])}))}}class yZ extends Bh{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const s in e)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(e[s])}async syncData(){const t=[],e=[],s=[];for(const r in this.history){const o=this.history[r];for(let l=0;l<o.length;++l)if(typeof o[l]!="number"){const c=o[l];t.push(c.data()),e.push(r),s.push(l)}}const i=await Promise.all(t);for(let r=0;r<i.length;++r)this.history[e[r]][s[r]].dispose(),this.history[e[r]][s[r]]=i[r][0]}}class bZ extends Bh{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||dO,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=pZ),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Av(this.yieldEvery)&&(this.maybeWait=_J(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,s){const i=[];this.yield!=null&&(await Sa(s),i.push(this.yield(t,e,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await Sa(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const s=[];this.epochEnd!=null&&(await Sa(e),s.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(t,e){this.batchBegin!=null&&(await Sa(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const s=[];this.batchEnd!=null&&(await Sa(e),s.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Av(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(s)}async onTrainBegin(t){this.trainBegin!=null&&(await Sa(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Sa(t),await this.trainEnd(t))}}function lM(n,t){return n==null&&(n={}),n instanceof Bh?[n]:Array.isArray(n)&&n[0]instanceof Bh?n:ve(n).map(s=>new bZ(s,t))}class hi{constructor(){}static registerCallbackConstructor(t,e){F(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),hi.checkForDuplicate(e),hi.constructors[t]==null&&(hi.constructors[t]=[]),hi.constructors[t].push(e)}static checkForDuplicate(t){for(const e in hi.constructors)hi.constructors[+e].forEach(i=>{if(i===t)throw new W("Duplicate callback constructor.")})}static clear(){hi.constructors={}}static createCallbacks(t){const e=[];for(const s in hi.constructors){const i=+s;t>=i&&e.push(...hi.constructors[i])}return e.map(s=>new s)}}hi.constructors={};function cM(n,t,e,s,i,r,o,l,c){const h=new yZ,d=[new gZ,...hi.createCallbacks(t)];n!=null&&d.push(...n),d.push(h);const p=new mZ(d);return p.setParams({epochs:e,initialEpoch:s,samples:i,steps:r,batchSize:o,verbose:t,doValidation:l,metrics:c}),{callbackList:p,history:h}}function ur(n,t={},e=!1){return af(n,di.getMap().classNameMap,t,"layer",e)}function Vm(n,t){return it(()=>{n.dtype!=="float32"&&(n=$t(n,"float32"));const e=Mt(cf(n),t,!0),s=dy(e.shape,yn()),i=Kn(Ko(e,s));return Lt(n,i)})}function Cy(n,t){return it(()=>ln(cf(Bt(t,n)),-1))}function cC(n,t){return it(()=>ln(Qn(Bt(t,n)),-1))}function uC(n,t){return it(()=>{const e=Bt(n,t),s=Ks(Qn(n),yn(),Number.MAX_VALUE),i=Qn(Lt(e,s));return Y(100,ln(i,-1))})}function xZ(n,t){return it(()=>{const e=Ks(t,yn(),Number.MAX_VALUE),s=fr(wt(1,e)),i=Ks(n,yn(),Number.MAX_VALUE),r=fr(wt(1,i));return ln(cf(Bt(s,r)),-1)})}function vZ(n,t){return it(()=>{const e=Ko(0,Bt(1,Y(n,t)));return ln(cf(e),-1)})}function wZ(n,t){return it(()=>{const e=Ko(0,Bt(1,Y(n,t)));return ln(e,-1)})}function SZ(n,t){return it(()=>{const e=Mt(Y(n,t),-1),s=Pi(Y(Bt(1,n),t),-1);return Ko(0,wt(1,Bt(s,e)))})}function CZ(n,t){return it(()=>{const e=Math.log(2),s=Bt(t,n),i=Bt(wt(s,Qd(Y(-2,s))),e);return ln(i,-1)})}function Vh(n,t,e=!1){return it(()=>{if(e)t=fS(t);else{const s=Mt(t,t.shape.length-1,!0);t=Lt(t,s)}return t=Ks(t,yn(),1-yn()),tn(Mt(Y($t(n,"float32"),fr(t)),t.shape.length-1))})}function Um(n,t,e=!1){return it(()=>{const s=$t(my(jJ(n)),"int32");t=Ks(t,yn(),1-yn());const i=t.shape,r=tt(DD(s,i[i.length-1]),i);return Vh(r,t,e)})}function TZ(n,t){if(!me(n.shape,t.shape))throw new W(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return it(()=>{const e=ll(t),s=tn(Qn(t));return wt(Bt(e,Y(t,n)),ND(dr(s)))})}function Ty(n,t){return it(()=>{let e;return e=Ks(t,yn(),1-yn()),e=fr(Lt(e,Bt(1,e))),ln(TZ(n,e),-1)})}function kZ(n,t){return it(()=>{const e=Ks(n,yn(),1),s=Ks(t,yn(),1);return Mt(Y(n,fr(Lt(e,s))),-1)})}function $Z(n,t){return it(()=>{const e=fr(wt(yn(),t));return ln(Bt(t,Y(n,e)),-1)})}function uM(n,t){return it(()=>{const e=Vm(n,-1),s=Vm(t,-1),i=Y(e,s);return tn(Mt(i,-1))})}const jm={meanSquaredError:Cy,meanAbsoluteError:cC,meanAbsolutePercentageError:uC,meanSquaredLogarithmicError:xZ,squaredHinge:vZ,hinge:wZ,categoricalHinge:SZ,logcosh:CZ,categoricalCrossentropy:Vh,sparseCategoricalCrossentropy:Um,binaryCrossentropy:Ty,kullbackLeiblerDivergence:kZ,poisson:$Z,cosineProximity:uM};function zx(n){if(typeof n=="string"){if(n in jm)return jm[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new W(t)}else return n}function hM(n,t){return it(()=>{const e=Y(.5,bi(t)),s=lr(Xs(t,e),n.dtype);return ln(hr(n,s),-1)})}function dM(n,t){return it(()=>lr(hr(Mh(n,-1),Mh(t,-1)),"float32"))}function EZ(n,t){return it(()=>$t(Mt(jr(hr(n,1),hr(t,1))),"float32"))}function IZ(n,t){return it(()=>$t(Mt(jr(hr(n,0),hr(t,1))),"float32"))}function NZ(n,t){return it(()=>{const e=EZ(n,t),s=IZ(n,t),i=wt(e,s);return $t(ss(Xs(i,0),Lt(e,i),0),"float32")})}function AZ(n,t){return Ty(n,t)}function _Z(n,t){return n.rank===t.rank&&(n=ef(n,[n.rank-1])),t=Mh(t,-1),t.dtype!==n.dtype&&(t=$t(t,n.dtype)),$t(hr(n,t),"float32")}const RZ=Cy,DZ=Cy,OZ=cC,MZ=cC,FZ=uC,LZ=uC,fM=Vh,zZ=uM,pM=Um,Gm={binaryAccuracy:hM,categoricalAccuracy:dM,precision:NZ,categoricalCrossentropy:fM,sparseCategoricalCrossentropy:pM,mse:RZ,MSE:DZ,mae:OZ,MAE:MZ,mape:FZ,MAPE:LZ,cosine:zZ};function PZ(n){if(typeof n=="string"&&n in Gm)return Gm[n];if(typeof n!="string"&&n!=null)return n;throw new W(`Unknown metric ${n}`)}function Xp(n){if(tr(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(jm))if(jm[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(Gm))if(Gm[e]===n){t=e;break}return t!==void 0?t:n.name}}function BZ(n){const t={Adagrad:()=>lc.adagrad(.01),Adadelta:()=>lc.adadelta(1,.95,yn()),Adam:()=>lc.adam(.001,.9,.999,yn()),Adamax:()=>lc.adamax(.002,.9,.999,yn(),0),RMSProp:()=>lc.rmsprop(.001,.9,0,yn()),SGD:()=>lc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new W(`Unknown Optimizer ${n}`)}const kN=1*1024*1024;function $N(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!ew(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>kN&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${kN}.`)}}function ew(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!ew(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!ew(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function VZ(n,t,e,s=console.log){const i=jZ(n),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(t*d)));let o;if(!i){r.push("Receives inputs"),o=[];for(const d in n.nodesByDepth)o.push(...n.nodesByDepth[d])}s("_".repeat(t)),Wm(r,e,s),s("=".repeat(t));const l=n.layers;for(let d=0;d<l.length;++d)i?GZ(l[d],e,s):WZ(l[d],e,o,s),s((d===l.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const c=UZ(n),h=zm(n.nonTrainableWeights);s(`Total params: ${c+h}`),s(`Trainable params: ${c}`),s(`Non-trainable params: ${h}`),s("_".repeat(t))}function UZ(n){let t;return n.collectedTrainableWeights!=null?t=zm(n.collectedTrainableWeights):t=zm(n.trainableWeights),t}function jZ(n){let t=!0;const e=[],s=[];for(const i in n.nodesByDepth)e.push(n.nodesByDepth[i]);for(const i of e){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){t=!1;break}s.push(...i)}if(t)for(const i of n.layers){let r=!1;for(const o of i.inboundNodes)if(s.indexOf(o)!==-1)if(r){t=!1;break}else r=!0;if(!t)break}return t}function Wm(n,t,e=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,t[i]),s+=" ".repeat(t[i]-s.length);e(s)}function GZ(n,t,e){let s,i;try{i=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const r=n.name,o=n.getClassName(),l=[`${r} (${o})`,i,s,n.countParams().toString()];Wm(l,t,e)}function WZ(n,t,e,s){let i,r;try{r=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const o=[];for(const p of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){const y=p.inboundLayers[m].name,b=p.nodeIndices[m],x=p.tensorIndices[m];o.push(`${y}[${b}][${x}]`)}const l=n.name,c=n.getClassName(),h=o.length===0?"":o[0],d=[`${l} (${c})`,r,i,n.countParams().toString(),h];Wm(d,t,s);for(let p=1;p<o.length;++p)Wm(["","","","",o[p]],t,s)}function mM(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function Hm(n,t){if(n===null)return null;if(typeof n=="string")return Aa(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];mM(t,i,r)?e.push(r):e.push(Hm(r,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")e[s]=i;else{const r=Aa(s);e[r]=Hm(i,r)}}return e}}function nw(n,t){if(n==null)return null;if(typeof n=="string")return zr(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];mM(t,i,r)?e.push(r):e.push(nw(r,t))}return e}else{const e={};for(const s of Object.keys(n)){const i=n[s],r=zr(s);(s==="name"||s==="className")&&typeof i=="string"?e[r]=i:e[r]=nw(i,s)}return e}}const gM="4.22.0";const HZ=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class Ri extends Qt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const T=this.getClassName().toLowerCase();this.name=vy(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Ro(this.inputs).length!==this.inputs.length)throw new W(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Ro(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const T of this.outputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;this.outputLayers.push(k),this.outputLayersNodeIndices.push($),this.outputLayersTensorIndices.push(E)}for(const T of this.inputs){const k=T.sourceLayer,$=T.nodeIndex,E=T.tensorIndex;tr($===0,"input layer has >1 nodes"),tr(E===0,"input layer has >1 tensors"),this.inputLayers.push(k),this.inputLayersNodeIndices.push($),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){const k=this.inputLayers[T];if(!(k instanceof hf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${T} (0-based) originates from layer type ${k.getClassName()}.`);this.inputNames.push(k.name),this.feedInputShapes.push(k.batchInputShape),this.feedInputNames.push(k.name)}for(const T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);const e={},s={},i={},r={},o={},l=[],c=(T,k,$,E,N,_)=>{(E==null||N==null||_==null)&&(E=T.sourceLayer,N=T.nodeIndex,_=T.tensorIndex);const R=E.inboundNodes[N];if($.indexOf(R)!==-1)throw new pi(`The tensor ${T.name} at layer "${E.name}" is part of a cycle.`);if(k.indexOf(R)!==-1)return;this.containerNodes.add(Ri.nodeKey(E,N)),E.id in o||(o[E.id]=Object.keys(o).length),$.indexOf(R)===-1&&$.push(R);const D=R.inboundLayers.length;for(let M=0;M<D;M++){const A=R.inputTensors[M],B=R.inboundLayers[M],H=R.nodeIndices[M],J=R.tensorIndices[M];c(A,k,$,B,H,J)}for(k.push(R);$.indexOf(R)>=0;)$.splice($.indexOf(R),1);l.push(R)},h=[],d=[];for(const T of this.outputs)c(T,h,d);const p=l.slice().reverse();for(const T of p){s[T.id]=T,T.id in e||(e[T.id]=0);let k=e[T.id];const $=i[T.outboundLayer.id]==null?0:i[T.outboundLayer.id];k=Math.max(k,$),i[T.outboundLayer.id]=k,r[T.outboundLayer.id]=T.outboundLayer,e[T.id]=k;for(let E=0;E<T.inboundLayers.length;E++){const N=T.inboundLayers[E],_=T.nodeIndices[E],R=N.inboundNodes[_],D=e[R.id]==null?0:e[R.id];e[R.id]=Math.max(k+1,D),s[R.id]=R}}const m={};for(const T in e){const k=e[T];k in m||(m[k]=[]),m[k].push(s[T])}const y={};for(const T in i){const k=i[T];k in y||(y[k]=[]),y[k].push(r[T])}let b=Object.keys(y).map(T=>parseInt(T,10)).sort(Hp);this.layers=[];for(const T of b){const k=y[T];k.sort(($,E)=>{const N=o[$.id],_=o[E.id];return N<_?-1:N>_?1:0});for(const $ of k)$ instanceof Ri&&this.internalContainerRefs.push($),this.layers.push($)}this.layersByDepth=y,b=Object.keys(m).map(T=>parseInt(T,10)).sort(Hp);const x=this.inputs.slice(),w=[];for(const T of b)for(const k of m[T]){const $=k.outboundLayer;if($!=null){for(const E of k.inputTensors)if(x.indexOf(E)===-1)throw new pi(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${$.name}". The following previous layers were accessed without issue: ${w}`);for(const E of k.outputTensors)x.push(E);w.push($.name)}}this.nodesByDepth=m;const S=this.layers.map(T=>T.name);for(const T of S){const k=S.filter($=>$===T).length;if(k!==1)throw new pi(`The name "${T}" is used ${k} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(S))}this.outboundNodes=[],this.inboundNodes=[],new Sy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new W("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let i=0;const r=HZ(t);r&&this.parseWeights(t);for(const l of this.layers)for(const[c,h]of l.weights.entries()){const d=r?`${h.name.split("/").slice(0,-1).join("/")+"/"}${c}`:h.originalName;if(s[d]!=null)throw new W(`Duplicate weight name: ${d}`);s[d]=h,i++}const o=[];for(const l in t){let c=l;if(s[l]==null){const h=l.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[c]!=null)o.push([s[c],t[l]]);else if(e)throw new W(`Provided weight data has no target variable: ${l}`);delete s[c]}if(e){const l=[];for(const c in s)l.push(c);if(l.length>0)throw new W(`${l.length} of ${i} weights are not set: ${l}`)}aC(o)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),i=["vars","layer_checkpoint_dependencies"],r=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");r!==e&&(t[r]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${gM}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=nw(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return it(()=>{t=ve(t);const s=new Io;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],t[i]);return hh(this.outputs,s,e)})}computeMask(t,e){return it(()=>{t=ve(t);let s;return e==null?s=nl(null,t.length):s=ve(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=Lm(t);if(e.length!==this.inputLayers.length)throw new W(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let l=0;l<e.length;l++){const c=this.inputLayers[l],h=e[l],d=c.name+"_0_0";s[d]=h}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Hp);if(i.length>1)for(const l of i){const c=this.nodesByDepth[l];for(const h of c){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const p=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],S=h.nodeIndices[x],T=h.tensorIndices[x],k=`${w.name}_${S}_${T}`,$=s[k];p.push($)}const m=d.computeOutputShape(hs(p)),y=Lm(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const r=[],o=[];for(let l=0;l<this.outputLayers.length;l++){const c=this.outputLayers[l],h=this.outputLayersNodeIndices[l],d=this.outputLayersTensorIndices[l],p=`${c.name}_${h}_${d}`;o.push(p)}for(let l=0;l<o.length;l++){const c=o[l];tr(c in s),r.push(s[c])}return hs(r)}runInternalGraph(t,e){e==null&&(e=nl(null,t.length));const s={};for(let c=0;c<this.inputs.length;++c){const h=this.inputs[c],d=t[c],p=e[c];s[h.id]=[d,p]}const i=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(Hp);for(const c of i){const h=this.nodesByDepth[c];for(const d of h){const p=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,S,T,k;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[$,E]=b[0];x.mask==null&&(x.mask=E),T=ve(p.call($,x)),k=ve(p.computeMask($,E)),w=[$],S=[E]}else w=b.map($=>$[0]),S=b.map($=>$[1]),x.mask==null&&(x.mask=S),T=ve(p.call(w,x)),k=ve(p.computeMask(w,S));if(p.activityRegularizer)throw new Kt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let $=0;$<y.length;++$){const E=y[$],N=T[$],_=k[$];s[E.id]=[N,_]}}}}const r=[],o=[],l=[];for(const c of this.outputs){tr(c.id in s,`Could not compute output ${c.name} : ${c.id}`);const[h,d]=s[c.id];l.push(h.shape),r.push(h),o.push(d)}return[r,o,l]}buildNodeConversionMap(t){const e={};let s;for(const i of this.layers){s=i instanceof Ri?1:0;for(let r=0;r<i.inboundNodes.length;r++){const o=Ri.nodeKey(i,r);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new W("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new W(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new W(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return it(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const i=Ri.nodeKey(e,s);this.containerNodes.has(i)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const l=o.getClassName(),c=o.getConfig(),h=[];for(let p=0;p<o.inboundNodes.length;p++){const m=o.inboundNodes[p],y=Ri.nodeKey(o,p);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const S=m.inboundLayers[w],T=m.nodeIndices[w],k=m.tensorIndices[w],$=Ri.nodeKey(S,T);let E=e[$];E==null&&(E=0),x.push([S.name,E,k,b])}h.push(x)}}}const d={};d.name=o.name,d.className=l,d.config=c,d.inboundNodes=h,s.push(d)}t.layers=s;const i=[];for(let o=0;o<this.inputLayers.length;o++){const l=this.inputLayers[o],c=this.inputLayersNodeIndices[o],h=Ri.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=e[h];d==null&&(d=0);const p=this.inputLayersTensorIndices[o];i.push([l.name,d,p])}t.inputLayers=i;const r=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],h=Ri.nodeKey(l,c);if(!this.containerNodes.has(h))continue;let d=e[h];d==null&&(d=0);const p=this.outputLayersTensorIndices[o];r.push([l.name,d,p])}return t.outputLayers=r,t}static fromConfig(t,e,s={},i=!1){const r={},o={};function l(w,S){w.name in o?o[w.name].push(S):o[w.name]=[S]}function c(w,S){const T=[];let k;for(const $ of S){const E=$[0],N=$[1],_=$[2];if(k=$[3]==null?{}:$[3],!(E in r)){l(w,S);return}const R=r[E];if(R.inboundNodes.length<=N){l(w,S);return}const D=R.inboundNodes[N];T.push(D.outputTensors[_])}T.length>0&&w.apply(hs(T),k)}function h(w){const S=w.name,T=ur(w,e.customObjects!=null?e.customObjects:{});T.setFastWeightInitDuringBuild(i),r[S]=T,w.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new W(`Corrupted configuration, expected array for nodeData: ${$}`);l(T,$)})}const d=e.name,p=e.layers;for(const w of p)h(w);for(;!AJ(o);)for(const w of p){const S=r[w.name];if(S.name in o){const T=o[S.name];delete o[S.name];for(const k of T)c(S,k)}}const m=[],y=[],b=e.inputLayers;for(const w of b){const S=w[0],T=w[1],k=w[2];tr(S in r);const E=r[S].inboundNodes[T].outputTensors;m.push(E[k])}const x=e.outputLayers;for(const w of x){const S=w[0],T=w[1],k=w[2];tr(S in r);const E=r[S].inboundNodes[T].outputTensors;y.push(E[k])}return new t({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new W("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){it(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function qZ(n,t,e){const s=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return t.forEach(r=>{r in n?i.push(n[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function yM(n,t){return qZ(n,t,"classWeight")}async function bM(n,t,e,s){if(e!=null){const i=it(()=>{if(n.shape.length===1)return Va(n);if(n.shape.length===2){if(n.shape[1]>1)return Mh(n,1);if(n.shape[1]===1)return tt(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());Yt(i);const o=[];return r.forEach(l=>{if(e[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);o.push(e[l])}),Is(o,"float32")}else return null}function KZ(n,t){return Y(n,t)}const XZ=32;function xM(n,t){let e,s;const i=t;e=i.xs,s=i.ys,F(e!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const r=EN("input",n.inputNames,e),o=EN("output",n.outputNames,s),l=r[0].shape[0];F(r.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),F(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<r.length;c++)F(r[c].shape[0]===l,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${r[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);for(let c=0;c<o.length;c++)F(o[c].shape[0]===l,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${o[c].shape[0]}; expected  ${l} based on input ${n.inputNames[0]}.`);return{xs:r,ys:o}}function EN(n,t,e){if(e instanceof gn)return[e];if(Array.isArray(e))return F(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const i of t){if(e[i]==null)throw new W(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(e[i])}return s}}function YZ(n){if(n.length===3)throw new Kt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function JZ(n,t,e){const s=e.batchesPerEpoch!=null;if(F(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),F(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),F(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),F(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),F(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=e.validationData!=null;let r,o;if(i)if(IN(e.validationData))F(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const w=YZ(e.validationData);r=w.xs,o=w.ys}const l=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let h;i?h=c.slice().concat(c.map(w=>"val_"+w)):h=c.slice();const d=lM(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:y}=cM(d,p,e.epochs,null,null,ZZ(t,e),null,i,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=e.initialEpoch==null?0:e.initialEpoch,x=await t.iterator();for(;b<e.epochs;){const w={};await m.onEpochBegin(b);let S=0,T=0;for(s||(x=await t.iterator());!s||S<e.batchesPerEpoch;){const k=await x.next();if(s&&k.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${S} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(k.value!=null){const{xs:$,ys:E}=xM(n,k.value),N={};N.batch=T,N.size=$[0].shape[0],await m.onBatchBegin(T,N);const _=[];if(e.classWeight!=null){const M=yM(e.classWeight,n.outputNames);for(let A=0;A<M.length;++A)_.push(await bM(E[A],null,M[A]))}const R=$.concat(E).concat(_),D=l(R);Yt(R);for(let M=0;M<c.length;++M){const A=c[M],B=D[M];N[A]=B,or(B)}await m.onBatchEnd(T,N),aM(N),T++,S++}if(s?S>=e.batchesPerEpoch:k.done){if(i){let $;IN(e.validationData)?$=ve(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):$=ve(n.evaluate(r,o,{batchSize:e.validationBatchSize==null?XZ:e.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=$[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function ZZ(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function IN(n){return typeof n.iterator=="function"}function QZ(n){return typeof n.next=="function"}async function tQ(n,t,e){e=e||{};const s=e.batches!=null,i=n.testFunction;let r=[];if(e.verbose>0)throw new Kt("Verbose mode is not implemented yet.");F(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=QZ(t)?t:await t.iterator();let l=0,c=0;for(;!s||c<e.batches;){const h=await o.next();if(r=it(()=>{if(h.value){const{xs:d,ys:p}=xM(n,h.value),m=d.concat(p),y=it(()=>i(m));if(Yt(m),c===0)for(let x=0;x<y.length;++x)r.push(pe(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],S=r[x];r[x]=it(()=>wt(r[x],Y(b,w))),c>0&&Yt(S)}Yt(y),l+=b,++c}return r}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<r.length;++h){const d=r[h];r[h]=Lt(r[h],l),Yt(d)}return hs(r)}function Px(n){F(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function rh(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(s=>ja(s,t,e-t)):ja(n,t,e-t)}function sw(n,t){return it(()=>n==null?null:Array.isArray(n)?n.map(e=>sw(e,t)):qO(n,t.dtype==="int32"?t:$t(t,"int32")))}function Bx(n,t){const e=[];let s=0,i=null;for(;s<n;)i=s+t,i>=n&&(i=n),e.push([s,i]),s=i;return e}function vM(n){const t=[];n instanceof gn&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(s.rank===1)t.push(lf(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Ni(n,t){if(n==null)return;const e=[];if(t instanceof gn)e.push(t.id);else if(Array.isArray(t))t.forEach(i=>e.push(i.id));else if(t!=null)for(const i in t){const r=t[i];e.push(r.id)}const s=[];if(n instanceof gn)e.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{e.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const r=n[i];e.indexOf(r.id)===-1&&s.push(r)}s.forEach(i=>{i.isDisposed||i.dispose()})}function eQ(n){return n instanceof gn}function iw(n){return Array.isArray(n)}function NN(n){return!eQ(n)&&!iw(n)}function AN(n,t,e,s=!0,i=""){if(t==null||t.length===0){if(n!=null){let o=!1;if(iw(n)&&n.length>0)o=!0;else if(NN(n)){for(const l in n)if(n.hasOwnProperty(l)){o=!0;break}}else o=!0;if(o)throw new W(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(o=>null);let r;if(NN(n)){n=n,r=[];for(const o of t){if(n[o]==null)throw new W(`No data provided for "${o}". Need data for each key in: ${t}`);r.push(n[o])}}else if(iw(n)){if(n=n,n.length!==t.length)throw new W(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);r=n}else{if(n=n,t.length>1)throw new W(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);r=[n]}if(r=vM(r),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const l=r[o];if(l.shape.length!==e[o].length)throw new W(`Error when checking ${i}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${l.shape}`);for(let c=0;c<e[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=e[o][c];if(d!=null&&d>=0&&h!==d)throw new W(`${i} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${i} received an input with ${l.shape[0]} examples, each with shape [${l.shape.slice(1,l.shape.length)}] (tensor shape [${l.shape}])`)}}return r}function nQ(n,t,e){const s=Ro(n.map(r=>r.shape[0]));s.sort();const i=Ro(t.map(r=>r.shape[0]));if(i.sort(),s.length>1)throw new W(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(r=>r.shape))}`);if(i.length>1)throw new W(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(r=>r.shape))}`);if(s.length>0&&i.length>0&&!me(s,i))throw new W(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function sQ(n,t,e){const s=[Cy,Ty,Vh];for(let i=0;i<n.length;++i){const r=n[i],o=t[i],l=e[i];if(o!=null){if(o===Vh&&r.shape[r.shape.length-1]===1)throw new W(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const c=r.shape.slice(1),h=l.slice(1);for(let d=0;d<c.length;++d){const p=c[d],m=h[d];if(m!=null&&p!==m)throw new W(`A target Tensor with shape ${r.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function _N(n,t,e,s=!0,i=""){let r;if(Array.isArray(n)){if(n.length!==t.length)throw new W(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);r=n}else{if(t.length>1)throw new W(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);r=[n]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const l=r[o];if(l.shape.length!==e[o].length)throw new W(`Error when checking ${i}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let c=0;c<e[o].length;++c){if(c===0&&!s)continue;const h=l.shape[c],d=e[o][c];if(d!=null&&d!==h)throw new W(`Error when checking ${i}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function iQ(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const i of t){let r=e.hasOwnProperty(i)?e[i]:[];Array.isArray(r)||(r=[r]),s.push(r)}return s}}const rQ="layers-model";class Ic extends Ri{constructor(t){super(t),this.isTraining=!1}summary(t,e,s=console.log){if(!this.built)throw new W("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");VZ(this,t,e,s)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=BZ(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Yo))throw new W("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new W(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(zx(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new W(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(l=>zx(l))}else{const o=zx(t.loss);this.outputs.forEach(l=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const l=this.internalOutputShapes[o],c=this.outputNames[o];this.feedOutputNames.push(c),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ua("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([l,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const i=iQ(t.metrics,this.outputNames),r=(o,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[o]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,o])};Ua("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const l=i[o];(h=>{let p,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[o];w[w.length-1]===1||this.lossFunctions[o]===Ty?["accuracy","acc"].indexOf(b)!==-1?m=hM:["crossentropy","ce"].indexOf(b)!==-1&&(m=AZ):this.lossFunctions[o]===Um?["accuracy","acc"].indexOf(b)!==-1?m=_Z:["crossentropy","ce"].indexOf(b)!==-1&&(m=pM):["accuracy","acc"].indexOf(b)!==-1?m=dM:["crossentropy","ce"].indexOf(b)!==-1&&(m=fM);let S;["accuracy","acc"].indexOf(b)!==-1?S="acc":["crossentropy","ce"].indexOf(b)!==-1&&(S="ce"),y=m,p=""+S}else y=PZ(b),p=""+Xp(b);let x;Ua(p,()=>{x=y}),r(o,p,x)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,s={}){const i=s.batchSize==null?32:s.batchSize;Px(i);const o=this.standardizeUserDataXY(t,e,!0,i);try{const l=o[0].concat(o[1]);this.makeTestFunction();const c=this.testFunction,h=this.testLoop(c,l,i,s.verbose,s.steps);return hs(h)}finally{Ni(o[0],t),Ni(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),tQ(this,t,e)}checkNumSamples(t,e,s,i="steps"){let r;if(s!=null){if(r=null,e!=null)throw new W(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?r=t[0].shape[0]:r=t.shape[0];else throw new W(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new W("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(e),i=s?e:[e],r=this.retrieveSymbolicTensors(i),o=new Io;if(t instanceof gn&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new W(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)o.add(this.inputs[c],t[c])}else for(const c of this.inputs){const h=t[c.name];if(h==null)throw new W(`No value is provided for the model's input ${c.name}`);o.add(c,h)}const l=hh(r,o);return s?l:l[0]}retrieveSymbolicTensors(t){const e=nl(null,t.length);let s=t.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],o=r.map(l=>l.name);for(let l=0;l<t.length;++l){const c=o.indexOf(t[l]);if(c!==-1&&(e[l]=r[c],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw e.forEach((r,o)=>{r==null&&i.push(t[o])}),new W(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return e}predictLoop(t,e=32,s=!1){return it(()=>{const i=this.checkNumSamples(t);if(s)throw new Kt("Verbose predictLoop() is not implemented yet.");const r=Bx(i,e),o=this.outputs.map(l=>[]);for(let l=0;l<r.length;++l)it(()=>{const h=r[l][0],d=r[l][1],p=rh(t,h,d),m=[];if(Array.isArray(p))for(let b=0;b<p.length;++b)m.push({key:this.inputs[b],value:p[b]});else m.push({key:this.inputs[0],value:p});const y=new Io(m);return hh(this.outputs,y)}).forEach((h,d)=>o[d].push(h));return hs(o.map(l=>fs(l,0)))})}predict(t,e={}){const s=vM(t);_N(s,this.inputNames,this.feedInputShapes,!1);try{const i=e.batchSize==null?32:e.batchSize;return Px(i),this.predictLoop(s,i)}finally{Ni(s,t)}}predictOnBatch(t){_N(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,s=!0,i){if(this.optimizer_==null)throw new pi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let o=0;o<this.feedOutputShapes.length;++o){const l=this.feedOutputShapes[o];this.feedLossFns[o]===Um?r.push(l.slice(0,l.length-1).concat([1])):r.push(l)}if(t=AN(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=AN(e,this.feedOutputNames,r,!1,"target"),nQ(t,e),sQ(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&t[0].shape[0]%i!==0)throw new W(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,s,i,r=!0,o){const[l,c]=this.standardizeUserDataXY(t,e,r,o);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(i!=null){const d=yM(i,this.outputNames);h=[];for(let p=0;p<d.length;++p)h.push(await bM(c[p],null,d[p]))}return[l,c,h]}testLoop(t,e,s,i=0,r){return it(()=>{const o=this.checkNumSamples(e,s,r,"steps"),l=[];if(i>0)throw new Kt("Verbose mode is not implemented yet.");if(r!=null)throw new Kt("steps mode in testLoop() is not implemented yet");{const c=Bx(o,s),h=Is(Vi(0,o));for(let d=0;d<c.length;++d){const p=c[d][0],m=c[d][1],y=ja(h,p,m-p),b=sw(e,y),x=t(b);if(d===0)for(let w=0;w<x.length;++w)l.push(pe(0));for(let w=0;w<x.length;++w){const S=x[w];l[w]=wt(l[w],Y(m-p,S))}}for(let d=0;d<l.length;++d)l[d]=Lt(l[d],o)}return l})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let s=0;s<t.length;++s){const i=t[s];let r=i;if(mN(t,i)>1){const o=mN(t.slice(0,s),i);r+=`_${o}`}e.push(r)}return e}makeTrainFunction(){return t=>{const e=[],s=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],l=()=>{const p=[];for(let x=0;x<this.inputs.length;++x)p.push({key:this.inputs[x],value:s[x]});const m=new Io(p),y=hh(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let S=w(i[x],y[x]);r[x]!=null&&(S=KZ(S,r[x]));const T=ln(S);e.push(T),x===0?b=S:b=wt(b,S)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=e[x];else{const S=this.metricsTensors[x][0],T=this.metricsTensors[x][1];w=ln(S(i[T],y[T]))}or(w),o.push(w)}return b=ln(b),this.calculateLosses().forEach(x=>{b=wt(b,x)}),b},c=this.collectedTrainableWeights.map(p=>p.read());return[this.optimizer_.minimize(l,!0,c)].concat(o)}}makeTestFunction(){this.testFunction=t=>it(()=>{const e=[];let s;const i=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let h=0;h<this.inputs.length;++h)o.push({key:this.inputs[h],value:i[h]});const l=new Io(o),c=hh(this.outputs,l);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],p=ln(d(r[h],c[h]));h===0?s=p:s=wt(s,p),e.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],p=this.metricsTensors[h][1],m=ln(d(r[p],c[p]));e.push(m)}return e})}async fit(t,e,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,o,l,c,h,d,p,m;try{const y=s.batchSize==null?32:s.batchSize;Px(y);const x=await this.standardizeUserData(t,e,s.sampleWeight,s.classWeight,!1,y);i=x[0],r=x[1],m=x[2];let w=!1,S;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)c=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new Kt("validationData including sample weights is not supported yet."):new W(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const M=await this.standardizeUserData(c,h,null,null,!0,y);d=M[0],p=M[1],S=d.concat(p)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const D=Math.floor(i[0].shape[0]*(1-s.validationSplit)),M=i[0].shape[0];d=rh(i,D,M),o=i,i=rh(i,0,D),p=rh(r,D,M),l=r,r=rh(r,0,D),S=d.concat(p)}else s.validationSteps!=null&&(w=!0);const T=i.concat(r).concat(m);this.checkTrainableWeightsConsistency();const k=this.makeTrainFunction(),$=this.getDedupedMetricsNames();let E,N;w?(this.makeTestFunction(),E=this.testFunction,N=$.slice().concat($.map(D=>"val_"+D))):(E=null,S=[],N=$.slice());const _=lM(s.callbacks,s.yieldEvery);return await this.fitLoop(k,T,$,y,s.epochs,s.verbose,_,E,S,s.shuffle,N,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ni(i,t),Ni(r,e),Ni(o,t),Ni(l,e),Ni(d,c),Ni(p,h),m!=null&&Yt(m)}}async fitLoop(t,e,s,i,r,o,l,c,h,d,p,m,y,b){i==null&&(i=32),r==null&&(r=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(c!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new W("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(e,i,y,"steps_per_epoch");let S;w!=null&&(S=Vi(0,w)),o==null&&(o=1);const{callbackList:T,history:k}=cM(l,o,r,m,w,y,i,x,p);T.setModel(this),this.history=k,await T.onTrainBegin(),this.stopTraining_=!1;for(let $=m;$<r;++$){await T.onEpochBegin($);const E={};if(y!=null)throw new Kt("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Kt("batch shuffling is not implemneted yet");d&&v6(S);const N=Is(S),_=Bx(w,i);for(let R=0;R<_.length;++R){const D={};if(await T.onBatchBegin(R,D),it(()=>{const M=_[R][0],A=_[R][1],B=ja(N,M,A-M);D.batch=R,D.size=A-M;const H=sw(e,B),J=t(H);for(let X=0;X<s.length;++X){const z=s[X],P=J[X];D[z]=P,or(P)}if(R===_.length-1&&x){const X=this.testLoop(c,h,i);for(let z=0;z<s.length;++z){const P=s[z],V=X[z];or(V),E["val_"+P]=V}}}),await T.onBatchEnd(R,D),aM(D),this.stopTraining_)break}N.dispose()}if(await T.onEpochEnd($,E),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return JZ(this,t,e)}async trainOnBatch(t,e){const s=await this.standardizeUserData(t,e),i=s[0],r=s[1],l=this.makeTrainFunction()(i.concat(r)),c=[];for(const h of l){const d=await h.data();c.push(d[0])}return Yt(l),Ni(s[0],t),Ni(s[1],e),hs(c)}getNamedWeights(t){const e=[],s=t!=null&&t.trainableOnly,i=s?this.trainableWeights:this.weights,r=this.getWeights(s);for(let o=0;o<i.length;++o)s&&!i[o].trainable||e.push({name:i[o].originalName,tensor:r[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=BI().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-BI().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=zr(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>zr(e))}else{const e=Object.keys(this.loss);t={};const s=this.loss;for(const i of e)if(typeof s[i]=="string")t[i]=zr(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[zr(Xp(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>zr(Xp(t)));{const t={};for(const e in this.metrics)t[e]=zr(Xp(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=Hm(t.optimizer_config),s=ur(e);let i;if(typeof t.loss=="string")i=Aa(t.loss);else if(Array.isArray(t.loss))i=t.loss.map(o=>Aa(o));else if(t.loss!=null){i={};for(const o in t.loss)i[o]=Aa(t.loss[o])}let r;if(Array.isArray(t.metrics))r=t.metrics.map(o=>Aa(o));else if(t.metrics!=null){r={};for(const o in t.metrics)r[o]=Aa(t.metrics[o])}this.compile({loss:i,metrics:r,optimizer:s})}async save(t,e){if(typeof t=="string"){const h=$5(t);if(h.length===0)throw new W(`Cannot find any save handlers for URL '${t}'`);if(h.length>1)throw new W(`Found more than one (${h.length}) save handlers for URL '${t}'`);t=h[0]}if(t.save==null)throw new W("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await UI(this.getNamedWeights(e)),l={modelTopology:this.toJSON(null,!1),format:rQ,generatedBy:`TensorFlow.js tfjs-layers v${gM}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:p}=await UI(await this.optimizer.getWeights(),h);s.specs.push(...p),s.data=b5([s.data,d])}return this.userDefinedMetadata!=null&&($N(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=s.data,l.weightSpecs=s.specs,t.save(l)}setUserDefinedMetadata(t){$N(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ic.className="Model";xt(Ic);class wM extends Ic{}wM.className="Functional";xt(wM);async function oQ(n,t){if(t==null&&(t={}),typeof n=="string"){const e=E5(n,t);if(e.length===0)e.push(u7(n,t));else if(e.length>1)throw new W(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return aQ(n,void 0,t)}async function aQ(n,t,e){if(e==null&&(e={}),n.load==null)throw new W("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let i=s.modelTopology;i.model_config!=null&&(i=i.model_config);const r=e.strict==null?!0:e.strict,o=s.weightData!=null&&s.weightSpecs!=null&&r,l=ur(Hm(i),t,o),c=s.trainingConfig;if(c!=null&&l.loadTrainingConfig(c),s.userDefinedMetadata!=null&&l.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new W("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=lQ(s.weightData,s.weightSpecs);l.loadWeights(h,r),l.optimizer!=null&&d.length>0&&await l.optimizer.setWeights(d),Yt(h),Yt(d.map(p=>p.tensor))}return l}function lQ(n,t){const e=d5(n,t),s={},i=[];return t.forEach(r=>{r.group==="optimizer"?i.push({name:r.name,tensor:e[r.name]}):s[r.name]=e[r.name]}),{modelWeights:s,optimizerWeights:i}}class Uh extends Ic{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:vy("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new W(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof Uh||t instanceof Ic;let s;if(e){if(s=t,s.outputs.length!==1)throw new W("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new W("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new W("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=aZ({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(i)}if(e)this.outputs=s.outputs,this.inputs=s.inputs;else{if(t.inboundNodes.length!==1)throw new W(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new W("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=nM(this.outputs[0])}this.inboundNodes=[],new Sy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:nl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=t.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(ce(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ic({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,s=console.log){this.built||this.build(),super.summary(t,e,s)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,s={}){if(!this.built)throw new pi("The model needs to be compiled before being used.");return this.model.evaluate(t,e,s)}async evaluateDataset(t,e){if(!this.built)throw new pi("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,s={}){if(!this.built)throw new pi("The model needs to be compiled before being used.");return this.model.fit(t,e,s)}async fitDataset(t,e){if(!this.built)throw new pi("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,s={},i=!1){let r,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new W("Legacy serialization format not supported yet.");r=e}else F(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=e.layers,delete e.layers,o=e;const l=new t(o);if(!(l instanceof Uh))throw new Kt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of r){const d=ur(c,void 0,i);i&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(t){if(this.model==null)throw new W("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new W("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const s={};s.className=e.getClassName(),s.config=e.getConfig(),t.push(s)}return{name:this.name,layers:t}}}Uh.className="Sequential";xt(Uh);let Yn=class extends Zc{getConfig(){return{}}};class SM extends Yn{apply(t,e=1){return WJ(t,e)}}SM.className="elu";xt(SM);class CM extends Yn{apply(t){return zD(t)}}CM.className="selu";xt(CM);class TM extends Yn{apply(t){return ll(t)}}TM.className="relu";xt(TM);class kM extends Yn{apply(t){return it(()=>zh(6,ll(t)))}}kM.className="relu6";xt(kM);class $M extends Yn{apply(t){return t}}$M.className="linear";xt($M);class EM extends Yn{apply(t){return Xc(t)}}EM.className="sigmoid";xt(EM);class IM extends Yn{apply(t){return qJ(t)}}IM.className="hardSigmoid";xt(IM);class NM extends Yn{apply(t){return Qd(t)}}NM.className="softplus";xt(NM);class AM extends Yn{apply(t){return HJ(t)}}AM.className="softsign";xt(AM);class _M extends Yn{apply(t){return uy(t)}}_M.className="tanh";xt(_M);let hC=class extends Yn{apply(t,e=-1){return fS(t,e)}};hC.className="softmax";xt(hC);class RM extends Yn{apply(t,e=-1){return AD(t,e)}}RM.className="logSoftmax";xt(RM);class DM extends Yn{apply(t){return it(()=>it(()=>{const e=Math.sqrt(2),s=Y(.5,wt(1,kD(Lt(t,e))));return Y(t,s)}))}}DM.className="gelu";xt(DM);class OM extends Yn{apply(t){return it(()=>Y(.5,Y(t,wt(1,uy(Y(Kn(Lt(2,Math.PI)),wt(t,Y(.044715,Qa(t,3)))))))))}}OM.className="gelu_new";xt(OM);class MM extends Yn{apply(t){return it(()=>Y(t,uy(Qd(t))))}}MM.className="mish";xt(MM);class FM extends Yn{apply(t,e=1){return it(()=>Y(Xc(Y(t,e)),t))}}FM.className="swish";xt(FM);function zo(n){return n.getClassName()}function Vx(n,t={}){return af(n,di.getMap().classNameMap,t,"activation")}function Po(n){if(n==null){const t={};return t.className="linear",t.config={},Vx(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},Vx(t)}else return n instanceof Yn?n:Vx(n)}function cQ(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class LM extends Zc{}class zM extends LM{constructor(t){super(),cQ(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return it(()=>{let e=In([1]);return this.hasL1&&(e=wt(e,Mt(Y(this.l1,Qn(t))))),this.hasL2&&(e=wt(e,Mt(Y(this.l2,cf(t))))),tt(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}zM.className="L1L2";xt(zM);const RN={l1l2:"L1L2"};function Ne(n){return JS(n)}function DN(n,t={}){return af(n,di.getMap().classNameMap,t,"regularizer")}function Ve(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in RN?RN[n]:n,config:{}};return DN(e)}else return n instanceof LM?n:DN(n)}class PM extends Qt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=jt(t);let s=ll(t);return this.maxValue!=null&&(s=Ks(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}PM.className="ReLU";xt(PM);class BM extends Qt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=jt(t);return sS(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}BM.className="LeakyReLU";xt(BM);class VM extends Qt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Be(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ve(t.alphaRegularizer),this.alphaConstraint=vn(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new W(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=ce(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)e[i-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<t.length;++i)s[i]=t[i];this.inputSpec=[new bn({ndim:t.length,axes:s})],this.built=!0}call(t,e){return t=jt(t),cS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Ge(this.alphaInitializer),alphaRegularizer:Ne(this.alphaRegularizer),alphaConstraint:xn(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}VM.className="PReLU";xt(VM);let UM=class extends Qt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Kt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const s=jt(t);return fy(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};UM.className="ELU";xt(UM);class jM extends Qt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const s=jt(t);return Y(s,$t(Xs(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}jM.className="ThresholdedReLU";xt(jM);class GM extends Qt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new hC().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return it(()=>{let s=jt(t);const i=e.mask;if(i!=null){const r=Y(Bt(Xo(s.shape),$t(i,s.dtype)),pe(-1e9));s=wt(s,r)}return this.axis instanceof Array?this.axis.length>1?dr(Bt(s,_D(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}GM.className="Softmax";xt(GM);function Nc(n,t,e){if(typeof n=="number")return nl(n,t);if(n.length!==t)throw new W(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const i=n[s];if(!VJ(i))throw new W(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Bi(n,t,e,s,i=1){if(n==null)return n;const r=t+(t-1)*(i-1);let o;return e==="same"?o=n:o=n-r+1,Math.floor((o+s-1)/s)}function er(n,t,e,s){if(n==null)return null;if(s==="valid")n=n*t+Lo([e-t,0]);else if(s==="same")n=n*t;else throw new W(`Unsupport padding mode: ${s}.`);return n}function dC(n,t){return it(()=>(sn(t),t==="channelsFirst"?oe(n,[0,2,3,1]):n))}function WM(n,t){return it(()=>(sn(t),t==="channelsFirst"?oe(n,[0,2,3,4,1]):n))}function uQ(n,t,e,s=1,i="valid",r,o=1){return it(()=>{if(r==null&&(r=Ui()),sn(r),n.shape.length!==3)throw new W(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new W(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new W(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(r==="channelsFirst"&&(n=oe(n,[0,2,1])),i==="causal")throw new Kt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=vD(n,t,s,i==="same"?"same":"valid","NWC",o);return e!=null&&(l=Gi(l,e)),l})}function ON(n,t,e,s=[1,1],i="valid",r,o,l=null){return it(()=>{if(r==null&&(r=Ui()),sn(r),n.rank!==3&&n.rank!==4)throw new W(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new W(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=dC(n,r);if(i==="causal")throw new Kt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=a9({x:c,filter:t,strides:s,pad:i==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:l}),r==="channelsFirst"&&(c=oe(c,[0,3,1,2])),c})}function hQ(n,t,e,s=[1,1,1],i="valid",r,o){return it(()=>{if(r==null&&(r=Ui()),sn(r),n.rank!==4&&n.rank!==5)throw new W(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new W(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let l=WM(n,r);if(i==="causal")throw new Kt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=s8(l,t,s,i==="same"?"same":"valid","NDHWC",o),e!=null&&(l=Gi(l,e)),r==="channelsFirst"&&(l=oe(l,[0,4,1,2,3])),l})}class ky extends Qt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",ky.verifyArgs(e),this.rank=t,Nn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Kt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Nc(e.kernelSize,t,"kernelSize"),this.strides=Nc(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Ys(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,sn(this.dataFormat),this.activation=Po(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Be(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=vn(e.biasConstraint),this.biasRegularizer=Ve(e.biasRegularizer),this.activityRegularizer=Ve(e.activityRegularizer),this.dilationRate=Nc(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new W(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new W(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new W(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(tr("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!ZS(t.kernelSize,"number",1,3))throw new W(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:zo(this.activation),useBias:this.useBias,biasInitializer:Ge(this.biasInitializer),biasRegularizer:Ne(this.biasRegularizer),activityRegularizer:Ne(this.activityRegularizer),biasConstraint:xn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Qc extends ky{constructor(t,e){super(t,e),this.kernel=null,Qc.verifyArgs(e),this.filters=e.filters,Nn(this.filters,"filters"),this.kernelInitializer=Be(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=vn(e.kernelConstraint),this.kernelRegularizer=Ve(e.kernelRegularizer)}build(t){t=ce(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new W(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return it(()=>{t=jt(t);let s;const i=this.bias==null?null:this.bias.read(),r=VO(this.activation.getClassName());if(r!=null&&this.rank===2)s=ON(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)s=uQ(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=ON(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=hQ(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Kt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=ce(t);const e=[],s=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let r=0;r<s.length;++r){const o=Bi(s[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);e.push(o)}let i=[t[0]];return this.dataFormat==="channelsLast"?(i=i.concat(e),i.push(this.filters)):(i.push(this.filters),i=i.concat(e)),i}getConfig(){const t={filters:this.filters,kernelInitializer:Ge(this.kernelInitializer),kernelRegularizer:Ne(this.kernelRegularizer),kernelConstraint:xn(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new W(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class ff extends Qc{constructor(t){super(2,t),ff.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!ZS(t.kernelSize,"number",1,2))throw new W(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}ff.className="Conv2D";xt(ff);class pf extends Qc{constructor(t){super(3,t),pf.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new W(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}pf.className="Conv3D";xt(pf);class HM extends ff{constructor(t){if(super(t),this.inputSpec=[new bn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new W(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ce(t),t.length!==4)throw new W("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new W("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new bn({ndim:4,axes:{[e]:s}})],this.built=!0}call(t,e){return it(()=>{let s=jt(t);if(s.shape.length!==4)throw new W(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,l;this.dataFormat==="channelsFirst"?(o=2,l=3):(o=1,l=2);const c=i[o],h=i[l],d=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=er(c,m,d,this.padding),x=er(h,y,p,this.padding),w=[r,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=oe(s,[0,2,3,1]));let S=wD(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(S=oe(S,[0,3,1,2])),this.bias!=null&&(S=Gi(S,this.bias.read(),this.dataFormat)),this.activation!=null&&(S=this.activation.apply(S)),S})}computeOutputShape(t){t=ce(t);const e=t.slice();let s,i,r;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3):(s=3,i=1,r=2);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1];return e[s]=this.filters,e[i]=er(e[i],c,o,this.padding),e[r]=er(e[r],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}HM.className="Conv2DTranspose";xt(HM);class qM extends pf{constructor(t){if(super(t),this.inputSpec=[new bn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new W(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=ce(t),t.length!==5)throw new W("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new W("The channel dimension of the inputs should be defined. Found `None`.");const s=t[e],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new bn({ndim:5,axes:{[e]:s}})],this.built=!0}call(t,e){return it(()=>{let s=jt(t);if(s.shape.length!==5)throw new W(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,l,c;this.dataFormat==="channelsFirst"?(c=2,o=3,l=4):(c=1,o=2,l=3);const h=i[c],d=i[o],p=i[l],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],S=this.strides[2],T=er(h,x,m,this.padding),k=er(d,w,y,this.padding),$=er(p,S,b,this.padding),E=[r,T,k,$,this.filters];this.dataFormat!=="channelsLast"&&(s=oe(s,[0,2,3,4,1]));let N=o8(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=oe(N,[0,4,1,2,3])),this.bias!==null&&(N=Gi(N,this.bias.read(),this.dataFormat)),this.activation!==null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=ce(t);const e=t.slice();let s,i,r,o;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3,o=4):(s=4,i=1,r=2,o=3);const l=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],p=this.strides[1],m=this.strides[2];return e[s]=this.filters,e[i]=er(e[i],d,l,this.padding),e[r]=er(e[r],p,c,this.padding),e[o]=er(e[o],m,h,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}qM.className="Conv3DTranspose";xt(qM);class KM extends Qc{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new W("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new W("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new W(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Be(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ve(e.depthwiseRegularizer),this.depthwiseConstraint=vn(e.depthwiseConstraint),this.pointwiseInitializer=Be(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ve(e.pointwiseRegularizer),this.pointwiseConstraint=vn(e.pointwiseConstraint)}build(t){if(t=ce(t),t.length<this.rank+2)throw new W(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new W(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const s=t[e],i=this.kernelSize.concat([s,this.depthMultiplier]),r=[];for(let l=0;l<this.rank;++l)r.push(1);r.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new bn({ndim:this.rank+2,axes:{[e]:s}})],this.built=!0}call(t,e){return it(()=>{t=jt(t);let s;if(this.rank===1)throw new Kt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=oe(t,[0,2,3,1])),s=PD(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Gi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=oe(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ge(this.depthwiseInitializer),t.pointwiseInitializer=Ge(this.pointwiseInitializer),t.depthwiseRegularizer=Ne(this.depthwiseRegularizer),t.pointwiseRegularizer=Ne(this.pointwiseRegularizer),t.depthwiseConstraint=xn(this.depthwiseConstraint),t.pointwiseConstraint=xn(this.pointwiseConstraint),t}}KM.className="SeparableConv";class XM extends KM{constructor(t){super(2,t)}}XM.className="SeparableConv2D";xt(XM);class $y extends Qc{constructor(t){super(1,t),$y.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!ZS(t.kernelSize,"number",1,1))throw new W(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}$y.className="Conv1D";xt($y);class YM extends Qt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return it(()=>{if(t=jt(t),this.dataFormat==="channelsLast"){const s=Kp(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Kp(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=Kp(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Kp(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}YM.className="Cropping2D";xt(YM);class JM extends Qt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,sn(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,zJ(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],s=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,s]}else{const e=t[1]==null?null:this.size[0]*t[1],s=t[2]==null?null:this.size[1]*t[2];return[t[0],e,s,t[3]]}}call(t,e){return it(()=>{let s=jt(t);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=oe(s,[0,2,3,1]);const r=this.size[0]*i[2],o=this.size[1]*i[3],l=this.interpolation==="nearest"?Br.resizeNearestNeighbor(s,[r,o]):Br.resizeBilinear(s,[r,o]);return oe(l,[0,3,1,2])}else{const r=this.size[0]*i[1],o=this.size[1]*i[2];return this.interpolation==="nearest"?Br.resizeNearestNeighbor(s,[r,o]):Br.resizeBilinear(s,[r,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}JM.className="UpSampling2D";xt(JM);function dQ(n,t,e=[1,1],s="valid",i,r){return it(()=>{i==null&&(i=Ui()),sn(i);let o=dC(n,i);if(n.rank!==4)throw new W(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new W(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Q1(o,t,e,s==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(o=oe(o,[0,3,1,2])),o})}class ZM extends ky{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Be(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=vn(t.depthwiseConstraint),this.depthwiseRegularizer=Ve(t.depthwiseRegularizer)}build(t){if(t=ce(t),t.length<4)throw new W(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new W(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const s=t[e],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return it(()=>{t=jt(t);let s=dQ(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Gi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=ce(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,r=Bi(e,this.kernelSize[0],this.padding,this.strides[0]),o=Bi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],i,r,o]:[t[0],r,o,i]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ge(this.depthwiseInitializer),t.depthwiseRegularizer=Ne(this.depthwiseRegularizer),t.depthwiseConstraint=xn(this.depthwiseRegularizer),t}}ZM.className="DepthwiseConv2D";xt(ZM);function QM(n,t,e,s){if(Array.isArray(n)){if(t!=null||e!=null)throw new W("When inputs is an array, neither initialState or constants should be provided");s!=null&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return t=i(t),e=i(e),{inputs:n,initialState:t,constants:e}}function tF(n,t,e,s=!1,i,r,o=!1,l=!1){return it(()=>{const c=t.shape.length;if(c<3)throw new W(`Input should be at least 3D, but is ${c}D.`);const h=[1,0].concat(Vi(2,c));t=oe(t,h),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=$t($t(i,"bool"),"float32"),i.rank===c-1&&(i=us(i,-1)),i=oe(i,h)),s&&(t=tl(t,0),i!=null&&(i=tl(i,0)));const d=[];let p,m=e;const y=t.shape[0],b=el(t);let x;i!=null&&(x=el(i));for(let S=0;S<y;++S){const T=b[S],k=it(()=>n(T,m));if(i==null)p=k[0],m=k[1];else{const $=it(()=>{const E=x[S],N=Bt(bi(E),E),_=wt(Y(k[0],E),Y(m[0],N)),R=m.map((D,M)=>wt(Y(k[1][M],E),Y(D,N)));return{output:_,newStates:R}});p=$.output,m=$.newStates}l&&d.push(p)}let w;return l&&(w=Gr(d,1)),[p,w,m]})}class Jo extends Qt{constructor(t){super(t);let e;if(t.cell==null)throw new W("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new mC({cells:t.cell}):e=t.cell,e.stateSize==null)throw new W("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new bn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Vi(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Qv(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const s=e[0];let i;if(this.returnSequences?i=[t[0],t[1],s]:i=[t[0],s],this.returnState){const r=[];for(const o of e)r.push([t[0],o]);return[i].concat(r)}else return i}computeMask(t,e){return it(()=>{Array.isArray(e)&&(e=e[0]);const s=this.returnSequences?e:null;if(this.returnState){const i=this.states.map(r=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let s=0;s<t;++s)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Kt("Constants support is not implemented in RNN yet.");Qv(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new bn({shape:[e,null,...s]});const i=[t[0]].concat(t.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!me(this.stateSpec.map(o=>o.shape[o.shape.length-1]),r))throw new W(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(o=>new bn({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){it(()=>{if(!this.stateful)throw new Qi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new W("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>In([s,i])):this.states_=[In([s,this.cell.stateSize])];else if(t==null)Yt(this.states_),this.keptStates!=null&&(Yt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>In([s,i])):this.states_[0]=In([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new W(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Yt(this.states_);for(let i=0;i<this.states_.length;++i){const r=t[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[s,o];if(!me(r.shape,l))throw new W(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>or(i.clone()))})}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const r=QM(t,s,i,this.numConstants);t=r.inputs,s=r.initialState,i=r.constants;let o=[],l=[];if(s!=null){e.initialState=s,o=o.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new bn({shape:h.shape}));l=l.concat(this.stateSpec)}if(i!=null&&(e.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof pr){const h=[t].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return it(()=>{const s=e==null?null:e.mask,i=e==null?null:e.training;let r=e==null?null:e.initialState;t=jt(t),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new W(`RNN Layer has ${o} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:i},h=tF((b,x)=>{const w=this.cell.call([b].concat(x),l);return[w[0],w.slice(1)]},t,r,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],p=h[1],m=h[2];this.stateful&&this.resetStates(m,i);const y=this.returnSequences?p:d;return this.returnState?[y].concat(m):y})}getInitialState(t){return it(()=>{let e=In(t.shape);return e=Mt(e,[1,2]),e=lf(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?Jv(e,[1,s]):e):this.cell.stateSize>1?[Jv(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Jo.className&&(e.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),e)}static fromConfig(t,e,s={}){const i=e.cell,r=ur(i,s);return new t(Object.assign(e,{cell:r}))}}Jo.className="RNN";xt(Jo);class Ey extends Qt{}class fC extends Ey{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Nn(this.units,"units"),this.activation=Po(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Be(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Be(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Be(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ve(t.kernelRegularizer),this.recurrentRegularizer=Ve(t.recurrentRegularizer),this.biasRegularizer=Ve(t.biasRegularizer),this.kernelConstraint=vn(t.kernelConstraint),this.recurrentConstraint=vn(t.recurrentConstraint),this.biasConstraint=vn(t.biasConstraint),this.dropout=Lc([1,Lo([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Lc([1,Lo([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ce(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return it(()=>{if(t=t,t.length!==2)throw new W(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const i=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Bo({ones:()=>bi(t),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Bo({ones:()=>bi(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const o=this.dropoutMask,l=this.recurrentDropoutMask;o!=null?r=cr(Y(t,o),this.kernel.read()):r=cr(t,this.kernel.read()),this.bias!=null&&(r=Gi(r,this.bias.read())),l!=null&&(s=Y(s,l));let c=wt(r,cr(s,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:Ge(this.kernelInitializer),recurrentInitializer:Ge(this.recurrentInitializer),biasInitializer:Ge(this.biasInitializer),kernelRegularizer:Ne(this.kernelRegularizer),recurrentRegularizer:Ne(this.recurrentRegularizer),biasRegularizer:Ne(this.biasRegularizer),activityRegularizer:Ne(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),recurrentConstraint:xn(this.recurrentConstraint),biasConstraint:xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}fC.className="SimpleRNNCell";xt(fC);class eF extends Jo{constructor(t){t.cell=new fC(t),super(t)}call(t,e){return it(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}static fromConfig(t,e){return new t(e)}}eF.className="SimpleRNN";xt(eF);class pC extends Ey{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new W("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Nn(this.units,"units"),this.activation=Po(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Po(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Be(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Be(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Be(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ve(t.kernelRegularizer),this.recurrentRegularizer=Ve(t.recurrentRegularizer),this.biasRegularizer=Ve(t.biasRegularizer),this.kernelConstraint=vn(t.kernelConstraint),this.recurrentConstraint=vn(t.recurrentConstraint),this.biasConstraint=vn(t.biasConstraint),this.dropout=Lc([1,Lo([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Lc([1,Lo([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ce(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return it(()=>{if(t=t,t.length!==2)throw new W(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training==null?!1:e.training;let i=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Bo({ones:()=>bi(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Bo({ones:()=>bi(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,h;0<this.dropout&&this.dropout<1&&(t=Y(t,r[0]));let d=cr(t,this.kernel.read());this.useBias&&(d=Gi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=Y(i,o[0]));const p=this.recurrentKernel.read(),[m,y]=qs(p,[2*this.units,this.units],p.rank-1),b=cr(i,m),[x,w,S]=qs(d,3,d.rank-1),[T,k]=qs(b,2,b.rank-1);l=this.recurrentActivation.apply(wt(x,T)),c=this.recurrentActivation.apply(wt(w,k));const $=cr(Y(c,i),y);h=this.activation.apply(wt(S,$));const E=wt(Y(l,i),Y(wt(1,tn(l)),h));return[E,E]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ge(this.kernelInitializer),recurrentInitializer:Ge(this.recurrentInitializer),biasInitializer:Ge(this.biasInitializer),kernelRegularizer:Ne(this.kernelRegularizer),recurrentRegularizer:Ne(this.recurrentRegularizer),biasRegularizer:Ne(this.biasRegularizer),activityRegularizer:Ne(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),recurrentConstraint:xn(this.recurrentConstraint),biasConstraint:xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}pC.className="GRUCell";xt(pC);class nF extends Jo{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new pC(t),super(t)}call(t,e){return it(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}nF.className="GRU";xt(nF);class Iy extends Ey{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Nn(this.units,"units"),this.activation=Po(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Po(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Be(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Be(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Be(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ve(t.kernelRegularizer),this.recurrentRegularizer=Ve(t.recurrentRegularizer),this.biasRegularizer=Ve(t.biasRegularizer),this.kernelConstraint=vn(t.kernelConstraint),this.recurrentConstraint=vn(t.recurrentConstraint),this.biasConstraint=vn(t.biasConstraint),this.dropout=Lc([1,Lo([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Lc([1,Lo([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=ce(t);const s=t[t.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,o=this.units;i=new(e=class extends vi{apply(c,h){const d=r.apply([o]),p=new tC().apply([o]),m=r.apply([o*2]);return yN(yN(d,p),m)}},e.className="CustomInit",e)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return it(()=>{const s=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new W(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let i=t[1];const r=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Bo({ones:()=>bi(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Bo({ones:()=>bi(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,l=this.recurrentDropoutMask;let c,h,d,p;0<this.dropout&&this.dropout<1&&(t=Y(t,o[0]));let m=cr(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=Y(i,l[0])),m=wt(m,cr(i,this.recurrentKernel.read())),this.useBias&&(m=Gi(m,this.bias.read()));const[y,b,x,w]=qs(m,4,m.rank-1);c=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=wt(Y(h,r),Y(c,this.activation.apply(x))),p=this.recurrentActivation.apply(w);const S=Y(p,this.activation.apply(d));return[S,S,d]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:zo(this.activation),recurrentActivation:zo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ge(this.kernelInitializer),recurrentInitializer:Ge(this.recurrentInitializer),biasInitializer:Ge(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ne(this.kernelRegularizer),recurrentRegularizer:Ne(this.recurrentRegularizer),biasRegularizer:Ne(this.biasRegularizer),activityRegularizer:Ne(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),recurrentConstraint:xn(this.recurrentConstraint),biasConstraint:xn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}Iy.className="LSTMCell";xt(Iy);class sF extends Jo{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Iy(t),super(t)}call(t,e){return it(()=>{this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}sF.className="LSTM";xt(sF);class mC extends Ey{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return it(()=>{t=t;let s=t.slice(1);const i=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?i.push(s.splice(0,l.stateSize.length)):i.push(s.splice(0,1));i.reverse();const r=[];let o;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=i[l],l===0?o=[t[0]].concat(s):o=[o[0]].concat(s),o=c.call(o,e),r.push(o.slice(1))}s=[];for(const l of r.slice().reverse())s.push(...l);return[o[0]].concat(s)})}build(t){Qv(t)&&(t=t[0]),t=t;let e;this.cells.forEach((s,i)=>{Ua(`RNNCell_${i}`,()=>{s.build(t),Array.isArray(s.stateSize)?e=s.stateSize[0]:e=s.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),i)}static fromConfig(t,e,s={}){const i=[];for(const r of e.cells)i.push(ur(r,s));return new t({cells:i})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return tw(t)}setWeights(t){const e=[];for(const s of this.cells){const i=s.weights.length,r=t.splice(i);for(let o=0;o<s.weights.length;++o)e.push([s.weights[o],r[o]])}aC(e)}}mC.className="StackedRNNCells";xt(mC);function Bo(n){const{ones:t,rate:e,training:s=!1,count:i=1,dropoutFunc:r}=n,o=()=>r!=null?r(t(),e):KO(t(),e),l=()=>uf(o,t,s);return!i||i<=1?or(l().clone()):Array(i).fill(void 0).map(l).map(h=>or(h.clone()))}var fQ=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)t.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(e[s[i]]=n[s[i]]);return e};class iF extends Jo{constructor(t){if(t.unroll)throw new Kt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Kt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new bn({ndim:5})]}call(t,e){return it(()=>{if(this.cell.dropoutMask!=null&&(Yt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new W("ConvRNN2D cell does not support constants");const s=e==null?null:e.mask,i=e==null?null:e.training,r=e==null?null:e.initialState;return super.call(t,{mask:s,training:i,initialState:r})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return it(()=>{const{stateSize:e}=this.cell,s=t.shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)],o=In(r);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){it(()=>{if(!this.stateful)throw new Qi("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)];if(s[0]==null)throw new W("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>In(r)):this.states_=[In(r)];else if(t==null)Yt(this.states_),this.keptStates!=null&&(Yt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>In(r)):this.states_[0]=In(r);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new W(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Yt(this.states_);for(let l=0;l<this.states_.length;++l){const c=t[l],h=r;if(!me(c.shape,h))throw new W(`State ${l} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>or(l.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:i,padding:r,strides:o,dilationRate:l}=this.cell,c=e==="channelsFirst",h=t[c?3:2],d=t[c?4:3],p=Bi(h,i[0],r,o[0],l[0]),m=Bi(d,i[1],r,o[1],l[1]);return[...t.slice(0,2),...c?[s,p,m]:[p,m,s]]}}iF.className="ConvRNN2D";class gC extends Iy{constructor(t){const{filters:e,kernelSize:s,strides:i,padding:r,dataFormat:o,dilationRate:l}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,Nn(this.filters,"filters"),this.kernelSize=Nc(s,2,"kernelSize"),this.kernelSize.forEach(c=>Nn(c,"kernelSize")),this.strides=Nc(i||1,2,"strides"),this.strides.forEach(c=>Nn(c,"strides")),this.padding=r||"valid",Ys(this.padding),this.dataFormat=o||"channelsLast",sn(this.dataFormat),this.dilationRate=Nc(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Nn(c,"dilationRate"))}build(t){var e;t=ce(t);const s=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[s]==null)throw new W(`The channel dimension of the input should be defined. Found ${t[s]}`);const i=t[s],r=4,o=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;c=new(e=class extends vi{apply(m,y){const b=h.apply([d]),x=Xo([d]),w=h.apply([d*2]);return QS([b,x,w])}},e.className="CustomInit",e)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return it(()=>{if(t.length!==3)throw new W(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=e.training||!1,i=t[0],r=t[1],o=t[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Bo({ones:()=>bi(i),rate:this.dropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,h=(st,L,j)=>!L||!L[j]?st:Y(L[j],st);let d=h(i,c,0),p=h(i,c,1),m=h(i,c,2),y=h(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Bo({ones:()=>bi(r),rate:this.recurrentDropout,training:s,count:l,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(r,b,0),w=h(r,b,1),S=h(r,b,2),T=h(r,b,3);const k=3,[$,E,N,_]=qs(this.kernel.read(),l,k),[R,D,M,A]=this.useBias?qs(this.bias.read(),l):[null,null,null,null];d=this.inputConv(d,$,R,this.padding),p=this.inputConv(p,E,D,this.padding),m=this.inputConv(m,N,M,this.padding),y=this.inputConv(y,_,A,this.padding);const[B,H,J,X]=qs(this.recurrentKernel.read(),l,k);x=this.recurrentConv(x,B),w=this.recurrentConv(w,H),S=this.recurrentConv(S,J),T=this.recurrentConv(T,X);const z=this.recurrentActivation.apply(wt(d,x)),P=this.recurrentActivation.apply(wt(p,w)),V=wt(Y(P,o),Y(z,this.activation.apply(wt(m,S)))),K=Y(this.recurrentActivation.apply(wt(y,T)),this.activation.apply(V));return[K,K,V]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=fQ(t,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(t,e,s,i){const r=Za(t,e,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Gi(r,s,this.dataFormat):r}recurrentConv(t,e){return Za(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}gC.className="ConvLSTM2DCell";xt(gC);class rF extends iF{constructor(t){const e=new gC(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}rF.className="ConvLSTM2D";xt(rF);class yC extends Qt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?e[i]:this.noiseShape[i]);return s}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t);if(0<this.rate&&this.rate<1){const i=e.training==null?!1:e.training,r=this.getNoiseShape(s);return uf(()=>KO(s,this.rate,r,this.seed),()=>s,i)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}yC.className="Dropout";xt(yC);class oF extends yC{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}oF.className="SpatialDropout1D";xt(oF);class aF extends Qt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,Nn(this.units,"units"),this.activation=Po(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Be(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Be(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=vn(t.kernelConstraint),this.biasConstraint=vn(t.biasConstraint),this.kernelRegularizer=Ve(t.kernelRegularizer),this.biasRegularizer=Ve(t.biasRegularizer),this.activityRegularizer=Ve(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=ce(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=ce(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t),i=VO(this.activation.getClassName());let r;return i!=null?r=cr(s,this.kernel.read(),i,this.bias?this.bias.read():null):(r=cr(s,this.kernel.read()),this.bias!=null&&(r=Gi(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const t={units:this.units,activation:zo(this.activation),useBias:this.useBias,kernelInitializer:Ge(this.kernelInitializer),biasInitializer:Ge(this.biasInitializer),kernelRegularizer:Ne(this.kernelRegularizer),biasRegularizer:Ne(this.biasRegularizer),activityRegularizer:Ne(this.activityRegularizer),kernelConstraint:xn(this.kernelConstraint),biasConstraint:xn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}aF.className="Dense";xt(aF);class lF extends Qt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ce(t);for(const e of t.slice(1))if(e==null)throw new W(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Do(t,1)]}call(t,e){return it(()=>{this.invokeCallHook(t,e);let s=jt(t);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let r=2;r<s.rank;++r)i.push(r);i.push(1),s=oe(s,i)}return GJ(s)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}lF.className="Flatten";xt(lF);class cF extends Qt{constructor(t){super(t),this.supportsMasking=!0,this.activation=Po(t.activation)}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t);return this.activation.apply(s)})}getConfig(){const t={activation:zo(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}cF.className="Activation";xt(cF);class uF extends Qt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return it(()=>(t=jt(t),UJ(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}uF.className="RepeatVector";xt(uF);class hF extends Qt{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const s="Total size of new array must be unchanged.",i=e.slice();let r=1,o=null;for(let c=0;c<i.length;++c){const h=i[c];if(this.isUnknown(h))if(o===null)o=c;else throw new W("Can only specifiy one unknown dimension.");else r*=h}const l=Do(t);if(o!==null){if(r===0||l%r!==0)throw new W(s);i[o]=l/r}else if(l!==r)throw new W(s);return i}computeOutputShape(t){let e=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t),i=s.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return tt(s,r)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}hF.className="Reshape";xt(hF);class dF extends Qt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=Vi(1,t.dims.length+1);if(!me(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new bn({ndim:this.dims.length+1})]}computeOutputShape(t){t=ce(t);const e=t.slice();return this.dims.forEach((s,i)=>{e[i+1]=t[s]}),e}call(t,e){return oe(jt(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}dF.className="Permute";xt(dF);class fF extends Qt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const s=jt(t);return Gv(Om(s,this.maskValue),-1)}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t),o=Gv(Om(s,this.maskValue),-1,!0);return Y(s,$t(o,s.dtype))})}}fF.className="Masking";xt(fF);class pF extends Qt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(ve(t.inputLength))}this.inputDim=t.inputDim,Nn(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Nn(this.outputDim,"outputDim"),this.embeddingsInitializer=Be(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ve(t.embeddingsRegularizer),this.activityRegularizer=Ve(t.activityRegularizer),this.embeddingsConstraint=vn(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return it(()=>this.maskZero?(t=jt(t),Om(t,ae(t))):null)}computeOutputShape(t){if(t=ce(t),this.inputLength==null)return[...t,this.outputDim];const e=ve(this.inputLength);if(e.length!==t.length-1)throw new W(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let i=0;i<e.length;++i){const r=e[i],o=t[i+1];if(r!=null&&o!=null&&r!==o)throw new W(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);r==null&&(e[s]=o),s++}}return[t[0],...e,this.outputDim]}call(t,e){return it(()=>{this.invokeCallHook(t,e);let s=jt(t);s.dtype!=="int32"&&(s=lr(s,"int32"));const i=qO(this.embeddings.read(),tt(s,[s.size]));return tt(i,ce(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ge(this.embeddingsInitializer),embeddingsRegularizer:Ne(this.embeddingsRegularizer),activityRegularizer:Ne(this.activityRegularizer),embeddingsConstraint:xn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}pF.className="Embedding";xt(pF);class hl extends Qt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Kt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const s=t.slice(0,t.length-e.length);for(let i=0;i<e.length;++i){const r=t[t.length-e.length+i],o=e[i];if(r==null||o==null||r<0||o<0)s.push(null);else if(r===1)s.push(o);else if(o===1)s.push(r);else{if(r!==o)throw new W("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(r)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ce(t)]),t=t,t.length<2)throw new W(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const r of t)r!=null&&r[0]!==null&&e.push(r[0]);if(e=Ro(e),e.length>1)throw new W(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=t[0]==null?null:t[0].slice(1);for(let r=1;r<t.length;++r){const o=t[r]==null?null:t[r].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const i=t.map(r=>r.length);t.indexOf(null)===-1&&Ro(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return it(()=>{if(t=t,this.reshapeRequired){const s=[],i=t.map(r=>r.rank);if(i.indexOf(null)===-1){const r=Lo(i);for(let o of t){const l=o.rank;for(let c=0;c<r-l;++c)o=lf(o,1);s.push(o)}return this.mergeFunction(s)}else{let r=!1;for(const c of t){const h=c.rank;if(h==null){const d=c.shape,p=d[0],m=d.slice(1).concat([p]);let y=tt(c,[p].concat(Do(d.slice(1))));y=oe(y,[1,0]),y=tt(y,m),s.push(y),r=!0}else if(h>1){const d=Vi(1,h).concat([0]);s.push(oe(c,d)),r=!0}else s.push(c)}let o=this.mergeFunction(s);const l=o.rank;if(r){if(l==null){const c=o.shape,h=c.length,d=c[h-1],p=[d].concat(c.slice(0,c.length-1));o=tt(oe(tt(o,[-1,d]),[1,0]),p)}else if(l>1){const c=[l-1].concat(Vi(0,l-1));o=oe(o,c)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let i=1;i<t.length;++i){const r=t[i]==null?null:t[i].slice(1);e=this.computeElementwiseOpOutputShape(e,r)}let s=[];for(const i of t)i!=null&&i[0]!==null&&s.push(i[0]);return s=Ro(s),s.length===1?e=s.concat(e):e=[null].concat(e),e}computeMask(t,e){return it(()=>{if(e==null)return null;if(!Array.isArray(e))throw new W("`mask` should be an Array");if(!Array.isArray(t))throw new W("`inputs` should be an Array");if(e.length!==t.length)throw new W(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(i=>i==null))return null;e=e.map(i=>i==null?i:us(i,0));let s=e[0];for(let i=1;i<e.length-1;++i)s=jr(s,e[i]);return s})}}class mF extends hl{constructor(t){super(t)}mergeFunction(t){return it(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=wt(e,t[s]);return e})}}mF.className="Add";xt(mF);class gF extends hl{constructor(t){super(t)}mergeFunction(t){return it(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=Y(e,t[s]);return e})}}gF.className="Multiply";xt(gF);class yF extends hl{constructor(t){super(t)}mergeFunction(t){return it(()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=wt(e,t[s]);return Y(1/t.length,e)})}}yF.className="Average";xt(yF);class bF extends hl{constructor(t){super(t)}mergeFunction(t){return it(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=Ko(e,t[s]);return e})}}bF.className="Maximum";xt(bF);class xF extends hl{constructor(t){super(t)}mergeFunction(t){return it(()=>{let e=t[0];for(let s=1;s<t.length;++s)e=zh(e,t[s]);return e})}}xF.className="Minimum";xt(xF);class vF extends hl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new W("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const i of t)if(i!=null){e=!1;break}if(e)return;const s=[];for(let i=0;i<t.length;++i){const r=t[i].slice();r.splice(this.axis,1);let o=!1;for(const l of s)if(me(l,r)){o=!0;break}o||s.push(r)}if(s.length>1)throw new W("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return it(()=>QS(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new W("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const r of e.slice(1)){if(s[i]==null||r[i]==null){s[i]=null;break}s[i]+=r[i]}return s}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new W("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new W("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new W(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return it(()=>{let s=!0;if(e.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const i=[];for(let o=0;o<t.length;++o)e[o]==null?i.push($t(bi(t[o]),"bool")):e[o].rank<t[o].rank?i.push(us(e[o],-1)):i.push(e[o]);const r=fs(i,this.axis);return xD(r,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}vF.className="Concatenate";xt(vF);function oh(n,t){for(;n<0;)n+=t;return n}function pQ(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Kt("batchDot is not implemented for tensors of 4D or higher rank yet");if(F(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),F(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Kt("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=t.shape.length;e==null&&(e=[s-1,i-2]);const r=e;return it(()=>{let o;if(s>i){o=s-i;const c=[];for(let h=0;h<o;++h)c.push(1);t=tt(t,t.shape.concat(c))}else if(i>s){o=i-s;const c=[];for(let h=0;h<o;++h)c.push(1);n=tt(n,n.shape.concat(c))}else o=0;let l;if(n.shape.length===2&&t.shape.length===2)r[0]===r[1]?l=Mt(Y(n,t),r[0]):l=Mt(Y(oe(n,[1,0]),t),r[1]);else{const c=r[0]!==n.shape.length-1,h=r[1]===t.shape.length-1;l=fe(n,t,c,h)}if(o>0){let c;s>i?c=s+i-3:c=s-1;const h=[];for(let d=c;d<c+o;++d)h.push(d);l=ef(l,h)}return l.shape.length===1&&(l=us(l,1)),l})}class wF extends hl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){F(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new Kt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);if(e[i[0]]!==s[i[1]])throw new W(`Dimension incompatibility: ${e[i[0]]} !== ${s[i[1]]}`)}mergeFunction(t){if(t.length!==2)throw new W(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],s=t[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,o)=>oh(r,t[o].shape.length)):i=[oh(this.axes,e.shape.length),oh(this.axes,s.shape.length)],this.normalize&&(e=Vm(e,i[0]),s=Vm(s,i[1])),pQ(e,s,i)}interpretAxes(t,e){let s;return Array.isArray(this.axes)?s=this.axes:s=[oh(this.axes,t.length),oh(this.axes,e.length)],s}computeOutputShape(t){F(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new Kt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);e.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=e.concat(s);return r.length===1&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}wF.className="Dot";xt(wF);class SF extends Qt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t);return uf(()=>wt(wy(s.shape,0,this.stddev),s),()=>s,e.training||!1)})}}SF.className="GaussianNoise";xt(SF);class CF extends Qt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return it(()=>{this.invokeCallHook(t,e);const s=jt(t);return this.rate>0&&this.rate<1?uf(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return Y(s,wy(s.shape,1,r))},()=>s,e.training||!1):s})}}CF.className="GaussianDropout";xt(CF);class TF extends Qt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||jt(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return it(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return uf(()=>{const r=jt(t),l=-1.6732632423543772*1.0507009873554805;let c=al(tf(s),this.rate);c=lr(c,"float32");const h=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-h*l*this.rate,p=wt(Y(r,c),Y(wt(c,-1),l));return wt(Y(p,h),d)},()=>jt(t),e.training||!1)}return t})}}TF.className="AlphaDropout";xt(TF);function jh(n,t,e,s,i,r=.001){let o;if(n.rank===2)o=Dq(n,t,e,s,i,r);else if(n.rank===3)o=Mq(n,t,e,s,i,r);else if(n.rank===4)o=Lq(n,t,e,s,i,r);else throw new Kt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function mQ(n,t,e,s,i=.001){return it(()=>{const r=oS(n,s),o=r.mean,l=r.variance;return[jh(n,o,l,e,t,i),o,l]})}function gQ(n,t,e,s,i=.001){return it(()=>{const r=oS(n,s),o=r.mean,l=r.variance,c=[];for(const b of Vi(0,n.rank))s.indexOf(b)!==-1?c.push(1):c.push(n.shape[b]);const h=tt(o,c),d=tt(l,c),p=t==null?null:tt(t,c),m=e==null?null:tt(e,c);return[jh(n,h,d,m,p,i),o,l]})}function yQ(n,t,e,s,i=.001){return me(s.slice().sort(),Vi(0,n.rank-1))?mQ(n,t,e,s,i):gQ(n,t,e,s,i)}class kF extends Qt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Be(t.betaInitializer||"zeros"),this.gammaInitializer=Be(t.gammaInitializer||"ones"),this.movingMeanInitializer=Be(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Be(t.movingVarianceInitializer||"ones"),this.betaConstraint=vn(t.betaConstraint),this.gammaConstraint=vn(t.gammaConstraint),this.betaRegularizer=Ve(t.betaRegularizer),this.gammaRegularizer=Ve(t.gammaRegularizer)}build(t){t=ce(t);const e=this.axis>=0?this.axis:this.axis+t.length,s=t[e];if(s==null)throw new W(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new bn({ndim:t.length,axes:{[e]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return it(()=>{const s=e.training==null?!1:e.training,i=jt(t),r=i.shape,o=r.length,l=Vi(0,o),c=this.axis>=0?this.axis:this.axis+o;l.splice(c,1);const h=nl(1,o);h[c]=r[c];const d=l.slice();d.sort();const p=!me(d,Vi(0,o).slice(0,o-1)),m=()=>{if(p){const T=tt(this.movingMean.read(),h),k=tt(this.movingVariance.read(),h),$=this.center?tt(this.beta.read(),h):null,E=this.scale?tt(this.gamma.read(),h):null;return jh(i,T,k,$,E,this.epsilon)}else return jh(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=yQ(i,this.gamma.read(),this.beta.read(),l,this.epsilon),w=(T,k,$)=>{it(()=>{const E=1-$,N=T.read(),_=Y(Bt(N,k),E);T.write(Bt(N,_))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ge(this.betaInitializer),gammaInitializer:Ge(this.gammaInitializer),movingMeanInitializer:Ge(this.movingMeanInitializer),movingVarianceInitializer:Ge(this.movingVarianceInitializer),betaRegularizer:Ne(this.betaRegularizer),gammaRegularizer:Ne(this.gammaRegularizer),betaConstraint:xn(this.betaConstraint),gammaConstraint:xn(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}kF.className="BatchNormalization";xt(kF);class $F extends Qt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Be(t.betaInitializer||"zeros"),this.gammaInitializer=Be(t.gammaInitializer||"ones"),this.betaRegularizer=Ve(t.betaRegularizer),this.gammaRegularizer=Ve(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=ce(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=e);for(const r of this.axis)if(r<0||r>=e)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Ro(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(r=>t[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(t,e){const s=jt(t),i=s.shape,r=i.length;return it(()=>{let{mean:l,variance:c}=oS(s,this.axis,!0);const h=nl(1,r);for(const x of this.axis)h[x]=i[x];const d=x=>x!=null&&x.shape.length!==r?tt(x,h):x;let p=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<r;++x)this.axis.indexOf(x)!==-1?(y.push(i[x]),b.push(1)):(y.push(1),b.push(i[x]));return l=Li(l,y),c=Li(c,y),p!=null&&(p=Li(p,b)),m!=null&&(m=Li(m,b)),jh(s,l,c,m,p,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ge(this.betaInitializer),gammaInitializer:Ge(this.gammaInitializer),betaRegularizer:Ne(this.betaRegularizer),gammaRegularizer:Ne(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}$F.className="LayerNormalization";xt($F);function bQ(n,t,e){return it(()=>{if(n.rank!==4)throw new W(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new W("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=Ui()),e!=="channelsLast"&&e!=="channelsFirst")throw new W(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return e==="channelsFirst"?s=[[0,0],[0,0],t[0],t[1]]:s=[[0,0],t[0],t[1],[0,0]],aS(n,s)})}class EF extends Qt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?Ui():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new W(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,s;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new W(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new W(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[e,s]}this.inputSpec=[new bn({ndim:4})]}computeOutputShape(t){t=ce(t);let e,s;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?s=t[3]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],t[1],e,s]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?s=t[2]+this.padding[1][0]+this.padding[1][1]:s=null,[t[0],e,s,t[3]])}call(t,e){return it(()=>bQ(jt(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}EF.className="ZeroPadding2D";xt(EF);function Ny(n,t,e,s,i,r){return it(()=>{sn(i),jO(r),Ys(s),e==null&&(e=[1,1]),s==null&&(s="valid"),i==null&&(i=Ui()),r==null&&(r="max"),n=dC(n,i);let o;const l=s==="same"?"same":"valid";return r==="max"?o=rS(n,t,e,l):o=X1(n,t,e,l),i==="channelsFirst"&&(o=oe(o,[0,3,1,2])),o})}function IF(n,t,e,s,i,r){return it(()=>{sn(i),jO(r),Ys(s),e==null&&(e=[1,1,1]),s==null&&(s="valid"),i==null&&(i=Ui()),r==null&&(r="max"),n=WM(n,i);let o;const l=s==="same"?"same":"valid";return r==="max"?o=wK(n,t,e,l):o=Cq(n,t,e,l),i==="channelsFirst"&&(o=oe(o,[0,4,1,2,3])),o})}class NF extends Qt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new W(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(Nn(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new W(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);Nn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Ys(this.padding),this.inputSpec=[new bn({ndim:3})]}computeOutputShape(t){t=ce(t);const e=Bi(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return it(()=>{this.invokeCallHook(t,e),t=lf(jt(t),2);const s=this.poolingFunction(jt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ef(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class AF extends NF{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return sn(r),Ys(i),Ny(t,e,s,i,r,"max")}}AF.className="MaxPooling1D";xt(AF);class _F extends NF{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return sn(r),Ys(i),Ny(t,e,s,i,r,"avg")}}_F.className="AveragePooling1D";xt(_F);class RF extends Qt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new W(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Nn(this.poolSize,"poolSize"),Nn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,sn(this.dataFormat),Ys(this.padding),this.inputSpec=[new bn({ndim:4})]}computeOutputShape(t){t=ce(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=Bi(e,this.poolSize[0],this.padding,this.strides[0]),s=Bi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return it(()=>(this.invokeCallHook(t,e),this.poolingFunction(jt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class DF extends RF{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return sn(r),Ys(i),Ny(t,e,s,i,r,"max")}}DF.className="MaxPooling2D";xt(DF);class OF extends RF{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return sn(r),Ys(i),Ny(t,e,s,i,r,"avg")}}OF.className="AveragePooling2D";xt(OF);class MF extends Qt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new W(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Nn(this.poolSize,"poolSize"),Nn(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,sn(this.dataFormat),Ys(this.padding),this.inputSpec=[new bn({ndim:5})]}computeOutputShape(t){t=ce(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],s=this.dataFormat==="channelsFirst"?t[3]:t[2],i=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=Bi(e,this.poolSize[0],this.padding,this.strides[0]),s=Bi(s,this.poolSize[1],this.padding,this.strides[1]),i=Bi(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,s,i]:[t[0],e,s,i,t[4]]}call(t,e){return it(()=>(this.invokeCallHook(t,e),this.poolingFunction(jt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class FF extends MF{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return sn(r),Ys(i),IF(t,e,s,i,r,"max")}}FF.className="MaxPooling3D";xt(FF);class LF extends MF{constructor(t){super(t)}poolingFunction(t,e,s,i,r){return sn(r),Ys(i),IF(t,e,s,i,r,"avg")}}LF.className="AveragePooling3D";xt(LF);class zF extends Qt{constructor(t){super(t),this.inputSpec=[new bn({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Kt}}class PF extends zF{constructor(t){super(t||{})}call(t,e){return it(()=>{const s=jt(t);return ln(s,1)})}}PF.className="GlobalAveragePooling1D";xt(PF);class BF extends zF{constructor(t){super(t||{})}call(t,e){return it(()=>{const s=jt(t);return Pi(s,1)})}}BF.className="GlobalMaxPooling1D";xt(BF);class VF extends Qt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,sn(this.dataFormat),this.inputSpec=[new bn({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Kt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class UF extends VF{call(t,e){return it(()=>{const s=jt(t);return this.dataFormat==="channelsLast"?ln(s,[1,2]):ln(s,[2,3])})}}UF.className="GlobalAveragePooling2D";xt(UF);class jF extends VF{call(t,e){return it(()=>{const s=jt(t);return this.dataFormat==="channelsLast"?Pi(s,[1,2]):Pi(s,[2,3])})}}jF.className="GlobalMaxPooling2D";xt(jF);class GF extends Qt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const i=e.layer,r=ur(i,s);delete e.layer;const o={layer:r};return Object.assign(o,e),new t(o)}}class WF extends GF{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=ce(t),t.length<3)throw new W(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=ce(t);const e=[t[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(e),i=t[1];return[s[0],i].concat(s.slice(1))}call(t,e){return it(()=>(t=jt(t),tF((o,l)=>[jt(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}WF.className="TimeDistributed";xt(WF);function xQ(n){ul(LJ,"BidirectionalMergeMode",n)}const vQ="concat";class HF extends GF{constructor(t){super(t);const e=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=e,this.forwardLayer=ur(s),e.goBackwards=e.goBackwards!==!0;const i={};if(i.className=t.layer.getClassName(),i.config=e,this.backwardLayer=ur(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?vQ:t.mergeMode,xQ(this.mergeMode),t.weights)throw new Kt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,s=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let s,i,r;return this.returnState&&(r=e.slice(1)),s=e[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[s].concat(r).concat(r.slice()):hs(i)}apply(t,e){let s=e==null?null:e.initialState,i=e==null?null:e.constants;e==null&&(e={});const r=QM(t,s,i,this.numConstants);if(t=r.inputs,s=r.initialState,i=r.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(s==null||s.length===0)&&i==null)return super.apply(t,e);const o=[],l=[];if(s!=null){const h=s.length;if(h%2>0)throw new W("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=s,o.push(...s);const d=s.map(p=>new bn({shape:p.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),l.push(...d)}if(i!=null)throw new Kt("Support for constants in Bidirectional layers is not implemented yet.");const c=o[0]instanceof pr;for(const h of o)if(h instanceof pr!==c)throw new W("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const h=[t].concat(o),d=this.inputSpec.concat(l),p=this.inputSpec;this.inputSpec=d;const m=super.apply(h,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return it(()=>{const s=e.initialState;let i,r;if(s==null)i=this.forwardLayer.call(t,e),r=this.backwardLayer.call(t,e);else{const c=s.slice(0,s.length/2),h=s.slice(s.length/2);i=this.forwardLayer.call(t,Object.assign(e,{initialState:c})),r=this.backwardLayer.call(t,Object.assign(e,{initialState:h}))}let o;this.returnState&&(Array.isArray(i)&&(o=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=tl(r,1));let l;return this.mergeMode==="concat"?l=QS([i,r]):this.mergeMode==="sum"?l=wt(i,r):this.mergeMode==="ave"?l=Y(.5,wt(i,r)):this.mergeMode==="mul"?l=Y(i,r):this.mergeMode==null&&(l=[i,r]),this.returnState?this.mergeMode==null?l.concat(o):[l].concat(o):l})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Ua(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Ua(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[e,e]:s=e:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const r=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(r).concat(r):[s].concat(r).concat(r)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const s=ur(e.layer);if(delete e.layer,e.numConstants!=null)throw new Kt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=e;return i.layer=s,new t(i)}}HF.className="Bidirectional";xt(HF);class qF extends Qt{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return it(()=>(t=jt(t),t.dtype!=="float32"&&(t=lr(t,"float32")),wt(Y(t,this.scale),this.offset)))}}qF.className="Rescaling";xt(qF);const{resizeBilinear:wQ,cropAndResize:SQ}=Br;class KF extends Qt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,s,i,r,o,l,c){return it(()=>{let h,d=!1;const p=e/o,m=s/l,y=(i+e)/o,b=(r+s)/l,x=[p,m,y,b],w=[];t.rank===3?(d=!0,h=Gr([t])):h=t;for(let E=0;E<h.shape[0];E++)w.push(x);const S=wh(w,[w.length,4]),T=Ph(0,w.length,1,"int32"),$=SQ(h,S,T,[i,r],"nearest");return lr(d?jt(el($)):$,c)})}upsize(t,e,s,i){return it(()=>{const r=wQ(t,[e,s]);return lr(r,i)})}call(t,e){return it(()=>{const s=jt(t),i=s.dtype,r=s.shape,o=r[r.length-3],l=r[r.length-2];let c=0;o!==this.height&&(c=Math.floor((o-this.height)/2));let h=0;return l!==this.width&&(h=Math.floor((l-this.width)/2),h===0&&(h=1)),c>=0&&h>=0?this.centerCrop(s,c,h,this.height,this.width,o,l,i):this.upsize(t,this.height,this.width,i)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=ce(t);const e=t.length-3,s=t.length-2;return t[e]=this.height,t[s]=this.width,t}}KF.className="CenterCrop";xt(KF);function CQ(n,t,e,s){let i=jt(n);if(i.dtype!=="int32"&&(i=lr(i,"int32")),t==="int")return i;const r=i.shape;if(i.rank===0&&(i=us(i,-1)),t==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=us(i,-1)),i.rank>2)throw new W(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${r} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(t),l=i;let c;if(typeof s<"u"&&t==="count"?c=HI(l,s,e,o):c=HI(l,[],e,o),t!=="tfIdf")return c;if(s)return Y(c,s);throw new W("When outputMode is 'tfIdf', weights must be provided.")}class XF extends Qt{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=ce(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return it(()=>{t=jt(t),t.dtype!=="int32"&&(t=lr(t,"int32"));let s;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new W(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);s=jt(e.countWeights)}const i=Pi(t),r=Rm(t),o=Xs(this.numTokens,i).bufferSync().get(0),l=al(r,0).bufferSync().get(0);if(!(o&&l))throw new W(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return CQ(t,this.outputMode,this.numTokens,s)})}}XF.className="CategoryEncoding";xt(XF);const TQ=["bilinear","nearest"],MN=new Set(TQ);class YF extends Qt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(MN.has(t.interpolation))this.interpolation=t.interpolation;else throw new W(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=ce(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return it(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Br.resizeBilinear(t,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Br.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...MN]} are supported`)})}}YF.className="Resizing";xt(YF);class JF{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}JF.className="RandomSeed";class ZF extends Qt{constructor(t){super(t),this.randomGenerator=new JF(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}ZF.className="BaseRandomLayer";const kQ=["bilinear","nearest"],FN=new Set(kQ);class QF extends ZF{constructor(t){super(t);const{factor:e,interpolation:s="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new W(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new W(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new W(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(FN.has(s))this.interpolation=s;else throw new W(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=ce(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return it(()=>{const s=jt(t);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=tf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*i;r=Math.round(r);const o=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Br.resizeBilinear(t,o);case"nearest":return Br.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...FN]} are supported`)}})}}QF.className="RandomWidth";xt(QF);const $Q=at();$Q.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var LN;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(LN||(LN={}));var zN;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(zN||(zN={}));var PN;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(PN||(PN={}));function Nt(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&F(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const EQ=qD;class Ay extends Jw{nextDataId(){return Ay.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new vR(this,Ji())}write(t,e,s){this.firstUse&&(this.firstUse=!1,at().get("IS_NODE")&&Ws(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:t,dtype:s,refCount:1}),i}makeTensorInfo(t,e,s){let i;if(e==="string"&&s!=null&&s.length>0&&td(s[0])){const r=s.map(o=>_o(o));i=this.write(r,t,e)}else i=this.write(s,t,e);return{dataId:i,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,s,i,r){this.data.set(t,{values:e,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:s}=this.data.get(t);if(e==="complex64"){const i=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return Wr(i,r)}return $6(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>Fo(i));return Jt(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Jt(t.shape,t.dtype,e)}makeOutput(t,e,s){return Ji().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=cs();return t(),{kernelMs:cs()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Nt([t],"where");const e=this.readSync(t.dataId);return EQ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Ay.nextDataId=0;function t3(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const IQ=n=>{const{x:t}=n.inputs,e=n.backend;Nt(t,"abs");let s=new Float32Array(ft(t.shape));const i=e.data.get(t.dataId).values;return s=t3(i),e.makeOutput(s,t.shape,t.dtype)},NQ={kernelName:cg,backendName:"cpu",kernelFunc:IQ};function rn(n){return(t,e,s,i,r)=>{const o=Ht(t,e),l=o.length,c=Ot(o),h=ft(o),d=Hn(r,h),p=t.length,m=e.length,y=Ot(t),b=Ot(e),x=Mc(t,o),w=Mc(e,o);if(x.length+w.length===0)for(let S=0;S<d.length;++S)d[S]=n(s[S%s.length],i[S%i.length]);else for(let S=0;S<d.length;++S){const T=qc(S,l,c),k=T.slice(-p);x.forEach(_=>k[_]=0);const $=rr(k,p,y),E=T.slice(-m);w.forEach(_=>E[_]=0);const N=rr(E,m,b);d[S]=n(s[$],i[N])}return[d,o]}}function $s(n){const{inputs:t,backend:e}=n,{real:s,imag:i}=t,r=e.data.get(s.dataId).values,o=e.data.get(i.dataId).values,l=e.makeTensorInfo(s.shape,"complex64"),c=e.data.get(l.dataId);return c.complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",r),imag:e.makeTensorInfo(i.shape,"float32",o)},l}const AQ={kernelName:h1,backendName:"cpu",kernelFunc:$s};function qm(n,t,e="float32"){if(e==="complex64"){const i=qm(n,t,"float32"),r=qm(n,t,"float32");return $s({inputs:{real:i,imag:r},backend:n})}const s=qn(ft(t),e);return n.makeTensorInfo(t,e,s)}function mr(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const _Q={kernelName:wd,backendName:"cpu",kernelFunc:mr};function sl(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.data.get(s.dataId).complexTensorInfos.real,r=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,r)}const RQ={kernelName:M1,backendName:"cpu",kernelFunc:sl};function e3(n,t,e,s){if(s==="int32"){const i=Int32Array.from(n);return[t,"int32",i]}if(s==="bool"){const i=ol([0],e),[r,o]=rn((l,c)=>l!==c?1:0)(t,[],n,i,"bool");return[o,"bool",r]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function Vo(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return mr({inputs:{x:i},backend:e});const d=qm(e,i.shape,i.dtype),p=Vo({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),m=$s({inputs:{real:p,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),m}if(i.dtype==="complex64"){const d=sl({inputs:{input:i},backend:e}),p=Vo({inputs:{x:d},backend:e,attrs:{dtype:r}});return e.disposeIntermediateTensorInfo(d),p}if(!SR(i.dtype,r)){const d=mr({inputs:{x:i},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:r}}const o=e.data.get(i.dataId).values,[l,c,h]=e3(o,i.shape,i.dtype,r);return e.makeTensorInfo(l,c,h)}const DQ={kernelName:ld,backendName:"cpu",kernelFunc:Vo};function Sn(n,t,e,s){return e==null?({inputs:i,backend:r})=>{const{a:o,b:l}=i,c=r;Nt([o,l],n);const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=o.dtype==="string"?Hr(h):h,m=o.dtype==="string"?Hr(d):d,y=s||o.dtype,[b,x]=t(o.shape,l.shape,p,m,y);return c.makeTensorInfo(x,y,b)}:({inputs:i,backend:r})=>{const{a:o,b:l}=i,c=r;if(o.dtype==="complex64"||l.dtype==="complex64"){const h=Vo({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),d=c.data.get(h.dataId),p=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=c.data.get(p.dataId).values,b=c.data.get(m.dataId).values,x=Vo({inputs:{x:l},backend:c,attrs:{dtype:"complex64"}}),w=c.data.get(x.dataId),S=w.complexTensorInfos.real,T=w.complexTensorInfos.imag,k=c.data.get(S.dataId).values,$=c.data.get(T.dataId).values,[E,N,_]=e(o.shape,l.shape,y,b,k,$),R=c.makeTensorInfo(_,"float32",E),D=c.makeTensorInfo(_,"float32",N),M=$s({inputs:{real:R,imag:D},backend:c});return c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(R),c.disposeIntermediateTensorInfo(D),M}else{const h=c.data.get(o.dataId).values,d=c.data.get(l.dataId).values,p=s||o.dtype,[m,y]=t(o.shape,l.shape,h,d,p);return c.makeTensorInfo(y,p,m)}}}function bC(n){return(t,e,s,i,r,o)=>{const l=Ht(t,e),c=ft(l),h=l.length,d=Ot(l),p=Hn("float32",c),m=Hn("float32",c),y=Mc(t,l),b=Mc(e,l),x=Wr(s,i),w=Wr(r,o),S=t.length,T=Ot(t),k=e.length,$=Ot(e);if(y.length+b.length===0)for(let E=0;E<p.length;E++){const N=E%x.length,_=E%w.length,R=n(x[N*2],x[N*2+1],w[_*2],w[_*2+1]);p[E]=R.real,m[E]=R.imag}else for(let E=0;E<p.length;E++){const N=qc(E,h,d),_=N.slice(-S);y.forEach(B=>_[B]=0);const R=rr(_,S,T),D=N.slice(-k);b.forEach(B=>D[B]=0);const M=rr(D,k,$),A=n(x[R*2],x[R*2+1],w[M*2],w[M*2+1]);p[E]=A.real,m[E]=A.imag}return[p,m,l]}}const n3=rn(((n,t)=>n+t)),OQ=bC(((n,t,e,s)=>({real:n+e,imag:t+s}))),zc=Sn(Kc,n3,OQ),MQ={kernelName:Kc,backendName:"cpu",kernelFunc:zc};function xC(n,t,e,s,i){const r=ft(s),o=qn(i,e);for(let l=0;l<n.length;l++){const c=n[l];if(c<0)throw new Error("Input x must be non-negative!");c>=i||(r>0?o[c]+=t[l]:o[c]+=1)}return o}function s3(n,t,e,s=!1){const i=n.shape[0],r=n.shape[1],o=Jt([i,e],t.dtype);for(let l=0;l<i;l++)for(let c=0;c<r;c++){const h=n.get(l,c);if(h<0)throw new Error("Input x must be non-negative!");h>=e||(s?o.set(1,l,h):t.size>0?o.set(o.get(l,h)+t.get(l,c),l,h):o.set(o.get(l,h)+1,l,h))}return o}const i3=rn(((n,t)=>n&t)),FQ=Sn(u1,i3),LQ={kernelName:u1,backendName:"cpu",kernelFunc:FQ};function yr(n){return(t,e,s)=>{const i=Qe(e,t.length);for(let r=0;r<t.length;++r)i[r]=n(t[r],s);return i}}function we(n,t,e){const s=yr(t);return Zo(n,s,e)}function Zo(n,t,e){return({inputs:s,attrs:i,backend:r})=>{const{x:o}=s;Nt(o,n);const l=r,c=l.data.get(o.dataId).values;let h;if(o.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");h=Hr(c)}else h=c;const d=e||o.dtype,p=t(h,d,i);return l.makeTensorInfo(o.shape,d,p)}}const r3=yr(n=>Math.ceil(n)),zQ=Zo(cd,r3),PQ={kernelName:cd,backendName:"cpu",kernelFunc:zQ};function o3(n,t,e,s){const i=Qe(e,ft(t));if(s&&e!=="string"){let r=0;n.forEach(o=>{const l=ft(o.shape);i.set(o.vals,r),r+=l})}else{let r=0;n.forEach(o=>{const l=e==="string"?Hr(o.vals):o.vals;let c=0;for(let h=0;h<o.shape[0];++h){const d=h*t[1]+r;for(let p=0;p<o.shape[1];++p)i[d+p]=l[c++]}r+=o.shape[1]})}return i}const a3=rn((n,t)=>n===t?1:0),l3=Sn(Tg,a3,null,"bool"),BQ={kernelName:Tg,backendName:"cpu",kernelFunc:l3};const c3=yr(n=>Math.exp(n)),u3=Zo(gd,c3,"float32"),VQ={kernelName:gd,backendName:"cpu",kernelFunc:u3};const h3=yr(n=>Math.expm1(n)),UQ=Zo(yd,h3),jQ={kernelName:yd,backendName:"cpu",kernelFunc:UQ};const d3=yr(n=>Math.floor(n)),GQ=Zo(bd,d3),WQ={kernelName:bd,backendName:"cpu",kernelFunc:GQ};const f3=rn((n,t)=>Math.floor(n/t)),HQ=Sn(xd,f3,null,"int32"),qQ={kernelName:xd,backendName:"cpu",kernelFunc:HQ};function p3(n,t,e,s,i,r,o,l,c){const h=Jt([s,r],e);for(let d=0;d<s;d++){const p=[];let m=0;for(let y=0;y<i;y++){const b=n[d*i+y];m+=b*o[y],p.push(b)}if(m<0||m>=c/r)throw new Error(`Invalid indices: ${p} does not index into ${l}`);for(let y=0;y<r;y++)h.values[d*r+y]=t.get(...t.indexToLoc(m*r+y))}return h}function m3(n,t,e){const s=Jt(e,n.dtype);for(let i=0;i<s.size;++i){const o=s.indexToLoc(i).slice(),l=o[0],c=o[2],h=t.locToIndex([l,c]);o[2]=t.values[h];const d=n.locToIndex(o);0<=d&&d<n.values.length&&(s.values[i]=n.values[d])}return s}const g3=rn((n,t)=>n>t?1:0),KQ=Sn(Ig,g3,null,"bool"),XQ={kernelName:Ig,backendName:"cpu",kernelFunc:KQ};const y3=rn((n,t)=>n>=t?1:0),YQ=Sn(vd,y3,null,"bool"),JQ={kernelName:vd,backendName:"cpu",kernelFunc:YQ};const b3=rn((n,t)=>n<t?1:0),ZQ=Sn(Ag,b3,null,"bool"),QQ={kernelName:Ag,backendName:"cpu",kernelFunc:ZQ};const x3=rn((n,t)=>n<=t?1:0),ttt=Sn(_g,x3,null,"bool"),ett={kernelName:_g,backendName:"cpu",kernelFunc:ttt};function v3(n,t,e){const s=(t-n)/(e-1),i=qn(e,"float32");i[0]=n;for(let r=1;r<i.length;r++)i[r]=i[r-1]+s;return i}const w3=yr(n=>Math.log(n)),ntt=Zo(kd,w3),stt={kernelName:kd,backendName:"cpu",kernelFunc:ntt};function S3(n,t,e,s){const i=Hn(s,ft(e));for(let r=0;r<i.length;++r){const o=r*t;let l=n[o];for(let c=0;c<t;++c){const h=n[o+c];(Number.isNaN(h)||h>l)&&(l=h)}i[r]=l}return i}const C3=rn(((n,t)=>Math.max(n,t))),itt=Sn(Ed,C3),rtt={kernelName:Ed,backendName:"cpu",kernelFunc:itt};const T3=rn(((n,t)=>Math.min(n,t))),ott=Sn(Id,T3),att={kernelName:Id,backendName:"cpu",kernelFunc:ott};const vC=rn(((n,t)=>n*t)),ltt=bC(((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e}))),_y=Sn(Ad,vC,ltt),ctt={kernelName:Ad,backendName:"cpu",kernelFunc:_y};function k3(n,t,e){const s=Go(-1,e);return vC([],t,s,n,e)}function utt(n){const{inputs:t,backend:e}=n,{x:s}=t;Nt(s,"neg");const i=e.data.get(s.dataId).values,[r,o]=k3(i,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,r)}const htt={kernelName:Ug,backendName:"cpu",kernelFunc:utt};const $3=rn(((n,t)=>n!==t?1:0)),dtt=Sn(jg,$3,null,"bool"),ftt={kernelName:jg,backendName:"cpu",kernelFunc:dtt};function wC(n,t,e,s,i){const r=t.length,o=ft(t),l=Ot(t),c=Ot(i),h=Hn(e,ft(i));for(let d=0;d<o;++d){const p=qc(d,r,l),m=new Array(p.length);for(let b=0;b<m.length;b++)m[b]=p[s[b]];const y=rr(m,r,c);h[y]=n[d]}return h}function ms(n){const{inputs:t,attrs:e,backend:s}=n,{x:i}=t,{perm:r}=e;Nt(i,"transpose");const o=i.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=i.shape[r[p]];const c=s.data.get(i.dataId).values,h=wC(c,i.shape,i.dtype,r,l);return{dataId:s.write(h,l,i.dtype),shape:l,dtype:i.dtype}}const ptt={kernelName:$c,backendName:"cpu",kernelFunc:ms};function E3(n,t,e,s){const[i,r]=An(n,s),o=Ns(t,"int32"),l=qn(ft(i),o),c=ft(r);for(let h=0;h<l.length;++h){const d=h*c;let p=1;for(let m=0;m<c;++m)p*=e[d+m];l[h]=p}return{outVals:l,outShape:i,outDtype:o}}function mtt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s;Nt(i,"prod");const l=i.shape.length,c=Zt(r,i.shape),h=We(c,l);let d=c,p=i;const m=[];h!=null&&(p=ms({inputs:{x:i},backend:e,attrs:{perm:h}}),m.push(p),d=nn(d.length,l));const y=e.data.get(p.dataId).values,{outVals:b,outShape:x,outDtype:w}=E3(p.shape,p.dtype,y,d);let S=x;return o&&(S=cn(x,c)),m.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(S,w,b)}const gtt={kernelName:Xg,backendName:"cpu",kernelFunc:mtt};function ytt(n,t,e){n.forEach((s,i)=>{if(s<0||s>=e){const r=qc(i,t.length,Ot(t)).join(",");throw new Error(`indices[${r}] = ${s} is not in [0, ${e})`)}})}function btt(n,t){for(let e=0;e<n.length;++e){const s=n[e],i=e===n.length-1?t:n[e+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<s.length;++r)if(s[r-1]>s[r])throw new Error("Ragged splits must be sorted in ascending order")}}function xtt(n,t,e,s){const i=[];let r=0;const o=t.length-1+e.length,l=new Array(o).fill(null).map(()=>[0]);btt(e,s);let c=1;for(let h=0;h<t.length-1;++h){c*=t[h];const d=t[h+1];for(let p=1;p<c+1;++p)l[h].push(p*d)}for(let h=0;h<n.length;++h){let d=n[h],p=n[h]+1;for(let m=0;m<e.length;++m){const y=e[m],b=m+t.length-1;if(b>=0){const x=l[b],w=x[x.length-1]-y[d];for(let S=d;S<p;++S)l[b].push(y[S+1]+w)}d=y[d],p=y[p]}p!==d&&(i.push([d,p]),r+=p-d)}return{outSplits:l,valueSlices:i,numValues:r}}function vtt(n){const t=[];for(let e=0;e<n.length;++e){const s=n[e].length,i=Qe("int32",s);t.push(i),n[e].forEach((r,o)=>i[o]=r)}return t}function BN(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function wtt(n,t,e,s,i,r){const o=BN(t,2)[1],l=BN(r,2)[1];let c=0;for(const h of e)for(let d=h[0];d<h[1];++d){for(let p=0;p<s;++p)i[c*l+p]=n[d*o+p];++c}}function Stt(n,t,e,s,i){const r=t.slice();r[0]=i;const o=Qe(e,ft(r)),l=n.length,c=l===0?0:l/t[0];return wtt(n,t,s,c,o,r),[o,r]}function I3(n,t,e,s,i,r,o,l){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const c=t[0][0]-1;if(ytt(r,o,c),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:p,numValues:m}=xtt(r,o,n,h),y=vtt(d),b=Stt(e,s,i,p,m);return[y,b[0],b[1]]}const VN=2147483647;function N3(n,t,e,s,i,r,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const l=t.length===0,c=i.length===0,h=o.length===0,d=[];l||d.push(t[0]),c||d.push(i[0]),h||d.push(o[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const p=d.length===0?1:d[0],m=Qe("int32",p+1);m[0]=0;for(let w=0;w<p;++w){const S=l?n[0]:n[w],T=c?s[0]:s[w],k=h?r[0]:r[w];if(k===0)throw new Error("Requires delta != 0");let $;if(k>0&&T<S||k<0&&T>S)$=0;else if($=Math.ceil(Math.abs((T-S)/k)),$>VN)throw new Error(`Requires ((limit - start) / delta) <= ${VN}`);m[w+1]=m[w]+$}const y=m[p],b=Qe(e,y);let x=0;for(let w=0;w<p;++w){const S=m[w+1]-m[w];let T=l?n[0]:n[w];const k=h?r[0]:r[w];for(let $=0;$<S;++$)b[x++]=T,T+=k}return[m,b]}var ci=Fi;class Km{constructor(t,e,s,i,r,o,l,c,h,d){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=i,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=l,this.rowPartitionValues=c,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=pO(d),this.raggedRank=mO(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ci.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ci.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ci.VALUE_ROWIDS:return Km.getMaxWidthValueRowID(e);case ci.ROW_SPLITS:return Km.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${ci[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let s=0;for(let i=0;i<e-1;++i){const r=t[i+1]-t[i];r>s&&(s=r)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let s=0,i=t[0],r=0;for(let o=1;o<e;++o){const l=t[o];l!==i&&(i=l,r=Math.max(o-s,r),s=o)}return Math.max(e-s,r)}tensorShapeFromTensor(t,e,s=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return jN(t,s)}calculateOutputSize(t){const e=this.valuesShape,s=this.defaultValueShape;gO(s,e);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=fO(this.raggedRank,i,e);o[0]<0&&(o[0]=t);for(let l=1;l<=this.raggedRank;++l)o[l]<0&&(o[l]=this.getMaxWidth(l));return o}calculateFirstParentOutputIndex(t,e,s){const i=Math.min(t,s),r=[];let o=0;for(let l=0;l<i;++l,o+=e)r.push(o);for(let l=i;l<t;++l)r.push(-1);return F(r.length===t,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(t,e,s,i){const r=t.length,o=[];for(let l=0;l<r-1;++l){const c=t[l+1]-t[l];let h=Math.min(i,c),d=e[l];d===-1&&(h=0);for(let p=0;p<h;++p)o.push(d),d+=s;for(let p=0;p<c-h;++p)o.push(-1)}if(r>0&&o.length!==t[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,s,i){const r=t.length,o=[];if(r===0)return[];let l=0,c=t[0];if(c>=e.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${e.length}`);let h=e[c];o.push(h);for(let d=1;d<r;++d){const p=t[d];if(p===c)h>=0&&(++l,l<i?h+=s:h=-1);else{if(l=0,c=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);h=e[p]}o.push(h)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,s,i){const r=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case ci.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,e,s,i);case ci.ROW_SPLITS:if(r.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(r,e,s,i);default:throw new Error(`Unsupported partition type: ${ci[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case ci.FIRST_DIM_SIZE:return t[0];case ci.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ci.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ci[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let c=i.length-2;c>=0;--c)i[c]=i[c+1]*s[c+1];const r=jN(s,!1),o=Qe(this.valuesDType,ft(r));if(i[0]*s[0]>0){let c=this.calculateFirstParentOutputIndex(e,i[0],s[0]);for(let h=1;h<=this.raggedRank;++h)c=this.calculateOutputIndex(h-1,c,i[h],s[h]);this.setOutput(this.raggedRank,c,o,r)}return[r,o]}setOutput(t,e,s,i){if(s.length===0)return;const r=this.values,o=s;let l=i.slice();l=l.slice(t+1);const c=ft(l),h=e.length;let d=this.defaultValue;if(d.length!==c&&d.length!==1){const b=this.defaultValueShape;it(()=>{const x=tt(d,b);d=Sh(x,l).dataSync()})}let p=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?e[b]:-1;if(x===y){++y;continue}if(m<y){const w=r.subarray(p*c),S=o.subarray(m*c),T=(y-m)*c;UN(S,w,T)}if(b>=h){const w=s.length;x=Math.floor(w/c)}if(x>y)if(this.defaultValue.length===1)o.subarray(y*c,x*c).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=o.slice(y*c);UN(w,d,c),++y}x<0?(p=b+1,m=y):(p=b,m=y,y=m+1)}}}function UN(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function jN(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function A3(n,t,e,s,i,r,o,l,c,h){return new Km(n,t,e,s,i,r,o,l,c,h).compute()}function _3(n,t,e,s){const i=n===t,r=n<t&&e<0,o=t<n&&e>1;if(i||r||o)return qn(0,s);const l=Math.abs(Math.ceil((t-n)/e)),c=qn(l,s);t<n&&e===1&&(e=-1),c[0]=n;for(let h=1;h<c.length;h++)c[h]=c[h-1]+e;return c}const R3=yr(n=>1/Math.sqrt(n)),Ctt=Zo(Fd,R3),Ttt={kernelName:Fd,backendName:"cpu",kernelFunc:Ctt};function Fa(n,t,e,s,i,r,o,l,c,h){const d=[s/i,i],p=n.values,m=t.values;if(s===0)return Jt(e,t.dtype);const y=c instanceof On?c:Jt(d,t.dtype);typeof c=="string"||typeof c=="number"?y.values.fill(c):typeof c=="boolean"&&y.values.fill(+c);for(let b=0;b<r;b++){const x=[];let w=0;for(let S=0;S<o;S++){const T=p[b*o+S];x.push(T),w+=T*l[S]}if(w<0||w>=s/i)throw new Error(`Invalid indices: ${x} does not index into ${e}`);for(let S=0;S<i;S++)h?y.values[w*i+S]+=m[b*i+S]:y.values[w*i+S]=t.rank===0?m[0]:m[b*i+S]}return y}const ktt=yr(n=>1/(1+Math.exp(-n))),D3=we(Vd,n=>1/(1+Math.exp(-n))),$tt={kernelName:Vd,backendName:"cpu",kernelFunc:D3};function O3(n,t,e,s,i){const r=IS(s,t,e),o=ft(e),l=Ot(s);if(r){const p=NS(t,l);return i==="string"?n.slice(p,p+o):n.subarray(p,p+o)}const c=i==="string"?Hr(n):n,h=Jt(s,i,c),d=Jt(e,i);for(let p=0;p<d.size;++p){const m=d.indexToLoc(p),y=m.map((b,x)=>b+t[x]);d.set(h.get(...y),...m)}return i==="string"?FO(d.values):d.values}function il(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,size:o}=s;Nt(i,"slice");const[l,c]=gy(i,r,o);$S(i,l,c);const h=e.data.get(i.dataId).values,d=O3(h,l,c,i.shape,i.dtype);return e.makeTensorInfo(c,i.dtype,d)}const Ett={kernelName:ey,backendName:"cpu",kernelFunc:il};function M3(n,t,e,s,i,r,o){const l=t[0],c=r[0],h=new Array(c),d=new Array(l),p=t[1];if(c===0){if(l!==0)throw new Error(CO(l));const w=Qe(e,0),S=Qe(i,0);return[w,[0,p],S,h,d]}let m=!0,y=0;const b=new Array(c).fill(0);for(let w=0;w<l;++w){const S=n[w*p];if(S<0)throw new Error(TO(w,S));if(S>=c)throw new Error(kO(w,S,c));++b[S],m=m&&S>=y,y=S}let x=!0;for(let w=0;w<c;++w){const S=b[w]===0;h[w]=S,x=x&&!S,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,S=s;for(let T=0;T<l;++T)d[T]=T;return[w,[l,p],S,h,d]}else{const w=b[c-1],S=Qe(e,w*p),T=Qe(i,w),k=new Array(c).fill(0);for(let $=0;$<l;++$){const E=n[$*p],N=k[E],_=(E===0?0:b[E-1])+N;k[E]++;for(let R=0;R<p;++R)S[_*p+R]=n[$*p+R];T[_]=s[$],d[$]=_}for(let $=0;$<c;++$)if(k[$]===0){const N=$===0?0:b[$-1];S[N*p+0]=$;for(let _=1;_<p;++_)S[N*p+_]=0;T[N]=o}return[S,[w,p],T,h,d]}}function F3(n,t,e,s,i){const r=ft(s),o=t[0],l=i.length,c=[];let h=1,d=-1;for(let w=0;w<l;++w){const S=i[w];if(S===-1){if(d!==-1)throw new Error($O(d,w));d=w,c.push(1)}else{if(S<0)throw new Error(EO(w,S));h*=S,c.push(S)}}if(d!==-1){if(h<=0)throw new Error(IO());const w=Math.trunc(r/h);if(h*w!==r)throw new Error(NO(s,c));c[d]=w}if(ft(c)!==r)throw new Error(AO(s,c));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(l>0){b[l-1]=1;for(let w=l-2;w>=0;--w)b[w]=b[w+1]*c[w+1]}const x=Qe(e,o*l);for(let w=0;w<o;++w){let S=0;for(let T=0;T<m;++T)S+=n[w*m+T]*y[T];for(let T=0;T<l;++T)x[w*l+T]=Math.trunc(S/b[T]),S%=b[T]}return[x,[o,l],c]}function SC(n,t,e,s,i,r=!1,o=0){const l=s.length,c=[t[0],n.length/t[0]],h=c[1],p=l>0?i[l-1]+1:0;if(p<0)throw new Error(Xv());const m=t.slice();m[0]=p;const y=m.reduce((k,$)=>k*$,1),b=Qe(e,y);if(l===0)return p>0&&b.fill(o),[b,m];if(p<=0)throw new Error(Xv());let x=0,w=1,S=0,T=i[x];for(;;){let k=0;if(w<l){if(k=i[w],T===k){++w;continue}if(T>=k)throw new Error(_O())}if(T<0||T>=p)throw new Error(RO(T,p));T>S&&b.fill(o,S*h,T*h);for(let $=x;$<w;++$){const E=s[$];if(E<0||E>=c[0])throw new Error(DO($,s[$],c[0]));for(let N=0;N<h;N++)b[T*h+N]+=n[E*h+N]}if(r)for(let $=0;$<h;$++)b[T*h+$]/=w-x;if(x=w,++w,S=T+1,T=k,w>l)break}return S<p&&b.fill(o,S*h,p*h),[b,m]}const Itt=yr(n=>Math.sqrt(n)),Ntt=we(jd,n=>Math.sqrt(n)),Att={kernelName:jd,backendName:"cpu",kernelFunc:Ntt};const L3=rn(((n,t)=>{const e=n-t;return e*e})),_tt=Sn(Gd,L3),Rtt={kernelName:Gd,backendName:"cpu",kernelFunc:_tt};const z3=yr((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:i}=t;return n.replace(new RegExp(e,s?"g":""),i)}),Dtt=Zo(P1,z3),Ott={kernelName:P1,backendName:"cpu",kernelFunc:Dtt};function P3(n,t,e,s){const i=Jt(n,t.dtype);for(let r=0;r<i.size;r++){const o=i.indexToLoc(r),l=new Array(o.length);for(let c=0;c<l.length;c++)l[c]=o[c]*e[c]+s[c];i.set(t.get(...l),...o)}return i}class Mtt{constructor(t,e,s,i,r,o){this.separator=_o(t),this.nGramWidths=e,this.leftPad=_o(s),this.rightPad=_o(i),this.padWidth=r,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,i,r,o){for(let l=0;l<r;++l){const c=this.getPadWidth(o),h=Math.max(0,c-l),d=Math.max(0,c-(r-(l+1))),p=o-(h+d),m=e+(h>0?0:l-c);let y=0;y+=h*this.leftPad.length;for(let T=0;T<p;++T)y+=t[m+T].length;y+=d*this.rightPad.length;const b=h+d+p-1;y+=b*this.separator.length,s[i+l]=new Uint8Array(y);const x=s[i+l];let w=0;const S=T=>T.forEach(k=>x[w++]=k);for(let T=0;T<h;++T)S(this.leftPad),S(this.separator);for(let T=0;T<p-1;++T)S(t[m+T]),S(this.separator);if(p>0){S(t[m+p-1]);for(let T=0;T<d;++T)S(this.separator),S(this.rightPad)}else{for(let T=0;T<d-1;++T)S(this.rightPad),S(this.separator);S(this.rightPad)}}}compute(t,e){const s=t.length,i=e.length;if(i>0){let c=e[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let h=1;h<i;++h){let d=e[h]>=c;if(d=d&&e[h]<=s,!d)throw new Error(`Invalid split value ${e[h]}, must be in [${c}, ${s}]`);c=e[h]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const r=i-1,o=Qe("int32",i);if(s===0||i===0){const c=new Array(s);for(let h=0;h<=r;++h)o[h]=0;return[c,o]}o[0]=0;for(let c=1;c<=r;++c){const h=e[c]-e[c-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(h,p)}),this.preserveShort&&h>0&&d===0&&(d=1),o[c]=o[c-1]+d}const l=new Array(o[r]);for(let c=0;c<r;++c){const h=e[c];let d=o[c];if(this.nGramWidths.forEach(p=>{const m=e[c+1]-e[c],y=this.getNumNGrams(m,p);this.createNGrams(t,h,l,d,y,p),d+=y}),this.preserveShort&&d===o[c]){const p=e[c+1]-e[c];if(p===0)continue;const m=p+2*this.padWidth;this.createNGrams(t,h,l,d,1,m)}}return[l,o]}}function B3(n,t,e,s,i,r,o,l){return new Mtt(e,s,i,r,o,l).compute(n,t)}function Ftt(n,t,e,s){if(!n.length)return;if(t.length===0){for(let r=0;r<n.length;++r)s.push(n.subarray(r,r+1));return}if(t.length===1){const r=t[0];let o=n.indexOf(r);for(;o!==-1;){const l=n.subarray(0,o);(!e||l.length!==0)&&s.push(l),n=n.subarray(o+1),o=n.indexOf(r)}(!e||n.length!==0)&&s.push(n);return}let i=0;for(let r=0;r<n.length+1;r++)if(r===n.length||t.indexOf(n[r])!==-1){const o=n.subarray(i,r);(!e||o.length!==0)&&s.push(o),i=r+1}}function V3(n,t,e){const s=n.length,i=[];let r=0,o=0;const l=new Array(s);for(let m=0;m<s;++m){const y=i.length;Ftt(n[m],t,e,i);const b=i.length-y;l[m]=b,r+=b,o=Math.max(o,b)}const c=Qe("int32",r*2),h=new Array(r),d=[s,o];let p=0;for(let m=0;m<s;++m)for(let y=0;y<l[m];++y)c[p*2]=m,c[p*2+1]=y,h[p]=i[p],++p;return[c,h,d]}function U3(n,t){const e=Qe("int32",n.length);for(let s=0;s<n.length;++s)e[s]=W6(n[s]).modulo(t).getLowBitsUnsigned();return e}const j3=rn(((n,t)=>n-t)),Ltt=bC(((n,t,e,s)=>({real:n-e,imag:t-s}))),CC=Sn(Wd,j3,Ltt),ztt={kernelName:Wd,backendName:"cpu",kernelFunc:CC};function G3(n,t){const e=new Array(n.rank);for(let i=0;i<e.length;i++)e[i]=n.shape[i]*t[i];const s=Jt(e,n.dtype);for(let i=0;i<s.values.length;++i){const r=s.indexToLoc(i),o=new Array(n.rank);for(let c=0;c<o.length;c++)o[c]=r[c]%n.shape[c];const l=n.locToIndex(o);s.values[i]=n.values[l]}return s}const dh=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function W3(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const l=s-e+1,c=t-e+1,h=Math.log(l),d=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*d*(l-d)/l)*Math.sign(c-l/2),m=Math.max(e,Math.floor(t-c*d/l+p)),y=Math.min(s,Math.floor(t+(l-c)*d/l+p));W3(n,t,m,y)}const i=n[t];let r=e,o=s;for(pc(n,e,t),dh(n[s],i)>0&&pc(n,e,s);r<o;){for(pc(n,r,o),r++,o--;dh(n[r],i)<0;)r=r+1;for(;dh(n[o],i)>0;)o=o-1}dh(n[e],i)===0?pc(n,e,o):(o=o+1,pc(n,o,s)),o<=t&&(e=o+1),t<=o&&(s=o-1)}}function H3(n,t,e,s,i){const r=t[t.length-1],[o,l]=[n.length/r,r],c=Hn(e,o*s),h=Hn("int32",o*s);for(let p=0;p<o;p++){const m=p*l,y=n.subarray(m,m+l);let b=new Array(y.length);y.forEach((T,k)=>b[k]={value:T,index:k}),s<b.length&&(W3(b,s),b=b.slice(0,s)),i&&b.sort(dh);const x=p*s,w=c.subarray(x,x+s),S=h.subarray(x,x+s);for(let T=0;T<s;T++)w[T]=b[T].value,S[T]=b[T].index}const d=t.slice();return d[d.length-1]=s,[Jt(d,e,c),Jt(d,"int32",h)]}function q3(n,t,e,s){const i=Zt(t,e)[0],r=[1,e[0],1];for(let b=0;b<i;b++)r[0]*=e[b];r[1]=e[i];for(let b=i+1;b<e.length;b++)r[2]*=e[b];const o=new Map,l=new Int32Array(e[i]),c=new On(r,s,n),h=[],d=r[0]===1&&r[2]===1;for(let b=0;b<e[i];b++){let x;if(d)x=n[b].toString();else{const S=[];for(let T=0;T<r[0];T++)for(let k=0;k<r[2];k++)S.push(c.get(T,b,k));x=S.join(",")}const w=o.get(x);if(w!=null)l[b]=w;else{const S=o.size;o.set(x,S),l[b]=S,h.push(b)}}const p=r.slice();p[1]=o.size;const m=new On(p,s);h.forEach((b,x)=>{for(let w=0;w<r[0];w++)for(let S=0;S<r[2];S++)m.set(c.get(w,b,S),w,x,S)});const y=e.slice();return y[i]=p[1],{outputValues:m.values,outputShape:y,indices:l}}const Ptt=Object.freeze(Object.defineProperty({__proto__:null,addImpl:n3,bincountImpl:xC,bincountReduceImpl:s3,bitwiseAndImpl:i3,castImpl:e3,ceilImpl:r3,concatImpl:o3,equalImpl:a3,expImpl:c3,expm1Impl:h3,floorDivImpl:f3,floorImpl:d3,gatherNdImpl:p3,gatherV2Impl:m3,greaterEqualImpl:y3,greaterImpl:g3,lessEqualImpl:x3,lessImpl:b3,linSpaceImpl:v3,logImpl:w3,maxImpl:S3,maximumImpl:C3,minimumImpl:T3,multiplyImpl:vC,negImpl:k3,notEqualImpl:$3,prodImpl:E3,raggedGatherImpl:I3,raggedRangeImpl:N3,raggedTensorToTensorImpl:A3,rangeImpl:_3,rsqrtImpl:R3,scatterImpl:Fa,sigmoidImpl:ktt,simpleAbsImpl:t3,sliceImpl:O3,sparseFillEmptyRowsImpl:M3,sparseReshapeImpl:F3,sparseSegmentReductionImpl:SC,sqrtImpl:Itt,squaredDifferenceImpl:L3,staticRegexReplaceImpl:z3,stridedSliceImpl:P3,stringNGramsImpl:B3,stringSplitImpl:V3,stringToHashBucketFastImpl:U3,subImpl:j3,tileImpl:G3,topKImpl:H3,transposeImpl:wC,uniqueImpl:q3},Symbol.toStringTag,{value:"Module"}));hD("cpu",()=>new Ay,1);const K3=we(pd,n=>n>=0?n:Math.exp(n)-1),Btt={kernelName:pd,backendName:"cpu",kernelFunc:K3};function X3(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:r}=s;Nt([i],"leakyRelu");const o=ft(i.shape),l=e.data.get(i.dataId).values,c=Hn("float32",o);for(let h=0;h<l.length;h++)c[h]=l[h]<0?r*l[h]:l[h];return e.makeTensorInfo(i.shape,"float32",c)}const Vtt={kernelName:Ng,backendName:"cpu",kernelFunc:X3};const Utt=rn((n,t)=>n<0?t*n:n);function Y3(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t;Nt([s,i],"prelu");const r=e.data.get(s.dataId).values,o=e.data.get(i.dataId).values,[l,c]=Utt(s.shape,i.shape,r,o,"float32");return e.makeTensorInfo(c,"float32",l)}const jtt={kernelName:Kg,backendName:"cpu",kernelFunc:Y3};const J3=we(Dd,n=>Math.max(0,n)),Gtt={kernelName:Dd,backendName:"cpu",kernelFunc:J3};const Z3=we(Od,n=>Math.min(Math.max(0,n),6)),Wtt={kernelName:Od,backendName:"cpu",kernelFunc:Z3};function Xm(n,t,e,s,i){if(e==="linear")return mr({inputs:{x:t},backend:n});if(e==="relu")return J3({inputs:{x:t},backend:n});if(e==="elu")return K3({inputs:{x:t},backend:n});if(e==="relu6")return Z3({inputs:{x:t},backend:n});if(e==="prelu")return Y3({inputs:{x:t,alpha:s},backend:n});if(e==="leakyrelu")return X3({inputs:{x:t},backend:n,attrs:{alpha:i}});if(e==="sigmoid")return D3({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function De(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{shape:r}=s,o=ft(i.shape),l=wR(r,o),c=ft(l);F(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(i.dataId);const h=e.data.get(i.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag;d.shape=l,p.shape=l}return{dataId:i.dataId,shape:l,dtype:i.dtype}}const Htt={kernelName:Yg,backendName:"cpu",kernelFunc:De};function Q3(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r}=t,{transposeA:o,transposeB:l}=s;Nt([i,r],"matMul");const c=i.shape.length,h=r.shape.length,d=o?i.shape[c-2]:i.shape[c-1],p=l?r.shape[h-1]:r.shape[h-2],m=o?i.shape[c-1]:i.shape[c-2],y=l?r.shape[h-2]:r.shape[h-1],b=i.shape.slice(0,-2),x=r.shape.slice(0,-2),w=ft(b),S=ft(x),k=Ht(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([m,y]);F(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${o} and transposeB=${l} must match.`);const $=o?[w,d,m]:[w,m,d],E=l?[S,y,p]:[S,p,y],N=De({inputs:{x:i},backend:e,attrs:{shape:$}}),_=De({inputs:{x:r},backend:e,attrs:{shape:E}}),R=o?N.shape[1]:N.shape[2],D=o?N.shape[2]:N.shape[1],M=l?_.shape[1]:_.shape[2],A=Math.max(w,S),B=e.data.get(N.dataId).values,H=e.data.get(_.dataId).values,J=Ot(N.shape),X=Ot(_.shape),[z,P,V]=o?[J[0],1,J[1]]:[J[0],J[1],1],[K,st,L]=l?[1,X[1],X[0]]:[X[1],1,X[0]],j=D*M,Q=Jt([A,D,M],N.dtype),ct=Q.values,ut=e.blockSize;for(let pt=0;pt<A;pt++){const vt=pt%w,Et=pt%S;for(let Ct=0;Ct<D;Ct+=ut){const Rt=Math.min(Ct+ut,D);for(let zt=0;zt<M;zt+=ut){const ne=Math.min(zt+ut,M);for(let xe=0;xe<R;xe+=ut){const ge=Math.min(xe+ut,R);for(let ye=Ct;ye<Rt;ye++)for(let ue=zt;ue<ne;ue++){let Oe=0;for(let ke=xe;ke<ge;ke++){const Rs=B[vt*z+ye*P+ke*V],Ke=H[ke*K+ue*st+Et*L];Oe+=Rs*Ke}ct[pt*j+(ye*M+ue)]+=Oe}}}}}return e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(_),e.makeTensorInfo(k,Q.dtype,Q.values)}const qtt={kernelName:pg,backendName:"cpu",kernelFunc:Q3};function Ktt(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:l}=t,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;let m,y,b;const x=[];m=Q3({inputs:{a:i,b:r},attrs:{transposeA:c,transposeB:h},backend:e}),o&&(y=zc({inputs:{a:m,b:o},backend:e}),x.push(m),m=y),d&&(b=Xm(e,m,d,l,p),x.push(m),m=b);for(const S of x)e.disposeIntermediateTensorInfo(S);return m}const Xtt={kernelName:Em,backendName:"cpu",kernelFunc:Ktt};const Ytt=we(ed,n=>Math.acos(n)),Jtt={kernelName:ed,backendName:"cpu",kernelFunc:Ytt};const Ztt=we(nd,n=>Math.acosh(n)),Qtt={kernelName:nd,backendName:"cpu",kernelFunc:Ztt};function tet(n){const{inputs:t,backend:e}=n,s=t;Nt(t,"addN");const i=s.map(l=>e.data.get(l.dataId).values),r=Jt(s[0].shape,s[0].dtype),o=r.values;for(let l=0;l<s.length;l++){const c=i[l];for(let h=0;h<o.length;h++)o[h]+=c[h]}return e.makeTensorInfo(r.shape,r.dtype,r.values)}const eet={kernelName:i1,backendName:"cpu",kernelFunc:tet};function net(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s;Nt(i,"all");const l=Zt(r,i.shape);let c=l;const h=We(c,i.shape.length);let d=i;h!=null&&(d=ms({inputs:{x:i},backend:e,attrs:{perm:h}}),c=nn(c.length,i.shape.length)),Fn("all",c,d.shape.length);const[p,m]=An(d.shape,c),y=ft(m),b=qn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k&&E}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=cn(p,l),T=De({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const set={kernelName:r1,backendName:"cpu",kernelFunc:net};function iet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s;Nt(i,"any");const l=Zt(r,i.shape);let c=l;const h=We(c,i.shape.length);let d=i;h!=null&&(d=ms({inputs:{x:i},backend:e,attrs:{perm:h}}),c=nn(c.length,i.shape.length)),Fn("any",c,d.shape.length);const[p,m]=An(d.shape,c),y=ft(m),b=qn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];k=k||E}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=cn(p,l),T=De({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const ret={kernelName:o1,backendName:"cpu",kernelFunc:iet};function oet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;Nt(i,"argMax");let o=Zt(r,i.shape);const l=We(o,i.shape.length);let c=i;const h=[];l!=null&&(c=ms({inputs:{x:i},backend:e,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),o=[o[0]],Fn("argMax",o,c.shape.length);const[d,p]=An(c.shape,o),m=ft(d),y=qn(m,"int32"),b=ft(p),x=e.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E>T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(d,"int32",y)}const aet={kernelName:ug,backendName:"cpu",kernelFunc:oet};function cet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;Nt(i,"argMin");let o=Zt(r,i.shape);const l=We(o,i.shape.length);let c=i;const h=[];l!=null&&(c=ms({inputs:{x:i},backend:e,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),o=[o[0]],Fn("argMin",o,c.shape.length);const[d,p]=An(c.shape,o),m=ft(d),y=qn(m,"int32"),b=ft(p),x=e.data.get(c.dataId).values;for(let w=0;w<y.length;++w){const S=w*b;let T=x[S],k=0;for(let $=0;$<b;++$){const E=x[S+$];E<T&&(T=E,k=$)}y[w]=k}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(d,"int32",y)}const uet={kernelName:hg,backendName:"cpu",kernelFunc:cet};const het=we(sd,n=>Math.asin(n)),det={kernelName:sd,backendName:"cpu",kernelFunc:het};const fet=we(id,n=>Math.asinh(n)),pet={kernelName:id,backendName:"cpu",kernelFunc:fet};const met=we(rd,n=>Math.atan(n)),get={kernelName:rd,backendName:"cpu",kernelFunc:met};const yet=rn((n,t)=>Math.atan2(n,t)),bet=Sn(ad,yet),xet={kernelName:ad,backendName:"cpu",kernelFunc:bet};const vet=we(od,n=>Math.atanh(n)),wet={kernelName:od,backendName:"cpu",kernelFunc:vet};function TC(n,t,e,s,i,r){const o=i.strideHeight,l=i.strideWidth,c=i.dilationHeight,h=i.dilationWidth,d=i.effectiveFilterHeight,p=i.effectiveFilterWidth,m=i.padInfo.top,y=i.padInfo.left,b=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Jt(i.outShape,e),w=x.values,S=i.outShape[1]*i.outShape[2]*i.outShape[3],T=i.outShape[2]*i.outShape[3],k=i.outShape[3];for(let $=0;$<i.batchSize;++$){const E=$*S,N=$*s[0];for(let _=0;_<i.inChannels;++_)for(let R=0;R<i.outHeight;++R){const D=R*o-m,M=Math.max(0,D),A=Math.min(i.inHeight,d+D),B=E+R*T;for(let H=0;H<i.outWidth;++H){const J=H*l-y,X=Math.max(0,J),z=Math.min(i.inWidth,p+J);let P=b,V=0,K=0;for(let L=M;L<A;L+=c){const j=N+L*s[1];for(let Q=X;Q<z;Q+=h){const ct=j+Q*s[2],ut=n[ct+_];r==="max"&&ut>P?P=ut:r==="avg"&&(V+=ut,K++)}if(isNaN(P))break}const st=B+H*k+_;w[st]=r==="avg"?V/K:P}}}return x}function tL(n,t,e,s,i=!1,r=!1){const o=Jt(s.outShape,"int32"),l=s.strideHeight,c=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=Jt(t,e,n);for(let w=0;w<s.batchSize;++w)for(let S=0;S<s.inChannels;++S)for(let T=0;T<s.outHeight;++T){const k=T*l-y;let $=k;for(;$<0;)$+=h;const E=Math.min(s.inHeight,p+k);for(let N=0;N<s.outWidth;++N){const _=N*c-b;let R=_;for(;R<0;)R+=d;const D=Math.min(s.inWidth,m+_);let M=Number.NEGATIVE_INFINITY,A=-1;for(let B=$;B<E;B+=h){const H=B-k;for(let J=R;J<D;J+=d){const X=J-_,z=x.get(w,B,J,S);z>M&&(M=z,i?A=r?((w*s.inHeight+B)*s.inWidth+J)*s.inChannels+S:(B*s.inWidth+J)*s.inChannels+S:A=H*m+X)}}o.set(A,w,T,N,S)}}return o}function eL(n,t,e,s,i,r){const o=i.strideDepth,l=i.strideHeight,c=i.strideWidth,h=i.dilationDepth,d=i.dilationHeight,p=i.dilationWidth,m=i.effectiveFilterDepth,y=i.effectiveFilterHeight,b=i.effectiveFilterWidth,x=i.padInfo.front,w=i.padInfo.top,S=i.padInfo.left,T=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=Jt(i.outShape,e),$=k.values,E=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],N=i.outShape[2]*i.outShape[3]*i.outShape[4],_=i.outShape[3]*i.outShape[4],R=i.outShape[4];for(let D=0;D<i.batchSize;++D){const M=D*E,A=D*s[0];for(let B=0;B<i.inChannels;++B)for(let H=0;H<i.outDepth;++H){const J=H*o-x;let X=J;for(;X<0;)X+=h;const z=Math.min(i.inDepth,m+J),P=M+H*N;for(let V=0;V<i.outHeight;++V){const K=V*l-w;let st=K;for(;st<0;)st+=d;const L=Math.min(i.inHeight,y+K),j=P+V*_;for(let Q=0;Q<i.outWidth;++Q){const ct=Q*c-S;let ut=ct;for(;ut<0;)ut+=p;const pt=Math.min(i.inWidth,b+ct),vt=j+Q*R;let Et=T,Ct=0,Rt=0;for(let ne=X;ne<z;ne+=h){const xe=A+ne*s[1];for(let ge=st;ge<L;ge+=d){const ye=xe+ge*s[2];for(let ue=ut;ue<pt;ue+=p){const Oe=ye+ue*s[3],ke=n[Oe+B];if(r==="max"&&ke>Et?Et=ke:r==="avg"&&(Ct+=ke,Rt++),isNaN(Et))break}if(isNaN(Et))break}if(isNaN(Et))break}const zt=vt+B;$[zt]=r==="avg"?Ct/Math.max(Rt,1):Et}}}}return k}function Cet(n,t){const e=Jt(t.outShape,"int32"),s=t.strideDepth,i=t.strideHeight,r=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,h=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;for(let x=0;x<t.batchSize;++x)for(let w=0;w<t.inChannels;++w)for(let S=0;S<t.outDepth;++S){const T=S*s-m;let k=T;for(;k<0;)k+=o;const $=Math.min(t.inDepth,h+T);for(let E=0;E<t.outHeight;++E){const N=E*i-y;let _=N;for(;_<0;)_+=l;const R=Math.min(t.inHeight,d+N);for(let D=0;D<t.outWidth;++D){const M=D*r-b;let A=M;for(;A<0;)A+=c;const B=Math.min(t.inWidth,p+M);let H=Number.NEGATIVE_INFINITY,J=-1;for(let X=k;X<$;X+=o){const z=X-T;for(let P=_;P<R;P+=l){const V=P-N;for(let K=A;K<B;K+=c){const st=K-M,L=n.get(x,X,P,K,w);L>=H&&(H=L,J=z*d*p+V*d+st)}}}e.set(J,x,S,E,D,w)}}}return e}function Tet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;Nt(i,"avgPool");const{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=s,h=1;F(Xn(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=xi(i.shape,r,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&me(d.inShape,d.outShape))p=mr({inputs:{x:i},backend:e});else{const m=e.data.get(i.dataId).values,y=Ot(i.shape),b=TC(m,i.shape,i.dtype,y,d,"avg");p=e.makeTensorInfo(d.outShape,i.dtype,b.values)}return p}const ket={kernelName:dg,backendName:"cpu",kernelFunc:Tet};function $et(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Nt(i,"avgPool3d");const d=Xr(i.shape,r,o,1,l,c,h),p=e.data.get(i.dataId).values,m=eL(p,i.shape,i.dtype,Ot(i.shape),d,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}const Eet={kernelName:fg,backendName:"cpu",kernelFunc:$et};function Iet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Nt([i,r],"avgPool3DGrad");const d=Xr(r.shape,o,l,1,c,h),p=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,S=d.dilationDepth,T=d.dilationHeight,k=d.dilationWidth,$=d.effectiveFilterDepth,E=d.effectiveFilterHeight,N=d.effectiveFilterWidth,_=$-1-d.padInfo.front,R=N-1-d.padInfo.left,D=E-1-d.padInfo.top,M=Jt(r.shape,"float32"),A=1/(b*x*w),B=e.bufferSync(i);for(let H=0;H<d.batchSize;++H)for(let J=0;J<d.inChannels;++J)for(let X=0;X<d.inDepth;++X)for(let z=0;z<d.inHeight;++z)for(let P=0;P<d.inWidth;++P){const V=X-_,K=z-D,st=P-R;let L=0;for(let j=0;j<$;j+=S){const Q=(V+j)/p;if(!(Q<0||Q>=d.outDepth||Math.floor(Q)!==Q))for(let ct=0;ct<E;ct+=T){const ut=(K+ct)/m;if(!(ut<0||ut>=d.outHeight||Math.floor(ut)!==ut))for(let pt=0;pt<N;pt+=k){const vt=(st+pt)/y;if(vt<0||vt>=d.outWidth||Math.floor(vt)!==vt)continue;const Et=B.get(H,Q,ut,vt,J);L+=Et}}}M.set(L*A,H,X,z,P,J)}return e.makeTensorInfo(M.shape,M.dtype,M.values)}const Net={kernelName:l1,backendName:"cpu",kernelFunc:Iet};function Aet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,o=r;Nt([i,r],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=xi(o.shape,l,c,1,h),p=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,S=d.effectiveFilterHeight,T=d.effectiveFilterWidth,k=T-1-d.padInfo.left,$=S-1-d.padInfo.top,E=Jt(o.shape,"float32"),N=1/(y*b),_=e.data.get(i.dataId).values,R=Jt(i.shape,"float32",_);for(let D=0;D<d.batchSize;++D)for(let M=0;M<d.inChannels;++M)for(let A=0;A<d.inHeight;++A)for(let B=0;B<d.inWidth;++B){const H=A-$,J=B-k;let X=0;for(let z=0;z<S;z+=x){const P=(H+z)/p;if(!(P<0||P>=d.outHeight||Math.floor(P)!==P))for(let V=0;V<T;V+=w){const K=(J+V)/m;if(K<0||K>=d.outWidth||Math.floor(K)!==K)continue;const st=R.get(D,P,K,M);X+=st}}E.set(X*N,D,A,B,M)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}const _et={kernelName:a1,backendName:"cpu",kernelFunc:Aet};function Ret(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,scale:r,offset:o,mean:l,variance:c}=t;F(l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(r==null||l.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Nt([i,l,c,r,o],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=e.data.get(i.dataId).values,p=e.data.get(l.dataId).values,m=e.data.get(c.dataId).values,y=r?e.data.get(r.dataId).values:new Float32Array([1]),b=o?e.data.get(o.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,S=y.length,T=m.length,k=p.length;let $=0,E=0,N=0,_=0;for(let R=0;R<d.length;++R)x[R]=b[$++]+(d[R]-p[E++])*y[N++]/Math.sqrt(m[_++]+h),$>=w&&($=0),E>=k&&(E=0),N>=S&&(N=0),_>=T&&(_=0);return e.makeTensorInfo(i.shape,i.dtype,x)}const Det={kernelName:$g,backendName:"cpu",kernelFunc:Ret};function Oet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,crops:o}=s;Nt([i],"batchToSpaceND");const l=r.reduce((S,T)=>S*T),c=sf(i.shape,r,l),h=rf(c.length,r.length),d=of(i.shape,r,l),p=OS(o,r.length),m=MS(d,o,r.length),y=De({inputs:{x:i},backend:e,attrs:{shape:c}}),b=ms({inputs:{x:y},backend:e,attrs:{perm:h}}),x=De({inputs:{x:b},backend:e,attrs:{shape:d}}),w=il({inputs:{x},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),w}const Met={kernelName:mg,backendName:"cpu",kernelFunc:Oet};function Fet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:o}=s,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,h=xC(l,c,r.dtype,r.shape,o);return e.makeTensorInfo([o],r.dtype,h)}const Let={kernelName:c1,backendName:"cpu",kernelFunc:Fet};function zet(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t,r=e.data.get(s.dataId).values,o=e.data.get(i.dataId).values,l=Ht(Array.from(r),Array.from(o));return e.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const Pet={kernelName:ER,backendName:"cpu",kernelFunc:zet};const Bet=we(ud,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),Vet={kernelName:ud,backendName:"cpu",kernelFunc:Bet};const Uet=n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(ft(t.shape)),i=e.data.get(t.dataId),r=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,l=e.data.get(r.dataId).values,c=e.data.get(o.dataId).values;for(let h=0;h<l.length;h++){const d=l[h],p=c[h];s[h]=Math.hypot(d,p)}return e.makeOutput(s,t.shape,"float32")},jet={kernelName:gg,backendName:"cpu",kernelFunc:Uet};function Pc(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.data.get(s.dataId).complexTensorInfos.imag,r=e.data.get(i.dataId).values;return e.makeTensorInfo(i.shape,i.dtype,r)}const Get={kernelName:E1,backendName:"cpu",kernelFunc:Pc};function Bc(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,r=Zt(i,t[0].shape)[0],o=t.map(x=>x.shape);_S(o,r);let l=ar(t.map(x=>x.shape),r);if(ft(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const c=t.filter(x=>ft(x.shape)>0);if(c.length===1)return mr({inputs:{x:c[0]},backend:e});if(c[0].dtype==="complex64"){const x=c.map($=>sl({inputs:{input:$},backend:e})),w=c.map($=>Pc({inputs:{input:$},backend:e})),S=Bc({inputs:x,backend:e,attrs:{axis:r}}),T=Bc({inputs:w,backend:e,attrs:{axis:r}}),k=$s({inputs:{real:S,imag:T},backend:e});return x.forEach($=>e.disposeIntermediateTensorInfo($)),w.forEach($=>e.disposeIntermediateTensorInfo($)),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),k}const h=c.map(x=>{const S=[-1,ft(x.shape.slice(r))];return De({inputs:{x},backend:e,attrs:{shape:S}})}),d=h.map(x=>({vals:e.data.get(x.dataId).values,shape:x.shape}));l=ar(h.map(x=>x.shape),1);const p=h[0].shape[0]===1,m=o3(d,l,t[0].dtype,p),y=ar(c.map(x=>x.shape),r),b=e.makeTensorInfo(y,t[0].dtype,m);return h.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const Wet={kernelName:yg,backendName:"cpu",kernelFunc:Bc};function nL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s;Nt([i,r],"conv2d");const p=Yr(c),m=Mn(i.shape,r.shape,o,h,l,d,!1,p),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,S=m.padInfo.left,T=m.padInfo.top,k=m.dataFormat==="channelsLast",$=new On(m.outShape,i.dtype),E=Ot(i.shape),N=Ot(r.shape),_=E[0],R=k?E[1]:E[2],D=k?E[2]:1,M=k?1:E[1],A=$.strides[0],B=k?$.strides[1]:$.strides[2],H=k?$.strides[2]:1,J=k?1:$.strides[1],X=e.data.get(i.dataId).values,z=e.data.get(r.dataId).values,P=$.values;for(let V=0;V<m.batchSize;++V){const K=V*_,st=V*A;for(let L=0;L<m.outHeight;++L){const j=st+L*B,Q=L*m.strideHeight-T;for(let ct=0;ct<y;++ct){const ut=Q+ct*x;if(ut<0||ut>=m.inHeight)continue;const pt=ct*N[0],vt=K+ut*R;for(let Et=0;Et<m.outWidth;++Et){const Ct=j+Et*H,Rt=Et*m.strideWidth-S;for(let zt=0;zt<b;++zt){const ne=Rt+zt*w;if(ne<0||ne>=m.inWidth)continue;const xe=pt+zt*N[1],ge=vt+ne*D;let ye=xe;for(let ue=0;ue<m.inChannels;++ue){const Oe=X[ge+ue*M];for(let ke=0;ke<m.outChannels;++ke)P[Ct+ke*J]+=Oe*z[ye+ke];ye+=m.outChannels}}}}}}return e.makeTensorInfo($.shape,$.dtype,P)}const Het={kernelName:bg,backendName:"cpu",kernelFunc:nL};function qet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s;Nt([i,r],"conv2dBackpropFilter");const p=Yr(c),m=Mn(i.shape,d,o,1,l,h,!1,p),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,S=m.dataFormat==="channelsLast",T=new On(m.filterShape,"float32"),k=m.padInfo.left,$=m.padInfo.top,E=e.data.get(i.dataId).values,N=e.data.get(r.dataId).values,_=new On(i.shape,i.dtype,E),R=new On(r.shape,r.dtype,N);for(let D=0;D<x;++D){const M=Math.max(0,Math.ceil(($-D)/y)),A=Math.min(m.outHeight,(m.inHeight+$-D)/y);for(let B=0;B<w;++B){const H=Math.max(0,Math.ceil((k-B)/b)),J=Math.min(m.outWidth,(m.inWidth+k-B)/b);for(let X=0;X<m.inChannels;++X)for(let z=0;z<m.outChannels;++z){let P=0;for(let V=0;V<m.batchSize;++V)for(let K=M;K<A;++K){const st=D+K*y-$;for(let L=H;L<J;++L){const j=B+L*b-k;S?P+=_.get(V,st,j,X)*R.get(V,K,L,z):P+=_.get(V,X,st,j)*R.get(V,z,K,L)}}T.set(P,D,B,X,z)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const Ket={kernelName:d1,backendName:"cpu",kernelFunc:qet};function Xet(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s;Nt([i,r],"conv2dBackpropInput");const p=Ot(r.shape),m=Ot(i.shape);let y=Yr(h);const b=Mn(o,r.shape,l,1,c,d,!1,y),x=new On(b.inShape,"float32"),w=x.values,S=e.data.get(i.dataId).values,T=e.data.get(r.dataId).values,[k,$,E]=p,{batchSize:N,filterHeight:_,filterWidth:R,inChannels:D,inHeight:M,inWidth:A,outChannels:B,outHeight:H,outWidth:J,strideHeight:X,strideWidth:z}=b;y=b.dataFormat;const P=_-1-b.padInfo.top,V=R-1-b.padInfo.left,K=y==="channelsLast",st=x.strides[0],L=K?x.strides[1]:x.strides[2],j=K?x.strides[2]:1,Q=K?1:x.strides[1],ct=m[0],ut=K?m[1]:m[2],pt=K?m[2]:1,vt=K?1:m[1];for(let Et=0;Et<N;++Et)for(let Ct=0;Ct<D;++Ct)for(let Rt=0;Rt<M;++Rt){const zt=Rt-P,ne=Math.max(0,Math.ceil(zt/X)),xe=Math.min(H,(_+zt)/X);for(let ge=0;ge<A;++ge){const ye=ge-V,ue=Math.max(0,Math.ceil(ye/z)),Oe=Math.min(J,(R+ye)/z);let ke=0;for(let Ke=ne;Ke<xe;++Ke){const Js=Ke*X-zt;for(let os=ue;os<Oe;++os){const br=os*z-ye,Le=ct*Et+ut*Ke+pt*os,Si=k*(_-1-Js)+$*(R-1-br)+E*Ct;for(let Ci=0;Ci<B;++Ci){const Ti=S[Le+vt*Ci],Ds=T[Si+Ci];ke+=Ti*Ds}}}const Rs=st*Et+L*Rt+j*ge+Q*Ct;w[Rs]=ke}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}const Yet={kernelName:xg,backendName:"cpu",kernelFunc:Xet};function Jet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dilations:c}=s;Nt([i,r],"conv3d");const h=Ho(i.shape,r.shape,o,c,l),{filterDepth:d,filterHeight:p,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,S=w.front,T=w.left,k=w.top,$=new On(h.outShape,i.dtype),E=e.data.get(i.dataId).values,N=e.data.get(r.dataId).values,_=$.values,R=Ot(i.shape),D=Ot(r.shape);for(let M=0;M<h.batchSize;++M){const A=M*R[0],B=M*$.strides[0];for(let H=0;H<h.outDepth;++H){const J=B+H*$.strides[1],X=H*h.strideDepth-S;for(let z=0;z<d;++z){const P=X+z*y;if(P<0||P>=h.inDepth)continue;const V=z*D[0],K=A+P*R[1];for(let st=0;st<h.outHeight;++st){const L=J+st*$.strides[2],j=st*h.strideHeight-k;for(let Q=0;Q<p;++Q){const ct=j+Q*b;if(ct<0||ct>=h.inHeight)continue;const ut=V+Q*D[1],pt=K+ct*R[2];for(let vt=0;vt<h.outWidth;++vt){const Et=L+vt*h.outChannels,Ct=vt*h.strideWidth-T;for(let Rt=0;Rt<m;++Rt){const zt=Ct+Rt*x;if(zt<0||zt>=h.inWidth)continue;const ne=ut+Rt*D[2],xe=pt+zt*h.inChannels;let ge=ne;for(let ye=0;ye<h.inChannels;++ye){const ue=E[xe+ye];for(let Oe=0;Oe<h.outChannels;++Oe)_[Et+Oe]+=ue*N[ge+Oe];ge+=h.outChannels}}}}}}}}return e.makeTensorInfo($.shape,$.dtype,$.values)}const Zet={kernelName:vg,backendName:"cpu",kernelFunc:Jet};function Qet(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:o,pad:l,filterShape:c}=s;Nt([i,r],"conv3dBackpropFilterV2");const h=Ot(i.shape),d=Ot(r.shape),p=Ho(i.shape,c,o,1,l),m=p.strideDepth,y=p.strideHeight,b=p.strideWidth,x=p.filterDepth,w=p.filterHeight,S=p.filterWidth,T=new On(p.filterShape,"float32"),k=T.values,[$,E,N,_]=T.strides,R=e.data.get(r.dataId).values,[D,M,A,B]=d,H=e.data.get(i.dataId).values,[J,X,z,P]=h,V=p.padInfo.front,K=p.padInfo.left,st=p.padInfo.top;for(let L=0;L<x;++L){const j=Math.max(0,Math.ceil((V-L)/m)),Q=Math.min(p.outDepth,(p.inDepth+V-L)/m),ct=L*$;for(let ut=0;ut<w;++ut){const pt=Math.max(0,Math.ceil((st-ut)/y)),vt=Math.min(p.outHeight,(p.inHeight+st-ut)/y),Et=ut*E+ct;for(let Ct=0;Ct<S;++Ct){const Rt=Math.max(0,Math.ceil((K-Ct)/b)),zt=Math.min(p.outWidth,(p.inWidth+K-Ct)/b),ne=Ct*N+Et;for(let xe=0;xe<p.inChannels;++xe){const ge=xe*_+ne;for(let ye=0;ye<p.outChannels;++ye){let ue=0;for(let Oe=0;Oe<p.batchSize;++Oe){const ke=Oe*J,Rs=Oe*D;for(let Ke=j;Ke<Q;++Ke){const os=(L+Ke*m-V)*X+ke,br=Ke*M+Rs;for(let Le=pt;Le<vt;++Le){const Ci=(ut+Le*y-st)*z+os,Ti=Le*A+br;for(let Ds=Rt;Ds<zt;++Ds){const gl=(Ct+Ds*b-K)*P+Ci,lu=Ds*B+Ti;ue+=H[gl+xe]*R[lu+ye]}}}}k[ge+ye]=ue}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const tnt={kernelName:f1,backendName:"cpu",kernelFunc:Qet};function ent(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{pad:o,strides:l,inputShape:c}=s;Nt([i],"conv3dBackpropInputV2");const h=Ot(i.shape),d=Ot(r.shape),p=Ho(c,r.shape,l,1,o),m=new On(p.inShape,"float32"),y=m.values,[b,x,w,S]=m.strides,T=e.data.get(i.dataId).values,[k,$,E,N]=h,_=e.data.get(r.dataId).values,[R,D,M,A]=d,{batchSize:B,filterDepth:H,filterHeight:J,filterWidth:X,inChannels:z,inDepth:P,inHeight:V,inWidth:K,outChannels:st,outDepth:L,outHeight:j,outWidth:Q,strideDepth:ct,strideHeight:ut,strideWidth:pt}=p,vt=H-1-p.padInfo.front,Et=J-1-p.padInfo.top,Ct=X-1-p.padInfo.left;for(let Rt=0;Rt<B;++Rt)for(let zt=0;zt<z;++zt)for(let ne=0;ne<P;++ne){const xe=ne-vt,ge=Math.max(0,Math.ceil(xe/ct)),ye=Math.min(L,(H+xe)/ct);for(let ue=0;ue<V;++ue){const Oe=ue-Et,ke=Math.max(0,Math.ceil(Oe/ut)),Rs=Math.min(j,(J+Oe)/ut);for(let Ke=0;Ke<K;++Ke){const Js=Ke-Ct,os=Math.max(0,Math.ceil(Js/pt)),br=Math.min(Q,(X+Js)/pt);let Le=0;for(let Si=ge;Si<ye;++Si){const Ci=Si*ct-xe;for(let Ti=ke;Ti<Rs;++Ti){const Ds=Ti*ut-Oe;for(let ta=os;ta<br;++ta){const gl=ta*pt-Js,lu=k*Rt+$*Si+E*Ti+N*ta,Ly=R*(H-1-Ci)+D*(J-1-Ds)+M*(X-1-gl)+A*zt;for(let Wi=0;Wi<st;++Wi){const as=T[lu+Wi],Hi=_[Ly+Wi];Le+=as*Hi}}}}y[b*Rt+x*ne+w*ue+S*Ke+zt]=Le}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}const nnt={kernelName:p1,backendName:"cpu",kernelFunc:ent};const snt=we(hd,n=>Math.cos(n)),int={kernelName:hd,backendName:"cpu",kernelFunc:snt};const rnt=we(dd,n=>Math.cosh(n)),ont={kernelName:dd,backendName:"cpu",kernelFunc:rnt};function ant(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:r,boxInd:o}=t,{cropSize:l,method:c,extrapolationValue:h}=s,[d,p,m,y]=i.shape,b=r.shape[0],[x,w]=l,S=Jt([b,x,w,y],"float32"),T=e.data.get(r.dataId).values,k=e.data.get(o.dataId).values,$=e.data.get(i.dataId).values,E=Ot(i.shape),N=Ot(S.shape);for(let _=0;_<b;_++){const R=_*4,D=T[R],M=T[R+1],A=T[R+2],B=T[R+3],H=k[_];if(H>=d)continue;const J=x>1?(A-D)*(p-1)/(x-1):0,X=w>1?(B-M)*(m-1)/(w-1):0;for(let z=0;z<x;z++){const P=x>1?D*(p-1)+z*J:.5*(D+A)*(p-1);if(P<0||P>p-1){for(let V=0;V<w;V++)for(let K=0;K<y;K++){const st=K+V*N[2]+z*N[1]+_*N[0];S.values[st]=h}continue}if(c==="bilinear"){const V=Math.floor(P),K=Math.ceil(P),st=P-V;for(let L=0;L<w;L++){const j=w>1?M*(m-1)+L*X:.5*(M+B)*(m-1);if(j<0||j>m-1){for(let pt=0;pt<y;pt++){const vt=pt+L*N[2]+z*N[1]+_*N[0];S.values[vt]=h}continue}const Q=Math.floor(j),ct=Math.ceil(j),ut=j-Q;for(let pt=0;pt<y;pt++){let vt=pt+Q*E[2]+V*E[1]+H*E[0];const Et=$[vt];vt=pt+ct*E[2]+V*E[1]+H*E[0];const Ct=$[vt];vt=pt+Q*E[2]+K*E[1]+H*E[0];const Rt=$[vt];vt=pt+ct*E[2]+K*E[1]+H*E[0];const zt=$[vt],ne=Et+(Ct-Et)*ut,xe=Rt+(zt-Rt)*ut;vt=pt+L*N[2]+z*N[1]+_*N[0],S.values[vt]=ne+(xe-ne)*st}}}else for(let V=0;V<w;++V){const K=w>1?M*(m-1)+V*X:.5*(M+B)*(m-1);if(K<0||K>m-1){for(let j=0;j<y;j++){const Q=j+V*N[2]+z*N[1]+_*N[0];S.values[Q]=h}continue}const st=Math.round(K),L=Math.round(P);for(let j=0;j<y;j++){const Q=j+st*E[2]+L*E[1]+H*E[0],ct=j+V*N[2]+z*N[1]+_*N[0];S.values[ct]=$[Q]}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const lnt={kernelName:g1,backendName:"cpu",kernelFunc:ant};function cnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:o,reverse:l}=s;Nt(i,"cumprod");const c=We([r],i.shape.length);let h=i;c!=null&&(h=ms({inputs:{x:i},backend:e,attrs:{perm:c}}));const d=nn(1,i.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=Ns(h.dtype,"int32"),m=e1(ft(h.shape),p),y=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?1:y[k];else{const $=x(S,T-1);m[k]=o?y[$]*m[$]:y[k]*m[$]}}const w=e.makeTensorInfo(h.shape,p,m);if(c!=null){const S=qo(c),T=ms({inputs:{x:w},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(h),T}return w}const unt={kernelName:m1,backendName:"cpu",kernelFunc:cnt};function hnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:o,reverse:l}=s;Nt(i,"cumsum");const c=We([r],i.shape.length);let h=i;c!=null&&(h=ms({inputs:{x:i},backend:e,attrs:{perm:c}}));const d=nn(1,i.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const p=Ns(h.dtype,"int32"),m=qn(ft(h.shape),p),y=e.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=l?(S,T)=>S+b-T-1:(S,T)=>S+T;for(let S=0;S<y.length;S+=b)for(let T=0;T<b;T++){const k=x(S,T);if(T===0)m[k]=o?0:y[k];else{const $=x(S,T-1);m[k]=o?y[$]+m[$]:y[k]+m[$]}}const w=e.makeTensorInfo(h.shape,p,m);if(c!=null){const S=qo(c),T=ms({inputs:{x:w},backend:e,attrs:{perm:S}});return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(h),T}return w}const dnt={kernelName:wg,backendName:"cpu",kernelFunc:hnt};function fnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:o,binaryOutput:l}=s;if(i.shape.length===1){const c=e.data.get(i.dataId).values,h=e.data.get(r.dataId).values,d=xC(c,h,r.dtype,r.shape,o);return e.makeTensorInfo([o],r.dtype,d)}else if(i.shape.length===2){const c=e.bufferSync(i),h=e.bufferSync(r),d=s3(c,h,o,l);return e.makeTensorInfo(d.shape,r.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const pnt={kernelName:y1,backendName:"cpu",kernelFunc:fnt};function mnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:r,dataFormat:o}=s;F(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const l=i.shape[0],c=i.shape[1],h=i.shape[2],d=i.shape[3],p=c*r,m=h*r,y=d/(r*r),b=e.data.get(i.dataId).values,x=new Float32Array(l*p*m*y);let w=0;for(let S=0;S<l;++S)for(let T=0;T<p;++T){const k=Math.floor(T/r),$=T%r;for(let E=0;E<m;++E){const N=Math.floor(E/r),_=E%r,R=($*r+_)*y;for(let D=0;D<y;++D){const A=D+R+d*(N+h*(k+c*S));x[w++]=b[A]}}}return e.makeTensorInfo([l,p,m,y],i.dtype,x)}const gnt={kernelName:b1,backendName:"cpu",kernelFunc:mnt};function sL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;Nt([i,r],"depthwiseConv2DNative");const d=Ot(i.shape),p=Ot(r.shape);let m=c;m==null&&(m=[1,1]),F(Xn(o,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);const y=Mn(i.shape,r.shape,o,m,l,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:S,padInfo:T}=y,k=T.left,$=T.top,E=y.outChannels/y.inChannels,N=new On(y.outShape,i.dtype),_=e.data.get(i.dataId).values,R=e.data.get(r.dataId).values,D=N.values;for(let M=0;M<y.batchSize;++M){const A=M*d[0],B=M*N.strides[0];for(let H=0;H<y.outHeight;++H){const J=B+H*N.strides[1],X=H*y.strideHeight-$;for(let z=0;z<b;++z){const P=X+z*w;if(P<0||P>=y.inHeight)continue;const V=z*p[0],K=A+P*d[1];for(let st=0;st<y.outWidth;++st){const L=J+st*N.strides[2],j=st*y.strideWidth-k;for(let Q=0;Q<x;++Q){const ct=j+Q*S;if(ct<0||ct>=y.inWidth)continue;const ut=V+Q*p[1],pt=K+ct*y.inChannels;let vt=L,Et=ut;for(let Ct=0;Ct<y.inChannels;++Ct){const Rt=_[pt+Ct];for(let zt=0;zt<E;++zt)D[vt+zt]+=Rt*R[Et+zt];vt+=E,Et+=E}}}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}const ynt={kernelName:Sg,backendName:"cpu",kernelFunc:sL};function bnt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s;Nt([i,r],"depthwiseConv2dNativeBackpropFilter");const p=Mn(i.shape,d,o,l,c,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=p,w=new On(p.filterShape,"float32"),S=p.padInfo.left,T=p.padInfo.top,k=p.outChannels/p.inChannels,$=e.data.get(i.dataId).values,E=new On(i.shape,i.dtype,$),N=e.data.get(r.dataId).values,_=new On(r.shape,r.dtype,N);for(let R=0;R<b;++R){const D=Math.max(0,Math.ceil((T-R)/m)),M=Math.min(p.outHeight,(p.inHeight+T-R)/m);for(let A=0;A<x;++A){const B=Math.max(0,Math.ceil((S-A)/y)),H=Math.min(p.outWidth,(p.inWidth+S-A)/y);for(let J=0;J<p.outChannels;++J){const X=Math.trunc(J/k),z=J%k;let P=0;for(let V=0;V<p.batchSize;++V)for(let K=D;K<M;++K){const st=R+K*m-T;for(let L=B;L<H;++L){const j=A+L*y-S;P+=E.get(V,st,j,X)*_.get(V,K,L,J)}}w.set(P,R,A,X,z)}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const xnt={kernelName:x1,backendName:"cpu",kernelFunc:bnt};function vnt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s;Nt([i,r],"depthwiseConv2DNativeBackpropInput");const p=Ot(i.shape),m=Ot(r.shape),y=Mn(d,r.shape,o,l,c,h,!0),b=new On(y.inShape,"float32"),x=b.values,[w,S,T]=b.strides,k=e.data.get(i.dataId).values,[$,E,N]=p,_=e.data.get(r.dataId).values,[R,D,M]=m,{batchSize:A,filterHeight:B,filterWidth:H,inChannels:J,inHeight:X,inWidth:z,outChannels:P,outHeight:V,outWidth:K,strideHeight:st,strideWidth:L}=y,j=B-1-y.padInfo.top,Q=H-1-y.padInfo.left,ct=P/J;for(let ut=0;ut<A;++ut)for(let pt=0;pt<J;++pt)for(let vt=0;vt<X;++vt){const Et=vt-j,Ct=Math.max(0,Math.ceil(Et/st)),Rt=Math.min(V,(B+Et)/st);for(let zt=0;zt<z;++zt){const ne=zt-Q,xe=Math.max(0,Math.ceil(ne/L)),ge=Math.min(K,(H+ne)/L);let ye=0;for(let ue=Ct;ue<Rt;++ue){const Oe=ue*st-Et;for(let ke=xe;ke<ge;++ke){const Rs=ke*L-ne,Ke=$*ut+E*ue+N*ke,Js=R*(B-1-Oe)+D*(H-1-Rs)+M*pt;for(let os=0;os<ct;++os){const br=pt*ct+os,Le=k[Ke+br],Si=_[Js+os];ye+=Le*Si}}}x[w*ut+S*vt+T*zt+pt]=ye}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const wnt={kernelName:v1,backendName:"cpu",kernelFunc:vnt};function Snt(n){const{inputs:t,backend:e}=n,{x:s}=t,i=ft(s.shape),r=e.data.get(s.dataId).values,o=Jt([i,i],s.dtype),l=o.values;for(let h=0;h<r.length;h++)l[h*i+h]=r[h];const c=[...s.shape,...s.shape];return e.makeTensorInfo(c,o.dtype,o.values)}const Cnt={kernelName:IR,backendName:"cpu",kernelFunc:Snt};const Tnt={kernelName:Cg,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i}=n,{strides:r,pad:o,dilations:l}=e,c=t,h=c.data.get(s.dataId).values,d=s.shape.length,p=c.data.get(i.dataId).values,m=i.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:S,outWidth:T,padInfo:k,strideHeight:$,strideWidth:E,filterHeight:N,filterWidth:_,dilationHeight:R,dilationWidth:D,outShape:M}=Zd(s.shape,i.shape,r,o,"NHWC",l),A=ft(M),B=M.length,H=Qe(s.dtype,A);for(let X=0;X<y;++X)for(let z=0;z<S;++z){const P=z*$-k.top;for(let V=0;V<T;++V){const K=V*E-k.left;for(let st=0;st<w;++st){let L=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<N;++Q){const ct=P+Q*R;if(ct>=0&&ct<b)for(let ut=0;ut<_;++ut){const pt=K+ut*D;if(pt>=0&&pt<x){const vt=rr([X,ct,pt,st],d,Ot(s.shape)),Et=rr([Q,ut,st],m,Ot(i.shape)),Ct=h[vt]+p[Et];Ct>L&&(L=Ct)}}}const j=rr([X,z,V,st],B,Ot(M));H[j]=L}}}return{dataId:c.write(ol(H,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}};const knt={kernelName:Ov,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:l,dilations:c}=e,h=t,d=zi(s.shape,h.data.get(s.dataId).values),p=zi(i.shape,h.data.get(i.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Zd(s.shape,i.shape,o,l,"NHWC",c);F(r.rank===D.length,()=>`Error in ${Ov}, dy must have the same rank as output ${D.length}, but got ${r.rank}`);const M=zi(D,h.data.get(r.dataId).values),A=TR(i.shape,i.dtype);for(let H=0;H<m;++H)for(let J=0;J<w;++J){const X=J*k-T.top;for(let z=0;z<S;++z){const P=z*$-T.left;for(let V=0;V<x;++V){let K=Number.MIN_SAFE_INTEGER,st=0,L=0;for(let j=0;j<E;++j){const Q=X+j*_;if(Q>=0&&Q<y)for(let ct=0;ct<N;++ct){const ut=P+ct*R;if(ut>=0&&ut<b){const pt=d[H][Q][ut][V]+p[j][ct][V];pt>K&&(K=pt,st=j,L=ct)}}}A[st][L][V]+=M[H][J][z][V]}}}return{dataId:h.write(ol(A,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};const $nt={kernelName:Dv,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:l,dilations:c}=e,h=t,d=zi(s.shape,h.data.get(s.dataId).values),p=zi(i.shape,h.data.get(i.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:S,padInfo:T,strideHeight:k,strideWidth:$,filterHeight:E,filterWidth:N,dilationHeight:_,dilationWidth:R,outShape:D}=Zd(s.shape,i.shape,o,l,"NHWC",c);F(r.rank===D.length,()=>`Error in ${Dv}, dy must have the same rank as output ${D.length}, but got ${r.rank}`);const M=zi(D,h.data.get(r.dataId).values),A=TR(s.shape,s.dtype);for(let H=0;H<m;++H)for(let J=0;J<w;++J){const X=J*k-T.top;for(let z=0;z<S;++z){const P=z*$-T.left;for(let V=0;V<x;++V){let K=Number.MIN_SAFE_INTEGER,st=X<0?0:X,L=P<0?0:P;for(let j=0;j<E;++j){const Q=X+j*_;if(Q>=0&&Q<y)for(let ct=0;ct<N;++ct){const ut=P+ct*R;if(ut>=0&&ut<b){const pt=d[H][Q][ut][V]+p[j][ct][V];pt>K&&(K=pt,st=Q,L=ut)}}}A[H][st][L][V]+=M[H][J][z][V]}}}return{dataId:h.write(ol(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Ent(n){const{inputs:t,backend:e,attrs:s}=n,{image:i}=t,{canvas:r,options:o}=s,{contextOptions:l,imageOptions:c}=o||{},h=c?.alpha||1,d=l?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);const p=r.getContext(d,l?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=i.shape.slice(0,2),b=i.shape.length===2?1:i.shape[2],x=e.data.get(i.dataId).values,w=i.dtype==="float32"?255:1,S=new Uint8ClampedArray(y*m*4);for(let k=0;k<m*y;++k){const $=[0,0,0,255*h];for(let N=0;N<b;N++){const _=x[k*b+N];if(i.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(i.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);b===1?($[0]=_*w,$[1]=_*w,$[2]=_*w):$[N]=_*w}const E=k*4;S[E+0]=Math.round($[0]),S[E+1]=Math.round($[1]),S[E+2]=Math.round($[2]),S[E+3]=Math.round($[3])}r.width=y,r.height=m;const T=new ImageData(S,y,m);return p.putImageData(T,0,0),i}const Int={kernelName:O6,backendName:"cpu",kernelFunc:Ent};function mf(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s;Nt(i,"sum");let l;i.dtype==="bool"?l=Vo({inputs:{x:i},backend:e,attrs:{dtype:"int32"}}):l=mr({inputs:{x:i},backend:e});const c=l.shape.length,h=Zt(r,l.shape),d=We(h,c);let p=h,m=l;d!=null&&(m=ms({inputs:{x:l},backend:e,attrs:{perm:d}}),p=nn(p.length,c)),Fn("sum",p,m.shape.length);const[y,b]=An(m.shape,p),x=Ns(m.dtype,"int32");let w=qm(e,y,x);const S=ft(b),T=e.data.get(w.dataId).values,k=e.data.get(m.dataId).values;for(let $=0;$<T.length;++$){const E=$*S;let N=0;for(let _=0;_<S;++_)N+=k[E+_];T[$]=N}if(o){const $=cn(w.shape,h),E=w;w=De({inputs:{x:w},backend:e,attrs:{shape:$}}),e.disposeIntermediateTensorInfo(E)}return e.disposeIntermediateTensorInfo(l),d!=null&&e.disposeIntermediateTensorInfo(m),w}const Nnt={kernelName:ny,backendName:"cpu",kernelFunc:mf};function Ant(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,r=t,{allDims:o,summedDims:l,idDims:c}=jS(i,r.length);WS(o.length,c,r);const{path:h,steps:d}=HS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=GS(y,c[w]);let k;qS(S)?k=r[w]:(k=ms({inputs:{x:r[w]},backend:e,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);me(k.shape,$)||(k=De({inputs:{x:k},backend:e,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=_y({inputs:{a:k,b:m},backend:e}),b.push(m))}x<p-1&&(h[x]>=0&&(m=mf({inputs:{x:m},backend:e,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&e.disposeIntermediateTensorInfo(x);return m}const _nt={kernelName:w1,backendName:"cpu",kernelFunc:Ant};function Rnt(n){const{inputs:t,backend:e}=n,{dy:s,y:i}=t;Nt([s,i],"eluGrad");const r=new Float32Array(ft(i.shape)),o=e.data.get(i.dataId).values,l=e.data.get(s.dataId).values;for(let c=0;c<o.length;++c){const h=o[c];h>=0?r[c]=l[c]:r[c]=l[c]*(h+1)}return e.makeTensorInfo(i.shape,"float32",r)}const Dnt={kernelName:S1,backendName:"cpu",kernelFunc:Rnt};const Ont=FS,Mnt=LS,Fnt=zS,Lnt=PS,znt=BS,Pnt=VS,Bnt=we(md,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+Ont*e);return t*(1-((((Pnt*s+znt)*s+Lnt)*s+Fnt)*s+Mnt)*s*Math.exp(-e*e))}),Vnt={kernelName:md,backendName:"cpu",kernelFunc:Bnt};function Ym(n){const{inputs:t,backend:e,attrs:s}=n,{input:i}=t,{dim:r}=s,o=i.shape.length,l=i.shape.slice();let c=r;return r<0&&(F(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+r+1),l.splice(c,0,1),De({inputs:{x:i},backend:e,attrs:{shape:l}})}const Unt={kernelName:kg,backendName:"cpu",kernelFunc:Ym};const jnt=rn((n,t)=>n/t),kC=Sn(fd,jnt),rw={kernelName:fd,backendName:"cpu",kernelFunc:kC};function iL(n,t,e){const s=n.shape,i=s[0],r=s[1],o=e.data.get(n.dataId),l=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,h=[i,r],d=ft(h),p=Hn("float32",d),m=Hn("float32",d);for(let w=0;w<i;w++){const S=il({inputs:{x:l},backend:e,attrs:{begin:[w,0],size:[1,r]}}),T=il({inputs:{x:c},backend:e,attrs:{begin:[w,0],size:[1,r]}}),k=$s({inputs:{real:S,imag:T},backend:e}),{real:$,imag:E}=Gnt(k,t,e),N=Wr($,E);for(let _=0;_<r;_++){const R=US(N,_);p[w*r+_]=R.real,m[w*r+_]=R.imag}e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(k)}const y=e.makeTensorInfo(h,"float32",p),b=e.makeTensorInfo(h,"float32",m),x=$s({inputs:{real:y,imag:b},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),x}function Gnt(n,t,e){const s=ft(n.shape),i=e.data.get(n.dataId),r=e.data.get(i.complexTensorInfos.real.dataId).values,o=e.data.get(i.complexTensorInfos.imag.dataId).values;if(Wnt(s)){const l=ow(r,o,s,t,e),c=[n.shape[0],n.shape[1]];if(t){const h=e.makeTensorInfo(c,"float32",l.real),d=e.makeTensorInfo(c,"float32",l.imag),p=e.makeTensorInfo([],"float32",Go(s,"float32")),m=mr({inputs:{x:p},backend:e}),y=rw.kernelFunc({inputs:{a:h,b:p},backend:e}),b=rw.kernelFunc({inputs:{a:d,b:m},backend:e}),x=e.data.get(y.dataId).values,w=e.data.get(b.dataId).values;return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return l}else{const l=Wr(r,o),c=Hnt(l,s,t);return yO(c)}}function Wnt(n){return(n&n-1)===0}function ow(n,t,e,s,i){if(e===1)return{real:n,imag:t};const r=Wr(n,t),o=e/2,l=bO(r),c=l.real,h=l.imag,d=[c.length],p=i.makeTensorInfo(d,"float32",c),m=i.makeTensorInfo(d,"float32",h),y=$s({inputs:{real:p,imag:m},backend:i}),b=xO(r),x=b.real,w=b.imag,S=[x.length],T=i.makeTensorInfo(S,"float32",x),k=i.makeTensorInfo(S,"float32",w),$=$s({inputs:{real:T,imag:k},backend:i}),E=ow(c,h,o,s,i),N=E.real,_=E.imag,R=[N.length],D=i.makeTensorInfo(R,"float32",N),M=i.makeTensorInfo(R,"float32",_),A=$s({inputs:{real:D,imag:M},backend:i}),B=ow(x,w,o,s,i),H=B.real,J=B.imag,X=[H.length],z=i.makeTensorInfo(X,"float32",H),P=i.makeTensorInfo(X,"float32",J),V=$s({inputs:{real:z,imag:P},backend:i}),K=wO(e,s),st=[K.real.length],L=i.makeTensorInfo(st,"float32",K.real),j=i.makeTensorInfo(st,"float32",K.imag),Q=$s({inputs:{real:L,imag:j},backend:i}),ct=_y({inputs:{a:Q,b:V},backend:i}),ut=zc({inputs:{a:A,b:ct},backend:i}),pt=CC({inputs:{a:A,b:ct},backend:i}),vt=sl({inputs:{input:ut},backend:i}),Et=sl({inputs:{input:pt},backend:i}),Ct=Pc({inputs:{input:ut},backend:i}),Rt=Pc({inputs:{input:pt},backend:i}),zt=Bc({inputs:[vt,Et],backend:i,attrs:{axis:0}}),ne=Bc({inputs:[Ct,Rt],backend:i,attrs:{axis:0}}),xe=i.data.get(zt.dataId).values,ge=i.data.get(ne.dataId).values;return i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(m),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(z),i.disposeIntermediateTensorInfo(P),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(L),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(Q),i.disposeIntermediateTensorInfo(ct),i.disposeIntermediateTensorInfo(ut),i.disposeIntermediateTensorInfo(pt),i.disposeIntermediateTensorInfo(vt),i.disposeIntermediateTensorInfo(Ct),i.disposeIntermediateTensorInfo(Et),i.disposeIntermediateTensorInfo(Rt),i.disposeIntermediateTensorInfo(zt),i.disposeIntermediateTensorInfo(ne),{real:xe,imag:ge}}function Hnt(n,t,e){const s=new Float32Array(t*2);for(let i=0;i<t;i++){let r=0,o=0;for(let l=0;l<t;l++){const c=SO(i*l,t,e),h=US(n,l);r+=h.real*c.real-h.imag*c.imag,o+=h.real*c.imag+h.imag*c.real}e&&(r/=t,o/=t),vO(s,r,o,i)}return s}function qnt(n){const{inputs:t,backend:e}=n,{input:s}=t,i=ft(s.shape),r=s.shape[s.shape.length-1],o=i/r,l=De({inputs:{x:s},backend:e,attrs:{shape:[o,r]}}),c=iL(l,!1,e),h=De({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const Knt={kernelName:C1,backendName:"cpu",kernelFunc:qnt};function $C(n){const{backend:t,attrs:e}=n,{shape:s,value:i,dtype:r}=e,o=r||Hc(i),l=Qe(o,ft(s));return Ynt(l,i,o),t.makeTensorInfo(s,o,l)}const Xnt={kernelName:T1,backendName:"cpu",kernelFunc:$C};function Ynt(n,t,e){n.fill(t)}const Jnt={kernelName:k1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,i=e,r=Hn(s.dtype,ft(s.shape)),[o,l,c,h]=s.shape,d=i.data.get(s.dataId).values;for(let m=0;m<o;m++){const y=m*c*l*h;for(let b=0;b<l;b++){const x=b*(c*h);for(let w=0;w<c;w++){const S=w*h;for(let T=0;T<h;T++){const k=Math.round(c-w-1),$=y+x+S+T;let E=d[$];if(k>=0&&k<c){const N=k*h,_=y+x+N+T;E=d[_]}r[$]=E}}}}return{dataId:i.write(r,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Znt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=nL({inputs:{x:i,filter:r},backend:e,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;if(d==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const S=De({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});x=zc({inputs:{a:x,b:S},backend:e}),e.disposeIntermediateTensorInfo(S)}else x=zc({inputs:{a:x,b:o},backend:e});e.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&l.shape.length===1&&l.shape[0]!==1){const S=De({inputs:{x:l},backend:e,attrs:{shape:[l.shape[0],1,1]}});x=Xm(e,x,y,S,b),e.disposeIntermediateTensorInfo(S)}else x=Xm(e,x,y,l,b);e.disposeIntermediateTensorInfo(w)}return x}const Qnt={kernelName:Im,backendName:"cpu",kernelFunc:Znt};function tst(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=sL({inputs:{x:i,filter:r},backend:e,attrs:{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m}});if(o){const w=x;x=zc({inputs:{a:x,b:o},backend:e}),e.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=Xm(e,x,y,l,b),e.disposeIntermediateTensorInfo(w)}return x}const est={kernelName:qR,backendName:"cpu",kernelFunc:tst};function nst(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,r=ft(s.shape),o=i.shape,l=o[o.length-1],[c,h,d,p]=kS(s,i);if(h===0)return e.makeTensorInfo(c,s.dtype,[]);const m=e.data.get(i.dataId).values,y=e.bufferSync(s),b=p3(m,y,s.dtype,h,l,d,p,s.shape,r);return e.makeTensorInfo(c,s.dtype,b.values)}const sst={kernelName:NR,backendName:"cpu",kernelFunc:nst};function ist(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:r}=t,{axis:o,batchDims:l}=s;Nt([i,r],"gatherV2");const c=Zt(o,i.shape)[0],h=e.data.get(r.dataId).values,d=i.shape[c];for(let $=0;$<h.length;++$){const E=h[$];F(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let p=l;l==null&&(p=0);const m=ft(r.shape),y=XS(i,r,c,p),b=De({inputs:{x:i},backend:e,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=De({inputs:{x:r},backend:e,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],S=e.bufferSync(x),T=e.bufferSync(b),k=m3(T,S,w);return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.makeTensorInfo(y.outputShape,k.dtype,k.values)}const rst={kernelName:Eg,backendName:"cpu",kernelFunc:ist};function ost(n){const{inputs:t,backend:e}=n,{input:s}=t,i=ft(s.shape),r=s.shape[s.shape.length-1],o=i/r,l=De({inputs:{x:s},backend:e,attrs:{shape:[o,r]}}),c=iL(l,!0,e),h=De({inputs:{x:c},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),h}const ast={kernelName:$1,backendName:"cpu",kernelFunc:ost};const lst=we(Sd,n=>Number.isFinite(n)?1:0,"bool"),cst={kernelName:Sd,backendName:"cpu",kernelFunc:lst};const ust=we(Cd,n=>Math.abs(n)===1/0?1:0,"bool"),hst={kernelName:Cd,backendName:"cpu",kernelFunc:ust};const dst=we(Td,n=>Number.isNaN(n)?1:0,"bool"),fst={kernelName:Td,backendName:"cpu",kernelFunc:dst};function pst(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:r}=e,o=v3(s,i,r);return t.makeTensorInfo([o.length],"float32",o)}const mst={kernelName:AR,backendName:"cpu",kernelFunc:pst};const gst=we($d,n=>Math.log1p(n)),yst={kernelName:$d,backendName:"cpu",kernelFunc:gst};const bst=rn((n,t)=>n&&t),xst=Sn(Rg,bst,null,"bool"),vst={kernelName:Rg,backendName:"cpu",kernelFunc:xst};const wst=we(Dg,n=>n?0:1,"bool"),Sst={kernelName:Dg,backendName:"cpu",kernelFunc:wst};const Cst=rn((n,t)=>n||t),Tst=Sn(Og,Cst,null,"bool"),kst={kernelName:Og,backendName:"cpu",kernelFunc:Tst};function $st(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:r,bias:o,alpha:l,beta:c}=s;Nt(i,"LRN");const h=i.shape[3],d=h-1,p=e.data.get(i.dataId).values,m=ft(i.shape),y=new Float32Array(m);function b(x){const w=x%h;let S=x-w+Math.max(0,w-r);const T=x-w+Math.min(w+r,d);let k=0;for(;S<=T;S++){const $=p[S];k+=$*$}return k}for(let x=0;x<m;x++){const w=b(x),S=p[x]*Math.pow(o+l*w,-c);y[x]=S}return e.makeTensorInfo(i.shape,i.dtype,y)}const Est={kernelName:Mg,backendName:"cpu",kernelFunc:$st};function Ist(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,y:r,dy:o}=t,{depthRadius:l,bias:c,alpha:h,beta:d}=s;Nt(o,"LRNGrad");const p=ft(o.shape),m=o.shape[3],y=e.data.get(o.dataId).values,b=e.data.get(i.dataId).values,x=e.data.get(r.dataId).values,w=new Float32Array(p),S=p;for(let T=0;T<S;T++){const k=T%m,$=T-k+Math.max(0,k-l),E=T-k+Math.min(m,k+l+1);let N=0;for(let _=$;_<E;_++)N+=Math.pow(b[_],2);N=h*N+c;for(let _=$;_<E;_++){let R=-2*h*d*b[_]*x[T]/N;T===_&&(R+=Math.pow(N,-d)),R*=y[T],w[_]+=R}}return e.makeTensorInfo(o.shape,i.dtype,w)}const Nst={kernelName:I1,backendName:"cpu",kernelFunc:Ist};function rL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:r,keepDims:o}=s,l=e;let c=i.shape;const h=c.length,d=Zt(r,c);let p=d;const m=We(p,h);let y=l.data.get(i.dataId).values;if(m!=null){const $=new Array(h);for(let E=0;E<$.length;E++)$[E]=c[m[E]];y=wC(y,c,i.dtype,m,$),p=nn(p.length,h),c=$}Nt(i,"max"),Fn("max",p,h);const[b,x]=An(c,p),w=ft(x),S=S3(y,w,b,i.dtype),T=l.write(S,b,i.dtype);let k=b;return o&&(k=cn(b,d)),{dataId:T,shape:k,dtype:i.dtype}}const Ast={kernelName:Fg,backendName:"cpu",kernelFunc:rL};function _st(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;Nt(i,"maxPool");const{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=s,h=1;F(Xn(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=xi(i.shape,r,o,h,l,c);let p;if(d.filterWidth===1&&d.filterHeight===1&&me(d.inShape,d.outShape))p=mr({inputs:{x:i},backend:e});else{const m=e.data.get(i.dataId).values,y=Ot(i.shape),b=TC(m,i.shape,i.dtype,y,d,"max");p=e.makeTensorInfo(d.outShape,i.dtype,b.values)}return p}const Rst={kernelName:Lg,backendName:"cpu",kernelFunc:_st};function Dst(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s;Nt(i,"maxPool3d");const d=Xr(i.shape,r,o,1,l,c,h),p=e.data.get(i.dataId).values,m=eL(p,i.shape,i.dtype,Ot(i.shape),d,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}const Ost={kernelName:zg,backendName:"cpu",kernelFunc:Dst};function Mst(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,{filterSize:o,strides:l,pad:c,dimRoundingMode:h}=s;Nt([i,r],"maxPool3DGrad");const d=Xr(r.shape,o,l,1,c,h),p=e.bufferSync(r),m=Cet(p,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,S=d.dilationHeight,T=d.dilationWidth,k=d.effectiveFilterDepth,$=d.effectiveFilterHeight,E=d.effectiveFilterWidth,N=k-1-d.padInfo.front,_=E-1-d.padInfo.left,R=$-1-d.padInfo.top,D=Jt(r.shape,"float32"),M=e.bufferSync(i);for(let A=0;A<d.batchSize;++A)for(let B=0;B<d.inChannels;++B)for(let H=0;H<d.inDepth;++H)for(let J=0;J<d.inHeight;++J)for(let X=0;X<d.inWidth;++X){const z=H-N,P=J-R,V=X-_;let K=0;for(let st=0;st<k;st+=w){const L=(z+st)/y;if(!(L<0||L>=d.outDepth||Math.floor(L)!==L))for(let j=0;j<$;j+=S){const Q=(P+j)/b;if(!(Q<0||Q>=d.outHeight||Math.floor(Q)!==Q))for(let ct=0;ct<E;ct+=T){const ut=(V+ct)/x;if(ut<0||ut>=d.outWidth||Math.floor(ut)!==ut)continue;const pt=k*$*E-1-m.get(A,L,Q,ut,B),vt=st*$*E+j*E+ct,Et=pt===vt?1:0;if(Et===0)continue;const Ct=M.get(A,L,Q,ut,B);K+=Ct*Et}}}D.set(K,A,H,J,X,B)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}const Fst={kernelName:A1,backendName:"cpu",kernelFunc:Mst};function Lst(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r,output:o}=t,l=r;Nt([r,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=xi(l.shape,c,h,1,d,p),y=e.data.get(l.dataId).values,b=Jt(m.outShape,l.dtype,tL(y,l.shape,l.dtype,m).values),x=m.strideHeight,w=m.strideWidth,S=m.dilationHeight,T=m.dilationWidth,k=m.effectiveFilterHeight,$=m.effectiveFilterWidth,E=$-1-m.padInfo.left,N=k-1-m.padInfo.top,_=Jt(l.shape,"float32"),R=e.data.get(i.dataId).values,D=Jt(i.shape,"float32",R);for(let M=0;M<m.batchSize;++M)for(let A=0;A<m.inChannels;++A)for(let B=0;B<m.inHeight;++B)for(let H=0;H<m.inWidth;++H){const J=B-N,X=H-E;let z=0;for(let P=0;P<k;P+=S){const V=(J+P)/x;if(!(V<0||V>=m.outHeight||Math.floor(V)!==V))for(let K=0;K<$;K+=T){const st=(X+K)/w;if(st<0||st>=m.outWidth||Math.floor(st)!==st)continue;const L=k*$-1-b.get(M,V,st,A),j=P*$+K,Q=L===j?1:0;if(Q===0)continue;const ct=D.get(M,V,st,A);z+=ct*Q}}_.set(z,M,B,H,A)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const zst={kernelName:N1,backendName:"cpu",kernelFunc:Lst};function Pst(n,t,e,s,i){const r=Ot(t),o=TC(n,t,e,r,i,"max"),l=tL(n,t,e,i,!0,s);return[o.values,l.values]}const Bst={kernelName:_R,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:l}=t,c=e;Nt(s,"MaxPoolWithArgmax");const h=c.data.get(s.dataId).values,d=xi(s.shape,i,r,[1,1],o),[p,m]=Pst(h,s.shape,s.dtype,l,d),y=c.write(p,d.outShape,s.dtype),b=c.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function Vst(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s,l=Zt(r,i.shape),h=An(i.shape,l)[1],d=ft(h),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([d]));p.push(m);const y=Vo({inputs:{x:i},backend:e,attrs:{dtype:"float32"}});p.push(y);const b=kC({inputs:{a:y,b:m},backend:e});p.push(b);const x=mf({inputs:{x:b},backend:e,attrs:{axis:r,keepDims:o}});return p.forEach(w=>e.disposeIntermediateTensorInfo(w)),x}const Ust={kernelName:Pg,backendName:"cpu",kernelFunc:Vst};function jst(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s;Nt(i,"min");const l=Zt(r,i.shape);let c=l;const h=We(c,i.shape.length);let d=i;h!=null&&(d=ms({inputs:{x:i},backend:e,attrs:{perm:h}}),c=nn(c.length,i.shape.length)),Fn("min",c,d.shape.length);const[p,m]=An(d.shape,c),y=ft(m),b=qn(ft(p),d.dtype),x=e.data.get(d.dataId).values;for(let S=0;S<b.length;++S){const T=S*y;let k=x[T];for(let $=0;$<y;++$){const E=x[T+$];(Number.isNaN(E)||E<k)&&(k=E)}b[S]=k}h!=null&&e.disposeIntermediateTensorInfo(d);const w=e.makeTensorInfo(p,d.dtype,b);if(o){const S=cn(p,l),T=De({inputs:{x:w},backend:e,attrs:{shape:S}});return e.disposeIntermediateTensorInfo(w),T}return w}const Gst={kernelName:Bg,backendName:"cpu",kernelFunc:jst};function Wst(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:r,mode:o}=s;Nt(i,"mirrorPad");const l=r.map((k,$)=>k[0]+i.shape[$]+k[1]),c=r.map(k=>k[0]),h=r.map((k,$)=>k[0]+i.shape[$]),d=o==="reflect"?0:1,p=e.data.get(i.dataId).values,m=i.shape.length,y=Ot(i.shape),b=ft(l),x=l.length,w=Ot(l),S=Hn(i.dtype,b);for(let k=0;k<b;k++){let $=qc(k,x,w);for(let N=0;N<x;N++)$[N]<c[N]?$[N]=c[N]*2-$[N]-d:$[N]>=h[N]&&($[N]=(h[N]-1)*2-$[N]+d);$=$.map((N,_)=>N-c[_]);const E=rr($,m,y);S[k]=p[E]}return{dataId:e.write(S,l,i.dtype),shape:l,dtype:i.dtype}}const Hst={kernelName:Vg,backendName:"cpu",kernelFunc:Wst};const qst=rn(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),Kst=Sn(Nd,qst),Xst={kernelName:Nd,backendName:"cpu",kernelFunc:Kst};function oL(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:r}=s,o=i.shape.length;let l=r;if(l===-1&&(l=o-1),l!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${l}`);const c=Zt([l],i.shape),h=rL({inputs:{x:i},backend:e,attrs:{reductionIndices:c,keepDims:!1}}),d=cn(h.shape,c),p=De({inputs:{x:h},backend:e,attrs:{shape:d}}),m=CC({inputs:{a:i,b:p},backend:e}),y=u3({inputs:{x:m},backend:e}),b=mf({inputs:{x:y},backend:e,attrs:{axis:c,keepDims:!1}}),x=De({inputs:{x:b},backend:e,attrs:{shape:d}}),w=kC({inputs:{a:y,b:x},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),w}const Yst={kernelName:ry,backendName:"cpu",kernelFunc:oL};function Jst(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:r,seed:o,normalized:l}=s;Nt(i,"multinomial");const c=l?i:oL({inputs:{logits:i},backend:e,attrs:{dim:-1}}),h=c.shape[0],d=c.shape[1],p=e.data.get(c.dataId).values,m=[h,r],y=qn(ft(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=p[x];for(let k=1;k<w.length;++k)w[k]=w[k-1]+p[x+k];const S=uS.alea(o.toString()),T=b*r;for(let k=0;k<r;++k){const $=S();y[T+k]=w.length;for(let E=0;E<w.length;E++)if($<w[E]){y[T+k]=E;break}}}return l||e.disposeIntermediateTensorInfo(c),e.makeTensorInfo(m,"int32",y)}const Zst={kernelName:RR,backendName:"cpu",kernelFunc:Jst};const Qst=xS;function tit(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s;Nt(i,"NonMaxSuppression");const h=e.data.get(i.dataId).values,d=e.data.get(r.dataId).values,{selectedIndices:p}=Qst(h,d,o,l,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const eit={kernelName:_1,backendName:"cpu",kernelFunc:tit};const nit=vS;function sit(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s;Nt(i,"NonMaxSuppressionPadded");const d=e.data.get(i.dataId).values,p=e.data.get(r.dataId).values,{selectedIndices:m,validOutputs:y}=nit(d,p,o,l,c,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const iit={kernelName:R1,backendName:"cpu",kernelFunc:sit};const rit=wS;function oit(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s;Nt(i,"NonMaxSuppressionWithScore");const d=e.data.get(i.dataId).values,p=e.data.get(r.dataId).values,m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=rit(d,p,m,y,b,x);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const ait={kernelName:D1,backendName:"cpu",kernelFunc:oit};function lit(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:r,depth:o,onValue:l,offValue:c}=s;Nt(i,"oneHot");const h=ft(i.shape),d=new Float32Array(h*o);d.fill(c);const p=e.data.get(i.dataId).values;for(let m=0;m<h;++m)p[m]>=0&&p[m]<o&&(d[m*o+p[m]]=l);return e.makeTensorInfo([...i.shape,o],r,d)}const cit={kernelName:Wg,backendName:"cpu",kernelFunc:lit};function Jm(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=sl({inputs:{input:s},backend:e}),r=Jm({inputs:{x:i},backend:e}),o=Pc({inputs:{input:s},backend:e}),l=Jm({inputs:{x:o},backend:e}),c=$s({inputs:{real:r,imag:l},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return $C({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const uit={kernelName:ly,backendName:"cpu",kernelFunc:Jm};function aL(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=sl({inputs:{input:s},backend:e}),r=aL({inputs:{x:i},backend:e}),o=Pc({inputs:{input:s},backend:e}),l=Jm({inputs:{x:o},backend:e}),c=$s({inputs:{real:r,imag:l},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return $C({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const hit={kernelName:Gg,backendName:"cpu",kernelFunc:aL};function lL(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return Ym({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const r=t[0].shape,o=t[0].dtype;t.forEach(d=>{Qw(r,d.shape,"All tensors passed to stack must have matching shapes"),F(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=t.map(d=>{const p=Ym({inputs:{input:d},backend:e,attrs:{dim:i}});return l.push(p),p}),h=Bc({inputs:c,backend:e,attrs:{axis:i}});return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const dit={kernelName:Hg,backendName:"cpu",kernelFunc:lL};function fit(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:r,constantValue:o}=s;Nt(i,"pad");const l=r.map((T,k)=>T[0]+i.shape[k]+T[1]),c=r.map(T=>T[0]),h=e.data.get(i.dataId).values,d=ft(i.shape),p=i.shape.length,m=Ot(i.shape),y=ft(l),b=l.length,x=Ot(l),w=Hn(i.dtype,y);o!==0&&w.fill(o);for(let T=0;T<d;T++){const $=qc(T,p,m).map((N,_)=>N+c[_]),E=rr($,b,x);w[E]=h[T]}return{dataId:e.write(w,l,i.dtype),shape:l,dtype:i.dtype}}const cL={kernelName:qg,backendName:"cpu",kernelFunc:fit};const pit=rn((n,t)=>Math.pow(n,t)),mit=Sn(_d,pit),git={kernelName:_d,backendName:"cpu",kernelFunc:mit};function yit(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=t,{outputRaggedRank:l}=s,c=i.map(S=>e.data.get(S.dataId).values),h=i.map(S=>S.shape),d=e.data.get(r.dataId).values,p=e.data.get(o.dataId).values,[m,y,b]=I3(c,h,d,r.shape,r.dtype,p,o.shape),x=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),w=e.makeTensorInfo(b,r.dtype,y);return x.concat([w])}const bit={kernelName:DR,backendName:"cpu",kernelFunc:yit};function xit(n){const{inputs:t,backend:e}=n,{starts:s,limits:i,deltas:r}=t,o=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,[h,d]=N3(o,s.shape,s.dtype,l,i.shape,c,r.shape),p=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const vit={kernelName:OR,backendName:"cpu",kernelFunc:xit};function wit(n){const{inputs:t,backend:e,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:l}=t,{rowPartitionTypes:c}=s,h=e.data.get(i.dataId).values,d=e.data.get(r.dataId).values,p=e.data.get(o.dataId).values,m=l.map(w=>e.data.get(w.dataId).values),y=l.map(w=>w.shape),[b,x]=A3(h,i.shape,d,r.shape,r.dtype,p,o.shape,m,y,c);return e.makeTensorInfo(b,r.dtype,x)}const Sit={kernelName:MR,backendName:"cpu",kernelFunc:wit};function Cit(n){const{backend:t,attrs:e}=n,{start:s,stop:i,dtype:r,step:o}=e,l=_3(s,i,o,r);return t.makeTensorInfo([l.length],r,l)}const Tit={kernelName:O1,backendName:"cpu",kernelFunc:Cit};const kit=we(Rd,n=>1/n),$it={kernelName:Rd,backendName:"cpu",kernelFunc:kit};function Eit(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:o,size:l}=s;Nt(i,"resizeBilinear");const c=Ot(i.shape),[h,d]=l,[p,m,y,b]=i.shape,x=e.data.get(i.dataId).values,w=new Float32Array(ft([p,h,d,b])),S=[r&&h>1?m-1:m,r&&d>1?y-1:y],T=[r&&h>1?h-1:h,r&&d>1?d-1:d];let k=0;const $=S[0]/T[0],E=S[1]/T[1];for(let N=0;N<p;N++)for(let _=0;_<h;_++){let R;o?R=$*(_+.5)-.5:R=$*_;const D=Math.max(0,Math.floor(R)),M=R-D,A=Math.min(m-1,Math.ceil(R)),B=N*c[0]+D*c[1],H=N*c[0]+A*c[1];for(let J=0;J<d;J++){let X;o?X=E*(J+.5)-.5:X=E*J;const z=Math.max(0,Math.floor(X)),P=X-z,V=Math.min(y-1,Math.ceil(X)),K=B+z*c[2],st=H+z*c[2],L=B+V*c[2],j=H+V*c[2];for(let Q=0;Q<b;Q++){const ct=x[K+Q],ut=x[st+Q],pt=x[L+Q],vt=x[j+Q],Et=ct+(pt-ct)*P,Ct=ut+(vt-ut)*P,Rt=Et+(Ct-Et)*M;w[k++]=Rt}}}return e.makeTensorInfo([p,h,d,b],"float32",w)}const Iit={kernelName:Zg,backendName:"cpu",kernelFunc:Eit};function Nit(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:o}=s;Nt([r,i],"resizeBilinearGrad");const l=Ot(i.shape),[c,h,d,p]=i.shape,[,m,y]=r.shape,b=new Float32Array(c*h*d*p),x=[o&&m>1?h-1:h,o&&y>1?d-1:d],w=[o&&m>1?m-1:m,o&&y>1?y-1:y],S=x[0]/w[0],T=x[1]/w[1],k=e.data.get(r.dataId).values;let $=0;for(let E=0;E<c;E++){const N=E*l[0];for(let _=0;_<m;_++){const R=_*S,D=Math.floor(R),M=Math.min(Math.ceil(R),h-1),A=N+D*l[1],B=N+M*l[1],H=R-D,J=1-H;for(let X=0;X<y;X++){const z=X*T,P=Math.floor(z),V=Math.min(Math.ceil(z),d-1),K=z-P,st=1-K,L=A+P*l[2],j=A+V*l[2],Q=B+P*l[2],ct=B+V*l[2],ut=J*st,pt=J*K,vt=H*st,Et=H*K;for(let Ct=0;Ct<p;Ct++){const Rt=k[$++];b[L+Ct]+=Rt*ut,b[j+Ct]+=Rt*pt,b[Q+Ct]+=Rt*vt,b[ct+Ct]+=Rt*Et}}}}return e.makeTensorInfo([c,d,h,p],"float32",b)}const Ait={kernelName:L1,backendName:"cpu",kernelFunc:Nit};function _it(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:o,size:l}=s;Nt(i,"resizeNearestNeighbor");const c=Ot(i.shape),[h,d]=l,[p,m,y,b]=i.shape,x=e.data.get(i.dataId).values,w=new Float32Array(p*h*d*b),S=[r&&h>1?m-1:m,r&&d>1?y-1:y],T=[r&&h>1?h-1:h,r&&d>1?d-1:d],k=S[0]/T[0],$=S[1]/T[1];let E=0;for(let N=0;N<p;N++){const _=N*c[0];for(let R=0;R<h;R++){const D=o?k*(R+.5):k*R;let M=Math.min(m-1,r?Math.round(D):Math.floor(D));o&&(M=Math.max(0,M));const A=_+M*c[1];for(let B=0;B<d;B++){const H=o?$*(B+.5):$*B;let J=Math.min(y-1,r?Math.round(H):Math.floor(H));o&&(J=Math.max(0,J));const X=A+J*c[2];for(let z=0;z<b;z++){const P=x[X+z];w[E++]=P}}}}return e.makeTensorInfo([p,h,d,b],i.dtype,w)}const Rit={kernelName:Jg,backendName:"cpu",kernelFunc:_it};function Dit(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:o}=s;Nt([r,i],"resizeNearestNeighborGrad");const l=Ot(i.shape),c=Ot(r.shape),[h,d,p,m]=i.shape,[,y,b]=r.shape,x=new Float32Array(h*d*p*m),w=e.data.get(r.dataId).values,S=[o&&y>1?d-1:d,o&&b>1?p-1:p],T=[o&&y>1?y-1:y,o&&b>1?b-1:b],k=S[0]/T[0],$=S[1]/T[1],E=1/k,N=1/$,_=Math.ceil(E)*2+2,R=Math.ceil(N)*2+2;for(let D=0;D<h;D++){const M=D*l[0];for(let A=0;A<d;A++){const B=M+A*l[1],H=Math.floor(A*E),J=Math.floor(H-_/2);for(let X=0;X<p;X++){const z=B+X*l[2],P=Math.floor(X*N),V=Math.floor(P-R/2);for(let K=0;K<m;K++){let st=0;for(let L=0;L<_;L++){const j=L+J;if(j<0||j>=y)continue;const Q=M+j*c[1],ct=j*k,ut=Math.min(d-1,o?Math.round(ct):Math.floor(ct));if(A===ut)for(let pt=0;pt<R;pt++){const vt=pt+V;if(vt<0||vt>=b)continue;const Et=Q+vt*c[2],Ct=vt*$,Rt=Math.min(p-1,o?Math.round(Ct):Math.floor(Ct));X===Rt&&(st+=w[Et+K])}}x[z+K]=st}}}}return e.makeTensorInfo(i.shape,i.dtype,x)}const Oit={kernelName:F1,backendName:"cpu",kernelFunc:Dit};function Mit(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:r}=s;Nt(i,"reverse");const o=i.shape.length,l=Zt(r,i.shape);if(o===0)return mr({inputs:{x:i},backend:e});const c=new On(i.shape,i.dtype),h=e.bufferSync(i);for(let d=0;d<c.size;d++){const p=c.indexToLoc(d),m=p.slice();l.forEach(y=>m[y]=i.shape[y]-1-m[y]),c.set(h.get(...m),...p)}return e.makeTensorInfo(c.shape,c.dtype,c.values)}const Fit={kernelName:Qg,backendName:"cpu",kernelFunc:Mit};const Lit={kernelName:G1,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=t,l=e,c=Hn(s.dtype,ft(s.shape)),[h,d,p,m]=s.shape,[y,b]=DS(o,d,p),x=255,w=Math.sin(i),S=Math.cos(i),T=l.data.get(s.dataId).values;for(let $=0;$<h;$++){const E=$*p*d*m;for(let N=0;N<d;N++){const _=N*(p*m);for(let R=0;R<p;R++){const D=R*m;for(let M=0;M<m;M++){const A=[h,N,R,M],B=A[2],H=A[1];let J=(B-y)*S-(H-b)*w,X=(B-y)*w+(H-b)*S;J=Math.round(J+y),X=Math.round(X+b);let z=r;if(typeof r!="number"&&(M===3?z=x:z=r[M]),J>=0&&J<p&&X>=0&&X<d){const V=X*(p*m),K=J*m,st=E+V+K+M;z=T[st]}const P=E+_+D+M;c[P]=z}}}}return{dataId:l.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const zit=we(Md,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),Pit={kernelName:Md,backendName:"cpu",kernelFunc:zit};function Bit(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:r}=t,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(r,i,o),m=!0,y=e.bufferSync(i),b=e.bufferSync(r),x=Fa(y,b,o,p,h,c,l,d,0,m);return e.makeTensorInfo(o,x.dtype,x.values)}const Vit={kernelName:FR,backendName:"cpu",kernelFunc:Bit};function Uit(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<t?e=i+1:s=i;return s}function jit(n,t){let e=0,s=n.length,i=0;for(;e<s;)i=Math.floor((e+s)/2),n[i]<=t?e=i+1:s=i;return s}function Git(n,t,e,s,i,r){const o=Qe("int32",e*i);for(let l=0;l<e;++l){const c=n.slice(l*s,(l+1)*s),h=l*i;for(let d=0;d<i;++d)o[h+d]=r==="left"?Uit(c,t[d+h]):jit(c,t[d+h])}return o}function Wit(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:r}=t,{side:o}=s,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,h=Git(l,c,i.shape[0],i.shape[1],r.shape[1],o);return e.makeTensorInfo(r.shape,"int32",h)}const Hit={kernelName:zR,backendName:"cpu",kernelFunc:Wit};function qit(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:r}=t;Nt([s,i,r],"select");const o=s.shape.length,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,h=e.data.get(r.dataId).values,d=Ns(i.dtype,r.dtype),p=qn(ft(i.shape),d);let m=0;const y=o===0||o>1||i.shape.length===1?1:ft(i.shape.slice(1));for(let b=0;b<l.length;b++)for(let x=0;x<y;x++)l[b]===1?p[m++]=c[b]:p[m++]=h[b];return e.makeTensorInfo(i.shape,d,p)}const Kit={kernelName:ty,backendName:"cpu",kernelFunc:qit};const Xit=by,Yit=xy,Jit=we(Ld,n=>n>=0?Yit*n:Xit*(Math.exp(n)-1)),Zit={kernelName:Ld,backendName:"cpu",kernelFunc:Jit};const Qit=we(Bd,n=>n<0?-1:n>0?1:0),trt={kernelName:Bd,backendName:"cpu",kernelFunc:Qit};const ert=we(zd,n=>Math.sin(n)),nrt={kernelName:zd,backendName:"cpu",kernelFunc:ert};const srt=we(Pd,n=>Math.sinh(n)),irt={kernelName:Pd,backendName:"cpu",kernelFunc:srt};const rrt=11920928955078125e-23,GN=Math.log(rrt)+2,ort=we(Ud,n=>{const t=n>-GN,e=n<GN,s=Math.exp(n);let i;return e?i=s:t?i=n:i=Math.log(1+s),i}),art={kernelName:Ud,backendName:"cpu",kernelFunc:ort};function lrt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,paddings:o}=s;Nt([i],"spaceToBatchND");const l=ft(r),c=[[0,0]];c.push(...o);for(let N=1+r.length;N<i.shape.length;++N)c.push([0,0]);const h=cL.kernelFunc({inputs:{x:i},backend:e,attrs:{paddings:c,constantValue:0}}),d=sf(h.shape,r,l,!1),p=rf(d.length,r.length,!1),m=of(h.shape,r,l,!1),x=De({inputs:{x:h},backend:e,attrs:{shape:d}}),T=ms({inputs:{x},backend:e,attrs:{perm:p}}),E=De({inputs:{x:T},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(T),E}const crt={kernelName:sy,backendName:"cpu",kernelFunc:lrt};function urt(n){const{inputs:t,backend:e}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=t;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,h=e.data.get(r.dataId).values,d=e.data.get(o.dataId).values[0],[p,m,y,b,x]=M3(l,s.shape,s.dtype,c,i.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,p),e.makeTensorInfo([m[0]],i.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),e.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const hrt={kernelName:PR,backendName:"cpu",kernelFunc:urt};function drt(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:i,newShape:r}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(e.data.get(i.dataId).values),l=e.data.get(s.dataId).values,c=Array.from(e.data.get(r.dataId).values),[h,d,p]=F3(l,s.shape,s.dtype,o,c);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([p.length],r.dtype,new Int32Array(p))]}const frt={kernelName:BR,backendName:"cpu",kernelFunc:drt};function prt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,[h,d]=SC(o,s.shape,s.dtype,l,c,!0);return e.makeTensorInfo(d,s.dtype,h)}const mrt={kernelName:VR,backendName:"cpu",kernelFunc:prt};function grt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,c=e.data.get(r.dataId).values,[h,d]=SC(o,s.shape,s.dtype,l,c);return e.makeTensorInfo(d,s.dtype,h)}const yrt={kernelName:UR,backendName:"cpu",kernelFunc:grt};function brt(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=cl(r,i,l),y=!1,b=e.bufferSync(i);let x;switch(r.dtype){case"bool":{const w=e.bufferSync(r),S=!!e.data.get(o.dataId).values[0];x=Fa(b,w,l,m,d,h,c,p,S,y);break}case"float32":{const w=e.bufferSync(r),S=e.data.get(o.dataId).values[0];x=Fa(b,w,l,m,d,h,c,p,S,y);break}case"int32":{const w=e.bufferSync(r),S=e.data.get(o.dataId).values[0];x=Fa(b,w,l,m,d,h,c,p,S,y);break}case"string":{const w=e.bufferSync(r),S=Fo(e.data.get(o.dataId).values[0]);x=Fa(b,w,l,m,d,h,c,p,S,y);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return e.makeTensorInfo(l,x.dtype,x.values)}const xrt={kernelName:jR,backendName:"cpu",kernelFunc:brt};function vrt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:r,axis:o}=s,l=Zt(o,i.shape)[0],c=KS(i,r,l),h=new Array(i.shape.length).fill(0),d=i.shape.slice();return c.map(p=>{const m=[...d];m[l]=p;const y=il({inputs:{x:i},backend:e,attrs:{begin:h,size:m}});return h[l]+=p,y})}const wrt={kernelName:iy,backendName:"cpu",kernelFunc:vrt};const Srt={kernelName:z1,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;Nt(e,"square");const i=s.data.get(e.dataId).values,r=new Float32Array(i.length);for(let l=0;l<i.length;++l){const c=i[l];r[l]=c*c}return{dataId:s.write(r,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const Crt=we(Xd,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Trt={kernelName:Xd,backendName:"cpu",kernelFunc:Crt};function krt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s;Nt(i,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=AS(i.shape,r,o,l,c,h,d,p,m);let E;if(x)E=De({inputs:{x:i},backend:e,attrs:{shape:b}});else if(w||S){F(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const N=ES(T,k,$),_=il({inputs:{x:i},backend:e,attrs:{begin:T,size:N}});E=De({inputs:{x:_},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(_)}else{const N=e.bufferSync(i),_=P3(y,N,$,T);E=e.makeTensorInfo(b,_.dtype,_.values)}return E}const $rt={kernelName:B1,backendName:"cpu",kernelFunc:krt};function Ert(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=t,m=e.data.get(d.dataId).values,y=e.data.get(p.dataId).values,[b,x]=B3(m,y,i,r,o,l,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",x)]}const Irt={kernelName:GR,backendName:"cpu",kernelFunc:Ert};function Nrt(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=e.data.get(r.dataId).values,c=e.data.get(o.dataId).values[0],[h,d,p]=V3(l,c,i),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const Art={kernelName:WR,backendName:"cpu",kernelFunc:Nrt};function _rt(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:i}=s,{input:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=e.data.get(r.dataId).values,l=U3(o,i);return e.makeTensorInfo(r.shape,"int32",l)}const Rrt={kernelName:HR,backendName:"cpu",kernelFunc:_rt};const Drt=we(Hd,n=>Math.tan(n)),Ort={kernelName:Hd,backendName:"cpu",kernelFunc:Drt};const Mrt=we(qd,n=>Math.tanh(n)),Frt={kernelName:qd,backendName:"cpu",kernelFunc:Mrt};function Lrt(n){const{inputs:t,backend:e}=n,{tensor:s,indices:i,updates:r}=t,{sliceRank:o,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=cl(r,i,s.shape),p=!1,m=e.bufferSync(i),y=e.bufferSync(r),b=e.bufferSync(s),x=Fa(m,y,s.shape,d,c,l,o,h,b,p);return e.makeTensorInfo(s.shape,x.dtype,x.values)}const zrt={kernelName:LR,backendName:"cpu",kernelFunc:Lrt};function Prt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:r}=s;Nt(i,"tile");const o=G3(e.bufferSync(i),r);return e.makeTensorInfo(o.shape,o.dtype,o.values)}const Brt={kernelName:Kd,backendName:"cpu",kernelFunc:Prt};function Vrt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:r,sorted:o}=s;Nt(i,"topk");const l=e.data.get(i.dataId).values,[c,h]=H3(l,i.shape,i.dtype,r,o);return[e.makeTensorInfo(c.shape,c.dtype,c.values),e.makeTensorInfo(h.shape,h.dtype,h.values)]}const Urt={kernelName:V1,backendName:"cpu",kernelFunc:Vrt};function jrt(n){const{inputs:t,attrs:e,backend:s}=n,{image:i,transforms:r}=t,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=e,[d,p,m,y]=i.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=Ot(i.shape),T=S[0],k=S[1],$=S[2],E=Ot(w),N=E[0],_=E[1],R=E[2],D=Hn(i.dtype,ft(w));D.fill(c);const M=s.data.get(i.dataId).values,A=s.data.get(r.dataId).values;for(let H=0;H<d;++H){const J=r.shape[0]===1?A:A.subarray(H*8,H*8+8);for(let X=0;X<b;++X)for(let z=0;z<x;++z)for(let P=0;P<y;++P){let V;const K=J[6]*z+J[7]*X+1;if(K===0)continue;const st=(J[0]*z+J[1]*X+J[2])/K,L=(J[3]*z+J[4]*X+J[5])/K,j=WN(st,m,l),Q=WN(L,p,l);switch(o){case"nearest":V=Xrt(M,p,m,T,k,$,H,Q,j,P,c);break;case"bilinear":V=Yrt(M,p,m,T,k,$,H,Q,j,P,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ct=H*N+X*_+z*R+P;D[ct]=V}return s.makeTensorInfo(w,i.dtype,D)}return{dataId:s.write(D,w,i.dtype),shape:i.shape,dtype:i.dtype}}const Grt={kernelName:U1,backendName:"cpu",kernelFunc:jrt};function WN(n,t,e){switch(e){case"reflect":return Wrt(n,t);case"wrap":return Hrt(n,t);case"nearest":return Krt(n,t);default:return qrt(n)}}function Wrt(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return Wa(0,e,t-1)}function Hrt(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=t-1;e+=t*(Math.trunc(-e/s)+1)}else if(e>t-1)if(t<=1)e=0;else{const s=t-1;e-=t*Math.trunc(e/s)}return Wa(0,e,t-1)}function qrt(n,t){return n}function Krt(n,t){return Wa(0,n,t-1)}function fh(n,t,e,s,i,r,o,l,c,h,d){const p=o*s+l*i+c*r+h;return 0<=l&&l<t&&0<=c&&c<e?n[p]:d}function Xrt(n,t,e,s,i,r,o,l,c,h,d){const p=Math.round(l),m=Math.round(c);return fh(n,t,e,s,i,r,o,p,m,h,d)}function Yrt(n,t,e,s,i,r,o,l,c,h,d){const p=Math.floor(l),m=Math.floor(c),y=p+1,b=m+1,x=(b-c)*fh(n,t,e,s,i,r,o,p,m,h,d)+(c-m)*fh(n,t,e,s,i,r,o,p,b,h,d),w=(b-c)*fh(n,t,e,s,i,r,o,y,m,h,d)+(c-m)*fh(n,t,e,s,i,r,o,y,b,h,d);return(y-l)*x+(l-p)*w}function Jrt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:i}=e,{x:r}=t;Nt(r,"unique");const o=s.data.get(r.dataId).values,{outputValues:l,outputShape:c,indices:h}=q3(o,i,r.shape,r.dtype);return[s.makeTensorInfo(c,r.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const Zrt={kernelName:j1,backendName:"cpu",kernelFunc:Jrt};function Qrt(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i.shape.length,l=i.shape[r],c=new Array(o-1);let h=0;for(let y=0;y<o;y++)y!==r&&(c[h++]=i.shape[y]);const d=new Array(o).fill(0),p=i.shape.slice();p[r]=1;const m=new Array(l);for(let y=0;y<m.length;y++){d[r]=y;const b=il({inputs:{x:i},backend:e,attrs:{begin:d,size:p}});m[y]=De({inputs:{x:b},backend:e,attrs:{shape:c}}),e.disposeIntermediateTensorInfo(b)}return m}const tot={kernelName:oy,backendName:"cpu",kernelFunc:Qrt};function eot(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:r}=t,{numSegments:o}=s;Nt(i,"unsortedSegmentSum");const l=i.shape.length,c=r.shape.length,h=[],d=[],p=l-c;let m=r;for(let b=0;b<p;++b){const x=Ym({inputs:{input:m},backend:e,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<o;++b){const x=Go(b,"int32"),w=e.makeTensorInfo([],"int32",x),S=l3({inputs:{a:w,b:m},backend:e}),T=Vo({inputs:{x:S},backend:e,attrs:{dtype:"float32"}}),k=_y({inputs:{a:T,b:i},backend:e}),$=mf({inputs:{x:k},backend:e,attrs:{axis:0,keepDims:!1}});h.push($),d.push(w),d.push(S),d.push(T),d.push(k),d.push($)}const y=lL({inputs:h,backend:e,attrs:{axis:0}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const not={kernelName:ay,backendName:"cpu",kernelFunc:eot};const sot=[Xtt,NQ,Jtt,Qtt,MQ,eet,set,ret,aet,uet,det,pet,get,xet,wet,ket,Eet,Net,_et,qtt,Det,Met,Let,LQ,Pet,DQ,PQ,Vet,AQ,jet,Wet,Het,Ket,Yet,Zet,tnt,nnt,int,ont,lnt,unt,dnt,pnt,gnt,ynt,xnt,wnt,Cnt,Tnt,knt,$nt,Int,_nt,Btt,Dnt,BQ,Vnt,VQ,Unt,jQ,Knt,Xnt,Jnt,WQ,qQ,Qnt,est,sst,rst,XQ,JQ,_Q,ast,Get,cst,hst,fst,Vtt,QQ,ett,mst,stt,yst,vst,Sst,kst,Est,Nst,Ast,rtt,Rst,Ost,Fst,zst,Bst,Ust,Gst,att,Hst,Xst,Zst,ctt,htt,eit,iit,ait,ftt,cit,hit,dit,cL,git,jtt,gtt,bit,vit,Sit,Tit,RQ,rw,$it,Gtt,Wtt,Htt,Iit,Ait,Rit,Oit,Fit,Lit,Pit,Ttt,Vit,Hit,Kit,Zit,$tt,trt,nrt,irt,Ett,Yst,art,crt,hrt,frt,mrt,yrt,xrt,wrt,Att,Srt,Rtt,Ott,Trt,$rt,Irt,Art,Rrt,ztt,Nnt,Ort,Frt,zrt,Brt,Urt,Grt,ptt,Zrt,tot,not,uit];for(const n of sot)KR(n);const _a={},Yp={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function iot(n,t){_a[n]=t}function ji(n,t){if(!(n in _a)||t!=null){const s=oot(n,t);if(s!==null)_a[n]=s;else return console.log("Could not get context for WebGL version",n),null}const e=_a[n];return e==null||e.isContextLost()?(delete _a[n],ji(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_a[n])}function rot(n){if(!at().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function oot(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??rot(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete _a[n]},!1),at().getBool("SOFTWARE_WEBGL_ENABLED")&&(Yp.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",Yp)||e.getContext("experimental-webgl",Yp):e.getContext("webgl2",Yp)}var Gh;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Gh||(Gh={}));var Hs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Hs||(Hs={}));var Dn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Dn||(Dn={}));function gf(n,t){return[t,n]}function aot(n,t){return n*t}function Jp(n){const t=ft(n),e=Math.ceil(t/4);return Nv(e)}function tu(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function lot(n,t){const[e,s]=tu(n,t);return e*s*4}function EC(n,t){const e=n;let s,i,r,o,l,c,h,d,p,m;return at().getNumber("WEBGL_VERSION")===2?(s=e.R32F,i=e.R16F,r=e.RGBA16F,o=e.RGBA32F,l=e.RED,h=4,d=1,p=e.HALF_FLOAT,m=e.FLOAT,c=e.RGBA8):(s=n.RGBA,i=n.RGBA,r=n.RGBA,o=e.RGBA,l=n.RGBA,h=4,d=4,p=t!=null?t.HALF_FLOAT_OES:null,m=n.FLOAT,c=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:l,downloadTextureFormat:c,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:m}}function kt(n,t){const e=t();return at().getBool("DEBUG")&&cot(n),e}function cot(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+fot(n,t))}const uot=596e-10,hot=65504;function dot(n){return!!(at().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||uot<Math.abs(n)&&Math.abs(n)<hot)}function fot(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Zp(n,t){return Jr(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function pot(n,t){const e=Jr(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(kt(n,()=>n.shaderSource(e,t)),kt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function mot(n,t){const e=Jr(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(kt(n,()=>n.shaderSource(e,t)),kt(n,()=>n.compileShader(e)),at().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw uL(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const got=/ERROR: [0-9]+:([0-9]+):/g;function uL(n,t){const e=got.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const s=+e[1],i=n.split(`
`),r=i.length.toString().length+2,o=i.map((p,m)=>kc((m+1).toString(),r)+p);let l=0;for(let p=0;p<o.length;p++)l=Math.max(o[p].length,l);const c=o.slice(0,s-1),h=o.slice(s-1,s),d=o.slice(s);console.log(c.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${kc(h[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function yot(n){return Jr(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function bot(n,t){if(kt(n,()=>n.linkProgram(t)),!at().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Ux(n,t){if(kt(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function xot(n,t){const e=Jr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return kt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),kt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function vot(n,t){const e=Jr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return kt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),kt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function wot(n){return Jr(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Sot(n,t){const e=at().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const s=`[${n}x${t}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>e||t>e){const s=`[${n}x${t}]`,i=`[${e}x${e}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function Cot(n){return Jr(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function HN(n,t,e,s,i,r,o){const l=n.getAttribLocation(t,e);return l===-1?!1:(kt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),kt(n,()=>n.vertexAttribPointer(l,i,n.FLOAT,!1,r,o)),kt(n,()=>n.enableVertexAttribArray(l)),!0)}function Tot(n,t,e){Not(n,e),kt(n,()=>n.activeTexture(n.TEXTURE0+e)),kt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function kot(n,t,e){return Jr(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function $ot(n,t,e){return n.getUniformLocation(t,e)}function Eot(n,t,e,s){kt(n,()=>Tot(n,t,s)),kt(n,()=>n.uniform1i(e,s))}function jx(n,t,e){kt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),kt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function qN(n,t){kt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),kt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Qp(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Iot(n,t))}function Iot(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Jr(n,t,e){const s=kt(n,()=>t());if(s==null)throw new Error(e);return s}function Not(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e){const i=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${i}.`)}}function Vc(n,t=2){return ft(n.slice(0,n.length-t))}function Uc(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function tm(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[Vc(n),...Uc(n)]),t}function Aot(n,t=!1){let e=at().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=at().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&at().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e=e*2,s=s*2,n=n.map((l,c)=>c>=n.length-2?Zw(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=jo(n).newShape);let i=ft(n),r=null;n.length<=1&&i<=e?r=[1,i]:n.length===2&&n[0]<=e&&n[1]<=e?r=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?r=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?r=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?r=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(r=[n[0],n[1]*n[2]*n[3]]);const o=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(t?2:1)&&Math.min(...r)>0;if(r==null||o)if(t){const l=Vc(n);let c=2,h=2;n.length&&([c,h]=Uc(n)),i=l*(c/2)*(h/2),r=Nv(i).map(d=>d*2)}else r=Nv(i);return r}function em(n){return n%2===0}function Zm(n,t){if(n=n.slice(-2),t=t.slice(-2),me(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||em(e)&&em(s)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&em(n[0])&&em(t[0])}let Gx,Wx;function _ot(n){if(Gx==null){const t=ji(n);Gx=t.getParameter(t.MAX_TEXTURE_SIZE)}return Gx}function Rot(n){if(Wx==null){const t=ji(n);Wx=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Wx)}function Dot(n){if(n===0)return 0;let t;const e=ji(n);return mi(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:mi(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function mi(n,t){return n.getExtension(t)!=null}function KN(n){try{if(ji(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Oot(n){if(n===0)return!1;const t=ji(n);if(n===1){if(!mi(t,"OES_texture_float"))return!1}else if(!mi(t,"EXT_color_buffer_float"))return!1;return aw(t)}function Mot(n){if(n===0)return!1;const t=ji(n);if(n===1){if(!mi(t,"OES_texture_float")||!mi(t,"WEBGL_color_buffer_float"))return!1}else{if(mi(t,"EXT_color_buffer_float"))return aw(t);const s="EXT_color_buffer_half_float";if(mi(t,s)){const i=t.getExtension(s);return Fot(t,i)}return!1}return aw(t)}function aw(n){const t=EC(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(r),o}function Fot(n,t){const e=EC(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),l}function Lot(n){return n!==2?!1:ji(n).fenceSync!=null}function yf(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&F(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const At=at();At.registerFlag("HAS_WEBGL",()=>At.getNumber("WEBGL_VERSION")>0);At.registerFlag("WEBGL_VERSION",()=>KN(2)?2:KN(1)?1:0);At.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);At.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>At.get("WEBGL_VERSION")===2);At.registerFlag("WEBGL_CPU_FORWARD",()=>!0);At.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);At.registerFlag("WEBGL_PACK",()=>At.getBool("HAS_WEBGL"));At.registerFlag("WEBGL_PACK_NORMALIZATION",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CLIP",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_REDUCE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_LAZILY_UNPACK",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_CONV_IM2COL",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>At.getBool("WEBGL_PACK"));At.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>_ot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Rot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=At.getNumber("WEBGL_VERSION");return n===0?0:Dot(n)});At.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>At.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!aD());At.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Oot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>At.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:At.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));At.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Mot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Lot(At.getNumber("WEBGL_VERSION")));At.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>At.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);At.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});At.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>aD()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});At.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);At.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);At.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);At.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);At.registerFlag("WEBGL_EXP_CONV",()=>!1);At.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>At.getBool("IS_TEST"));At.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);At.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);At.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);At.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function rs(){let n,t,e,s,i,r,o,l,c,h;return at().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",s="in",i="texture",r="outputColor",o="out vec4 outputColor;",l=at().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",s="varying",i="texture2D",r="gl_FragColor",o="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:i,output:r,defineOutput:o,defineSpecialNaN:l,defineSpecialInf:c,defineRound:h}}function dl(n,t,e="index"){const s=Ot(t);return s.map((i,r)=>{const o=`int ${n[r]} = ${e} / ${i}`,l=r===s.length-1?`int ${n[r+1]} = ${e} - ${n[r]} * ${i}`:`index -= ${n[r]} * ${i}`;return`${o}; ${l};`}).join("")}function Ry(n,t,e="index"){const s=Ot(t);return s.map((i,r)=>{const o=`int ${n[r]} = ${e} / outShapeStrides[${r}]`,l=r===s.length-1?`int ${n[r+1]} = ${e} - ${n[r]} * outShapeStrides[${r}]`:`index -= ${n[r]} * outShapeStrides[${r}]`;return`${o}; ${l};`}).join("")}function zot(n,t){const e=n.length,s=n.map(r=>`${t}[${r}]`),i=new Array(e-1);i[e-2]=s[e-1];for(let r=e-3;r>=0;--r)i[r]=`(${i[r+1]} * ${s[r+1]})`;return i}function Pot(n,t,e="index"){const s=n.map((r,o)=>o),i=zot(s,t);return i.map((r,o)=>{const l=`int ${n[o]} = ${e} / ${i[o]}`,c=o===i.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${i[o]}`:`index -= ${n[o]} * ${i[o]}`;return`${l}; ${c};`}).join("")}function IC(n){const t=Ot(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function NC(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const hL=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:dL}=T7;function Bot(n,t,e){const s=[];if(n.forEach(y=>{const b=ft(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),e.enableShapeUniforms){const{uniformShape:x}=AC(e.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const i=s.join(`
`),r=n.map(y=>Vot(y,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),o=t.texShape,l=rs(),c=Got(l);let h,d,p=qot(l);return t.isPacked?(h=Uot(t.logicalShape,o,e.enableShapeUniforms),d=Hot(l)):(h=jot(t.logicalShape,o,e.enableShapeUniforms),d=Wot(l)),e.packedInputs&&(p+=Jot),[p,c,d,i,h,r,e.userCode].join(`
`)}function eu(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return cat(n,t);case 1:return hat(n,t);case 2:return fat(n,t);case 3:return mat(n,t);case 4:return yat(n,t);case 5:return bat(n);case 6:return xat(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function fL(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return lat(n);case 1:return uat(n,t);case 2:return dat(n,t);case 3:return pat(n,t);default:return gat(n,t)}}function Vot(n,t,e=!1,s){let i="";e?i+=fL(n,s):i+=eu(n,s);const r=n.shapeInfo.logicalShape,o=t.logicalShape;return r.length<=o.length&&(e?i+=vat(n,t):i+=wat(n,t)),i}function Uot(n,t,e){switch(n.length){case 0:return pL();case 1:return Zot(n,t,e);case 2:return oat(n,t,e);case 3:return tat(n,t,e);default:return nat(n,t,e)}}function jot(n,t,e){switch(n.length){case 0:return pL();case 1:return Qot(n,t,e);case 2:return aat(n,t,e);case 3:return eat(n,t,e);case 4:return sat(n,t,e);case 5:return iat(n,t);case 6:return rat(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function Got(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function Wot(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function Hot(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function qot(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Kot}
    ${Xot}
    ${Yot}
  `}const Kot=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Xot=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Yot=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Jot=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function pL(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Zot(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return s[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function Qot(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function tat(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[2]/2),r=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function eat(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ry(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=dl(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function nat(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(n[n.length-1]/2),r=i*Math.ceil(n[n.length-2]/2);let o=r,l="",c="b, r, c";for(let h=2;h<n.length-1;h++)o*=n[n.length-h-1],l=`
      int b${h} = index / ${o};
      index -= b${h} * ${o};
    `+l,c=`b${h}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${l}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${c});
    }
  `}function sat(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ry(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=dl(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function iat(n,t){const e=dl(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function rat(n,t){const e=dl(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function oat(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(me(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function aat(n,t,e){return me(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function fl(n){return`offset${n}`}function lat(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),s=rs();return`
    vec4 ${e}() {
      return ${s.texture2D}(${t}, halfCR);
    }
  `}function cat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[i,r]=n.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${s}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=fl(e);if(t)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});
      return sampleTexture(${e}, uv);
    }
  `;const[l,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${l}, ${c}, ${o});
      return sampleTexture(${e}, uv);
    }
  `}function uat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=n.shapeInfo.texShape,r=rs();if(t)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${e}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${r.texture2D}(${e}, uv);
    }
  `}function hat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${nu(n)}
      }
    `;const i=n.shapeInfo.texShape,r=i[0],o=i[1];if(o===1&&r===1)return`
      float ${s}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const l=fl(e);return o===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${r}.0);
        return sampleTexture(${e}, uv);
      }
    `:r===1?t?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${l});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${o}, index + ${l});
      return sampleTexture(${e}, uv);
    }
  `}function dat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=r[0],l=r[1],c=rs();if(r!=null&&me(e,r))return t?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${o}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(t)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],d=Math.ceil(e[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function fat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape;if(r!=null&&me(e,r)){if(t)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=r[0],y=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:l}=jo(e),c=o;if(c.length<e.length){const m=su(n,c),y=["row","col"];return`
      ${eu(m,t)}
      float ${i}(int row, int col) {
        return ${i}(${iu(y,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${nu(n)}
      }
    `;const h=r[0],d=r[1],p=fl(s);return d===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:t?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function pat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(e[0]===1){const m=e.slice(1),y=[1,2],b=su(n,m),x=["b","row","col"];return`
        ${fL(b,t)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${iu(x,y)});
        }
      `}const l=rs();if(t)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=o[0],h=o[1],d=Math.ceil(e[2]/2),p=d*Math.ceil(e[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${h}, ${p}, ${d}, b, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function mat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=e[1]*e[2],o=e[2],{newShape:l,keptDims:c}=jo(e),h=l;if(h.length<e.length){const x=su(n,h),w=["row","col","depth"];return`
        ${eu(x,t)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${iu(w,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${o}, 1)));
        ${nu(n)}
      }
    `;const d=n.shapeInfo.texShape,p=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===r&&y==null)return t?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===o&&y==null)return t?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=fl(s);return t?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${o} + depth + ${b};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function gat(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=rs();if(t)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${e}, uv);
    }
  `;const r=n.shapeInfo.logicalShape,o=r.length,l=n.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],h=c[0],d=c[1],p=Math.ceil(r[o-1]/2);let m=p*Math.ceil(r[o-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<o-1;x++)y=`int b${x}, `+y,m*=r[o-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${i.texture2D}(${e}, uv);
    }
  `}function yat(n,t){const e=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=e[3],o=e[2]*r,l=e[1]*o,{newShape:c,keptDims:h}=jo(e);if(c.length<e.length){const T=su(n,c),k=["row","col","depth","depth2"];return`
      ${eu(T,t)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${iu(k,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${o}, ${r}, 1)));
        ${nu(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===l&&d==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===r&&d==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const S=fl(s);return t?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${S});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${S});
      return sampleTexture(${s}, uv);
    }
  `}function bat(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),i=t[4],r=t[3]*i,o=t[2]*r,l=t[1]*o,{newShape:c,keptDims:h}=jo(t);if(c.length<t.length){const x=su(n,c),w=["row","col","depth","depth2","depth3"];return`
      ${eu(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${iu(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${o}, ${r}, ${i})) +
          depth3;
        ${nu(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,m=p[0],y=p[1];if(y===l&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(y===i&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;const b=fl(e);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${o} + depth * ${r} +
          depth2 * ${i} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${e}, uv);
    }
  `}function xat(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:i,keptDims:r}=jo(t);if(i.length<t.length){const w=su(n,i),S=["row","col","depth","depth2","depth3","depth4"];return`
      ${eu(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${iu(S,r)});
      }
    `}const o=t[5],l=t[4]*o,c=t[3]*l,h=t[2]*c,d=t[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${c}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${nu(n)}
      }
    `;const p=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${c}, ${l}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(b===o&&p==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;const x=fl(e);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${c} +
          depth2 * ${l} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${e}, uv);
    }
  `}function nu(n){const t=n.name,e=ft(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function vat(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),i="get"+s+"AtOutCoords",r=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=dL(n.shapeInfo.logicalShape,t.logicalShape),c=Te(o),h=o-r;let d;const p=["x","y","z","w","u","v"];r===0?d="":o<2&&l.length>=1?d="coords = 0;":d=l.map(T=>`coords.${p[T+h]} = 0;`).join(`
`);let m="";o<2&&r>0?m="coords":m=n.shapeInfo.logicalShape.map((T,k)=>`coords.${p[k+h]}`).join(", ");let y="return outputValue;";const x=ft(n.shapeInfo.logicalShape)===1,S=ft(t.logicalShape)===1;if(r===1&&!x&&!S)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!S)o===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(l.length){const T=r-2,k=r-1;l.indexOf(T)>-1&&l.indexOf(k)>-1?y="return vec4(outputValue.x);":l.indexOf(T)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(k)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${c} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function wat(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),i="get"+s+"AtOutCoords",r=t.texShape,o=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!n.shapeInfo.isUniform&&l===c&&n.shapeInfo.flatOffset==null&&me(o,r))return`
      float ${i}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const h=Te(c),d=dL(n.shapeInfo.logicalShape,t.logicalShape),p=c-l;let m;const y=["x","y","z","w","u","v"];l===0?m="":c<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+p]} = 0;`).join(`
`);let b="";return c<2&&l>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+p]}`).join(", "),`
    float ${i}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function Te(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function AC(n,t,e){const{newShape:s,keptDims:i}=jo(t),r=t.length,o=n&&r===3&&t[0]===1,l=o?t.slice(1):s,c=!n&&r>1&&!me(t,e)&&s.length<r||o;return{useSqueezeShape:c,uniformShape:c?l:t,keptDims:i}}function su(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function iu(n,t){return t.map(e=>n[e]).join(", ")}function Sat(n,t,e,s){const i=e.map((d,p)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),r=i.map(d=>d.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},l=Bot(i,o,t),c=mot(n.gl,l),h=n.createProgram(c);return at().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:r,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:t,fragmentShader:c,source:l,webGLProgram:h,inShapeInfos:r,outShapeInfo:o},mL(n,t,h)))}function mL(n,t,e){const s=[],i=[];let r,o,l,c=null,h=null;h=n.getUniformLocation(e,"NAN",!1),at().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const p of t.variableNames){const m={name:p,uniform:n.getUniformLocation(e,p,d),offset:n.getUniformLocation(e,`offset${p}`,d)};t.enableShapeUniforms&&(m.shape=n.getUniformLocation(e,`${p}Shape`,d),m.texShape=n.getUniformLocation(e,`${p}TexShape`,d)),s.push(m)}if(t.enableShapeUniforms&&(r=n.getUniformLocation(e,"outShape",d),l=n.getUniformLocation(e,"outShapeStrides",d),o=n.getUniformLocation(e,"outTexShape",d)),t.customUniforms)for(const p of t.customUniforms)i.push(n.getUniformLocation(e,p.name,d));return{variablesLocations:s,customUniformLocations:i,infLoc:c,nanLoc:h,outShapeLocation:r,outShapeStridesLocation:l,outTexShapeLocation:o}}function XN(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const i=e.logicalShape,r=t[s],o=r.shape;if(!me(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(e.isUniform&&r.isUniform)return;const l=e.texShape,c=r.isUniform?null:r.texData.texShape;if(!me(l,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${c} must match`)})}function Cat(n,t,e,s,i){t.program.enableShapeUniforms||(XN(t.inShapeInfos,e),XN([t.outShapeInfo],[s]));const r=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(r.texture,o[0],o[1]):n.setOutputMatrixTexture(r.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),at().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<e.length;++c){const h=e[c],{uniform:d,offset:p,shape:m,texShape:y}=t.variablesLocations[c];if(m){const{uniformShape:b}=AC(t.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(ft(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,c)}}const l=t.outShapeLocation;if(l)switch(s.shape.length){case 1:n.gl.uniform1iv(l,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(l,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(l,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(l,new Int32Array(s.shape));break}if(t.outShapeStridesLocation){const c=Ot(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(c));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&i)for(let c=0;c<t.program.customUniforms.length;++c){const h=t.program.customUniforms[c],d=t.customUniformLocations[c],p=i[c];if(h.type==="float")n.gl.uniform1fv(d,p);else if(h.type==="vec2")n.gl.uniform2fv(d,p);else if(h.type==="vec3")n.gl.uniform3fv(d,p);else if(h.type==="vec4")n.gl.uniform4fv(d,p);else if(h.type==="int")n.gl.uniform1iv(d,p);else if(h.type==="ivec2")n.gl.uniform2iv(d,p);else if(h.type==="ivec3")n.gl.uniform3iv(d,p);else if(h.type==="ivec4")n.gl.uniform4iv(d,p);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function Tat(n,t,e){let s="";t.concat(e).forEach(o=>{const l=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const c=o.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:p}=AC(n.packedInputs,o.shape,c);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Ot(d);b=`${E[0]===c[1]}_${E[E.length-1]===c[1]}`}const x=o.shape.length,w=d.length===2&&me(o.shape,c),S=ft(o.shape)===1,T=Mc(o.shape,e.shape),k=!n.packedInputs&&x===e.shape.length&&me(c,e.texData.texShape),$=n.packedInputs||d.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${x}_${k}_${h?p:""}_${d.length}_${S}_${T}_${w}_${m}_${y}_${b}_${$}_${l}`}else{const c=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${c}_${l}`}});const i=n.userCode;let r=n.constructor.name;return r+="_"+s+"_"+i+`${at().getNumber("WEBGL_VERSION")}`,r}function Jn(n){return at().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class kat{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Gh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=rs();this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ry(["r","c","d"],t):dl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class $at{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Gh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=rs();this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ry(["r","c","d"],t):dl(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class Eat{constructor(t){this.variableNames=["A"],this.outTexUsage=Hs.DOWNLOAD;const e=rs();this.outputShape=t,this.userCode=`
      ${hL}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class Iat{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Hs.DOWNLOAD;const e=rs();this.outputShape=t,this.userCode=`
      ${hL}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const Nat={R:0,G:1,B:2,A:3};class YN{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=rs();this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length);let r="result";e&&(r="floor(result * 255. + 0.5)");let o="";for(let l=0;l<s.length;l++){const c=s[l];o+=`
          if(offset == ${l}) {
            result = values[${Nat[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?NC():IC(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}class Aat{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=rs();this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length);let i="",r="result";e&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){const c=o*2+l;i+=`
          localCoords = coords;
          if(localCoords[2] + ${l} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${l};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?NC():IC(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `}}function _at(n){const t=rs(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return pot(n,e)}function Rat(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return xot(n,t)}function Dat(n){const t=new Uint16Array([0,1,2,2,1,3]);return vot(n,t)}function bf(n,t,e,s,i,r){Sot(t,e);const o=wot(n),l=n.TEXTURE_2D;return kt(n,()=>n.bindTexture(l,o)),kt(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),kt(n,()=>n.texParameteri(l,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),kt(n,()=>n.texParameteri(l,n.TEXTURE_MIN_FILTER,n.NEAREST)),kt(n,()=>n.texParameteri(l,n.TEXTURE_MAG_FILTER,n.NEAREST)),at().getNumber("WEBGL_VERSION")===1?kt(n,()=>n.texImage2D(l,0,s,t,e,0,i,r,null)):kt(n,()=>n.texStorage2D(l,1,s,t,e)),kt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function gL(n){return n.internalFormatFloat}function Oat(n,t,e,s){const[i,r]=gf(t,e);return bf(n,i,r,gL(s),s.textureFormatFloat,n.FLOAT)}function yL(n){return n.internalFormatHalfFloat}function Mat(n,t,e,s){const[i,r]=gf(t,e);return bf(n,i,r,yL(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function bL(n){return n.downloadTextureFormat}function Fat(n,t,e,s){const[i,r]=gf(t,e);return bf(n,i,r,bL(s),n.RGBA,n.UNSIGNED_BYTE)}function xL(n){return n.internalFormatPackedFloat}function Lat(n,t,e,s){const[i,r]=tu(t,e);return bf(n,i,r,xL(s),n.RGBA,n.FLOAT)}function vL(n){return n.internalFormatPackedHalfFloat}function zat(n,t,e,s){const[i,r]=tu(t,e);return bf(n,i,r,vL(s),n.RGBA,s.textureTypeHalfFloat)}function Pat(n,t,e){return kt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),HN(n,t,"clipSpacePos",e,3,20,0)&&HN(n,t,"uv",e,2,20,12)}function Bat(n,t,e,s,i,r){kt(n,()=>n.bindTexture(n.TEXTURE_2D,t));let o,l,c;i instanceof Uint8Array?(o=new Uint8Array(e*s*4),l=n.UNSIGNED_BYTE,c=n.RGBA):(o=new Float32Array(e*s*4),l=n.FLOAT,c=r.internalFormatPackedFloat),o.set(i),at().getNumber("WEBGL_VERSION")===2?kt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,l,o)):kt(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,e,s,0,n.RGBA,l,o)),kt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Vat(n,t,e){kt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?at().getNumber("WEBGL_VERSION")===2?kt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):kt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):at().getNumber("WEBGL_VERSION")===2?kt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):kt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),kt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Uat(n,t,e,s){const i=n.createBuffer();kt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const l=4*4*t*e;return kt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,l,n.STREAM_READ)),kt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),kt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function jat(n,t,e){const s=n,i=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function Gat(n,t,e,s){const[i,r]=gf(t,e),o=4,l=new Uint8Array(aot(t*e,o));return kt(n,()=>n.readPixels(0,0,i,r,s.downloadTextureFormat,n.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function Wat(n,t,e,s,i,r,o,l){const c=n,h=new Float32Array(lot(r,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,h),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),h}function Hat(n,t,e){const s=new Float32Array(t*e*4);return kt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}class Hx{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=at().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,iot(e,t)):this.gl=ji(e),t=this.gl,at().getNumber("WEBGL_VERSION")===2){const r=t;this.createVertexArray=()=>kt(r,()=>r.createVertexArray()),this.bindVertexArray=o=>kt(r,()=>r.bindVertexArray(o)),this.deleteVertexArray=o=>kt(r,()=>r.deleteVertexArray(o)),this.getVertexArray=()=>kt(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(t!=null){const r=t.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>kt(t,()=>r.createVertexArrayOES()),this.bindVertexArray=o=>kt(t,()=>r.bindVertexArrayOES(o)),this.deleteVertexArray=o=>kt(t,()=>r.deleteVertexArrayOES(o)),this.getVertexArray=()=>kt(t,()=>t.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),at().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Zp(this.gl,r),mi(this.gl,o))this.textureHalfFloatExtension=Zp(this.gl,o);else if(at().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),mi(this.gl,i))this.colorBufferHalfFloatExtension=Zp(this.gl,i);else if(at().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",mi(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(mi(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Rat(this.gl),this.indexBuffer=Dat(this.gl),this.framebuffer=Cot(this.gl),this.textureConfig=EC(this.gl,this.textureHalfFloatExtension)}get debug(){return at().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;kt(t,()=>t.finish()),kt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),kt(t,()=>t.deleteFramebuffer(this.framebuffer)),kt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),kt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),kt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),Oat(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),Mat(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),Fat(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),Vat(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,i){this.throwIfDisposed(),Bat(this.gl,t,e,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),zat(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),Lat(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(qN(this.gl,this.framebuffer),this.outputTexture=null),kt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>Gat(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,i,r,o){return Wat(this.gl,t,e,s,i,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return jat(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const i=Uat(this.gl,e,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(at().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=i.clientWaitSync(r,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},e=r}else at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>Hat(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=_at(e));const s=yot(e);kt(e,()=>e.attachShader(s,this.vertexShader)),kt(e,()=>e.attachShader(s,t)),bot(e,s);const i=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Ux(e,i),i}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;kt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Pat(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(kt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Ux(this.gl,this.program),kt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?kot(this.gl,t,e):$ot(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),kt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),Eot(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[i,r]=tu(e,s);this.setOutputMatrixTextureDriver(t,i,r)}setOutputMatrixWriteRegion(t,e,s,i){this.setOutputMatrixWriteRegionDriver(s,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Ux(this.gl,this.program),Qp(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}kt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),kt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Zp(this.gl,at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,r),r}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();e.endQuery(s.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await NI(()=>this.disposed||this.isQueryAvailable(t,at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=qat(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in at().platform&&(s=at().platform.setTimeoutCustom.bind(at().platform)),NI(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),jx(this.gl,t,this.framebuffer),this.debug&&Qp(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(jx(this.gl,this.outputTexture,this.framebuffer),this.debug&&Qp(this.gl)):qN(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const i=this.gl;jx(i,t,this.framebuffer),this.debug&&Qp(i),this.outputTexture=t,kt(i,()=>i.viewport(0,0,e,s)),kt(i,()=>i.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,i){this.throwIfDisposed(),kt(this.gl,()=>this.gl.scissor(t,e,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function qat(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}const{addImpl:Kat,bincountImpl:wL,bincountReduceImpl:Xat,bitwiseAndImpl:Yat,castImpl:Jat,ceilImpl:Zat,concatImpl:Qat,equalImpl:tlt,expImpl:elt,expm1Impl:nlt,floorImpl:slt,gatherNdImpl:ilt,gatherV2Impl:rlt,greaterImpl:olt,greaterEqualImpl:alt,lessImpl:llt,lessEqualImpl:clt,linSpaceImpl:ult,logImpl:hlt,maxImpl:dlt,maximumImpl:flt,minimumImpl:plt,multiplyImpl:mlt,negImpl:glt,notEqualImpl:ylt,prodImpl:blt,raggedGatherImpl:xlt,raggedRangeImpl:vlt,raggedTensorToTensorImpl:wlt,rangeImpl:Slt,rsqrtImpl:Clt,scatterImpl:Tlt,sigmoidImpl:klt,simpleAbsImpl:SL,sliceImpl:$lt,sparseFillEmptyRowsImpl:Elt,sparseReshapeImpl:Ilt,sparseSegmentReductionImpl:CL,sqrtImpl:Nlt,staticRegexReplaceImpl:Alt,stridedSliceImpl:_lt,stringNGramsImpl:Rlt,stringSplitImpl:Dlt,stringToHashBucketFastImpl:Olt,subImpl:Mlt,tileImpl:Flt,topKImpl:Llt,transposeImpl:_C,uniqueImpl:zlt}=Ptt;function TL(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function es(n,t){return t===1?[n]:TL(n,t)}function Plt(n,t){if(n===1)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}class Blt{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Jn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=es("rc",this.rank),s=Te(this.rank),i=this.getOutOfBoundsCondition(e),r=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let r=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)r=`${t[t.length-1-o]},`+r;e.push(r)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class kL{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length);let s="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),s+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${Vlt(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?NC():IC(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${s}

        setOutput(result);
      }
    `}}function Vlt(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Pot(["r","c","d"],"inputShape"):dl(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class Ult{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const i=ZN(e,s),r=QN(t,i,s);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=JN(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const c=this.freeTextures[r].pop();return this.usedTextures[r].push(c),c}let l;return i===Dn.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):i===Dn.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):i===Dn.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):i===Dn.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):i===Dn.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[r].push(l),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),l}releaseTexture(t,e,s,i){if(this.freeTextures==null)return;const r=ZN(s,i),o=QN(e,r,i);o in this.freeTextures||(this.freeTextures[o]=[]);const l=JN(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),c=at().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=l):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const h=this.usedTextures[o],d=h&&h.indexOf(t);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function jlt(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function JN(n,t,e,s,i){const r=Glt(t,s);let o;if(i){const[c,h]=tu(n[0],n[1]);o=c*h}else{const[c,h]=gf(n[0],n[1]);o=c*h}const l=jlt(e,r);return o*l}function Glt(n,t){switch(n){case Dn.PACKED_2X2_FLOAT32:return xL(t);case Dn.PACKED_2X2_FLOAT16:return vL(t);case Dn.UNPACKED_FLOAT32:return gL(t);case Dn.UNPACKED_FLOAT16:return yL(t);case Dn.PACKED_4X1_UNSIGNED_BYTE:return bL(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function Wlt(n){return at().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Dn.PACKED_2X2_FLOAT32:Dn.UNPACKED_FLOAT32:n?Dn.PACKED_2X2_FLOAT16:Dn.UNPACKED_FLOAT16}function ZN(n,t){if(n===Hs.UPLOAD)return Dn.PACKED_2X2_FLOAT32;if(n===Hs.RENDER||n==null)return Wlt(t);if(n===Hs.DOWNLOAD||n===Hs.PIXELS)return Dn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function QN(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class nr{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const wi="if (isnan(x)) return x;",Hlt="return x;",tA="return abs(x);",qlt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Klt=wi+`
  return (x < 0.0) ? 0.0 : x;
`,Xlt=wi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ko="return x;",Ylt="return 1.0 / (1.0 + exp(-1.0 * x));";const Jlt="return x;",Zlt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Qlt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tct=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ect="return 1.0 / (1.0 + exp(-1.0 * x));";class No{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class nct{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length);const e=t.length,s=es("rc",e),i=Te(e),r=Plt(e,s),o=s.slice(-2),l=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}const sct=qD,ict=1e-7,rct=1e-4,nm={};function oct(n){return n in nm||(nm[n]={}),nm[n]}const act=at().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),lct=600;function cct(){return at().global.screen==null?1024:at().global.screen.height*at().global.screen.width*window.devicePixelRatio*lct/1024/1024}class Dy extends Jw{nextDataId(){return Dy.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!at().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof Hx)e=t;else{const s=ji(at().getNumber("WEBGL_VERSION"),t);e=new Hx(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=ji(at().getNumber("WEBGL_VERSION"));e=new Hx(s),this.binaryCache=oct(at().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Ult(this.gpgpu),this.numMBBeforeWarning=cct(),this.texData=new vR(this,Ji())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,s,i,r,o){const l=this.makeTensorInfo(e,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:t,texShape:[i,r]},c.texShape=[i,r];const h=tm(e),d=new YN(h,!1,o),p=this.runWebGLProgram(d,[l],s,[[i,r]]);return p.shape=e,c.texture=null,this.disposeIntermediateTensorInfo(l),p.dataId}write(t,e,s){if((at().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||at().getBool("DEBUG"))&&this.checkNumericalProblems(t),s==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:e,dtype:s,values:t,usage:Hs.UPLOAD,refCount:1}),i}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,s,i,r){if(at().getBool("DEBUG")&&this.checkNumericalProblems(e),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:i,values:e,usage:Hs.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:s,dtype:i,complexTensorInfos:r,slice:o,shape:l,isPacked:c}=e;if(o!=null){let m;c?m=new No(l,ko):m=new nr(l,ko);const y=this.runWebGLProgram(m,[{dataId:t,shape:l,dtype:i}],i),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(t);if(i==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=cs());let p;if(i==="complex64"){const m=this.readSync(r.real.dataId),y=this.readSync(r.imag.dataId);p=Wr(m,y)}else p=this.getValuesFromTexture(t);return h&&(this.downloadWaitMs+=cs()-d),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){const b=this.pendingRead.get(t);return new Promise(x=>b.push(x))}const e=this.texData.get(t),{values:s,shape:i,slice:r,dtype:o,complexTensorInfos:l,isPacked:c}=e;if(r!=null){let b;c?b=new No(i,ko):b=new nr(i,ko);const x=this.runWebGLProgram(b,[{dataId:t,shape:i,dtype:o}],o),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(t);if(at().getBool("DEBUG")&&!at().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&at().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(o!=="complex64"&&at().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(t);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Jp(i))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(o==="complex64"){const b=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),x=b[0],w=b[1];p=Wr(x,w)}else if(h==null)p=this.getValuesFromTexture(t);else{const b=ft(i);p=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;kt(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(t,p),y=this.pendingRead.get(t);return this.pendingRead.delete(t),y.forEach(b=>b(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Ji().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){const s=this.texData.get(t),{values:i,shape:r,slice:o,dtype:l,isPacked:c,texture:h}=s;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let y;c?y=new No(r,ko):y=new nr(r,ko);const b=this.runWebGLProgram(y,[{dataId:t,shape:r,dtype:l}],l),x=this.readToGPU(b,e);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(t,e.customTexShape),p=Ji().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const s=e.map(i=>Fo(i));return Jt(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Jt(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const s=t[e];if(!dot(s))throw at().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:s,isPacked:i}=this.texData.get(t),r=ft(e);if(at().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(t),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Jp(e)).subarray(0,r);return this.disposeIntermediateTensorInfo(m),b}const o=at().getBool("WEBGL_PACK")&&i===!0,l=o?tm(e):e,c=o?new Iat(l):new Eat(l),h=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:t}],"float32"),d=this.texData.get(h.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(h),p}timerAvailable(){return at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,t();const r=Ha(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Ha(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=e,i&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(r);l.kernelMs=w6(c),l.getExtraProfileInfo=()=>c.map((h,d)=>({name:o[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:cs(),endMs:null}}endTimer(t){return at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=cs(),t)}async getQueryTime(t){if(at().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return s!=null&&(this.disposeData(s.real.dataId,e),this.disposeData(s.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:s,texShape:i,usage:r,isPacked:o,slice:l}=this.texData.get(t),c=l&&l.origDataId||t,h=this.dataRefCount.get(c);h>1?this.dataRefCount.set(c,h-1):(this.dataRefCount.delete(c),e!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(e,i,r,o)));const d=this.texData.get(t);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=act){return at().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>this.texData.get(s.dataId).texture==null&&ft(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){Ws("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return sct(t.shape,e)}packedUnaryOp(t,e,s){const i=new No(t.shape,e),r=this.compileAndRun(i,[t],s);return Ji().makeTensorFromTensorInfo(r)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const i=SL(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,i)}if(at().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,tA,t.dtype);const e=new nr(t.shape,tA),s=this.compileAndRun(e,[t]);return Ji().makeTensorFromTensorInfo(s)}makeTensorInfo(t,e,s){let i;if(e==="string"&&s!=null&&s.length>0&&td(s[0])){const r=s.map(o=>_o(o));i=this.write(r,t,e)}else i=this.write(s,t,e);return this.texData.get(i).usage=null,{dataId:i,shape:t,dtype:e}}makeOutput(t,e,s){return Ji().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,s),this)}unpackTensor(t){const e=new nct(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new Blt(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const s=[Vc(t.shape),...Uc(t.shape)],i={dtype:t.dtype,shape:s,dataId:t.dataId},r=[Vc(e),...Uc(e)],o=new kL(r,s),l=!0,c=[s],h=this.runWebGLProgram(o,[i],t.dtype,c,l);return{dataId:h.dataId,shape:e,dtype:h.dtype}}decode(t,e){const s=this.texData.get(t),{isPacked:i,shape:r,dtype:o}=s;if(e!=null){const m=ft(r),y=e[0]*e[1]*4;F(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const l=tm(r);let c;i?c=new $at(l):c=new kat(l);const h=!0,d=[e??Jp(l)],p=this.runWebGLProgram(c,[{shape:l,dtype:o,dataId:t}],o,d,h,e);return{dtype:o,shape:r,dataId:p.dataId}}runWebGLProgram(t,e,s,i,r=!1,o){const l=this.makeTensorInfo(t.outputShape,s),c=this.texData.get(l.dataId);if(t.packedOutput&&(c.isPacked=!0),t.outPackingScheme===Gh.DENSE){const S=o??Jp(t.outputShape);c.texShape=S.map(T=>T*2)}if(t.outTexUsage!=null&&(c.usage=t.outTexUsage),ft(l.shape)===0)return c.values=Hn(l.dtype,0),l;const h=[],d=e.map(S=>{if(S.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(S.dataId);if(T.texture==null){if(!t.packedInputs&&ft(S.shape)<=at().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:S.shape,texData:null,isUniform:!0,uniformValues:T.values};t.packedInputs&&(T.isPacked=!0,T.shape=S.shape)}if(this.uploadToGPU(S.dataId),!!T.isPacked!=!!t.packedInputs)S=T.isPacked?this.unpackTensor(S):this.packTensor(S),h.push(S),T=this.texData.get(S.dataId);else if(T.isPacked&&!Zm(T.shape,S.shape)){const k=S,$=S.shape;S.shape=T.shape,S=this.packedReshape(S,$),h.push(S),T=this.texData.get(S.dataId),k.shape=$}return{shape:S.shape,texData:T,isUniform:!1}});this.uploadToGPU(l.dataId);const p={shape:l.shape,texData:c,isUniform:!1},m=Tat(t,d,p),y=this.getAndSaveBinary(m,()=>Sat(this.gpgpu,t,d,p)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),at().get("ENGINE_COMPILE_ONLY")||Cat(this.gpgpu,y,d,p,i),h.forEach(S=>this.disposeIntermediateTensorInfo(S)),b&&(x=this.endTimer(x),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(x)}));const w=at().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const S=cs();S-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=S)}if(!at().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&r===!1){const S=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),S}return l}compileAndRun(t,e,s,i,r=!1){return s=s||e[0].dtype,this.runWebGLProgram(t,e,s,i,r)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(at().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=it(()=>{if(!at().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=at().getBool("DEBUG");at().set("DEBUG",!1);const e=this.abs(pe(1e-8)).dataSync()[0];if(at().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?ict:rct}uploadToGPU(t){const e=this.texData.get(t),{shape:s,dtype:i,values:r,texture:o,usage:l,isPacked:c}=e;if(o!=null)return;const h=this.activeTimers!=null;let d;h&&(d=cs());let p=e.texShape;if(p==null&&(p=Aot(s,c),e.texShape=p),r!=null){const m=tm(s);let y,b=p[1],x=p[0];const w=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(c||!w)&&([b,x]=tu(p[0],p[1])),c?y=new Aat(m,w):y=new YN(m,w);const S=w?[x,b]:p,T=this.makeTensorInfo(S,i),k=this.texData.get(T.dataId);w?k.usage=Hs.PIXELS:k.usage=Hs.UPLOAD,k.texShape=S,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),b,x,r);const $=[[x,b]],N=this.runWebGLProgram(y,[T],i,$,!0),_=this.texData.get(N.dataId);e.texShape=_.texShape,e.isPacked=_.isPacked,e.usage=_.usage,at().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(e.texture=_.texture,e.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(T),h&&(this.uploadWaitMs+=cs()-d)}else{const m=this.acquireTexture(p,l,i,c);e.texture=m}}convertAndCacheOnCPU(t,e){const s=this.texData.get(t),{dtype:i}=s;return e!=null&&(s.values=uct(e,i)),s.values}acquireTexture(t,e,s,i){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,i)}computeBytes(t,e){return t[0]*t[1]*$m(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(e),i(!0)}catch(r){throw r}});t.push(s)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await dO(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(uL(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:s,infLoc:i,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:c}=mL(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=s,t.infLoc=i,t.nanLoc=r,t.outShapeLocation=o,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}createTensorFromGPUData(t,e,s){t.channels=t.channels||"RGBA";const{texture:i,height:r,width:o,channels:l}=t,c=Ji().backend;if(!c.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=c.writeTexture(i,e,s,r,o,l);return Ji().makeTensorFromDataId(h,e,s,c)}}Dy.nextDataId=0;function uct(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}else throw new Error(`Unknown dtype ${t}`)}lD()&&hD("webgl",()=>new Dy,2);const RC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class rl{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=Ht(e,s),this.enableShapeUniforms=Jn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const pl=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ru{constructor(t,e,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ht(e,s);const r=this.outputShape.length;this.enableShapeUniforms=Jn(r);let o="";if(i)if(r===0||ft(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Te(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=es("coords",r);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${c[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${c[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${c[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${c[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function _s(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const hct={kernelName:wd,backendName:"webgl",kernelFunc:_s};function Qo(n){const{inputs:t,backend:e}=n,{real:s,imag:i}=t,r=e.makeTensorInfo(s.shape,"complex64"),o=e.texData.get(r.dataId),l=_s({inputs:{x:s},backend:e}),c=_s({inputs:{x:i},backend:e});return o.complexTensorInfos={real:l,imag:c},r}const dct={kernelName:h1,backendName:"webgl",kernelFunc:Qo};const $L="return (a < 0.) ? b * a : a;",EL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function fct(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{alpha:r}=s,o=e.makeTensorInfo([],"float32",Go(r,"float32")),l=at().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(EL,i.shape,o.shape):new rl($L,i.shape,o.shape),c=e.runWebGLProgram(l,[i,o],"float32");return e.disposeIntermediateTensorInfo(o),c}const pct={kernelName:Ng,backendName:"webgl",kernelFunc:fct};const IL="return (a < 0.) ? b * a : a;",NL=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function mct(n){const{inputs:t,backend:e}=n,{x:s,alpha:i}=t,r=at().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(NL,s.shape,i.shape):new rl(IL,s.shape,i.shape);return e.runWebGLProgram(r,[s,i],"float32")}const gct={kernelName:Kg,backendName:"webgl",kernelFunc:mct};const ou="if (isnan(x)) return x;";function le({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:i,backend:r})=>{const{x:o}=i,l=r,c=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&e!=null){const p=l.texData.get(o.dataId),m=e(p.values,c);return l.makeTensorInfo(o.shape,c,m)}const h=at().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let d;return h?d=new No(o.shape,t):d=new nr(o.shape,n),l.runWebGLProgram(d,[o],c)}}function Ln({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:r}){return({inputs:o,backend:l})=>{const{a:c,b:h}=o,d=l;if(s&&c.dtype==="complex64"){const b=d.texData.get(c.dataId),x=d.texData.get(h.dataId),[w,S]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(k=>{const[$,E]=k,N={dataId:$.dataId,dtype:$.dtype,shape:c.shape},_={dataId:E.dataId,dtype:E.dtype,shape:h.shape},R=new rl(n,c.shape,h.shape);return d.runWebGLProgram(R,[N,_],Ns($.dtype,E.dtype))}),T=Qo({inputs:{real:w,imag:S},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(S),T}const p=r||Ns(c.dtype,h.dtype);if((c.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([c,h]))&&i!=null){const b=d.texData.get(c.dataId).values,x=d.texData.get(h.dataId).values,w=c.dtype==="string"?Hr(b):b,S=c.dtype==="string"?Hr(x):x,[T,k]=i(c.shape,h.shape,w,S,p),$=d.makeTensorInfo(k,p),E=d.texData.get($.dataId);return E.values=T,$}const m=at().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let y;return m?y=new ru(t,c.shape,h.shape,e):y=new rl(n,c.shape,h.shape),d.runWebGLProgram(y,[c,h],p)}}function Wh(n,t=!1){if(n==="linear")return t?Jlt:Hlt;if(n==="relu")return t?Qlt:Klt;if(n==="elu")return t?Zlt:qlt;if(n==="relu6")return t?tct:Xlt;if(n==="prelu")return t?NL:IL;if(n==="leakyrelu")return t?EL:$L;if(n==="sigmoid")return t?ect:Ylt;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class AL{constructor(t,e,s,i=!1,r=!1,o=!1,l=null,c=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Jn(this.outputShape.length);const d=i?t[1]:t[2],p=Math.ceil(d/2),m=i?"i * 2, rc.y":"rc.y, i * 2",y=r?"rc.z, i * 2":"i * 2, rc.z",b=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",S="";l&&(c?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:w=`vec4 activation(vec4 x) {
          ${l}
        }`,S="result = activation(result);");const T=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let k="rc.x",$="rc.x";t[0]<e[0]?k=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&($=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${k};
        int batchB = ${$};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${S}

        setOutput(result);
      }
    `}}const eA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class nA{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ht(e,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const sA="return a * b;";function DC(n){const{inputs:t,backend:e}=n,{a:s,b:i}=t,r=Ns(s.dtype,i.dtype);if(s.dtype==="complex64"){const l=e.texData.get(s.dataId),c=e.texData.get(i.dataId),h=new nA(eA.REAL,s.shape,i.shape),d=new nA(eA.IMAG,s.shape,i.shape),p=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape}],m=e.runWebGLProgram(h,p,"float32"),y=e.runWebGLProgram(d,p,"float32"),b=Qo({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}if(e.shouldExecuteOnCPU([s,i])){const l=e.texData.get(s.dataId),c=e.texData.get(i.dataId),[h,d]=mlt(s.shape,i.shape,l.values,c.values,r),p=e.makeTensorInfo(d,r),m=e.texData.get(p.dataId);return m.values=h,p}let o;return at().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new ru(sA,s.shape,i.shape):o=new rl(sA,s.shape,i.shape),e.runWebGLProgram(o,[s,i],r)}const yct={kernelName:Ad,backendName:"webgl",kernelFunc:DC};function bct(n,t,e){const s=[Vc(n.shape),...Uc(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},r=[Vc(t),...Uc(t)],o=new kL(r,s),l=!0,c=[s],h=e.runWebGLProgram(o,[i],n.dtype,c,l);return{dataId:h.dataId,shape:t,dtype:h.dtype}}function Tt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{shape:r}=s,o=e,l=ft(i.shape),c=wR(r,l),h=ft(c);F(l===h,()=>`The new shape (${c}) has ${h} elements and the old shape (${i.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(i.dataId);return d.isPacked&&!Zm(i.shape,c)&&!(d.texture!==null&&Zm(d.shape,c))?bct(i,c,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:c,dtype:i.dtype})}const xct={kernelName:Yg,backendName:"webgl",kernelFunc:Tt};class iA{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=t;this.outputShape=[i,o];const l=Math.floor(s/4)*4,c=s%4;let h="sumValue += dot(values, ones);";if(e!=null){const p=1/e;h=`sumValue += dot(values * ${Rc(p)?p.toPrecision(2):p}, ones);`}let d="";r%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class vct{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=t;this.outputShape=[i,o];let l="0.0",c="";e==="prod"?l="1.0":e==="min"?(l="1.0 / 1e-20",c="min"):e==="max"&&(l="-1.0 / 1e-20",c="max");let h=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?h="sumValue":e==="prod"?h="prodValue":e==="all"?h="allValue":e==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,p=s%4;let m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";e==="all"?(l="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):e==="any"&&(l="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";r%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function wct(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],s=yy(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}function ml(n,t,e,s){const i=wct(n.shape);let r=n;for(let o=0;o<i.length;o++){const{inSize:l,windowSize:c,outSize:h}=i[o];let d,p;e==="mean"?d=o===0?new iA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},l):new iA({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h}):d=new vct({windowSize:c,inSize:l,batchSize:n.shape[0],outSize:h},e),p=r,r=s.runWebGLProgram(d,[r],t),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return r}class Sct{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[e[o]];this.outputShape=s,this.rank=s.length;const i=Te(this.rank),r=Cct(e);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}}function Cct(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let i=0;i<n.length;i++)s[n[i]]=e[i];return s.join()}class Tct{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let d=0;d<s.length;d++)s[d]=t[e[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Te(this.rank),r=TL("rc",this.rank),o=new Array(this.rank);for(let d=0;d<e.length;d++)o[e[d]]=r[d];const l=`vec2(${o.slice(-2).join()})`,c=`++${r[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${o.join()}), ${l})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${c}) {
        result[1] = ${h};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${c}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function Oy(n,t,e){const s=at().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Tct(n.shape,t):new Sct(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function kct(n,t,e,s){const i=t,r=n.shape.length,o=Zt(i,n.shape);let l=o;const c=We(l,r),h=c!=null;let d=n;h&&(d=Oy(n,c,s),l=nn(l.length,r)),Fn("sum",l,r);const[p,m]=An(d.shape,l);let y=p;e&&(y=cn(p,o));const b=ft(m),w=ft(n.shape)/b,S=Tt({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),T=W1(n.dtype),k=ml(S,T,"sum",s),$=Tt({inputs:{x:k},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(k),h&&s.disposeIntermediateTensorInfo(d),$}function My(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s;return kct(i,r,o,e)}const $ct={kernelName:ny,backendName:"webgl",kernelFunc:My};function is(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{perm:r}=s,o=e,l=i.shape.length,c=new Array(l);for(let d=0;d<c.length;d++)c[d]=i.shape[r[d]];let h;if(o.shouldExecuteOnCPU([i])){const p=o.texData.get(i.dataId).values,m=_C(p,i.shape,i.dtype,r,c);h=o.makeTensorInfo(c,i.dtype);const y=o.texData.get(h.dataId);y.values=m}else h=Oy(i,r,o);return h}const Ect={kernelName:$c,backendName:"webgl",kernelFunc:is};const _L=1e3;function Qm({a:n,b:t,transposeA:e,transposeB:s,backend:i,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:c=null}){const h=n.shape.length,d=t.shape.length,p=e?n.shape[h-2]:n.shape[h-1],m=s?t.shape[d-1]:t.shape[d-2],y=e?n.shape[h-1]:n.shape[h-2],b=s?t.shape[d-2]:t.shape[d-1],x=n.shape.slice(0,-2),w=t.shape.slice(0,-2),S=ft(x),T=ft(w),$=Ht(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([y,b]);F(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const E=e?[S,p,y]:[S,y,p],N=s?[T,b,m]:[T,m,b],_=Tt({inputs:{x:n},backend:i,attrs:{shape:E}}),R=Tt({inputs:{x:t},backend:i,attrs:{shape:N}}),D=[_,R],M=Math.max(S,T),A=e?_.shape[1]:_.shape[2],B=r!=null,H=o!=null,J=c==="leakyrelu",X=c!=null?Wh(c,!0):null,z=B||H||J||X!=null;let P;if((y===1||b===1)&&A>_L&&z===!1){let K=_,st=R;e&&(K=is({inputs:{x:_},backend:i,attrs:{perm:[0,2,1]}}),D.push(K)),s&&(st=is({inputs:{x:R},backend:i,attrs:{perm:[0,2,1]}}),D.push(st));const L=b!==1,j=b===1;let Q=K;L&&(Q=Tt({inputs:{x:K},backend:i,attrs:{shape:[M,A,1]}}),D.push(Q));const ct=b===1?2:1;let ut=st;j&&(ut=Tt({inputs:{x:st},backend:i,attrs:{shape:[M,1,A]}}),D.push(ut));const pt=DC({inputs:{a:Q,b:ut},backend:i});P=My({inputs:{x:pt},backend:i,attrs:{axis:ct,keepDims:!0}}),D.push(pt)}else{const K=Ns(n.dtype,t.dtype),st=new AL(E,N,[M,y,b],e,s,B,X,H,J),L=[_,R];if(r!=null&&L.push(r),H&&L.push(o),J){const j=i.makeTensorInfo([],"float32",Go(l,"float32"));L.push(j),D.push(j)}P=i.runWebGLProgram(st,L,K)}const V=Tt({inputs:{x:P},backend:i,attrs:{shape:$}});D.push(P);for(const K of D)i.disposeIntermediateTensorInfo(K);return V}function Ict(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:l}=t,{transposeA:c,transposeB:h,activation:d,leakyreluAlpha:p}=s;return Qm({a:i,b:r,transposeA:c,transposeB:h,backend:e,bias:o,preluActivationWeights:l,leakyreluAlpha:p,activation:d})}const Nct={kernelName:Em,backendName:"webgl",kernelFunc:Ict};const rA="return abs(x);";function Act(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const r=e.texData.get(s.dataId),o=SL(r.values);return e.makeTensorInfo(s.shape,s.dtype,o)}let i;return at().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new No(s.shape,rA):i=new nr(s.shape,rA),e.runWebGLProgram(i,[s],s.dtype)}const _ct={kernelName:cg,backendName:"webgl",kernelFunc:Act};const Rct=wi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Dct=le({opSnippet:Rct}),Oct={kernelName:ed,backendName:"webgl",kernelFunc:Dct};const Mct=wi+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Fct=le({opSnippet:Mct}),Lct={kernelName:nd,backendName:"webgl",kernelFunc:Fct};const oA="return a + b;",zct=Ln({opSnippet:oA,packedOpSnippet:oA,supportsComplex:!0,cpuKernelImpl:Kat}),Pct={kernelName:Kc,backendName:"webgl",kernelFunc:zct};class Bct{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}class Vct{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}function gm(n){const{inputs:t,backend:e}=n,s=t;if(s.length===1)return _s({inputs:{x:s[0]},backend:e});if(s.length>at().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),h=gm({inputs:s.slice(0,c),backend:e}),d=gm({inputs:s.slice(c),backend:e});return gm({inputs:[h,d],backend:e})}const i=s.map(c=>c.dtype).reduce((c,h)=>Ns(c,h)),r=s.map(c=>c.shape),l=at().getBool("WEBGL_PACK")?new Vct(s[0].shape,r):new Bct(s[0].shape,r);return e.runWebGLProgram(l,s,i)}const Uct={kernelName:i1,backendName:"webgl",kernelFunc:gm};function jct(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s,l=i.shape.length,c=Zt(r,i.shape);let h=c;const d=We(h,l);let p=i;d!=null&&(p=is({inputs:{x:i},backend:e,attrs:{perm:d}}),h=nn(h.length,l)),Fn("all",h,l);const[m,y]=An(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"all",e);let S;if(o){const T=cn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const Gct={kernelName:r1,backendName:"webgl",kernelFunc:jct};function Wct(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s,l=i.shape.length,c=Zt(r,i.shape);let h=c;const d=We(h,l);let p=i;d!=null&&(p=is({inputs:{x:i},backend:e,attrs:{perm:d}}),h=nn(h.length,l)),Fn("any",h,l);const[m,y]=An(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"any",e);let S;if(o){const T=cn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const Hct={kernelName:o1,backendName:"webgl",kernelFunc:Wct};class qct{constructor(t,e,s){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const l=e==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class Kct{constructor(t,e,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,F(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const r=t[t.length-1],o=Math.ceil(r/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const l=this.outputShape,c=l.length,h=Te(c),d=es("coords",c);let p,m;if(o===1){m=c+1;const R=Te(m);p=`
        ${R} sourceLocR = ${R}(${d.join()}, 0);
        ++${d[c-1]};
        ${R} sourceLocG = ${R}(${d.join()}, 0);
        ++${d[c-2]};
        ${R} sourceLocA = ${R}(${d.join()}, 0);
        --${d[c-1]};
        ${R} sourceLocB = ${R}(${d.join()}, 0);
        --${d[c-2]};`}else m=c,p=`
        ${h} sourceLocR = coords;
        ++${d[c-1]};
        ${h} sourceLocG = coords;
        ++${d[c-2]};
        ${h} sourceLocA = coords;
        --${d[c-1]};
        ${h} sourceLocB = coords;
        --${d[c-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(R=>"int "+R),w=es("sourceLocR",m-1).concat("inIdx.r"),S=es("sourceLocG",m-1).concat("inIdx.g"),T=es("sourceLocB",m-1).concat("inIdx.b"),k=es("sourceLocA",m-1).concat("inIdx.a"),$=s==="max"?"greaterThan":"lessThan",E=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${k.join()})));`,N=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${S.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${k.join()}) : 0.)`,_=i?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[c-1]} < ${l[c-1]-1};
        bool hasNextRow = ${d[c-2]} < ${l[c-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${N};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${N};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function RL(n,t,e,s=null){let i=t.shape[0],r=t.shape[1];s!=null&&(i=s.shape[0],r=s.shape[1]);const o=yy(r),l={windowSize:o,inSize:r,batchSize:i,outSize:Math.ceil(r/o)},c=new qct(l,e,s==null),h=[t];s!=null&&h.push(s);const d=n.runWebGLProgram(c,h,"int32");if(d.shape[1]===1)return d;const p=RL(n,t,e,d);return n.disposeIntermediateTensorInfo(d),p}function DL(n,t,e,s=null){const i=s!=null?s.shape:t.shape,r=i[i.length-1],o=yy(r),l=new Kct(i,o,e,s==null),c=s==null?[t]:[t,s],h=n.runWebGLProgram(l,c,"int32");if(h.shape.length===t.shape.length){const d=DL(n,t,e,h);return n.disposeIntermediateTensorInfo(h),d}return h}function OL(n,t,e,s){const i=[e];if(Fn("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,t.shape.length),!at().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const r=[],o=n.texData.get(t.dataId),l=o!==null&&o.isPacked;let c=t;l&&(c=n.unpackTensor(t),r.push(c));const[h,d]=An(c.shape,i),p=ft(d),m=Tt({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});r.push(m);const y=RL(n,m,s);r.push(y);const b=Tt({inputs:{x:y},backend:n,attrs:{shape:h}});return r.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return DL(n,t,s)}function Xct(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;let o=Zt(r,i.shape);const l=We(o,i.shape.length);let c=i;const h=[];l!=null&&(c=is({inputs:{x:i},backend:e,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),Fn("argMax",[o[0]],c.shape.length);const d=OL(e,c,o[0],"max");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}const Yct={kernelName:ug,backendName:"webgl",kernelFunc:Xct};function Jct(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r}=s;let o=Zt(r,i.shape);const l=We(o,i.shape.length);let c=i;const h=[];l!=null&&(c=is({inputs:{x:i},backend:e,attrs:{perm:l}}),h.push(c),o=nn(o.length,c.shape.length)),Fn("argMin",[o[0]],c.shape.length);const d=OL(e,c,o[0],"min");return h.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}const Zct={kernelName:hg,backendName:"webgl",kernelFunc:Jct};const Qct=wi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,tut=le({opSnippet:Qct}),eut={kernelName:sd,backendName:"webgl",kernelFunc:tut};const nut=wi+"return log(x + sqrt(x * x + 1.0));",sut=le({opSnippet:nut}),iut={kernelName:id,backendName:"webgl",kernelFunc:sut};const rut=wi+`
  return atan(x);
`,out=le({opSnippet:rut}),aut={kernelName:rd,backendName:"webgl",kernelFunc:out};const lut=RC+`
  return atan(a, b);
`,cut=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,uut=Ln({opSnippet:lut,packedOpSnippet:cut}),hut={kernelName:ad,backendName:"webgl",kernelFunc:uut};const dut=wi+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,fut=le({opSnippet:dut}),put={kernelName:od,backendName:"webgl",kernelFunc:fut};class Hh{constructor(t,e,s,i=!1,r=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,l=t.strideHeight,c=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const x=e==="avg",w=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,S=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let T="0.0";if(x||(T="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${l}, ${c});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?w:S:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const k="max";let $=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&($="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,N=o%4,_=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${E};
          if (${N===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${N===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${$});
      }
    `}}class OC{constructor(t,e,s,i=!1,r=!1){if(this.variableNames=["x"],e==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,l=t.strideDepth,c=t.strideHeight,h=t.strideWidth,d=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,y=t.effectiveFilterDepth,b=t.effectiveFilterHeight,x=t.effectiveFilterWidth,w=t.padInfo.front,S=t.padInfo.top,T=t.padInfo.left;this.outputShape=t.outShape;const k=e==="avg";let $="0.0";if(k||($="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${c}, ${h});
        const ivec3 pads = ivec3(${w}, ${S}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let N=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(N="avgValue / max(count, 1.0)");const _=Math.floor(o/4)*4,R=o%4,D=`
      if (${k}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${c}, ${h});
      const ivec3 pads = ivec3(${w}, ${S}, ${T});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${_};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${N});
      }
    `}}function mut(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;yf(i,"avgPool");const{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=s,h=1;F(Xn(o,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=xi(i.shape,r,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&me(d.inShape,d.outShape))return _s({inputs:{x:i},backend:e});const p=new Hh(d,"avg",!1);return e.runWebGLProgram(p,[i],"float32")}const gut={kernelName:dg,backendName:"webgl",kernelFunc:mut};function yut(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:o,pad:l,dimRoundingMode:c,dataFormat:h}=s,d=[1,1,1],p=Xr(i.shape,r,o,d,l,c,h),m=new OC(p,"avg",!1);return e.runWebGLProgram(m,[i],"float32")}const but={kernelName:fg,backendName:"webgl",kernelFunc:yut};class xut{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i=t.strideHeight,r=t.strideWidth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=c-1-t.padInfo.top,p=h-1-t.padInfo.left,m=1/(e*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class vut{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,i=t.filterWidth,r=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=p-1-t.padInfo.front,x=m-1-t.padInfo.top,w=y-1-t.padInfo.left,S=1/(e*s*i);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function wut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,o=r,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Xr(o.shape,l,c,p,h,d),y=new vut(m);return e.runWebGLProgram(y,[i],o.dtype)}const Sut={kernelName:l1,backendName:"webgl",kernelFunc:wut};function Cut(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,o=r;yf([i,r],"avgPoolGrad");const{filterSize:l,strides:c,pad:h}=s,d=xi(o.shape,l,c,1,h),p=new xut(d);return e.runWebGLProgram(p,[i],o.dtype)}const Tut={kernelName:a1,backendName:"webgl",kernelFunc:Cut};function kut(n){const{inputs:t,backend:e,attrs:s}=n,{a:i,b:r}=t,{transposeA:o,transposeB:l}=s;return Qm({a:i,b:r,transposeA:o,transposeB:l,backend:e})}const $ut={kernelName:pg,backendName:"webgl",kernelFunc:kut};class Eut{constructor(t,e,s,i,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ht(t,e),Ht(t,s);let l="0.0";i!=null&&(Ht(t,i),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="1.0";r!=null&&(Ht(t,r),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Iut{constructor(t,e,s,i,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ht(t,e),Ht(t,s);let l="vec4(0.0)";i!=null&&(Ht(t,i),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let c="vec4(1.0)";r!=null&&(Ht(t,r),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const Nut=({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:i,variance:r,offset:o,scale:l}=n;F(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(l==null||i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=e;c==null&&(c=.001);const h=[s,i,r];let d=null;o!=null&&(d=o.shape,h.push(o));let p=null;l!=null&&(p=l.shape,h.push(l));const m=at().getBool("WEBGL_PACK_NORMALIZATION")?new Iut(s.shape,i.shape,r.shape,d,p,c):new Eut(s.shape,i.shape,r.shape,d,p,c);return t.runWebGLProgram(m,h,h[0].dtype)},Aut={kernelName:$g,backendName:"webgl",kernelFunc:Nut};class _ut{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=Te(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Rut(this.rank);let i;const r=t.map((o,l)=>`sourceLoc.${lw[l]} = start[${l}] + coords.${lw[l]};`);i=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}}const lw=["x","y","z","w","u","v"];function Rut(n){if(n===1)return"sourceLoc";if(n<=6)return lw.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Dut{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Te(this.rank),s=es("coords",this.rank),i=es("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${r})`,l=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((d,p)=>`start[${p}]`).join()});`:t.map((d,p)=>`${i[p]} = ${s[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${l}
        ${c}
        setOutput(result);
      }
    `}}function Out(n,t,e,s){const i=s.texData.get(n.dataId),r=s.makeTensorInfo(e,n.dtype),o=s.texData.get(r.dataId);Object.assign(o,i),o.refCount=1,o.shape=e,o.dtype=n.dtype;let l=NS(t,Ot(n.shape));i.slice&&(l+=i.slice.flatOffset),o.slice={flatOffset:l,origDataId:i.slice&&i.slice.origDataId||n.dataId};const c=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,c+1),r}function au(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,size:o}=s,[l,c]=gy(i,r,o);if($S(i,l,c),ft(c)===0)return e.makeTensorInfo(c,i.dtype,[]);if(e.shouldExecuteOnCPU([i])||i.dtype==="string"){const p=e.texData.get(i.dataId),m=$lt(p.values,l,c,i.shape,i.dtype);return e.makeTensorInfo(c,i.dtype,m)}const{isPacked:h}=e.texData.get(i.dataId),d=IS(i.shape,l,c);if(h||!d){const p=at().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dut(c):new _ut(c),m=[l];return e.runWebGLProgram(p,[i],i.dtype,m)}return e.uploadToGPU(i.dataId),Out(i,l,c,e)}const Mut={kernelName:ey,backendName:"webgl",kernelFunc:au};const Fut=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,crops:o}=s;F(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const l=r.reduce((T,k)=>T*k),c=sf(i.shape,r,l),h=rf(c.length,r.length),d=of(i.shape,r,l),p=OS(o,r.length),m=MS(d,o,r.length),y=[],b=Tt({inputs:{x:i},backend:e,attrs:{shape:c}}),x=is({inputs:{x:b},backend:e,attrs:{perm:h}}),w=Tt({inputs:{x},backend:e,attrs:{shape:d}}),S=au({inputs:{x:w},backend:e,attrs:{begin:p,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(T=>e.disposeIntermediateTensorInfo(T)),S},Lut={kernelName:mg,backendName:"webgl",kernelFunc:Fut};function zut(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:o}=s,l=e.readSync(i.dataId),c=e.readSync(r.dataId),h=wL(l,c,r.dtype,r.shape,o);return e.makeTensorInfo([o],r.dtype,h)}const Put={kernelName:c1,backendName:"webgl",kernelFunc:zut};const But=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Vut=`
  return float(int(a.r) & int(b.r));
`;function Uut(n){const{inputs:t,backend:e}=n,{a:s,b:i}=t,r=at().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=at().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,i])||o===1){const c=e.texData.get(s.dataId).values,h=e.texData.get(i.dataId).values,[d,p]=Yat(s.shape,i.shape,c,h,s.dtype),m=e.makeTensorInfo(p,s.dtype),y=e.texData.get(m.dataId);return y.values=d,m}let l;return r?l=new ru(But,s.shape,i.shape,!1):l=new rl(Vut,s.shape,i.shape),e.runWebGLProgram(l,[s,i],s.dtype)}const jut={kernelName:u1,backendName:"webgl",kernelFunc:Uut};function Gut(n){const{inputs:t,backend:e}=n,{s0:s,s1:i}=t,r=e.readSync(s.dataId),o=e.readSync(i.dataId),l=Ht(Array.from(r),Array.from(o));return e.makeTensorInfo([l.length],"int32",Int32Array.from(l))}const Wut={kernelName:ER,backendName:"webgl",kernelFunc:Gut};const Hut="return float(a != b);",ML=Ln({opSnippet:Hut,cpuKernelImpl:ylt,dtype:"bool"}),qut={kernelName:jg,backendName:"webgl",kernelFunc:ML};function xf(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.texData.get(s.dataId);return _s({inputs:{x:i.complexTensorInfos.real},backend:e})}const Kut={kernelName:M1,backendName:"webgl",kernelFunc:xf};const Xut="return float(int(x));";function Yut(n,t){const e=new nr(n.shape,Xut),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function cw(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return _s({inputs:{x:i},backend:e});const o=In(i.shape),l=cw({inputs:{x:i},backend:e,attrs:{dtype:"float32"}}),c=Qo({inputs:{real:l,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(l),c}if(i.dtype==="complex64"){const o=xf({inputs:{input:i},backend:e}),l=cw({inputs:{x:o},backend:e,attrs:{dtype:r}});return e.disposeIntermediateTensorInfo(o),l}if(!SR(i.dtype,r)){const o=_s({inputs:{x:i},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:r}}if(e.shouldExecuteOnCPU([i])){const o=e.texData.get(i.dataId).values,[l,c,h]=Jat(o,i.shape,i.dtype,r);return e.makeTensorInfo(l,c,h)}if(r==="int32")return Yut(i,e);if(r==="bool"){const o=e.makeTensorInfo([],"bool",Hn("bool",1)),c=ML({inputs:{a:i,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),c}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const Jut={kernelName:ld,backendName:"webgl",kernelFunc:cw};const aA="return ceil(x);",Zut=le({opSnippet:aA,packedOpSnippet:aA,cpuKernelImpl:Zat}),Qut={kernelName:cd,backendName:"webgl",kernelFunc:Zut};class tht{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class eht{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function nht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{clipValueMin:r,clipValueMax:o}=s;let l;at().getBool("WEBGL_PACK_CLIP")?l=new eht(i.shape):l=new tht(i.shape);const c=[[r],[o]];return e.runWebGLProgram(l,[i],i.dtype,c)}const sht={kernelName:ud,backendName:"webgl",kernelFunc:nht};class iht{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function lA(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function rht(n){const{inputs:t,backend:e}=n,{x:s}=t,i=e.texData.get(s.dataId),r=new iht(s.shape),o=[lA(s,i.complexTensorInfos.real),lA(s,i.complexTensorInfos.imag)];return e.runWebGLProgram(r,o,o[0].dtype)}const oht={kernelName:gg,backendName:"webgl",kernelFunc:rht};class aht{constructor(t){this.outputShape=[],this.outputShape=ar(t,1),this.variableNames=t.map((o,l)=>`T${l}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++){const l=e[o-1];s.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${l}));`)}const i=e.length,r=e[e.length-1];s.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class lht{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ar(t,e);const s=this.outputShape,i=s.length,r=Te(i),o=es("coords",i),l=["x","y","z","w","u","v"].slice(0,i);this.variableNames=t.map((x,w)=>`T${w}`);const c=new Array(t.length-1);c[0]=t[0][e];for(let x=1;x<c.length;x++)c[x]=c[x-1]+t[x][e];const h=l[e],d=l.slice(-2),p=l.join();let m=`if (${h} < ${c[0]}) {
        return getChannel(
            getT0(${p}), vec2(${d.join()}));
        }`;for(let x=1;x<c.length;x++){const w=c[x-1];m+=`
        if (${h} < ${c[x]}  && ${h} >= ${c[x-1]}) {
          return getChannel(
            getT${x}(${sm(l,h,w)}),
            vec2(${sm(d,h,w)}));
        }`}const y=c.length,b=c[c.length-1];m+=`
        return getChannel(
          getT${y}(${sm(l,h,b)}),
          vec2(${sm(d,h,b)}));`,this.userCode=`
      float getValue(${l.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${s[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${s[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${s[i-2]} &&
            ${o[i-1]} < ${s[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function sm(n,t,e){const s=n.indexOf(t);return n.map((r,o)=>o===s?`${r} - ${e}`:r).join()}function Fy(n){const{inputs:t,backend:e}=n,{input:s}=t,i=e.texData.get(s.dataId);return _s({inputs:{x:i.complexTensorInfos.imag},backend:e})}const cht={kernelName:E1,backendName:"webgl",kernelFunc:Fy};function ph(n,t,e){const s=n[0].dtype;if(s==="complex64"){const y=n.map(T=>xf({inputs:{input:T},backend:e})),b=n.map(T=>Fy({inputs:{input:T},backend:e})),x=ph(y,t,e),w=ph(b,t,e),S=Qo({inputs:{real:x,imag:w},backend:e});return y.forEach(T=>e.disposeIntermediateTensorInfo(T)),b.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),S}let i=e.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const y=n.map($=>{const N=[-1,ft($.shape.slice(t))];return Tt({inputs:{x:$},backend:e,attrs:{shape:N}})}),b=y.map($=>({vals:e.readSync($.dataId),shape:$.shape})),x=ar(y.map($=>$.shape),1),w=y[0].shape[0]===1,S=Qat(b,x,s,w),T=ar(n.map($=>$.shape),t),k=e.makeTensorInfo(T,s,S);return y.forEach($=>e.disposeIntermediateTensorInfo($)),k}const r=n.filter(y=>ft(y.shape)>0),o=at().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const y=o?new nr(n[0].shape,ko):new No(n[0].shape,ko);return e.runWebGLProgram(y,n,s)}const l=at().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>l){const y=[];for(let x=0;x<r.length;x+=l){const w=r.slice(x,x+l);y.push(ph(w,t,e))}const b=ph(y,t,e);for(const x of y)e.disposeIntermediateTensorInfo(x);return b}if(o){const y=new lht(r.map(b=>b.shape),t);return e.runWebGLProgram(y,r,s)}const{tensors2D:c,outShape:h}=uht(r,t,e),d=new aht(c.map(y=>y.shape)),p=e.runWebGLProgram(d,c,s);c.forEach(y=>e.disposeIntermediateTensorInfo(y));const m=Tt({inputs:{x:p},attrs:{shape:h},backend:e});return e.disposeIntermediateTensorInfo(p),m}function uht(n,t,e){const s=ar(n.map(r=>r.shape),t);return{tensors2D:n.map(r=>Tt({inputs:{x:r},attrs:{shape:[-1,ft(r.shape.slice(t))]},backend:e})),outShape:s}}function FL(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s,r=Zt(i,t[0].shape)[0],o=t.map(h=>h.shape);_S(o,r);const l=ar(t.map(h=>h.shape),r);if(ft(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);const c=t.filter(h=>ft(h.shape)>0);return c.length===1?_s({inputs:{x:c[0]},backend:e}):ph(c,r,e)}const hht={kernelName:yg,backendName:"webgl",kernelFunc:FL};class LL{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,l=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,x=t.inChannels%4,w=t.dataFormat==="channelsLast",S=w?1:2,T=w?2:3,k=w?3:1;let $="",E="";s&&(i?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:$=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const N=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${c}, ${h});
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${k}];

        ivec2 xRCCorner =
            ivec2(coords[${S}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${N}
        ${E}
        setOutput(result);
      }
    `}}class dht{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,i=t.padInfo.left,r=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,h=t.dilationHeight,d=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,y=t.filterWidth,b=Math.floor(t.inChannels/4)*4,x=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${o}, ${l});
      const ivec3 pads = ivec3(${e}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zL{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(p+1)/2;w++){const S=w*2;if(m+=`
           xC = xCCorner + ${S*c};
           `,l===1){if(S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }
               `,c===1&&S>0?m+=`
                 xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                   } else {
                     xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xC${S} = xTexelC${S};
                 `,S+1<d)){const T=o%2===0?Zw(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                     xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${S+1}.zw = vec2(0.0);
                     }
                     xTexelC${S+1}Ready = 1;
                   }
                   `,c>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                     } else {
                      xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                     }
                     `:m+=`
                     xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                     `):T===1?m+=`
                     xC${S+1} = xTexelC${S};
                     `:m+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                       xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${S+1}.zw = vec2(0.0);
                       }
                       xTexelC${S+1}Ready = 1;
                     }

                     xC${S+1} = xTexelC${S+1};
                     `}}else S<d&&(o%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.0);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
               `,S+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                   xTexelC${S} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${S}.zw = vec2(0.0);
                   }
                   xTexelC${S}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                   xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${S+1}.zw = vec2(0.);
                   }
                   xTexelC${S+1}Ready = 1;
                 }

                 xC${S} = vec4(
                   xTexelC${S}.xy, xTexelC${S+1}.xy);
               `,S+1<d&&(m+=`
                   xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                 `)));S<d&&(m+=`
             wTexel = getW(r, ${S}, d1, d2);
             dotProd += xC${S}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${S}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,S+1<d&&(m+=`
               wTexel = getW(r, ${S+1}, d1, d2);
               dotProd += xC${S+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${S+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(i?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:r?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class fht{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Jn(this.outputShape.length);const{dataFormat:s}=e,i=rs(),r=s==="channelsLast",o=r?1:2,l=r?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)h+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${d};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${l}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${i.output} = result;
      }
    `}}function tg(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function PL({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape,h=s.texData.get(n.dataId),d=e.inChannels,p=c[0]*c[1]*c[2],m=e.outChannels,y=e.dataFormat==="channelsLast",b=!1,x=!1;let w;const S=[];if(r!=null){const $=tg(r.shape,y);$!=null&&(r=Tt({inputs:{x:r},backend:s,attrs:{shape:$}}),S.push(r))}if(i!=null){const $=tg(i.shape,y);$!=null&&(i=Tt({inputs:{x:i},backend:s,attrs:{shape:$}}),S.push(i))}if(!((p===1||m===1)&&d>_L)&&h.isPacked&&y&&h.texture!=null&&c[2]%2!==0&&me(h.shape.slice(-3),c.slice(-3))){const $=c[0]*c[1]*(c[2]+1),E={dataId:n.dataId,shape:[1,$,e.inChannels],dtype:n.dtype},N=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,F(Zm(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const _=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});S.push(_);const R=Qm({a:E,b:_,backend:s,transposeA:b,transposeB:x,bias:i,activation:l,preluActivationWeights:r,leakyreluAlpha:o}),D=s.texData.get(R.dataId);F(D.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=N,D.shape=e.outShape,w=_s({inputs:{x:R},backend:s}),w.shape=e.outShape,S.push(R)}else{const $=e.outHeight*e.outWidth,E=Tt({inputs:{x:n},backend:s,attrs:{shape:y?[e.batchSize,$,e.inChannels]:[e.batchSize,e.inChannels,$]}}),N=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),_=Qm({a:y?E:N,b:y?N:E,transposeA:!y,transposeB:x,backend:s,bias:i,activation:l,preluActivationWeights:r,leakyreluAlpha:o});w=Tt({inputs:{x:_},backend:s,attrs:{shape:e.outShape}}),S.push(E),S.push(N),S.push(_)}for(const $ of S)s.disposeIntermediateTensorInfo($);return w}function BL({x:n,filter:t,convInfo:e,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:l=null}){const{filterWidth:c,filterHeight:h,inChannels:d,outWidth:p,outHeight:m,dataFormat:y}=e,b=y==="channelsLast",x=c*h*d,w=m*p,S=[e.batchSize,x,w],T=!0,k=!1,$=[];if(r!=null){const V=tg(r.shape,b);V!=null&&(r=Tt({inputs:{x:r},backend:s,attrs:{shape:V}}),$.push(r))}if(i!=null){const V=tg(i.shape,b);V!=null&&(i=Tt({inputs:{x:i},backend:s,attrs:{shape:V}}),$.push(i))}const E=Tt({inputs:{x:t},backend:s,attrs:{shape:[1,x,ft(t.shape)/x]}});$.push(E);const N=new fht(S,e),_=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],R=s.runWebGLProgram(N,[n],"float32",_),D=Tt({inputs:{x:R},backend:s,attrs:{shape:S}});$.push(R),$.push(D);const M=i!=null,A=r!=null,B=l==="leakyrelu",H=l?Wh(l,!0):null,J=new AL(b?D.shape:E.shape,b?E.shape:D.shape,b?[e.batchSize,w,e.outChannels]:[e.batchSize,e.outChannels,w],T,k,M,H,A,B),X=b?[D,E]:[E,D];if(i&&X.push(i),A&&X.push(r),B){const V=s.makeTensorInfo([],"float32",Go(o,"float32"));X.push(V),$.push(V)}const z=s.runWebGLProgram(J,X,"float32"),P=Tt({inputs:{x:z},backend:s,attrs:{shape:e.outShape}});$.push(z);for(const V of $)s.disposeIntermediateTensorInfo(V);return P}function pht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}=s,p=Yr(c),m=Mn(i.shape,r.shape,o,h,l,d,!1,p);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=PL({x:i,filter:r,convInfo:m,backend:e});else if(m.strideWidth<=2&&p==="channelsLast"&&at().getBool("WEBGL_EXP_CONV")){const x=new zL(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=e.runWebGLProgram(x,[i,r],"float32",w)}else if(at().getBool("WEBGL_CONV_IM2COL"))y=BL({x:i,filter:r,convInfo:m,backend:e});else{const x=new LL(m);y=e.runWebGLProgram(x,[i,r],"float32")}const b=Tt({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(y),b}const mht={kernelName:bg,backendName:"webgl",kernelFunc:pht};class ght{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,i=t.padInfo.top,r=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class yht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i=t.strideHeight,r=t.strideWidth,o=t.dataFormat==="channelsLast",l=e-1-t.padInfo.top,c=s-1-t.padInfo.left,h=o?1:2,d=o?2:3,p=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class bht{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,s=t.strideHeight,i=t.strideWidth,r=t.padInfo.front,o=t.padInfo.top,l=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${r};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${l};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class xht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,i=t.filterWidth,r=t.strideDepth,o=t.strideHeight,l=t.strideWidth,c=e-1-t.padInfo.front,h=s-1-t.padInfo.top,d=i-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function vht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:o,pad:l,dataFormat:c,dimRoundingMode:h,filterShape:d}=s,p=Yr(c),m=Mn(i.shape,d,o,1,l,h,!1,p),y=new ght(m);return e.runWebGLProgram(y,[i,r],"float32")}const wht={kernelName:d1,backendName:"webgl",kernelFunc:vht};class Sht{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Jn(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth,i=e-1-t.padInfo.top,r=s-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Cht(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{inputShape:o,strides:l,pad:c,dataFormat:h,dimRoundingMode:d}=s,p=Yr(h),m=Mn(o,r.shape,l,1,c,d,!1,p);if(at().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new Sht(m);return e.runWebGLProgram(b,[i,r],"float32",y)}else{const y=new yht(m);return e.runWebGLProgram(y,[i,r],"float32")}}const Tht={kernelName:xg,backendName:"webgl",kernelFunc:Cht};function kht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dilations:c}=s,h=Ho(i.shape,r.shape,o,c,l),d=new dht(h);return e.runWebGLProgram(d,[i,r],"float32")}const $ht={kernelName:vg,backendName:"webgl",kernelFunc:kht};function Eht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:o,pad:l,filterShape:c}=s,h=Ho(i.shape,c,o,1,l),d=new bht(h);return e.runWebGLProgram(d,[i,r],"float32")}const Iht={kernelName:f1,backendName:"webgl",kernelFunc:Eht};function Nht(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{pad:o,strides:l,inputShape:c}=s,h=Ho(c,r.shape,l,1,o),d=new xht(h);return e.runWebGLProgram(d,[i,r],"float32")}const Aht={kernelName:p1,backendName:"webgl",kernelFunc:Nht};const _ht=ou+`
  return cos(x);
`,Rht=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${pl}
  return result;
`,Dht=le({opSnippet:_ht,packedOpSnippet:Rht}),Oht={kernelName:hd,backendName:"webgl",kernelFunc:Dht};const Mht=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Fht=le({opSnippet:Mht}),Lht={kernelName:dd,backendName:"webgl",kernelFunc:Fht};class zht{constructor(t,e,s,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,l,c,h]=t,[d]=e,[p,m]=s;this.outputShape=[d,p,m,h];const y=i==="bilinear"?1:0,[b,x]=[`${l-1}.0`,`${c-1}.0`],[w,S,T]=p>1?[`${(l-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[k,$,E]=m>1?[`${(c-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${k});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${S};
        float width_scale = ${$};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const Pht=n=>{const{inputs:t,backend:e,attrs:s}=n,{image:i,boxes:r,boxInd:o}=t,{cropSize:l,method:c,extrapolationValue:h}=s,d=new zht(i.shape,r.shape,l,c,h);return e.runWebGLProgram(d,[i,r,o],"float32")},Bht={kernelName:g1,backendName:"webgl",kernelFunc:Pht};var qh;(function(n){n.Prod="*",n.Sum="+"})(qh||(qh={}));class cA{constructor(t,e,s,i){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===qh.Prod?"1.0":"0.0",l=s?o:`getX(${uA(r,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=i?`end != ${c-1}`:"end != 0",d=i?"end + 1":"end - 1"):(h=i?`end + pow2 < ${c}`:"end >= pow2",d=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Te(r)} coords = getOutputCoords();
        int end = ${hA(r,"coords",this.op)};
        float val = ${l};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${hA(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${uA(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function uA(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function hA(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function VL(n,t,e,s,i,r){const o=t.shape.length,l=We([s],o);let c=t;l!=null&&(c=is({inputs:{x:t},backend:e,attrs:{perm:l}}));const h=nn(1,o)[0];if(h!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=c.shape[h];let p=_s({inputs:{x:c},backend:e});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new cA(n,c.shape,!1,r),b=[[m]],x=p;p=e.runWebGLProgram(y,[p],p.dtype,b),e.disposeIntermediateTensorInfo(x)}if(i){const m=new cA(n,c.shape,i,r),y=p;p=e.runWebGLProgram(m,[p],p.dtype),e.disposeIntermediateTensorInfo(y)}if(l!=null){const m=qo(l),y=is({inputs:{x:p},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(c),y}return p}function Vht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:o,reverse:l}=s;return VL(qh.Prod,i,e,r,o,l)}const Uht={kernelName:m1,backendName:"webgl",kernelFunc:Vht};function jht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,exclusive:o,reverse:l}=s;return VL(qh.Sum,i,e,r,o,l)}const Ght={kernelName:wg,backendName:"webgl",kernelFunc:jht};function Wht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,weights:r}=t,{size:o,binaryOutput:l}=s;if(i.shape.length===1){const c=e.readSync(i.dataId),h=e.readSync(r.dataId),d=wL(c,h,r.dtype,r.shape,o);return e.makeTensorInfo([o],r.dtype,d)}else if(i.shape.length===2){const c=e.bufferSync(i),h=e.bufferSync(r),d=Xat(c,h,o,l);return e.makeTensorInfo(d.shape,r.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const Hht={kernelName:y1,backendName:"webgl",kernelFunc:Wht};class qht{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function Kht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockSize:r,dataFormat:o}=s,l=i.shape[0],c=o==="NHWC"?i.shape[1]:i.shape[2],h=o==="NHWC"?i.shape[2]:i.shape[3],d=o==="NHWC"?i.shape[3]:i.shape[1],p=c*r,m=h*r,y=d/(r*r),b=o==="NHWC"?[l,p,m,y]:[l,y,p,m],x=new qht(b,r,o);return e.runWebGLProgram(x,[i],i.dtype)}const Xht={kernelName:b1,backendName:"webgl",kernelFunc:Kht};class UL{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=t.filterHeight,l=t.filterWidth,c=t.outChannels/t.inChannels;let h="",d="";s&&(i?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${l}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${d}
        setOutput(result);
      }
    `}}class jL{constructor(t,e=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Jn(this.outputShape.length);const o=t.outChannels/t.inChannels,l=t.padInfo.left,c=t.strideWidth,h=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,m=p;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let S=0;S<p;S++)y+=`
          vec4 xTexelC${S*2};
          int xTexelC${S*2}Ready;
          vec4 xTexelC${S*2+1};
          int xTexelC${S*2+1}Ready;
          vec4 xC${S};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let S=0;S<p;S++)y+=`
          xTexelC${S*2} = vec4(0.0);
          xTexelC${S*2}Ready = 0;
          xTexelC${S*2+1} = vec4(0.0);
          xTexelC${S*2+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const T=S*2;if(y+=`
          xC = xCCorner + ${T*h};
          `,c===1){if(T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,h===1&&T>0?y+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<p)){const k=l%2===0?Zw(h):h;h%2===0&&l%2===1||h%2!==0&&l%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${k};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:y+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):k===1?y+=`
                    xC${T+1} = xTexelC${T};
                    `:y+=`
                    xCOffset = xC + ${k};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<p&&(l%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<p&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<p&&(y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<p&&(y+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<p&&(y+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(i?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function Yht(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dilations:c,dimRoundingMode:h}=s;let d=c;d==null&&(d=[1,1]),F(Xn(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Mn(i.shape,r.shape,o,d,l,h,!0);let m;at().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new jL(p):m=new UL(p);const y=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[i,r],"float32",y)}const Jht={kernelName:Sg,backendName:"webgl",kernelFunc:Yht};class Zht{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,s=t.strideWidth,i=t.padInfo.top,r=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${i};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Qht{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i=t.strideHeight,r=t.strideWidth,o=e-1-t.padInfo.top,l=s-1-t.padInfo.left,c=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function tdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,dy:r}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,filterShape:d}=s,p=Mn(i.shape,d,o,l,c,h,!0),m=new Zht(p);return e.runWebGLProgram(m,[i,r],"float32")}const edt={kernelName:x1,backendName:"webgl",kernelFunc:tdt};function ndt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,filter:r}=t,{strides:o,dilations:l,pad:c,dimRoundingMode:h,inputShape:d}=s,p=Mn(d,r.shape,o,l,c,h,!0),m=new Qht(p);return e.runWebGLProgram(m,[i,r],"float32")}const sdt={kernelName:v1,backendName:"webgl",kernelFunc:ndt};class idt{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function rdt(n){const{inputs:t,backend:e}=n,{x:s}=t,i=[...s.shape,...s.shape],r=ft(s.shape),o=Tt({inputs:{x:s},backend:e,attrs:{shape:[r]}}),l=new idt(r),c=e.runWebGLProgram(l,[o],o.dtype),h=Tt({inputs:{x:c},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(c),h}const odt={kernelName:IR,backendName:"webgl",kernelFunc:rdt};class adt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:i,strideHeight:r,strideWidth:o,filterHeight:l,filterWidth:c,dilationHeight:h,dilationWidth:d}=t,{top:p,left:m}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${o});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function ldt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r}=t,{strides:o,pad:l,dilations:c}=s,h=Zd(i.shape,r.shape,o,l,"NHWC",c);let d;const p=new adt(h);d=e.runWebGLProgram(p,[i,r],"float32");const m=Tt({inputs:{x:d},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(d),m}const cdt={kernelName:Cg,backendName:"webgl",kernelFunc:ldt};function udt(n){const{inputs:t,backend:e,attrs:s}=n,{equation:i}=s,r=t,{allDims:o,summedDims:l,idDims:c}=jS(i,r.length);WS(o.length,c,r);const{path:h,steps:d}=HS(l,c),p=d.length;let m=null,y=o.length;const b=[];for(let x=0;x<p;++x){for(const w of d[x]){const{permutationIndices:S,expandDims:T}=GS(y,c[w]);let k;qS(S)?k=r[w]:(k=is({inputs:{x:r[w]},backend:e,attrs:{perm:S}}),b.push(k));const $=k.shape.slice();for(let E=0;E<T.length;++E)$.splice(T[E],0,1);me(k.shape,$)||(k=Tt({inputs:{x:k},backend:e,attrs:{shape:$}}),b.push(k)),m===null?m=k:(m=DC({inputs:{a:k,b:m},backend:e}),b.push(m))}x<p-1&&(h[x]>=0&&(m=My({inputs:{x:m},backend:e,attrs:{axis:h[x]-(o.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&e.disposeIntermediateTensorInfo(x);return m}const hdt={kernelName:w1,backendName:"webgl",kernelFunc:udt};const ddt="return (x >= 0.0) ? x : (exp(x) - 1.0);",fdt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,pdt=le({opSnippet:ddt,packedOpSnippet:fdt}),mdt={kernelName:pd,backendName:"webgl",kernelFunc:pdt};const gdt="return (b >= 0.0) ? a : a * (b + 1.0);",ydt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,bdt=n=>{const{inputs:t,backend:e}=n,{dy:s,y:i}=t,r=at().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ru(ydt,s.shape,i.shape):new rl(gdt,s.shape,i.shape);return e.runWebGLProgram(r,[s,i],s.dtype)},xdt={kernelName:S1,backendName:"webgl",kernelFunc:bdt};const vdt=`
  return vec4(equal(a, b));
`,wdt="return float(a == b);",Sdt=Ln({opSnippet:wdt,packedOpSnippet:vdt,dtype:"bool",cpuKernelImpl:tlt}),Cdt={kernelName:Tg,backendName:"webgl",kernelFunc:Sdt};const Tdt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${FS};
  float a1 = ${LS};
  float a2 = ${zS};
  float a3 = ${PS};
  float a4 = ${BS};
  float a5 = ${VS};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,kdt=le({opSnippet:Tdt}),$dt={kernelName:md,backendName:"webgl",kernelFunc:kdt};const Edt=ou+`
  return exp(x);
`,Idt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,GL=le({opSnippet:Edt,packedOpSnippet:Idt,cpuKernelImpl:elt,dtype:"float32"}),Ndt={kernelName:gd,backendName:"webgl",kernelFunc:GL};function uw(n){const{inputs:t,attrs:e,backend:s}=n,{dim:i}=e,{input:r}=t,o=r.shape.length,l=r.shape.slice();let c=i;return i<0&&(F(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+i+1),l.splice(c,0,1),Tt({inputs:{x:r},backend:s,attrs:{shape:l}})}const Adt={kernelName:kg,backendName:"webgl",kernelFunc:uw};const dA="return exp(x) - 1.0;",_dt=le({opSnippet:dA,packedOpSnippet:dA,cpuKernelImpl:nlt}),Rdt={kernelName:yd,backendName:"webgl",kernelFunc:_dt};class fA{constructor(t,e,s){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const r=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${i}.0`:"1.0";let l;if(t==="real")l="return real * expR - imag * expI;";else if(t==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function WL(n,t,e){const s=e.texData.get(n.dataId),i=ft(n.shape),r=n.shape[n.shape.length-1],o=i/r,l=Tt({inputs:{x:n},backend:e,attrs:{shape:[o,r]}}),c=l.shape,h=new fA("real",c,t),d=new fA("imag",c,t),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],m=e.runWebGLProgram(h,p,"float32"),y=e.runWebGLProgram(d,p,"float32"),b=Qo({inputs:{real:m,imag:y},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y);const x=Tt({inputs:{x:b},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(b),x}function Ddt(n){const{inputs:t,backend:e}=n,{input:s}=t;return WL(s,!1,e)}const Odt={kernelName:C1,backendName:"webgl",kernelFunc:Ddt};class Mdt{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function vf(n){const{backend:t,attrs:e}=n,{shape:s,value:i}=e;let{dtype:r}=e;if(r=r||Hc(i),r==="string"){const o=Qe(r,ft(s));return o.fill(i),t.makeTensorInfo(s,r,o)}else{const o=new Mdt(s,i),l=[[i]];return t.runWebGLProgram(o,[],r,l)}}const Fdt={kernelName:T1,backendName:"webgl",kernelFunc:vf};class Ldt{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const zdt={kernelName:k1,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,i=new Ldt(e.shape);return s.runWebGLProgram(i,[e],e.dtype)}};const pA="return floor(x);",Pdt=le({opSnippet:pA,packedOpSnippet:pA,cpuKernelImpl:slt}),Bdt={kernelName:bd,backendName:"webgl",kernelFunc:Pdt};const Vdt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Udt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,jdt=Ln({opSnippet:Vdt,packedOpSnippet:Udt,dtype:"int32"}),Gdt={kernelName:xd,backendName:"webgl",kernelFunc:jdt};class Wdt{constructor(t){this.variableNames=["A"];const e=rs(),[s,i]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class Hdt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=rs(),[s,i]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const qdt={kernelName:F6,backendName:"webgl",kernelFunc:Kdt};let uc,qx=at().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Kdt(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:i}=t;const{numChannels:r}=s,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,l=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[c,h]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],d=[h,c],p=[h,c,r];if(l||o){const x=at().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(uc==null||x!==qx)&&(qx=x,uc=document.createElement("canvas").getContext("2d",{willReadFrequently:qx})),uc.canvas.width=c,uc.canvas.height=h,uc.drawImage(i,0,0,c,h),i=uc.canvas}const m=e.makeTensorInfo(d,"int32");e.texData.get(m.dataId).usage=Hs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),i);const y=at().getBool("WEBGL_PACK")?new Hdt(p):new Wdt(p),b=e.runWebGLProgram(y,[m],"int32");return e.disposeData(m.dataId),b}function Xdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dataFormat:d,dilations:p,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=Yr(d),w=Mn(i.shape,r.shape,c,p,h,m,!1,x);let S;const T=[],k=o!=null,$=l!=null,E=y==="leakyrelu",N=()=>{const R=[i,r],D=(M,A)=>{if(A==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const B=Tt({inputs:{x:M},backend:e,attrs:{shape:[M.shape[0],1,1]}});return T.push(B),B}return M};if(k&&R.push(D(o,d)),$&&R.push(D(l,d)),E){const M=e.makeTensorInfo([],"float32",Go(b,"float32"));R.push(M),T.push(M)}return R};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))S=PL({x:i,filter:r,convInfo:w,backend:e,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&at().getBool("WEBGL_EXP_CONV")){const R=y?Wh(y,!0):null,D=new zL(w,k,R,$,E),M=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=N();S=e.runWebGLProgram(D,A,"float32",M)}else if(at().getBool("WEBGL_CONV_IM2COL"))S=BL({x:i,filter:r,convInfo:w,backend:e,bias:o,activation:y,preluActivationWeights:l,leakyreluAlpha:b});else{const R=y?Wh(y,!1):null,D=new LL(w,k,R,$,E),M=N();S=e.runWebGLProgram(D,M,"float32")}const _=Tt({inputs:{x:S},backend:e,attrs:{shape:w.outShape}});return T.push(S),T.forEach(R=>e.disposeIntermediateTensorInfo(R)),_}const Ydt={kernelName:Im,backendName:"webgl",kernelFunc:Xdt};function Jdt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:l}=t,{strides:c,pad:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),F(Xn(c,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${x}'`);const w=Mn(i.shape,r.shape,c,x,h,p,!0),S=at().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,T=m?Wh(m,S):null,k=[i,r],$=o!=null,E=l!=null,N=m==="leakyrelu";if($&&k.push(o),E&&k.push(l),N){const M=e.makeTensorInfo([],"float32",Go(y,"float32"));k.push(M),b.push(M)}let _;S?_=new jL(w,$,T,E,N):_=new UL(w,$,T,E,N);const R=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],D=e.runWebGLProgram(_,k,"float32",R);return b.forEach(M=>e.disposeIntermediateTensorInfo(M)),D}const Zdt={kernelName:qR,backendName:"webgl",kernelFunc:Jdt};class Qdt{constructor(t,e,s,i){this.sliceDim=t,this.strides=e,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const r=Te(s.length);let o=`
    int index;`;for(let l=0;l<this.sliceDim;l++)o+=`
          index = round(getIndices(coords[0], ${l}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[l]};
          flattenIndex += index * ${this.strides[l]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function tft(n){const{inputs:t,backend:e}=n,{params:s,indices:i}=t,r=i.shape,o=r[r.length-1],l=ft(s.shape),[c,h,d,p]=kS(s,i),m=Tt({inputs:{x:i},backend:e,attrs:{shape:[h,o]}}),y=Tt({inputs:{x:s},backend:e,attrs:{shape:[ft(s.shape)/d,d]}});if(e.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const S=e.readSync(i.dataId),T=e.bufferSync(s),k=ilt(S,T,s.dtype,h,o,d,p,s.shape,l);return e.makeTensorInfo(c,s.dtype,k.values)}const b=new Qdt(o,p,[h,d],s.shape),x=e.runWebGLProgram(b,[y,m],y.dtype),w=Tt({inputs:{x},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),w}const eft={kernelName:NR,backendName:"webgl",kernelFunc:tft};class nft{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=Te(this.rank),i=sft(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function sft(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${e[i]}`);return s.join()}function HL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,indices:r}=t,{axis:o,batchDims:l}=s,c=Zt(o,i.shape)[0];if(at().get("DEBUG")){const T=e.readSync(r.dataId),k=i.shape[c];for(let $=0;$<T.length;++$){const E=T[$];F(E<=k-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${k-1}]`)}}const h=XS(i,r,c,l),d=ft(r.shape),p=[],m=Tt({inputs:{x:i},backend:e,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=Tt({inputs:{x:r},backend:e,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(m),p.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(e.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const T=e.bufferSync(y),k=e.bufferSync(m),$=rlt(k,T,b);return p.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.makeTensorInfo(h.outputShape,$.dtype,$.values)}const x=new nft(m.shape,b),w=e.runWebGLProgram(x,[m,y],m.dtype);p.push(w);const S=Tt({inputs:{x:w},backend:e,attrs:{shape:h.outputShape}});return p.forEach(T=>e.disposeIntermediateTensorInfo(T)),S}const ift={kernelName:Eg,backendName:"webgl",kernelFunc:HL};const rft="return float(a > b);",oft=`
  return vec4(greaterThan(a, b));
`,aft=Ln({opSnippet:rft,packedOpSnippet:oft,cpuKernelImpl:olt,dtype:"bool"}),lft={kernelName:Ig,backendName:"webgl",kernelFunc:aft};const cft="return float(a >= b);",uft=`
  return vec4(greaterThanEqual(a, b));
`,hft=Ln({opSnippet:cft,packedOpSnippet:uft,dtype:"bool",cpuKernelImpl:alt}),dft={kernelName:vd,backendName:"webgl",kernelFunc:hft};function fft(n){const{inputs:t,backend:e}=n,{input:s}=t;return WL(s,!0,e)}const pft={kernelName:$1,backendName:"webgl",kernelFunc:fft};const mft="return float(!isnan(x) && !isinf(x));",gft=le({opSnippet:mft,dtype:"bool"}),yft={kernelName:Sd,backendName:"webgl",kernelFunc:gft};const bft="return float(isinf(x));",xft=le({opSnippet:bft,dtype:"bool"}),vft={kernelName:Cd,backendName:"webgl",kernelFunc:xft};const wft="return float(isnan(x));",Sft=le({opSnippet:wft,dtype:"bool"}),Cft={kernelName:Td,backendName:"webgl",kernelFunc:Sft};const Tft="return float(a < b);",kft=`
  return vec4(lessThan(a, b));
`,$ft=Ln({opSnippet:Tft,packedOpSnippet:kft,cpuKernelImpl:llt,dtype:"bool"}),Eft={kernelName:Ag,backendName:"webgl",kernelFunc:$ft};const Ift="return float(a <= b);",Nft=`
  return vec4(lessThanEqual(a, b));
`,Aft=Ln({opSnippet:Ift,packedOpSnippet:Nft,cpuKernelImpl:clt,dtype:"bool"}),_ft={kernelName:_g,backendName:"webgl",kernelFunc:Aft};function Rft(n){const{backend:t,attrs:e}=n,{start:s,stop:i,num:r}=e,o=ult(s,i,r);return t.makeTensorInfo([o.length],"float32",o)}const Dft={kernelName:AR,backendName:"webgl",kernelFunc:Rft};const Oft=ou+`
  return x < 0.0 ? 0./0. : log(x);
`,Mft=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Fft=le({opSnippet:Oft,packedOpSnippet:Mft,cpuKernelImpl:hlt}),Lft={kernelName:kd,backendName:"webgl",kernelFunc:Fft};const zft=ou+`
  return log(1.0 + x);
`,Pft=le({opSnippet:zft}),Bft={kernelName:$d,backendName:"webgl",kernelFunc:Pft};const Vft="return float(a >= 1.0 && b >= 1.0);",Uft=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,jft=Ln({opSnippet:Vft,packedOpSnippet:Uft,dtype:"bool"}),Gft={kernelName:Rg,backendName:"webgl",kernelFunc:jft};const Wft="return float(!(x >= 1.0));",Hft=le({opSnippet:Wft}),qft={kernelName:Dg,backendName:"webgl",kernelFunc:Hft};const Kft="return float(a >= 1.0 || b >= 1.0);",Xft=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Yft=Ln({opSnippet:Kft,packedOpSnippet:Xft,dtype:"bool"}),Jft={kernelName:Og,backendName:"webgl",kernelFunc:Yft};class Zft{constructor(t,e,s,i,r){this.variableNames=["x"],this.outputShape=[];const o=e,l=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${i}) * sum`;r===.5?c=`inversesqrt(${h})`:r===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}class Qft{constructor(t,e,s,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,l=t[3]-1;this.outputShape=t;let c;const h=`float(${s}) + float(${i}) * sum`;r===.5?c=`inversesqrt(${h})`:r===1?c=`1.0/(${h})`:c=`exp(log(${h}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}const tpt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{depthRadius:r,bias:o,alpha:l,beta:c}=s,h=at().getBool("WEBGL_PACK_NORMALIZATION")?new Qft(i.shape,r,o,l,c):new Zft(i.shape,r,o,l,c);return e.runWebGLProgram(h,[i],i.dtype)},ept={kernelName:Mg,backendName:"webgl",kernelFunc:tpt};class npt{constructor(t,e,s,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const spt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i,y:r,dy:o}=t,{depthRadius:l,bias:c,alpha:h,beta:d}=s,p=new npt(i.shape,l,c,h,d);return e.runWebGLProgram(p,[i,r,o],i.dtype)},ipt={kernelName:I1,backendName:"webgl",kernelFunc:spt};function rpt(n,t,e,s){const i=ft(t),o=ft(n.shape)/i,l=Tt({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),c=ml(l,n.dtype,"max",s),h=Tt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}function qL(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reductionIndices:r,keepDims:o}=s,l=i.shape.length,c=Zt(r,i.shape);let h=c;const d=We(h,l),p=d!=null,m=e.shouldExecuteOnCPU([i]);let y=i;if(p){if(m){const k=e.texData.get(y.dataId).values,$=new Array(l);for(let _=0;_<$.length;_++)$[_]=i.shape[d[_]];const E=_C(k,i.shape,i.dtype,d,$);y=e.makeTensorInfo($,i.dtype);const N=e.texData.get(y.dataId);N.values=E}else y=Oy(i,d,e);h=nn(h.length,l)}Fn("max",h,l);const[b,x]=An(y.shape,h);let w=b;o&&(w=cn(b,c));let S;if(m){const k=e.texData.get(y.dataId).values,$=dlt(k,ft(x),w,i.dtype);S=e.makeTensorInfo(w,i.dtype);const E=e.texData.get(S.dataId);E.values=$}else S=rpt(y,x,w,e);return p&&e.disposeIntermediateTensorInfo(y),S}const opt={kernelName:Fg,backendName:"webgl",kernelFunc:qL};const apt=RC+`
  return max(a, b);
`,lpt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,cpt=Ln({opSnippet:apt,packedOpSnippet:lpt,cpuKernelImpl:flt}),upt={kernelName:Ed,backendName:"webgl",kernelFunc:cpt};function hpt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;yf(i,"maxPool");const{filterSize:r,strides:o,pad:l,dimRoundingMode:c}=s,h=1;F(Xn(o,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=xi(i.shape,r,o,h,l,c);if(d.filterWidth===1&&d.filterHeight===1&&me(d.inShape,d.outShape))return _s({inputs:{x:i},backend:e});const p=new Hh(d,"max",!1);return e.runWebGLProgram(p,[i],i.dtype)}const dpt={kernelName:Lg,backendName:"webgl",kernelFunc:hpt};function fpt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{filterSize:r,strides:o,pad:l,dataFormat:c,dimRoundingMode:h}=s,d=[1,1,1],p=Xr(i.shape,r,o,d,l,h,c),m=new OC(p,"max",!1);return e.runWebGLProgram(m,[i],i.dtype)}const ppt={kernelName:zg,backendName:"webgl",kernelFunc:fpt};class mpt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,r=t.effectiveFilterHeight,o=t.effectiveFilterWidth,l=r-1-t.padInfo.top,c=o-1-t.padInfo.left,h=r*o-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class gpt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,s=t.strideHeight,i=t.strideWidth,r=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,m=h-1-t.padInfo.top,y=d-1-t.padInfo.left,b=c*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function ypt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r}=t,o=r,{filterSize:l,strides:c,pad:h,dimRoundingMode:d}=s,p=[1,1,1],m=Xr(o.shape,l,c,p,h,d),y=new OC(m,"max",!0),b=e.runWebGLProgram(y,[o],o.dtype),x=new gpt(m),w=e.runWebGLProgram(x,[i,b],o.dtype);return e.disposeIntermediateTensorInfo(b),w}const bpt={kernelName:A1,backendName:"webgl",kernelFunc:ypt};function xpt(n){const{inputs:t,backend:e,attrs:s}=n,{dy:i,input:r,output:o}=t,l=r;yf([r,o],"maxPoolGrad");const{filterSize:c,strides:h,pad:d,dimRoundingMode:p}=s,m=xi(l.shape,c,h,1,d,p),y=!0,b=new Hh(m,"max",y),x=e.runWebGLProgram(b,[l],l.dtype),w=new mpt(m),S=e.runWebGLProgram(w,[i,x],l.dtype);return e.disposeIntermediateTensorInfo(x),S}const vpt={kernelName:N1,backendName:"webgl",kernelFunc:xpt};function wpt(n,t,e,s){let i=new Hh(e,"max",!1);const r=s.runWebGLProgram(i,[n],"float32");i=new Hh(e,"max",!0,!0,t);const o=s.runWebGLProgram(i,[n],"float32");return[r,o]}const Spt={kernelName:_R,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:l}=t,c=e;F(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];F(Xn(r,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${h}'`);const d=xi(s.shape,i,r,h,o),[p,m]=wpt(s,l,d,c);return[p,m]}};function Cpt(n,t,e,s){const i=ft(t),o=ft(n.shape)/i,l=Tt({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),c=ml(l,"float32","mean",s),h=Tt({inputs:{x:c},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(l),s.disposeIntermediateTensorInfo(c),h}const Tpt={kernelName:Pg,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:i,axis:r}=t,o=e,l=s.shape.length,c=Zt(r,s.shape);let h=c;const d=We(h,l),p=d!=null,m=o.shouldExecuteOnCPU([s]),y=[];let b=s;if(p){if(m){const $=o.texData.get(b.dataId).values,E=new Array(l);for(let R=0;R<E.length;R++)E[R]=s.shape[d[R]];const N=_C($,s.shape,s.dtype,d,E);b=o.makeTensorInfo(E,s.dtype);const _=o.texData.get(b.dataId);_.values=N}else b=Oy(s,d,o);y.push(b),h=nn(h.length,l)}Fn("sum",h,l);const[x,w]=An(b.shape,h);let S=x;i&&(S=cn(x,c));const T=Cpt(b,w,S,o);for(const k of y)o.disposeIntermediateTensorInfo(k);return T}};function kpt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s,l=i.shape.length,c=Zt(r,i.shape);let h=c;const d=We(h,l);let p=i;d!=null&&(p=is({inputs:{x:i},backend:e,attrs:{perm:d}}),h=nn(h.length,i.shape.length)),Fn("min",h,l);const[m,y]=An(p.shape,h),b=ft(y),x=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,b]}}),w=ml(x,x.dtype,"min",e);let S;if(o){const T=cn(m,c);S=Tt({inputs:{x:w},backend:e,attrs:{shape:T}})}else S=Tt({inputs:{x:w},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(w),d!=null&&e.disposeIntermediateTensorInfo(p),S}const $pt={kernelName:Bg,backendName:"webgl",kernelFunc:kpt};const Ept=RC+`
  return min(a, b);
`,Ipt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+pl+`
  return result;
`,Npt=Ln({opSnippet:Ept,packedOpSnippet:Ipt,cpuKernelImpl:plt}),Apt={kernelName:Id,backendName:"webgl",kernelFunc:Npt};class _pt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((d,p)=>d[0]+t[p]+d[1]);const i=t.length,r=Te(i),o=e.map(d=>d[0]).join(","),l=e.map((d,p)=>d[0]+t[p]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),h=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${l});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}class Rpt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((b,x)=>b[0]+t[x]+b[1]);const i=t.length,r=Te(i),o=e.map(b=>b[0]).join(","),l=e.map((b,x)=>b[0]+t[x]).join(","),c=es("rc",i),h=es("source",i),d=`${c[i-1]} < ${this.outputShape[i-1]}`,p=i===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(i===1){const b=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${r} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[i-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
      `}else{const b=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${r} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${p});
        ${c[i-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${p});
        }
        rc = outputLoc;
        ${c[i-2]} += 1;
        if(${c[i-2]} < ${this.outputShape[i-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${p});
          ${c[i-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${l});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const Dpt=({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:i,mode:r}=e,o=at().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rpt(s.shape,i,r):new _pt(s.shape,i,r);return t.runWebGLProgram(o,[s],s.dtype)},Opt={kernelName:Vg,backendName:"webgl",kernelFunc:Dpt};const Mpt=`if (b == 0.0) return NAN;
  return mod(a, b);`,Fpt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+pl+`
  return result;
`,Lpt=Ln({opSnippet:Mpt,packedOpSnippet:Fpt}),zpt={kernelName:Nd,backendName:"webgl",kernelFunc:Lpt};class Ppt{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const Bpt=`
if (a == b) {
  return 1.0;
};
return a / b;`,Vpt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,KL=Ln({opSnippet:Bpt,packedOpSnippet:Vpt,checkOutOfBounds:!0}),Upt={kernelName:fd,backendName:"webgl",kernelFunc:KL};const mA="return a - b;",XL=Ln({opSnippet:mA,packedOpSnippet:mA,supportsComplex:!0,cpuKernelImpl:Mlt}),jpt={kernelName:Wd,backendName:"webgl",kernelFunc:XL};function YL(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{dim:r}=s,o=Zt([r],i.shape),l=qL({inputs:{x:i},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),c=cn(l.shape,o),h=Tt({inputs:{x:l},backend:e,attrs:{shape:c}}),d=XL({inputs:{a:i,b:h},backend:e}),p=GL({inputs:{x:d},backend:e}),m=My({inputs:{x:p},backend:e,attrs:{axis:o,keepDims:!1}}),y=Tt({inputs:{x:m},backend:e,attrs:{shape:c}}),b=KL({inputs:{a:p,b:y},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}const Gpt={kernelName:ry,backendName:"webgl",kernelFunc:YL};function Wpt(n){const{inputs:t,backend:e,attrs:s}=n,{logits:i}=t,{numSamples:r,seed:o,normalized:l}=s,c=l?i:YL({inputs:{logits:i},backend:e,attrs:{dim:i.shape.length-1}}),h=c.shape[0],d=c.shape[1],p=new Ppt(h,d,r),m=[[o]],y=e.runWebGLProgram(p,[c],"int32",m);return l||e.disposeIntermediateTensorInfo(c),y}const Hpt={kernelName:RR,backendName:"webgl",kernelFunc:Wpt};const qpt=wi+`
  return -x;
`,Kpt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Xpt(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const r=e.texData.get(s.dataId),[o,l]=glt(r.values,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,o)}let i;return at().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new No(s.shape,Kpt):i=new nr(s.shape,qpt),e.runWebGLProgram(i,[s],s.dtype)}const Ypt={kernelName:Ug,backendName:"webgl",kernelFunc:Xpt};const Jpt=xS;function Zpt(n){Ws("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=s,h=e.readSync(i.dataId),d=e.readSync(r.dataId),{selectedIndices:p}=Jpt(h,d,o,l,c);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}const Qpt={kernelName:_1,backendName:"webgl",kernelFunc:Zpt};const tmt=vS;function emt(n){Ws("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,padToMaxOutputSize:h}=s,d=e.readSync(i.dataId),p=e.readSync(r.dataId),{selectedIndices:m,validOutputs:y}=tmt(d,p,o,l,c,h);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}const nmt={kernelName:R1,backendName:"webgl",kernelFunc:emt};const smt=wS;function imt(n){Ws("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:i,scores:r}=t,{maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=s,d=e.readSync(i.dataId),p=e.readSync(r.dataId),m=o,y=l,b=c,x=h,{selectedIndices:w,selectedScores:S}=smt(d,p,m,y,b,x);return[e.makeTensorInfo([w.length],"int32",new Int32Array(w)),e.makeTensorInfo([S.length],"float32",new Float32Array(S))]}const rmt={kernelName:D1,backendName:"webgl",kernelFunc:imt};class omt{constructor(t,e,s,i){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const amt=n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:i}=t,{dtype:r,depth:o,onValue:l,offValue:c}=s,h=ft(i.shape),d=new omt(h,o,l,c),p=Tt({inputs:{x:i},backend:e,attrs:{shape:[h]}}),m=e.runWebGLProgram(d,[p],r);e.disposeIntermediateTensorInfo(p);const y=[...i.shape,o],b=Tt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),b},lmt={kernelName:Wg,backendName:"webgl",kernelFunc:amt};function eg(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="complex64"){const i=xf({inputs:{input:s},backend:e}),r=eg({inputs:{x:i},backend:e}),o=Fy({inputs:{input:s},backend:e}),l=eg({inputs:{x:o},backend:e}),c=Qo({inputs:{real:r,imag:l},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return vf({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:e})}const cmt={kernelName:ly,backendName:"webgl",kernelFunc:eg};function JL(n){const{inputs:t,backend:e}=n,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=xf({inputs:{input:s},backend:e}),r=JL({inputs:{x:i},backend:e}),o=Fy({inputs:{input:s},backend:e}),l=eg({inputs:{x:o},backend:e}),c=Qo({inputs:{real:r,imag:l},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}else return vf({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}const umt={kernelName:Gg,backendName:"webgl",kernelFunc:JL};function hmt(n){const{inputs:t,backend:e,attrs:s}=n,{axis:i}=s;if(t.length===1)return uw({inputs:{input:t[0]},backend:e,attrs:{dim:i}});const r=t[0].shape,o=t[0].dtype;t.forEach(d=>{Qw(r,d.shape,"All tensors passed to stack must have matching shapes"),F(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],c=t.map(d=>{const p=uw({inputs:{input:d},backend:e,attrs:{dim:i}});return l.push(p),p}),h=FL({inputs:c,backend:e,attrs:{axis:i}});return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const dmt={kernelName:Hg,backendName:"webgl",kernelFunc:hmt};class fmt{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,d)=>h[0]+t[d]+h[1]);const i=t.length,r=Te(i),o=e.map(h=>h[0]).join(","),l=e.map((h,d)=>h[0]+t[d]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${l});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}class pmt{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((x,w)=>x[0]+t[w]+x[1]);const i=t.length,r=Te(i),o=e.map(x=>x[0]).join(","),l=e.map((x,w)=>x[0]+t[w]).join(","),c=es("rc",i),h=es("source",i),d=`${c[i-1]} < ${this.outputShape[i-1]}`,p=i===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${r} rc = outputLoc;`,`${c[i-1]} += 1;
       if(${d}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${c[i-2]} += 1;
       if(${c[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${c[i-1]} += 1;
         if(${d}) {`],y=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=i===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${p});
        }
      `;b+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${l});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const ZL=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{paddings:r,constantValue:o}=s;if(ft(i.shape)===0){const h=r.map((d,p)=>d[0]+i.shape[p]+d[1]);return vf({backend:e,attrs:{shape:h,value:o,dtype:i.dtype}})}const l=at().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pmt(i.shape,r,o):new fmt(i.shape,r,o),c=[[o]];return e.runWebGLProgram(l,[i],i.dtype,c)},mmt={kernelName:qg,backendName:"webgl",kernelFunc:ZL};const gmt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,ymt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+pl+`
  return result;
`,bmt=Ln({opSnippet:gmt,packedOpSnippet:ymt}),xmt={kernelName:_d,backendName:"webgl",kernelFunc:bmt};function vmt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{axis:r,keepDims:o}=s,l=i.shape.length,c=[],h=Zt(r,i.shape);let d=h;const p=We(d,l);let m=i;p!=null&&(m=is({inputs:{x:i},backend:e,attrs:{perm:p}}),d=nn(d.length,l),c.push(m)),Fn("prod",d,l);let y;if(e.shouldExecuteOnCPU([m])){const b=e.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:S}=blt(m.shape,m.dtype,b,d);y=e.makeTensorInfo(w,S,x)}else{const[b,x]=An(m.shape,d),w=ft(x),S=Tt({inputs:{x:m},backend:e,attrs:{shape:[-1,w]}}),T=W1(i.dtype),k=ml(S,T,"prod",e);y=Tt({inputs:{x:k},backend:e,attrs:{shape:b}}),c.push(S),c.push(k)}if(o){c.push(y);const b=cn(y.shape,h);y=Tt({inputs:{x:y},backend:e,attrs:{shape:b}})}return c.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const wmt={kernelName:Xg,backendName:"webgl",kernelFunc:vmt};function Smt(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=t,{outputRaggedRank:l}=s,c=i.map(S=>e.readSync(S.dataId)),h=i.map(S=>S.shape),d=e.readSync(r.dataId),p=e.readSync(o.dataId),[m,y,b]=xlt(c,h,d,r.shape,r.dtype,p,o.shape,l),x=m.map(S=>e.makeTensorInfo([S.length],"int32",S)),w=e.makeTensorInfo(b,r.dtype,y);return x.concat([w])}const Cmt={kernelName:DR,backendName:"webgl",kernelFunc:Smt};function Tmt(n){const{inputs:t,backend:e}=n,{starts:s,limits:i,deltas:r}=t,o=e.readSync(s.dataId),l=e.readSync(i.dataId),c=e.readSync(r.dataId),[h,d]=vlt(o,s.shape,s.dtype,l,i.shape,c,r.shape),p=e.makeTensorInfo([h.length],"int32",h),m=e.makeTensorInfo([d.length],s.dtype,d);return[p,m]}const kmt={kernelName:OR,backendName:"webgl",kernelFunc:Tmt};function $mt(n){const{inputs:t,backend:e,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:l}=t,{rowPartitionTypes:c}=s,h=e.readSync(i.dataId),d=e.readSync(r.dataId),p=e.readSync(o.dataId),m=l.map(w=>e.readSync(w.dataId)),y=l.map(w=>w.shape),[b,x]=wlt(h,i.shape,d,r.shape,r.dtype,p,o.shape,m,y,c);return e.makeTensorInfo(b,r.dtype,x)}const Emt={kernelName:MR,backendName:"webgl",kernelFunc:$mt};const QL=n=>{const{backend:t,attrs:e}=n,{start:s,stop:i,step:r,dtype:o}=e,l=Slt(s,i,r,o);return t.makeTensorInfo([l.length],o,l)},Imt={kernelName:O1,backendName:"webgl",kernelFunc:QL};const Nmt="return 1.0 / x;",Amt=le({opSnippet:Nmt}),_mt={kernelName:Rd,backendName:"webgl",kernelFunc:Amt};const Rmt=wi+`
  return (x < 0.0) ? 0.0 : x;
`,Dmt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Omt=le({opSnippet:Rmt,packedOpSnippet:Dmt}),Mmt={kernelName:Dd,backendName:"webgl",kernelFunc:Omt};const Fmt=wi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Lmt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zmt=le({opSnippet:Fmt,packedOpSnippet:Lmt}),Pmt={kernelName:Od,backendName:"webgl",kernelFunc:zmt};class Bmt{constructor(t,e,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[i&&e>1?l-1:l,i&&s>1?c-1:c],p=[i&&e>1?e-1:e,i&&s>1?s-1:s];let m;r?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class Vmt{constructor(t,e,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[i&&e>1?l-1:l,i&&s>1?c-1:c],p=[i&&e>1?e-1:e,i&&s>1?s-1:s];let m;r?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function Umt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:o,size:l}=s,[c,h]=l,d=at().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Vmt(i.shape,c,h,r,o):new Bmt(i.shape,c,h,r,o);return e.runWebGLProgram(d,[i],"float32")}const jmt={kernelName:Zg,backendName:"webgl",kernelFunc:Umt};class Gmt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,o,l]=t,c=[s&&o>1?i-1:i,s&&l>1?r-1:r],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function Wmt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:o}=s,l=new Gmt(r.shape,i.shape,o);return e.runWebGLProgram(l,[r],r.dtype)}const Hmt={kernelName:L1,backendName:"webgl",kernelFunc:Wmt};class qmt{constructor(t,e,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[i&&e>1?l-1:l,i&&s>1?c-1:c],p=[i&&e>1?e-1:e,i&&s>1?s-1:s],m=i?"0.5":"0.0";let y;r?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/p[0]},
          ${d[1]/p[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class Kmt{constructor(t,e,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,l,c,h]=t;this.outputShape=[o,e,s,h];const d=[i&&e>1?l-1:l,i&&s>1?c-1:c],p=[i&&e>1?e-1:e,i&&s>1?s-1:s],m=i?"0.5":"0.0";let y;r?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/p[0]},
          ${d[1]/p[1]},
          ${d[1]/p[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function Xmt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i}=t,{alignCorners:r,halfPixelCenters:o,size:l}=s,[c,h]=l,d=at().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Kmt(i.shape,c,h,r,o):new qmt(i.shape,c,h,r,o);return e.runWebGLProgram(d,[i],i.dtype)}const Ymt={kernelName:Jg,backendName:"webgl",kernelFunc:Xmt};class Jmt{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,i,r]=e,[,o,l]=t,c=[s&&o>1?i-1:i,s&&l>1?r-1:r],h=[s&&o>1?o-1:o,s&&l>1?l-1:l],d=c[0]/h[0],p=c[1]/h[1],m=1/d,y=1/p,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function Zmt(n){const{inputs:t,backend:e,attrs:s}=n,{images:i,dy:r}=t,{alignCorners:o}=s,l=new Jmt(r.shape,i.shape,o);return e.runWebGLProgram(l,[r],r.dtype)}const Qmt={kernelName:F1,backendName:"webgl",kernelFunc:Zmt};class tgt{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const i=l=>e.indexOf(l)!==-1&&t[l]!==1?`${t[l]} - coords[${l}] - 1`:`coords[${l}]`,r=t.map((l,c)=>i(c)).join(","),o=Te(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}}class egt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const i=es("rc",s),r=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,l=Te(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(i.slice())};
          if(${r}){
            result.g = ${h(i.slice())};
          }
          if(${o}) {
            result.b = ${d(i.slice())};
            if(${r}) {
              result.a = ${p(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function p(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=t.map((T,k)=>y(k,b)),w=x.join(","),S=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${S}))`}function y(b,x){return e.indexOf(b)!==-1&&t[b]!==1?`${t[b]} - ${x[b]} - 1`:`${x[b]}`}}}function ngt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{dims:r}=s,o=i.shape.length,l=Zt(r,i.shape);if(o===0)return _s({inputs:{x:i},backend:e});const c=at().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new egt(i.shape,l):new tgt(i.shape,l);return e.runWebGLProgram(c,[i],i.dtype)}const sgt={kernelName:Qg,backendName:"webgl",kernelFunc:ngt};class igt{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],i=t[2];this.outputShape=t;let r="";typeof e=="number"?r=`float outputValue = ${e.toFixed(2)};`:r=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const rgt={kernelName:G1,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=t,l=e,c=new igt(s.shape,r),[h,d]=DS(o,s.shape[1],s.shape[2]),p=[[h,d,Math.sin(i),Math.cos(i)]];return l.runWebGLProgram(c,[s],s.dtype,p)}};const ogt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,agt=le({opSnippet:ogt}),lgt={kernelName:Md,backendName:"webgl",kernelFunc:agt};const cgt="return inversesqrt(x);",ugt=le({opSnippet:cgt,cpuKernelImpl:Clt}),hgt={kernelName:Fd,backendName:"webgl",kernelFunc:ugt};class MC{constructor(t,e,s,i,r,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const h=Te(r.length),d=Te(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";i===1?y="i":i===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=e>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${S};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class dgt{constructor(t,e,s,i,r,o,l=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const h=Te(r.length),d=Te(o.length);let p="";s===1?p="i":s===2&&(p="i, j");const m=`getIndices(${p})`;let y="";i===1?y="i":i===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";c&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,S=e>1?"strides[j]":"strides",T=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${S};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${T};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function fgt(n){const{inputs:t,backend:e,attrs:s}=n,{indices:i,updates:r}=t,{shape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(r,i,o),m=[p/h,h];if(p===0)return e.makeTensorInfo(o,i.dtype);const y=Tt({inputs:{x:i},backend:e,attrs:{shape:[c,l]}}),b=Tt({inputs:{x:r},backend:e,attrs:{shape:[c,h]}}),x=e.makeTensorInfo([],"float32",new Float32Array([0]));let w;at().getBool("WEBGL_PACK")?w=new dgt(c,l,y.shape.length,b.shape.length,d,m):w=new MC(c,l,y.shape.length,b.shape.length,d,m);const S=e.runWebGLProgram(w,[b,y,x],b.dtype),T=Tt({inputs:{x:S},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(x),T}const pgt={kernelName:FR,backendName:"webgl",kernelFunc:fgt};class mgt{constructor(t,e,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const r="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,l=at().getNumber("WEBGL_VERSION")===2?r:o,c=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${l}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function ggt(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:i,values:r}=t,{side:o}=s,l=new mgt(i.shape[0],i.shape[1],r.shape[1],o),c=[[i.shape[1]]];return e.runWebGLProgram(l,[i,r],"int32",c)}const ygt={kernelName:zR,backendName:"webgl",kernelFunc:ggt};class bgt{constructor(t,e,s){this.variableNames=["c","a","b"],this.outputShape=e;let i,r;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)r="resRC",i="resRC";else{const l=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],h=[];for(let d=0;d<e.length;d++)h.push(`${l[d]}`),d<t&&c.push(`${l[d]}`);i=c.join(),r=h.join()}const o=Te(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}}function xgt(n){const{inputs:t,backend:e}=n,{condition:s,t:i,e:r}=t,o=new bgt(s.shape.length,i.shape,i.shape.length);return e.runWebGLProgram(o,[s,i,r],Ns(i.dtype,r.dtype))}const vgt={kernelName:ty,backendName:"webgl",kernelFunc:xgt};const wgt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${by};
  float scale = ${xy};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Sgt=le({opSnippet:wgt}),Cgt={kernelName:Ld,backendName:"webgl",kernelFunc:Sgt};const Tgt=ou+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,kgt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$gt=le({opSnippet:Tgt,packedOpSnippet:kgt,cpuKernelImpl:klt}),Egt={kernelName:Vd,backendName:"webgl",kernelFunc:$gt};const Igt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ngt=le({opSnippet:Igt}),Agt={kernelName:Bd,backendName:"webgl",kernelFunc:Ngt};const _gt=ou+`
  return sin(x);
`,Rgt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${pl}
  return result;
`,Dgt=le({opSnippet:_gt,packedOpSnippet:Rgt}),Ogt={kernelName:zd,backendName:"webgl",kernelFunc:Dgt};const Mgt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Fgt=le({opSnippet:Mgt}),Lgt={kernelName:Pd,backendName:"webgl",kernelFunc:Fgt};const zgt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Pgt=le({opSnippet:zgt}),Bgt={kernelName:Ud,backendName:"webgl",kernelFunc:Pgt};const Vgt=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{blockShape:r,paddings:o}=s;F(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const l=r.reduce((S,T)=>S*T),c=[[0,0]];c.push(...o);for(let S=1+r.length;S<i.shape.length;++S)c.push([0,0]);const h=[],d=ZL({inputs:{x:i},backend:e,attrs:{paddings:c,constantValue:0}}),p=sf(d.shape,r,l,!1),m=rf(p.length,r.length,!1),y=of(d.shape,r,l,!1),b=Tt({inputs:{x:d},backend:e,attrs:{shape:p}}),x=is({inputs:{x:b},backend:e,attrs:{perm:m}}),w=Tt({inputs:{x},backend:e,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(S=>e.disposeIntermediateTensorInfo(S)),w},Ugt={kernelName:sy,backendName:"webgl",kernelFunc:Vgt};function jgt(n){const{inputs:t,backend:e}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=t;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const l=e.readSync(s.dataId),c=e.readSync(i.dataId),h=e.readSync(r.dataId),d=e.readSync(o.dataId)[0],[p,m,y,b,x]=Elt(l,s.shape,s.dtype,c,i.dtype,h,d);return[e.makeTensorInfo(m,s.dtype,p),e.makeTensorInfo([m[0]],i.dtype,y),e.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),e.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const Ggt={kernelName:PR,backendName:"webgl",kernelFunc:jgt};function Wgt(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:i,newShape:r}=t;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(e.readSync(i.dataId)),l=e.readSync(s.dataId),c=Array.from(e.readSync(r.dataId)),[h,d,p]=Ilt(l,s.shape,s.dtype,o,c);return[e.makeTensorInfo(d,s.dtype,h),e.makeTensorInfo([p.length],r.dtype,new Int32Array(p))]}const Hgt={kernelName:BR,backendName:"webgl",kernelFunc:Wgt};function qgt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const o=e.readSync(s.dataId),l=e.readSync(i.dataId),c=e.readSync(r.dataId),[h,d]=CL(o,s.shape,s.dtype,l,c,!0);return e.makeTensorInfo(d,s.dtype,h)}const Kgt={kernelName:VR,backendName:"webgl",kernelFunc:qgt};function Xgt(n){const{inputs:t,backend:e}=n,{data:s,indices:i,segmentIds:r}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const o=e.readSync(s.dataId),l=e.readSync(i.dataId),c=e.readSync(r.dataId),[h,d]=CL(o,s.shape,s.dtype,l,c);return e.makeTensorInfo(d,s.dtype,h)}const Ygt={kernelName:UR,backendName:"webgl",kernelFunc:Xgt};function Jgt(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=t,{outputShape:l}=s,{sliceRank:c,numUpdates:h,sliceSize:d,strides:p,outputSize:m}=cl(r,i,l),y=!1;if(r.dtype==="string"){const S=e.bufferSync(i),T=e.bufferSync(r),k=Fo(e.readSync(o.dataId)[0]),$=Tlt(S,T,l,m,d,h,c,p,k,y);return e.makeTensorInfo(l,$.dtype,$.values)}const b=new MC(h,c,i.shape.length,r.shape.length,p,[m,1],y),x=e.runWebGLProgram(b,[r,i,o],r.dtype),w=Tt({inputs:{x},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(x),w}const Zgt={kernelName:jR,backendName:"webgl",kernelFunc:Jgt};function Qgt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{numOrSizeSplits:r,axis:o}=s,l=Zt(o,i.shape)[0],c=KS(i,r,l),h=i.shape.length,d=new Array(h).fill(0),p=i.shape.slice();return c.map(m=>{const y=[...p];y[l]=m;const b=au({inputs:{x:i},backend:e,attrs:{begin:d,size:y}});return d[l]+=m,b})}const tyt={kernelName:iy,backendName:"webgl",kernelFunc:Qgt};const gA="return sqrt(x);",eyt=le({opSnippet:gA,packedOpSnippet:gA,cpuKernelImpl:Nlt}),nyt={kernelName:jd,backendName:"webgl",kernelFunc:eyt};const syt="return x * x;",iyt=le({opSnippet:syt}),ryt={kernelName:z1,backendName:"webgl",kernelFunc:iyt};const yA="return (a - b) * (a - b);",oyt=Ln({opSnippet:yA,packedOpSnippet:yA}),ayt={kernelName:Gd,backendName:"webgl",kernelFunc:oyt};function lyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const r=e.readSync(i.dataId),o=Hr(r),l=Alt(o,"string",s);return e.makeTensorInfo(i.shape,"string",l)}const cyt={kernelName:P1,backendName:"webgl",kernelFunc:lyt};function uyt({inputs:n,attrs:t,backend:e}){const{x:s}=n,i=wi+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,r=new nr(s.shape,i);return e.runWebGLProgram(r,[s],s.dtype)}const hyt={kernelName:Xd,backendName:"webgl",kernelFunc:uyt};class dyt{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,r=Te(s.length),o=Te(s.length);let l="";if(i===1)l="coords * strides + begin";else{let c=0;l=s.map((h,d)=>(c++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${c-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${t});
      ${r} strides = ${r}(${e});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}}function fyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{begin:r,end:o,strides:l,beginMask:c,endMask:h,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:S,begin:T,end:k,strides:$}=AS(i.shape,r,o,l,c,h,d,p,m);let E;if(x)E=Tt({inputs:{x:i},backend:e,attrs:{shape:b}});else if(w||S){F(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const _=ES(T,k,$),R=au({inputs:{x:i},backend:e,attrs:{begin:T,size:_}});E=Tt({inputs:{x:R},backend:e,attrs:{shape:b}}),e.disposeIntermediateTensorInfo(R)}else if(e.shouldExecuteOnCPU([i])){const R=e.readSync(i.dataId),D=Jt(i.shape,i.dtype,R),M=_lt(y,D,$,T);E=e.makeTensorInfo(b,i.dtype,M.values)}else{const R=new dyt(T,$,y);E=e.runWebGLProgram(R,[i],i.dtype)}const N=Tt({inputs:{x:E},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(E),N}const pyt={kernelName:B1,backendName:"webgl",kernelFunc:fyt};function myt(n){const{inputs:t,backend:e,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:l,padWidth:c,preserveShortSequences:h}=s,{data:d,dataSplits:p}=t,m=e.readSync(d.dataId),y=e.readSync(p.dataId),[b,x]=Rlt(m,y,i,r,o,l,c,h);return[e.makeTensorInfo([b.length],"string",b),e.makeTensorInfo(p.shape,"int32",x)]}const gyt={kernelName:GR,backendName:"webgl",kernelFunc:myt};function yyt(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const l=e.readSync(r.dataId),c=e.readSync(o.dataId)[0],[h,d,p]=Dlt(l,c,i),m=d.length;return[e.makeTensorInfo([m,2],"int32",h),e.makeTensorInfo([m],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}const byt={kernelName:WR,backendName:"webgl",kernelFunc:yyt};function xyt(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:i}=s,{input:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(r.dataId),l=Olt(o,i);return e.makeTensorInfo(r.shape,"int32",l)}const vyt={kernelName:HR,backendName:"webgl",kernelFunc:xyt};const wyt="return tan(x);",Syt=le({opSnippet:wyt}),Cyt={kernelName:Hd,backendName:"webgl",kernelFunc:Syt};const Tyt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,kyt=le({opSnippet:Tyt}),$yt={kernelName:qd,backendName:"webgl",kernelFunc:kyt};function Eyt(n){const{inputs:t,backend:e,attrs:s}=n,{tensor:i,indices:r,updates:o}=t,{sliceRank:l,numUpdates:c,sliceSize:h,strides:d,outputSize:p}=cl(o,r,i.shape),m=[p/h,h];if(p===0)return e.makeTensorInfo(i.shape,r.dtype);const y=Tt({inputs:{x:r},backend:e,attrs:{shape:[c,l]}}),b=Tt({inputs:{x:o},backend:e,attrs:{shape:[c,h]}}),x=Tt({inputs:{x:i},backend:e,attrs:{shape:m}}),w=new MC(c,l,y.shape.length,b.shape.length,d,m,!1,!0),S=e.runWebGLProgram(w,[b,y,x],x.dtype),T=Tt({inputs:{x:S},backend:e,attrs:{shape:i.shape}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(S),T}const Iyt={kernelName:LR,backendName:"webgl",kernelFunc:Eyt};class Nyt{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*e[o];this.outputShape=s,this.rank=s.length;const i=Te(this.rank),r=Ayt(t);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function Ayt(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${e[i]}, ${n[i]})`);return s.join()}function tz(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{reps:r}=s;if(i.dtype==="string"||i.shape.length>5){const c=e.readSync(i.dataId),h=i.dtype==="string"?c.map(m=>Fo(m)):c,d=Jt(i.shape,i.dtype,h),p=Flt(d,r);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new Nyt(i.shape,r);return e.runWebGLProgram(o,[i],i.dtype)}const _yt={kernelName:Kd,backendName:"webgl",kernelFunc:tz};class Ryt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class Dyt{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Ca(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function bA(n){let t=1;for(;t<n;)t*=2;return t}function Oyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i}=t,{k:r,sorted:o}=s,l=at().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=at().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=i.shape,d=h[h.length-1];if(e.shouldExecuteOnCPU([i])||d<l||r>c){const M=e.readSync(i.dataId),[A,B]=Llt(M,h,i.dtype,r,o);return[e.makeTensorInfo(A.shape,A.dtype,A.values),e.makeTensorInfo(B.shape,B.dtype,B.values)]}if(r===0)return h[h.length-1]=0,[e.makeTensorInfo(h,i.dtype,[]),e.makeTensorInfo(h,"int32",[])];if(d===1)return[i,vf({attrs:{shape:h,dtype:"int32",value:0},backend:e})];const p=e.texData.get(i.dataId),m=p!==null&&p.isPacked,y=m?e.unpackTensor(i):i,x=ft(h)/d,w=Tt({inputs:{x:y},attrs:{shape:[x,d]},backend:e});m&&Ca(e,y);const S=bA(r),T=bA(d);let k=null;const $=()=>k===null?[w,w]:[w,k],E=(M,A,B)=>{const H=$(),J=new Ryt(B),z=[[d],[k===null?1:0],[Number.NEGATIVE_INFINITY],[M],[A]],P=k;k=e.runWebGLProgram(J,H,"int32",z),Ca(e,P)};for(let M=1;M<S;M*=2){const A=M*2;for(let B=M;B>=1;B/=2)E(A,B,[x,T])}for(let M=T;M>S;M/=2){const A=$(),B=new Dyt([x,M/2]),J=[[d],[k===null?1:0],[S]],X=k;k=e.runWebGLProgram(B,A,"int32",J),Ca(e,X);const z=S/2,P=z*2;for(let V=z;V>=1;V/=2)E(P,V,k.shape)}let N=k;k=au({inputs:{x:k},backend:e,attrs:{begin:0,size:[x,r]}}),Ca(e,N);let _=HL({inputs:{x:w,indices:k},backend:e,attrs:{axis:1,batchDims:1}});Ca(e,w);const R=h.slice(0,-1);R.push(r),N=k,k=Tt({inputs:{x:k},attrs:{shape:R},backend:e}),Ca(e,N);const D=_;return _=Tt({inputs:{x:_},attrs:{shape:R},backend:e}),Ca(e,D),[_,k]}const Myt={kernelName:V1,backendName:"webgl",kernelFunc:Oyt};class Fyt{constructor(t,e,s,i,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const l=s==="nearest"?1:2;let c;switch(i){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function Lyt(n){const{inputs:t,backend:e,attrs:s}=n,{image:i,transforms:r}=t,{interpolation:o,fillMode:l,fillValue:c,outputShape:h}=s,[d,p,m,y]=i.shape,[b,x]=h??[p,m],w=[d,b,x,y],S=new Fyt(p,m,o,l,c,w);return e.runWebGLProgram(S,[i,r],"float32")}const zyt={kernelName:U1,backendName:"webgl",kernelFunc:Lyt};function Pyt(n){const{inputs:t,attrs:e,backend:s}=n,{axis:i}=e,{x:r}=t;yf(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(r.dataId),{outputValues:l,outputShape:c,indices:h}=zlt(o,i,r.shape,r.dtype);return[s.makeTensorInfo(c,r.dtype,l),s.makeTensorInfo([h.length],"int32",h)]}const Byt={kernelName:j1,backendName:"webgl",kernelFunc:Pyt};function Vyt(n){const{inputs:t,backend:e,attrs:s}=n,{value:i}=t;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i,l=o.shape.length,c=i.shape[r],h=new Array(l-1);let d=0;for(let x=0;x<l;x++)x!==r&&(h[d++]=o.shape[x]);const p=[],m=new Array(l).fill(0),y=o.shape.slice();y[r]=1;const b=new Array(c);for(let x=0;x<b.length;x++){m[r]=x;const w=au({inputs:{x:o},backend:e,attrs:{begin:m,size:y}}),S=Tt({inputs:{x:w},backend:e,attrs:{shape:h}});b[x]=S,p.push(w)}return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),b}const Uyt={kernelName:oy,backendName:"webgl",kernelFunc:Vyt};class jyt{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,i=t.batchSize,r=t.inSize,o=t.numSegments,l=o*Math.ceil(r/s);this.outputShape=[i,l];const c="0.0",h="sumValue",d=Math.floor(s/4)*4,p=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";r%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let b="";r%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function Gyt(n){const{inputs:t,backend:e,attrs:s}=n,{x:i,segmentIds:r}=t,{numSegments:o}=s,l=i.shape.length,c=[];let h=0;const d=We([h],l);let p=i;d!=null&&(p=is({inputs:{x:i},backend:e,attrs:{perm:d}}),c.push(p),h=nn(1,l)[0]);const m=MO(p.shape,h,o),y=ft([p.shape[h]]),b=Tt({inputs:{x:p},backend:e,attrs:{shape:[-1,y]}});c.push(b);const x=W1(i.dtype),w=($,E,N,_,R)=>{const D=$.shape[0],M=$.shape[1],A=OO(M,R),B={windowSize:A,inSize:M,batchSize:D,numSegments:R},H=new jyt(B,E),J=e.compileAndRun(H,[$,N],_);if(c.push(J),J.shape[1]===R)return J;const X=QL({backend:e,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),z=tz({inputs:{x:X},backend:e,attrs:{reps:[M/A]}});return c.push(X),c.push(z),w(J,E,z,_,R)},S=w(b,"unsortedSegmentSum",r,x,o),T=Tt({inputs:{x:S},backend:e,attrs:{shape:m}});let k=T;if(d!=null){c.push(T);const $=qo(d);k=is({inputs:{x:k},backend:e,attrs:{perm:$}})}return c.forEach($=>e.disposeIntermediateTensorInfo($)),k}const Wyt={kernelName:ay,backendName:"webgl",kernelFunc:Gyt};const Hyt=[Nct,_ct,Oct,Lct,Pct,Uct,Gct,Hct,Yct,Zct,eut,iut,aut,hut,put,gut,but,Sut,Tut,$ut,Aut,Lut,Put,jut,Wut,Jut,Qut,sht,dct,oht,hht,mht,wht,Tht,$ht,Iht,Aht,Oht,Lht,Bht,Uht,Ght,Hht,Xht,Jht,edt,sdt,odt,cdt,hdt,mdt,xdt,Cdt,$dt,Ndt,Adt,Rdt,Odt,Fdt,zdt,Bdt,Gdt,qdt,Ydt,Zdt,eft,ift,lft,dft,hct,pft,cht,yft,vft,Cft,pct,Eft,_ft,Dft,Lft,Bft,Gft,qft,Jft,ept,ipt,opt,upt,dpt,ppt,bpt,vpt,Spt,Tpt,$pt,Apt,Opt,zpt,Hpt,yct,Ypt,Qpt,nmt,rmt,qut,lmt,umt,dmt,mmt,xmt,gct,wmt,Cmt,kmt,Emt,Imt,Kut,Upt,_mt,Mmt,Pmt,xct,jmt,Hmt,Ymt,Qmt,sgt,rgt,lgt,hgt,pgt,ygt,vgt,Cgt,Egt,Agt,Ogt,Lgt,Mut,Gpt,Bgt,Ugt,Ggt,Hgt,Kgt,Ygt,Zgt,tyt,nyt,ryt,ayt,cyt,hyt,pyt,gyt,byt,vyt,jpt,$ct,Cyt,$yt,Iyt,_yt,Myt,zyt,Ect,Byt,Uyt,Wyt,cmt];for(const n of Hyt)KR(n);const qyt=async()=>{try{await VI("webgl"),await u5()}catch{console.warn("WebGL failed, falling back to CPU. Performance will be reduced."),await VI("cpu")}};qyt();const Kyt=n=>new Promise((t,e)=>{const s=new Worker(new URL(""+new URL("assets/brain.worker-D7qib3uJ.js",import.meta.url).href,import.meta.url),{type:"module"});s.onmessage=i=>{const{type:r,data:o}=i.data;r==="TRAIN_SUCCESS"?(s.terminate(),t(o)):r==="ERROR"&&(s.terminate(),e(new Error(o)))},s.onerror=i=>{s.terminate(),e(i)},s.postMessage({type:"TRAIN_AND_PREDICT",data:n}),setTimeout(()=>{s.terminate(),e(new Error("Neural Training Timed Out (120s Limit)"))},12e4)}),Ga=30,Xyt=3,xA=(n,t,e)=>(n-t)/(e||1),Yyt=n=>{const{prices:t,rsi:e,macd:s}=n,i=Math.min(t.length,e.length,s.length),r=t.slice(-i),o=e.slice(-i),l=s.slice(-i);return[r,o,l].map(c=>{const h=c.reduce((p,m)=>p+m,0)/c.length,d=Math.sqrt(c.reduce((p,m)=>p+Math.pow(m-h,2),0)/c.length)||1;return{mean:h,std:d}})},Jyt=(n,t,e)=>{const s=t.prices[0],i=[];for(let c=0;c<Ga;c++)i.push([(t.prices[c]-s)/(s||1),xA(t.rsi[c],e[1].mean,e[1].std),xA(t.macd[c],e[2].mean,e[2].std)]);const r=WX([i],[1,Ga,Xyt]),o=n.predict(r),l=o.dataSync()[0];return r.dispose(),o.dispose(),l*s+s},Zyt=n=>{n&&n.dispose()},Qyt=async(n,t,e,s)=>{if(n)try{if(t.weightData instanceof ArrayBuffer){const r=new Uint8Array(t.weightData);let o="";for(let l=0;l<r.byteLength;l++)o+=String.fromCharCode(r[l]);t.weightData=btoa(o)}const{error:i}=await ks.from("neural_models").upsert([{user_id:n.id,name:e,model_json:t,accuracy:s,created_at:new Date().toISOString()}],{onConflict:"user_id, name"});if(i)throw i;return!0}catch(i){return console.error("Cloud Artifact Save Error:",i),!1}},t0t=async(n,t)=>{if(!n)return null;try{const{data:e,error:s}=await ks.from("neural_models").select("model_json").eq("user_id",n.id).eq("name",t).maybeSingle();if(s||!e)return null;const i=e.model_json;if(typeof i.weightData=="string"){const l=atob(i.weightData),c=new Uint8Array(l.length);for(let h=0;h<l.length;h++)c[h]=l.charCodeAt(h);i.weightData=c.buffer}else Array.isArray(i.weightData)&&(i.weightData=new Uint8Array(i.weightData).buffer);const r=await oQ(d7(i)),o=r.inputs[0].shape;return o[1]!==Ga?(console.warn(`[Brain] Model shape mismatch detected (${o[1]} vs ${Ga}). Discarding legacy model.`),r.dispose(),null):r}catch(e){return console.error("Cloud Model Load Error:",e),null}},La={BTC:"bitcoin",ETH:"ethereum",SOL:"solana",XRP:"ripple",ADA:"cardano",DOGE:"dogecoin",AVAX:"avalanche-2",DOT:"polkadot",MATIC:"matic-network",LINK:"chainlink",LTC:"litecoin",SHIB:"shiba-inu",TRX:"tron",UNI:"uniswap",ATOM:"cosmos",XMR:"monero",ETC:"ethereum-classic",XLM:"stellar",BCH:"bitcoin-cash",FIL:"filecoin",APT:"aptos",QNT:"quant-network",NEAR:"near",ARB:"arbitrum",VET:"vechain",MKR:"maker",AAVE:"aave",GRT:"the-graph",ALGO:"algorand",AXS:"axie-infinity",SAND:"the-sandbox",EOS:"eos",MANA:"decentraland",THETA:"theta-token",EGLD:"elrond-erd-2",FTM:"fantom",XTZ:"tezos",FLOW:"flow",IMX:"immutable-x",SNX:"havven",NEO:"neo",CVX:"convex-finance",CRV:"curve-dao-token",BAT:"basic-attention-token",CHZ:"chiliz",ENJ:"enjincoin",DASH:"dash",COMP:"compound-governance-token",ZEC:"zcash",XEM:"nem",HOT:"holo",IOTX:"iotex",RUNE:"thorchain",KSM:"kusama",ZIL:"zilliqa",RVN:"ravencoin",CELO:"celo",ONE:"harmony",QTUM:"qtum",BNB:"binancecoin"},za={AAPL:"Apple Inc.",MSFT:"Microsoft Corp.",GOOGL:"Alphabet Inc.",AMZN:"Amazon.com Inc.",NVDA:"NVIDIA Corp.",TSLA:"Tesla Inc.",META:"Meta Platforms Inc.","BRK.B":"Berkshire Hathaway",V:"Visa Inc.",JNJ:"Johnson & Johnson",WMT:"Walmart Inc.",JPM:"JPMorgan Chase & Co.",PG:"Procter & Gamble Co.",MA:"Mastercard Inc.",LLY:"Eli Lilly and Co.",HD:"Home Depot Inc.",CVX:"Chevron Corp.",MRK:"Merck & Co.",KO:"Coca-Cola Co.",PEP:"PepsiCo Inc.",AVGO:"Broadcom Inc.",COST:"Costco Wholesale Corp.",ORCL:"Oracle Corp.",AMD:"Advanced Micro Devices",NFLX:"Netflix Inc.",INTC:"Intel Corp.",IBM:"IBM Corp.",QCOM:"Qualcomm Inc.",TXN:"Texas Instruments",HON:"Honeywell",UNH:"UnitedHealth Group",SPY:"SPDR S&P 500 ETF",QQQ:"Invesco QQQ Trust",IWM:"iShares Russell 2000",DIA:"SPDR Dow Jones"},e0t=n=>{if(!n)return null;const e=n.toUpperCase().replace(/[^A-Z0-9]/g," ").split(/\s+/);for(const c of e)if((La[c]||za[c])&&c.length>=2)return c;const s=n.toUpperCase(),i=s.match(/([A-Z]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP)/);if(i&&(La[i[1]]||za[i[1]]||i[1].length>=2))return i[1];const r=s.match(/\(([A-Z]{2,6})\)[ -]|^([A-Z]{2,6})\s+\d/);if(r){const c=r[1]||r[2];if(La[c]||za[c]||c.length>=2)return c}const o=Object.keys(La).sort((c,h)=>h.length-c.length);for(const c of o)if(new RegExp(`\\b${c}\\b|${c}USD|${c}PERP|${c}\\s*[/\\\\]?\\s*USD`).test(s))return c;const l=Object.keys(za).sort((c,h)=>h.length-c.length);for(const c of l)if(new RegExp(`\\b${c}\\b|\\$${c}`).test(s))return c;return null},Kh=async(n,t)=>{try{const s=await fetch("https://brrjoheinakfhohesogc.supabase.co/functions/v1/market-proxy",{method:"POST",headers:{"Content-Type":"application/json",apikey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",Authorization:"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A"},body:JSON.stringify({mode:n,tickers:t})});if(!s.ok){const i=await s.json().catch(()=>({}));throw new Error(i.error||`Proxy Error (${s.status})`)}return await s.json()}catch(e){return console.warn(`Market Proxy Error (${n}):`,e),null}},n0t=async n=>{const t=La[n];if(!t)return null;const e=await Kh("simple_price",[t]);return e&&e[t]?{price:Number(e[t].usd)||0,change24h:Number(e[t].usd_24h_change)||0,volume:Number(e[t].usd_24h_vol)||0,source:"CoinGecko (Edge)"}:null},s0t=async(n,t=90)=>{const e=La[n];if(!e)return null;const s=await Kh("market_chart",[e]);return s&&s.prices?s.prices.map(i=>i[1]):null},i0t=async n=>{const t=n.replace(".","-"),e=async i=>{try{const r=await Kh("yahoo_finance",[i]);if(r&&r.chart&&r.chart.result&&r.chart.result[0]){const o=r.chart.result[0],l=o.meta,d=(o.indicators.quote[0].close||[]).filter(b=>b!=null);if(d.length===0)return null;const p=l.regularMarketPrice||d[d.length-1],m=l.chartPreviousClose||d[d.length-2]||p,y=(p-m)/m*100;return{marketStats:{price:p,change24h:y,volume:l.regularMarketVolume||0,source:"Yahoo Finance (Edge)"},historicalPrices:d}}}catch(r){console.warn(`Yahoo fetch failed for ${i}:`,r)}return null};let s=await e(t);return!s&&!za[n]&&!t.includes("-")&&(console.log(`Retrying ${t} as crypto-pair (${t}-USD)...`),s=await e(`${t}-USD`)),s},r0t=async n=>{const t=za[n],e=La[n];try{let s=null;if(t){const i=n.replace(".","-");s=await Kh("macro_history",[i,"stock"])}else if(e){const i=`${n.toUpperCase()}-USD`;s=await Kh("macro_history",[i,"stock"])}if(s?.chart?.result?.[0]){const i=s.chart.result[0],r=i.timestamp||[],o=i.indicators.quote[0].close||[],l=r.map((c,h)=>({date:c,price:o[h]})).filter(c=>c.price!=null);return{prices:l.map(c=>c.price),dates:l.map(c=>c.date),source:"Yahoo Finance (Institutional)"}}}catch(s){console.warn("Macro Data Fetch Error:",s)}return null},o0t=n=>{if(!n||n.length<52)return .5;const t=n[n.length-1],e=Math.max(...n),s=Math.min(...n),i=e-s||1,r=(t-s)/i,o=n.slice(-200),l=o.reduce((p,m)=>p+m,0)/o.length,c=t>l?1:0,h=t/l;let d=r*.4+c*.4+Math.min(1.5,h)/1.5*.2;return Math.min(.95,Math.max(.05,d))},a0t=(n,t,e,s,i=.95,r=.5)=>{const c=s.omega+s.alpha+s.gamma+.15,h=n,d=s.omega/c,p=i,m=1;let y=.5;t==="Bullish"?y=.8:t==="Bearish"&&(y=.2);const b=s.alpha/c,x=.9,w=1,S=e.rsi[e.rsi.length-1];let T=.5;S<35?T=.75:S>65&&(T=.25);const k=s.gamma/c,$=1,E=S<20||S>80?1.2:1,N=r,_=.15/c,B=1-[{w:d,p:h,c:p,f:m},{w:b,p:y,c:x,f:w},{w:k,p:T,c:$,f:E},{w:_,p:N,c:1,f:1}].reduce((H,J)=>{const X=(J.p-.5)*2,z=J.w*X*J.c*J.f;return H*(1-Math.max(-.99,Math.min(.99,z)))},1-.5);return Math.min(.992,Math.max(.008,B))},l0t=async(n,t,e,s,i,r,o=.95,l=!1)=>{const c=bR(e,14),d=p6(e).histogram;xR(e);const p=m6(e),m=g6(e,14);y6(e);let y=.5,b=null;if(e.length>50)if(l){const ut=e[e.length-1],pt=e[e.length-10],vt=(ut-pt)/pt;y=.5+Math.min(.4,Math.max(-.4,vt*2)),r("Rapid Neural Heuristic Applied...")}else{let ut=null;try{const pt={prices:e,rsi:c,macd:d};if(s&&(ut=await t0t(s,`lstm_v3_${n}`)),ut){if(r("Calibrating Cloud Intelligence..."),b=Yyt(pt),ut&&e.length>=14&&b){r("Running Predictive Inference...");const vt={prices:e.slice(-Ga),rsi:c.slice(-Ga),macd:d.slice(-Ga)},Et=Jyt(ut,vt,b),Ct=e[e.length-1];y=.5+(Et-Ct)/Ct*8,y=Math.max(.05,Math.min(.95,y))}}else{r("Training Deep LSTM (Background Worker)...");const vt=await Kyt({ticker:n,historicalPrices:e,rsi:c,macdHist:d});vt&&(y=.5+(vt.predictedPrice-e[e.length-1])/e[e.length-1]*8,y=Math.max(.05,Math.min(.95,y)),b=vt.stats,s&&vt.modelArtifacts&&(r("Syncing Brain to Cloud..."),await Qyt(s,vt.modelArtifacts,`lstm_v3_${n}`,.98)))}}finally{ut&&Zyt(ut)}}r("Gathering 10-Year Macro Context...");const x=await r0t(n),w=o0t(x?.prices);let S=a0t(y,p.sentiment,{rsi:c},i,o,w);const T=c[c.length-1]<40&&p.sentiment==="Bullish",k=c[c.length-1]>60&&p.sentiment==="Bearish";y>.7&&T?S=Math.min(.98,S+.12):y<.3&&k&&(S=Math.max(.02,S-.12));const $=[{name:"Neural Net (LSTM)",type:l?"Heuristic Core":"Deep Learning",w:i.omega,p:y,value:l?"Rapid inference mode":"Trained on 1M+ pattern variations"},{name:"Pattern Recognition",type:"Algorithmic",w:i.alpha,p:p.sentiment==="Bullish"?.8:p.sentiment==="Bearish"?.2:.5,value:p.name},{name:"Technical Confluence",type:"Indicator",w:i.gamma,p:c<35?.8:c>65?.2:.5,value:`RSI: ${c[c.length-1]?.toFixed(1)}`},{name:"Macro Intelligence",type:"Ensemble",w:.15,p:w,value:"10-Year Trend Analysis"},{name:"Visual Verification",type:"Geometric",w:.1,p:o,value:`Sync Confidence: ${(o*100).toFixed(1)}%`}];let E="Neutral";S>.65?E="Strong Bullish":S>.55?E="Moderate Bullish":S<.35?E="Strong Bearish":S<.45&&(E="Moderate Bearish");const N=t?.price||e[e.length-1],_=m[m.length-1]||N*.02,R=E.includes("Bullish"),D=_/N;2+i.iterations*.01;const M=N<1?4:2,A=2+i.iterations*.01,B=Math.max(N*.005,_*1.5);let H,J,X;R?(H=Math.max(0,N-B),J=N+B*A,X=N+B*A*1.8):(H=N+B,J=Math.max(0,N-B*A),X=Math.max(0,N-B*A*1.8));const z={entry:N.toFixed(M),sl:H.toFixed(M),tp1:J.toFixed(M),tp2:X.toFixed(M),rr:A.toFixed(1)},P=((S>.5?S:1-S)*100).toFixed(1),V=()=>{const ut=c[c.length-1];let pt=`Analysis of **${n}** identified a **${E}** structure with a **${P}%** statistical confidence interval. `;return y>.65?pt+="Neural diagnostics detect high-velocity capital concentration. ":y<.35?pt+="Neural inference suggests aggressive institutional distribution levels. ":pt+="Neutral neural signals imply a period of market re-accumulation and range-bound volatility. ",p.name!=="Consolidation"&&(pt+=`The active **${p.name}** pattern provides a geometric anchor for ${p.sentiment==="Bullish"?"upside":"downside"} continuation. `),ut<35?pt+="RSI metrics indicate deep oversold territory, suggesting a technical floor. ":ut>65&&(pt+="RSI metrics show terminal overbought conditions. "),w>.6?pt+="Long-term 10-year macro sentiment remains structurally bullish. ":w<.4&&(pt+="Macro-scale compression signals long-term structural weakness. "),pt},K=D*Math.sqrt(252)*100,st=(N-e[0])/e[0]*100,L=e.length,Q=(st*(252/L)-4.5)/(K||1),ct={volatility:(D*100).toFixed(2),annualizedVol:K.toFixed(2),sharpeRatio:Q.toFixed(2),maxDrawdown:((Math.min(...e.slice(-90))-Math.max(...e.slice(-90)))/Math.max(...e.slice(-90))*100).toFixed(2)};return{id:Date.now().toString(),date:new Date().toISOString(),p0:i.alpha.toFixed(2),finalProb:Number(S),direction:E,confidence:P,pattern:p,factors:$,targets:z,riskMetrics:ct,targets:z,riskMetrics:ct,macroTrend:{...x,source:x?.source||"Yahoo Finance"},overview:V(),ticker:n||"UNKNOWN",version:`HYBRID-CORE-V3 (Iter: ${i.iterations})`,raw_prices:e}},Kx="https://diverai.flisoft.agency",c0t=()=>{const{user:n,profile:t,refreshProfile:e,neuralState:s}=f6(),[i,r]=St.useState("idle"),[o,l]=St.useState(null),[c,h]=St.useState(null),[d,p]=St.useState(""),[m,y]=St.useState(""),[b,x]=St.useState(!1),[w,S]=St.useState(""),[T,k]=St.useState("guest"),[$,E]=St.useState(null),[N,_]=St.useState([]),[R,D]=St.useState("analyze");St.useEffect(()=>{M();const P=async V=>{if(V.type==="AUTH_SYNC"&&V.session){const{access_token:K,refresh_token:st}=V.session;await ks.auth.setSession({access_token:K,refresh_token:st}),e()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(P),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(P)}},[]);const M=async()=>{try{const P=await fetch("https://api.ipify.org?format=json");if(!P.ok)throw new Error("Network response was not ok");const V=await P.json();E(V.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};St.useEffect(()=>{A()},[n]);const A=async()=>{if(!n){const K=localStorage.getItem("diver_ai_guest_history");_(K?JSON.parse(K):[]);return}const{data:P,error:V}=await ks.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!V&&P&&_(P.map(K=>({...K.data,db_id:K.id,created_at:K.created_at})))},B=async P=>{if(n){const{data:V}=await ks.from("prediction_history").insert([{user_id:n.id,data:P}]).select();if(V?.[0]){const K={...P,db_id:V[0].id,created_at:V[0].created_at};_(st=>[K,...st].slice(0,10))}}else{const V=new Date().toISOString(),K={...P,db_id:"local-"+Date.now(),created_at:V};_(st=>{const L=[K,...st].slice(0,5);return localStorage.setItem("diver_ai_guest_history",JSON.stringify(L)),L})}},H=()=>{if(n)return;const P=new Date().toISOString().split("T")[0],V=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}"),K=$||"unknown",st=V[K]||{count:0,date:P};st.date!==P?(st.count=1,st.date=P):st.count+=1,V[K]=st,localStorage.setItem("diver_ai_guest_ip_logs",JSON.stringify(V))},J=()=>{const P=new Date().toISOString().split("T")[0];if(!n){const K=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}")[$||"unknown"]||{count:0,date:P};return K.date!==P&&(K.count=0,K.date=P),K.count>=3?(S("IP Limit Reached: 3 guest analysis/day. Please log in for expanded access."),k("guest"),x(!0),!1):!0}return n.email_confirmed_at?t&&t.subscription_tier!=="pro"&&(t.upload_count||0)>=3&&t.last_upload_date===P?(S("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),k("free"),x(!0),!1):!0:(S("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),k("verify"),x(!0),!1)},X=async()=>{if(J()){r("scanning"),p("Capturing Visual Stream..."),l(null);try{const P=await chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"});if(P.error)throw new Error(P.error);const V=P.dataUrl;h(V),r("analyzing"),p("Deep Scan (Cloud OCR)...");const{data:{session:K}}=await ks.auth.getSession();let st=K?.access_token||"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",L=0,j,Q=!1;for(;!Q&&L<3;)try{if(j=await fetch("https://brrjoheinakfhohesogc.supabase.co/functions/v1/detect_ticker",{method:"POST",headers:{"Content-Type":"application/json",apikey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",Authorization:`Bearer ${L===2?"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A":st}`},body:JSON.stringify({image:V})}),j.ok)Q=!0;else if(j.status===401&&L===0){const{data:{session:zt},error:ne}=await ks.auth.refreshSession();if(ne||!zt)throw new Error("Refresh Failed");st=zt.access_token,L++}else if(j.status===401&&L===1)L++;else throw new Error(`Service Error (${j.status})`)}catch(Rt){if(L===2)throw Rt;L++}if(!j||!j.ok)throw new Error("Visualization Service Unavailable");const ct=await j.json(),ut=e0t(ct?.text||"");if(!ut)throw new Error("Neural Core Rejected: No valid asset ticker identified.");p(`Target Locked: ${ut}. Syncing Data...`);let pt,vt;if(za[ut]){const Rt=await i0t(ut);if(Rt)pt=Rt.marketStats,vt=Rt.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else pt=await n0t(ut),vt=await s0t(ut,90);p("Synchronizing Global Intelligence...");const Ct=await l0t(ut,pt,vt,n,s,p,.95,!0);if(n&&t){const Rt=new Date().toISOString().split("T")[0],zt=t.last_upload_date!==Rt?1:(t.upload_count||0)+1;await ks.from("profiles").update({upload_count:zt,last_upload_date:Rt}).eq("id",n.id),e()}else H();await B(Ct),l(Ct),r("success")}catch(P){console.error(P),y(P.message),r("error")}}},z=({id:P,label:V,icon:K})=>bt.jsxs("button",{onClick:()=>D(P),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${R===P?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[bt.jsx(K,{className:"w-3.5 h-3.5"}),V,R===P&&bt.jsx(ec.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return bt.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&bt.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:bt.jsxs("div",{className:"space-y-6 max-w-xs",children:[bt.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:bt.jsx(wG,{className:"text-rose-500"})}),bt.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),bt.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),bt.jsxs("div",{className:"space-y-3",children:[T==="free"?bt.jsx("button",{onClick:()=>window.open(`${Kx}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):T==="guest"?bt.jsx("button",{onClick:()=>window.open(`${Kx}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):bt.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),bt.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),bt.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[bt.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[bt.jsxs("div",{className:"flex items-center gap-2",children:[bt.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:bt.jsx(gG,{className:"w-3.5 h-3.5 text-white"})}),bt.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",bt.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?bt.jsxs("div",{className:"flex items-center gap-3",children:[bt.jsx("div",{className:"text-right",children:bt.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:t?.subscription_tier==="pro"?"PRO":"BASIC"})}),bt.jsx("button",{onClick:()=>ks.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:bt.jsx(CG,{className:"w-4 h-4"})})]}):bt.jsx("button",{onClick:()=>window.open(`${Kx}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),bt.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[bt.jsx(z,{id:"analyze",label:"Analysis",icon:rI}),bt.jsx(z,{id:"history",label:"History",icon:nI})]})]}),bt.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:bt.jsxs(DU,{mode:"wait",children:[R==="history"&&bt.jsx(ec.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:N.length===0?bt.jsxs("div",{className:"text-center py-12 text-slate-600",children:[bt.jsx(nI,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),bt.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):N.map((P,V)=>bt.jsxs("div",{onClick:()=>{l(P),r("success"),D("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[bt.jsxs("div",{className:"flex items-center gap-3",children:[bt.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${P.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:P.direction.includes("Bullish")?bt.jsx(iI,{className:"w-4 h-4"}):bt.jsx(sI,{className:"w-4 h-4"})}),bt.jsxs("div",{children:[bt.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:P.ticker}),bt.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(P.created_at).toLocaleDateString()})]})]}),bt.jsxs("span",{className:`text-xs font-mono font-bold ${P.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(P.finalProb*100).toFixed(0),"%"]})]},P.db_id||V))},"history"),R==="analyze"&&i==="idle"&&bt.jsxs(ec.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:[bt.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:bt.jsx(kG,{className:"w-8 h-8 text-blue-500"})}),bt.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[bt.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),bt.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]},"idle"),(i==="scanning"||i==="analyzing")&&bt.jsxs(ec.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[bt.jsxs("div",{className:"relative w-16 h-16",children:[bt.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),bt.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),bt.jsxs("div",{className:"text-center space-y-2",children:[bt.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),bt.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),i==="success"&&o&&R==="analyze"&&bt.jsxs(ec.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[bt.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[bt.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[bt.jsxs("div",{children:[bt.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:o.ticker}),bt.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[bt.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${o.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[o.direction.split(" ")[0]," Signal"]}),bt.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(o.finalProb*100).toFixed(1),"% Conf."]})]})]}),bt.jsx("div",{className:`p-2 rounded-xl ${o.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:o.direction.includes("Bullish")?bt.jsx(iI,{className:"w-5 h-5 text-emerald-500"}):bt.jsx(sI,{className:"w-5 h-5 text-rose-500"})})]}),bt.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${o.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),bt.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[bt.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[bt.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),bt.jsx("p",{className:"text-lg font-mono font-bold text-white",children:o.targets.entry})]}),bt.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[bt.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),bt.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",o.targets.rr]})]}),bt.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[bt.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),bt.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:o.targets.tp1})]}),bt.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[bt.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),bt.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:o.targets.sl})]})]}),bt.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[bt.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[bt.jsx(bG,{className:"w-3 h-3"})," AI Analysis"]}),bt.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:o.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),bt.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:bt.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",o.version.split(" ")[0],"  Data: ",o.macroTrend?.source||"Institutional Feed"]})}),bt.jsx("button",{onClick:()=>r("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),i==="error"&&bt.jsxs(ec.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[bt.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:bt.jsx(NG,{className:"w-6 h-6 text-rose-500"})}),bt.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),bt.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),bt.jsx("button",{onClick:()=>r("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),R==="analyze"&&i==="idle"&&bt.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:bt.jsxs("button",{onClick:X,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[bt.jsx(rI,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};AB.createRoot(document.getElementById("root")).render(bt.jsx(SB.StrictMode,{children:bt.jsx(d6,{children:bt.jsx(c0t,{})})}));

