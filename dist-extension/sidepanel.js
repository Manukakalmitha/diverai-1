function IG(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in n)){const a=Object.getOwnPropertyDescriptor(s,r);a&&Object.defineProperty(n,r,a.get?a:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(r){if(r.ep)return;r.ep=!0;const a=t(r);fetch(r.href,a)}})();function TC(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function _G(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){var r=!1;try{r=this instanceof s}catch{}return r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:function(){return n[s]}})}),t}var J1={exports:{}},hf={};var dR;function AG(){if(dR)return hf;dR=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,r,a){var i=null;if(a!==void 0&&(i=""+a),r.key!==void 0&&(i=""+r.key),"key"in r){a={};for(var o in r)o!=="key"&&(a[o]=r[o])}else a=r;return r=a.ref,{$$typeof:n,type:s,key:i,ref:r!==void 0?r:null,props:a}}return hf.Fragment=e,hf.jsx=t,hf.jsxs=t,hf}var fR;function RG(){return fR||(fR=1,J1.exports=AG()),J1.exports}var me=RG(),Z1={exports:{}},Qe={};var pR;function DG(){if(pR)return Qe;pR=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),a=Symbol.for("react.consumer"),i=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.for("react.activity"),m=Symbol.iterator;function y(P){return P===null||typeof P!="object"?null:(P=m&&P[m]||P["@@iterator"],typeof P=="function"?P:null)}var b={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,w={};function v(P,j,te){this.props=P,this.context=j,this.refs=w,this.updater=te||b}v.prototype.isReactComponent={},v.prototype.setState=function(P,j){if(typeof P!="object"&&typeof P!="function"&&P!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,P,j,"setState")},v.prototype.forceUpdate=function(P){this.updater.enqueueForceUpdate(this,P,"forceUpdate")};function C(){}C.prototype=v.prototype;function N(P,j,te){this.props=P,this.context=j,this.refs=w,this.updater=te||b}var k=N.prototype=new C;k.constructor=N,x(k,v.prototype),k.isPureReactComponent=!0;var E=Array.isArray;function _(){}var R={H:null,A:null,T:null,S:null},D=Object.prototype.hasOwnProperty;function F(P,j,te){var oe=te.ref;return{$$typeof:n,type:P,key:j,ref:oe!==void 0?oe:null,props:te}}function L(P,j){return F(P.type,j,P.props)}function A(P){return typeof P=="object"&&P!==null&&P.$$typeof===n}function V(P){var j={"=":"=0",":":"=2"};return"$"+P.replace(/[=:]/g,function(te){return j[te]})}var q=/\/+/g;function ne(P,j){return typeof P=="object"&&P!==null&&P.key!=null?V(""+P.key):j.toString(36)}function Q(P){switch(P.status){case"fulfilled":return P.value;case"rejected":throw P.reason;default:switch(typeof P.status=="string"?P.then(_,_):(P.status="pending",P.then(function(j){P.status==="pending"&&(P.status="fulfilled",P.value=j)},function(j){P.status==="pending"&&(P.status="rejected",P.reason=j)})),P.status){case"fulfilled":return P.value;case"rejected":throw P.reason}}throw P}function B(P,j,te,oe,pe){var xe=typeof P;(xe==="undefined"||xe==="boolean")&&(P=null);var Te=!1;if(P===null)Te=!0;else switch(xe){case"bigint":case"string":case"number":Te=!0;break;case"object":switch(P.$$typeof){case n:case e:Te=!0;break;case d:return Te=P._init,B(Te(P._payload),j,te,oe,pe)}}if(Te)return pe=pe(P),Te=oe===""?"."+ne(P,0):oe,E(pe)?(te="",Te!=null&&(te=Te.replace(q,"$&/")+"/"),B(pe,j,te,"",function(Ue){return Ue})):pe!=null&&(A(pe)&&(pe=L(pe,te+(pe.key==null||P&&P.key===pe.key?"":(""+pe.key).replace(q,"$&/")+"/")+Te)),j.push(pe)),1;Te=0;var _e=oe===""?".":oe+":";if(E(P))for(var $e=0;$e<P.length;$e++)oe=P[$e],xe=_e+ne(oe,$e),Te+=B(oe,j,te,xe,pe);else if($e=y(P),typeof $e=="function")for(P=$e.call(P),$e=0;!(oe=P.next()).done;)oe=oe.value,xe=_e+ne(oe,$e++),Te+=B(oe,j,te,xe,pe);else if(xe==="object"){if(typeof P.then=="function")return B(Q(P),j,te,oe,pe);throw j=String(P),Error("Objects are not valid as a React child (found: "+(j==="[object Object]"?"object with keys {"+Object.keys(P).join(", ")+"}":j)+"). If you meant to render a collection of children, use an array instead.")}return Te}function U(P,j,te){if(P==null)return P;var oe=[],pe=0;return B(P,oe,"","",function(xe){return j.call(te,xe,pe++)}),oe}function X(P){if(P._status===-1){var j=P._result;j=j(),j.then(function(te){(P._status===0||P._status===-1)&&(P._status=1,P._result=te)},function(te){(P._status===0||P._status===-1)&&(P._status=2,P._result=te)}),P._status===-1&&(P._status=0,P._result=j)}if(P._status===1)return P._result.default;throw P._result}var K=typeof reportError=="function"?reportError:function(P){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var j=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof P=="object"&&P!==null&&typeof P.message=="string"?String(P.message):String(P),error:P});if(!window.dispatchEvent(j))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",P);return}console.error(P)},se={map:U,forEach:function(P,j,te){U(P,function(){j.apply(this,arguments)},te)},count:function(P){var j=0;return U(P,function(){j++}),j},toArray:function(P){return U(P,function(j){return j})||[]},only:function(P){if(!A(P))throw Error("React.Children.only expected to receive a single React element child.");return P}};return Qe.Activity=f,Qe.Children=se,Qe.Component=v,Qe.Fragment=t,Qe.Profiler=r,Qe.PureComponent=N,Qe.StrictMode=s,Qe.Suspense=l,Qe.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=R,Qe.__COMPILER_RUNTIME={__proto__:null,c:function(P){return R.H.useMemoCache(P)}},Qe.cache=function(P){return function(){return P.apply(null,arguments)}},Qe.cacheSignal=function(){return null},Qe.cloneElement=function(P,j,te){if(P==null)throw Error("The argument must be a React element, but you passed "+P+".");var oe=x({},P.props),pe=P.key;if(j!=null)for(xe in j.key!==void 0&&(pe=""+j.key),j)!D.call(j,xe)||xe==="key"||xe==="__self"||xe==="__source"||xe==="ref"&&j.ref===void 0||(oe[xe]=j[xe]);var xe=arguments.length-2;if(xe===1)oe.children=te;else if(1<xe){for(var Te=Array(xe),_e=0;_e<xe;_e++)Te[_e]=arguments[_e+2];oe.children=Te}return F(P.type,pe,oe)},Qe.createContext=function(P){return P={$$typeof:i,_currentValue:P,_currentValue2:P,_threadCount:0,Provider:null,Consumer:null},P.Provider=P,P.Consumer={$$typeof:a,_context:P},P},Qe.createElement=function(P,j,te){var oe,pe={},xe=null;if(j!=null)for(oe in j.key!==void 0&&(xe=""+j.key),j)D.call(j,oe)&&oe!=="key"&&oe!=="__self"&&oe!=="__source"&&(pe[oe]=j[oe]);var Te=arguments.length-2;if(Te===1)pe.children=te;else if(1<Te){for(var _e=Array(Te),$e=0;$e<Te;$e++)_e[$e]=arguments[$e+2];pe.children=_e}if(P&&P.defaultProps)for(oe in Te=P.defaultProps,Te)pe[oe]===void 0&&(pe[oe]=Te[oe]);return F(P,xe,pe)},Qe.createRef=function(){return{current:null}},Qe.forwardRef=function(P){return{$$typeof:o,render:P}},Qe.isValidElement=A,Qe.lazy=function(P){return{$$typeof:d,_payload:{_status:-1,_result:P},_init:X}},Qe.memo=function(P,j){return{$$typeof:h,type:P,compare:j===void 0?null:j}},Qe.startTransition=function(P){var j=R.T,te={};R.T=te;try{var oe=P(),pe=R.S;pe!==null&&pe(te,oe),typeof oe=="object"&&oe!==null&&typeof oe.then=="function"&&oe.then(_,K)}catch(xe){K(xe)}finally{j!==null&&te.types!==null&&(j.types=te.types),R.T=j}},Qe.unstable_useCacheRefresh=function(){return R.H.useCacheRefresh()},Qe.use=function(P){return R.H.use(P)},Qe.useActionState=function(P,j,te){return R.H.useActionState(P,j,te)},Qe.useCallback=function(P,j){return R.H.useCallback(P,j)},Qe.useContext=function(P){return R.H.useContext(P)},Qe.useDebugValue=function(){},Qe.useDeferredValue=function(P,j){return R.H.useDeferredValue(P,j)},Qe.useEffect=function(P,j){return R.H.useEffect(P,j)},Qe.useEffectEvent=function(P){return R.H.useEffectEvent(P)},Qe.useId=function(){return R.H.useId()},Qe.useImperativeHandle=function(P,j,te){return R.H.useImperativeHandle(P,j,te)},Qe.useInsertionEffect=function(P,j){return R.H.useInsertionEffect(P,j)},Qe.useLayoutEffect=function(P,j){return R.H.useLayoutEffect(P,j)},Qe.useMemo=function(P,j){return R.H.useMemo(P,j)},Qe.useOptimistic=function(P,j){return R.H.useOptimistic(P,j)},Qe.useReducer=function(P,j,te){return R.H.useReducer(P,j,te)},Qe.useRef=function(P){return R.H.useRef(P)},Qe.useState=function(P){return R.H.useState(P)},Qe.useSyncExternalStore=function(P,j,te){return R.H.useSyncExternalStore(P,j,te)},Qe.useTransition=function(){return R.H.useTransition()},Qe.version="19.2.3",Qe}var mR;function CC(){return mR||(mR=1,Z1.exports=DG()),Z1.exports}var Ce=CC();const OG=TC(Ce);var Q1={exports:{}},df={},eS={exports:{}},tS={};var gR;function FG(){return gR||(gR=1,(function(n){function e(B,U){var X=B.length;B.push(U);e:for(;0<X;){var K=X-1>>>1,se=B[K];if(0<r(se,U))B[K]=U,B[X]=se,X=K;else break e}}function t(B){return B.length===0?null:B[0]}function s(B){if(B.length===0)return null;var U=B[0],X=B.pop();if(X!==U){B[0]=X;e:for(var K=0,se=B.length,P=se>>>1;K<P;){var j=2*(K+1)-1,te=B[j],oe=j+1,pe=B[oe];if(0>r(te,X))oe<se&&0>r(pe,te)?(B[K]=pe,B[oe]=X,K=oe):(B[K]=te,B[j]=X,K=j);else if(oe<se&&0>r(pe,X))B[K]=pe,B[oe]=X,K=oe;else break e}}return U}function r(B,U){var X=B.sortIndex-U.sortIndex;return X!==0?X:B.id-U.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var a=performance;n.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();n.unstable_now=function(){return i.now()-o}}var l=[],h=[],d=1,f=null,m=3,y=!1,b=!1,x=!1,w=!1,v=typeof setTimeout=="function"?setTimeout:null,C=typeof clearTimeout=="function"?clearTimeout:null,N=typeof setImmediate<"u"?setImmediate:null;function k(B){for(var U=t(h);U!==null;){if(U.callback===null)s(h);else if(U.startTime<=B)s(h),U.sortIndex=U.expirationTime,e(l,U);else break;U=t(h)}}function E(B){if(x=!1,k(B),!b)if(t(l)!==null)b=!0,_||(_=!0,V());else{var U=t(h);U!==null&&Q(E,U.startTime-B)}}var _=!1,R=-1,D=5,F=-1;function L(){return w?!0:!(n.unstable_now()-F<D)}function A(){if(w=!1,_){var B=n.unstable_now();F=B;var U=!0;try{e:{b=!1,x&&(x=!1,C(R),R=-1),y=!0;var X=m;try{t:{for(k(B),f=t(l);f!==null&&!(f.expirationTime>B&&L());){var K=f.callback;if(typeof K=="function"){f.callback=null,m=f.priorityLevel;var se=K(f.expirationTime<=B);if(B=n.unstable_now(),typeof se=="function"){f.callback=se,k(B),U=!0;break t}f===t(l)&&s(l),k(B)}else s(l);f=t(l)}if(f!==null)U=!0;else{var P=t(h);P!==null&&Q(E,P.startTime-B),U=!1}}break e}finally{f=null,m=X,y=!1}U=void 0}}finally{U?V():_=!1}}}var V;if(typeof N=="function")V=function(){N(A)};else if(typeof MessageChannel<"u"){var q=new MessageChannel,ne=q.port2;q.port1.onmessage=A,V=function(){ne.postMessage(null)}}else V=function(){v(A,0)};function Q(B,U){R=v(function(){B(n.unstable_now())},U)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(B){B.callback=null},n.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<B?Math.floor(1e3/B):5},n.unstable_getCurrentPriorityLevel=function(){return m},n.unstable_next=function(B){switch(m){case 1:case 2:case 3:var U=3;break;default:U=m}var X=m;m=U;try{return B()}finally{m=X}},n.unstable_requestPaint=function(){w=!0},n.unstable_runWithPriority=function(B,U){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var X=m;m=B;try{return U()}finally{m=X}},n.unstable_scheduleCallback=function(B,U,X){var K=n.unstable_now();switch(typeof X=="object"&&X!==null?(X=X.delay,X=typeof X=="number"&&0<X?K+X:K):X=K,B){case 1:var se=-1;break;case 2:se=250;break;case 5:se=1073741823;break;case 4:se=1e4;break;default:se=5e3}return se=X+se,B={id:d++,callback:U,priorityLevel:B,startTime:X,expirationTime:se,sortIndex:-1},X>K?(B.sortIndex=X,e(h,B),t(l)===null&&B===t(h)&&(x?(C(R),R=-1):x=!0,Q(E,X-K))):(B.sortIndex=se,e(l,B),b||y||(b=!0,_||(_=!0,V()))),B},n.unstable_shouldYield=L,n.unstable_wrapCallback=function(B){var U=m;return function(){var X=m;m=U;try{return B.apply(this,arguments)}finally{m=X}}}})(tS)),tS}var yR;function LG(){return yR||(yR=1,eS.exports=FG()),eS.exports}var nS={exports:{}},ds={};var bR;function MG(){if(bR)return ds;bR=1;var n=CC();function e(l){var h="https://react.dev/errors/"+l;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)h+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+l+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},r=Symbol.for("react.portal");function a(l,h,d){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:f==null?null:""+f,children:l,containerInfo:h,implementation:d}}var i=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(l,h){if(l==="font")return"";if(typeof h=="string")return h==="use-credentials"?h:""}return ds.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,ds.createPortal=function(l,h){var d=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!h||h.nodeType!==1&&h.nodeType!==9&&h.nodeType!==11)throw Error(e(299));return a(l,h,null,d)},ds.flushSync=function(l){var h=i.T,d=s.p;try{if(i.T=null,s.p=2,l)return l()}finally{i.T=h,s.p=d,s.d.f()}},ds.preconnect=function(l,h){typeof l=="string"&&(h?(h=h.crossOrigin,h=typeof h=="string"?h==="use-credentials"?h:"":void 0):h=null,s.d.C(l,h))},ds.prefetchDNS=function(l){typeof l=="string"&&s.d.D(l)},ds.preinit=function(l,h){if(typeof l=="string"&&h&&typeof h.as=="string"){var d=h.as,f=o(d,h.crossOrigin),m=typeof h.integrity=="string"?h.integrity:void 0,y=typeof h.fetchPriority=="string"?h.fetchPriority:void 0;d==="style"?s.d.S(l,typeof h.precedence=="string"?h.precedence:void 0,{crossOrigin:f,integrity:m,fetchPriority:y}):d==="script"&&s.d.X(l,{crossOrigin:f,integrity:m,fetchPriority:y,nonce:typeof h.nonce=="string"?h.nonce:void 0})}},ds.preinitModule=function(l,h){if(typeof l=="string")if(typeof h=="object"&&h!==null){if(h.as==null||h.as==="script"){var d=o(h.as,h.crossOrigin);s.d.M(l,{crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0})}}else h==null&&s.d.M(l)},ds.preload=function(l,h){if(typeof l=="string"&&typeof h=="object"&&h!==null&&typeof h.as=="string"){var d=h.as,f=o(d,h.crossOrigin);s.d.L(l,d,{crossOrigin:f,integrity:typeof h.integrity=="string"?h.integrity:void 0,nonce:typeof h.nonce=="string"?h.nonce:void 0,type:typeof h.type=="string"?h.type:void 0,fetchPriority:typeof h.fetchPriority=="string"?h.fetchPriority:void 0,referrerPolicy:typeof h.referrerPolicy=="string"?h.referrerPolicy:void 0,imageSrcSet:typeof h.imageSrcSet=="string"?h.imageSrcSet:void 0,imageSizes:typeof h.imageSizes=="string"?h.imageSizes:void 0,media:typeof h.media=="string"?h.media:void 0})}},ds.preloadModule=function(l,h){if(typeof l=="string")if(h){var d=o(h.as,h.crossOrigin);s.d.m(l,{as:typeof h.as=="string"&&h.as!=="script"?h.as:void 0,crossOrigin:d,integrity:typeof h.integrity=="string"?h.integrity:void 0})}else s.d.m(l)},ds.requestFormReset=function(l){s.d.r(l)},ds.unstable_batchedUpdates=function(l,h){return l(h)},ds.useFormState=function(l,h,d){return i.H.useFormState(l,h,d)},ds.useFormStatus=function(){return i.H.useHostTransitionStatus()},ds.version="19.2.3",ds}var xR;function zG(){if(xR)return nS.exports;xR=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),nS.exports=MG(),nS.exports}var wR;function PG(){if(wR)return df;wR=1;var n=LG(),e=CC(),t=zG();function s(u){var c="https://react.dev/errors/"+u;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var p=2;p<arguments.length;p++)c+="&args[]="+encodeURIComponent(arguments[p])}return"Minified React error #"+u+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(u){return!(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)}function a(u){var c=u,p=u;if(u.alternate)for(;c.return;)c=c.return;else{u=c;do c=u,(c.flags&4098)!==0&&(p=c.return),u=c.return;while(u)}return c.tag===3?p:null}function i(u){if(u.tag===13){var c=u.memoizedState;if(c===null&&(u=u.alternate,u!==null&&(c=u.memoizedState)),c!==null)return c.dehydrated}return null}function o(u){if(u.tag===31){var c=u.memoizedState;if(c===null&&(u=u.alternate,u!==null&&(c=u.memoizedState)),c!==null)return c.dehydrated}return null}function l(u){if(a(u)!==u)throw Error(s(188))}function h(u){var c=u.alternate;if(!c){if(c=a(u),c===null)throw Error(s(188));return c!==u?null:u}for(var p=u,g=c;;){var S=p.return;if(S===null)break;var T=S.alternate;if(T===null){if(g=S.return,g!==null){p=g;continue}break}if(S.child===T.child){for(T=S.child;T;){if(T===p)return l(S),u;if(T===g)return l(S),c;T=T.sibling}throw Error(s(188))}if(p.return!==g.return)p=S,g=T;else{for(var I=!1,z=S.child;z;){if(z===p){I=!0,p=S,g=T;break}if(z===g){I=!0,g=S,p=T;break}z=z.sibling}if(!I){for(z=T.child;z;){if(z===p){I=!0,p=T,g=S;break}if(z===g){I=!0,g=T,p=S;break}z=z.sibling}if(!I)throw Error(s(189))}}if(p.alternate!==g)throw Error(s(190))}if(p.tag!==3)throw Error(s(188));return p.stateNode.current===p?u:c}function d(u){var c=u.tag;if(c===5||c===26||c===27||c===6)return u;for(u=u.child;u!==null;){if(c=d(u),c!==null)return c;u=u.sibling}return null}var f=Object.assign,m=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),b=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),w=Symbol.for("react.strict_mode"),v=Symbol.for("react.profiler"),C=Symbol.for("react.consumer"),N=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),R=Symbol.for("react.memo"),D=Symbol.for("react.lazy"),F=Symbol.for("react.activity"),L=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function V(u){return u===null||typeof u!="object"?null:(u=A&&u[A]||u["@@iterator"],typeof u=="function"?u:null)}var q=Symbol.for("react.client.reference");function ne(u){if(u==null)return null;if(typeof u=="function")return u.$$typeof===q?null:u.displayName||u.name||null;if(typeof u=="string")return u;switch(u){case x:return"Fragment";case v:return"Profiler";case w:return"StrictMode";case E:return"Suspense";case _:return"SuspenseList";case F:return"Activity"}if(typeof u=="object")switch(u.$$typeof){case b:return"Portal";case N:return u.displayName||"Context";case C:return(u._context.displayName||"Context")+".Consumer";case k:var c=u.render;return u=u.displayName,u||(u=c.displayName||c.name||"",u=u!==""?"ForwardRef("+u+")":"ForwardRef"),u;case R:return c=u.displayName||null,c!==null?c:ne(u.type)||"Memo";case D:c=u._payload,u=u._init;try{return ne(u(c))}catch{}}return null}var Q=Array.isArray,B=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,U=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,X={pending:!1,data:null,method:null,action:null},K=[],se=-1;function P(u){return{current:u}}function j(u){0>se||(u.current=K[se],K[se]=null,se--)}function te(u,c){se++,K[se]=u.current,u.current=c}var oe=P(null),pe=P(null),xe=P(null),Te=P(null);function _e(u,c){switch(te(xe,c),te(pe,u),te(oe,null),c.nodeType){case 9:case 11:u=(u=c.documentElement)&&(u=u.namespaceURI)?FA(u):0;break;default:if(u=c.tagName,c=c.namespaceURI)c=FA(c),u=LA(c,u);else switch(u){case"svg":u=1;break;case"math":u=2;break;default:u=0}}j(oe),te(oe,u)}function $e(){j(oe),j(pe),j(xe)}function Ue(u){u.memoizedState!==null&&te(Te,u);var c=oe.current,p=LA(c,u.type);c!==p&&(te(pe,u),te(oe,p))}function Se(u){pe.current===u&&(j(oe),j(pe)),Te.current===u&&(j(Te),of._currentValue=X)}var je,Ye;function Ke(u){if(je===void 0)try{throw Error()}catch(p){var c=p.stack.trim().match(/\n( *(at )?)/);je=c&&c[1]||"",Ye=-1<p.stack.indexOf(`
    at`)?" (<anonymous>)":-1<p.stack.indexOf("@")?"@unknown:0:0":""}return`
`+je+u+Ye}var ot=!1;function gt(u,c){if(!u||ot)return"";ot=!0;var p=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var g={DetermineComponentFrameRoot:function(){try{if(c){var be=function(){throw Error()};if(Object.defineProperty(be.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(be,[])}catch(de){var ce=de}Reflect.construct(u,[],be)}else{try{be.call()}catch(de){ce=de}u.call(be.prototype)}}else{try{throw Error()}catch(de){ce=de}(be=u())&&typeof be.catch=="function"&&be.catch(function(){})}}catch(de){if(de&&ce&&typeof de.stack=="string")return[de.stack,ce.stack]}return[null,null]}};g.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var S=Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot,"name");S&&S.configurable&&Object.defineProperty(g.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var T=g.DetermineComponentFrameRoot(),I=T[0],z=T[1];if(I&&z){var H=I.split(`
`),ue=z.split(`
`);for(S=g=0;g<H.length&&!H[g].includes("DetermineComponentFrameRoot");)g++;for(;S<ue.length&&!ue[S].includes("DetermineComponentFrameRoot");)S++;if(g===H.length||S===ue.length)for(g=H.length-1,S=ue.length-1;1<=g&&0<=S&&H[g]!==ue[S];)S--;for(;1<=g&&0<=S;g--,S--)if(H[g]!==ue[S]){if(g!==1||S!==1)do if(g--,S--,0>S||H[g]!==ue[S]){var ge=`
`+H[g].replace(" at new "," at ");return u.displayName&&ge.includes("<anonymous>")&&(ge=ge.replace("<anonymous>",u.displayName)),ge}while(1<=g&&0<=S);break}}}finally{ot=!1,Error.prepareStackTrace=p}return(p=u?u.displayName||u.name:"")?Ke(p):""}function Pt(u,c){switch(u.tag){case 26:case 27:case 5:return Ke(u.type);case 16:return Ke("Lazy");case 13:return u.child!==c&&c!==null?Ke("Suspense Fallback"):Ke("Suspense");case 19:return Ke("SuspenseList");case 0:case 15:return gt(u.type,!1);case 11:return gt(u.type.render,!1);case 1:return gt(u.type,!0);case 31:return Ke("Activity");default:return""}}function _t(u){try{var c="",p=null;do c+=Pt(u,p),p=u,u=u.return;while(u);return c}catch(g){return`
Error generating stack: `+g.message+`
`+g.stack}}var nr=Object.prototype.hasOwnProperty,nn=n.unstable_scheduleCallback,kr=n.unstable_cancelCallback,Ts=n.unstable_shouldYield,Ja=n.unstable_requestPaint,Vt=n.unstable_now,Jr=n.unstable_getCurrentPriorityLevel,Zr=n.unstable_ImmediatePriority,Qr=n.unstable_UserBlockingPriority,sr=n.unstable_NormalPriority,Jo=n.unstable_LowPriority,Nu=n.unstable_IdlePriority,bd=n.log,zw=n.unstable_setDisableYieldValue,ka=null,Cs=null;function Ea(u){if(typeof bd=="function"&&zw(u),Cs&&typeof Cs.setStrictMode=="function")try{Cs.setStrictMode(ka,u)}catch{}}var rr=Math.clz32?Math.clz32:mj,fj=Math.log,pj=Math.LN2;function mj(u){return u>>>=0,u===0?32:31-(fj(u)/pj|0)|0}var ug=256,cg=262144,hg=4194304;function Zo(u){var c=u&42;if(c!==0)return c;switch(u&-u){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return u&261888;case 262144:case 524288:case 1048576:case 2097152:return u&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return u&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return u}}function dg(u,c,p){var g=u.pendingLanes;if(g===0)return 0;var S=0,T=u.suspendedLanes,I=u.pingedLanes;u=u.warmLanes;var z=g&134217727;return z!==0?(g=z&~T,g!==0?S=Zo(g):(I&=z,I!==0?S=Zo(I):p||(p=z&~u,p!==0&&(S=Zo(p))))):(z=g&~T,z!==0?S=Zo(z):I!==0?S=Zo(I):p||(p=g&~u,p!==0&&(S=Zo(p)))),S===0?0:c!==0&&c!==S&&(c&T)===0&&(T=S&-S,p=c&-c,T>=p||T===32&&(p&4194048)!==0)?c:S}function xd(u,c){return(u.pendingLanes&~(u.suspendedLanes&~u.pingedLanes)&c)===0}function gj(u,c){switch(u){case 1:case 2:case 4:case 8:case 64:return c+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return c+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function g$(){var u=hg;return hg<<=1,(hg&62914560)===0&&(hg=4194304),u}function Pw(u){for(var c=[],p=0;31>p;p++)c.push(u);return c}function wd(u,c){u.pendingLanes|=c,c!==268435456&&(u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0)}function yj(u,c,p,g,S,T){var I=u.pendingLanes;u.pendingLanes=p,u.suspendedLanes=0,u.pingedLanes=0,u.warmLanes=0,u.expiredLanes&=p,u.entangledLanes&=p,u.errorRecoveryDisabledLanes&=p,u.shellSuspendCounter=0;var z=u.entanglements,H=u.expirationTimes,ue=u.hiddenUpdates;for(p=I&~p;0<p;){var ge=31-rr(p),be=1<<ge;z[ge]=0,H[ge]=-1;var ce=ue[ge];if(ce!==null)for(ue[ge]=null,ge=0;ge<ce.length;ge++){var de=ce[ge];de!==null&&(de.lane&=-536870913)}p&=~be}g!==0&&y$(u,g,0),T!==0&&S===0&&u.tag!==0&&(u.suspendedLanes|=T&~(I&~c))}function y$(u,c,p){u.pendingLanes|=c,u.suspendedLanes&=~c;var g=31-rr(c);u.entangledLanes|=c,u.entanglements[g]=u.entanglements[g]|1073741824|p&261930}function b$(u,c){var p=u.entangledLanes|=c;for(u=u.entanglements;p;){var g=31-rr(p),S=1<<g;S&c|u[g]&c&&(u[g]|=c),p&=~S}}function x$(u,c){var p=c&-c;return p=(p&42)!==0?1:Bw(p),(p&(u.suspendedLanes|c))!==0?0:p}function Bw(u){switch(u){case 2:u=1;break;case 8:u=4;break;case 32:u=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:u=128;break;case 268435456:u=134217728;break;default:u=0}return u}function Vw(u){return u&=-u,2<u?8<u?(u&134217727)!==0?32:268435456:8:2}function w$(){var u=U.p;return u!==0?u:(u=window.event,u===void 0?32:aR(u.type))}function v$(u,c){var p=U.p;try{return U.p=u,c()}finally{U.p=p}}var Ui=Math.random().toString(36).slice(2),ns="__reactFiber$"+Ui,Ls="__reactProps$"+Ui,ku="__reactContainer$"+Ui,Uw="__reactEvents$"+Ui,bj="__reactListeners$"+Ui,xj="__reactHandles$"+Ui,S$="__reactResources$"+Ui,vd="__reactMarker$"+Ui;function jw(u){delete u[ns],delete u[Ls],delete u[Uw],delete u[bj],delete u[xj]}function Eu(u){var c=u[ns];if(c)return c;for(var p=u.parentNode;p;){if(c=p[ku]||p[ns]){if(p=c.alternate,c.child!==null||p!==null&&p.child!==null)for(u=jA(u);u!==null;){if(p=u[ns])return p;u=jA(u)}return c}u=p,p=u.parentNode}return null}function $u(u){if(u=u[ns]||u[ku]){var c=u.tag;if(c===5||c===6||c===13||c===31||c===26||c===27||c===3)return u}return null}function Sd(u){var c=u.tag;if(c===5||c===26||c===27||c===6)return u.stateNode;throw Error(s(33))}function Iu(u){var c=u[S$];return c||(c=u[S$]={hoistableStyles:new Map,hoistableScripts:new Map}),c}function jn(u){u[vd]=!0}var T$=new Set,C$={};function Qo(u,c){_u(u,c),_u(u+"Capture",c)}function _u(u,c){for(C$[u]=c,u=0;u<c.length;u++)T$.add(c[u])}var wj=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),N$={},k$={};function vj(u){return nr.call(k$,u)?!0:nr.call(N$,u)?!1:wj.test(u)?k$[u]=!0:(N$[u]=!0,!1)}function fg(u,c,p){if(vj(c))if(p===null)u.removeAttribute(c);else{switch(typeof p){case"undefined":case"function":case"symbol":u.removeAttribute(c);return;case"boolean":var g=c.toLowerCase().slice(0,5);if(g!=="data-"&&g!=="aria-"){u.removeAttribute(c);return}}u.setAttribute(c,""+p)}}function pg(u,c,p){if(p===null)u.removeAttribute(c);else{switch(typeof p){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(c);return}u.setAttribute(c,""+p)}}function Za(u,c,p,g){if(g===null)u.removeAttribute(p);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":u.removeAttribute(p);return}u.setAttributeNS(c,p,""+g)}}function Er(u){switch(typeof u){case"bigint":case"boolean":case"number":case"string":case"undefined":return u;case"object":return u;default:return""}}function E$(u){var c=u.type;return(u=u.nodeName)&&u.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function Sj(u,c,p){var g=Object.getOwnPropertyDescriptor(u.constructor.prototype,c);if(!u.hasOwnProperty(c)&&typeof g<"u"&&typeof g.get=="function"&&typeof g.set=="function"){var S=g.get,T=g.set;return Object.defineProperty(u,c,{configurable:!0,get:function(){return S.call(this)},set:function(I){p=""+I,T.call(this,I)}}),Object.defineProperty(u,c,{enumerable:g.enumerable}),{getValue:function(){return p},setValue:function(I){p=""+I},stopTracking:function(){u._valueTracker=null,delete u[c]}}}}function Ww(u){if(!u._valueTracker){var c=E$(u)?"checked":"value";u._valueTracker=Sj(u,c,""+u[c])}}function $$(u){if(!u)return!1;var c=u._valueTracker;if(!c)return!0;var p=c.getValue(),g="";return u&&(g=E$(u)?u.checked?"true":"false":u.value),u=g,u!==p?(c.setValue(u),!0):!1}function mg(u){if(u=u||(typeof document<"u"?document:void 0),typeof u>"u")return null;try{return u.activeElement||u.body}catch{return u.body}}var Tj=/[\n"\\]/g;function $r(u){return u.replace(Tj,function(c){return"\\"+c.charCodeAt(0).toString(16)+" "})}function Gw(u,c,p,g,S,T,I,z){u.name="",I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"?u.type=I:u.removeAttribute("type"),c!=null?I==="number"?(c===0&&u.value===""||u.value!=c)&&(u.value=""+Er(c)):u.value!==""+Er(c)&&(u.value=""+Er(c)):I!=="submit"&&I!=="reset"||u.removeAttribute("value"),c!=null?Hw(u,I,Er(c)):p!=null?Hw(u,I,Er(p)):g!=null&&u.removeAttribute("value"),S==null&&T!=null&&(u.defaultChecked=!!T),S!=null&&(u.checked=S&&typeof S!="function"&&typeof S!="symbol"),z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?u.name=""+Er(z):u.removeAttribute("name")}function I$(u,c,p,g,S,T,I,z){if(T!=null&&typeof T!="function"&&typeof T!="symbol"&&typeof T!="boolean"&&(u.type=T),c!=null||p!=null){if(!(T!=="submit"&&T!=="reset"||c!=null)){Ww(u);return}p=p!=null?""+Er(p):"",c=c!=null?""+Er(c):p,z||c===u.value||(u.value=c),u.defaultValue=c}g=g??S,g=typeof g!="function"&&typeof g!="symbol"&&!!g,u.checked=z?u.checked:!!g,u.defaultChecked=!!g,I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(u.name=I),Ww(u)}function Hw(u,c,p){c==="number"&&mg(u.ownerDocument)===u||u.defaultValue===""+p||(u.defaultValue=""+p)}function Au(u,c,p,g){if(u=u.options,c){c={};for(var S=0;S<p.length;S++)c["$"+p[S]]=!0;for(p=0;p<u.length;p++)S=c.hasOwnProperty("$"+u[p].value),u[p].selected!==S&&(u[p].selected=S),S&&g&&(u[p].defaultSelected=!0)}else{for(p=""+Er(p),c=null,S=0;S<u.length;S++){if(u[S].value===p){u[S].selected=!0,g&&(u[S].defaultSelected=!0);return}c!==null||u[S].disabled||(c=u[S])}c!==null&&(c.selected=!0)}}function _$(u,c,p){if(c!=null&&(c=""+Er(c),c!==u.value&&(u.value=c),p==null)){u.defaultValue!==c&&(u.defaultValue=c);return}u.defaultValue=p!=null?""+Er(p):""}function A$(u,c,p,g){if(c==null){if(g!=null){if(p!=null)throw Error(s(92));if(Q(g)){if(1<g.length)throw Error(s(93));g=g[0]}p=g}p==null&&(p=""),c=p}p=Er(c),u.defaultValue=p,g=u.textContent,g===p&&g!==""&&g!==null&&(u.value=g),Ww(u)}function Ru(u,c){if(c){var p=u.firstChild;if(p&&p===u.lastChild&&p.nodeType===3){p.nodeValue=c;return}}u.textContent=c}var Cj=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function R$(u,c,p){var g=c.indexOf("--")===0;p==null||typeof p=="boolean"||p===""?g?u.setProperty(c,""):c==="float"?u.cssFloat="":u[c]="":g?u.setProperty(c,p):typeof p!="number"||p===0||Cj.has(c)?c==="float"?u.cssFloat=p:u[c]=(""+p).trim():u[c]=p+"px"}function D$(u,c,p){if(c!=null&&typeof c!="object")throw Error(s(62));if(u=u.style,p!=null){for(var g in p)!p.hasOwnProperty(g)||c!=null&&c.hasOwnProperty(g)||(g.indexOf("--")===0?u.setProperty(g,""):g==="float"?u.cssFloat="":u[g]="");for(var S in c)g=c[S],c.hasOwnProperty(S)&&p[S]!==g&&R$(u,S,g)}else for(var T in c)c.hasOwnProperty(T)&&R$(u,T,c[T])}function qw(u){if(u.indexOf("-")===-1)return!1;switch(u){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Nj=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),kj=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function gg(u){return kj.test(""+u)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":u}function Qa(){}var Kw=null;function Xw(u){return u=u.target||u.srcElement||window,u.correspondingUseElement&&(u=u.correspondingUseElement),u.nodeType===3?u.parentNode:u}var Du=null,Ou=null;function O$(u){var c=$u(u);if(c&&(u=c.stateNode)){var p=u[Ls]||null;e:switch(u=c.stateNode,c.type){case"input":if(Gw(u,p.value,p.defaultValue,p.defaultValue,p.checked,p.defaultChecked,p.type,p.name),c=p.name,p.type==="radio"&&c!=null){for(p=u;p.parentNode;)p=p.parentNode;for(p=p.querySelectorAll('input[name="'+$r(""+c)+'"][type="radio"]'),c=0;c<p.length;c++){var g=p[c];if(g!==u&&g.form===u.form){var S=g[Ls]||null;if(!S)throw Error(s(90));Gw(g,S.value,S.defaultValue,S.defaultValue,S.checked,S.defaultChecked,S.type,S.name)}}for(c=0;c<p.length;c++)g=p[c],g.form===u.form&&$$(g)}break e;case"textarea":_$(u,p.value,p.defaultValue);break e;case"select":c=p.value,c!=null&&Au(u,!!p.multiple,c,!1)}}}var Yw=!1;function F$(u,c,p){if(Yw)return u(c,p);Yw=!0;try{var g=u(c);return g}finally{if(Yw=!1,(Du!==null||Ou!==null)&&(sy(),Du&&(c=Du,u=Ou,Ou=Du=null,O$(c),u)))for(c=0;c<u.length;c++)O$(u[c])}}function Td(u,c){var p=u.stateNode;if(p===null)return null;var g=p[Ls]||null;if(g===null)return null;p=g[c];e:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(g=!g.disabled)||(u=u.type,g=!(u==="button"||u==="input"||u==="select"||u==="textarea")),u=!g;break e;default:u=!1}if(u)return null;if(p&&typeof p!="function")throw Error(s(231,c,typeof p));return p}var ei=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Jw=!1;if(ei)try{var Cd={};Object.defineProperty(Cd,"passive",{get:function(){Jw=!0}}),window.addEventListener("test",Cd,Cd),window.removeEventListener("test",Cd,Cd)}catch{Jw=!1}var ji=null,Zw=null,yg=null;function L$(){if(yg)return yg;var u,c=Zw,p=c.length,g,S="value"in ji?ji.value:ji.textContent,T=S.length;for(u=0;u<p&&c[u]===S[u];u++);var I=p-u;for(g=1;g<=I&&c[p-g]===S[T-g];g++);return yg=S.slice(u,1<g?1-g:void 0)}function bg(u){var c=u.keyCode;return"charCode"in u?(u=u.charCode,u===0&&c===13&&(u=13)):u=c,u===10&&(u=13),32<=u||u===13?u:0}function xg(){return!0}function M$(){return!1}function Ms(u){function c(p,g,S,T,I){this._reactName=p,this._targetInst=S,this.type=g,this.nativeEvent=T,this.target=I,this.currentTarget=null;for(var z in u)u.hasOwnProperty(z)&&(p=u[z],this[z]=p?p(T):T[z]);return this.isDefaultPrevented=(T.defaultPrevented!=null?T.defaultPrevented:T.returnValue===!1)?xg:M$,this.isPropagationStopped=M$,this}return f(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var p=this.nativeEvent;p&&(p.preventDefault?p.preventDefault():typeof p.returnValue!="unknown"&&(p.returnValue=!1),this.isDefaultPrevented=xg)},stopPropagation:function(){var p=this.nativeEvent;p&&(p.stopPropagation?p.stopPropagation():typeof p.cancelBubble!="unknown"&&(p.cancelBubble=!0),this.isPropagationStopped=xg)},persist:function(){},isPersistent:xg}),c}var el={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(u){return u.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},wg=Ms(el),Nd=f({},el,{view:0,detail:0}),Ej=Ms(Nd),Qw,ev,kd,vg=f({},Nd,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:nv,button:0,buttons:0,relatedTarget:function(u){return u.relatedTarget===void 0?u.fromElement===u.srcElement?u.toElement:u.fromElement:u.relatedTarget},movementX:function(u){return"movementX"in u?u.movementX:(u!==kd&&(kd&&u.type==="mousemove"?(Qw=u.screenX-kd.screenX,ev=u.screenY-kd.screenY):ev=Qw=0,kd=u),Qw)},movementY:function(u){return"movementY"in u?u.movementY:ev}}),z$=Ms(vg),$j=f({},vg,{dataTransfer:0}),Ij=Ms($j),_j=f({},Nd,{relatedTarget:0}),tv=Ms(_j),Aj=f({},el,{animationName:0,elapsedTime:0,pseudoElement:0}),Rj=Ms(Aj),Dj=f({},el,{clipboardData:function(u){return"clipboardData"in u?u.clipboardData:window.clipboardData}}),Oj=Ms(Dj),Fj=f({},el,{data:0}),P$=Ms(Fj),Lj={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Mj={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},zj={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pj(u){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(u):(u=zj[u])?!!c[u]:!1}function nv(){return Pj}var Bj=f({},Nd,{key:function(u){if(u.key){var c=Lj[u.key]||u.key;if(c!=="Unidentified")return c}return u.type==="keypress"?(u=bg(u),u===13?"Enter":String.fromCharCode(u)):u.type==="keydown"||u.type==="keyup"?Mj[u.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:nv,charCode:function(u){return u.type==="keypress"?bg(u):0},keyCode:function(u){return u.type==="keydown"||u.type==="keyup"?u.keyCode:0},which:function(u){return u.type==="keypress"?bg(u):u.type==="keydown"||u.type==="keyup"?u.keyCode:0}}),Vj=Ms(Bj),Uj=f({},vg,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),B$=Ms(Uj),jj=f({},Nd,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:nv}),Wj=Ms(jj),Gj=f({},el,{propertyName:0,elapsedTime:0,pseudoElement:0}),Hj=Ms(Gj),qj=f({},vg,{deltaX:function(u){return"deltaX"in u?u.deltaX:"wheelDeltaX"in u?-u.wheelDeltaX:0},deltaY:function(u){return"deltaY"in u?u.deltaY:"wheelDeltaY"in u?-u.wheelDeltaY:"wheelDelta"in u?-u.wheelDelta:0},deltaZ:0,deltaMode:0}),Kj=Ms(qj),Xj=f({},el,{newState:0,oldState:0}),Yj=Ms(Xj),Jj=[9,13,27,32],sv=ei&&"CompositionEvent"in window,Ed=null;ei&&"documentMode"in document&&(Ed=document.documentMode);var Zj=ei&&"TextEvent"in window&&!Ed,V$=ei&&(!sv||Ed&&8<Ed&&11>=Ed),U$=" ",j$=!1;function W$(u,c){switch(u){case"keyup":return Jj.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function G$(u){return u=u.detail,typeof u=="object"&&"data"in u?u.data:null}var Fu=!1;function Qj(u,c){switch(u){case"compositionend":return G$(c);case"keypress":return c.which!==32?null:(j$=!0,U$);case"textInput":return u=c.data,u===U$&&j$?null:u;default:return null}}function eW(u,c){if(Fu)return u==="compositionend"||!sv&&W$(u,c)?(u=L$(),yg=Zw=ji=null,Fu=!1,u):null;switch(u){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return V$&&c.locale!=="ko"?null:c.data;default:return null}}var tW={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function H$(u){var c=u&&u.nodeName&&u.nodeName.toLowerCase();return c==="input"?!!tW[u.type]:c==="textarea"}function q$(u,c,p,g){Du?Ou?Ou.push(g):Ou=[g]:Du=g,c=cy(c,"onChange"),0<c.length&&(p=new wg("onChange","change",null,p,g),u.push({event:p,listeners:c}))}var $d=null,Id=null;function nW(u){IA(u,0)}function Sg(u){var c=Sd(u);if($$(c))return u}function K$(u,c){if(u==="change")return c}var X$=!1;if(ei){var rv;if(ei){var av="oninput"in document;if(!av){var Y$=document.createElement("div");Y$.setAttribute("oninput","return;"),av=typeof Y$.oninput=="function"}rv=av}else rv=!1;X$=rv&&(!document.documentMode||9<document.documentMode)}function J$(){$d&&($d.detachEvent("onpropertychange",Z$),Id=$d=null)}function Z$(u){if(u.propertyName==="value"&&Sg(Id)){var c=[];q$(c,Id,u,Xw(u)),F$(nW,c)}}function sW(u,c,p){u==="focusin"?(J$(),$d=c,Id=p,$d.attachEvent("onpropertychange",Z$)):u==="focusout"&&J$()}function rW(u){if(u==="selectionchange"||u==="keyup"||u==="keydown")return Sg(Id)}function aW(u,c){if(u==="click")return Sg(c)}function iW(u,c){if(u==="input"||u==="change")return Sg(c)}function oW(u,c){return u===c&&(u!==0||1/u===1/c)||u!==u&&c!==c}var ar=typeof Object.is=="function"?Object.is:oW;function _d(u,c){if(ar(u,c))return!0;if(typeof u!="object"||u===null||typeof c!="object"||c===null)return!1;var p=Object.keys(u),g=Object.keys(c);if(p.length!==g.length)return!1;for(g=0;g<p.length;g++){var S=p[g];if(!nr.call(c,S)||!ar(u[S],c[S]))return!1}return!0}function Q$(u){for(;u&&u.firstChild;)u=u.firstChild;return u}function eI(u,c){var p=Q$(u);u=0;for(var g;p;){if(p.nodeType===3){if(g=u+p.textContent.length,u<=c&&g>=c)return{node:p,offset:c-u};u=g}e:{for(;p;){if(p.nextSibling){p=p.nextSibling;break e}p=p.parentNode}p=void 0}p=Q$(p)}}function tI(u,c){return u&&c?u===c?!0:u&&u.nodeType===3?!1:c&&c.nodeType===3?tI(u,c.parentNode):"contains"in u?u.contains(c):u.compareDocumentPosition?!!(u.compareDocumentPosition(c)&16):!1:!1}function nI(u){u=u!=null&&u.ownerDocument!=null&&u.ownerDocument.defaultView!=null?u.ownerDocument.defaultView:window;for(var c=mg(u.document);c instanceof u.HTMLIFrameElement;){try{var p=typeof c.contentWindow.location.href=="string"}catch{p=!1}if(p)u=c.contentWindow;else break;c=mg(u.document)}return c}function iv(u){var c=u&&u.nodeName&&u.nodeName.toLowerCase();return c&&(c==="input"&&(u.type==="text"||u.type==="search"||u.type==="tel"||u.type==="url"||u.type==="password")||c==="textarea"||u.contentEditable==="true")}var lW=ei&&"documentMode"in document&&11>=document.documentMode,Lu=null,ov=null,Ad=null,lv=!1;function sI(u,c,p){var g=p.window===p?p.document:p.nodeType===9?p:p.ownerDocument;lv||Lu==null||Lu!==mg(g)||(g=Lu,"selectionStart"in g&&iv(g)?g={start:g.selectionStart,end:g.selectionEnd}:(g=(g.ownerDocument&&g.ownerDocument.defaultView||window).getSelection(),g={anchorNode:g.anchorNode,anchorOffset:g.anchorOffset,focusNode:g.focusNode,focusOffset:g.focusOffset}),Ad&&_d(Ad,g)||(Ad=g,g=cy(ov,"onSelect"),0<g.length&&(c=new wg("onSelect","select",null,c,p),u.push({event:c,listeners:g}),c.target=Lu)))}function tl(u,c){var p={};return p[u.toLowerCase()]=c.toLowerCase(),p["Webkit"+u]="webkit"+c,p["Moz"+u]="moz"+c,p}var Mu={animationend:tl("Animation","AnimationEnd"),animationiteration:tl("Animation","AnimationIteration"),animationstart:tl("Animation","AnimationStart"),transitionrun:tl("Transition","TransitionRun"),transitionstart:tl("Transition","TransitionStart"),transitioncancel:tl("Transition","TransitionCancel"),transitionend:tl("Transition","TransitionEnd")},uv={},rI={};ei&&(rI=document.createElement("div").style,"AnimationEvent"in window||(delete Mu.animationend.animation,delete Mu.animationiteration.animation,delete Mu.animationstart.animation),"TransitionEvent"in window||delete Mu.transitionend.transition);function nl(u){if(uv[u])return uv[u];if(!Mu[u])return u;var c=Mu[u],p;for(p in c)if(c.hasOwnProperty(p)&&p in rI)return uv[u]=c[p];return u}var aI=nl("animationend"),iI=nl("animationiteration"),oI=nl("animationstart"),uW=nl("transitionrun"),cW=nl("transitionstart"),hW=nl("transitioncancel"),lI=nl("transitionend"),uI=new Map,cv="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");cv.push("scrollEnd");function ea(u,c){uI.set(u,c),Qo(c,[u])}var Tg=typeof reportError=="function"?reportError:function(u){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var c=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof u=="object"&&u!==null&&typeof u.message=="string"?String(u.message):String(u),error:u});if(!window.dispatchEvent(c))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",u);return}console.error(u)},Ir=[],zu=0,hv=0;function Cg(){for(var u=zu,c=hv=zu=0;c<u;){var p=Ir[c];Ir[c++]=null;var g=Ir[c];Ir[c++]=null;var S=Ir[c];Ir[c++]=null;var T=Ir[c];if(Ir[c++]=null,g!==null&&S!==null){var I=g.pending;I===null?S.next=S:(S.next=I.next,I.next=S),g.pending=S}T!==0&&cI(p,S,T)}}function Ng(u,c,p,g){Ir[zu++]=u,Ir[zu++]=c,Ir[zu++]=p,Ir[zu++]=g,hv|=g,u.lanes|=g,u=u.alternate,u!==null&&(u.lanes|=g)}function dv(u,c,p,g){return Ng(u,c,p,g),kg(u)}function sl(u,c){return Ng(u,null,null,c),kg(u)}function cI(u,c,p){u.lanes|=p;var g=u.alternate;g!==null&&(g.lanes|=p);for(var S=!1,T=u.return;T!==null;)T.childLanes|=p,g=T.alternate,g!==null&&(g.childLanes|=p),T.tag===22&&(u=T.stateNode,u===null||u._visibility&1||(S=!0)),u=T,T=T.return;return u.tag===3?(T=u.stateNode,S&&c!==null&&(S=31-rr(p),u=T.hiddenUpdates,g=u[S],g===null?u[S]=[c]:g.push(c),c.lane=p|536870912),T):null}function kg(u){if(50<Qd)throw Qd=0,v1=null,Error(s(185));for(var c=u.return;c!==null;)u=c,c=u.return;return u.tag===3?u.stateNode:null}var Pu={};function dW(u,c,p,g){this.tag=u,this.key=p,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=g,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ir(u,c,p,g){return new dW(u,c,p,g)}function fv(u){return u=u.prototype,!(!u||!u.isReactComponent)}function ti(u,c){var p=u.alternate;return p===null?(p=ir(u.tag,c,u.key,u.mode),p.elementType=u.elementType,p.type=u.type,p.stateNode=u.stateNode,p.alternate=u,u.alternate=p):(p.pendingProps=c,p.type=u.type,p.flags=0,p.subtreeFlags=0,p.deletions=null),p.flags=u.flags&65011712,p.childLanes=u.childLanes,p.lanes=u.lanes,p.child=u.child,p.memoizedProps=u.memoizedProps,p.memoizedState=u.memoizedState,p.updateQueue=u.updateQueue,c=u.dependencies,p.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},p.sibling=u.sibling,p.index=u.index,p.ref=u.ref,p.refCleanup=u.refCleanup,p}function hI(u,c){u.flags&=65011714;var p=u.alternate;return p===null?(u.childLanes=0,u.lanes=c,u.child=null,u.subtreeFlags=0,u.memoizedProps=null,u.memoizedState=null,u.updateQueue=null,u.dependencies=null,u.stateNode=null):(u.childLanes=p.childLanes,u.lanes=p.lanes,u.child=p.child,u.subtreeFlags=0,u.deletions=null,u.memoizedProps=p.memoizedProps,u.memoizedState=p.memoizedState,u.updateQueue=p.updateQueue,u.type=p.type,c=p.dependencies,u.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext}),u}function Eg(u,c,p,g,S,T){var I=0;if(g=u,typeof u=="function")fv(u)&&(I=1);else if(typeof u=="string")I=yG(u,p,oe.current)?26:u==="html"||u==="head"||u==="body"?27:5;else e:switch(u){case F:return u=ir(31,p,c,S),u.elementType=F,u.lanes=T,u;case x:return rl(p.children,S,T,c);case w:I=8,S|=24;break;case v:return u=ir(12,p,c,S|2),u.elementType=v,u.lanes=T,u;case E:return u=ir(13,p,c,S),u.elementType=E,u.lanes=T,u;case _:return u=ir(19,p,c,S),u.elementType=_,u.lanes=T,u;default:if(typeof u=="object"&&u!==null)switch(u.$$typeof){case N:I=10;break e;case C:I=9;break e;case k:I=11;break e;case R:I=14;break e;case D:I=16,g=null;break e}I=29,p=Error(s(130,u===null?"null":typeof u,"")),g=null}return c=ir(I,p,c,S),c.elementType=u,c.type=g,c.lanes=T,c}function rl(u,c,p,g){return u=ir(7,u,g,c),u.lanes=p,u}function pv(u,c,p){return u=ir(6,u,null,c),u.lanes=p,u}function dI(u){var c=ir(18,null,null,0);return c.stateNode=u,c}function mv(u,c,p){return c=ir(4,u.children!==null?u.children:[],u.key,c),c.lanes=p,c.stateNode={containerInfo:u.containerInfo,pendingChildren:null,implementation:u.implementation},c}var fI=new WeakMap;function _r(u,c){if(typeof u=="object"&&u!==null){var p=fI.get(u);return p!==void 0?p:(c={value:u,source:c,stack:_t(c)},fI.set(u,c),c)}return{value:u,source:c,stack:_t(c)}}var Bu=[],Vu=0,$g=null,Rd=0,Ar=[],Rr=0,Wi=null,$a=1,Ia="";function ni(u,c){Bu[Vu++]=Rd,Bu[Vu++]=$g,$g=u,Rd=c}function pI(u,c,p){Ar[Rr++]=$a,Ar[Rr++]=Ia,Ar[Rr++]=Wi,Wi=u;var g=$a;u=Ia;var S=32-rr(g)-1;g&=~(1<<S),p+=1;var T=32-rr(c)+S;if(30<T){var I=S-S%5;T=(g&(1<<I)-1).toString(32),g>>=I,S-=I,$a=1<<32-rr(c)+S|p<<S|g,Ia=T+u}else $a=1<<T|p<<S|g,Ia=u}function gv(u){u.return!==null&&(ni(u,1),pI(u,1,0))}function yv(u){for(;u===$g;)$g=Bu[--Vu],Bu[Vu]=null,Rd=Bu[--Vu],Bu[Vu]=null;for(;u===Wi;)Wi=Ar[--Rr],Ar[Rr]=null,Ia=Ar[--Rr],Ar[Rr]=null,$a=Ar[--Rr],Ar[Rr]=null}function mI(u,c){Ar[Rr++]=$a,Ar[Rr++]=Ia,Ar[Rr++]=Wi,$a=c.id,Ia=c.overflow,Wi=u}var ss=null,Ut=null,yt=!1,Gi=null,Dr=!1,bv=Error(s(519));function Hi(u){var c=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Dd(_r(c,u)),bv}function gI(u){var c=u.stateNode,p=u.type,g=u.memoizedProps;switch(c[ns]=u,c[Ls]=g,p){case"dialog":ht("cancel",c),ht("close",c);break;case"iframe":case"object":case"embed":ht("load",c);break;case"video":case"audio":for(p=0;p<tf.length;p++)ht(tf[p],c);break;case"source":ht("error",c);break;case"img":case"image":case"link":ht("error",c),ht("load",c);break;case"details":ht("toggle",c);break;case"input":ht("invalid",c),I$(c,g.value,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name,!0);break;case"select":ht("invalid",c);break;case"textarea":ht("invalid",c),A$(c,g.value,g.defaultValue,g.children)}p=g.children,typeof p!="string"&&typeof p!="number"&&typeof p!="bigint"||c.textContent===""+p||g.suppressHydrationWarning===!0||DA(c.textContent,p)?(g.popover!=null&&(ht("beforetoggle",c),ht("toggle",c)),g.onScroll!=null&&ht("scroll",c),g.onScrollEnd!=null&&ht("scrollend",c),g.onClick!=null&&(c.onclick=Qa),c=!0):c=!1,c||Hi(u,!0)}function yI(u){for(ss=u.return;ss;)switch(ss.tag){case 5:case 31:case 13:Dr=!1;return;case 27:case 3:Dr=!0;return;default:ss=ss.return}}function Uu(u){if(u!==ss)return!1;if(!yt)return yI(u),yt=!0,!1;var c=u.tag,p;if((p=c!==3&&c!==27)&&((p=c===5)&&(p=u.type,p=!(p!=="form"&&p!=="button")||L1(u.type,u.memoizedProps)),p=!p),p&&Ut&&Hi(u),yI(u),c===13){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Ut=UA(u)}else if(c===31){if(u=u.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(317));Ut=UA(u)}else c===27?(c=Ut,io(u.type)?(u=V1,V1=null,Ut=u):Ut=c):Ut=ss?Fr(u.stateNode.nextSibling):null;return!0}function al(){Ut=ss=null,yt=!1}function xv(){var u=Gi;return u!==null&&(Vs===null?Vs=u:Vs.push.apply(Vs,u),Gi=null),u}function Dd(u){Gi===null?Gi=[u]:Gi.push(u)}var wv=P(null),il=null,si=null;function qi(u,c,p){te(wv,c._currentValue),c._currentValue=p}function ri(u){u._currentValue=wv.current,j(wv)}function vv(u,c,p){for(;u!==null;){var g=u.alternate;if((u.childLanes&c)!==c?(u.childLanes|=c,g!==null&&(g.childLanes|=c)):g!==null&&(g.childLanes&c)!==c&&(g.childLanes|=c),u===p)break;u=u.return}}function Sv(u,c,p,g){var S=u.child;for(S!==null&&(S.return=u);S!==null;){var T=S.dependencies;if(T!==null){var I=S.child;T=T.firstContext;e:for(;T!==null;){var z=T;T=S;for(var H=0;H<c.length;H++)if(z.context===c[H]){T.lanes|=p,z=T.alternate,z!==null&&(z.lanes|=p),vv(T.return,p,u),g||(I=null);break e}T=z.next}}else if(S.tag===18){if(I=S.return,I===null)throw Error(s(341));I.lanes|=p,T=I.alternate,T!==null&&(T.lanes|=p),vv(I,p,u),I=null}else I=S.child;if(I!==null)I.return=S;else for(I=S;I!==null;){if(I===u){I=null;break}if(S=I.sibling,S!==null){S.return=I.return,I=S;break}I=I.return}S=I}}function ju(u,c,p,g){u=null;for(var S=c,T=!1;S!==null;){if(!T){if((S.flags&524288)!==0)T=!0;else if((S.flags&262144)!==0)break}if(S.tag===10){var I=S.alternate;if(I===null)throw Error(s(387));if(I=I.memoizedProps,I!==null){var z=S.type;ar(S.pendingProps.value,I.value)||(u!==null?u.push(z):u=[z])}}else if(S===Te.current){if(I=S.alternate,I===null)throw Error(s(387));I.memoizedState.memoizedState!==S.memoizedState.memoizedState&&(u!==null?u.push(of):u=[of])}S=S.return}u!==null&&Sv(c,u,p,g),c.flags|=262144}function Ig(u){for(u=u.firstContext;u!==null;){if(!ar(u.context._currentValue,u.memoizedValue))return!0;u=u.next}return!1}function ol(u){il=u,si=null,u=u.dependencies,u!==null&&(u.firstContext=null)}function rs(u){return bI(il,u)}function _g(u,c){return il===null&&ol(u),bI(u,c)}function bI(u,c){var p=c._currentValue;if(c={context:c,memoizedValue:p,next:null},si===null){if(u===null)throw Error(s(308));si=c,u.dependencies={lanes:0,firstContext:c},u.flags|=524288}else si=si.next=c;return p}var fW=typeof AbortController<"u"?AbortController:function(){var u=[],c=this.signal={aborted:!1,addEventListener:function(p,g){u.push(g)}};this.abort=function(){c.aborted=!0,u.forEach(function(p){return p()})}},pW=n.unstable_scheduleCallback,mW=n.unstable_NormalPriority,wn={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Tv(){return{controller:new fW,data:new Map,refCount:0}}function Od(u){u.refCount--,u.refCount===0&&pW(mW,function(){u.controller.abort()})}var Fd=null,Cv=0,Wu=0,Gu=null;function gW(u,c){if(Fd===null){var p=Fd=[];Cv=0,Wu=E1(),Gu={status:"pending",value:void 0,then:function(g){p.push(g)}}}return Cv++,c.then(xI,xI),c}function xI(){if(--Cv===0&&Fd!==null){Gu!==null&&(Gu.status="fulfilled");var u=Fd;Fd=null,Wu=0,Gu=null;for(var c=0;c<u.length;c++)(0,u[c])()}}function yW(u,c){var p=[],g={status:"pending",value:null,reason:null,then:function(S){p.push(S)}};return u.then(function(){g.status="fulfilled",g.value=c;for(var S=0;S<p.length;S++)(0,p[S])(c)},function(S){for(g.status="rejected",g.reason=S,S=0;S<p.length;S++)(0,p[S])(void 0)}),g}var wI=B.S;B.S=function(u,c){sA=Vt(),typeof c=="object"&&c!==null&&typeof c.then=="function"&&gW(u,c),wI!==null&&wI(u,c)};var ll=P(null);function Nv(){var u=ll.current;return u!==null?u:Ft.pooledCache}function Ag(u,c){c===null?te(ll,ll.current):te(ll,c.pool)}function vI(){var u=Nv();return u===null?null:{parent:wn._currentValue,pool:u}}var Hu=Error(s(460)),kv=Error(s(474)),Rg=Error(s(542)),Dg={then:function(){}};function SI(u){return u=u.status,u==="fulfilled"||u==="rejected"}function TI(u,c,p){switch(p=u[p],p===void 0?u.push(c):p!==c&&(c.then(Qa,Qa),c=p),c.status){case"fulfilled":return c.value;case"rejected":throw u=c.reason,NI(u),u;default:if(typeof c.status=="string")c.then(Qa,Qa);else{if(u=Ft,u!==null&&100<u.shellSuspendCounter)throw Error(s(482));u=c,u.status="pending",u.then(function(g){if(c.status==="pending"){var S=c;S.status="fulfilled",S.value=g}},function(g){if(c.status==="pending"){var S=c;S.status="rejected",S.reason=g}})}switch(c.status){case"fulfilled":return c.value;case"rejected":throw u=c.reason,NI(u),u}throw cl=c,Hu}}function ul(u){try{var c=u._init;return c(u._payload)}catch(p){throw p!==null&&typeof p=="object"&&typeof p.then=="function"?(cl=p,Hu):p}}var cl=null;function CI(){if(cl===null)throw Error(s(459));var u=cl;return cl=null,u}function NI(u){if(u===Hu||u===Rg)throw Error(s(483))}var qu=null,Ld=0;function Og(u){var c=Ld;return Ld+=1,qu===null&&(qu=[]),TI(qu,u,c)}function Md(u,c){c=c.props.ref,u.ref=c!==void 0?c:null}function Fg(u,c){throw c.$$typeof===m?Error(s(525)):(u=Object.prototype.toString.call(c),Error(s(31,u==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":u)))}function kI(u){function c(ae,ee){if(u){var le=ae.deletions;le===null?(ae.deletions=[ee],ae.flags|=16):le.push(ee)}}function p(ae,ee){if(!u)return null;for(;ee!==null;)c(ae,ee),ee=ee.sibling;return null}function g(ae){for(var ee=new Map;ae!==null;)ae.key!==null?ee.set(ae.key,ae):ee.set(ae.index,ae),ae=ae.sibling;return ee}function S(ae,ee){return ae=ti(ae,ee),ae.index=0,ae.sibling=null,ae}function T(ae,ee,le){return ae.index=le,u?(le=ae.alternate,le!==null?(le=le.index,le<ee?(ae.flags|=67108866,ee):le):(ae.flags|=67108866,ee)):(ae.flags|=1048576,ee)}function I(ae){return u&&ae.alternate===null&&(ae.flags|=67108866),ae}function z(ae,ee,le,ye){return ee===null||ee.tag!==6?(ee=pv(le,ae.mode,ye),ee.return=ae,ee):(ee=S(ee,le),ee.return=ae,ee)}function H(ae,ee,le,ye){var Ve=le.type;return Ve===x?ge(ae,ee,le.props.children,ye,le.key):ee!==null&&(ee.elementType===Ve||typeof Ve=="object"&&Ve!==null&&Ve.$$typeof===D&&ul(Ve)===ee.type)?(ee=S(ee,le.props),Md(ee,le),ee.return=ae,ee):(ee=Eg(le.type,le.key,le.props,null,ae.mode,ye),Md(ee,le),ee.return=ae,ee)}function ue(ae,ee,le,ye){return ee===null||ee.tag!==4||ee.stateNode.containerInfo!==le.containerInfo||ee.stateNode.implementation!==le.implementation?(ee=mv(le,ae.mode,ye),ee.return=ae,ee):(ee=S(ee,le.children||[]),ee.return=ae,ee)}function ge(ae,ee,le,ye,Ve){return ee===null||ee.tag!==7?(ee=rl(le,ae.mode,ye,Ve),ee.return=ae,ee):(ee=S(ee,le),ee.return=ae,ee)}function be(ae,ee,le){if(typeof ee=="string"&&ee!==""||typeof ee=="number"||typeof ee=="bigint")return ee=pv(""+ee,ae.mode,le),ee.return=ae,ee;if(typeof ee=="object"&&ee!==null){switch(ee.$$typeof){case y:return le=Eg(ee.type,ee.key,ee.props,null,ae.mode,le),Md(le,ee),le.return=ae,le;case b:return ee=mv(ee,ae.mode,le),ee.return=ae,ee;case D:return ee=ul(ee),be(ae,ee,le)}if(Q(ee)||V(ee))return ee=rl(ee,ae.mode,le,null),ee.return=ae,ee;if(typeof ee.then=="function")return be(ae,Og(ee),le);if(ee.$$typeof===N)return be(ae,_g(ae,ee),le);Fg(ae,ee)}return null}function ce(ae,ee,le,ye){var Ve=ee!==null?ee.key:null;if(typeof le=="string"&&le!==""||typeof le=="number"||typeof le=="bigint")return Ve!==null?null:z(ae,ee,""+le,ye);if(typeof le=="object"&&le!==null){switch(le.$$typeof){case y:return le.key===Ve?H(ae,ee,le,ye):null;case b:return le.key===Ve?ue(ae,ee,le,ye):null;case D:return le=ul(le),ce(ae,ee,le,ye)}if(Q(le)||V(le))return Ve!==null?null:ge(ae,ee,le,ye,null);if(typeof le.then=="function")return ce(ae,ee,Og(le),ye);if(le.$$typeof===N)return ce(ae,ee,_g(ae,le),ye);Fg(ae,le)}return null}function de(ae,ee,le,ye,Ve){if(typeof ye=="string"&&ye!==""||typeof ye=="number"||typeof ye=="bigint")return ae=ae.get(le)||null,z(ee,ae,""+ye,Ve);if(typeof ye=="object"&&ye!==null){switch(ye.$$typeof){case y:return ae=ae.get(ye.key===null?le:ye.key)||null,H(ee,ae,ye,Ve);case b:return ae=ae.get(ye.key===null?le:ye.key)||null,ue(ee,ae,ye,Ve);case D:return ye=ul(ye),de(ae,ee,le,ye,Ve)}if(Q(ye)||V(ye))return ae=ae.get(le)||null,ge(ee,ae,ye,Ve,null);if(typeof ye.then=="function")return de(ae,ee,le,Og(ye),Ve);if(ye.$$typeof===N)return de(ae,ee,le,_g(ee,ye),Ve);Fg(ee,ye)}return null}function De(ae,ee,le,ye){for(var Ve=null,vt=null,Me=ee,st=ee=0,mt=null;Me!==null&&st<le.length;st++){Me.index>st?(mt=Me,Me=null):mt=Me.sibling;var St=ce(ae,Me,le[st],ye);if(St===null){Me===null&&(Me=mt);break}u&&Me&&St.alternate===null&&c(ae,Me),ee=T(St,ee,st),vt===null?Ve=St:vt.sibling=St,vt=St,Me=mt}if(st===le.length)return p(ae,Me),yt&&ni(ae,st),Ve;if(Me===null){for(;st<le.length;st++)Me=be(ae,le[st],ye),Me!==null&&(ee=T(Me,ee,st),vt===null?Ve=Me:vt.sibling=Me,vt=Me);return yt&&ni(ae,st),Ve}for(Me=g(Me);st<le.length;st++)mt=de(Me,ae,st,le[st],ye),mt!==null&&(u&&mt.alternate!==null&&Me.delete(mt.key===null?st:mt.key),ee=T(mt,ee,st),vt===null?Ve=mt:vt.sibling=mt,vt=mt);return u&&Me.forEach(function(ho){return c(ae,ho)}),yt&&ni(ae,st),Ve}function We(ae,ee,le,ye){if(le==null)throw Error(s(151));for(var Ve=null,vt=null,Me=ee,st=ee=0,mt=null,St=le.next();Me!==null&&!St.done;st++,St=le.next()){Me.index>st?(mt=Me,Me=null):mt=Me.sibling;var ho=ce(ae,Me,St.value,ye);if(ho===null){Me===null&&(Me=mt);break}u&&Me&&ho.alternate===null&&c(ae,Me),ee=T(ho,ee,st),vt===null?Ve=ho:vt.sibling=ho,vt=ho,Me=mt}if(St.done)return p(ae,Me),yt&&ni(ae,st),Ve;if(Me===null){for(;!St.done;st++,St=le.next())St=be(ae,St.value,ye),St!==null&&(ee=T(St,ee,st),vt===null?Ve=St:vt.sibling=St,vt=St);return yt&&ni(ae,st),Ve}for(Me=g(Me);!St.done;st++,St=le.next())St=de(Me,ae,st,St.value,ye),St!==null&&(u&&St.alternate!==null&&Me.delete(St.key===null?st:St.key),ee=T(St,ee,st),vt===null?Ve=St:vt.sibling=St,vt=St);return u&&Me.forEach(function($G){return c(ae,$G)}),yt&&ni(ae,st),Ve}function Dt(ae,ee,le,ye){if(typeof le=="object"&&le!==null&&le.type===x&&le.key===null&&(le=le.props.children),typeof le=="object"&&le!==null){switch(le.$$typeof){case y:e:{for(var Ve=le.key;ee!==null;){if(ee.key===Ve){if(Ve=le.type,Ve===x){if(ee.tag===7){p(ae,ee.sibling),ye=S(ee,le.props.children),ye.return=ae,ae=ye;break e}}else if(ee.elementType===Ve||typeof Ve=="object"&&Ve!==null&&Ve.$$typeof===D&&ul(Ve)===ee.type){p(ae,ee.sibling),ye=S(ee,le.props),Md(ye,le),ye.return=ae,ae=ye;break e}p(ae,ee);break}else c(ae,ee);ee=ee.sibling}le.type===x?(ye=rl(le.props.children,ae.mode,ye,le.key),ye.return=ae,ae=ye):(ye=Eg(le.type,le.key,le.props,null,ae.mode,ye),Md(ye,le),ye.return=ae,ae=ye)}return I(ae);case b:e:{for(Ve=le.key;ee!==null;){if(ee.key===Ve)if(ee.tag===4&&ee.stateNode.containerInfo===le.containerInfo&&ee.stateNode.implementation===le.implementation){p(ae,ee.sibling),ye=S(ee,le.children||[]),ye.return=ae,ae=ye;break e}else{p(ae,ee);break}else c(ae,ee);ee=ee.sibling}ye=mv(le,ae.mode,ye),ye.return=ae,ae=ye}return I(ae);case D:return le=ul(le),Dt(ae,ee,le,ye)}if(Q(le))return De(ae,ee,le,ye);if(V(le)){if(Ve=V(le),typeof Ve!="function")throw Error(s(150));return le=Ve.call(le),We(ae,ee,le,ye)}if(typeof le.then=="function")return Dt(ae,ee,Og(le),ye);if(le.$$typeof===N)return Dt(ae,ee,_g(ae,le),ye);Fg(ae,le)}return typeof le=="string"&&le!==""||typeof le=="number"||typeof le=="bigint"?(le=""+le,ee!==null&&ee.tag===6?(p(ae,ee.sibling),ye=S(ee,le),ye.return=ae,ae=ye):(p(ae,ee),ye=pv(le,ae.mode,ye),ye.return=ae,ae=ye),I(ae)):p(ae,ee)}return function(ae,ee,le,ye){try{Ld=0;var Ve=Dt(ae,ee,le,ye);return qu=null,Ve}catch(Me){if(Me===Hu||Me===Rg)throw Me;var vt=ir(29,Me,null,ae.mode);return vt.lanes=ye,vt.return=ae,vt}}}var hl=kI(!0),EI=kI(!1),Ki=!1;function Ev(u){u.updateQueue={baseState:u.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function $v(u,c){u=u.updateQueue,c.updateQueue===u&&(c.updateQueue={baseState:u.baseState,firstBaseUpdate:u.firstBaseUpdate,lastBaseUpdate:u.lastBaseUpdate,shared:u.shared,callbacks:null})}function Xi(u){return{lane:u,tag:0,payload:null,callback:null,next:null}}function Yi(u,c,p){var g=u.updateQueue;if(g===null)return null;if(g=g.shared,(Tt&2)!==0){var S=g.pending;return S===null?c.next=c:(c.next=S.next,S.next=c),g.pending=c,c=kg(u),cI(u,null,p),c}return Ng(u,g,c,p),kg(u)}function zd(u,c,p){if(c=c.updateQueue,c!==null&&(c=c.shared,(p&4194048)!==0)){var g=c.lanes;g&=u.pendingLanes,p|=g,c.lanes=p,b$(u,p)}}function Iv(u,c){var p=u.updateQueue,g=u.alternate;if(g!==null&&(g=g.updateQueue,p===g)){var S=null,T=null;if(p=p.firstBaseUpdate,p!==null){do{var I={lane:p.lane,tag:p.tag,payload:p.payload,callback:null,next:null};T===null?S=T=I:T=T.next=I,p=p.next}while(p!==null);T===null?S=T=c:T=T.next=c}else S=T=c;p={baseState:g.baseState,firstBaseUpdate:S,lastBaseUpdate:T,shared:g.shared,callbacks:g.callbacks},u.updateQueue=p;return}u=p.lastBaseUpdate,u===null?p.firstBaseUpdate=c:u.next=c,p.lastBaseUpdate=c}var _v=!1;function Pd(){if(_v){var u=Gu;if(u!==null)throw u}}function Bd(u,c,p,g){_v=!1;var S=u.updateQueue;Ki=!1;var T=S.firstBaseUpdate,I=S.lastBaseUpdate,z=S.shared.pending;if(z!==null){S.shared.pending=null;var H=z,ue=H.next;H.next=null,I===null?T=ue:I.next=ue,I=H;var ge=u.alternate;ge!==null&&(ge=ge.updateQueue,z=ge.lastBaseUpdate,z!==I&&(z===null?ge.firstBaseUpdate=ue:z.next=ue,ge.lastBaseUpdate=H))}if(T!==null){var be=S.baseState;I=0,ge=ue=H=null,z=T;do{var ce=z.lane&-536870913,de=ce!==z.lane;if(de?(pt&ce)===ce:(g&ce)===ce){ce!==0&&ce===Wu&&(_v=!0),ge!==null&&(ge=ge.next={lane:0,tag:z.tag,payload:z.payload,callback:null,next:null});e:{var De=u,We=z;ce=c;var Dt=p;switch(We.tag){case 1:if(De=We.payload,typeof De=="function"){be=De.call(Dt,be,ce);break e}be=De;break e;case 3:De.flags=De.flags&-65537|128;case 0:if(De=We.payload,ce=typeof De=="function"?De.call(Dt,be,ce):De,ce==null)break e;be=f({},be,ce);break e;case 2:Ki=!0}}ce=z.callback,ce!==null&&(u.flags|=64,de&&(u.flags|=8192),de=S.callbacks,de===null?S.callbacks=[ce]:de.push(ce))}else de={lane:ce,tag:z.tag,payload:z.payload,callback:z.callback,next:null},ge===null?(ue=ge=de,H=be):ge=ge.next=de,I|=ce;if(z=z.next,z===null){if(z=S.shared.pending,z===null)break;de=z,z=de.next,de.next=null,S.lastBaseUpdate=de,S.shared.pending=null}}while(!0);ge===null&&(H=be),S.baseState=H,S.firstBaseUpdate=ue,S.lastBaseUpdate=ge,T===null&&(S.shared.lanes=0),to|=I,u.lanes=I,u.memoizedState=be}}function $I(u,c){if(typeof u!="function")throw Error(s(191,u));u.call(c)}function II(u,c){var p=u.callbacks;if(p!==null)for(u.callbacks=null,u=0;u<p.length;u++)$I(p[u],c)}var Ku=P(null),Lg=P(0);function _I(u,c){u=fi,te(Lg,u),te(Ku,c),fi=u|c.baseLanes}function Av(){te(Lg,fi),te(Ku,Ku.current)}function Rv(){fi=Lg.current,j(Ku),j(Lg)}var or=P(null),Or=null;function Ji(u){var c=u.alternate;te(fn,fn.current&1),te(or,u),Or===null&&(c===null||Ku.current!==null||c.memoizedState!==null)&&(Or=u)}function Dv(u){te(fn,fn.current),te(or,u),Or===null&&(Or=u)}function AI(u){u.tag===22?(te(fn,fn.current),te(or,u),Or===null&&(Or=u)):Zi()}function Zi(){te(fn,fn.current),te(or,or.current)}function lr(u){j(or),Or===u&&(Or=null),j(fn)}var fn=P(0);function Mg(u){for(var c=u;c!==null;){if(c.tag===13){var p=c.memoizedState;if(p!==null&&(p=p.dehydrated,p===null||P1(p)||B1(p)))return c}else if(c.tag===19&&(c.memoizedProps.revealOrder==="forwards"||c.memoizedProps.revealOrder==="backwards"||c.memoizedProps.revealOrder==="unstable_legacy-backwards"||c.memoizedProps.revealOrder==="together")){if((c.flags&128)!==0)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===u)break;for(;c.sibling===null;){if(c.return===null||c.return===u)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}var ai=0,nt=null,At=null,vn=null,zg=!1,Xu=!1,dl=!1,Pg=0,Vd=0,Yu=null,bW=0;function sn(){throw Error(s(321))}function Ov(u,c){if(c===null)return!1;for(var p=0;p<c.length&&p<u.length;p++)if(!ar(u[p],c[p]))return!1;return!0}function Fv(u,c,p,g,S,T){return ai=T,nt=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,B.H=u===null||u.memoizedState===null?p_:Yv,dl=!1,T=p(g,S),dl=!1,Xu&&(T=DI(c,p,g,S)),RI(u),T}function RI(u){B.H=Wd;var c=At!==null&&At.next!==null;if(ai=0,vn=At=nt=null,zg=!1,Vd=0,Yu=null,c)throw Error(s(300));u===null||Sn||(u=u.dependencies,u!==null&&Ig(u)&&(Sn=!0))}function DI(u,c,p,g){nt=u;var S=0;do{if(Xu&&(Yu=null),Vd=0,Xu=!1,25<=S)throw Error(s(301));if(S+=1,vn=At=null,u.updateQueue!=null){var T=u.updateQueue;T.lastEffect=null,T.events=null,T.stores=null,T.memoCache!=null&&(T.memoCache.index=0)}B.H=m_,T=c(p,g)}while(Xu);return T}function xW(){var u=B.H,c=u.useState()[0];return c=typeof c.then=="function"?Ud(c):c,u=u.useState()[0],(At!==null?At.memoizedState:null)!==u&&(nt.flags|=1024),c}function Lv(){var u=Pg!==0;return Pg=0,u}function Mv(u,c,p){c.updateQueue=u.updateQueue,c.flags&=-2053,u.lanes&=~p}function zv(u){if(zg){for(u=u.memoizedState;u!==null;){var c=u.queue;c!==null&&(c.pending=null),u=u.next}zg=!1}ai=0,vn=At=nt=null,Xu=!1,Vd=Pg=0,Yu=null}function Ns(){var u={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return vn===null?nt.memoizedState=vn=u:vn=vn.next=u,vn}function pn(){if(At===null){var u=nt.alternate;u=u!==null?u.memoizedState:null}else u=At.next;var c=vn===null?nt.memoizedState:vn.next;if(c!==null)vn=c,At=u;else{if(u===null)throw nt.alternate===null?Error(s(467)):Error(s(310));At=u,u={memoizedState:At.memoizedState,baseState:At.baseState,baseQueue:At.baseQueue,queue:At.queue,next:null},vn===null?nt.memoizedState=vn=u:vn=vn.next=u}return vn}function Bg(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Ud(u){var c=Vd;return Vd+=1,Yu===null&&(Yu=[]),u=TI(Yu,u,c),c=nt,(vn===null?c.memoizedState:vn.next)===null&&(c=c.alternate,B.H=c===null||c.memoizedState===null?p_:Yv),u}function Vg(u){if(u!==null&&typeof u=="object"){if(typeof u.then=="function")return Ud(u);if(u.$$typeof===N)return rs(u)}throw Error(s(438,String(u)))}function Pv(u){var c=null,p=nt.updateQueue;if(p!==null&&(c=p.memoCache),c==null){var g=nt.alternate;g!==null&&(g=g.updateQueue,g!==null&&(g=g.memoCache,g!=null&&(c={data:g.data.map(function(S){return S.slice()}),index:0})))}if(c==null&&(c={data:[],index:0}),p===null&&(p=Bg(),nt.updateQueue=p),p.memoCache=c,p=c.data[c.index],p===void 0)for(p=c.data[c.index]=Array(u),g=0;g<u;g++)p[g]=L;return c.index++,p}function ii(u,c){return typeof c=="function"?c(u):c}function Ug(u){var c=pn();return Bv(c,At,u)}function Bv(u,c,p){var g=u.queue;if(g===null)throw Error(s(311));g.lastRenderedReducer=p;var S=u.baseQueue,T=g.pending;if(T!==null){if(S!==null){var I=S.next;S.next=T.next,T.next=I}c.baseQueue=S=T,g.pending=null}if(T=u.baseState,S===null)u.memoizedState=T;else{c=S.next;var z=I=null,H=null,ue=c,ge=!1;do{var be=ue.lane&-536870913;if(be!==ue.lane?(pt&be)===be:(ai&be)===be){var ce=ue.revertLane;if(ce===0)H!==null&&(H=H.next={lane:0,revertLane:0,gesture:null,action:ue.action,hasEagerState:ue.hasEagerState,eagerState:ue.eagerState,next:null}),be===Wu&&(ge=!0);else if((ai&ce)===ce){ue=ue.next,ce===Wu&&(ge=!0);continue}else be={lane:0,revertLane:ue.revertLane,gesture:null,action:ue.action,hasEagerState:ue.hasEagerState,eagerState:ue.eagerState,next:null},H===null?(z=H=be,I=T):H=H.next=be,nt.lanes|=ce,to|=ce;be=ue.action,dl&&p(T,be),T=ue.hasEagerState?ue.eagerState:p(T,be)}else ce={lane:be,revertLane:ue.revertLane,gesture:ue.gesture,action:ue.action,hasEagerState:ue.hasEagerState,eagerState:ue.eagerState,next:null},H===null?(z=H=ce,I=T):H=H.next=ce,nt.lanes|=be,to|=be;ue=ue.next}while(ue!==null&&ue!==c);if(H===null?I=T:H.next=z,!ar(T,u.memoizedState)&&(Sn=!0,ge&&(p=Gu,p!==null)))throw p;u.memoizedState=T,u.baseState=I,u.baseQueue=H,g.lastRenderedState=T}return S===null&&(g.lanes=0),[u.memoizedState,g.dispatch]}function Vv(u){var c=pn(),p=c.queue;if(p===null)throw Error(s(311));p.lastRenderedReducer=u;var g=p.dispatch,S=p.pending,T=c.memoizedState;if(S!==null){p.pending=null;var I=S=S.next;do T=u(T,I.action),I=I.next;while(I!==S);ar(T,c.memoizedState)||(Sn=!0),c.memoizedState=T,c.baseQueue===null&&(c.baseState=T),p.lastRenderedState=T}return[T,g]}function OI(u,c,p){var g=nt,S=pn(),T=yt;if(T){if(p===void 0)throw Error(s(407));p=p()}else p=c();var I=!ar((At||S).memoizedState,p);if(I&&(S.memoizedState=p,Sn=!0),S=S.queue,Wv(MI.bind(null,g,S,u),[u]),S.getSnapshot!==c||I||vn!==null&&vn.memoizedState.tag&1){if(g.flags|=2048,Ju(9,{destroy:void 0},LI.bind(null,g,S,p,c),null),Ft===null)throw Error(s(349));T||(ai&127)!==0||FI(g,c,p)}return p}function FI(u,c,p){u.flags|=16384,u={getSnapshot:c,value:p},c=nt.updateQueue,c===null?(c=Bg(),nt.updateQueue=c,c.stores=[u]):(p=c.stores,p===null?c.stores=[u]:p.push(u))}function LI(u,c,p,g){c.value=p,c.getSnapshot=g,zI(c)&&PI(u)}function MI(u,c,p){return p(function(){zI(c)&&PI(u)})}function zI(u){var c=u.getSnapshot;u=u.value;try{var p=c();return!ar(u,p)}catch{return!0}}function PI(u){var c=sl(u,2);c!==null&&Us(c,u,2)}function Uv(u){var c=Ns();if(typeof u=="function"){var p=u;if(u=p(),dl){Ea(!0);try{p()}finally{Ea(!1)}}}return c.memoizedState=c.baseState=u,c.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:ii,lastRenderedState:u},c}function BI(u,c,p,g){return u.baseState=p,Bv(u,At,typeof g=="function"?g:ii)}function wW(u,c,p,g,S){if(Gg(u))throw Error(s(485));if(u=c.action,u!==null){var T={payload:S,action:u,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(I){T.listeners.push(I)}};B.T!==null?p(!0):T.isTransition=!1,g(T),p=c.pending,p===null?(T.next=c.pending=T,VI(c,T)):(T.next=p.next,c.pending=p.next=T)}}function VI(u,c){var p=c.action,g=c.payload,S=u.state;if(c.isTransition){var T=B.T,I={};B.T=I;try{var z=p(S,g),H=B.S;H!==null&&H(I,z),UI(u,c,z)}catch(ue){jv(u,c,ue)}finally{T!==null&&I.types!==null&&(T.types=I.types),B.T=T}}else try{T=p(S,g),UI(u,c,T)}catch(ue){jv(u,c,ue)}}function UI(u,c,p){p!==null&&typeof p=="object"&&typeof p.then=="function"?p.then(function(g){jI(u,c,g)},function(g){return jv(u,c,g)}):jI(u,c,p)}function jI(u,c,p){c.status="fulfilled",c.value=p,WI(c),u.state=p,c=u.pending,c!==null&&(p=c.next,p===c?u.pending=null:(p=p.next,c.next=p,VI(u,p)))}function jv(u,c,p){var g=u.pending;if(u.pending=null,g!==null){g=g.next;do c.status="rejected",c.reason=p,WI(c),c=c.next;while(c!==g)}u.action=null}function WI(u){u=u.listeners;for(var c=0;c<u.length;c++)(0,u[c])()}function GI(u,c){return c}function HI(u,c){if(yt){var p=Ft.formState;if(p!==null){e:{var g=nt;if(yt){if(Ut){t:{for(var S=Ut,T=Dr;S.nodeType!==8;){if(!T){S=null;break t}if(S=Fr(S.nextSibling),S===null){S=null;break t}}T=S.data,S=T==="F!"||T==="F"?S:null}if(S){Ut=Fr(S.nextSibling),g=S.data==="F!";break e}}Hi(g)}g=!1}g&&(c=p[0])}}return p=Ns(),p.memoizedState=p.baseState=c,g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:GI,lastRenderedState:c},p.queue=g,p=h_.bind(null,nt,g),g.dispatch=p,g=Uv(!1),T=Xv.bind(null,nt,!1,g.queue),g=Ns(),S={state:c,dispatch:null,action:u,pending:null},g.queue=S,p=wW.bind(null,nt,S,T,p),S.dispatch=p,g.memoizedState=u,[c,p,!1]}function qI(u){var c=pn();return KI(c,At,u)}function KI(u,c,p){if(c=Bv(u,c,GI)[0],u=Ug(ii)[0],typeof c=="object"&&c!==null&&typeof c.then=="function")try{var g=Ud(c)}catch(I){throw I===Hu?Rg:I}else g=c;c=pn();var S=c.queue,T=S.dispatch;return p!==c.memoizedState&&(nt.flags|=2048,Ju(9,{destroy:void 0},vW.bind(null,S,p),null)),[g,T,u]}function vW(u,c){u.action=c}function XI(u){var c=pn(),p=At;if(p!==null)return KI(c,p,u);pn(),c=c.memoizedState,p=pn();var g=p.queue.dispatch;return p.memoizedState=u,[c,g,!1]}function Ju(u,c,p,g){return u={tag:u,create:p,deps:g,inst:c,next:null},c=nt.updateQueue,c===null&&(c=Bg(),nt.updateQueue=c),p=c.lastEffect,p===null?c.lastEffect=u.next=u:(g=p.next,p.next=u,u.next=g,c.lastEffect=u),u}function YI(){return pn().memoizedState}function jg(u,c,p,g){var S=Ns();nt.flags|=u,S.memoizedState=Ju(1|c,{destroy:void 0},p,g===void 0?null:g)}function Wg(u,c,p,g){var S=pn();g=g===void 0?null:g;var T=S.memoizedState.inst;At!==null&&g!==null&&Ov(g,At.memoizedState.deps)?S.memoizedState=Ju(c,T,p,g):(nt.flags|=u,S.memoizedState=Ju(1|c,T,p,g))}function JI(u,c){jg(8390656,8,u,c)}function Wv(u,c){Wg(2048,8,u,c)}function SW(u){nt.flags|=4;var c=nt.updateQueue;if(c===null)c=Bg(),nt.updateQueue=c,c.events=[u];else{var p=c.events;p===null?c.events=[u]:p.push(u)}}function ZI(u){var c=pn().memoizedState;return SW({ref:c,nextImpl:u}),function(){if((Tt&2)!==0)throw Error(s(440));return c.impl.apply(void 0,arguments)}}function QI(u,c){return Wg(4,2,u,c)}function e_(u,c){return Wg(4,4,u,c)}function t_(u,c){if(typeof c=="function"){u=u();var p=c(u);return function(){typeof p=="function"?p():c(null)}}if(c!=null)return u=u(),c.current=u,function(){c.current=null}}function n_(u,c,p){p=p!=null?p.concat([u]):null,Wg(4,4,t_.bind(null,c,u),p)}function Gv(){}function s_(u,c){var p=pn();c=c===void 0?null:c;var g=p.memoizedState;return c!==null&&Ov(c,g[1])?g[0]:(p.memoizedState=[u,c],u)}function r_(u,c){var p=pn();c=c===void 0?null:c;var g=p.memoizedState;if(c!==null&&Ov(c,g[1]))return g[0];if(g=u(),dl){Ea(!0);try{u()}finally{Ea(!1)}}return p.memoizedState=[g,c],g}function Hv(u,c,p){return p===void 0||(ai&1073741824)!==0&&(pt&261930)===0?u.memoizedState=c:(u.memoizedState=p,u=aA(),nt.lanes|=u,to|=u,p)}function a_(u,c,p,g){return ar(p,c)?p:Ku.current!==null?(u=Hv(u,p,g),ar(u,c)||(Sn=!0),u):(ai&42)===0||(ai&1073741824)!==0&&(pt&261930)===0?(Sn=!0,u.memoizedState=p):(u=aA(),nt.lanes|=u,to|=u,c)}function i_(u,c,p,g,S){var T=U.p;U.p=T!==0&&8>T?T:8;var I=B.T,z={};B.T=z,Xv(u,!1,c,p);try{var H=S(),ue=B.S;if(ue!==null&&ue(z,H),H!==null&&typeof H=="object"&&typeof H.then=="function"){var ge=yW(H,g);jd(u,c,ge,hr(u))}else jd(u,c,g,hr(u))}catch(be){jd(u,c,{then:function(){},status:"rejected",reason:be},hr())}finally{U.p=T,I!==null&&z.types!==null&&(I.types=z.types),B.T=I}}function TW(){}function qv(u,c,p,g){if(u.tag!==5)throw Error(s(476));var S=o_(u).queue;i_(u,S,c,X,p===null?TW:function(){return l_(u),p(g)})}function o_(u){var c=u.memoizedState;if(c!==null)return c;c={memoizedState:X,baseState:X,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ii,lastRenderedState:X},next:null};var p={};return c.next={memoizedState:p,baseState:p,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:ii,lastRenderedState:p},next:null},u.memoizedState=c,u=u.alternate,u!==null&&(u.memoizedState=c),c}function l_(u){var c=o_(u);c.next===null&&(c=u.alternate.memoizedState),jd(u,c.next.queue,{},hr())}function Kv(){return rs(of)}function u_(){return pn().memoizedState}function c_(){return pn().memoizedState}function CW(u){for(var c=u.return;c!==null;){switch(c.tag){case 24:case 3:var p=hr();u=Xi(p);var g=Yi(c,u,p);g!==null&&(Us(g,c,p),zd(g,c,p)),c={cache:Tv()},u.payload=c;return}c=c.return}}function NW(u,c,p){var g=hr();p={lane:g,revertLane:0,gesture:null,action:p,hasEagerState:!1,eagerState:null,next:null},Gg(u)?d_(c,p):(p=dv(u,c,p,g),p!==null&&(Us(p,u,g),f_(p,c,g)))}function h_(u,c,p){var g=hr();jd(u,c,p,g)}function jd(u,c,p,g){var S={lane:g,revertLane:0,gesture:null,action:p,hasEagerState:!1,eagerState:null,next:null};if(Gg(u))d_(c,S);else{var T=u.alternate;if(u.lanes===0&&(T===null||T.lanes===0)&&(T=c.lastRenderedReducer,T!==null))try{var I=c.lastRenderedState,z=T(I,p);if(S.hasEagerState=!0,S.eagerState=z,ar(z,I))return Ng(u,c,S,0),Ft===null&&Cg(),!1}catch{}if(p=dv(u,c,S,g),p!==null)return Us(p,u,g),f_(p,c,g),!0}return!1}function Xv(u,c,p,g){if(g={lane:2,revertLane:E1(),gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},Gg(u)){if(c)throw Error(s(479))}else c=dv(u,p,g,2),c!==null&&Us(c,u,2)}function Gg(u){var c=u.alternate;return u===nt||c!==null&&c===nt}function d_(u,c){Xu=zg=!0;var p=u.pending;p===null?c.next=c:(c.next=p.next,p.next=c),u.pending=c}function f_(u,c,p){if((p&4194048)!==0){var g=c.lanes;g&=u.pendingLanes,p|=g,c.lanes=p,b$(u,p)}}var Wd={readContext:rs,use:Vg,useCallback:sn,useContext:sn,useEffect:sn,useImperativeHandle:sn,useLayoutEffect:sn,useInsertionEffect:sn,useMemo:sn,useReducer:sn,useRef:sn,useState:sn,useDebugValue:sn,useDeferredValue:sn,useTransition:sn,useSyncExternalStore:sn,useId:sn,useHostTransitionStatus:sn,useFormState:sn,useActionState:sn,useOptimistic:sn,useMemoCache:sn,useCacheRefresh:sn};Wd.useEffectEvent=sn;var p_={readContext:rs,use:Vg,useCallback:function(u,c){return Ns().memoizedState=[u,c===void 0?null:c],u},useContext:rs,useEffect:JI,useImperativeHandle:function(u,c,p){p=p!=null?p.concat([u]):null,jg(4194308,4,t_.bind(null,c,u),p)},useLayoutEffect:function(u,c){return jg(4194308,4,u,c)},useInsertionEffect:function(u,c){jg(4,2,u,c)},useMemo:function(u,c){var p=Ns();c=c===void 0?null:c;var g=u();if(dl){Ea(!0);try{u()}finally{Ea(!1)}}return p.memoizedState=[g,c],g},useReducer:function(u,c,p){var g=Ns();if(p!==void 0){var S=p(c);if(dl){Ea(!0);try{p(c)}finally{Ea(!1)}}}else S=c;return g.memoizedState=g.baseState=S,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:u,lastRenderedState:S},g.queue=u,u=u.dispatch=NW.bind(null,nt,u),[g.memoizedState,u]},useRef:function(u){var c=Ns();return u={current:u},c.memoizedState=u},useState:function(u){u=Uv(u);var c=u.queue,p=h_.bind(null,nt,c);return c.dispatch=p,[u.memoizedState,p]},useDebugValue:Gv,useDeferredValue:function(u,c){var p=Ns();return Hv(p,u,c)},useTransition:function(){var u=Uv(!1);return u=i_.bind(null,nt,u.queue,!0,!1),Ns().memoizedState=u,[!1,u]},useSyncExternalStore:function(u,c,p){var g=nt,S=Ns();if(yt){if(p===void 0)throw Error(s(407));p=p()}else{if(p=c(),Ft===null)throw Error(s(349));(pt&127)!==0||FI(g,c,p)}S.memoizedState=p;var T={value:p,getSnapshot:c};return S.queue=T,JI(MI.bind(null,g,T,u),[u]),g.flags|=2048,Ju(9,{destroy:void 0},LI.bind(null,g,T,p,c),null),p},useId:function(){var u=Ns(),c=Ft.identifierPrefix;if(yt){var p=Ia,g=$a;p=(g&~(1<<32-rr(g)-1)).toString(32)+p,c="_"+c+"R_"+p,p=Pg++,0<p&&(c+="H"+p.toString(32)),c+="_"}else p=bW++,c="_"+c+"r_"+p.toString(32)+"_";return u.memoizedState=c},useHostTransitionStatus:Kv,useFormState:HI,useActionState:HI,useOptimistic:function(u){var c=Ns();c.memoizedState=c.baseState=u;var p={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return c.queue=p,c=Xv.bind(null,nt,!0,p),p.dispatch=c,[u,c]},useMemoCache:Pv,useCacheRefresh:function(){return Ns().memoizedState=CW.bind(null,nt)},useEffectEvent:function(u){var c=Ns(),p={impl:u};return c.memoizedState=p,function(){if((Tt&2)!==0)throw Error(s(440));return p.impl.apply(void 0,arguments)}}},Yv={readContext:rs,use:Vg,useCallback:s_,useContext:rs,useEffect:Wv,useImperativeHandle:n_,useInsertionEffect:QI,useLayoutEffect:e_,useMemo:r_,useReducer:Ug,useRef:YI,useState:function(){return Ug(ii)},useDebugValue:Gv,useDeferredValue:function(u,c){var p=pn();return a_(p,At.memoizedState,u,c)},useTransition:function(){var u=Ug(ii)[0],c=pn().memoizedState;return[typeof u=="boolean"?u:Ud(u),c]},useSyncExternalStore:OI,useId:u_,useHostTransitionStatus:Kv,useFormState:qI,useActionState:qI,useOptimistic:function(u,c){var p=pn();return BI(p,At,u,c)},useMemoCache:Pv,useCacheRefresh:c_};Yv.useEffectEvent=ZI;var m_={readContext:rs,use:Vg,useCallback:s_,useContext:rs,useEffect:Wv,useImperativeHandle:n_,useInsertionEffect:QI,useLayoutEffect:e_,useMemo:r_,useReducer:Vv,useRef:YI,useState:function(){return Vv(ii)},useDebugValue:Gv,useDeferredValue:function(u,c){var p=pn();return At===null?Hv(p,u,c):a_(p,At.memoizedState,u,c)},useTransition:function(){var u=Vv(ii)[0],c=pn().memoizedState;return[typeof u=="boolean"?u:Ud(u),c]},useSyncExternalStore:OI,useId:u_,useHostTransitionStatus:Kv,useFormState:XI,useActionState:XI,useOptimistic:function(u,c){var p=pn();return At!==null?BI(p,At,u,c):(p.baseState=u,[u,p.queue.dispatch])},useMemoCache:Pv,useCacheRefresh:c_};m_.useEffectEvent=ZI;function Jv(u,c,p,g){c=u.memoizedState,p=p(g,c),p=p==null?c:f({},c,p),u.memoizedState=p,u.lanes===0&&(u.updateQueue.baseState=p)}var Zv={enqueueSetState:function(u,c,p){u=u._reactInternals;var g=hr(),S=Xi(g);S.payload=c,p!=null&&(S.callback=p),c=Yi(u,S,g),c!==null&&(Us(c,u,g),zd(c,u,g))},enqueueReplaceState:function(u,c,p){u=u._reactInternals;var g=hr(),S=Xi(g);S.tag=1,S.payload=c,p!=null&&(S.callback=p),c=Yi(u,S,g),c!==null&&(Us(c,u,g),zd(c,u,g))},enqueueForceUpdate:function(u,c){u=u._reactInternals;var p=hr(),g=Xi(p);g.tag=2,c!=null&&(g.callback=c),c=Yi(u,g,p),c!==null&&(Us(c,u,p),zd(c,u,p))}};function g_(u,c,p,g,S,T,I){return u=u.stateNode,typeof u.shouldComponentUpdate=="function"?u.shouldComponentUpdate(g,T,I):c.prototype&&c.prototype.isPureReactComponent?!_d(p,g)||!_d(S,T):!0}function y_(u,c,p,g){u=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(p,g),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(p,g),c.state!==u&&Zv.enqueueReplaceState(c,c.state,null)}function fl(u,c){var p=c;if("ref"in c){p={};for(var g in c)g!=="ref"&&(p[g]=c[g])}if(u=u.defaultProps){p===c&&(p=f({},p));for(var S in u)p[S]===void 0&&(p[S]=u[S])}return p}function b_(u){Tg(u)}function x_(u){console.error(u)}function w_(u){Tg(u)}function Hg(u,c){try{var p=u.onUncaughtError;p(c.value,{componentStack:c.stack})}catch(g){setTimeout(function(){throw g})}}function v_(u,c,p){try{var g=u.onCaughtError;g(p.value,{componentStack:p.stack,errorBoundary:c.tag===1?c.stateNode:null})}catch(S){setTimeout(function(){throw S})}}function Qv(u,c,p){return p=Xi(p),p.tag=3,p.payload={element:null},p.callback=function(){Hg(u,c)},p}function S_(u){return u=Xi(u),u.tag=3,u}function T_(u,c,p,g){var S=p.type.getDerivedStateFromError;if(typeof S=="function"){var T=g.value;u.payload=function(){return S(T)},u.callback=function(){v_(c,p,g)}}var I=p.stateNode;I!==null&&typeof I.componentDidCatch=="function"&&(u.callback=function(){v_(c,p,g),typeof S!="function"&&(no===null?no=new Set([this]):no.add(this));var z=g.stack;this.componentDidCatch(g.value,{componentStack:z!==null?z:""})})}function kW(u,c,p,g,S){if(p.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){if(c=p.alternate,c!==null&&ju(c,p,S,!0),p=or.current,p!==null){switch(p.tag){case 31:case 13:return Or===null?ry():p.alternate===null&&rn===0&&(rn=3),p.flags&=-257,p.flags|=65536,p.lanes=S,g===Dg?p.flags|=16384:(c=p.updateQueue,c===null?p.updateQueue=new Set([g]):c.add(g),C1(u,g,S)),!1;case 22:return p.flags|=65536,g===Dg?p.flags|=16384:(c=p.updateQueue,c===null?(c={transitions:null,markerInstances:null,retryQueue:new Set([g])},p.updateQueue=c):(p=c.retryQueue,p===null?c.retryQueue=new Set([g]):p.add(g)),C1(u,g,S)),!1}throw Error(s(435,p.tag))}return C1(u,g,S),ry(),!1}if(yt)return c=or.current,c!==null?((c.flags&65536)===0&&(c.flags|=256),c.flags|=65536,c.lanes=S,g!==bv&&(u=Error(s(422),{cause:g}),Dd(_r(u,p)))):(g!==bv&&(c=Error(s(423),{cause:g}),Dd(_r(c,p))),u=u.current.alternate,u.flags|=65536,S&=-S,u.lanes|=S,g=_r(g,p),S=Qv(u.stateNode,g,S),Iv(u,S),rn!==4&&(rn=2)),!1;var T=Error(s(520),{cause:g});if(T=_r(T,p),Zd===null?Zd=[T]:Zd.push(T),rn!==4&&(rn=2),c===null)return!0;g=_r(g,p),p=c;do{switch(p.tag){case 3:return p.flags|=65536,u=S&-S,p.lanes|=u,u=Qv(p.stateNode,g,u),Iv(p,u),!1;case 1:if(c=p.type,T=p.stateNode,(p.flags&128)===0&&(typeof c.getDerivedStateFromError=="function"||T!==null&&typeof T.componentDidCatch=="function"&&(no===null||!no.has(T))))return p.flags|=65536,S&=-S,p.lanes|=S,S=S_(S),T_(S,u,p,g),Iv(p,S),!1}p=p.return}while(p!==null);return!1}var e1=Error(s(461)),Sn=!1;function as(u,c,p,g){c.child=u===null?EI(c,null,p,g):hl(c,u.child,p,g)}function C_(u,c,p,g,S){p=p.render;var T=c.ref;if("ref"in g){var I={};for(var z in g)z!=="ref"&&(I[z]=g[z])}else I=g;return ol(c),g=Fv(u,c,p,I,T,S),z=Lv(),u!==null&&!Sn?(Mv(u,c,S),oi(u,c,S)):(yt&&z&&gv(c),c.flags|=1,as(u,c,g,S),c.child)}function N_(u,c,p,g,S){if(u===null){var T=p.type;return typeof T=="function"&&!fv(T)&&T.defaultProps===void 0&&p.compare===null?(c.tag=15,c.type=T,k_(u,c,T,g,S)):(u=Eg(p.type,null,g,c,c.mode,S),u.ref=c.ref,u.return=c,c.child=u)}if(T=u.child,!l1(u,S)){var I=T.memoizedProps;if(p=p.compare,p=p!==null?p:_d,p(I,g)&&u.ref===c.ref)return oi(u,c,S)}return c.flags|=1,u=ti(T,g),u.ref=c.ref,u.return=c,c.child=u}function k_(u,c,p,g,S){if(u!==null){var T=u.memoizedProps;if(_d(T,g)&&u.ref===c.ref)if(Sn=!1,c.pendingProps=g=T,l1(u,S))(u.flags&131072)!==0&&(Sn=!0);else return c.lanes=u.lanes,oi(u,c,S)}return t1(u,c,p,g,S)}function E_(u,c,p,g){var S=g.children,T=u!==null?u.memoizedState:null;if(u===null&&c.stateNode===null&&(c.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),g.mode==="hidden"){if((c.flags&128)!==0){if(T=T!==null?T.baseLanes|p:p,u!==null){for(g=c.child=u.child,S=0;g!==null;)S=S|g.lanes|g.childLanes,g=g.sibling;g=S&~T}else g=0,c.child=null;return $_(u,c,T,p,g)}if((p&536870912)!==0)c.memoizedState={baseLanes:0,cachePool:null},u!==null&&Ag(c,T!==null?T.cachePool:null),T!==null?_I(c,T):Av(),AI(c);else return g=c.lanes=536870912,$_(u,c,T!==null?T.baseLanes|p:p,p,g)}else T!==null?(Ag(c,T.cachePool),_I(c,T),Zi(),c.memoizedState=null):(u!==null&&Ag(c,null),Av(),Zi());return as(u,c,S,p),c.child}function Gd(u,c){return u!==null&&u.tag===22||c.stateNode!==null||(c.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),c.sibling}function $_(u,c,p,g,S){var T=Nv();return T=T===null?null:{parent:wn._currentValue,pool:T},c.memoizedState={baseLanes:p,cachePool:T},u!==null&&Ag(c,null),Av(),AI(c),u!==null&&ju(u,c,g,!0),c.childLanes=S,null}function qg(u,c){return c=Xg({mode:c.mode,children:c.children},u.mode),c.ref=u.ref,u.child=c,c.return=u,c}function I_(u,c,p){return hl(c,u.child,null,p),u=qg(c,c.pendingProps),u.flags|=2,lr(c),c.memoizedState=null,u}function EW(u,c,p){var g=c.pendingProps,S=(c.flags&128)!==0;if(c.flags&=-129,u===null){if(yt){if(g.mode==="hidden")return u=qg(c,g),c.lanes=536870912,Gd(null,u);if(Dv(c),(u=Ut)?(u=VA(u,Dr),u=u!==null&&u.data==="&"?u:null,u!==null&&(c.memoizedState={dehydrated:u,treeContext:Wi!==null?{id:$a,overflow:Ia}:null,retryLane:536870912,hydrationErrors:null},p=dI(u),p.return=c,c.child=p,ss=c,Ut=null)):u=null,u===null)throw Hi(c);return c.lanes=536870912,null}return qg(c,g)}var T=u.memoizedState;if(T!==null){var I=T.dehydrated;if(Dv(c),S)if(c.flags&256)c.flags&=-257,c=I_(u,c,p);else if(c.memoizedState!==null)c.child=u.child,c.flags|=128,c=null;else throw Error(s(558));else if(Sn||ju(u,c,p,!1),S=(p&u.childLanes)!==0,Sn||S){if(g=Ft,g!==null&&(I=x$(g,p),I!==0&&I!==T.retryLane))throw T.retryLane=I,sl(u,I),Us(g,u,I),e1;ry(),c=I_(u,c,p)}else u=T.treeContext,Ut=Fr(I.nextSibling),ss=c,yt=!0,Gi=null,Dr=!1,u!==null&&mI(c,u),c=qg(c,g),c.flags|=4096;return c}return u=ti(u.child,{mode:g.mode,children:g.children}),u.ref=c.ref,c.child=u,u.return=c,u}function Kg(u,c){var p=c.ref;if(p===null)u!==null&&u.ref!==null&&(c.flags|=4194816);else{if(typeof p!="function"&&typeof p!="object")throw Error(s(284));(u===null||u.ref!==p)&&(c.flags|=4194816)}}function t1(u,c,p,g,S){return ol(c),p=Fv(u,c,p,g,void 0,S),g=Lv(),u!==null&&!Sn?(Mv(u,c,S),oi(u,c,S)):(yt&&g&&gv(c),c.flags|=1,as(u,c,p,S),c.child)}function __(u,c,p,g,S,T){return ol(c),c.updateQueue=null,p=DI(c,g,p,S),RI(u),g=Lv(),u!==null&&!Sn?(Mv(u,c,T),oi(u,c,T)):(yt&&g&&gv(c),c.flags|=1,as(u,c,p,T),c.child)}function A_(u,c,p,g,S){if(ol(c),c.stateNode===null){var T=Pu,I=p.contextType;typeof I=="object"&&I!==null&&(T=rs(I)),T=new p(g,T),c.memoizedState=T.state!==null&&T.state!==void 0?T.state:null,T.updater=Zv,c.stateNode=T,T._reactInternals=c,T=c.stateNode,T.props=g,T.state=c.memoizedState,T.refs={},Ev(c),I=p.contextType,T.context=typeof I=="object"&&I!==null?rs(I):Pu,T.state=c.memoizedState,I=p.getDerivedStateFromProps,typeof I=="function"&&(Jv(c,p,I,g),T.state=c.memoizedState),typeof p.getDerivedStateFromProps=="function"||typeof T.getSnapshotBeforeUpdate=="function"||typeof T.UNSAFE_componentWillMount!="function"&&typeof T.componentWillMount!="function"||(I=T.state,typeof T.componentWillMount=="function"&&T.componentWillMount(),typeof T.UNSAFE_componentWillMount=="function"&&T.UNSAFE_componentWillMount(),I!==T.state&&Zv.enqueueReplaceState(T,T.state,null),Bd(c,g,T,S),Pd(),T.state=c.memoizedState),typeof T.componentDidMount=="function"&&(c.flags|=4194308),g=!0}else if(u===null){T=c.stateNode;var z=c.memoizedProps,H=fl(p,z);T.props=H;var ue=T.context,ge=p.contextType;I=Pu,typeof ge=="object"&&ge!==null&&(I=rs(ge));var be=p.getDerivedStateFromProps;ge=typeof be=="function"||typeof T.getSnapshotBeforeUpdate=="function",z=c.pendingProps!==z,ge||typeof T.UNSAFE_componentWillReceiveProps!="function"&&typeof T.componentWillReceiveProps!="function"||(z||ue!==I)&&y_(c,T,g,I),Ki=!1;var ce=c.memoizedState;T.state=ce,Bd(c,g,T,S),Pd(),ue=c.memoizedState,z||ce!==ue||Ki?(typeof be=="function"&&(Jv(c,p,be,g),ue=c.memoizedState),(H=Ki||g_(c,p,H,g,ce,ue,I))?(ge||typeof T.UNSAFE_componentWillMount!="function"&&typeof T.componentWillMount!="function"||(typeof T.componentWillMount=="function"&&T.componentWillMount(),typeof T.UNSAFE_componentWillMount=="function"&&T.UNSAFE_componentWillMount()),typeof T.componentDidMount=="function"&&(c.flags|=4194308)):(typeof T.componentDidMount=="function"&&(c.flags|=4194308),c.memoizedProps=g,c.memoizedState=ue),T.props=g,T.state=ue,T.context=I,g=H):(typeof T.componentDidMount=="function"&&(c.flags|=4194308),g=!1)}else{T=c.stateNode,$v(u,c),I=c.memoizedProps,ge=fl(p,I),T.props=ge,be=c.pendingProps,ce=T.context,ue=p.contextType,H=Pu,typeof ue=="object"&&ue!==null&&(H=rs(ue)),z=p.getDerivedStateFromProps,(ue=typeof z=="function"||typeof T.getSnapshotBeforeUpdate=="function")||typeof T.UNSAFE_componentWillReceiveProps!="function"&&typeof T.componentWillReceiveProps!="function"||(I!==be||ce!==H)&&y_(c,T,g,H),Ki=!1,ce=c.memoizedState,T.state=ce,Bd(c,g,T,S),Pd();var de=c.memoizedState;I!==be||ce!==de||Ki||u!==null&&u.dependencies!==null&&Ig(u.dependencies)?(typeof z=="function"&&(Jv(c,p,z,g),de=c.memoizedState),(ge=Ki||g_(c,p,ge,g,ce,de,H)||u!==null&&u.dependencies!==null&&Ig(u.dependencies))?(ue||typeof T.UNSAFE_componentWillUpdate!="function"&&typeof T.componentWillUpdate!="function"||(typeof T.componentWillUpdate=="function"&&T.componentWillUpdate(g,de,H),typeof T.UNSAFE_componentWillUpdate=="function"&&T.UNSAFE_componentWillUpdate(g,de,H)),typeof T.componentDidUpdate=="function"&&(c.flags|=4),typeof T.getSnapshotBeforeUpdate=="function"&&(c.flags|=1024)):(typeof T.componentDidUpdate!="function"||I===u.memoizedProps&&ce===u.memoizedState||(c.flags|=4),typeof T.getSnapshotBeforeUpdate!="function"||I===u.memoizedProps&&ce===u.memoizedState||(c.flags|=1024),c.memoizedProps=g,c.memoizedState=de),T.props=g,T.state=de,T.context=H,g=ge):(typeof T.componentDidUpdate!="function"||I===u.memoizedProps&&ce===u.memoizedState||(c.flags|=4),typeof T.getSnapshotBeforeUpdate!="function"||I===u.memoizedProps&&ce===u.memoizedState||(c.flags|=1024),g=!1)}return T=g,Kg(u,c),g=(c.flags&128)!==0,T||g?(T=c.stateNode,p=g&&typeof p.getDerivedStateFromError!="function"?null:T.render(),c.flags|=1,u!==null&&g?(c.child=hl(c,u.child,null,S),c.child=hl(c,null,p,S)):as(u,c,p,S),c.memoizedState=T.state,u=c.child):u=oi(u,c,S),u}function R_(u,c,p,g){return al(),c.flags|=256,as(u,c,p,g),c.child}var n1={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function s1(u){return{baseLanes:u,cachePool:vI()}}function r1(u,c,p){return u=u!==null?u.childLanes&~p:0,c&&(u|=cr),u}function D_(u,c,p){var g=c.pendingProps,S=!1,T=(c.flags&128)!==0,I;if((I=T)||(I=u!==null&&u.memoizedState===null?!1:(fn.current&2)!==0),I&&(S=!0,c.flags&=-129),I=(c.flags&32)!==0,c.flags&=-33,u===null){if(yt){if(S?Ji(c):Zi(),(u=Ut)?(u=VA(u,Dr),u=u!==null&&u.data!=="&"?u:null,u!==null&&(c.memoizedState={dehydrated:u,treeContext:Wi!==null?{id:$a,overflow:Ia}:null,retryLane:536870912,hydrationErrors:null},p=dI(u),p.return=c,c.child=p,ss=c,Ut=null)):u=null,u===null)throw Hi(c);return B1(u)?c.lanes=32:c.lanes=536870912,null}var z=g.children;return g=g.fallback,S?(Zi(),S=c.mode,z=Xg({mode:"hidden",children:z},S),g=rl(g,S,p,null),z.return=c,g.return=c,z.sibling=g,c.child=z,g=c.child,g.memoizedState=s1(p),g.childLanes=r1(u,I,p),c.memoizedState=n1,Gd(null,g)):(Ji(c),a1(c,z))}var H=u.memoizedState;if(H!==null&&(z=H.dehydrated,z!==null)){if(T)c.flags&256?(Ji(c),c.flags&=-257,c=i1(u,c,p)):c.memoizedState!==null?(Zi(),c.child=u.child,c.flags|=128,c=null):(Zi(),z=g.fallback,S=c.mode,g=Xg({mode:"visible",children:g.children},S),z=rl(z,S,p,null),z.flags|=2,g.return=c,z.return=c,g.sibling=z,c.child=g,hl(c,u.child,null,p),g=c.child,g.memoizedState=s1(p),g.childLanes=r1(u,I,p),c.memoizedState=n1,c=Gd(null,g));else if(Ji(c),B1(z)){if(I=z.nextSibling&&z.nextSibling.dataset,I)var ue=I.dgst;I=ue,g=Error(s(419)),g.stack="",g.digest=I,Dd({value:g,source:null,stack:null}),c=i1(u,c,p)}else if(Sn||ju(u,c,p,!1),I=(p&u.childLanes)!==0,Sn||I){if(I=Ft,I!==null&&(g=x$(I,p),g!==0&&g!==H.retryLane))throw H.retryLane=g,sl(u,g),Us(I,u,g),e1;P1(z)||ry(),c=i1(u,c,p)}else P1(z)?(c.flags|=192,c.child=u.child,c=null):(u=H.treeContext,Ut=Fr(z.nextSibling),ss=c,yt=!0,Gi=null,Dr=!1,u!==null&&mI(c,u),c=a1(c,g.children),c.flags|=4096);return c}return S?(Zi(),z=g.fallback,S=c.mode,H=u.child,ue=H.sibling,g=ti(H,{mode:"hidden",children:g.children}),g.subtreeFlags=H.subtreeFlags&65011712,ue!==null?z=ti(ue,z):(z=rl(z,S,p,null),z.flags|=2),z.return=c,g.return=c,g.sibling=z,c.child=g,Gd(null,g),g=c.child,z=u.child.memoizedState,z===null?z=s1(p):(S=z.cachePool,S!==null?(H=wn._currentValue,S=S.parent!==H?{parent:H,pool:H}:S):S=vI(),z={baseLanes:z.baseLanes|p,cachePool:S}),g.memoizedState=z,g.childLanes=r1(u,I,p),c.memoizedState=n1,Gd(u.child,g)):(Ji(c),p=u.child,u=p.sibling,p=ti(p,{mode:"visible",children:g.children}),p.return=c,p.sibling=null,u!==null&&(I=c.deletions,I===null?(c.deletions=[u],c.flags|=16):I.push(u)),c.child=p,c.memoizedState=null,p)}function a1(u,c){return c=Xg({mode:"visible",children:c},u.mode),c.return=u,u.child=c}function Xg(u,c){return u=ir(22,u,null,c),u.lanes=0,u}function i1(u,c,p){return hl(c,u.child,null,p),u=a1(c,c.pendingProps.children),u.flags|=2,c.memoizedState=null,u}function O_(u,c,p){u.lanes|=c;var g=u.alternate;g!==null&&(g.lanes|=c),vv(u.return,c,p)}function o1(u,c,p,g,S,T){var I=u.memoizedState;I===null?u.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:g,tail:p,tailMode:S,treeForkCount:T}:(I.isBackwards=c,I.rendering=null,I.renderingStartTime=0,I.last=g,I.tail=p,I.tailMode=S,I.treeForkCount=T)}function F_(u,c,p){var g=c.pendingProps,S=g.revealOrder,T=g.tail;g=g.children;var I=fn.current,z=(I&2)!==0;if(z?(I=I&1|2,c.flags|=128):I&=1,te(fn,I),as(u,c,g,p),g=yt?Rd:0,!z&&u!==null&&(u.flags&128)!==0)e:for(u=c.child;u!==null;){if(u.tag===13)u.memoizedState!==null&&O_(u,p,c);else if(u.tag===19)O_(u,p,c);else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===c)break e;for(;u.sibling===null;){if(u.return===null||u.return===c)break e;u=u.return}u.sibling.return=u.return,u=u.sibling}switch(S){case"forwards":for(p=c.child,S=null;p!==null;)u=p.alternate,u!==null&&Mg(u)===null&&(S=p),p=p.sibling;p=S,p===null?(S=c.child,c.child=null):(S=p.sibling,p.sibling=null),o1(c,!1,S,p,T,g);break;case"backwards":case"unstable_legacy-backwards":for(p=null,S=c.child,c.child=null;S!==null;){if(u=S.alternate,u!==null&&Mg(u)===null){c.child=S;break}u=S.sibling,S.sibling=p,p=S,S=u}o1(c,!0,p,null,T,g);break;case"together":o1(c,!1,null,null,void 0,g);break;default:c.memoizedState=null}return c.child}function oi(u,c,p){if(u!==null&&(c.dependencies=u.dependencies),to|=c.lanes,(p&c.childLanes)===0)if(u!==null){if(ju(u,c,p,!1),(p&c.childLanes)===0)return null}else return null;if(u!==null&&c.child!==u.child)throw Error(s(153));if(c.child!==null){for(u=c.child,p=ti(u,u.pendingProps),c.child=p,p.return=c;u.sibling!==null;)u=u.sibling,p=p.sibling=ti(u,u.pendingProps),p.return=c;p.sibling=null}return c.child}function l1(u,c){return(u.lanes&c)!==0?!0:(u=u.dependencies,!!(u!==null&&Ig(u)))}function $W(u,c,p){switch(c.tag){case 3:_e(c,c.stateNode.containerInfo),qi(c,wn,u.memoizedState.cache),al();break;case 27:case 5:Ue(c);break;case 4:_e(c,c.stateNode.containerInfo);break;case 10:qi(c,c.type,c.memoizedProps.value);break;case 31:if(c.memoizedState!==null)return c.flags|=128,Dv(c),null;break;case 13:var g=c.memoizedState;if(g!==null)return g.dehydrated!==null?(Ji(c),c.flags|=128,null):(p&c.child.childLanes)!==0?D_(u,c,p):(Ji(c),u=oi(u,c,p),u!==null?u.sibling:null);Ji(c);break;case 19:var S=(u.flags&128)!==0;if(g=(p&c.childLanes)!==0,g||(ju(u,c,p,!1),g=(p&c.childLanes)!==0),S){if(g)return F_(u,c,p);c.flags|=128}if(S=c.memoizedState,S!==null&&(S.rendering=null,S.tail=null,S.lastEffect=null),te(fn,fn.current),g)break;return null;case 22:return c.lanes=0,E_(u,c,p,c.pendingProps);case 24:qi(c,wn,u.memoizedState.cache)}return oi(u,c,p)}function L_(u,c,p){if(u!==null)if(u.memoizedProps!==c.pendingProps)Sn=!0;else{if(!l1(u,p)&&(c.flags&128)===0)return Sn=!1,$W(u,c,p);Sn=(u.flags&131072)!==0}else Sn=!1,yt&&(c.flags&1048576)!==0&&pI(c,Rd,c.index);switch(c.lanes=0,c.tag){case 16:e:{var g=c.pendingProps;if(u=ul(c.elementType),c.type=u,typeof u=="function")fv(u)?(g=fl(u,g),c.tag=1,c=A_(null,c,u,g,p)):(c.tag=0,c=t1(null,c,u,g,p));else{if(u!=null){var S=u.$$typeof;if(S===k){c.tag=11,c=C_(null,c,u,g,p);break e}else if(S===R){c.tag=14,c=N_(null,c,u,g,p);break e}}throw c=ne(u)||u,Error(s(306,c,""))}}return c;case 0:return t1(u,c,c.type,c.pendingProps,p);case 1:return g=c.type,S=fl(g,c.pendingProps),A_(u,c,g,S,p);case 3:e:{if(_e(c,c.stateNode.containerInfo),u===null)throw Error(s(387));g=c.pendingProps;var T=c.memoizedState;S=T.element,$v(u,c),Bd(c,g,null,p);var I=c.memoizedState;if(g=I.cache,qi(c,wn,g),g!==T.cache&&Sv(c,[wn],p,!0),Pd(),g=I.element,T.isDehydrated)if(T={element:g,isDehydrated:!1,cache:I.cache},c.updateQueue.baseState=T,c.memoizedState=T,c.flags&256){c=R_(u,c,g,p);break e}else if(g!==S){S=_r(Error(s(424)),c),Dd(S),c=R_(u,c,g,p);break e}else for(u=c.stateNode.containerInfo,u.nodeType===9?u=u.body:u=u.nodeName==="HTML"?u.ownerDocument.body:u,Ut=Fr(u.firstChild),ss=c,yt=!0,Gi=null,Dr=!0,p=EI(c,null,g,p),c.child=p;p;)p.flags=p.flags&-3|4096,p=p.sibling;else{if(al(),g===S){c=oi(u,c,p);break e}as(u,c,g,p)}c=c.child}return c;case 26:return Kg(u,c),u===null?(p=qA(c.type,null,c.pendingProps,null))?c.memoizedState=p:yt||(p=c.type,u=c.pendingProps,g=hy(xe.current).createElement(p),g[ns]=c,g[Ls]=u,is(g,p,u),jn(g),c.stateNode=g):c.memoizedState=qA(c.type,u.memoizedProps,c.pendingProps,u.memoizedState),null;case 27:return Ue(c),u===null&&yt&&(g=c.stateNode=WA(c.type,c.pendingProps,xe.current),ss=c,Dr=!0,S=Ut,io(c.type)?(V1=S,Ut=Fr(g.firstChild)):Ut=S),as(u,c,c.pendingProps.children,p),Kg(u,c),u===null&&(c.flags|=4194304),c.child;case 5:return u===null&&yt&&((S=g=Ut)&&(g=rG(g,c.type,c.pendingProps,Dr),g!==null?(c.stateNode=g,ss=c,Ut=Fr(g.firstChild),Dr=!1,S=!0):S=!1),S||Hi(c)),Ue(c),S=c.type,T=c.pendingProps,I=u!==null?u.memoizedProps:null,g=T.children,L1(S,T)?g=null:I!==null&&L1(S,I)&&(c.flags|=32),c.memoizedState!==null&&(S=Fv(u,c,xW,null,null,p),of._currentValue=S),Kg(u,c),as(u,c,g,p),c.child;case 6:return u===null&&yt&&((u=p=Ut)&&(p=aG(p,c.pendingProps,Dr),p!==null?(c.stateNode=p,ss=c,Ut=null,u=!0):u=!1),u||Hi(c)),null;case 13:return D_(u,c,p);case 4:return _e(c,c.stateNode.containerInfo),g=c.pendingProps,u===null?c.child=hl(c,null,g,p):as(u,c,g,p),c.child;case 11:return C_(u,c,c.type,c.pendingProps,p);case 7:return as(u,c,c.pendingProps,p),c.child;case 8:return as(u,c,c.pendingProps.children,p),c.child;case 12:return as(u,c,c.pendingProps.children,p),c.child;case 10:return g=c.pendingProps,qi(c,c.type,g.value),as(u,c,g.children,p),c.child;case 9:return S=c.type._context,g=c.pendingProps.children,ol(c),S=rs(S),g=g(S),c.flags|=1,as(u,c,g,p),c.child;case 14:return N_(u,c,c.type,c.pendingProps,p);case 15:return k_(u,c,c.type,c.pendingProps,p);case 19:return F_(u,c,p);case 31:return EW(u,c,p);case 22:return E_(u,c,p,c.pendingProps);case 24:return ol(c),g=rs(wn),u===null?(S=Nv(),S===null&&(S=Ft,T=Tv(),S.pooledCache=T,T.refCount++,T!==null&&(S.pooledCacheLanes|=p),S=T),c.memoizedState={parent:g,cache:S},Ev(c),qi(c,wn,S)):((u.lanes&p)!==0&&($v(u,c),Bd(c,null,null,p),Pd()),S=u.memoizedState,T=c.memoizedState,S.parent!==g?(S={parent:g,cache:g},c.memoizedState=S,c.lanes===0&&(c.memoizedState=c.updateQueue.baseState=S),qi(c,wn,g)):(g=T.cache,qi(c,wn,g),g!==S.cache&&Sv(c,[wn],p,!0))),as(u,c,c.pendingProps.children,p),c.child;case 29:throw c.pendingProps}throw Error(s(156,c.tag))}function li(u){u.flags|=4}function u1(u,c,p,g,S){if((c=(u.mode&32)!==0)&&(c=!1),c){if(u.flags|=16777216,(S&335544128)===S)if(u.stateNode.complete)u.flags|=8192;else if(uA())u.flags|=8192;else throw cl=Dg,kv}else u.flags&=-16777217}function M_(u,c){if(c.type!=="stylesheet"||(c.state.loading&4)!==0)u.flags&=-16777217;else if(u.flags|=16777216,!ZA(c))if(uA())u.flags|=8192;else throw cl=Dg,kv}function Yg(u,c){c!==null&&(u.flags|=4),u.flags&16384&&(c=u.tag!==22?g$():536870912,u.lanes|=c,tc|=c)}function Hd(u,c){if(!yt)switch(u.tailMode){case"hidden":c=u.tail;for(var p=null;c!==null;)c.alternate!==null&&(p=c),c=c.sibling;p===null?u.tail=null:p.sibling=null;break;case"collapsed":p=u.tail;for(var g=null;p!==null;)p.alternate!==null&&(g=p),p=p.sibling;g===null?c||u.tail===null?u.tail=null:u.tail.sibling=null:g.sibling=null}}function jt(u){var c=u.alternate!==null&&u.alternate.child===u.child,p=0,g=0;if(c)for(var S=u.child;S!==null;)p|=S.lanes|S.childLanes,g|=S.subtreeFlags&65011712,g|=S.flags&65011712,S.return=u,S=S.sibling;else for(S=u.child;S!==null;)p|=S.lanes|S.childLanes,g|=S.subtreeFlags,g|=S.flags,S.return=u,S=S.sibling;return u.subtreeFlags|=g,u.childLanes=p,c}function IW(u,c,p){var g=c.pendingProps;switch(yv(c),c.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jt(c),null;case 1:return jt(c),null;case 3:return p=c.stateNode,g=null,u!==null&&(g=u.memoizedState.cache),c.memoizedState.cache!==g&&(c.flags|=2048),ri(wn),$e(),p.pendingContext&&(p.context=p.pendingContext,p.pendingContext=null),(u===null||u.child===null)&&(Uu(c)?li(c):u===null||u.memoizedState.isDehydrated&&(c.flags&256)===0||(c.flags|=1024,xv())),jt(c),null;case 26:var S=c.type,T=c.memoizedState;return u===null?(li(c),T!==null?(jt(c),M_(c,T)):(jt(c),u1(c,S,null,g,p))):T?T!==u.memoizedState?(li(c),jt(c),M_(c,T)):(jt(c),c.flags&=-16777217):(u=u.memoizedProps,u!==g&&li(c),jt(c),u1(c,S,u,g,p)),null;case 27:if(Se(c),p=xe.current,S=c.type,u!==null&&c.stateNode!=null)u.memoizedProps!==g&&li(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return jt(c),null}u=oe.current,Uu(c)?gI(c):(u=WA(S,g,p),c.stateNode=u,li(c))}return jt(c),null;case 5:if(Se(c),S=c.type,u!==null&&c.stateNode!=null)u.memoizedProps!==g&&li(c);else{if(!g){if(c.stateNode===null)throw Error(s(166));return jt(c),null}if(T=oe.current,Uu(c))gI(c);else{var I=hy(xe.current);switch(T){case 1:T=I.createElementNS("http://www.w3.org/2000/svg",S);break;case 2:T=I.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;default:switch(S){case"svg":T=I.createElementNS("http://www.w3.org/2000/svg",S);break;case"math":T=I.createElementNS("http://www.w3.org/1998/Math/MathML",S);break;case"script":T=I.createElement("div"),T.innerHTML="<script><\/script>",T=T.removeChild(T.firstChild);break;case"select":T=typeof g.is=="string"?I.createElement("select",{is:g.is}):I.createElement("select"),g.multiple?T.multiple=!0:g.size&&(T.size=g.size);break;default:T=typeof g.is=="string"?I.createElement(S,{is:g.is}):I.createElement(S)}}T[ns]=c,T[Ls]=g;e:for(I=c.child;I!==null;){if(I.tag===5||I.tag===6)T.appendChild(I.stateNode);else if(I.tag!==4&&I.tag!==27&&I.child!==null){I.child.return=I,I=I.child;continue}if(I===c)break e;for(;I.sibling===null;){if(I.return===null||I.return===c)break e;I=I.return}I.sibling.return=I.return,I=I.sibling}c.stateNode=T;e:switch(is(T,S,g),S){case"button":case"input":case"select":case"textarea":g=!!g.autoFocus;break e;case"img":g=!0;break e;default:g=!1}g&&li(c)}}return jt(c),u1(c,c.type,u===null?null:u.memoizedProps,c.pendingProps,p),null;case 6:if(u&&c.stateNode!=null)u.memoizedProps!==g&&li(c);else{if(typeof g!="string"&&c.stateNode===null)throw Error(s(166));if(u=xe.current,Uu(c)){if(u=c.stateNode,p=c.memoizedProps,g=null,S=ss,S!==null)switch(S.tag){case 27:case 5:g=S.memoizedProps}u[ns]=c,u=!!(u.nodeValue===p||g!==null&&g.suppressHydrationWarning===!0||DA(u.nodeValue,p)),u||Hi(c,!0)}else u=hy(u).createTextNode(g),u[ns]=c,c.stateNode=u}return jt(c),null;case 31:if(p=c.memoizedState,u===null||u.memoizedState!==null){if(g=Uu(c),p!==null){if(u===null){if(!g)throw Error(s(318));if(u=c.memoizedState,u=u!==null?u.dehydrated:null,!u)throw Error(s(557));u[ns]=c}else al(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;jt(c),u=!1}else p=xv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=p),u=!0;if(!u)return c.flags&256?(lr(c),c):(lr(c),null);if((c.flags&128)!==0)throw Error(s(558))}return jt(c),null;case 13:if(g=c.memoizedState,u===null||u.memoizedState!==null&&u.memoizedState.dehydrated!==null){if(S=Uu(c),g!==null&&g.dehydrated!==null){if(u===null){if(!S)throw Error(s(318));if(S=c.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(s(317));S[ns]=c}else al(),(c.flags&128)===0&&(c.memoizedState=null),c.flags|=4;jt(c),S=!1}else S=xv(),u!==null&&u.memoizedState!==null&&(u.memoizedState.hydrationErrors=S),S=!0;if(!S)return c.flags&256?(lr(c),c):(lr(c),null)}return lr(c),(c.flags&128)!==0?(c.lanes=p,c):(p=g!==null,u=u!==null&&u.memoizedState!==null,p&&(g=c.child,S=null,g.alternate!==null&&g.alternate.memoizedState!==null&&g.alternate.memoizedState.cachePool!==null&&(S=g.alternate.memoizedState.cachePool.pool),T=null,g.memoizedState!==null&&g.memoizedState.cachePool!==null&&(T=g.memoizedState.cachePool.pool),T!==S&&(g.flags|=2048)),p!==u&&p&&(c.child.flags|=8192),Yg(c,c.updateQueue),jt(c),null);case 4:return $e(),u===null&&A1(c.stateNode.containerInfo),jt(c),null;case 10:return ri(c.type),jt(c),null;case 19:if(j(fn),g=c.memoizedState,g===null)return jt(c),null;if(S=(c.flags&128)!==0,T=g.rendering,T===null)if(S)Hd(g,!1);else{if(rn!==0||u!==null&&(u.flags&128)!==0)for(u=c.child;u!==null;){if(T=Mg(u),T!==null){for(c.flags|=128,Hd(g,!1),u=T.updateQueue,c.updateQueue=u,Yg(c,u),c.subtreeFlags=0,u=p,p=c.child;p!==null;)hI(p,u),p=p.sibling;return te(fn,fn.current&1|2),yt&&ni(c,g.treeForkCount),c.child}u=u.sibling}g.tail!==null&&Vt()>ty&&(c.flags|=128,S=!0,Hd(g,!1),c.lanes=4194304)}else{if(!S)if(u=Mg(T),u!==null){if(c.flags|=128,S=!0,u=u.updateQueue,c.updateQueue=u,Yg(c,u),Hd(g,!0),g.tail===null&&g.tailMode==="hidden"&&!T.alternate&&!yt)return jt(c),null}else 2*Vt()-g.renderingStartTime>ty&&p!==536870912&&(c.flags|=128,S=!0,Hd(g,!1),c.lanes=4194304);g.isBackwards?(T.sibling=c.child,c.child=T):(u=g.last,u!==null?u.sibling=T:c.child=T,g.last=T)}return g.tail!==null?(u=g.tail,g.rendering=u,g.tail=u.sibling,g.renderingStartTime=Vt(),u.sibling=null,p=fn.current,te(fn,S?p&1|2:p&1),yt&&ni(c,g.treeForkCount),u):(jt(c),null);case 22:case 23:return lr(c),Rv(),g=c.memoizedState!==null,u!==null?u.memoizedState!==null!==g&&(c.flags|=8192):g&&(c.flags|=8192),g?(p&536870912)!==0&&(c.flags&128)===0&&(jt(c),c.subtreeFlags&6&&(c.flags|=8192)):jt(c),p=c.updateQueue,p!==null&&Yg(c,p.retryQueue),p=null,u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(p=u.memoizedState.cachePool.pool),g=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(g=c.memoizedState.cachePool.pool),g!==p&&(c.flags|=2048),u!==null&&j(ll),null;case 24:return p=null,u!==null&&(p=u.memoizedState.cache),c.memoizedState.cache!==p&&(c.flags|=2048),ri(wn),jt(c),null;case 25:return null;case 30:return null}throw Error(s(156,c.tag))}function _W(u,c){switch(yv(c),c.tag){case 1:return u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 3:return ri(wn),$e(),u=c.flags,(u&65536)!==0&&(u&128)===0?(c.flags=u&-65537|128,c):null;case 26:case 27:case 5:return Se(c),null;case 31:if(c.memoizedState!==null){if(lr(c),c.alternate===null)throw Error(s(340));al()}return u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 13:if(lr(c),u=c.memoizedState,u!==null&&u.dehydrated!==null){if(c.alternate===null)throw Error(s(340));al()}return u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 19:return j(fn),null;case 4:return $e(),null;case 10:return ri(c.type),null;case 22:case 23:return lr(c),Rv(),u!==null&&j(ll),u=c.flags,u&65536?(c.flags=u&-65537|128,c):null;case 24:return ri(wn),null;case 25:return null;default:return null}}function z_(u,c){switch(yv(c),c.tag){case 3:ri(wn),$e();break;case 26:case 27:case 5:Se(c);break;case 4:$e();break;case 31:c.memoizedState!==null&&lr(c);break;case 13:lr(c);break;case 19:j(fn);break;case 10:ri(c.type);break;case 22:case 23:lr(c),Rv(),u!==null&&j(ll);break;case 24:ri(wn)}}function qd(u,c){try{var p=c.updateQueue,g=p!==null?p.lastEffect:null;if(g!==null){var S=g.next;p=S;do{if((p.tag&u)===u){g=void 0;var T=p.create,I=p.inst;g=T(),I.destroy=g}p=p.next}while(p!==S)}}catch(z){Et(c,c.return,z)}}function Qi(u,c,p){try{var g=c.updateQueue,S=g!==null?g.lastEffect:null;if(S!==null){var T=S.next;g=T;do{if((g.tag&u)===u){var I=g.inst,z=I.destroy;if(z!==void 0){I.destroy=void 0,S=c;var H=p,ue=z;try{ue()}catch(ge){Et(S,H,ge)}}}g=g.next}while(g!==T)}}catch(ge){Et(c,c.return,ge)}}function P_(u){var c=u.updateQueue;if(c!==null){var p=u.stateNode;try{II(c,p)}catch(g){Et(u,u.return,g)}}}function B_(u,c,p){p.props=fl(u.type,u.memoizedProps),p.state=u.memoizedState;try{p.componentWillUnmount()}catch(g){Et(u,c,g)}}function Kd(u,c){try{var p=u.ref;if(p!==null){switch(u.tag){case 26:case 27:case 5:var g=u.stateNode;break;case 30:g=u.stateNode;break;default:g=u.stateNode}typeof p=="function"?u.refCleanup=p(g):p.current=g}}catch(S){Et(u,c,S)}}function _a(u,c){var p=u.ref,g=u.refCleanup;if(p!==null)if(typeof g=="function")try{g()}catch(S){Et(u,c,S)}finally{u.refCleanup=null,u=u.alternate,u!=null&&(u.refCleanup=null)}else if(typeof p=="function")try{p(null)}catch(S){Et(u,c,S)}else p.current=null}function V_(u){var c=u.type,p=u.memoizedProps,g=u.stateNode;try{e:switch(c){case"button":case"input":case"select":case"textarea":p.autoFocus&&g.focus();break e;case"img":p.src?g.src=p.src:p.srcSet&&(g.srcset=p.srcSet)}}catch(S){Et(u,u.return,S)}}function c1(u,c,p){try{var g=u.stateNode;ZW(g,u.type,p,c),g[Ls]=c}catch(S){Et(u,u.return,S)}}function U_(u){return u.tag===5||u.tag===3||u.tag===26||u.tag===27&&io(u.type)||u.tag===4}function h1(u){e:for(;;){for(;u.sibling===null;){if(u.return===null||U_(u.return))return null;u=u.return}for(u.sibling.return=u.return,u=u.sibling;u.tag!==5&&u.tag!==6&&u.tag!==18;){if(u.tag===27&&io(u.type)||u.flags&2||u.child===null||u.tag===4)continue e;u.child.return=u,u=u.child}if(!(u.flags&2))return u.stateNode}}function d1(u,c,p){var g=u.tag;if(g===5||g===6)u=u.stateNode,c?(p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p).insertBefore(u,c):(c=p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p,c.appendChild(u),p=p._reactRootContainer,p!=null||c.onclick!==null||(c.onclick=Qa));else if(g!==4&&(g===27&&io(u.type)&&(p=u.stateNode,c=null),u=u.child,u!==null))for(d1(u,c,p),u=u.sibling;u!==null;)d1(u,c,p),u=u.sibling}function Jg(u,c,p){var g=u.tag;if(g===5||g===6)u=u.stateNode,c?p.insertBefore(u,c):p.appendChild(u);else if(g!==4&&(g===27&&io(u.type)&&(p=u.stateNode),u=u.child,u!==null))for(Jg(u,c,p),u=u.sibling;u!==null;)Jg(u,c,p),u=u.sibling}function j_(u){var c=u.stateNode,p=u.memoizedProps;try{for(var g=u.type,S=c.attributes;S.length;)c.removeAttributeNode(S[0]);is(c,g,p),c[ns]=u,c[Ls]=p}catch(T){Et(u,u.return,T)}}var ui=!1,Tn=!1,f1=!1,W_=typeof WeakSet=="function"?WeakSet:Set,Wn=null;function AW(u,c){if(u=u.containerInfo,O1=by,u=nI(u),iv(u)){if("selectionStart"in u)var p={start:u.selectionStart,end:u.selectionEnd};else e:{p=(p=u.ownerDocument)&&p.defaultView||window;var g=p.getSelection&&p.getSelection();if(g&&g.rangeCount!==0){p=g.anchorNode;var S=g.anchorOffset,T=g.focusNode;g=g.focusOffset;try{p.nodeType,T.nodeType}catch{p=null;break e}var I=0,z=-1,H=-1,ue=0,ge=0,be=u,ce=null;t:for(;;){for(var de;be!==p||S!==0&&be.nodeType!==3||(z=I+S),be!==T||g!==0&&be.nodeType!==3||(H=I+g),be.nodeType===3&&(I+=be.nodeValue.length),(de=be.firstChild)!==null;)ce=be,be=de;for(;;){if(be===u)break t;if(ce===p&&++ue===S&&(z=I),ce===T&&++ge===g&&(H=I),(de=be.nextSibling)!==null)break;be=ce,ce=be.parentNode}be=de}p=z===-1||H===-1?null:{start:z,end:H}}else p=null}p=p||{start:0,end:0}}else p=null;for(F1={focusedElem:u,selectionRange:p},by=!1,Wn=c;Wn!==null;)if(c=Wn,u=c.child,(c.subtreeFlags&1028)!==0&&u!==null)u.return=c,Wn=u;else for(;Wn!==null;){switch(c=Wn,T=c.alternate,u=c.flags,c.tag){case 0:if((u&4)!==0&&(u=c.updateQueue,u=u!==null?u.events:null,u!==null))for(p=0;p<u.length;p++)S=u[p],S.ref.impl=S.nextImpl;break;case 11:case 15:break;case 1:if((u&1024)!==0&&T!==null){u=void 0,p=c,S=T.memoizedProps,T=T.memoizedState,g=p.stateNode;try{var De=fl(p.type,S);u=g.getSnapshotBeforeUpdate(De,T),g.__reactInternalSnapshotBeforeUpdate=u}catch(We){Et(p,p.return,We)}}break;case 3:if((u&1024)!==0){if(u=c.stateNode.containerInfo,p=u.nodeType,p===9)z1(u);else if(p===1)switch(u.nodeName){case"HEAD":case"HTML":case"BODY":z1(u);break;default:u.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((u&1024)!==0)throw Error(s(163))}if(u=c.sibling,u!==null){u.return=c.return,Wn=u;break}Wn=c.return}}function G_(u,c,p){var g=p.flags;switch(p.tag){case 0:case 11:case 15:hi(u,p),g&4&&qd(5,p);break;case 1:if(hi(u,p),g&4)if(u=p.stateNode,c===null)try{u.componentDidMount()}catch(I){Et(p,p.return,I)}else{var S=fl(p.type,c.memoizedProps);c=c.memoizedState;try{u.componentDidUpdate(S,c,u.__reactInternalSnapshotBeforeUpdate)}catch(I){Et(p,p.return,I)}}g&64&&P_(p),g&512&&Kd(p,p.return);break;case 3:if(hi(u,p),g&64&&(u=p.updateQueue,u!==null)){if(c=null,p.child!==null)switch(p.child.tag){case 27:case 5:c=p.child.stateNode;break;case 1:c=p.child.stateNode}try{II(u,c)}catch(I){Et(p,p.return,I)}}break;case 27:c===null&&g&4&&j_(p);case 26:case 5:hi(u,p),c===null&&g&4&&V_(p),g&512&&Kd(p,p.return);break;case 12:hi(u,p);break;case 31:hi(u,p),g&4&&K_(u,p);break;case 13:hi(u,p),g&4&&X_(u,p),g&64&&(u=p.memoizedState,u!==null&&(u=u.dehydrated,u!==null&&(p=BW.bind(null,p),iG(u,p))));break;case 22:if(g=p.memoizedState!==null||ui,!g){c=c!==null&&c.memoizedState!==null||Tn,S=ui;var T=Tn;ui=g,(Tn=c)&&!T?di(u,p,(p.subtreeFlags&8772)!==0):hi(u,p),ui=S,Tn=T}break;case 30:break;default:hi(u,p)}}function H_(u){var c=u.alternate;c!==null&&(u.alternate=null,H_(c)),u.child=null,u.deletions=null,u.sibling=null,u.tag===5&&(c=u.stateNode,c!==null&&jw(c)),u.stateNode=null,u.return=null,u.dependencies=null,u.memoizedProps=null,u.memoizedState=null,u.pendingProps=null,u.stateNode=null,u.updateQueue=null}var Ht=null,zs=!1;function ci(u,c,p){for(p=p.child;p!==null;)q_(u,c,p),p=p.sibling}function q_(u,c,p){if(Cs&&typeof Cs.onCommitFiberUnmount=="function")try{Cs.onCommitFiberUnmount(ka,p)}catch{}switch(p.tag){case 26:Tn||_a(p,c),ci(u,c,p),p.memoizedState?p.memoizedState.count--:p.stateNode&&(p=p.stateNode,p.parentNode.removeChild(p));break;case 27:Tn||_a(p,c);var g=Ht,S=zs;io(p.type)&&(Ht=p.stateNode,zs=!1),ci(u,c,p),sf(p.stateNode),Ht=g,zs=S;break;case 5:Tn||_a(p,c);case 6:if(g=Ht,S=zs,Ht=null,ci(u,c,p),Ht=g,zs=S,Ht!==null)if(zs)try{(Ht.nodeType===9?Ht.body:Ht.nodeName==="HTML"?Ht.ownerDocument.body:Ht).removeChild(p.stateNode)}catch(T){Et(p,c,T)}else try{Ht.removeChild(p.stateNode)}catch(T){Et(p,c,T)}break;case 18:Ht!==null&&(zs?(u=Ht,PA(u.nodeType===9?u.body:u.nodeName==="HTML"?u.ownerDocument.body:u,p.stateNode),uc(u)):PA(Ht,p.stateNode));break;case 4:g=Ht,S=zs,Ht=p.stateNode.containerInfo,zs=!0,ci(u,c,p),Ht=g,zs=S;break;case 0:case 11:case 14:case 15:Qi(2,p,c),Tn||Qi(4,p,c),ci(u,c,p);break;case 1:Tn||(_a(p,c),g=p.stateNode,typeof g.componentWillUnmount=="function"&&B_(p,c,g)),ci(u,c,p);break;case 21:ci(u,c,p);break;case 22:Tn=(g=Tn)||p.memoizedState!==null,ci(u,c,p),Tn=g;break;default:ci(u,c,p)}}function K_(u,c){if(c.memoizedState===null&&(u=c.alternate,u!==null&&(u=u.memoizedState,u!==null))){u=u.dehydrated;try{uc(u)}catch(p){Et(c,c.return,p)}}}function X_(u,c){if(c.memoizedState===null&&(u=c.alternate,u!==null&&(u=u.memoizedState,u!==null&&(u=u.dehydrated,u!==null))))try{uc(u)}catch(p){Et(c,c.return,p)}}function RW(u){switch(u.tag){case 31:case 13:case 19:var c=u.stateNode;return c===null&&(c=u.stateNode=new W_),c;case 22:return u=u.stateNode,c=u._retryCache,c===null&&(c=u._retryCache=new W_),c;default:throw Error(s(435,u.tag))}}function Zg(u,c){var p=RW(u);c.forEach(function(g){if(!p.has(g)){p.add(g);var S=VW.bind(null,u,g);g.then(S,S)}})}function Ps(u,c){var p=c.deletions;if(p!==null)for(var g=0;g<p.length;g++){var S=p[g],T=u,I=c,z=I;e:for(;z!==null;){switch(z.tag){case 27:if(io(z.type)){Ht=z.stateNode,zs=!1;break e}break;case 5:Ht=z.stateNode,zs=!1;break e;case 3:case 4:Ht=z.stateNode.containerInfo,zs=!0;break e}z=z.return}if(Ht===null)throw Error(s(160));q_(T,I,S),Ht=null,zs=!1,T=S.alternate,T!==null&&(T.return=null),S.return=null}if(c.subtreeFlags&13886)for(c=c.child;c!==null;)Y_(c,u),c=c.sibling}var ta=null;function Y_(u,c){var p=u.alternate,g=u.flags;switch(u.tag){case 0:case 11:case 14:case 15:Ps(c,u),Bs(u),g&4&&(Qi(3,u,u.return),qd(3,u),Qi(5,u,u.return));break;case 1:Ps(c,u),Bs(u),g&512&&(Tn||p===null||_a(p,p.return)),g&64&&ui&&(u=u.updateQueue,u!==null&&(g=u.callbacks,g!==null&&(p=u.shared.hiddenCallbacks,u.shared.hiddenCallbacks=p===null?g:p.concat(g))));break;case 26:var S=ta;if(Ps(c,u),Bs(u),g&512&&(Tn||p===null||_a(p,p.return)),g&4){var T=p!==null?p.memoizedState:null;if(g=u.memoizedState,p===null)if(g===null)if(u.stateNode===null){e:{g=u.type,p=u.memoizedProps,S=S.ownerDocument||S;t:switch(g){case"title":T=S.getElementsByTagName("title")[0],(!T||T[vd]||T[ns]||T.namespaceURI==="http://www.w3.org/2000/svg"||T.hasAttribute("itemprop"))&&(T=S.createElement(g),S.head.insertBefore(T,S.querySelector("head > title"))),is(T,g,p),T[ns]=u,jn(T),g=T;break e;case"link":var I=YA("link","href",S).get(g+(p.href||""));if(I){for(var z=0;z<I.length;z++)if(T=I[z],T.getAttribute("href")===(p.href==null||p.href===""?null:p.href)&&T.getAttribute("rel")===(p.rel==null?null:p.rel)&&T.getAttribute("title")===(p.title==null?null:p.title)&&T.getAttribute("crossorigin")===(p.crossOrigin==null?null:p.crossOrigin)){I.splice(z,1);break t}}T=S.createElement(g),is(T,g,p),S.head.appendChild(T);break;case"meta":if(I=YA("meta","content",S).get(g+(p.content||""))){for(z=0;z<I.length;z++)if(T=I[z],T.getAttribute("content")===(p.content==null?null:""+p.content)&&T.getAttribute("name")===(p.name==null?null:p.name)&&T.getAttribute("property")===(p.property==null?null:p.property)&&T.getAttribute("http-equiv")===(p.httpEquiv==null?null:p.httpEquiv)&&T.getAttribute("charset")===(p.charSet==null?null:p.charSet)){I.splice(z,1);break t}}T=S.createElement(g),is(T,g,p),S.head.appendChild(T);break;default:throw Error(s(468,g))}T[ns]=u,jn(T),g=T}u.stateNode=g}else JA(S,u.type,u.stateNode);else u.stateNode=XA(S,g,u.memoizedProps);else T!==g?(T===null?p.stateNode!==null&&(p=p.stateNode,p.parentNode.removeChild(p)):T.count--,g===null?JA(S,u.type,u.stateNode):XA(S,g,u.memoizedProps)):g===null&&u.stateNode!==null&&c1(u,u.memoizedProps,p.memoizedProps)}break;case 27:Ps(c,u),Bs(u),g&512&&(Tn||p===null||_a(p,p.return)),p!==null&&g&4&&c1(u,u.memoizedProps,p.memoizedProps);break;case 5:if(Ps(c,u),Bs(u),g&512&&(Tn||p===null||_a(p,p.return)),u.flags&32){S=u.stateNode;try{Ru(S,"")}catch(De){Et(u,u.return,De)}}g&4&&u.stateNode!=null&&(S=u.memoizedProps,c1(u,S,p!==null?p.memoizedProps:S)),g&1024&&(f1=!0);break;case 6:if(Ps(c,u),Bs(u),g&4){if(u.stateNode===null)throw Error(s(162));g=u.memoizedProps,p=u.stateNode;try{p.nodeValue=g}catch(De){Et(u,u.return,De)}}break;case 3:if(py=null,S=ta,ta=dy(c.containerInfo),Ps(c,u),ta=S,Bs(u),g&4&&p!==null&&p.memoizedState.isDehydrated)try{uc(c.containerInfo)}catch(De){Et(u,u.return,De)}f1&&(f1=!1,J_(u));break;case 4:g=ta,ta=dy(u.stateNode.containerInfo),Ps(c,u),Bs(u),ta=g;break;case 12:Ps(c,u),Bs(u);break;case 31:Ps(c,u),Bs(u),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,Zg(u,g)));break;case 13:Ps(c,u),Bs(u),u.child.flags&8192&&u.memoizedState!==null!=(p!==null&&p.memoizedState!==null)&&(ey=Vt()),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,Zg(u,g)));break;case 22:S=u.memoizedState!==null;var H=p!==null&&p.memoizedState!==null,ue=ui,ge=Tn;if(ui=ue||S,Tn=ge||H,Ps(c,u),Tn=ge,ui=ue,Bs(u),g&8192)e:for(c=u.stateNode,c._visibility=S?c._visibility&-2:c._visibility|1,S&&(p===null||H||ui||Tn||pl(u)),p=null,c=u;;){if(c.tag===5||c.tag===26){if(p===null){H=p=c;try{if(T=H.stateNode,S)I=T.style,typeof I.setProperty=="function"?I.setProperty("display","none","important"):I.display="none";else{z=H.stateNode;var be=H.memoizedProps.style,ce=be!=null&&be.hasOwnProperty("display")?be.display:null;z.style.display=ce==null||typeof ce=="boolean"?"":(""+ce).trim()}}catch(De){Et(H,H.return,De)}}}else if(c.tag===6){if(p===null){H=c;try{H.stateNode.nodeValue=S?"":H.memoizedProps}catch(De){Et(H,H.return,De)}}}else if(c.tag===18){if(p===null){H=c;try{var de=H.stateNode;S?BA(de,!0):BA(H.stateNode,!1)}catch(De){Et(H,H.return,De)}}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===u)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===u)break e;for(;c.sibling===null;){if(c.return===null||c.return===u)break e;p===c&&(p=null),c=c.return}p===c&&(p=null),c.sibling.return=c.return,c=c.sibling}g&4&&(g=u.updateQueue,g!==null&&(p=g.retryQueue,p!==null&&(g.retryQueue=null,Zg(u,p))));break;case 19:Ps(c,u),Bs(u),g&4&&(g=u.updateQueue,g!==null&&(u.updateQueue=null,Zg(u,g)));break;case 30:break;case 21:break;default:Ps(c,u),Bs(u)}}function Bs(u){var c=u.flags;if(c&2){try{for(var p,g=u.return;g!==null;){if(U_(g)){p=g;break}g=g.return}if(p==null)throw Error(s(160));switch(p.tag){case 27:var S=p.stateNode,T=h1(u);Jg(u,T,S);break;case 5:var I=p.stateNode;p.flags&32&&(Ru(I,""),p.flags&=-33);var z=h1(u);Jg(u,z,I);break;case 3:case 4:var H=p.stateNode.containerInfo,ue=h1(u);d1(u,ue,H);break;default:throw Error(s(161))}}catch(ge){Et(u,u.return,ge)}u.flags&=-3}c&4096&&(u.flags&=-4097)}function J_(u){if(u.subtreeFlags&1024)for(u=u.child;u!==null;){var c=u;J_(c),c.tag===5&&c.flags&1024&&c.stateNode.reset(),u=u.sibling}}function hi(u,c){if(c.subtreeFlags&8772)for(c=c.child;c!==null;)G_(u,c.alternate,c),c=c.sibling}function pl(u){for(u=u.child;u!==null;){var c=u;switch(c.tag){case 0:case 11:case 14:case 15:Qi(4,c,c.return),pl(c);break;case 1:_a(c,c.return);var p=c.stateNode;typeof p.componentWillUnmount=="function"&&B_(c,c.return,p),pl(c);break;case 27:sf(c.stateNode);case 26:case 5:_a(c,c.return),pl(c);break;case 22:c.memoizedState===null&&pl(c);break;case 30:pl(c);break;default:pl(c)}u=u.sibling}}function di(u,c,p){for(p=p&&(c.subtreeFlags&8772)!==0,c=c.child;c!==null;){var g=c.alternate,S=u,T=c,I=T.flags;switch(T.tag){case 0:case 11:case 15:di(S,T,p),qd(4,T);break;case 1:if(di(S,T,p),g=T,S=g.stateNode,typeof S.componentDidMount=="function")try{S.componentDidMount()}catch(ue){Et(g,g.return,ue)}if(g=T,S=g.updateQueue,S!==null){var z=g.stateNode;try{var H=S.shared.hiddenCallbacks;if(H!==null)for(S.shared.hiddenCallbacks=null,S=0;S<H.length;S++)$I(H[S],z)}catch(ue){Et(g,g.return,ue)}}p&&I&64&&P_(T),Kd(T,T.return);break;case 27:j_(T);case 26:case 5:di(S,T,p),p&&g===null&&I&4&&V_(T),Kd(T,T.return);break;case 12:di(S,T,p);break;case 31:di(S,T,p),p&&I&4&&K_(S,T);break;case 13:di(S,T,p),p&&I&4&&X_(S,T);break;case 22:T.memoizedState===null&&di(S,T,p),Kd(T,T.return);break;case 30:break;default:di(S,T,p)}c=c.sibling}}function p1(u,c){var p=null;u!==null&&u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(p=u.memoizedState.cachePool.pool),u=null,c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(u=c.memoizedState.cachePool.pool),u!==p&&(u!=null&&u.refCount++,p!=null&&Od(p))}function m1(u,c){u=null,c.alternate!==null&&(u=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==u&&(c.refCount++,u!=null&&Od(u))}function na(u,c,p,g){if(c.subtreeFlags&10256)for(c=c.child;c!==null;)Z_(u,c,p,g),c=c.sibling}function Z_(u,c,p,g){var S=c.flags;switch(c.tag){case 0:case 11:case 15:na(u,c,p,g),S&2048&&qd(9,c);break;case 1:na(u,c,p,g);break;case 3:na(u,c,p,g),S&2048&&(u=null,c.alternate!==null&&(u=c.alternate.memoizedState.cache),c=c.memoizedState.cache,c!==u&&(c.refCount++,u!=null&&Od(u)));break;case 12:if(S&2048){na(u,c,p,g),u=c.stateNode;try{var T=c.memoizedProps,I=T.id,z=T.onPostCommit;typeof z=="function"&&z(I,c.alternate===null?"mount":"update",u.passiveEffectDuration,-0)}catch(H){Et(c,c.return,H)}}else na(u,c,p,g);break;case 31:na(u,c,p,g);break;case 13:na(u,c,p,g);break;case 23:break;case 22:T=c.stateNode,I=c.alternate,c.memoizedState!==null?T._visibility&2?na(u,c,p,g):Xd(u,c):T._visibility&2?na(u,c,p,g):(T._visibility|=2,Zu(u,c,p,g,(c.subtreeFlags&10256)!==0||!1)),S&2048&&p1(I,c);break;case 24:na(u,c,p,g),S&2048&&m1(c.alternate,c);break;default:na(u,c,p,g)}}function Zu(u,c,p,g,S){for(S=S&&((c.subtreeFlags&10256)!==0||!1),c=c.child;c!==null;){var T=u,I=c,z=p,H=g,ue=I.flags;switch(I.tag){case 0:case 11:case 15:Zu(T,I,z,H,S),qd(8,I);break;case 23:break;case 22:var ge=I.stateNode;I.memoizedState!==null?ge._visibility&2?Zu(T,I,z,H,S):Xd(T,I):(ge._visibility|=2,Zu(T,I,z,H,S)),S&&ue&2048&&p1(I.alternate,I);break;case 24:Zu(T,I,z,H,S),S&&ue&2048&&m1(I.alternate,I);break;default:Zu(T,I,z,H,S)}c=c.sibling}}function Xd(u,c){if(c.subtreeFlags&10256)for(c=c.child;c!==null;){var p=u,g=c,S=g.flags;switch(g.tag){case 22:Xd(p,g),S&2048&&p1(g.alternate,g);break;case 24:Xd(p,g),S&2048&&m1(g.alternate,g);break;default:Xd(p,g)}c=c.sibling}}var Yd=8192;function Qu(u,c,p){if(u.subtreeFlags&Yd)for(u=u.child;u!==null;)Q_(u,c,p),u=u.sibling}function Q_(u,c,p){switch(u.tag){case 26:Qu(u,c,p),u.flags&Yd&&u.memoizedState!==null&&bG(p,ta,u.memoizedState,u.memoizedProps);break;case 5:Qu(u,c,p);break;case 3:case 4:var g=ta;ta=dy(u.stateNode.containerInfo),Qu(u,c,p),ta=g;break;case 22:u.memoizedState===null&&(g=u.alternate,g!==null&&g.memoizedState!==null?(g=Yd,Yd=16777216,Qu(u,c,p),Yd=g):Qu(u,c,p));break;default:Qu(u,c,p)}}function eA(u){var c=u.alternate;if(c!==null&&(u=c.child,u!==null)){c.child=null;do c=u.sibling,u.sibling=null,u=c;while(u!==null)}}function Jd(u){var c=u.deletions;if((u.flags&16)!==0){if(c!==null)for(var p=0;p<c.length;p++){var g=c[p];Wn=g,nA(g,u)}eA(u)}if(u.subtreeFlags&10256)for(u=u.child;u!==null;)tA(u),u=u.sibling}function tA(u){switch(u.tag){case 0:case 11:case 15:Jd(u),u.flags&2048&&Qi(9,u,u.return);break;case 3:Jd(u);break;case 12:Jd(u);break;case 22:var c=u.stateNode;u.memoizedState!==null&&c._visibility&2&&(u.return===null||u.return.tag!==13)?(c._visibility&=-3,Qg(u)):Jd(u);break;default:Jd(u)}}function Qg(u){var c=u.deletions;if((u.flags&16)!==0){if(c!==null)for(var p=0;p<c.length;p++){var g=c[p];Wn=g,nA(g,u)}eA(u)}for(u=u.child;u!==null;){switch(c=u,c.tag){case 0:case 11:case 15:Qi(8,c,c.return),Qg(c);break;case 22:p=c.stateNode,p._visibility&2&&(p._visibility&=-3,Qg(c));break;default:Qg(c)}u=u.sibling}}function nA(u,c){for(;Wn!==null;){var p=Wn;switch(p.tag){case 0:case 11:case 15:Qi(8,p,c);break;case 23:case 22:if(p.memoizedState!==null&&p.memoizedState.cachePool!==null){var g=p.memoizedState.cachePool.pool;g!=null&&g.refCount++}break;case 24:Od(p.memoizedState.cache)}if(g=p.child,g!==null)g.return=p,Wn=g;else e:for(p=u;Wn!==null;){g=Wn;var S=g.sibling,T=g.return;if(H_(g),g===p){Wn=null;break e}if(S!==null){S.return=T,Wn=S;break e}Wn=T}}}var DW={getCacheForType:function(u){var c=rs(wn),p=c.data.get(u);return p===void 0&&(p=u(),c.data.set(u,p)),p},cacheSignal:function(){return rs(wn).controller.signal}},OW=typeof WeakMap=="function"?WeakMap:Map,Tt=0,Ft=null,ct=null,pt=0,kt=0,ur=null,eo=!1,ec=!1,g1=!1,fi=0,rn=0,to=0,ml=0,y1=0,cr=0,tc=0,Zd=null,Vs=null,b1=!1,ey=0,sA=0,ty=1/0,ny=null,no=null,Rn=0,so=null,nc=null,pi=0,x1=0,w1=null,rA=null,Qd=0,v1=null;function hr(){return(Tt&2)!==0&&pt!==0?pt&-pt:B.T!==null?E1():w$()}function aA(){if(cr===0)if((pt&536870912)===0||yt){var u=cg;cg<<=1,(cg&3932160)===0&&(cg=262144),cr=u}else cr=536870912;return u=or.current,u!==null&&(u.flags|=32),cr}function Us(u,c,p){(u===Ft&&(kt===2||kt===9)||u.cancelPendingCommit!==null)&&(sc(u,0),ro(u,pt,cr,!1)),wd(u,p),((Tt&2)===0||u!==Ft)&&(u===Ft&&((Tt&2)===0&&(ml|=p),rn===4&&ro(u,pt,cr,!1)),Aa(u))}function iA(u,c,p){if((Tt&6)!==0)throw Error(s(327));var g=!p&&(c&127)===0&&(c&u.expiredLanes)===0||xd(u,c),S=g?MW(u,c):T1(u,c,!0),T=g;do{if(S===0){ec&&!g&&ro(u,c,0,!1);break}else{if(p=u.current.alternate,T&&!FW(p)){S=T1(u,c,!1),T=!1;continue}if(S===2){if(T=c,u.errorRecoveryDisabledLanes&T)var I=0;else I=u.pendingLanes&-536870913,I=I!==0?I:I&536870912?536870912:0;if(I!==0){c=I;e:{var z=u;S=Zd;var H=z.current.memoizedState.isDehydrated;if(H&&(sc(z,I).flags|=256),I=T1(z,I,!1),I!==2){if(g1&&!H){z.errorRecoveryDisabledLanes|=T,ml|=T,S=4;break e}T=Vs,Vs=S,T!==null&&(Vs===null?Vs=T:Vs.push.apply(Vs,T))}S=I}if(T=!1,S!==2)continue}}if(S===1){sc(u,0),ro(u,c,0,!0);break}e:{switch(g=u,T=S,T){case 0:case 1:throw Error(s(345));case 4:if((c&4194048)!==c)break;case 6:ro(g,c,cr,!eo);break e;case 2:Vs=null;break;case 3:case 5:break;default:throw Error(s(329))}if((c&62914560)===c&&(S=ey+300-Vt(),10<S)){if(ro(g,c,cr,!eo),dg(g,0,!0)!==0)break e;pi=c,g.timeoutHandle=MA(oA.bind(null,g,p,Vs,ny,b1,c,cr,ml,tc,eo,T,"Throttled",-0,0),S);break e}oA(g,p,Vs,ny,b1,c,cr,ml,tc,eo,T,null,-0,0)}}break}while(!0);Aa(u)}function oA(u,c,p,g,S,T,I,z,H,ue,ge,be,ce,de){if(u.timeoutHandle=-1,be=c.subtreeFlags,be&8192||(be&16785408)===16785408){be={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Qa},Q_(c,T,be);var De=(T&62914560)===T?ey-Vt():(T&4194048)===T?sA-Vt():0;if(De=xG(be,De),De!==null){pi=T,u.cancelPendingCommit=De(mA.bind(null,u,c,T,p,g,S,I,z,H,ge,be,null,ce,de)),ro(u,T,I,!ue);return}}mA(u,c,T,p,g,S,I,z,H)}function FW(u){for(var c=u;;){var p=c.tag;if((p===0||p===11||p===15)&&c.flags&16384&&(p=c.updateQueue,p!==null&&(p=p.stores,p!==null)))for(var g=0;g<p.length;g++){var S=p[g],T=S.getSnapshot;S=S.value;try{if(!ar(T(),S))return!1}catch{return!1}}if(p=c.child,c.subtreeFlags&16384&&p!==null)p.return=c,c=p;else{if(c===u)break;for(;c.sibling===null;){if(c.return===null||c.return===u)return!0;c=c.return}c.sibling.return=c.return,c=c.sibling}}return!0}function ro(u,c,p,g){c&=~y1,c&=~ml,u.suspendedLanes|=c,u.pingedLanes&=~c,g&&(u.warmLanes|=c),g=u.expirationTimes;for(var S=c;0<S;){var T=31-rr(S),I=1<<T;g[T]=-1,S&=~I}p!==0&&y$(u,p,c)}function sy(){return(Tt&6)===0?(ef(0),!1):!0}function S1(){if(ct!==null){if(kt===0)var u=ct.return;else u=ct,si=il=null,zv(u),qu=null,Ld=0,u=ct;for(;u!==null;)z_(u.alternate,u),u=u.return;ct=null}}function sc(u,c){var p=u.timeoutHandle;p!==-1&&(u.timeoutHandle=-1,tG(p)),p=u.cancelPendingCommit,p!==null&&(u.cancelPendingCommit=null,p()),pi=0,S1(),Ft=u,ct=p=ti(u.current,null),pt=c,kt=0,ur=null,eo=!1,ec=xd(u,c),g1=!1,tc=cr=y1=ml=to=rn=0,Vs=Zd=null,b1=!1,(c&8)!==0&&(c|=c&32);var g=u.entangledLanes;if(g!==0)for(u=u.entanglements,g&=c;0<g;){var S=31-rr(g),T=1<<S;c|=u[S],g&=~T}return fi=c,Cg(),p}function lA(u,c){nt=null,B.H=Wd,c===Hu||c===Rg?(c=CI(),kt=3):c===kv?(c=CI(),kt=4):kt=c===e1?8:c!==null&&typeof c=="object"&&typeof c.then=="function"?6:1,ur=c,ct===null&&(rn=1,Hg(u,_r(c,u.current)))}function uA(){var u=or.current;return u===null?!0:(pt&4194048)===pt?Or===null:(pt&62914560)===pt||(pt&536870912)!==0?u===Or:!1}function cA(){var u=B.H;return B.H=Wd,u===null?Wd:u}function hA(){var u=B.A;return B.A=DW,u}function ry(){rn=4,eo||(pt&4194048)!==pt&&or.current!==null||(ec=!0),(to&134217727)===0&&(ml&134217727)===0||Ft===null||ro(Ft,pt,cr,!1)}function T1(u,c,p){var g=Tt;Tt|=2;var S=cA(),T=hA();(Ft!==u||pt!==c)&&(ny=null,sc(u,c)),c=!1;var I=rn;e:do try{if(kt!==0&&ct!==null){var z=ct,H=ur;switch(kt){case 8:S1(),I=6;break e;case 3:case 2:case 9:case 6:or.current===null&&(c=!0);var ue=kt;if(kt=0,ur=null,rc(u,z,H,ue),p&&ec){I=0;break e}break;default:ue=kt,kt=0,ur=null,rc(u,z,H,ue)}}LW(),I=rn;break}catch(ge){lA(u,ge)}while(!0);return c&&u.shellSuspendCounter++,si=il=null,Tt=g,B.H=S,B.A=T,ct===null&&(Ft=null,pt=0,Cg()),I}function LW(){for(;ct!==null;)dA(ct)}function MW(u,c){var p=Tt;Tt|=2;var g=cA(),S=hA();Ft!==u||pt!==c?(ny=null,ty=Vt()+500,sc(u,c)):ec=xd(u,c);e:do try{if(kt!==0&&ct!==null){c=ct;var T=ur;t:switch(kt){case 1:kt=0,ur=null,rc(u,c,T,1);break;case 2:case 9:if(SI(T)){kt=0,ur=null,fA(c);break}c=function(){kt!==2&&kt!==9||Ft!==u||(kt=7),Aa(u)},T.then(c,c);break e;case 3:kt=7;break e;case 4:kt=5;break e;case 7:SI(T)?(kt=0,ur=null,fA(c)):(kt=0,ur=null,rc(u,c,T,7));break;case 5:var I=null;switch(ct.tag){case 26:I=ct.memoizedState;case 5:case 27:var z=ct;if(I?ZA(I):z.stateNode.complete){kt=0,ur=null;var H=z.sibling;if(H!==null)ct=H;else{var ue=z.return;ue!==null?(ct=ue,ay(ue)):ct=null}break t}}kt=0,ur=null,rc(u,c,T,5);break;case 6:kt=0,ur=null,rc(u,c,T,6);break;case 8:S1(),rn=6;break e;default:throw Error(s(462))}}zW();break}catch(ge){lA(u,ge)}while(!0);return si=il=null,B.H=g,B.A=S,Tt=p,ct!==null?0:(Ft=null,pt=0,Cg(),rn)}function zW(){for(;ct!==null&&!Ts();)dA(ct)}function dA(u){var c=L_(u.alternate,u,fi);u.memoizedProps=u.pendingProps,c===null?ay(u):ct=c}function fA(u){var c=u,p=c.alternate;switch(c.tag){case 15:case 0:c=__(p,c,c.pendingProps,c.type,void 0,pt);break;case 11:c=__(p,c,c.pendingProps,c.type.render,c.ref,pt);break;case 5:zv(c);default:z_(p,c),c=ct=hI(c,fi),c=L_(p,c,fi)}u.memoizedProps=u.pendingProps,c===null?ay(u):ct=c}function rc(u,c,p,g){si=il=null,zv(c),qu=null,Ld=0;var S=c.return;try{if(kW(u,S,c,p,pt)){rn=1,Hg(u,_r(p,u.current)),ct=null;return}}catch(T){if(S!==null)throw ct=S,T;rn=1,Hg(u,_r(p,u.current)),ct=null;return}c.flags&32768?(yt||g===1?u=!0:ec||(pt&536870912)!==0?u=!1:(eo=u=!0,(g===2||g===9||g===3||g===6)&&(g=or.current,g!==null&&g.tag===13&&(g.flags|=16384))),pA(c,u)):ay(c)}function ay(u){var c=u;do{if((c.flags&32768)!==0){pA(c,eo);return}u=c.return;var p=IW(c.alternate,c,fi);if(p!==null){ct=p;return}if(c=c.sibling,c!==null){ct=c;return}ct=c=u}while(c!==null);rn===0&&(rn=5)}function pA(u,c){do{var p=_W(u.alternate,u);if(p!==null){p.flags&=32767,ct=p;return}if(p=u.return,p!==null&&(p.flags|=32768,p.subtreeFlags=0,p.deletions=null),!c&&(u=u.sibling,u!==null)){ct=u;return}ct=u=p}while(u!==null);rn=6,ct=null}function mA(u,c,p,g,S,T,I,z,H){u.cancelPendingCommit=null;do iy();while(Rn!==0);if((Tt&6)!==0)throw Error(s(327));if(c!==null){if(c===u.current)throw Error(s(177));if(T=c.lanes|c.childLanes,T|=hv,yj(u,p,T,I,z,H),u===Ft&&(ct=Ft=null,pt=0),nc=c,so=u,pi=p,x1=T,w1=S,rA=g,(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?(u.callbackNode=null,u.callbackPriority=0,UW(sr,function(){return wA(),null})):(u.callbackNode=null,u.callbackPriority=0),g=(c.flags&13878)!==0,(c.subtreeFlags&13878)!==0||g){g=B.T,B.T=null,S=U.p,U.p=2,I=Tt,Tt|=4;try{AW(u,c,p)}finally{Tt=I,U.p=S,B.T=g}}Rn=1,gA(),yA(),bA()}}function gA(){if(Rn===1){Rn=0;var u=so,c=nc,p=(c.flags&13878)!==0;if((c.subtreeFlags&13878)!==0||p){p=B.T,B.T=null;var g=U.p;U.p=2;var S=Tt;Tt|=4;try{Y_(c,u);var T=F1,I=nI(u.containerInfo),z=T.focusedElem,H=T.selectionRange;if(I!==z&&z&&z.ownerDocument&&tI(z.ownerDocument.documentElement,z)){if(H!==null&&iv(z)){var ue=H.start,ge=H.end;if(ge===void 0&&(ge=ue),"selectionStart"in z)z.selectionStart=ue,z.selectionEnd=Math.min(ge,z.value.length);else{var be=z.ownerDocument||document,ce=be&&be.defaultView||window;if(ce.getSelection){var de=ce.getSelection(),De=z.textContent.length,We=Math.min(H.start,De),Dt=H.end===void 0?We:Math.min(H.end,De);!de.extend&&We>Dt&&(I=Dt,Dt=We,We=I);var ae=eI(z,We),ee=eI(z,Dt);if(ae&&ee&&(de.rangeCount!==1||de.anchorNode!==ae.node||de.anchorOffset!==ae.offset||de.focusNode!==ee.node||de.focusOffset!==ee.offset)){var le=be.createRange();le.setStart(ae.node,ae.offset),de.removeAllRanges(),We>Dt?(de.addRange(le),de.extend(ee.node,ee.offset)):(le.setEnd(ee.node,ee.offset),de.addRange(le))}}}}for(be=[],de=z;de=de.parentNode;)de.nodeType===1&&be.push({element:de,left:de.scrollLeft,top:de.scrollTop});for(typeof z.focus=="function"&&z.focus(),z=0;z<be.length;z++){var ye=be[z];ye.element.scrollLeft=ye.left,ye.element.scrollTop=ye.top}}by=!!O1,F1=O1=null}finally{Tt=S,U.p=g,B.T=p}}u.current=c,Rn=2}}function yA(){if(Rn===2){Rn=0;var u=so,c=nc,p=(c.flags&8772)!==0;if((c.subtreeFlags&8772)!==0||p){p=B.T,B.T=null;var g=U.p;U.p=2;var S=Tt;Tt|=4;try{G_(u,c.alternate,c)}finally{Tt=S,U.p=g,B.T=p}}Rn=3}}function bA(){if(Rn===4||Rn===3){Rn=0,Ja();var u=so,c=nc,p=pi,g=rA;(c.subtreeFlags&10256)!==0||(c.flags&10256)!==0?Rn=5:(Rn=0,nc=so=null,xA(u,u.pendingLanes));var S=u.pendingLanes;if(S===0&&(no=null),Vw(p),c=c.stateNode,Cs&&typeof Cs.onCommitFiberRoot=="function")try{Cs.onCommitFiberRoot(ka,c,void 0,(c.current.flags&128)===128)}catch{}if(g!==null){c=B.T,S=U.p,U.p=2,B.T=null;try{for(var T=u.onRecoverableError,I=0;I<g.length;I++){var z=g[I];T(z.value,{componentStack:z.stack})}}finally{B.T=c,U.p=S}}(pi&3)!==0&&iy(),Aa(u),S=u.pendingLanes,(p&261930)!==0&&(S&42)!==0?u===v1?Qd++:(Qd=0,v1=u):Qd=0,ef(0)}}function xA(u,c){(u.pooledCacheLanes&=c)===0&&(c=u.pooledCache,c!=null&&(u.pooledCache=null,Od(c)))}function iy(){return gA(),yA(),bA(),wA()}function wA(){if(Rn!==5)return!1;var u=so,c=x1;x1=0;var p=Vw(pi),g=B.T,S=U.p;try{U.p=32>p?32:p,B.T=null,p=w1,w1=null;var T=so,I=pi;if(Rn=0,nc=so=null,pi=0,(Tt&6)!==0)throw Error(s(331));var z=Tt;if(Tt|=4,tA(T.current),Z_(T,T.current,I,p),Tt=z,ef(0,!1),Cs&&typeof Cs.onPostCommitFiberRoot=="function")try{Cs.onPostCommitFiberRoot(ka,T)}catch{}return!0}finally{U.p=S,B.T=g,xA(u,c)}}function vA(u,c,p){c=_r(p,c),c=Qv(u.stateNode,c,2),u=Yi(u,c,2),u!==null&&(wd(u,2),Aa(u))}function Et(u,c,p){if(u.tag===3)vA(u,u,p);else for(;c!==null;){if(c.tag===3){vA(c,u,p);break}else if(c.tag===1){var g=c.stateNode;if(typeof c.type.getDerivedStateFromError=="function"||typeof g.componentDidCatch=="function"&&(no===null||!no.has(g))){u=_r(p,u),p=S_(2),g=Yi(c,p,2),g!==null&&(T_(p,g,c,u),wd(g,2),Aa(g));break}}c=c.return}}function C1(u,c,p){var g=u.pingCache;if(g===null){g=u.pingCache=new OW;var S=new Set;g.set(c,S)}else S=g.get(c),S===void 0&&(S=new Set,g.set(c,S));S.has(p)||(g1=!0,S.add(p),u=PW.bind(null,u,c,p),c.then(u,u))}function PW(u,c,p){var g=u.pingCache;g!==null&&g.delete(c),u.pingedLanes|=u.suspendedLanes&p,u.warmLanes&=~p,Ft===u&&(pt&p)===p&&(rn===4||rn===3&&(pt&62914560)===pt&&300>Vt()-ey?(Tt&2)===0&&sc(u,0):y1|=p,tc===pt&&(tc=0)),Aa(u)}function SA(u,c){c===0&&(c=g$()),u=sl(u,c),u!==null&&(wd(u,c),Aa(u))}function BW(u){var c=u.memoizedState,p=0;c!==null&&(p=c.retryLane),SA(u,p)}function VW(u,c){var p=0;switch(u.tag){case 31:case 13:var g=u.stateNode,S=u.memoizedState;S!==null&&(p=S.retryLane);break;case 19:g=u.stateNode;break;case 22:g=u.stateNode._retryCache;break;default:throw Error(s(314))}g!==null&&g.delete(c),SA(u,p)}function UW(u,c){return nn(u,c)}var oy=null,ac=null,N1=!1,ly=!1,k1=!1,ao=0;function Aa(u){u!==ac&&u.next===null&&(ac===null?oy=ac=u:ac=ac.next=u),ly=!0,N1||(N1=!0,WW())}function ef(u,c){if(!k1&&ly){k1=!0;do for(var p=!1,g=oy;g!==null;){if(u!==0){var S=g.pendingLanes;if(S===0)var T=0;else{var I=g.suspendedLanes,z=g.pingedLanes;T=(1<<31-rr(42|u)+1)-1,T&=S&~(I&~z),T=T&201326741?T&201326741|1:T?T|2:0}T!==0&&(p=!0,kA(g,T))}else T=pt,T=dg(g,g===Ft?T:0,g.cancelPendingCommit!==null||g.timeoutHandle!==-1),(T&3)===0||xd(g,T)||(p=!0,kA(g,T));g=g.next}while(p);k1=!1}}function jW(){TA()}function TA(){ly=N1=!1;var u=0;ao!==0&&eG()&&(u=ao);for(var c=Vt(),p=null,g=oy;g!==null;){var S=g.next,T=CA(g,c);T===0?(g.next=null,p===null?oy=S:p.next=S,S===null&&(ac=p)):(p=g,(u!==0||(T&3)!==0)&&(ly=!0)),g=S}Rn!==0&&Rn!==5||ef(u),ao!==0&&(ao=0)}function CA(u,c){for(var p=u.suspendedLanes,g=u.pingedLanes,S=u.expirationTimes,T=u.pendingLanes&-62914561;0<T;){var I=31-rr(T),z=1<<I,H=S[I];H===-1?((z&p)===0||(z&g)!==0)&&(S[I]=gj(z,c)):H<=c&&(u.expiredLanes|=z),T&=~z}if(c=Ft,p=pt,p=dg(u,u===c?p:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),g=u.callbackNode,p===0||u===c&&(kt===2||kt===9)||u.cancelPendingCommit!==null)return g!==null&&g!==null&&kr(g),u.callbackNode=null,u.callbackPriority=0;if((p&3)===0||xd(u,p)){if(c=p&-p,c===u.callbackPriority)return c;switch(g!==null&&kr(g),Vw(p)){case 2:case 8:p=Qr;break;case 32:p=sr;break;case 268435456:p=Nu;break;default:p=sr}return g=NA.bind(null,u),p=nn(p,g),u.callbackPriority=c,u.callbackNode=p,c}return g!==null&&g!==null&&kr(g),u.callbackPriority=2,u.callbackNode=null,2}function NA(u,c){if(Rn!==0&&Rn!==5)return u.callbackNode=null,u.callbackPriority=0,null;var p=u.callbackNode;if(iy()&&u.callbackNode!==p)return null;var g=pt;return g=dg(u,u===Ft?g:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),g===0?null:(iA(u,g,c),CA(u,Vt()),u.callbackNode!=null&&u.callbackNode===p?NA.bind(null,u):null)}function kA(u,c){if(iy())return null;iA(u,c,!0)}function WW(){nG(function(){(Tt&6)!==0?nn(Zr,jW):TA()})}function E1(){if(ao===0){var u=Wu;u===0&&(u=ug,ug<<=1,(ug&261888)===0&&(ug=256)),ao=u}return ao}function EA(u){return u==null||typeof u=="symbol"||typeof u=="boolean"?null:typeof u=="function"?u:gg(""+u)}function $A(u,c){var p=c.ownerDocument.createElement("input");return p.name=c.name,p.value=c.value,u.id&&p.setAttribute("form",u.id),c.parentNode.insertBefore(p,c),u=new FormData(u),p.parentNode.removeChild(p),u}function GW(u,c,p,g,S){if(c==="submit"&&p&&p.stateNode===S){var T=EA((S[Ls]||null).action),I=g.submitter;I&&(c=(c=I[Ls]||null)?EA(c.formAction):I.getAttribute("formAction"),c!==null&&(T=c,I=null));var z=new wg("action","action",null,g,S);u.push({event:z,listeners:[{instance:null,listener:function(){if(g.defaultPrevented){if(ao!==0){var H=I?$A(S,I):new FormData(S);qv(p,{pending:!0,data:H,method:S.method,action:T},null,H)}}else typeof T=="function"&&(z.preventDefault(),H=I?$A(S,I):new FormData(S),qv(p,{pending:!0,data:H,method:S.method,action:T},T,H))},currentTarget:S}]})}}for(var $1=0;$1<cv.length;$1++){var I1=cv[$1],HW=I1.toLowerCase(),qW=I1[0].toUpperCase()+I1.slice(1);ea(HW,"on"+qW)}ea(aI,"onAnimationEnd"),ea(iI,"onAnimationIteration"),ea(oI,"onAnimationStart"),ea("dblclick","onDoubleClick"),ea("focusin","onFocus"),ea("focusout","onBlur"),ea(uW,"onTransitionRun"),ea(cW,"onTransitionStart"),ea(hW,"onTransitionCancel"),ea(lI,"onTransitionEnd"),_u("onMouseEnter",["mouseout","mouseover"]),_u("onMouseLeave",["mouseout","mouseover"]),_u("onPointerEnter",["pointerout","pointerover"]),_u("onPointerLeave",["pointerout","pointerover"]),Qo("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Qo("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Qo("onBeforeInput",["compositionend","keypress","textInput","paste"]),Qo("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Qo("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Qo("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var tf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),KW=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(tf));function IA(u,c){c=(c&4)!==0;for(var p=0;p<u.length;p++){var g=u[p],S=g.event;g=g.listeners;e:{var T=void 0;if(c)for(var I=g.length-1;0<=I;I--){var z=g[I],H=z.instance,ue=z.currentTarget;if(z=z.listener,H!==T&&S.isPropagationStopped())break e;T=z,S.currentTarget=ue;try{T(S)}catch(ge){Tg(ge)}S.currentTarget=null,T=H}else for(I=0;I<g.length;I++){if(z=g[I],H=z.instance,ue=z.currentTarget,z=z.listener,H!==T&&S.isPropagationStopped())break e;T=z,S.currentTarget=ue;try{T(S)}catch(ge){Tg(ge)}S.currentTarget=null,T=H}}}}function ht(u,c){var p=c[Uw];p===void 0&&(p=c[Uw]=new Set);var g=u+"__bubble";p.has(g)||(_A(c,u,2,!1),p.add(g))}function _1(u,c,p){var g=0;c&&(g|=4),_A(p,u,g,c)}var uy="_reactListening"+Math.random().toString(36).slice(2);function A1(u){if(!u[uy]){u[uy]=!0,T$.forEach(function(p){p!=="selectionchange"&&(KW.has(p)||_1(p,!1,u),_1(p,!0,u))});var c=u.nodeType===9?u:u.ownerDocument;c===null||c[uy]||(c[uy]=!0,_1("selectionchange",!1,c))}}function _A(u,c,p,g){switch(aR(c)){case 2:var S=SG;break;case 8:S=TG;break;default:S=H1}p=S.bind(null,c,p,u),S=void 0,!Jw||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||(S=!0),g?S!==void 0?u.addEventListener(c,p,{capture:!0,passive:S}):u.addEventListener(c,p,!0):S!==void 0?u.addEventListener(c,p,{passive:S}):u.addEventListener(c,p,!1)}function R1(u,c,p,g,S){var T=g;if((c&1)===0&&(c&2)===0&&g!==null)e:for(;;){if(g===null)return;var I=g.tag;if(I===3||I===4){var z=g.stateNode.containerInfo;if(z===S)break;if(I===4)for(I=g.return;I!==null;){var H=I.tag;if((H===3||H===4)&&I.stateNode.containerInfo===S)return;I=I.return}for(;z!==null;){if(I=Eu(z),I===null)return;if(H=I.tag,H===5||H===6||H===26||H===27){g=T=I;continue e}z=z.parentNode}}g=g.return}F$(function(){var ue=T,ge=Xw(p),be=[];e:{var ce=uI.get(u);if(ce!==void 0){var de=wg,De=u;switch(u){case"keypress":if(bg(p)===0)break e;case"keydown":case"keyup":de=Vj;break;case"focusin":De="focus",de=tv;break;case"focusout":De="blur",de=tv;break;case"beforeblur":case"afterblur":de=tv;break;case"click":if(p.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":de=z$;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":de=Ij;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":de=Wj;break;case aI:case iI:case oI:de=Rj;break;case lI:de=Hj;break;case"scroll":case"scrollend":de=Ej;break;case"wheel":de=Kj;break;case"copy":case"cut":case"paste":de=Oj;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":de=B$;break;case"toggle":case"beforetoggle":de=Yj}var We=(c&4)!==0,Dt=!We&&(u==="scroll"||u==="scrollend"),ae=We?ce!==null?ce+"Capture":null:ce;We=[];for(var ee=ue,le;ee!==null;){var ye=ee;if(le=ye.stateNode,ye=ye.tag,ye!==5&&ye!==26&&ye!==27||le===null||ae===null||(ye=Td(ee,ae),ye!=null&&We.push(nf(ee,ye,le))),Dt)break;ee=ee.return}0<We.length&&(ce=new de(ce,De,null,p,ge),be.push({event:ce,listeners:We}))}}if((c&7)===0){e:{if(ce=u==="mouseover"||u==="pointerover",de=u==="mouseout"||u==="pointerout",ce&&p!==Kw&&(De=p.relatedTarget||p.fromElement)&&(Eu(De)||De[ku]))break e;if((de||ce)&&(ce=ge.window===ge?ge:(ce=ge.ownerDocument)?ce.defaultView||ce.parentWindow:window,de?(De=p.relatedTarget||p.toElement,de=ue,De=De?Eu(De):null,De!==null&&(Dt=a(De),We=De.tag,De!==Dt||We!==5&&We!==27&&We!==6)&&(De=null)):(de=null,De=ue),de!==De)){if(We=z$,ye="onMouseLeave",ae="onMouseEnter",ee="mouse",(u==="pointerout"||u==="pointerover")&&(We=B$,ye="onPointerLeave",ae="onPointerEnter",ee="pointer"),Dt=de==null?ce:Sd(de),le=De==null?ce:Sd(De),ce=new We(ye,ee+"leave",de,p,ge),ce.target=Dt,ce.relatedTarget=le,ye=null,Eu(ge)===ue&&(We=new We(ae,ee+"enter",De,p,ge),We.target=le,We.relatedTarget=Dt,ye=We),Dt=ye,de&&De)t:{for(We=XW,ae=de,ee=De,le=0,ye=ae;ye;ye=We(ye))le++;ye=0;for(var Ve=ee;Ve;Ve=We(Ve))ye++;for(;0<le-ye;)ae=We(ae),le--;for(;0<ye-le;)ee=We(ee),ye--;for(;le--;){if(ae===ee||ee!==null&&ae===ee.alternate){We=ae;break t}ae=We(ae),ee=We(ee)}We=null}else We=null;de!==null&&AA(be,ce,de,We,!1),De!==null&&Dt!==null&&AA(be,Dt,De,We,!0)}}e:{if(ce=ue?Sd(ue):window,de=ce.nodeName&&ce.nodeName.toLowerCase(),de==="select"||de==="input"&&ce.type==="file")var vt=K$;else if(H$(ce))if(X$)vt=iW;else{vt=rW;var Me=sW}else de=ce.nodeName,!de||de.toLowerCase()!=="input"||ce.type!=="checkbox"&&ce.type!=="radio"?ue&&qw(ue.elementType)&&(vt=K$):vt=aW;if(vt&&(vt=vt(u,ue))){q$(be,vt,p,ge);break e}Me&&Me(u,ce,ue),u==="focusout"&&ue&&ce.type==="number"&&ue.memoizedProps.value!=null&&Hw(ce,"number",ce.value)}switch(Me=ue?Sd(ue):window,u){case"focusin":(H$(Me)||Me.contentEditable==="true")&&(Lu=Me,ov=ue,Ad=null);break;case"focusout":Ad=ov=Lu=null;break;case"mousedown":lv=!0;break;case"contextmenu":case"mouseup":case"dragend":lv=!1,sI(be,p,ge);break;case"selectionchange":if(lW)break;case"keydown":case"keyup":sI(be,p,ge)}var st;if(sv)e:{switch(u){case"compositionstart":var mt="onCompositionStart";break e;case"compositionend":mt="onCompositionEnd";break e;case"compositionupdate":mt="onCompositionUpdate";break e}mt=void 0}else Fu?W$(u,p)&&(mt="onCompositionEnd"):u==="keydown"&&p.keyCode===229&&(mt="onCompositionStart");mt&&(V$&&p.locale!=="ko"&&(Fu||mt!=="onCompositionStart"?mt==="onCompositionEnd"&&Fu&&(st=L$()):(ji=ge,Zw="value"in ji?ji.value:ji.textContent,Fu=!0)),Me=cy(ue,mt),0<Me.length&&(mt=new P$(mt,u,null,p,ge),be.push({event:mt,listeners:Me}),st?mt.data=st:(st=G$(p),st!==null&&(mt.data=st)))),(st=Zj?Qj(u,p):eW(u,p))&&(mt=cy(ue,"onBeforeInput"),0<mt.length&&(Me=new P$("onBeforeInput","beforeinput",null,p,ge),be.push({event:Me,listeners:mt}),Me.data=st)),GW(be,u,ue,p,ge)}IA(be,c)})}function nf(u,c,p){return{instance:u,listener:c,currentTarget:p}}function cy(u,c){for(var p=c+"Capture",g=[];u!==null;){var S=u,T=S.stateNode;if(S=S.tag,S!==5&&S!==26&&S!==27||T===null||(S=Td(u,p),S!=null&&g.unshift(nf(u,S,T)),S=Td(u,c),S!=null&&g.push(nf(u,S,T))),u.tag===3)return g;u=u.return}return[]}function XW(u){if(u===null)return null;do u=u.return;while(u&&u.tag!==5&&u.tag!==27);return u||null}function AA(u,c,p,g,S){for(var T=c._reactName,I=[];p!==null&&p!==g;){var z=p,H=z.alternate,ue=z.stateNode;if(z=z.tag,H!==null&&H===g)break;z!==5&&z!==26&&z!==27||ue===null||(H=ue,S?(ue=Td(p,T),ue!=null&&I.unshift(nf(p,ue,H))):S||(ue=Td(p,T),ue!=null&&I.push(nf(p,ue,H)))),p=p.return}I.length!==0&&u.push({event:c,listeners:I})}var YW=/\r\n?/g,JW=/\u0000|\uFFFD/g;function RA(u){return(typeof u=="string"?u:""+u).replace(YW,`
`).replace(JW,"")}function DA(u,c){return c=RA(c),RA(u)===c}function Rt(u,c,p,g,S,T){switch(p){case"children":typeof g=="string"?c==="body"||c==="textarea"&&g===""||Ru(u,g):(typeof g=="number"||typeof g=="bigint")&&c!=="body"&&Ru(u,""+g);break;case"className":pg(u,"class",g);break;case"tabIndex":pg(u,"tabindex",g);break;case"dir":case"role":case"viewBox":case"width":case"height":pg(u,p,g);break;case"style":D$(u,g,T);break;case"data":if(c!=="object"){pg(u,"data",g);break}case"src":case"href":if(g===""&&(c!=="a"||p!=="href")){u.removeAttribute(p);break}if(g==null||typeof g=="function"||typeof g=="symbol"||typeof g=="boolean"){u.removeAttribute(p);break}g=gg(""+g),u.setAttribute(p,g);break;case"action":case"formAction":if(typeof g=="function"){u.setAttribute(p,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof T=="function"&&(p==="formAction"?(c!=="input"&&Rt(u,c,"name",S.name,S,null),Rt(u,c,"formEncType",S.formEncType,S,null),Rt(u,c,"formMethod",S.formMethod,S,null),Rt(u,c,"formTarget",S.formTarget,S,null)):(Rt(u,c,"encType",S.encType,S,null),Rt(u,c,"method",S.method,S,null),Rt(u,c,"target",S.target,S,null)));if(g==null||typeof g=="symbol"||typeof g=="boolean"){u.removeAttribute(p);break}g=gg(""+g),u.setAttribute(p,g);break;case"onClick":g!=null&&(u.onclick=Qa);break;case"onScroll":g!=null&&ht("scroll",u);break;case"onScrollEnd":g!=null&&ht("scrollend",u);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(p=g.__html,p!=null){if(S.children!=null)throw Error(s(60));u.innerHTML=p}}break;case"multiple":u.multiple=g&&typeof g!="function"&&typeof g!="symbol";break;case"muted":u.muted=g&&typeof g!="function"&&typeof g!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(g==null||typeof g=="function"||typeof g=="boolean"||typeof g=="symbol"){u.removeAttribute("xlink:href");break}p=gg(""+g),u.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",p);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":g!=null&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(p,""+g):u.removeAttribute(p);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":g&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(p,""):u.removeAttribute(p);break;case"capture":case"download":g===!0?u.setAttribute(p,""):g!==!1&&g!=null&&typeof g!="function"&&typeof g!="symbol"?u.setAttribute(p,g):u.removeAttribute(p);break;case"cols":case"rows":case"size":case"span":g!=null&&typeof g!="function"&&typeof g!="symbol"&&!isNaN(g)&&1<=g?u.setAttribute(p,g):u.removeAttribute(p);break;case"rowSpan":case"start":g==null||typeof g=="function"||typeof g=="symbol"||isNaN(g)?u.removeAttribute(p):u.setAttribute(p,g);break;case"popover":ht("beforetoggle",u),ht("toggle",u),fg(u,"popover",g);break;case"xlinkActuate":Za(u,"http://www.w3.org/1999/xlink","xlink:actuate",g);break;case"xlinkArcrole":Za(u,"http://www.w3.org/1999/xlink","xlink:arcrole",g);break;case"xlinkRole":Za(u,"http://www.w3.org/1999/xlink","xlink:role",g);break;case"xlinkShow":Za(u,"http://www.w3.org/1999/xlink","xlink:show",g);break;case"xlinkTitle":Za(u,"http://www.w3.org/1999/xlink","xlink:title",g);break;case"xlinkType":Za(u,"http://www.w3.org/1999/xlink","xlink:type",g);break;case"xmlBase":Za(u,"http://www.w3.org/XML/1998/namespace","xml:base",g);break;case"xmlLang":Za(u,"http://www.w3.org/XML/1998/namespace","xml:lang",g);break;case"xmlSpace":Za(u,"http://www.w3.org/XML/1998/namespace","xml:space",g);break;case"is":fg(u,"is",g);break;case"innerText":case"textContent":break;default:(!(2<p.length)||p[0]!=="o"&&p[0]!=="O"||p[1]!=="n"&&p[1]!=="N")&&(p=Nj.get(p)||p,fg(u,p,g))}}function D1(u,c,p,g,S,T){switch(p){case"style":D$(u,g,T);break;case"dangerouslySetInnerHTML":if(g!=null){if(typeof g!="object"||!("__html"in g))throw Error(s(61));if(p=g.__html,p!=null){if(S.children!=null)throw Error(s(60));u.innerHTML=p}}break;case"children":typeof g=="string"?Ru(u,g):(typeof g=="number"||typeof g=="bigint")&&Ru(u,""+g);break;case"onScroll":g!=null&&ht("scroll",u);break;case"onScrollEnd":g!=null&&ht("scrollend",u);break;case"onClick":g!=null&&(u.onclick=Qa);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!C$.hasOwnProperty(p))e:{if(p[0]==="o"&&p[1]==="n"&&(S=p.endsWith("Capture"),c=p.slice(2,S?p.length-7:void 0),T=u[Ls]||null,T=T!=null?T[p]:null,typeof T=="function"&&u.removeEventListener(c,T,S),typeof g=="function")){typeof T!="function"&&T!==null&&(p in u?u[p]=null:u.hasAttribute(p)&&u.removeAttribute(p)),u.addEventListener(c,g,S);break e}p in u?u[p]=g:g===!0?u.setAttribute(p,""):fg(u,p,g)}}}function is(u,c,p){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":ht("error",u),ht("load",u);var g=!1,S=!1,T;for(T in p)if(p.hasOwnProperty(T)){var I=p[T];if(I!=null)switch(T){case"src":g=!0;break;case"srcSet":S=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:Rt(u,c,T,I,p,null)}}S&&Rt(u,c,"srcSet",p.srcSet,p,null),g&&Rt(u,c,"src",p.src,p,null);return;case"input":ht("invalid",u);var z=T=I=S=null,H=null,ue=null;for(g in p)if(p.hasOwnProperty(g)){var ge=p[g];if(ge!=null)switch(g){case"name":S=ge;break;case"type":I=ge;break;case"checked":H=ge;break;case"defaultChecked":ue=ge;break;case"value":T=ge;break;case"defaultValue":z=ge;break;case"children":case"dangerouslySetInnerHTML":if(ge!=null)throw Error(s(137,c));break;default:Rt(u,c,g,ge,p,null)}}I$(u,T,z,H,ue,I,S,!1);return;case"select":ht("invalid",u),g=I=T=null;for(S in p)if(p.hasOwnProperty(S)&&(z=p[S],z!=null))switch(S){case"value":T=z;break;case"defaultValue":I=z;break;case"multiple":g=z;default:Rt(u,c,S,z,p,null)}c=T,p=I,u.multiple=!!g,c!=null?Au(u,!!g,c,!1):p!=null&&Au(u,!!g,p,!0);return;case"textarea":ht("invalid",u),T=S=g=null;for(I in p)if(p.hasOwnProperty(I)&&(z=p[I],z!=null))switch(I){case"value":g=z;break;case"defaultValue":S=z;break;case"children":T=z;break;case"dangerouslySetInnerHTML":if(z!=null)throw Error(s(91));break;default:Rt(u,c,I,z,p,null)}A$(u,g,S,T);return;case"option":for(H in p)p.hasOwnProperty(H)&&(g=p[H],g!=null)&&(H==="selected"?u.selected=g&&typeof g!="function"&&typeof g!="symbol":Rt(u,c,H,g,p,null));return;case"dialog":ht("beforetoggle",u),ht("toggle",u),ht("cancel",u),ht("close",u);break;case"iframe":case"object":ht("load",u);break;case"video":case"audio":for(g=0;g<tf.length;g++)ht(tf[g],u);break;case"image":ht("error",u),ht("load",u);break;case"details":ht("toggle",u);break;case"embed":case"source":case"link":ht("error",u),ht("load",u);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(ue in p)if(p.hasOwnProperty(ue)&&(g=p[ue],g!=null))switch(ue){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,c));default:Rt(u,c,ue,g,p,null)}return;default:if(qw(c)){for(ge in p)p.hasOwnProperty(ge)&&(g=p[ge],g!==void 0&&D1(u,c,ge,g,p,void 0));return}}for(z in p)p.hasOwnProperty(z)&&(g=p[z],g!=null&&Rt(u,c,z,g,p,null))}function ZW(u,c,p,g){switch(c){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var S=null,T=null,I=null,z=null,H=null,ue=null,ge=null;for(de in p){var be=p[de];if(p.hasOwnProperty(de)&&be!=null)switch(de){case"checked":break;case"value":break;case"defaultValue":H=be;default:g.hasOwnProperty(de)||Rt(u,c,de,null,g,be)}}for(var ce in g){var de=g[ce];if(be=p[ce],g.hasOwnProperty(ce)&&(de!=null||be!=null))switch(ce){case"type":T=de;break;case"name":S=de;break;case"checked":ue=de;break;case"defaultChecked":ge=de;break;case"value":I=de;break;case"defaultValue":z=de;break;case"children":case"dangerouslySetInnerHTML":if(de!=null)throw Error(s(137,c));break;default:de!==be&&Rt(u,c,ce,de,g,be)}}Gw(u,I,z,H,ue,ge,T,S);return;case"select":de=I=z=ce=null;for(T in p)if(H=p[T],p.hasOwnProperty(T)&&H!=null)switch(T){case"value":break;case"multiple":de=H;default:g.hasOwnProperty(T)||Rt(u,c,T,null,g,H)}for(S in g)if(T=g[S],H=p[S],g.hasOwnProperty(S)&&(T!=null||H!=null))switch(S){case"value":ce=T;break;case"defaultValue":z=T;break;case"multiple":I=T;default:T!==H&&Rt(u,c,S,T,g,H)}c=z,p=I,g=de,ce!=null?Au(u,!!p,ce,!1):!!g!=!!p&&(c!=null?Au(u,!!p,c,!0):Au(u,!!p,p?[]:"",!1));return;case"textarea":de=ce=null;for(z in p)if(S=p[z],p.hasOwnProperty(z)&&S!=null&&!g.hasOwnProperty(z))switch(z){case"value":break;case"children":break;default:Rt(u,c,z,null,g,S)}for(I in g)if(S=g[I],T=p[I],g.hasOwnProperty(I)&&(S!=null||T!=null))switch(I){case"value":ce=S;break;case"defaultValue":de=S;break;case"children":break;case"dangerouslySetInnerHTML":if(S!=null)throw Error(s(91));break;default:S!==T&&Rt(u,c,I,S,g,T)}_$(u,ce,de);return;case"option":for(var De in p)ce=p[De],p.hasOwnProperty(De)&&ce!=null&&!g.hasOwnProperty(De)&&(De==="selected"?u.selected=!1:Rt(u,c,De,null,g,ce));for(H in g)ce=g[H],de=p[H],g.hasOwnProperty(H)&&ce!==de&&(ce!=null||de!=null)&&(H==="selected"?u.selected=ce&&typeof ce!="function"&&typeof ce!="symbol":Rt(u,c,H,ce,g,de));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var We in p)ce=p[We],p.hasOwnProperty(We)&&ce!=null&&!g.hasOwnProperty(We)&&Rt(u,c,We,null,g,ce);for(ue in g)if(ce=g[ue],de=p[ue],g.hasOwnProperty(ue)&&ce!==de&&(ce!=null||de!=null))switch(ue){case"children":case"dangerouslySetInnerHTML":if(ce!=null)throw Error(s(137,c));break;default:Rt(u,c,ue,ce,g,de)}return;default:if(qw(c)){for(var Dt in p)ce=p[Dt],p.hasOwnProperty(Dt)&&ce!==void 0&&!g.hasOwnProperty(Dt)&&D1(u,c,Dt,void 0,g,ce);for(ge in g)ce=g[ge],de=p[ge],!g.hasOwnProperty(ge)||ce===de||ce===void 0&&de===void 0||D1(u,c,ge,ce,g,de);return}}for(var ae in p)ce=p[ae],p.hasOwnProperty(ae)&&ce!=null&&!g.hasOwnProperty(ae)&&Rt(u,c,ae,null,g,ce);for(be in g)ce=g[be],de=p[be],!g.hasOwnProperty(be)||ce===de||ce==null&&de==null||Rt(u,c,be,ce,g,de)}function OA(u){switch(u){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function QW(){if(typeof performance.getEntriesByType=="function"){for(var u=0,c=0,p=performance.getEntriesByType("resource"),g=0;g<p.length;g++){var S=p[g],T=S.transferSize,I=S.initiatorType,z=S.duration;if(T&&z&&OA(I)){for(I=0,z=S.responseEnd,g+=1;g<p.length;g++){var H=p[g],ue=H.startTime;if(ue>z)break;var ge=H.transferSize,be=H.initiatorType;ge&&OA(be)&&(H=H.responseEnd,I+=ge*(H<z?1:(z-ue)/(H-ue)))}if(--g,c+=8*(T+I)/(S.duration/1e3),u++,10<u)break}}if(0<u)return c/u/1e6}return navigator.connection&&(u=navigator.connection.downlink,typeof u=="number")?u:5}var O1=null,F1=null;function hy(u){return u.nodeType===9?u:u.ownerDocument}function FA(u){switch(u){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function LA(u,c){if(u===0)switch(c){case"svg":return 1;case"math":return 2;default:return 0}return u===1&&c==="foreignObject"?0:u}function L1(u,c){return u==="textarea"||u==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.children=="bigint"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var M1=null;function eG(){var u=window.event;return u&&u.type==="popstate"?u===M1?!1:(M1=u,!0):(M1=null,!1)}var MA=typeof setTimeout=="function"?setTimeout:void 0,tG=typeof clearTimeout=="function"?clearTimeout:void 0,zA=typeof Promise=="function"?Promise:void 0,nG=typeof queueMicrotask=="function"?queueMicrotask:typeof zA<"u"?function(u){return zA.resolve(null).then(u).catch(sG)}:MA;function sG(u){setTimeout(function(){throw u})}function io(u){return u==="head"}function PA(u,c){var p=c,g=0;do{var S=p.nextSibling;if(u.removeChild(p),S&&S.nodeType===8)if(p=S.data,p==="/$"||p==="/&"){if(g===0){u.removeChild(S),uc(c);return}g--}else if(p==="$"||p==="$?"||p==="$~"||p==="$!"||p==="&")g++;else if(p==="html")sf(u.ownerDocument.documentElement);else if(p==="head"){p=u.ownerDocument.head,sf(p);for(var T=p.firstChild;T;){var I=T.nextSibling,z=T.nodeName;T[vd]||z==="SCRIPT"||z==="STYLE"||z==="LINK"&&T.rel.toLowerCase()==="stylesheet"||p.removeChild(T),T=I}}else p==="body"&&sf(u.ownerDocument.body);p=S}while(p);uc(c)}function BA(u,c){var p=u;u=0;do{var g=p.nextSibling;if(p.nodeType===1?c?(p._stashedDisplay=p.style.display,p.style.display="none"):(p.style.display=p._stashedDisplay||"",p.getAttribute("style")===""&&p.removeAttribute("style")):p.nodeType===3&&(c?(p._stashedText=p.nodeValue,p.nodeValue=""):p.nodeValue=p._stashedText||""),g&&g.nodeType===8)if(p=g.data,p==="/$"){if(u===0)break;u--}else p!=="$"&&p!=="$?"&&p!=="$~"&&p!=="$!"||u++;p=g}while(p)}function z1(u){var c=u.firstChild;for(c&&c.nodeType===10&&(c=c.nextSibling);c;){var p=c;switch(c=c.nextSibling,p.nodeName){case"HTML":case"HEAD":case"BODY":z1(p),jw(p);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(p.rel.toLowerCase()==="stylesheet")continue}u.removeChild(p)}}function rG(u,c,p,g){for(;u.nodeType===1;){var S=p;if(u.nodeName.toLowerCase()!==c.toLowerCase()){if(!g&&(u.nodeName!=="INPUT"||u.type!=="hidden"))break}else if(g){if(!u[vd])switch(c){case"meta":if(!u.hasAttribute("itemprop"))break;return u;case"link":if(T=u.getAttribute("rel"),T==="stylesheet"&&u.hasAttribute("data-precedence"))break;if(T!==S.rel||u.getAttribute("href")!==(S.href==null||S.href===""?null:S.href)||u.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin)||u.getAttribute("title")!==(S.title==null?null:S.title))break;return u;case"style":if(u.hasAttribute("data-precedence"))break;return u;case"script":if(T=u.getAttribute("src"),(T!==(S.src==null?null:S.src)||u.getAttribute("type")!==(S.type==null?null:S.type)||u.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin))&&T&&u.hasAttribute("async")&&!u.hasAttribute("itemprop"))break;return u;default:return u}}else if(c==="input"&&u.type==="hidden"){var T=S.name==null?null:""+S.name;if(S.type==="hidden"&&u.getAttribute("name")===T)return u}else return u;if(u=Fr(u.nextSibling),u===null)break}return null}function aG(u,c,p){if(c==="")return null;for(;u.nodeType!==3;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!p||(u=Fr(u.nextSibling),u===null))return null;return u}function VA(u,c){for(;u.nodeType!==8;)if((u.nodeType!==1||u.nodeName!=="INPUT"||u.type!=="hidden")&&!c||(u=Fr(u.nextSibling),u===null))return null;return u}function P1(u){return u.data==="$?"||u.data==="$~"}function B1(u){return u.data==="$!"||u.data==="$?"&&u.ownerDocument.readyState!=="loading"}function iG(u,c){var p=u.ownerDocument;if(u.data==="$~")u._reactRetry=c;else if(u.data!=="$?"||p.readyState!=="loading")c();else{var g=function(){c(),p.removeEventListener("DOMContentLoaded",g)};p.addEventListener("DOMContentLoaded",g),u._reactRetry=g}}function Fr(u){for(;u!=null;u=u.nextSibling){var c=u.nodeType;if(c===1||c===3)break;if(c===8){if(c=u.data,c==="$"||c==="$!"||c==="$?"||c==="$~"||c==="&"||c==="F!"||c==="F")break;if(c==="/$"||c==="/&")return null}}return u}var V1=null;function UA(u){u=u.nextSibling;for(var c=0;u;){if(u.nodeType===8){var p=u.data;if(p==="/$"||p==="/&"){if(c===0)return Fr(u.nextSibling);c--}else p!=="$"&&p!=="$!"&&p!=="$?"&&p!=="$~"&&p!=="&"||c++}u=u.nextSibling}return null}function jA(u){u=u.previousSibling;for(var c=0;u;){if(u.nodeType===8){var p=u.data;if(p==="$"||p==="$!"||p==="$?"||p==="$~"||p==="&"){if(c===0)return u;c--}else p!=="/$"&&p!=="/&"||c++}u=u.previousSibling}return null}function WA(u,c,p){switch(c=hy(p),u){case"html":if(u=c.documentElement,!u)throw Error(s(452));return u;case"head":if(u=c.head,!u)throw Error(s(453));return u;case"body":if(u=c.body,!u)throw Error(s(454));return u;default:throw Error(s(451))}}function sf(u){for(var c=u.attributes;c.length;)u.removeAttributeNode(c[0]);jw(u)}var Lr=new Map,GA=new Set;function dy(u){return typeof u.getRootNode=="function"?u.getRootNode():u.nodeType===9?u:u.ownerDocument}var mi=U.d;U.d={f:oG,r:lG,D:uG,C:cG,L:hG,m:dG,X:pG,S:fG,M:mG};function oG(){var u=mi.f(),c=sy();return u||c}function lG(u){var c=$u(u);c!==null&&c.tag===5&&c.type==="form"?l_(c):mi.r(u)}var ic=typeof document>"u"?null:document;function HA(u,c,p){var g=ic;if(g&&typeof c=="string"&&c){var S=$r(c);S='link[rel="'+u+'"][href="'+S+'"]',typeof p=="string"&&(S+='[crossorigin="'+p+'"]'),GA.has(S)||(GA.add(S),u={rel:u,crossOrigin:p,href:c},g.querySelector(S)===null&&(c=g.createElement("link"),is(c,"link",u),jn(c),g.head.appendChild(c)))}}function uG(u){mi.D(u),HA("dns-prefetch",u,null)}function cG(u,c){mi.C(u,c),HA("preconnect",u,c)}function hG(u,c,p){mi.L(u,c,p);var g=ic;if(g&&u&&c){var S='link[rel="preload"][as="'+$r(c)+'"]';c==="image"&&p&&p.imageSrcSet?(S+='[imagesrcset="'+$r(p.imageSrcSet)+'"]',typeof p.imageSizes=="string"&&(S+='[imagesizes="'+$r(p.imageSizes)+'"]')):S+='[href="'+$r(u)+'"]';var T=S;switch(c){case"style":T=oc(u);break;case"script":T=lc(u)}Lr.has(T)||(u=f({rel:"preload",href:c==="image"&&p&&p.imageSrcSet?void 0:u,as:c},p),Lr.set(T,u),g.querySelector(S)!==null||c==="style"&&g.querySelector(rf(T))||c==="script"&&g.querySelector(af(T))||(c=g.createElement("link"),is(c,"link",u),jn(c),g.head.appendChild(c)))}}function dG(u,c){mi.m(u,c);var p=ic;if(p&&u){var g=c&&typeof c.as=="string"?c.as:"script",S='link[rel="modulepreload"][as="'+$r(g)+'"][href="'+$r(u)+'"]',T=S;switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":T=lc(u)}if(!Lr.has(T)&&(u=f({rel:"modulepreload",href:u},c),Lr.set(T,u),p.querySelector(S)===null)){switch(g){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(p.querySelector(af(T)))return}g=p.createElement("link"),is(g,"link",u),jn(g),p.head.appendChild(g)}}}function fG(u,c,p){mi.S(u,c,p);var g=ic;if(g&&u){var S=Iu(g).hoistableStyles,T=oc(u);c=c||"default";var I=S.get(T);if(!I){var z={loading:0,preload:null};if(I=g.querySelector(rf(T)))z.loading=5;else{u=f({rel:"stylesheet",href:u,"data-precedence":c},p),(p=Lr.get(T))&&U1(u,p);var H=I=g.createElement("link");jn(H),is(H,"link",u),H._p=new Promise(function(ue,ge){H.onload=ue,H.onerror=ge}),H.addEventListener("load",function(){z.loading|=1}),H.addEventListener("error",function(){z.loading|=2}),z.loading|=4,fy(I,c,g)}I={type:"stylesheet",instance:I,count:1,state:z},S.set(T,I)}}}function pG(u,c){mi.X(u,c);var p=ic;if(p&&u){var g=Iu(p).hoistableScripts,S=lc(u),T=g.get(S);T||(T=p.querySelector(af(S)),T||(u=f({src:u,async:!0},c),(c=Lr.get(S))&&j1(u,c),T=p.createElement("script"),jn(T),is(T,"link",u),p.head.appendChild(T)),T={type:"script",instance:T,count:1,state:null},g.set(S,T))}}function mG(u,c){mi.M(u,c);var p=ic;if(p&&u){var g=Iu(p).hoistableScripts,S=lc(u),T=g.get(S);T||(T=p.querySelector(af(S)),T||(u=f({src:u,async:!0,type:"module"},c),(c=Lr.get(S))&&j1(u,c),T=p.createElement("script"),jn(T),is(T,"link",u),p.head.appendChild(T)),T={type:"script",instance:T,count:1,state:null},g.set(S,T))}}function qA(u,c,p,g){var S=(S=xe.current)?dy(S):null;if(!S)throw Error(s(446));switch(u){case"meta":case"title":return null;case"style":return typeof p.precedence=="string"&&typeof p.href=="string"?(c=oc(p.href),p=Iu(S).hoistableStyles,g=p.get(c),g||(g={type:"style",instance:null,count:0,state:null},p.set(c,g)),g):{type:"void",instance:null,count:0,state:null};case"link":if(p.rel==="stylesheet"&&typeof p.href=="string"&&typeof p.precedence=="string"){u=oc(p.href);var T=Iu(S).hoistableStyles,I=T.get(u);if(I||(S=S.ownerDocument||S,I={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},T.set(u,I),(T=S.querySelector(rf(u)))&&!T._p&&(I.instance=T,I.state.loading=5),Lr.has(u)||(p={rel:"preload",as:"style",href:p.href,crossOrigin:p.crossOrigin,integrity:p.integrity,media:p.media,hrefLang:p.hrefLang,referrerPolicy:p.referrerPolicy},Lr.set(u,p),T||gG(S,u,p,I.state))),c&&g===null)throw Error(s(528,""));return I}if(c&&g!==null)throw Error(s(529,""));return null;case"script":return c=p.async,p=p.src,typeof p=="string"&&c&&typeof c!="function"&&typeof c!="symbol"?(c=lc(p),p=Iu(S).hoistableScripts,g=p.get(c),g||(g={type:"script",instance:null,count:0,state:null},p.set(c,g)),g):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,u))}}function oc(u){return'href="'+$r(u)+'"'}function rf(u){return'link[rel="stylesheet"]['+u+"]"}function KA(u){return f({},u,{"data-precedence":u.precedence,precedence:null})}function gG(u,c,p,g){u.querySelector('link[rel="preload"][as="style"]['+c+"]")?g.loading=1:(c=u.createElement("link"),g.preload=c,c.addEventListener("load",function(){return g.loading|=1}),c.addEventListener("error",function(){return g.loading|=2}),is(c,"link",p),jn(c),u.head.appendChild(c))}function lc(u){return'[src="'+$r(u)+'"]'}function af(u){return"script[async]"+u}function XA(u,c,p){if(c.count++,c.instance===null)switch(c.type){case"style":var g=u.querySelector('style[data-href~="'+$r(p.href)+'"]');if(g)return c.instance=g,jn(g),g;var S=f({},p,{"data-href":p.href,"data-precedence":p.precedence,href:null,precedence:null});return g=(u.ownerDocument||u).createElement("style"),jn(g),is(g,"style",S),fy(g,p.precedence,u),c.instance=g;case"stylesheet":S=oc(p.href);var T=u.querySelector(rf(S));if(T)return c.state.loading|=4,c.instance=T,jn(T),T;g=KA(p),(S=Lr.get(S))&&U1(g,S),T=(u.ownerDocument||u).createElement("link"),jn(T);var I=T;return I._p=new Promise(function(z,H){I.onload=z,I.onerror=H}),is(T,"link",g),c.state.loading|=4,fy(T,p.precedence,u),c.instance=T;case"script":return T=lc(p.src),(S=u.querySelector(af(T)))?(c.instance=S,jn(S),S):(g=p,(S=Lr.get(T))&&(g=f({},p),j1(g,S)),u=u.ownerDocument||u,S=u.createElement("script"),jn(S),is(S,"link",g),u.head.appendChild(S),c.instance=S);case"void":return null;default:throw Error(s(443,c.type))}else c.type==="stylesheet"&&(c.state.loading&4)===0&&(g=c.instance,c.state.loading|=4,fy(g,p.precedence,u));return c.instance}function fy(u,c,p){for(var g=p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),S=g.length?g[g.length-1]:null,T=S,I=0;I<g.length;I++){var z=g[I];if(z.dataset.precedence===c)T=z;else if(T!==S)break}T?T.parentNode.insertBefore(u,T.nextSibling):(c=p.nodeType===9?p.head:p,c.insertBefore(u,c.firstChild))}function U1(u,c){u.crossOrigin==null&&(u.crossOrigin=c.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=c.referrerPolicy),u.title==null&&(u.title=c.title)}function j1(u,c){u.crossOrigin==null&&(u.crossOrigin=c.crossOrigin),u.referrerPolicy==null&&(u.referrerPolicy=c.referrerPolicy),u.integrity==null&&(u.integrity=c.integrity)}var py=null;function YA(u,c,p){if(py===null){var g=new Map,S=py=new Map;S.set(p,g)}else S=py,g=S.get(p),g||(g=new Map,S.set(p,g));if(g.has(u))return g;for(g.set(u,null),p=p.getElementsByTagName(u),S=0;S<p.length;S++){var T=p[S];if(!(T[vd]||T[ns]||u==="link"&&T.getAttribute("rel")==="stylesheet")&&T.namespaceURI!=="http://www.w3.org/2000/svg"){var I=T.getAttribute(c)||"";I=u+I;var z=g.get(I);z?z.push(T):g.set(I,[T])}}return g}function JA(u,c,p){u=u.ownerDocument||u,u.head.insertBefore(p,c==="title"?u.querySelector("head > title"):null)}function yG(u,c,p){if(p===1||c.itemProp!=null)return!1;switch(u){case"meta":case"title":return!0;case"style":if(typeof c.precedence!="string"||typeof c.href!="string"||c.href==="")break;return!0;case"link":if(typeof c.rel!="string"||typeof c.href!="string"||c.href===""||c.onLoad||c.onError)break;return c.rel==="stylesheet"?(u=c.disabled,typeof c.precedence=="string"&&u==null):!0;case"script":if(c.async&&typeof c.async!="function"&&typeof c.async!="symbol"&&!c.onLoad&&!c.onError&&c.src&&typeof c.src=="string")return!0}return!1}function ZA(u){return!(u.type==="stylesheet"&&(u.state.loading&3)===0)}function bG(u,c,p,g){if(p.type==="stylesheet"&&(typeof g.media!="string"||matchMedia(g.media).matches!==!1)&&(p.state.loading&4)===0){if(p.instance===null){var S=oc(g.href),T=c.querySelector(rf(S));if(T){c=T._p,c!==null&&typeof c=="object"&&typeof c.then=="function"&&(u.count++,u=my.bind(u),c.then(u,u)),p.state.loading|=4,p.instance=T,jn(T);return}T=c.ownerDocument||c,g=KA(g),(S=Lr.get(S))&&U1(g,S),T=T.createElement("link"),jn(T);var I=T;I._p=new Promise(function(z,H){I.onload=z,I.onerror=H}),is(T,"link",g),p.instance=T}u.stylesheets===null&&(u.stylesheets=new Map),u.stylesheets.set(p,c),(c=p.state.preload)&&(p.state.loading&3)===0&&(u.count++,p=my.bind(u),c.addEventListener("load",p),c.addEventListener("error",p))}}var W1=0;function xG(u,c){return u.stylesheets&&u.count===0&&yy(u,u.stylesheets),0<u.count||0<u.imgCount?function(p){var g=setTimeout(function(){if(u.stylesheets&&yy(u,u.stylesheets),u.unsuspend){var T=u.unsuspend;u.unsuspend=null,T()}},6e4+c);0<u.imgBytes&&W1===0&&(W1=62500*QW());var S=setTimeout(function(){if(u.waitingForImages=!1,u.count===0&&(u.stylesheets&&yy(u,u.stylesheets),u.unsuspend)){var T=u.unsuspend;u.unsuspend=null,T()}},(u.imgBytes>W1?50:800)+c);return u.unsuspend=p,function(){u.unsuspend=null,clearTimeout(g),clearTimeout(S)}}:null}function my(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)yy(this,this.stylesheets);else if(this.unsuspend){var u=this.unsuspend;this.unsuspend=null,u()}}}var gy=null;function yy(u,c){u.stylesheets=null,u.unsuspend!==null&&(u.count++,gy=new Map,c.forEach(wG,u),gy=null,my.call(u))}function wG(u,c){if(!(c.state.loading&4)){var p=gy.get(u);if(p)var g=p.get(null);else{p=new Map,gy.set(u,p);for(var S=u.querySelectorAll("link[data-precedence],style[data-precedence]"),T=0;T<S.length;T++){var I=S[T];(I.nodeName==="LINK"||I.getAttribute("media")!=="not all")&&(p.set(I.dataset.precedence,I),g=I)}g&&p.set(null,g)}S=c.instance,I=S.getAttribute("data-precedence"),T=p.get(I)||g,T===g&&p.set(null,S),p.set(I,S),this.count++,g=my.bind(this),S.addEventListener("load",g),S.addEventListener("error",g),T?T.parentNode.insertBefore(S,T.nextSibling):(u=u.nodeType===9?u.head:u,u.insertBefore(S,u.firstChild)),c.state.loading|=4}}var of={$$typeof:N,Provider:null,Consumer:null,_currentValue:X,_currentValue2:X,_threadCount:0};function vG(u,c,p,g,S,T,I,z,H){this.tag=1,this.containerInfo=u,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Pw(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Pw(0),this.hiddenUpdates=Pw(null),this.identifierPrefix=g,this.onUncaughtError=S,this.onCaughtError=T,this.onRecoverableError=I,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=H,this.incompleteTransitions=new Map}function QA(u,c,p,g,S,T,I,z,H,ue,ge,be){return u=new vG(u,c,p,I,H,ue,ge,be,z),c=1,T===!0&&(c|=24),T=ir(3,null,null,c),u.current=T,T.stateNode=u,c=Tv(),c.refCount++,u.pooledCache=c,c.refCount++,T.memoizedState={element:g,isDehydrated:p,cache:c},Ev(T),u}function eR(u){return u?(u=Pu,u):Pu}function tR(u,c,p,g,S,T){S=eR(S),g.context===null?g.context=S:g.pendingContext=S,g=Xi(c),g.payload={element:p},T=T===void 0?null:T,T!==null&&(g.callback=T),p=Yi(u,g,c),p!==null&&(Us(p,u,c),zd(p,u,c))}function nR(u,c){if(u=u.memoizedState,u!==null&&u.dehydrated!==null){var p=u.retryLane;u.retryLane=p!==0&&p<c?p:c}}function G1(u,c){nR(u,c),(u=u.alternate)&&nR(u,c)}function sR(u){if(u.tag===13||u.tag===31){var c=sl(u,67108864);c!==null&&Us(c,u,67108864),G1(u,67108864)}}function rR(u){if(u.tag===13||u.tag===31){var c=hr();c=Bw(c);var p=sl(u,c);p!==null&&Us(p,u,c),G1(u,c)}}var by=!0;function SG(u,c,p,g){var S=B.T;B.T=null;var T=U.p;try{U.p=2,H1(u,c,p,g)}finally{U.p=T,B.T=S}}function TG(u,c,p,g){var S=B.T;B.T=null;var T=U.p;try{U.p=8,H1(u,c,p,g)}finally{U.p=T,B.T=S}}function H1(u,c,p,g){if(by){var S=q1(g);if(S===null)R1(u,c,g,xy,p),iR(u,g);else if(NG(S,u,c,p,g))g.stopPropagation();else if(iR(u,g),c&4&&-1<CG.indexOf(u)){for(;S!==null;){var T=$u(S);if(T!==null)switch(T.tag){case 3:if(T=T.stateNode,T.current.memoizedState.isDehydrated){var I=Zo(T.pendingLanes);if(I!==0){var z=T;for(z.pendingLanes|=2,z.entangledLanes|=2;I;){var H=1<<31-rr(I);z.entanglements[1]|=H,I&=~H}Aa(T),(Tt&6)===0&&(ty=Vt()+500,ef(0))}}break;case 31:case 13:z=sl(T,2),z!==null&&Us(z,T,2),sy(),G1(T,2)}if(T=q1(g),T===null&&R1(u,c,g,xy,p),T===S)break;S=T}S!==null&&g.stopPropagation()}else R1(u,c,g,null,p)}}function q1(u){return u=Xw(u),K1(u)}var xy=null;function K1(u){if(xy=null,u=Eu(u),u!==null){var c=a(u);if(c===null)u=null;else{var p=c.tag;if(p===13){if(u=i(c),u!==null)return u;u=null}else if(p===31){if(u=o(c),u!==null)return u;u=null}else if(p===3){if(c.stateNode.current.memoizedState.isDehydrated)return c.tag===3?c.stateNode.containerInfo:null;u=null}else c!==u&&(u=null)}}return xy=u,null}function aR(u){switch(u){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Jr()){case Zr:return 2;case Qr:return 8;case sr:case Jo:return 32;case Nu:return 268435456;default:return 32}default:return 32}}var X1=!1,oo=null,lo=null,uo=null,lf=new Map,uf=new Map,co=[],CG="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function iR(u,c){switch(u){case"focusin":case"focusout":oo=null;break;case"dragenter":case"dragleave":lo=null;break;case"mouseover":case"mouseout":uo=null;break;case"pointerover":case"pointerout":lf.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":uf.delete(c.pointerId)}}function cf(u,c,p,g,S,T){return u===null||u.nativeEvent!==T?(u={blockedOn:c,domEventName:p,eventSystemFlags:g,nativeEvent:T,targetContainers:[S]},c!==null&&(c=$u(c),c!==null&&sR(c)),u):(u.eventSystemFlags|=g,c=u.targetContainers,S!==null&&c.indexOf(S)===-1&&c.push(S),u)}function NG(u,c,p,g,S){switch(c){case"focusin":return oo=cf(oo,u,c,p,g,S),!0;case"dragenter":return lo=cf(lo,u,c,p,g,S),!0;case"mouseover":return uo=cf(uo,u,c,p,g,S),!0;case"pointerover":var T=S.pointerId;return lf.set(T,cf(lf.get(T)||null,u,c,p,g,S)),!0;case"gotpointercapture":return T=S.pointerId,uf.set(T,cf(uf.get(T)||null,u,c,p,g,S)),!0}return!1}function oR(u){var c=Eu(u.target);if(c!==null){var p=a(c);if(p!==null){if(c=p.tag,c===13){if(c=i(p),c!==null){u.blockedOn=c,v$(u.priority,function(){rR(p)});return}}else if(c===31){if(c=o(p),c!==null){u.blockedOn=c,v$(u.priority,function(){rR(p)});return}}else if(c===3&&p.stateNode.current.memoizedState.isDehydrated){u.blockedOn=p.tag===3?p.stateNode.containerInfo:null;return}}}u.blockedOn=null}function wy(u){if(u.blockedOn!==null)return!1;for(var c=u.targetContainers;0<c.length;){var p=q1(u.nativeEvent);if(p===null){p=u.nativeEvent;var g=new p.constructor(p.type,p);Kw=g,p.target.dispatchEvent(g),Kw=null}else return c=$u(p),c!==null&&sR(c),u.blockedOn=p,!1;c.shift()}return!0}function lR(u,c,p){wy(u)&&p.delete(c)}function kG(){X1=!1,oo!==null&&wy(oo)&&(oo=null),lo!==null&&wy(lo)&&(lo=null),uo!==null&&wy(uo)&&(uo=null),lf.forEach(lR),uf.forEach(lR)}function vy(u,c){u.blockedOn===c&&(u.blockedOn=null,X1||(X1=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,kG)))}var Sy=null;function uR(u){Sy!==u&&(Sy=u,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Sy===u&&(Sy=null);for(var c=0;c<u.length;c+=3){var p=u[c],g=u[c+1],S=u[c+2];if(typeof g!="function"){if(K1(g||p)===null)continue;break}var T=$u(p);T!==null&&(u.splice(c,3),c-=3,qv(T,{pending:!0,data:S,method:p.method,action:g},g,S))}}))}function uc(u){function c(H){return vy(H,u)}oo!==null&&vy(oo,u),lo!==null&&vy(lo,u),uo!==null&&vy(uo,u),lf.forEach(c),uf.forEach(c);for(var p=0;p<co.length;p++){var g=co[p];g.blockedOn===u&&(g.blockedOn=null)}for(;0<co.length&&(p=co[0],p.blockedOn===null);)oR(p),p.blockedOn===null&&co.shift();if(p=(u.ownerDocument||u).$$reactFormReplay,p!=null)for(g=0;g<p.length;g+=3){var S=p[g],T=p[g+1],I=S[Ls]||null;if(typeof T=="function")I||uR(p);else if(I){var z=null;if(T&&T.hasAttribute("formAction")){if(S=T,I=T[Ls]||null)z=I.formAction;else if(K1(S)!==null)continue}else z=I.action;typeof z=="function"?p[g+1]=z:(p.splice(g,3),g-=3),uR(p)}}}function cR(){function u(T){T.canIntercept&&T.info==="react-transition"&&T.intercept({handler:function(){return new Promise(function(I){return S=I})},focusReset:"manual",scroll:"manual"})}function c(){S!==null&&(S(),S=null),g||setTimeout(p,20)}function p(){if(!g&&!navigation.transition){var T=navigation.currentEntry;T&&T.url!=null&&navigation.navigate(T.url,{state:T.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var g=!1,S=null;return navigation.addEventListener("navigate",u),navigation.addEventListener("navigatesuccess",c),navigation.addEventListener("navigateerror",c),setTimeout(p,100),function(){g=!0,navigation.removeEventListener("navigate",u),navigation.removeEventListener("navigatesuccess",c),navigation.removeEventListener("navigateerror",c),S!==null&&(S(),S=null)}}}function Y1(u){this._internalRoot=u}Ty.prototype.render=Y1.prototype.render=function(u){var c=this._internalRoot;if(c===null)throw Error(s(409));var p=c.current,g=hr();tR(p,g,u,c,null,null)},Ty.prototype.unmount=Y1.prototype.unmount=function(){var u=this._internalRoot;if(u!==null){this._internalRoot=null;var c=u.containerInfo;tR(u.current,2,null,u,null,null),sy(),c[ku]=null}};function Ty(u){this._internalRoot=u}Ty.prototype.unstable_scheduleHydration=function(u){if(u){var c=w$();u={blockedOn:null,target:u,priority:c};for(var p=0;p<co.length&&c!==0&&c<co[p].priority;p++);co.splice(p,0,u),p===0&&oR(u)}};var hR=e.version;if(hR!=="19.2.3")throw Error(s(527,hR,"19.2.3"));U.findDOMNode=function(u){var c=u._reactInternals;if(c===void 0)throw typeof u.render=="function"?Error(s(188)):(u=Object.keys(u).join(","),Error(s(268,u)));return u=h(c),u=u!==null?d(u):null,u=u===null?null:u.stateNode,u};var EG={bundleType:0,version:"19.2.3",rendererPackageName:"react-dom",currentDispatcherRef:B,reconcilerVersion:"19.2.3"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Cy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Cy.isDisabled&&Cy.supportsFiber)try{ka=Cy.inject(EG),Cs=Cy}catch{}}return df.createRoot=function(u,c){if(!r(u))throw Error(s(299));var p=!1,g="",S=b_,T=x_,I=w_;return c!=null&&(c.unstable_strictMode===!0&&(p=!0),c.identifierPrefix!==void 0&&(g=c.identifierPrefix),c.onUncaughtError!==void 0&&(S=c.onUncaughtError),c.onCaughtError!==void 0&&(T=c.onCaughtError),c.onRecoverableError!==void 0&&(I=c.onRecoverableError)),c=QA(u,1,!1,null,null,p,g,null,S,T,I,cR),u[ku]=c.current,A1(u),new Y1(c)},df.hydrateRoot=function(u,c,p){if(!r(u))throw Error(s(299));var g=!1,S="",T=b_,I=x_,z=w_,H=null;return p!=null&&(p.unstable_strictMode===!0&&(g=!0),p.identifierPrefix!==void 0&&(S=p.identifierPrefix),p.onUncaughtError!==void 0&&(T=p.onUncaughtError),p.onCaughtError!==void 0&&(I=p.onCaughtError),p.onRecoverableError!==void 0&&(z=p.onRecoverableError),p.formState!==void 0&&(H=p.formState)),c=QA(u,1,!0,c,p??null,g,S,H,T,I,z,cR),c.context=eR(null),p=c.current,g=hr(),g=Bw(g),S=Xi(g),S.callback=null,Yi(p,S,g),p=g,c.current.lanes=p,wd(c,p),Aa(c),u[ku]=c.current,A1(u),new Ty(c)},df.version="19.2.3",df}var vR;function BG(){if(vR)return Q1.exports;vR=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),Q1.exports=PG(),Q1.exports}var VG=BG();const UG=TC(VG),NC=Ce.createContext({});function kC(n){const e=Ce.useRef(null);return e.current===null&&(e.current=n()),e.current}const EC=typeof window<"u",Q3=EC?Ce.useLayoutEffect:Ce.useEffect,ib=Ce.createContext(null);function $C(n,e){n.indexOf(e)===-1&&n.push(e)}function IC(n,e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}const Ti=(n,e,t)=>t>e?e:t<n?n:t;let _C=()=>{};const Ci={},eF=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);function tF(n){return typeof n=="object"&&n!==null}const nF=n=>/^0[^.\s]+$/u.test(n);function AC(n){let e;return()=>(e===void 0&&(e=n()),e)}const Hr=n=>n,jG=(n,e)=>t=>e(n(t)),gp=(...n)=>n.reduce(jG),Pf=(n,e,t)=>{const s=e-n;return s===0?1:(t-n)/s};class RC{constructor(){this.subscriptions=[]}add(e){return $C(this.subscriptions,e),()=>IC(this.subscriptions,e)}notify(e,t,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](e,t,s);else for(let a=0;a<r;a++){const i=this.subscriptions[a];i&&i(e,t,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const Ma=n=>n*1e3,jr=n=>n/1e3;function sF(n,e){return e?n*(1e3/e):0}const rF=(n,e,t)=>(((1-3*t+3*e)*n+(3*t-6*e))*n+3*e)*n,WG=1e-7,GG=12;function HG(n,e,t,s,r){let a,i,o=0;do i=e+(t-e)/2,a=rF(i,s,r)-n,a>0?t=i:e=i;while(Math.abs(a)>WG&&++o<GG);return i}function yp(n,e,t,s){if(n===e&&t===s)return Hr;const r=a=>HG(a,0,1,n,t);return a=>a===0||a===1?a:rF(r(a),e,s)}const aF=n=>e=>e<=.5?n(2*e)/2:(2-n(2*(1-e)))/2,iF=n=>e=>1-n(1-e),oF=yp(.33,1.53,.69,.99),DC=iF(oF),lF=aF(DC),uF=n=>(n*=2)<1?.5*DC(n):.5*(2-Math.pow(2,-10*(n-1))),OC=n=>1-Math.sin(Math.acos(n)),cF=iF(OC),hF=aF(OC),qG=yp(.42,0,1,1),KG=yp(0,0,.58,1),dF=yp(.42,0,.58,1),XG=n=>Array.isArray(n)&&typeof n[0]!="number",fF=n=>Array.isArray(n)&&typeof n[0]=="number",YG={linear:Hr,easeIn:qG,easeInOut:dF,easeOut:KG,circIn:OC,circInOut:hF,circOut:cF,backIn:DC,backInOut:lF,backOut:oF,anticipate:uF},JG=n=>typeof n=="string",SR=n=>{if(fF(n)){_C(n.length===4);const[e,t,s,r]=n;return yp(e,t,s,r)}else if(JG(n))return YG[n];return n},Ny=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];function ZG(n,e){let t=new Set,s=new Set,r=!1,a=!1;const i=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1};function l(d){i.has(d)&&(h.schedule(d),n()),d(o)}const h={schedule:(d,f=!1,m=!1)=>{const b=m&&r?t:s;return f&&i.add(d),b.has(d)||b.add(d),d},cancel:d=>{s.delete(d),i.delete(d)},process:d=>{if(o=d,r){a=!0;return}r=!0,[t,s]=[s,t],t.forEach(l),t.clear(),r=!1,a&&(a=!1,h.process(d))}};return h}const QG=40;function pF(n,e){let t=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},a=()=>t=!0,i=Ny.reduce((N,k)=>(N[k]=ZG(a),N),{}),{setup:o,read:l,resolveKeyframes:h,preUpdate:d,update:f,preRender:m,render:y,postRender:b}=i,x=()=>{const N=Ci.useManualTiming?r.timestamp:performance.now();t=!1,Ci.useManualTiming||(r.delta=s?1e3/60:Math.max(Math.min(N-r.timestamp,QG),1)),r.timestamp=N,r.isProcessing=!0,o.process(r),l.process(r),h.process(r),d.process(r),f.process(r),m.process(r),y.process(r),b.process(r),r.isProcessing=!1,t&&e&&(s=!1,n(x))},w=()=>{t=!0,s=!0,r.isProcessing||n(x)};return{schedule:Ny.reduce((N,k)=>{const E=i[k];return N[k]=(_,R=!1,D=!1)=>(t||w(),E.schedule(_,R,D)),N},{}),cancel:N=>{for(let k=0;k<Ny.length;k++)i[Ny[k]].cancel(N)},state:r,steps:i}}const{schedule:Xt,cancel:ko,state:us,steps:sS}=pF(typeof requestAnimationFrame<"u"?requestAnimationFrame:Hr,!0);let Ky;function e5(){Ky=void 0}const Ks={now:()=>(Ky===void 0&&Ks.set(us.isProcessing||Ci.useManualTiming?us.timestamp:performance.now()),Ky),set:n=>{Ky=n,queueMicrotask(e5)}},mF=n=>e=>typeof e=="string"&&e.startsWith(n),gF=mF("--"),t5=mF("var(--"),FC=n=>t5(n)?n5.test(n.split("/*")[0].trim()):!1,n5=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,Jc={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},Bf={...Jc,transform:n=>Ti(0,1,n)},ky={...Jc,default:1},_f=n=>Math.round(n*1e5)/1e5,LC=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function s5(n){return n==null}const r5=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,MC=(n,e)=>t=>!!(typeof t=="string"&&r5.test(t)&&t.startsWith(n)||e&&!s5(t)&&Object.prototype.hasOwnProperty.call(t,e)),yF=(n,e,t)=>s=>{if(typeof s!="string")return s;const[r,a,i,o]=s.match(LC);return{[n]:parseFloat(r),[e]:parseFloat(a),[t]:parseFloat(i),alpha:o!==void 0?parseFloat(o):1}},a5=n=>Ti(0,255,n),rS={...Jc,transform:n=>Math.round(a5(n))},Dl={test:MC("rgb","red"),parse:yF("red","green","blue"),transform:({red:n,green:e,blue:t,alpha:s=1})=>"rgba("+rS.transform(n)+", "+rS.transform(e)+", "+rS.transform(t)+", "+_f(Bf.transform(s))+")"};function i5(n){let e="",t="",s="",r="";return n.length>5?(e=n.substring(1,3),t=n.substring(3,5),s=n.substring(5,7),r=n.substring(7,9)):(e=n.substring(1,2),t=n.substring(2,3),s=n.substring(3,4),r=n.substring(4,5),e+=e,t+=t,s+=s,r+=r),{red:parseInt(e,16),green:parseInt(t,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const GS={test:MC("#"),parse:i5,transform:Dl.transform},bp=n=>({test:e=>typeof e=="string"&&e.endsWith(n)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${n}`}),fo=bp("deg"),za=bp("%"),Xe=bp("px"),o5=bp("vh"),l5=bp("vw"),TR={...za,parse:n=>za.parse(n)/100,transform:n=>za.transform(n*100)},Cc={test:MC("hsl","hue"),parse:yF("hue","saturation","lightness"),transform:({hue:n,saturation:e,lightness:t,alpha:s=1})=>"hsla("+Math.round(n)+", "+za.transform(_f(e))+", "+za.transform(_f(t))+", "+_f(Bf.transform(s))+")"},Nn={test:n=>Dl.test(n)||GS.test(n)||Cc.test(n),parse:n=>Dl.test(n)?Dl.parse(n):Cc.test(n)?Cc.parse(n):GS.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?Dl.transform(n):Cc.transform(n),getAnimatableNone:n=>{const e=Nn.parse(n);return e.alpha=0,Nn.transform(e)}},u5=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function c5(n){return isNaN(n)&&typeof n=="string"&&(n.match(LC)?.length||0)+(n.match(u5)?.length||0)>0}const bF="number",xF="color",h5="var",d5="var(",CR="${}",f5=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Vf(n){const e=n.toString(),t=[],s={color:[],number:[],var:[]},r=[];let a=0;const o=e.replace(f5,l=>(Nn.test(l)?(s.color.push(a),r.push(xF),t.push(Nn.parse(l))):l.startsWith(d5)?(s.var.push(a),r.push(h5),t.push(l)):(s.number.push(a),r.push(bF),t.push(parseFloat(l))),++a,CR)).split(CR);return{values:t,split:o,indexes:s,types:r}}function wF(n){return Vf(n).values}function vF(n){const{split:e,types:t}=Vf(n),s=e.length;return r=>{let a="";for(let i=0;i<s;i++)if(a+=e[i],r[i]!==void 0){const o=t[i];o===bF?a+=_f(r[i]):o===xF?a+=Nn.transform(r[i]):a+=r[i]}return a}}const p5=n=>typeof n=="number"?0:Nn.test(n)?Nn.getAnimatableNone(n):n;function m5(n){const e=wF(n);return vF(n)(e.map(p5))}const Eo={test:c5,parse:wF,createTransformer:vF,getAnimatableNone:m5};function aS(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function g5({hue:n,saturation:e,lightness:t,alpha:s}){n/=360,e/=100,t/=100;let r=0,a=0,i=0;if(!e)r=a=i=t;else{const o=t<.5?t*(1+e):t+e-t*e,l=2*t-o;r=aS(l,o,n+1/3),a=aS(l,o,n),i=aS(l,o,n-1/3)}return{red:Math.round(r*255),green:Math.round(a*255),blue:Math.round(i*255),alpha:s}}function m0(n,e){return t=>t>0?e:n}const en=(n,e,t)=>n+(e-n)*t,iS=(n,e,t)=>{const s=n*n,r=t*(e*e-s)+s;return r<0?0:Math.sqrt(r)},y5=[GS,Dl,Cc],b5=n=>y5.find(e=>e.test(n));function NR(n){const e=b5(n);if(!e)return!1;let t=e.parse(n);return e===Cc&&(t=g5(t)),t}const kR=(n,e)=>{const t=NR(n),s=NR(e);if(!t||!s)return m0(n,e);const r={...t};return a=>(r.red=iS(t.red,s.red,a),r.green=iS(t.green,s.green,a),r.blue=iS(t.blue,s.blue,a),r.alpha=en(t.alpha,s.alpha,a),Dl.transform(r))},HS=new Set(["none","hidden"]);function x5(n,e){return HS.has(n)?t=>t<=0?n:e:t=>t>=1?e:n}function w5(n,e){return t=>en(n,e,t)}function zC(n){return typeof n=="number"?w5:typeof n=="string"?FC(n)?m0:Nn.test(n)?kR:T5:Array.isArray(n)?SF:typeof n=="object"?Nn.test(n)?kR:v5:m0}function SF(n,e){const t=[...n],s=t.length,r=n.map((a,i)=>zC(a)(a,e[i]));return a=>{for(let i=0;i<s;i++)t[i]=r[i](a);return t}}function v5(n,e){const t={...n,...e},s={};for(const r in t)n[r]!==void 0&&e[r]!==void 0&&(s[r]=zC(n[r])(n[r],e[r]));return r=>{for(const a in s)t[a]=s[a](r);return t}}function S5(n,e){const t=[],s={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const a=e.types[r],i=n.indexes[a][s[a]],o=n.values[i]??0;t[r]=o,s[a]++}return t}const T5=(n,e)=>{const t=Eo.createTransformer(e),s=Vf(n),r=Vf(e);return s.indexes.var.length===r.indexes.var.length&&s.indexes.color.length===r.indexes.color.length&&s.indexes.number.length>=r.indexes.number.length?HS.has(n)&&!r.values.length||HS.has(e)&&!s.values.length?x5(n,e):gp(SF(S5(s,r),r.values),t):m0(n,e)};function TF(n,e,t){return typeof n=="number"&&typeof e=="number"&&typeof t=="number"?en(n,e,t):zC(n)(n,e)}const C5=n=>{const e=({timestamp:t})=>n(t);return{start:(t=!0)=>Xt.update(e,t),stop:()=>ko(e),now:()=>us.isProcessing?us.timestamp:Ks.now()}},CF=(n,e,t=10)=>{let s="";const r=Math.max(Math.round(e/t),2);for(let a=0;a<r;a++)s+=Math.round(n(a/(r-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`},g0=2e4;function PC(n){let e=0;const t=50;let s=n.next(e);for(;!s.done&&e<g0;)e+=t,s=n.next(e);return e>=g0?1/0:e}function N5(n,e=100,t){const s=t({...n,keyframes:[0,e]}),r=Math.min(PC(s),g0);return{type:"keyframes",ease:a=>s.next(r*a).value/e,duration:jr(r)}}const k5=5;function NF(n,e,t){const s=Math.max(e-k5,0);return sF(t-n(s),e-s)}const on={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},oS=.001;function E5({duration:n=on.duration,bounce:e=on.bounce,velocity:t=on.velocity,mass:s=on.mass}){let r,a,i=1-e;i=Ti(on.minDamping,on.maxDamping,i),n=Ti(on.minDuration,on.maxDuration,jr(n)),i<1?(r=h=>{const d=h*i,f=d*n,m=d-t,y=qS(h,i),b=Math.exp(-f);return oS-m/y*b},a=h=>{const f=h*i*n,m=f*t+t,y=Math.pow(i,2)*Math.pow(h,2)*n,b=Math.exp(-f),x=qS(Math.pow(h,2),i);return(-r(h)+oS>0?-1:1)*((m-y)*b)/x}):(r=h=>{const d=Math.exp(-h*n),f=(h-t)*n+1;return-oS+d*f},a=h=>{const d=Math.exp(-h*n),f=(t-h)*(n*n);return d*f});const o=5/n,l=I5(r,a,o);if(n=Ma(n),isNaN(l))return{stiffness:on.stiffness,damping:on.damping,duration:n};{const h=Math.pow(l,2)*s;return{stiffness:h,damping:i*2*Math.sqrt(s*h),duration:n}}}const $5=12;function I5(n,e,t){let s=t;for(let r=1;r<$5;r++)s=s-n(s)/e(s);return s}function qS(n,e){return n*Math.sqrt(1-e*e)}const _5=["duration","bounce"],A5=["stiffness","damping","mass"];function ER(n,e){return e.some(t=>n[t]!==void 0)}function R5(n){let e={velocity:on.velocity,stiffness:on.stiffness,damping:on.damping,mass:on.mass,isResolvedFromDuration:!1,...n};if(!ER(n,A5)&&ER(n,_5))if(n.visualDuration){const t=n.visualDuration,s=2*Math.PI/(t*1.2),r=s*s,a=2*Ti(.05,1,1-(n.bounce||0))*Math.sqrt(r);e={...e,mass:on.mass,stiffness:r,damping:a}}else{const t=E5(n);e={...e,...t,mass:on.mass},e.isResolvedFromDuration=!0}return e}function y0(n=on.visualDuration,e=on.bounce){const t=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:e}:n;let{restSpeed:s,restDelta:r}=t;const a=t.keyframes[0],i=t.keyframes[t.keyframes.length-1],o={done:!1,value:a},{stiffness:l,damping:h,mass:d,duration:f,velocity:m,isResolvedFromDuration:y}=R5({...t,velocity:-jr(t.velocity||0)}),b=m||0,x=h/(2*Math.sqrt(l*d)),w=i-a,v=jr(Math.sqrt(l/d)),C=Math.abs(w)<5;s||(s=C?on.restSpeed.granular:on.restSpeed.default),r||(r=C?on.restDelta.granular:on.restDelta.default);let N;if(x<1){const E=qS(v,x);N=_=>{const R=Math.exp(-x*v*_);return i-R*((b+x*v*w)/E*Math.sin(E*_)+w*Math.cos(E*_))}}else if(x===1)N=E=>i-Math.exp(-v*E)*(w+(b+v*w)*E);else{const E=v*Math.sqrt(x*x-1);N=_=>{const R=Math.exp(-x*v*_),D=Math.min(E*_,300);return i-R*((b+x*v*w)*Math.sinh(D)+E*w*Math.cosh(D))/E}}const k={calculatedDuration:y&&f||null,next:E=>{const _=N(E);if(y)o.done=E>=f;else{let R=E===0?b:0;x<1&&(R=E===0?Ma(b):NF(N,E,_));const D=Math.abs(R)<=s,F=Math.abs(i-_)<=r;o.done=D&&F}return o.value=o.done?i:_,o},toString:()=>{const E=Math.min(PC(k),g0),_=CF(R=>k.next(E*R).value,E,30);return E+"ms "+_},toTransition:()=>{}};return k}y0.applyToOptions=n=>{const e=N5(n,100,y0);return n.ease=e.ease,n.duration=Ma(e.duration),n.type="keyframes",n};function KS({keyframes:n,velocity:e=0,power:t=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:a=500,modifyTarget:i,min:o,max:l,restDelta:h=.5,restSpeed:d}){const f=n[0],m={done:!1,value:f},y=D=>o!==void 0&&D<o||l!==void 0&&D>l,b=D=>o===void 0?l:l===void 0||Math.abs(o-D)<Math.abs(l-D)?o:l;let x=t*e;const w=f+x,v=i===void 0?w:i(w);v!==w&&(x=v-f);const C=D=>-x*Math.exp(-D/s),N=D=>v+C(D),k=D=>{const F=C(D),L=N(D);m.done=Math.abs(F)<=h,m.value=m.done?v:L};let E,_;const R=D=>{y(m.value)&&(E=D,_=y0({keyframes:[m.value,b(m.value)],velocity:NF(N,D,m.value),damping:r,stiffness:a,restDelta:h,restSpeed:d}))};return R(0),{calculatedDuration:null,next:D=>{let F=!1;return!_&&E===void 0&&(F=!0,k(D),R(D)),E!==void 0&&D>=E?_.next(D-E):(!F&&k(D),m)}}}function D5(n,e,t){const s=[],r=t||Ci.mix||TF,a=n.length-1;for(let i=0;i<a;i++){let o=r(n[i],n[i+1]);if(e){const l=Array.isArray(e)?e[i]||Hr:e;o=gp(l,o)}s.push(o)}return s}function O5(n,e,{clamp:t=!0,ease:s,mixer:r}={}){const a=n.length;if(_C(a===e.length),a===1)return()=>e[0];if(a===2&&e[0]===e[1])return()=>e[1];const i=n[0]===n[1];n[0]>n[a-1]&&(n=[...n].reverse(),e=[...e].reverse());const o=D5(e,s,r),l=o.length,h=d=>{if(i&&d<n[0])return e[0];let f=0;if(l>1)for(;f<n.length-2&&!(d<n[f+1]);f++);const m=Pf(n[f],n[f+1],d);return o[f](m)};return t?d=>h(Ti(n[0],n[a-1],d)):h}function F5(n,e){const t=n[n.length-1];for(let s=1;s<=e;s++){const r=Pf(0,e,s);n.push(en(t,1,r))}}function L5(n){const e=[0];return F5(e,n.length-1),e}function M5(n,e){return n.map(t=>t*e)}function z5(n,e){return n.map(()=>e||dF).splice(0,n.length-1)}function Af({duration:n=300,keyframes:e,times:t,ease:s="easeInOut"}){const r=XG(s)?s.map(SR):SR(s),a={done:!1,value:e[0]},i=M5(t&&t.length===e.length?t:L5(e),n),o=O5(i,e,{ease:Array.isArray(r)?r:z5(e,r)});return{calculatedDuration:n,next:l=>(a.value=o(l),a.done=l>=n,a)}}const P5=n=>n!==null;function BC(n,{repeat:e,repeatType:t="loop"},s,r=1){const a=n.filter(P5),o=r<0||e&&t!=="loop"&&e%2===1?0:a.length-1;return!o||s===void 0?a[o]:s}const B5={decay:KS,inertia:KS,tween:Af,keyframes:Af,spring:y0};function kF(n){typeof n.type=="string"&&(n.type=B5[n.type])}class VC{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise(e=>{this.resolve=e})}notifyFinished(){this.resolve()}then(e,t){return this.finished.then(e,t)}}const V5=n=>n/100;class UC extends VC{constructor(e){super(),this.state="idle",this.startTime=null,this.isStopped=!1,this.currentTime=0,this.holdTime=null,this.playbackSpeed=1,this.stop=()=>{const{motionValue:t}=this.options;t&&t.updatedAt!==Ks.now()&&this.tick(Ks.now()),this.isStopped=!0,this.state!=="idle"&&(this.teardown(),this.options.onStop?.())},this.options=e,this.initAnimation(),this.play(),e.autoplay===!1&&this.pause()}initAnimation(){const{options:e}=this;kF(e);const{type:t=Af,repeat:s=0,repeatDelay:r=0,repeatType:a,velocity:i=0}=e;let{keyframes:o}=e;const l=t||Af;l!==Af&&typeof o[0]!="number"&&(this.mixKeyframes=gp(V5,TF(o[0],o[1])),o=[0,100]);const h=l({...e,keyframes:o});a==="mirror"&&(this.mirroredGenerator=l({...e,keyframes:[...o].reverse(),velocity:-i})),h.calculatedDuration===null&&(h.calculatedDuration=PC(h));const{calculatedDuration:d}=h;this.calculatedDuration=d,this.resolvedDuration=d+r,this.totalDuration=this.resolvedDuration*(s+1)-r,this.generator=h}updateTime(e){const t=Math.round(e-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=t}tick(e,t=!1){const{generator:s,totalDuration:r,mixKeyframes:a,mirroredGenerator:i,resolvedDuration:o,calculatedDuration:l}=this;if(this.startTime===null)return s.next(0);const{delay:h=0,keyframes:d,repeat:f,repeatType:m,repeatDelay:y,type:b,onUpdate:x,finalKeyframe:w}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-r/this.speed,this.startTime)),t?this.currentTime=e:this.updateTime(e);const v=this.currentTime-h*(this.playbackSpeed>=0?1:-1),C=this.playbackSpeed>=0?v<0:v>r;this.currentTime=Math.max(v,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=r);let N=this.currentTime,k=s;if(f){const D=Math.min(this.currentTime,r)/o;let F=Math.floor(D),L=D%1;!L&&D>=1&&(L=1),L===1&&F--,F=Math.min(F,f+1),F%2&&(m==="reverse"?(L=1-L,y&&(L-=y/o)):m==="mirror"&&(k=i)),N=Ti(0,1,L)*o}const E=C?{done:!1,value:d[0]}:k.next(N);a&&(E.value=a(E.value));let{done:_}=E;!C&&l!==null&&(_=this.playbackSpeed>=0?this.currentTime>=r:this.currentTime<=0);const R=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&_);return R&&b!==KS&&(E.value=BC(d,this.options,w,this.speed)),x&&x(E.value),R&&this.finish(),E}then(e,t){return this.finished.then(e,t)}get duration(){return jr(this.calculatedDuration)}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+jr(e)}get time(){return jr(this.currentTime)}set time(e){e=Ma(e),this.currentTime=e,this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.playbackSpeed),this.driver?.start(!1)}get speed(){return this.playbackSpeed}set speed(e){this.updateTime(Ks.now());const t=this.playbackSpeed!==e;this.playbackSpeed=e,t&&(this.time=jr(this.currentTime))}play(){if(this.isStopped)return;const{driver:e=C5,startTime:t}=this.options;this.driver||(this.driver=e(r=>this.tick(r))),this.options.onPlay?.();const s=this.driver.now();this.state==="finished"?(this.updateFinished(),this.startTime=s):this.holdTime!==null?this.startTime=s-this.holdTime:this.startTime||(this.startTime=t??s),this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration),this.holdTime=null,this.state="running",this.driver.start()}pause(){this.state="paused",this.updateTime(Ks.now()),this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play(),this.state="finished",this.holdTime=null}finish(){this.notifyFinished(),this.teardown(),this.state="finished",this.options.onComplete?.()}cancel(){this.holdTime=null,this.startTime=0,this.tick(0),this.teardown(),this.options.onCancel?.()}teardown(){this.state="idle",this.stopDriver(),this.startTime=this.holdTime=null}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}attachTimeline(e){return this.options.allowFlatten&&(this.options.type="keyframes",this.options.ease="linear",this.initAnimation()),this.driver?.stop(),e.observe(this)}}function U5(n){for(let e=1;e<n.length;e++)n[e]??(n[e]=n[e-1])}const Ol=n=>n*180/Math.PI,XS=n=>{const e=Ol(Math.atan2(n[1],n[0]));return YS(e)},j5={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:n=>(Math.abs(n[0])+Math.abs(n[3]))/2,rotate:XS,rotateZ:XS,skewX:n=>Ol(Math.atan(n[1])),skewY:n=>Ol(Math.atan(n[2])),skew:n=>(Math.abs(n[1])+Math.abs(n[2]))/2},YS=n=>(n=n%360,n<0&&(n+=360),n),$R=XS,IR=n=>Math.sqrt(n[0]*n[0]+n[1]*n[1]),_R=n=>Math.sqrt(n[4]*n[4]+n[5]*n[5]),W5={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:IR,scaleY:_R,scale:n=>(IR(n)+_R(n))/2,rotateX:n=>YS(Ol(Math.atan2(n[6],n[5]))),rotateY:n=>YS(Ol(Math.atan2(-n[2],n[0]))),rotateZ:$R,rotate:$R,skewX:n=>Ol(Math.atan(n[4])),skewY:n=>Ol(Math.atan(n[1])),skew:n=>(Math.abs(n[1])+Math.abs(n[4]))/2};function JS(n){return n.includes("scale")?1:0}function ZS(n,e){if(!n||n==="none")return JS(e);const t=n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s,r;if(t)s=W5,r=t;else{const o=n.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=j5,r=o}if(!r)return JS(e);const a=s[e],i=r[1].split(",").map(H5);return typeof a=="function"?a(i):i[a]}const G5=(n,e)=>{const{transform:t="none"}=getComputedStyle(n);return ZS(t,e)};function H5(n){return parseFloat(n.trim())}const Zc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Qc=new Set(Zc),AR=n=>n===Jc||n===Xe,q5=new Set(["x","y","z"]),K5=Zc.filter(n=>!q5.has(n));function X5(n){const e=[];return K5.forEach(t=>{const s=n.getValue(t);s!==void 0&&(e.push([t,s.get()]),s.set(t.startsWith("scale")?1:0))}),e}const zl={width:({x:n},{paddingLeft:e="0",paddingRight:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),height:({y:n},{paddingTop:e="0",paddingBottom:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),top:(n,{top:e})=>parseFloat(e),left:(n,{left:e})=>parseFloat(e),bottom:({y:n},{top:e})=>parseFloat(e)+(n.max-n.min),right:({x:n},{left:e})=>parseFloat(e)+(n.max-n.min),x:(n,{transform:e})=>ZS(e,"x"),y:(n,{transform:e})=>ZS(e,"y")};zl.translateX=zl.x;zl.translateY=zl.y;const Pl=new Set;let QS=!1,eT=!1,tT=!1;function EF(){if(eT){const n=Array.from(Pl).filter(s=>s.needsMeasurement),e=new Set(n.map(s=>s.element)),t=new Map;e.forEach(s=>{const r=X5(s);r.length&&(t.set(s,r),s.render())}),n.forEach(s=>s.measureInitialState()),e.forEach(s=>{s.render();const r=t.get(s);r&&r.forEach(([a,i])=>{s.getValue(a)?.set(i)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}eT=!1,QS=!1,Pl.forEach(n=>n.complete(tT)),Pl.clear()}function $F(){Pl.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(eT=!0)})}function Y5(){tT=!0,$F(),EF(),tT=!1}class jC{constructor(e,t,s,r,a,i=!1){this.state="pending",this.isAsync=!1,this.needsMeasurement=!1,this.unresolvedKeyframes=[...e],this.onComplete=t,this.name=s,this.motionValue=r,this.element=a,this.isAsync=i}scheduleResolve(){this.state="scheduled",this.isAsync?(Pl.add(this),QS||(QS=!0,Xt.read($F),Xt.resolveKeyframes(EF))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:t,element:s,motionValue:r}=this;if(e[0]===null){const a=r?.get(),i=e[e.length-1];if(a!==void 0)e[0]=a;else if(s&&t){const o=s.readValue(t,i);o!=null&&(e[0]=o)}e[0]===void 0&&(e[0]=i),r&&a===void 0&&r.set(e[0])}U5(e)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(e=!1){this.state="complete",this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,e),Pl.delete(this)}cancel(){this.state==="scheduled"&&(Pl.delete(this),this.state="pending")}resume(){this.state==="pending"&&this.scheduleResolve()}}const J5=n=>n.startsWith("--");function Z5(n,e,t){J5(e)?n.style.setProperty(e,t):n.style[e]=t}const Q5=AC(()=>window.ScrollTimeline!==void 0),eH={};function tH(n,e){const t=AC(n);return()=>eH[e]??t()}const IF=tH(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),xf=([n,e,t,s])=>`cubic-bezier(${n}, ${e}, ${t}, ${s})`,RR={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:xf([0,.65,.55,1]),circOut:xf([.55,0,1,.45]),backIn:xf([.31,.01,.66,-.59]),backOut:xf([.33,1.53,.69,.99])};function _F(n,e){if(n)return typeof n=="function"?IF()?CF(n,e):"ease-out":fF(n)?xf(n):Array.isArray(n)?n.map(t=>_F(t,e)||RR.easeOut):RR[n]}function nH(n,e,t,{delay:s=0,duration:r=300,repeat:a=0,repeatType:i="loop",ease:o="easeOut",times:l}={},h=void 0){const d={[e]:t};l&&(d.offset=l);const f=_F(o,r);Array.isArray(f)&&(d.easing=f);const m={delay:s,duration:r,easing:Array.isArray(f)?"linear":f,fill:"both",iterations:a+1,direction:i==="reverse"?"alternate":"normal"};return h&&(m.pseudoElement=h),n.animate(d,m)}function AF(n){return typeof n=="function"&&"applyToOptions"in n}function sH({type:n,...e}){return AF(n)&&IF()?n.applyToOptions(e):(e.duration??(e.duration=300),e.ease??(e.ease="easeOut"),e)}class rH extends VC{constructor(e){if(super(),this.finishedTime=null,this.isStopped=!1,!e)return;const{element:t,name:s,keyframes:r,pseudoElement:a,allowFlatten:i=!1,finalKeyframe:o,onComplete:l}=e;this.isPseudoElement=!!a,this.allowFlatten=i,this.options=e,_C(typeof e.type!="string");const h=sH(e);this.animation=nH(t,s,r,h,a),h.autoplay===!1&&this.animation.pause(),this.animation.onfinish=()=>{if(this.finishedTime=this.time,!a){const d=BC(r,this.options,o,this.speed);this.updateMotionValue?this.updateMotionValue(d):Z5(t,s,d),this.animation.cancel()}l?.(),this.notifyFinished()}}play(){this.isStopped||(this.animation.play(),this.state==="finished"&&this.updateFinished())}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch{}}stop(){if(this.isStopped)return;this.isStopped=!0;const{state:e}=this;e==="idle"||e==="finished"||(this.updateMotionValue?this.updateMotionValue():this.commitStyles(),this.isPseudoElement||this.cancel())}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const e=this.animation.effect?.getComputedTiming?.().duration||0;return jr(Number(e))}get iterationDuration(){const{delay:e=0}=this.options||{};return this.duration+jr(e)}get time(){return jr(Number(this.animation.currentTime)||0)}set time(e){this.finishedTime=null,this.animation.currentTime=Ma(e)}get speed(){return this.animation.playbackRate}set speed(e){e<0&&(this.finishedTime=null),this.animation.playbackRate=e}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(e){this.animation.startTime=e}attachTimeline({timeline:e,observe:t}){return this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"}),this.animation.onfinish=null,e&&Q5()?(this.animation.timeline=e,Hr):t(this)}}const RF={anticipate:uF,backInOut:lF,circInOut:hF};function aH(n){return n in RF}function iH(n){typeof n.ease=="string"&&aH(n.ease)&&(n.ease=RF[n.ease])}const DR=10;class oH extends rH{constructor(e){iH(e),kF(e),super(e),e.startTime&&(this.startTime=e.startTime),this.options=e}updateMotionValue(e){const{motionValue:t,onUpdate:s,onComplete:r,element:a,...i}=this.options;if(!t)return;if(e!==void 0){t.set(e);return}const o=new UC({...i,autoplay:!1}),l=Ma(this.finishedTime??this.time);t.setWithVelocity(o.sample(l-DR).value,o.sample(l).value,DR),o.stop()}}const OR=(n,e)=>e==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(Eo.test(n)||n==="0")&&!n.startsWith("url("));function lH(n){const e=n[0];if(n.length===1)return!0;for(let t=0;t<n.length;t++)if(n[t]!==e)return!0}function uH(n,e,t,s){const r=n[0];if(r===null)return!1;if(e==="display"||e==="visibility")return!0;const a=n[n.length-1],i=OR(r,e),o=OR(a,e);return!i||!o?!1:lH(n)||(t==="spring"||AF(t))&&s}function nT(n){n.duration=0,n.type="keyframes"}const cH=new Set(["opacity","clipPath","filter","transform"]),hH=AC(()=>Object.hasOwnProperty.call(Element.prototype,"animate"));function dH(n){const{motionValue:e,name:t,repeatDelay:s,repeatType:r,damping:a,type:i}=n;if(!(e?.owner?.current instanceof HTMLElement))return!1;const{onUpdate:l,transformTemplate:h}=e.owner.getProps();return hH()&&t&&cH.has(t)&&(t!=="transform"||!h)&&!l&&!s&&r!=="mirror"&&a!==0&&i!=="inertia"}const fH=40;class pH extends VC{constructor({autoplay:e=!0,delay:t=0,type:s="keyframes",repeat:r=0,repeatDelay:a=0,repeatType:i="loop",keyframes:o,name:l,motionValue:h,element:d,...f}){super(),this.stop=()=>{this._animation&&(this._animation.stop(),this.stopTimeline?.()),this.keyframeResolver?.cancel()},this.createdAt=Ks.now();const m={autoplay:e,delay:t,type:s,repeat:r,repeatDelay:a,repeatType:i,name:l,motionValue:h,element:d,...f},y=d?.KeyframeResolver||jC;this.keyframeResolver=new y(o,(b,x,w)=>this.onKeyframesResolved(b,x,m,!w),l,h,d),this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(e,t,s,r){this.keyframeResolver=void 0;const{name:a,type:i,velocity:o,delay:l,isHandoff:h,onUpdate:d}=s;this.resolvedAt=Ks.now(),uH(e,a,i,o)||((Ci.instantAnimations||!l)&&d?.(BC(e,s,t)),e[0]=e[e.length-1],nT(s),s.repeat=0);const m={startTime:r?this.resolvedAt?this.resolvedAt-this.createdAt>fH?this.resolvedAt:this.createdAt:this.createdAt:void 0,finalKeyframe:t,...s,keyframes:e},y=!h&&dH(m)?new oH({...m,element:m.motionValue.owner.current}):new UC(m);y.finished.then(()=>this.notifyFinished()).catch(Hr),this.pendingTimeline&&(this.stopTimeline=y.attachTimeline(this.pendingTimeline),this.pendingTimeline=void 0),this._animation=y}get finished(){return this._animation?this.animation.finished:this._finished}then(e,t){return this.finished.finally(e).then(()=>{})}get animation(){return this._animation||(this.keyframeResolver?.resume(),Y5()),this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(e){this.animation.time=e}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(e){this.animation.speed=e}get startTime(){return this.animation.startTime}attachTimeline(e){return this._animation?this.stopTimeline=this.animation.attachTimeline(e):this.pendingTimeline=e,()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel(),this.keyframeResolver?.cancel()}}const mH=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function gH(n){const e=mH.exec(n);if(!e)return[,];const[,t,s,r]=e;return[`--${t??s}`,r]}function DF(n,e,t=1){const[s,r]=gH(n);if(!s)return;const a=window.getComputedStyle(e).getPropertyValue(s);if(a){const i=a.trim();return eF(i)?parseFloat(i):i}return FC(r)?DF(r,e,t+1):r}function WC(n,e){return n?.[e]??n?.default??n}const OF=new Set(["width","height","top","left","right","bottom",...Zc]),yH={test:n=>n==="auto",parse:n=>n},FF=n=>e=>e.test(n),LF=[Jc,Xe,za,fo,l5,o5,yH],FR=n=>LF.find(FF(n));function bH(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||nF(n):!0}const xH=new Set(["brightness","contrast","saturate","opacity"]);function wH(n){const[e,t]=n.slice(0,-1).split("(");if(e==="drop-shadow")return n;const[s]=t.match(LC)||[];if(!s)return n;const r=t.replace(s,"");let a=xH.has(e)?1:0;return s!==t&&(a*=100),e+"("+a+r+")"}const vH=/\b([a-z-]*)\(.*?\)/gu,sT={...Eo,getAnimatableNone:n=>{const e=n.match(vH);return e?e.map(wH).join(" "):n}},LR={...Jc,transform:Math.round},SH={rotate:fo,rotateX:fo,rotateY:fo,rotateZ:fo,scale:ky,scaleX:ky,scaleY:ky,scaleZ:ky,skew:fo,skewX:fo,skewY:fo,distance:Xe,translateX:Xe,translateY:Xe,translateZ:Xe,x:Xe,y:Xe,z:Xe,perspective:Xe,transformPerspective:Xe,opacity:Bf,originX:TR,originY:TR,originZ:Xe},GC={borderWidth:Xe,borderTopWidth:Xe,borderRightWidth:Xe,borderBottomWidth:Xe,borderLeftWidth:Xe,borderRadius:Xe,radius:Xe,borderTopLeftRadius:Xe,borderTopRightRadius:Xe,borderBottomRightRadius:Xe,borderBottomLeftRadius:Xe,width:Xe,maxWidth:Xe,height:Xe,maxHeight:Xe,top:Xe,right:Xe,bottom:Xe,left:Xe,padding:Xe,paddingTop:Xe,paddingRight:Xe,paddingBottom:Xe,paddingLeft:Xe,margin:Xe,marginTop:Xe,marginRight:Xe,marginBottom:Xe,marginLeft:Xe,backgroundPositionX:Xe,backgroundPositionY:Xe,...SH,zIndex:LR,fillOpacity:Bf,strokeOpacity:Bf,numOctaves:LR},TH={...GC,color:Nn,backgroundColor:Nn,outlineColor:Nn,fill:Nn,stroke:Nn,borderColor:Nn,borderTopColor:Nn,borderRightColor:Nn,borderBottomColor:Nn,borderLeftColor:Nn,filter:sT,WebkitFilter:sT},MF=n=>TH[n];function zF(n,e){let t=MF(n);return t!==sT&&(t=Eo),t.getAnimatableNone?t.getAnimatableNone(e):void 0}const CH=new Set(["auto","none","0"]);function NH(n,e,t){let s=0,r;for(;s<n.length&&!r;){const a=n[s];typeof a=="string"&&!CH.has(a)&&Vf(a).values.length&&(r=n[s]),s++}if(r&&t)for(const a of e)n[a]=zF(t,r)}class kH extends jC{constructor(e,t,s,r,a){super(e,t,s,r,a,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:t,name:s}=this;if(!t||!t.current)return;super.readKeyframes();for(let l=0;l<e.length;l++){let h=e[l];if(typeof h=="string"&&(h=h.trim(),FC(h))){const d=DF(h,t.current);d!==void 0&&(e[l]=d),l===e.length-1&&(this.finalKeyframe=h)}}if(this.resolveNoneKeyframes(),!OF.has(s)||e.length!==2)return;const[r,a]=e,i=FR(r),o=FR(a);if(i!==o)if(AR(i)&&AR(o))for(let l=0;l<e.length;l++){const h=e[l];typeof h=="string"&&(e[l]=parseFloat(h))}else zl[s]&&(this.needsMeasurement=!0)}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:t}=this,s=[];for(let r=0;r<e.length;r++)(e[r]===null||bH(e[r]))&&s.push(r);s.length&&NH(e,s,t)}measureInitialState(){const{element:e,unresolvedKeyframes:t,name:s}=this;if(!e||!e.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=zl[s](e.measureViewportBox(),window.getComputedStyle(e.current)),t[0]=this.measuredOrigin;const r=t[t.length-1];r!==void 0&&e.getValue(s,r).jump(r,!1)}measureEndState(){const{element:e,name:t,unresolvedKeyframes:s}=this;if(!e||!e.current)return;const r=e.getValue(t);r&&r.jump(this.measuredOrigin,!1);const a=s.length-1,i=s[a];s[a]=zl[t](e.measureViewportBox(),window.getComputedStyle(e.current)),i!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=i),this.removedTransforms?.length&&this.removedTransforms.forEach(([o,l])=>{e.getValue(o).set(l)}),this.resolveNoneKeyframes()}}function EH(n,e,t){if(n instanceof EventTarget)return[n];if(typeof n=="string"){let s=document;const r=t?.[n]??s.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}const PF=(n,e)=>e&&typeof n=="number"?e.transform(n):n;function BF(n){return tF(n)&&"offsetHeight"in n}const MR=30,$H=n=>!isNaN(parseFloat(n));class IH{constructor(e,t={}){this.canTrackVelocity=null,this.events={},this.updateAndNotify=s=>{const r=Ks.now();if(this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&(this.events.change?.notify(this.current),this.dependents))for(const a of this.dependents)a.dirty()},this.hasAnimated=!1,this.setCurrent(e),this.owner=t.owner}setCurrent(e){this.current=e,this.updatedAt=Ks.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=$H(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new RC);const s=this.events[e].add(t);return e==="change"?()=>{s(),Xt.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e){this.passiveEffect?this.passiveEffect(e,this.updateAndNotify):this.updateAndNotify(e)}setWithVelocity(e,t,s){this.set(t),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-s}jump(e,t=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,t&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(e){this.dependents||(this.dependents=new Set),this.dependents.add(e)}removeDependent(e){this.dependents&&this.dependents.delete(e)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const e=Ks.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>MR)return 0;const t=Math.min(this.updatedAt-this.prevUpdatedAt,MR);return sF(parseFloat(this.current)-parseFloat(this.prevFrameValue),t)}start(e){return this.stop(),new Promise(t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear(),this.events.destroy?.notify(),this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function Fc(n,e){return new IH(n,e)}const{schedule:HC}=pF(queueMicrotask,!1),ia={x:!1,y:!1};function VF(){return ia.x||ia.y}function _H(n){return n==="x"||n==="y"?ia[n]?null:(ia[n]=!0,()=>{ia[n]=!1}):ia.x||ia.y?null:(ia.x=ia.y=!0,()=>{ia.x=ia.y=!1})}function UF(n,e){const t=EH(n),s=new AbortController,r={passive:!0,...e,signal:s.signal};return[t,r,()=>s.abort()]}function zR(n){return!(n.pointerType==="touch"||VF())}function AH(n,e,t={}){const[s,r,a]=UF(n,t),i=o=>{if(!zR(o))return;const{target:l}=o,h=e(l,o);if(typeof h!="function"||!l)return;const d=f=>{zR(f)&&(h(f),l.removeEventListener("pointerleave",d))};l.addEventListener("pointerleave",d,r)};return s.forEach(o=>{o.addEventListener("pointerenter",i,r)}),a}const jF=(n,e)=>e?n===e?!0:jF(n,e.parentElement):!1,qC=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,RH=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function DH(n){return RH.has(n.tagName)||n.tabIndex!==-1}const Xy=new WeakSet;function PR(n){return e=>{e.key==="Enter"&&n(e)}}function lS(n,e){n.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const OH=(n,e)=>{const t=n.currentTarget;if(!t)return;const s=PR(()=>{if(Xy.has(t))return;lS(t,"down");const r=PR(()=>{lS(t,"up")}),a=()=>lS(t,"cancel");t.addEventListener("keyup",r,e),t.addEventListener("blur",a,e)});t.addEventListener("keydown",s,e),t.addEventListener("blur",()=>t.removeEventListener("keydown",s),e)};function BR(n){return qC(n)&&!VF()}function FH(n,e,t={}){const[s,r,a]=UF(n,t),i=o=>{const l=o.currentTarget;if(!BR(o))return;Xy.add(l);const h=e(l,o),d=(y,b)=>{window.removeEventListener("pointerup",f),window.removeEventListener("pointercancel",m),Xy.has(l)&&Xy.delete(l),BR(y)&&typeof h=="function"&&h(y,{success:b})},f=y=>{d(y,l===window||l===document||t.useGlobalTarget||jF(l,y.target))},m=y=>{d(y,!1)};window.addEventListener("pointerup",f,r),window.addEventListener("pointercancel",m,r)};return s.forEach(o=>{(t.useGlobalTarget?window:o).addEventListener("pointerdown",i,r),BF(o)&&(o.addEventListener("focus",h=>OH(h,r)),!DH(o)&&!o.hasAttribute("tabindex")&&(o.tabIndex=0))}),a}function WF(n){return tF(n)&&"ownerSVGElement"in n}function LH(n){return WF(n)&&n.tagName==="svg"}const ys=n=>!!(n&&n.getVelocity),MH=[...LF,Nn,Eo],zH=n=>MH.find(FF(n)),KC=Ce.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});function VR(n,e){if(typeof n=="function")return n(e);n!=null&&(n.current=e)}function PH(...n){return e=>{let t=!1;const s=n.map(r=>{const a=VR(r,e);return!t&&typeof a=="function"&&(t=!0),a});if(t)return()=>{for(let r=0;r<s.length;r++){const a=s[r];typeof a=="function"?a():VR(n[r],null)}}}}function BH(...n){return Ce.useCallback(PH(...n),n)}class VH extends Ce.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const s=t.offsetParent,r=BF(s)&&s.offsetWidth||0,a=this.props.sizeRef.current;a.height=t.offsetHeight||0,a.width=t.offsetWidth||0,a.top=t.offsetTop,a.left=t.offsetLeft,a.right=r-a.width-a.left}return null}componentDidUpdate(){}render(){return this.props.children}}function UH({children:n,isPresent:e,anchorX:t,root:s}){const r=Ce.useId(),a=Ce.useRef(null),i=Ce.useRef({width:0,height:0,top:0,left:0,right:0}),{nonce:o}=Ce.useContext(KC),l=BH(a,n?.ref);return Ce.useInsertionEffect(()=>{const{width:h,height:d,top:f,left:m,right:y}=i.current;if(e||!a.current||!h||!d)return;const b=t==="left"?`left: ${m}`:`right: ${y}`;a.current.dataset.motionPopId=r;const x=document.createElement("style");o&&(x.nonce=o);const w=s??document.head;return w.appendChild(x),x.sheet&&x.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${h}px !important;
            height: ${d}px !important;
            ${b}px !important;
            top: ${f}px !important;
          }
        `),()=>{w.contains(x)&&w.removeChild(x)}},[e]),me.jsx(VH,{isPresent:e,childRef:a,sizeRef:i,children:Ce.cloneElement(n,{ref:l})})}const jH=({children:n,initial:e,isPresent:t,onExitComplete:s,custom:r,presenceAffectsLayout:a,mode:i,anchorX:o,root:l})=>{const h=kC(WH),d=Ce.useId();let f=!0,m=Ce.useMemo(()=>(f=!1,{id:d,initial:e,isPresent:t,custom:r,onExitComplete:y=>{h.set(y,!0);for(const b of h.values())if(!b)return;s&&s()},register:y=>(h.set(y,!1),()=>h.delete(y))}),[t,h,s]);return a&&f&&(m={...m}),Ce.useMemo(()=>{h.forEach((y,b)=>h.set(b,!1))},[t]),Ce.useEffect(()=>{!t&&!h.size&&s&&s()},[t]),i==="popLayout"&&(n=me.jsx(UH,{isPresent:t,anchorX:o,root:l,children:n})),me.jsx(ib.Provider,{value:m,children:n})};function WH(){return new Map}function GF(n=!0){const e=Ce.useContext(ib);if(e===null)return[!0,null];const{isPresent:t,onExitComplete:s,register:r}=e,a=Ce.useId();Ce.useEffect(()=>{if(n)return r(a)},[n]);const i=Ce.useCallback(()=>n&&s&&s(a),[a,s,n]);return!t&&s?[!1,i]:[!0]}const Ey=n=>n.key||"";function UR(n){const e=[];return Ce.Children.forEach(n,t=>{Ce.isValidElement(t)&&e.push(t)}),e}const GH=({children:n,custom:e,initial:t=!0,onExitComplete:s,presenceAffectsLayout:r=!0,mode:a="sync",propagate:i=!1,anchorX:o="left",root:l})=>{const[h,d]=GF(i),f=Ce.useMemo(()=>UR(n),[n]),m=i&&!h?[]:f.map(Ey),y=Ce.useRef(!0),b=Ce.useRef(f),x=kC(()=>new Map),[w,v]=Ce.useState(f),[C,N]=Ce.useState(f);Q3(()=>{y.current=!1,b.current=f;for(let _=0;_<C.length;_++){const R=Ey(C[_]);m.includes(R)?x.delete(R):x.get(R)!==!0&&x.set(R,!1)}},[C,m.length,m.join("-")]);const k=[];if(f!==w){let _=[...f];for(let R=0;R<C.length;R++){const D=C[R],F=Ey(D);m.includes(F)||(_.splice(R,0,D),k.push(D))}return a==="wait"&&k.length&&(_=k),N(UR(_)),v(f),null}const{forceRender:E}=Ce.useContext(NC);return me.jsx(me.Fragment,{children:C.map(_=>{const R=Ey(_),D=i&&!h?!1:f===C||m.includes(R),F=()=>{if(x.has(R))x.set(R,!0);else return;let L=!0;x.forEach(A=>{A||(L=!1)}),L&&(E?.(),N(b.current),i&&d?.(),s&&s())};return me.jsx(jH,{isPresent:D,initial:!y.current||t?void 0:!1,custom:e,presenceAffectsLayout:r,mode:a,root:l,onExitComplete:D?void 0:F,anchorX:o,children:_},R)})})},HF=Ce.createContext({strict:!1}),jR={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},Lc={};for(const n in jR)Lc[n]={isEnabled:e=>jR[n].some(t=>!!e[t])};function HH(n){for(const e in n)Lc[e]={...Lc[e],...n[e]}}const qH=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function b0(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||qH.has(n)}let qF=n=>!b0(n);function KH(n){typeof n=="function"&&(qF=e=>e.startsWith("on")?!b0(e):n(e))}try{KH(require("@emotion/is-prop-valid").default)}catch{}function XH(n,e,t){const s={};for(const r in n)r==="values"&&typeof n.values=="object"||(qF(r)||t===!0&&b0(r)||!e&&!b0(r)||n.draggable&&r.startsWith("onDrag"))&&(s[r]=n[r]);return s}const ob=Ce.createContext({});function lb(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}function Uf(n){return typeof n=="string"||Array.isArray(n)}const XC=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],YC=["initial",...XC];function ub(n){return lb(n.animate)||YC.some(e=>Uf(n[e]))}function KF(n){return!!(ub(n)||n.variants)}function YH(n,e){if(ub(n)){const{initial:t,animate:s}=n;return{initial:t===!1||Uf(t)?t:void 0,animate:Uf(s)?s:void 0}}return n.inherit!==!1?e:{}}function JH(n){const{initial:e,animate:t}=YH(n,Ce.useContext(ob));return Ce.useMemo(()=>({initial:e,animate:t}),[WR(e),WR(t)])}function WR(n){return Array.isArray(n)?n.join(" "):n}function GR(n,e){return e.max===e.min?0:n/(e.max-e.min)*100}const ff={correct:(n,e)=>{if(!e.target)return n;if(typeof n=="string")if(Xe.test(n))n=parseFloat(n);else return n;const t=GR(n,e.target.x),s=GR(n,e.target.y);return`${t}% ${s}%`}},ZH={correct:(n,{treeScale:e,projectionDelta:t})=>{const s=n,r=Eo.parse(n);if(r.length>5)return s;const a=Eo.createTransformer(n),i=typeof r[0]!="number"?1:0,o=t.x.scale*e.x,l=t.y.scale*e.y;r[0+i]/=o,r[1+i]/=l;const h=en(o,l,.5);return typeof r[2+i]=="number"&&(r[2+i]/=h),typeof r[3+i]=="number"&&(r[3+i]/=h),a(r)}},rT={borderRadius:{...ff,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:ff,borderTopRightRadius:ff,borderBottomLeftRadius:ff,borderBottomRightRadius:ff,boxShadow:ZH};function XF(n,{layout:e,layoutId:t}){return Qc.has(n)||n.startsWith("origin")||(e||t!==void 0)&&(!!rT[n]||n==="opacity")}const QH={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},e6=Zc.length;function t6(n,e,t){let s="",r=!0;for(let a=0;a<e6;a++){const i=Zc[a],o=n[i];if(o===void 0)continue;let l=!0;if(typeof o=="number"?l=o===(i.startsWith("scale")?1:0):l=parseFloat(o)===0,!l||t){const h=PF(o,GC[i]);if(!l){r=!1;const d=QH[i]||i;s+=`${d}(${h}) `}t&&(e[i]=h)}}return s=s.trim(),t?s=t(e,r?"":s):r&&(s="none"),s}function JC(n,e,t){const{style:s,vars:r,transformOrigin:a}=n;let i=!1,o=!1;for(const l in e){const h=e[l];if(Qc.has(l)){i=!0;continue}else if(gF(l)){r[l]=h;continue}else{const d=PF(h,GC[l]);l.startsWith("origin")?(o=!0,a[l]=d):s[l]=d}}if(e.transform||(i||t?s.transform=t6(e,n.transform,t):s.transform&&(s.transform="none")),o){const{originX:l="50%",originY:h="50%",originZ:d=0}=a;s.transformOrigin=`${l} ${h} ${d}`}}const ZC=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function YF(n,e,t){for(const s in e)!ys(e[s])&&!XF(s,t)&&(n[s]=e[s])}function n6({transformTemplate:n},e){return Ce.useMemo(()=>{const t=ZC();return JC(t,e,n),Object.assign({},t.vars,t.style)},[e])}function s6(n,e){const t=n.style||{},s={};return YF(s,t,n),Object.assign(s,n6(n,e)),s}function r6(n,e){const t={},s=s6(n,e);return n.drag&&n.dragListener!==!1&&(t.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(t.tabIndex=0),t.style=s,t}const a6={offset:"stroke-dashoffset",array:"stroke-dasharray"},i6={offset:"strokeDashoffset",array:"strokeDasharray"};function o6(n,e,t=1,s=0,r=!0){n.pathLength=1;const a=r?a6:i6;n[a.offset]=Xe.transform(-s);const i=Xe.transform(e),o=Xe.transform(t);n[a.array]=`${i} ${o}`}function JF(n,{attrX:e,attrY:t,attrScale:s,pathLength:r,pathSpacing:a=1,pathOffset:i=0,...o},l,h,d){if(JC(n,o,h),l){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:f,style:m}=n;f.transform&&(m.transform=f.transform,delete f.transform),(m.transform||f.transformOrigin)&&(m.transformOrigin=f.transformOrigin??"50% 50%",delete f.transformOrigin),m.transform&&(m.transformBox=d?.transformBox??"fill-box",delete f.transformBox),e!==void 0&&(f.x=e),t!==void 0&&(f.y=t),s!==void 0&&(f.scale=s),r!==void 0&&o6(f,r,a,i,!1)}const ZF=()=>({...ZC(),attrs:{}}),QF=n=>typeof n=="string"&&n.toLowerCase()==="svg";function l6(n,e,t,s){const r=Ce.useMemo(()=>{const a=ZF();return JF(a,e,QF(s),n.transformTemplate,n.style),{...a.attrs,style:{...a.style}}},[e]);if(n.style){const a={};YF(a,n.style,n),r.style={...a,...r.style}}return r}const u6=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function QC(n){return typeof n!="string"||n.includes("-")?!1:!!(u6.indexOf(n)>-1||/[A-Z]/u.test(n))}function c6(n,e,t,{latestValues:s},r,a=!1){const o=(QC(n)?l6:r6)(e,s,r,n),l=XH(e,typeof n=="string",a),h=n!==Ce.Fragment?{...l,...o,ref:t}:{},{children:d}=e,f=Ce.useMemo(()=>ys(d)?d.get():d,[d]);return Ce.createElement(n,{...h,children:f})}function HR(n){const e=[{},{}];return n?.values.forEach((t,s)=>{e[0][s]=t.get(),e[1][s]=t.getVelocity()}),e}function e2(n,e,t,s){if(typeof e=="function"){const[r,a]=HR(s);e=e(t!==void 0?t:n.custom,r,a)}if(typeof e=="string"&&(e=n.variants&&n.variants[e]),typeof e=="function"){const[r,a]=HR(s);e=e(t!==void 0?t:n.custom,r,a)}return e}function Yy(n){return ys(n)?n.get():n}function h6({scrapeMotionValuesFromProps:n,createRenderState:e},t,s,r){return{latestValues:d6(t,s,r,n),renderState:e()}}function d6(n,e,t,s){const r={},a=s(n,{});for(const m in a)r[m]=Yy(a[m]);let{initial:i,animate:o}=n;const l=ub(n),h=KF(n);e&&h&&!l&&n.inherit!==!1&&(i===void 0&&(i=e.initial),o===void 0&&(o=e.animate));let d=t?t.initial===!1:!1;d=d||i===!1;const f=d?o:i;if(f&&typeof f!="boolean"&&!lb(f)){const m=Array.isArray(f)?f:[f];for(let y=0;y<m.length;y++){const b=e2(n,m[y]);if(b){const{transitionEnd:x,transition:w,...v}=b;for(const C in v){let N=v[C];if(Array.isArray(N)){const k=d?N.length-1:0;N=N[k]}N!==null&&(r[C]=N)}for(const C in x)r[C]=x[C]}}}return r}const eL=n=>(e,t)=>{const s=Ce.useContext(ob),r=Ce.useContext(ib),a=()=>h6(n,e,s,r);return t?a():kC(a)};function t2(n,e,t){const{style:s}=n,r={};for(const a in s)(ys(s[a])||e.style&&ys(e.style[a])||XF(a,n)||t?.getValue(a)?.liveStyle!==void 0)&&(r[a]=s[a]);return r}const f6=eL({scrapeMotionValuesFromProps:t2,createRenderState:ZC});function tL(n,e,t){const s=t2(n,e,t);for(const r in n)if(ys(n[r])||ys(e[r])){const a=Zc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;s[a]=n[r]}return s}const p6=eL({scrapeMotionValuesFromProps:tL,createRenderState:ZF}),m6=Symbol.for("motionComponentSymbol");function Nc(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function g6(n,e,t){return Ce.useCallback(s=>{s&&n.onMount&&n.onMount(s),e&&(s?e.mount(s):e.unmount()),t&&(typeof t=="function"?t(s):Nc(t)&&(t.current=s))},[e])}const n2=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),y6="framerAppearId",nL="data-"+n2(y6),sL=Ce.createContext({});function b6(n,e,t,s,r){const{visualElement:a}=Ce.useContext(ob),i=Ce.useContext(HF),o=Ce.useContext(ib),l=Ce.useContext(KC).reducedMotion,h=Ce.useRef(null);s=s||i.renderer,!h.current&&s&&(h.current=s(n,{visualState:e,parent:a,props:t,presenceContext:o,blockInitialAnimation:o?o.initial===!1:!1,reducedMotionConfig:l}));const d=h.current,f=Ce.useContext(sL);d&&!d.projection&&r&&(d.type==="html"||d.type==="svg")&&x6(h.current,t,r,f);const m=Ce.useRef(!1);Ce.useInsertionEffect(()=>{d&&m.current&&d.update(t,o)});const y=t[nL],b=Ce.useRef(!!y&&!window.MotionHandoffIsComplete?.(y)&&window.MotionHasOptimisedAnimation?.(y));return Q3(()=>{d&&(m.current=!0,window.MotionIsMounted=!0,d.updateFeatures(),d.scheduleRenderMicrotask(),b.current&&d.animationState&&d.animationState.animateChanges())}),Ce.useEffect(()=>{d&&(!b.current&&d.animationState&&d.animationState.animateChanges(),b.current&&(queueMicrotask(()=>{window.MotionHandoffMarkAsComplete?.(y)}),b.current=!1),d.enteringChildren=void 0)}),d}function x6(n,e,t,s){const{layoutId:r,layout:a,drag:i,dragConstraints:o,layoutScroll:l,layoutRoot:h,layoutCrossfade:d}=e;n.projection=new t(n.latestValues,e["data-framer-portal-id"]?void 0:rL(n.parent)),n.projection.setOptions({layoutId:r,layout:a,alwaysMeasureLayout:!!i||o&&Nc(o),visualElement:n,animationType:typeof a=="string"?a:"both",initialPromotionConfig:s,crossfade:d,layoutScroll:l,layoutRoot:h})}function rL(n){if(n)return n.options.allowProjection!==!1?n.projection:rL(n.parent)}function uS(n,{forwardMotionProps:e=!1}={},t,s){t&&HH(t);const r=QC(n)?p6:f6;function a(o,l){let h;const d={...Ce.useContext(KC),...o,layoutId:w6(o)},{isStatic:f}=d,m=JH(o),y=r(o,f);if(!f&&EC){v6();const b=S6(d);h=b.MeasureLayout,m.visualElement=b6(n,y,d,s,b.ProjectionNode)}return me.jsxs(ob.Provider,{value:m,children:[h&&m.visualElement?me.jsx(h,{visualElement:m.visualElement,...d}):null,c6(n,o,g6(y,m.visualElement,l),y,f,e)]})}a.displayName=`motion.${typeof n=="string"?n:`create(${n.displayName??n.name??""})`}`;const i=Ce.forwardRef(a);return i[m6]=n,i}function w6({layoutId:n}){const e=Ce.useContext(NC).id;return e&&n!==void 0?e+"-"+n:n}function v6(n,e){Ce.useContext(HF).strict}function S6(n){const{drag:e,layout:t}=Lc;if(!e&&!t)return{};const s={...e,...t};return{MeasureLayout:e?.isEnabled(n)||t?.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}function T6(n,e){if(typeof Proxy>"u")return uS;const t=new Map,s=(a,i)=>uS(a,i,n,e),r=(a,i)=>s(a,i);return new Proxy(r,{get:(a,i)=>i==="create"?s:(t.has(i)||t.set(i,uS(i,void 0,n,e)),t.get(i))})}function aL({top:n,left:e,right:t,bottom:s}){return{x:{min:e,max:t},y:{min:n,max:s}}}function C6({x:n,y:e}){return{top:e.min,right:n.max,bottom:e.max,left:n.min}}function N6(n,e){if(!e)return n;const t=e({x:n.left,y:n.top}),s=e({x:n.right,y:n.bottom});return{top:t.y,left:t.x,bottom:s.y,right:s.x}}function cS(n){return n===void 0||n===1}function aT({scale:n,scaleX:e,scaleY:t}){return!cS(n)||!cS(e)||!cS(t)}function Sl(n){return aT(n)||iL(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function iL(n){return qR(n.x)||qR(n.y)}function qR(n){return n&&n!=="0%"}function x0(n,e,t){const s=n-t,r=e*s;return t+r}function KR(n,e,t,s,r){return r!==void 0&&(n=x0(n,r,s)),x0(n,t,s)+e}function iT(n,e=0,t=1,s,r){n.min=KR(n.min,e,t,s,r),n.max=KR(n.max,e,t,s,r)}function oL(n,{x:e,y:t}){iT(n.x,e.translate,e.scale,e.originPoint),iT(n.y,t.translate,t.scale,t.originPoint)}const XR=.999999999999,YR=1.0000000000001;function k6(n,e,t,s=!1){const r=t.length;if(!r)return;e.x=e.y=1;let a,i;for(let o=0;o<r;o++){a=t[o],i=a.projectionDelta;const{visualElement:l}=a.options;l&&l.props.style&&l.props.style.display==="contents"||(s&&a.options.layoutScroll&&a.scroll&&a!==a.root&&Ec(n,{x:-a.scroll.offset.x,y:-a.scroll.offset.y}),i&&(e.x*=i.x.scale,e.y*=i.y.scale,oL(n,i)),s&&Sl(a.latestValues)&&Ec(n,a.latestValues))}e.x<YR&&e.x>XR&&(e.x=1),e.y<YR&&e.y>XR&&(e.y=1)}function kc(n,e){n.min=n.min+e,n.max=n.max+e}function JR(n,e,t,s,r=.5){const a=en(n.min,n.max,r);iT(n,e,t,a,s)}function Ec(n,e){JR(n.x,e.x,e.scaleX,e.scale,e.originX),JR(n.y,e.y,e.scaleY,e.scale,e.originY)}function lL(n,e){return aL(N6(n.getBoundingClientRect(),e))}function E6(n,e,t){const s=lL(n,t),{scroll:r}=e;return r&&(kc(s.x,r.offset.x),kc(s.y,r.offset.y)),s}const ZR=()=>({translate:0,scale:1,origin:0,originPoint:0}),$c=()=>({x:ZR(),y:ZR()}),QR=()=>({min:0,max:0}),On=()=>({x:QR(),y:QR()}),oT={current:null},uL={current:!1};function $6(){if(uL.current=!0,!!EC)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),e=()=>oT.current=n.matches;n.addEventListener("change",e),e()}else oT.current=!1}const I6=new WeakMap;function _6(n,e,t){for(const s in e){const r=e[s],a=t[s];if(ys(r))n.addValue(s,r);else if(ys(a))n.addValue(s,Fc(r,{owner:n}));else if(a!==r)if(n.hasValue(s)){const i=n.getValue(s);i.liveStyle===!0?i.jump(r):i.hasAnimated||i.set(r)}else{const i=n.getStaticValue(s);n.addValue(s,Fc(i!==void 0?i:r,{owner:n}))}}for(const s in t)e[s]===void 0&&n.removeValue(s);return e}const eD=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class A6{scrapeMotionValuesFromProps(e,t,s){return{}}constructor({parent:e,props:t,presenceContext:s,reducedMotionConfig:r,blockInitialAnimation:a,visualState:i},o={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=jC,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const m=Ks.now();this.renderScheduledAt<m&&(this.renderScheduledAt=m,Xt.render(this.render,!1,!0))};const{latestValues:l,renderState:h}=i;this.latestValues=l,this.baseTarget={...l},this.initialValues=t.initial?{...l}:{},this.renderState=h,this.parent=e,this.props=t,this.presenceContext=s,this.depth=e?e.depth+1:0,this.reducedMotionConfig=r,this.options=o,this.blockInitialAnimation=!!a,this.isControllingVariants=ub(t),this.isVariantNode=KF(t),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...f}=this.scrapeMotionValuesFromProps(t,{},this);for(const m in f){const y=f[m];l[m]!==void 0&&ys(y)&&y.set(l[m])}}mount(e){this.current=e,I6.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,s)=>this.bindToMotionValue(s,t)),uL.current||$6(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:oT.current,this.parent?.addChild(this),this.update(this.props,this.presenceContext)}unmount(){this.projection&&this.projection.unmount(),ko(this.notifyUpdate),ko(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent?.removeChild(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const t=this.features[e];t&&(t.unmount(),t.isMounted=!1)}this.current=null}addChild(e){this.children.add(e),this.enteringChildren??(this.enteringChildren=new Set),this.enteringChildren.add(e)}removeChild(e){this.children.delete(e),this.enteringChildren&&this.enteringChildren.delete(e)}bindToMotionValue(e,t){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const s=Qc.has(e);s&&this.onBindTransform&&this.onBindTransform();const r=t.on("change",i=>{this.latestValues[e]=i,this.props.onUpdate&&Xt.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0),this.scheduleRender()});let a;window.MotionCheckAppearSync&&(a=window.MotionCheckAppearSync(this,e,t)),this.valueSubscriptions.set(e,()=>{r(),a&&a(),t.owner&&t.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in Lc){const t=Lc[e];if(!t)continue;const{isEnabled:s,Feature:r}=t;if(!this.features[e]&&r&&s(this.props)&&(this.features[e]=new r(this)),this.features[e]){const a=this.features[e];a.isMounted?a.update():(a.mount(),a.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):On()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let s=0;s<eD.length;s++){const r=eD[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const a="on"+r,i=e[a];i&&(this.propEventSubscriptions[r]=this.on(r,i))}this.prevMotionValues=_6(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){const s=this.values.get(e);t!==s&&(s&&this.removeValue(e),this.bindToMotionValue(e,t),this.values.set(e,t),this.latestValues[e]=t.get())}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let s=this.values.get(e);return s===void 0&&t!==void 0&&(s=Fc(t===null?void 0:t,{owner:this}),this.addValue(e,s)),s}readValue(e,t){let s=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:this.getBaseTargetFromProps(this.props,e)??this.readValueFromInstance(this.current,e,this.options);return s!=null&&(typeof s=="string"&&(eF(s)||nF(s))?s=parseFloat(s):!zH(s)&&Eo.test(t)&&(s=zF(e,t)),this.setBaseTarget(e,ys(s)?s.get():s)),ys(s)?s.get():s}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){const{initial:t}=this.props;let s;if(typeof t=="string"||typeof t=="object"){const a=e2(this.props,t,this.presenceContext?.custom);a&&(s=a[e])}if(t&&s!==void 0)return s;const r=this.getBaseTargetFromProps(this.props,e);return r!==void 0&&!ys(r)?r:this.initialValues[e]!==void 0&&s===void 0?void 0:this.baseTarget[e]}on(e,t){return this.events[e]||(this.events[e]=new RC),this.events[e].add(t)}notify(e,...t){this.events[e]&&this.events[e].notify(...t)}scheduleRenderMicrotask(){HC.render(this.render)}}class cL extends A6{constructor(){super(...arguments),this.KeyframeResolver=kH}sortInstanceNodePosition(e,t){return e.compareDocumentPosition(t)&2?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,{vars:t,style:s}){delete t[e],delete s[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;ys(e)&&(this.childSubscription=e.on("change",t=>{this.current&&(this.current.textContent=`${t}`)}))}}function hL(n,{style:e,vars:t},s,r){const a=n.style;let i;for(i in e)a[i]=e[i];r?.applyProjectionStyles(a,s);for(i in t)a.setProperty(i,t[i])}function R6(n){return window.getComputedStyle(n)}class D6 extends cL{constructor(){super(...arguments),this.type="html",this.renderInstance=hL}readValueFromInstance(e,t){if(Qc.has(t))return this.projection?.isProjecting?JS(t):G5(e,t);{const s=R6(e),r=(gF(t)?s.getPropertyValue(t):s[t])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(e,{transformPagePoint:t}){return lL(e,t)}build(e,t,s){JC(e,t,s.transformTemplate)}scrapeMotionValuesFromProps(e,t,s){return t2(e,t,s)}}const dL=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function O6(n,e,t,s){hL(n,e,void 0,s);for(const r in e.attrs)n.setAttribute(dL.has(r)?r:n2(r),e.attrs[r])}class F6 extends cL{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=On}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(Qc.has(t)){const s=MF(t);return s&&s.default||0}return t=dL.has(t)?t:n2(t),e.getAttribute(t)}scrapeMotionValuesFromProps(e,t,s){return tL(e,t,s)}build(e,t,s){JF(e,t,this.isSVGTag,s.transformTemplate,s.style)}renderInstance(e,t,s,r){O6(e,t,s,r)}mount(e){this.isSVGTag=QF(e.tagName),super.mount(e)}}const L6=(n,e)=>QC(n)?new F6(e):new D6(e,{allowProjection:n!==Ce.Fragment});function _c(n,e,t){const s=n.getProps();return e2(s,e,t!==void 0?t:s.custom,n)}const lT=n=>Array.isArray(n);function M6(n,e,t){n.hasValue(e)?n.getValue(e).set(t):n.addValue(e,Fc(t))}function z6(n){return lT(n)?n[n.length-1]||0:n}function P6(n,e){const t=_c(n,e);let{transitionEnd:s={},transition:r={},...a}=t||{};a={...a,...s};for(const i in a){const o=z6(a[i]);M6(n,i,o)}}function B6(n){return!!(ys(n)&&n.add)}function uT(n,e){const t=n.getValue("willChange");if(B6(t))return t.add(e);if(!t&&Ci.WillChange){const s=new Ci.WillChange("auto");n.addValue("willChange",s),s.add(e)}}function fL(n){return n.props[nL]}const V6=n=>n!==null;function U6(n,{repeat:e,repeatType:t="loop"},s){const r=n.filter(V6),a=e&&t!=="loop"&&e%2===1?0:r.length-1;return r[a]}const j6={type:"spring",stiffness:500,damping:25,restSpeed:10},W6=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),G6={type:"keyframes",duration:.8},H6={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},q6=(n,{keyframes:e})=>e.length>2?G6:Qc.has(n)?n.startsWith("scale")?W6(e[1]):j6:H6;function K6({when:n,delay:e,delayChildren:t,staggerChildren:s,staggerDirection:r,repeat:a,repeatType:i,repeatDelay:o,from:l,elapsed:h,...d}){return!!Object.keys(d).length}const s2=(n,e,t,s={},r,a)=>i=>{const o=WC(s,n)||{},l=o.delay||s.delay||0;let{elapsed:h=0}=s;h=h-Ma(l);const d={keyframes:Array.isArray(t)?t:[null,t],ease:"easeOut",velocity:e.getVelocity(),...o,delay:-h,onUpdate:m=>{e.set(m),o.onUpdate&&o.onUpdate(m)},onComplete:()=>{i(),o.onComplete&&o.onComplete()},name:n,motionValue:e,element:a?void 0:r};K6(o)||Object.assign(d,q6(n,d)),d.duration&&(d.duration=Ma(d.duration)),d.repeatDelay&&(d.repeatDelay=Ma(d.repeatDelay)),d.from!==void 0&&(d.keyframes[0]=d.from);let f=!1;if((d.type===!1||d.duration===0&&!d.repeatDelay)&&(nT(d),d.delay===0&&(f=!0)),(Ci.instantAnimations||Ci.skipAnimations)&&(f=!0,nT(d),d.delay=0),d.allowFlatten=!o.type&&!o.ease,f&&!a&&e.get()!==void 0){const m=U6(d.keyframes,o);if(m!==void 0){Xt.update(()=>{d.onUpdate(m),d.onComplete()});return}}return o.isSync?new UC(d):new pH(d)};function X6({protectedKeys:n,needsAnimating:e},t){const s=n.hasOwnProperty(t)&&e[t]!==!0;return e[t]=!1,s}function pL(n,e,{delay:t=0,transitionOverride:s,type:r}={}){let{transition:a=n.getDefaultTransition(),transitionEnd:i,...o}=e;s&&(a=s);const l=[],h=r&&n.animationState&&n.animationState.getState()[r];for(const d in o){const f=n.getValue(d,n.latestValues[d]??null),m=o[d];if(m===void 0||h&&X6(h,d))continue;const y={delay:t,...WC(a||{},d)},b=f.get();if(b!==void 0&&!f.isAnimating&&!Array.isArray(m)&&m===b&&!y.velocity)continue;let x=!1;if(window.MotionHandoffAnimation){const v=fL(n);if(v){const C=window.MotionHandoffAnimation(v,d,Xt);C!==null&&(y.startTime=C,x=!0)}}uT(n,d),f.start(s2(d,f,m,n.shouldReduceMotion&&OF.has(d)?{type:!1}:y,n,x));const w=f.animation;w&&l.push(w)}return i&&Promise.all(l).then(()=>{Xt.update(()=>{i&&P6(n,i)})}),l}function mL(n,e,t,s=0,r=1){const a=Array.from(n).sort((h,d)=>h.sortNodePosition(d)).indexOf(e),i=n.size,o=(i-1)*s;return typeof t=="function"?t(a,i):r===1?a*s:o-a*s}function cT(n,e,t={}){const s=_c(n,e,t.type==="exit"?n.presenceContext?.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=s||{};t.transitionOverride&&(r=t.transitionOverride);const a=s?()=>Promise.all(pL(n,s,t)):()=>Promise.resolve(),i=n.variantChildren&&n.variantChildren.size?(l=0)=>{const{delayChildren:h=0,staggerChildren:d,staggerDirection:f}=r;return Y6(n,e,l,h,d,f,t)}:()=>Promise.resolve(),{when:o}=r;if(o){const[l,h]=o==="beforeChildren"?[a,i]:[i,a];return l().then(()=>h())}else return Promise.all([a(),i(t.delay)])}function Y6(n,e,t=0,s=0,r=0,a=1,i){const o=[];for(const l of n.variantChildren)l.notify("AnimationStart",e),o.push(cT(l,e,{...i,delay:t+(typeof s=="function"?0:s)+mL(n.variantChildren,l,s,r,a)}).then(()=>l.notify("AnimationComplete",e)));return Promise.all(o)}function J6(n,e,t={}){n.notify("AnimationStart",e);let s;if(Array.isArray(e)){const r=e.map(a=>cT(n,a,t));s=Promise.all(r)}else if(typeof e=="string")s=cT(n,e,t);else{const r=typeof e=="function"?_c(n,e,t.custom):e;s=Promise.all(pL(n,r,t))}return s.then(()=>{n.notify("AnimationComplete",e)})}function gL(n,e){if(!Array.isArray(e))return!1;const t=e.length;if(t!==n.length)return!1;for(let s=0;s<t;s++)if(e[s]!==n[s])return!1;return!0}const Z6=YC.length;function yL(n){if(!n)return;if(!n.isControllingVariants){const t=n.parent?yL(n.parent)||{}:{};return n.props.initial!==void 0&&(t.initial=n.props.initial),t}const e={};for(let t=0;t<Z6;t++){const s=YC[t],r=n.props[s];(Uf(r)||r===!1)&&(e[s]=r)}return e}const Q6=[...XC].reverse(),eq=XC.length;function tq(n){return e=>Promise.all(e.map(({animation:t,options:s})=>J6(n,t,s)))}function nq(n){let e=tq(n),t=tD(),s=!0;const r=l=>(h,d)=>{const f=_c(n,d,l==="exit"?n.presenceContext?.custom:void 0);if(f){const{transition:m,transitionEnd:y,...b}=f;h={...h,...b,...y}}return h};function a(l){e=l(n)}function i(l){const{props:h}=n,d=yL(n.parent)||{},f=[],m=new Set;let y={},b=1/0;for(let w=0;w<eq;w++){const v=Q6[w],C=t[v],N=h[v]!==void 0?h[v]:d[v],k=Uf(N),E=v===l?C.isActive:null;E===!1&&(b=w);let _=N===d[v]&&N!==h[v]&&k;if(_&&s&&n.manuallyAnimateOnMount&&(_=!1),C.protectedKeys={...y},!C.isActive&&E===null||!N&&!C.prevProp||lb(N)||typeof N=="boolean")continue;const R=sq(C.prevProp,N);let D=R||v===l&&C.isActive&&!_&&k||w>b&&k,F=!1;const L=Array.isArray(N)?N:[N];let A=L.reduce(r(v),{});E===!1&&(A={});const{prevResolvedValues:V={}}=C,q={...V,...A},ne=U=>{D=!0,m.has(U)&&(F=!0,m.delete(U)),C.needsAnimating[U]=!0;const X=n.getValue(U);X&&(X.liveStyle=!1)};for(const U in q){const X=A[U],K=V[U];if(y.hasOwnProperty(U))continue;let se=!1;lT(X)&&lT(K)?se=!gL(X,K):se=X!==K,se?X!=null?ne(U):m.add(U):X!==void 0&&m.has(U)?ne(U):C.protectedKeys[U]=!0}C.prevProp=N,C.prevResolvedValues=A,C.isActive&&(y={...y,...A}),s&&n.blockInitialAnimation&&(D=!1);const Q=_&&R;D&&(!Q||F)&&f.push(...L.map(U=>{const X={type:v};if(typeof U=="string"&&s&&!Q&&n.manuallyAnimateOnMount&&n.parent){const{parent:K}=n,se=_c(K,U);if(K.enteringChildren&&se){const{delayChildren:P}=se.transition||{};X.delay=mL(K.enteringChildren,n,P)}}return{animation:U,options:X}}))}if(m.size){const w={};if(typeof h.initial!="boolean"){const v=_c(n,Array.isArray(h.initial)?h.initial[0]:h.initial);v&&v.transition&&(w.transition=v.transition)}m.forEach(v=>{const C=n.getBaseTarget(v),N=n.getValue(v);N&&(N.liveStyle=!0),w[v]=C??null}),f.push({animation:w})}let x=!!f.length;return s&&(h.initial===!1||h.initial===h.animate)&&!n.manuallyAnimateOnMount&&(x=!1),s=!1,x?e(f):Promise.resolve()}function o(l,h){if(t[l].isActive===h)return Promise.resolve();n.variantChildren?.forEach(f=>f.animationState?.setActive(l,h)),t[l].isActive=h;const d=i(l);for(const f in t)t[f].protectedKeys={};return d}return{animateChanges:i,setActive:o,setAnimateFunction:a,getState:()=>t,reset:()=>{t=tD()}}}function sq(n,e){return typeof e=="string"?e!==n:Array.isArray(e)?!gL(e,n):!1}function gl(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function tD(){return{animate:gl(!0),whileInView:gl(),whileHover:gl(),whileTap:gl(),whileDrag:gl(),whileFocus:gl(),exit:gl()}}class Po{constructor(e){this.isMounted=!1,this.node=e}update(){}}class rq extends Po{constructor(e){super(e),e.animationState||(e.animationState=nq(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();lb(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let aq=0;class iq extends Po{constructor(){super(...arguments),this.id=aq++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===s)return;const r=this.node.animationState.setActive("exit",!e);t&&!e&&r.then(()=>{t(this.id)})}mount(){const{register:e,onExitComplete:t}=this.node.presenceContext||{};t&&t(this.id),e&&(this.unmount=e(this.id))}unmount(){}}const oq={animation:{Feature:rq},exit:{Feature:iq}};function jf(n,e,t,s={passive:!0}){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t)}function xp(n){return{point:{x:n.pageX,y:n.pageY}}}const lq=n=>e=>qC(e)&&n(e,xp(e));function Rf(n,e,t,s){return jf(n,e,lq(t),s)}const bL=1e-4,uq=1-bL,cq=1+bL,xL=.01,hq=0-xL,dq=0+xL;function Es(n){return n.max-n.min}function fq(n,e,t){return Math.abs(n-e)<=t}function nD(n,e,t,s=.5){n.origin=s,n.originPoint=en(e.min,e.max,n.origin),n.scale=Es(t)/Es(e),n.translate=en(t.min,t.max,n.origin)-n.originPoint,(n.scale>=uq&&n.scale<=cq||isNaN(n.scale))&&(n.scale=1),(n.translate>=hq&&n.translate<=dq||isNaN(n.translate))&&(n.translate=0)}function Df(n,e,t,s){nD(n.x,e.x,t.x,s?s.originX:void 0),nD(n.y,e.y,t.y,s?s.originY:void 0)}function sD(n,e,t){n.min=t.min+e.min,n.max=n.min+Es(e)}function pq(n,e,t){sD(n.x,e.x,t.x),sD(n.y,e.y,t.y)}function rD(n,e,t){n.min=e.min-t.min,n.max=n.min+Es(e)}function w0(n,e,t){rD(n.x,e.x,t.x),rD(n.y,e.y,t.y)}function Pr(n){return[n("x"),n("y")]}const wL=({current:n})=>n?n.ownerDocument.defaultView:null,aD=(n,e)=>Math.abs(n-e);function mq(n,e){const t=aD(n.x,e.x),s=aD(n.y,e.y);return Math.sqrt(t**2+s**2)}class vL{constructor(e,t,{transformPagePoint:s,contextWindow:r=window,dragSnapToOrigin:a=!1,distanceThreshold:i=3}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const m=dS(this.lastMoveEventInfo,this.history),y=this.startEvent!==null,b=mq(m.offset,{x:0,y:0})>=this.distanceThreshold;if(!y&&!b)return;const{point:x}=m,{timestamp:w}=us;this.history.push({...x,timestamp:w});const{onStart:v,onMove:C}=this.handlers;y||(v&&v(this.lastMoveEvent,m),this.startEvent=this.lastMoveEvent),C&&C(this.lastMoveEvent,m)},this.handlePointerMove=(m,y)=>{this.lastMoveEvent=m,this.lastMoveEventInfo=hS(y,this.transformPagePoint),Xt.update(this.updatePoint,!0)},this.handlePointerUp=(m,y)=>{this.end();const{onEnd:b,onSessionEnd:x,resumeAnimation:w}=this.handlers;if(this.dragSnapToOrigin&&w&&w(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const v=dS(m.type==="pointercancel"?this.lastMoveEventInfo:hS(y,this.transformPagePoint),this.history);this.startEvent&&b&&b(m,v),x&&x(m,v)},!qC(e))return;this.dragSnapToOrigin=a,this.handlers=t,this.transformPagePoint=s,this.distanceThreshold=i,this.contextWindow=r||window;const o=xp(e),l=hS(o,this.transformPagePoint),{point:h}=l,{timestamp:d}=us;this.history=[{...h,timestamp:d}];const{onSessionStart:f}=t;f&&f(e,dS(l,this.history)),this.removeListeners=gp(Rf(this.contextWindow,"pointermove",this.handlePointerMove),Rf(this.contextWindow,"pointerup",this.handlePointerUp),Rf(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),ko(this.updatePoint)}}function hS(n,e){return e?{point:e(n.point)}:n}function iD(n,e){return{x:n.x-e.x,y:n.y-e.y}}function dS({point:n},e){return{point:n,delta:iD(n,SL(e)),offset:iD(n,gq(e)),velocity:yq(e,.1)}}function gq(n){return n[0]}function SL(n){return n[n.length-1]}function yq(n,e){if(n.length<2)return{x:0,y:0};let t=n.length-1,s=null;const r=SL(n);for(;t>=0&&(s=n[t],!(r.timestamp-s.timestamp>Ma(e)));)t--;if(!s)return{x:0,y:0};const a=jr(r.timestamp-s.timestamp);if(a===0)return{x:0,y:0};const i={x:(r.x-s.x)/a,y:(r.y-s.y)/a};return i.x===1/0&&(i.x=0),i.y===1/0&&(i.y=0),i}function bq(n,{min:e,max:t},s){return e!==void 0&&n<e?n=s?en(e,n,s.min):Math.max(n,e):t!==void 0&&n>t&&(n=s?en(t,n,s.max):Math.min(n,t)),n}function oD(n,e,t){return{min:e!==void 0?n.min+e:void 0,max:t!==void 0?n.max+t-(n.max-n.min):void 0}}function xq(n,{top:e,left:t,bottom:s,right:r}){return{x:oD(n.x,t,r),y:oD(n.y,e,s)}}function lD(n,e){let t=e.min-n.min,s=e.max-n.max;return e.max-e.min<n.max-n.min&&([t,s]=[s,t]),{min:t,max:s}}function wq(n,e){return{x:lD(n.x,e.x),y:lD(n.y,e.y)}}function vq(n,e){let t=.5;const s=Es(n),r=Es(e);return r>s?t=Pf(e.min,e.max-s,n.min):s>r&&(t=Pf(n.min,n.max-r,e.min)),Ti(0,1,t)}function Sq(n,e){const t={};return e.min!==void 0&&(t.min=e.min-n.min),e.max!==void 0&&(t.max=e.max-n.min),t}const hT=.35;function Tq(n=hT){return n===!1?n=0:n===!0&&(n=hT),{x:uD(n,"left","right"),y:uD(n,"top","bottom")}}function uD(n,e,t){return{min:cD(n,e),max:cD(n,t)}}function cD(n,e){return typeof n=="number"?n:n[e]||0}const Cq=new WeakMap;class Nq{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=On(),this.latestPointerEvent=null,this.latestPanInfo=null,this.visualElement=e}start(e,{snapToCursor:t=!1,distanceThreshold:s}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const a=f=>{const{dragSnapToOrigin:m}=this.getProps();m?this.pauseAnimation():this.stopAnimation(),t&&this.snapToCursor(xp(f).point)},i=(f,m)=>{const{drag:y,dragPropagation:b,onDragStart:x}=this.getProps();if(y&&!b&&(this.openDragLock&&this.openDragLock(),this.openDragLock=_H(y),!this.openDragLock))return;this.latestPointerEvent=f,this.latestPanInfo=m,this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Pr(v=>{let C=this.getAxisMotionValue(v).get()||0;if(za.test(C)){const{projection:N}=this.visualElement;if(N&&N.layout){const k=N.layout.layoutBox[v];k&&(C=Es(k)*(parseFloat(C)/100))}}this.originPoint[v]=C}),x&&Xt.postRender(()=>x(f,m)),uT(this.visualElement,"transform");const{animationState:w}=this.visualElement;w&&w.setActive("whileDrag",!0)},o=(f,m)=>{this.latestPointerEvent=f,this.latestPanInfo=m;const{dragPropagation:y,dragDirectionLock:b,onDirectionLock:x,onDrag:w}=this.getProps();if(!y&&!this.openDragLock)return;const{offset:v}=m;if(b&&this.currentDirection===null){this.currentDirection=kq(v),this.currentDirection!==null&&x&&x(this.currentDirection);return}this.updateAxis("x",m.point,v),this.updateAxis("y",m.point,v),this.visualElement.render(),w&&w(f,m)},l=(f,m)=>{this.latestPointerEvent=f,this.latestPanInfo=m,this.stop(f,m),this.latestPointerEvent=null,this.latestPanInfo=null},h=()=>Pr(f=>this.getAnimationState(f)==="paused"&&this.getAxisMotionValue(f).animation?.play()),{dragSnapToOrigin:d}=this.getProps();this.panSession=new vL(e,{onSessionStart:a,onStart:i,onMove:o,onSessionEnd:l,resumeAnimation:h},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:d,distanceThreshold:s,contextWindow:wL(this.visualElement)})}stop(e,t){const s=e||this.latestPointerEvent,r=t||this.latestPanInfo,a=this.isDragging;if(this.cancel(),!a||!r||!s)return;const{velocity:i}=r;this.startAnimation(i);const{onDragEnd:o}=this.getProps();o&&Xt.postRender(()=>o(s,r))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,s){const{drag:r}=this.getProps();if(!s||!$y(e,r,this.currentDirection))return;const a=this.getAxisMotionValue(e);let i=this.originPoint[e]+s[e];this.constraints&&this.constraints[e]&&(i=bq(i,this.constraints[e],this.elastic[e])),a.set(i)}resolveConstraints(){const{dragConstraints:e,dragElastic:t}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):this.visualElement.projection?.layout,r=this.constraints;e&&Nc(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):e&&s?this.constraints=xq(s.layoutBox,e):this.constraints=!1,this.elastic=Tq(t),r!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&Pr(a=>{this.constraints!==!1&&this.getAxisMotionValue(a)&&(this.constraints[a]=Sq(s.layoutBox[a],this.constraints[a]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!Nc(e))return!1;const s=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const a=E6(s,r.root,this.visualElement.getTransformPagePoint());let i=wq(r.layout.layoutBox,a);if(t){const o=t(C6(i));this.hasMutatedConstraints=!!o,o&&(i=aL(o))}return i}startAnimation(e){const{drag:t,dragMomentum:s,dragElastic:r,dragTransition:a,dragSnapToOrigin:i,onDragTransitionEnd:o}=this.getProps(),l=this.constraints||{},h=Pr(d=>{if(!$y(d,t,this.currentDirection))return;let f=l&&l[d]||{};i&&(f={min:0,max:0});const m=r?200:1e6,y=r?40:1e7,b={type:"inertia",velocity:s?e[d]:0,bounceStiffness:m,bounceDamping:y,timeConstant:750,restDelta:1,restSpeed:10,...a,...f};return this.startAxisValueAnimation(d,b)});return Promise.all(h).then(o)}startAxisValueAnimation(e,t){const s=this.getAxisMotionValue(e);return uT(this.visualElement,e),s.start(s2(e,s,0,t,this.visualElement,!1))}stopAnimation(){Pr(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){Pr(e=>this.getAxisMotionValue(e).animation?.pause())}getAnimationState(e){return this.getAxisMotionValue(e).animation?.state}getAxisMotionValue(e){const t=`_drag${e.toUpperCase()}`,s=this.visualElement.getProps(),r=s[t];return r||this.visualElement.getValue(e,(s.initial?s.initial[e]:void 0)||0)}snapToCursor(e){Pr(t=>{const{drag:s}=this.getProps();if(!$y(t,s,this.currentDirection))return;const{projection:r}=this.visualElement,a=this.getAxisMotionValue(t);if(r&&r.layout){const{min:i,max:o}=r.layout.layoutBox[t];a.set(e[t]-en(i,o,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:s}=this.visualElement;if(!Nc(t)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};Pr(i=>{const o=this.getAxisMotionValue(i);if(o&&this.constraints!==!1){const l=o.get();r[i]=vq({min:l,max:l},this.constraints[i])}});const{transformTemplate:a}=this.visualElement.getProps();this.visualElement.current.style.transform=a?a({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),Pr(i=>{if(!$y(i,e,null))return;const o=this.getAxisMotionValue(i),{min:l,max:h}=this.constraints[i];o.set(en(l,h,r[i]))})}addListeners(){if(!this.visualElement.current)return;Cq.set(this.visualElement,this);const e=this.visualElement.current,t=Rf(e,"pointerdown",l=>{const{drag:h,dragListener:d=!0}=this.getProps();h&&d&&this.start(l)}),s=()=>{const{dragConstraints:l}=this.getProps();Nc(l)&&l.current&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,a=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),Xt.read(s);const i=jf(window,"resize",()=>this.scalePositionWithinConstraints()),o=r.addEventListener("didUpdate",(({delta:l,hasLayoutChanged:h})=>{this.isDragging&&h&&(Pr(d=>{const f=this.getAxisMotionValue(d);f&&(this.originPoint[d]+=l[d].translate,f.set(f.get()+l[d].translate))}),this.visualElement.render())}));return()=>{i(),t(),a(),o&&o()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:a=!1,dragElastic:i=hT,dragMomentum:o=!0}=e;return{...e,drag:t,dragDirectionLock:s,dragPropagation:r,dragConstraints:a,dragElastic:i,dragMomentum:o}}}function $y(n,e,t){return(e===!0||e===n)&&(t===null||t===n)}function kq(n,e=10){let t=null;return Math.abs(n.y)>e?t="y":Math.abs(n.x)>e&&(t="x"),t}class Eq extends Po{constructor(e){super(e),this.removeGroupControls=Hr,this.removeListeners=Hr,this.controls=new Nq(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||Hr}unmount(){this.removeGroupControls(),this.removeListeners()}}const hD=n=>(e,t)=>{n&&Xt.postRender(()=>n(e,t))};class $q extends Po{constructor(){super(...arguments),this.removePointerDownListener=Hr}onPointerDown(e){this.session=new vL(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:wL(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:hD(e),onStart:hD(t),onMove:s,onEnd:(a,i)=>{delete this.session,r&&Xt.postRender(()=>r(a,i))}}}mount(){this.removePointerDownListener=Rf(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const Jy={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let fS=!1;class Iq extends Ce.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s,layoutId:r}=this.props,{projection:a}=e;a&&(t.group&&t.group.add(a),s&&s.register&&r&&s.register(a),fS&&a.root.didUpdate(),a.addEventListener("animationComplete",()=>{this.safeToRemove()}),a.setOptions({...a.options,onExitComplete:()=>this.safeToRemove()})),Jy.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:s,drag:r,isPresent:a}=this.props,{projection:i}=s;return i&&(i.isPresent=a,fS=!0,r||e.layoutDependency!==t||t===void 0||e.isPresent!==a?i.willUpdate():this.safeToRemove(),e.isPresent!==a&&(a?i.promote():i.relegate()||Xt.postRender(()=>{const o=i.getStack();(!o||!o.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),HC.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s}=this.props,{projection:r}=e;fS=!0,r&&(r.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function TL(n){const[e,t]=GF(),s=Ce.useContext(NC);return me.jsx(Iq,{...n,layoutGroup:s,switchLayoutGroup:Ce.useContext(sL),isPresent:e,safeToRemove:t})}function _q(n,e,t){const s=ys(n)?n:Fc(n);return s.start(s2("",s,e,t)),s.animation}const Aq=(n,e)=>n.depth-e.depth;class Rq{constructor(){this.children=[],this.isDirty=!1}add(e){$C(this.children,e),this.isDirty=!0}remove(e){IC(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(Aq),this.isDirty=!1,this.children.forEach(e)}}function Dq(n,e){const t=Ks.now(),s=({timestamp:r})=>{const a=r-t;a>=e&&(ko(s),n(a-e))};return Xt.setup(s,!0),()=>ko(s)}const CL=["TopLeft","TopRight","BottomLeft","BottomRight"],Oq=CL.length,dD=n=>typeof n=="string"?parseFloat(n):n,fD=n=>typeof n=="number"||Xe.test(n);function Fq(n,e,t,s,r,a){r?(n.opacity=en(0,t.opacity??1,Lq(s)),n.opacityExit=en(e.opacity??1,0,Mq(s))):a&&(n.opacity=en(e.opacity??1,t.opacity??1,s));for(let i=0;i<Oq;i++){const o=`border${CL[i]}Radius`;let l=pD(e,o),h=pD(t,o);if(l===void 0&&h===void 0)continue;l||(l=0),h||(h=0),l===0||h===0||fD(l)===fD(h)?(n[o]=Math.max(en(dD(l),dD(h),s),0),(za.test(h)||za.test(l))&&(n[o]+="%")):n[o]=h}(e.rotate||t.rotate)&&(n.rotate=en(e.rotate||0,t.rotate||0,s))}function pD(n,e){return n[e]!==void 0?n[e]:n.borderRadius}const Lq=NL(0,.5,cF),Mq=NL(.5,.95,Hr);function NL(n,e,t){return s=>s<n?0:s>e?1:t(Pf(n,e,s))}function mD(n,e){n.min=e.min,n.max=e.max}function sa(n,e){mD(n.x,e.x),mD(n.y,e.y)}function gD(n,e){n.translate=e.translate,n.scale=e.scale,n.originPoint=e.originPoint,n.origin=e.origin}function yD(n,e,t,s,r){return n-=e,n=x0(n,1/t,s),r!==void 0&&(n=x0(n,1/r,s)),n}function zq(n,e=0,t=1,s=.5,r,a=n,i=n){if(za.test(e)&&(e=parseFloat(e),e=en(i.min,i.max,e/100)-i.min),typeof e!="number")return;let o=en(a.min,a.max,s);n===a&&(o-=e),n.min=yD(n.min,e,t,o,r),n.max=yD(n.max,e,t,o,r)}function bD(n,e,[t,s,r],a,i){zq(n,e[t],e[s],e[r],e.scale,a,i)}const Pq=["x","scaleX","originX"],Bq=["y","scaleY","originY"];function xD(n,e,t,s){bD(n.x,e,Pq,t?t.x:void 0,s?s.x:void 0),bD(n.y,e,Bq,t?t.y:void 0,s?s.y:void 0)}function wD(n){return n.translate===0&&n.scale===1}function kL(n){return wD(n.x)&&wD(n.y)}function vD(n,e){return n.min===e.min&&n.max===e.max}function Vq(n,e){return vD(n.x,e.x)&&vD(n.y,e.y)}function SD(n,e){return Math.round(n.min)===Math.round(e.min)&&Math.round(n.max)===Math.round(e.max)}function EL(n,e){return SD(n.x,e.x)&&SD(n.y,e.y)}function TD(n){return Es(n.x)/Es(n.y)}function CD(n,e){return n.translate===e.translate&&n.scale===e.scale&&n.originPoint===e.originPoint}class Uq{constructor(){this.members=[]}add(e){$C(this.members,e),e.scheduleRender()}remove(e){if(IC(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(e){const t=this.members.findIndex(r=>e===r);if(t===0)return!1;let s;for(let r=t;r>=0;r--){const a=this.members[r];if(a.isPresent!==!1){s=a;break}}return s?(this.promote(s),!0):!1}promote(e,t){const s=this.lead;if(e!==s&&(this.prevLead=s,this.lead=e,e.show(),s)){s.instance&&s.scheduleRender(),e.scheduleRender(),e.resumeFrom=s,t&&(e.resumeFrom.preserveOpacity=!0),s.snapshot&&(e.snapshot=s.snapshot,e.snapshot.latestValues=s.animationValues||s.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:t,resumingFrom:s}=e;t.onExitComplete&&t.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function jq(n,e,t){let s="";const r=n.x.translate/e.x,a=n.y.translate/e.y,i=t?.z||0;if((r||a||i)&&(s=`translate3d(${r}px, ${a}px, ${i}px) `),(e.x!==1||e.y!==1)&&(s+=`scale(${1/e.x}, ${1/e.y}) `),t){const{transformPerspective:h,rotate:d,rotateX:f,rotateY:m,skewX:y,skewY:b}=t;h&&(s=`perspective(${h}px) ${s}`),d&&(s+=`rotate(${d}deg) `),f&&(s+=`rotateX(${f}deg) `),m&&(s+=`rotateY(${m}deg) `),y&&(s+=`skewX(${y}deg) `),b&&(s+=`skewY(${b}deg) `)}const o=n.x.scale*e.x,l=n.y.scale*e.y;return(o!==1||l!==1)&&(s+=`scale(${o}, ${l})`),s||"none"}const pS=["","X","Y","Z"],Wq=1e3;let Gq=0;function mS(n,e,t,s){const{latestValues:r}=e;r[n]&&(t[n]=r[n],e.setStaticValue(n,0),s&&(s[n]=0))}function $L(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:e}=n.options;if(!e)return;const t=fL(e);if(window.MotionHasOptimisedAnimation(t,"transform")){const{layout:r,layoutId:a}=n.options;window.MotionCancelOptimisedAnimation(t,"transform",Xt,!(r||a))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&$L(s)}function IL({attachResizeListener:n,defaultParent:e,measureScroll:t,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(i={},o=e?.()){this.id=Gq++,this.animationId=0,this.animationCommitId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.layoutVersion=0,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,this.nodes.forEach(Kq),this.nodes.forEach(Zq),this.nodes.forEach(Qq),this.nodes.forEach(Xq)},this.resolvedRelativeTargetAt=0,this.linkedParentVersion=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=i,this.root=o?o.root||o:this,this.path=o?[...o.path,o]:[],this.parent=o,this.depth=o?o.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new Rq)}addEventListener(i,o){return this.eventHandlers.has(i)||this.eventHandlers.set(i,new RC),this.eventHandlers.get(i).add(o)}notifyListeners(i,...o){const l=this.eventHandlers.get(i);l&&l.notify(...o)}hasListeners(i){return this.eventHandlers.has(i)}mount(i){if(this.instance)return;this.isSVG=WF(i)&&!LH(i),this.instance=i;const{layoutId:o,layout:l,visualElement:h}=this.options;if(h&&!h.current&&h.mount(i),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),this.root.hasTreeAnimated&&(l||o)&&(this.isLayoutDirty=!0),n){let d,f=0;const m=()=>this.root.updateBlockedByResize=!1;Xt.read(()=>{f=window.innerWidth}),n(i,()=>{const y=window.innerWidth;y!==f&&(f=y,this.root.updateBlockedByResize=!0,d&&d(),d=Dq(m,250),Jy.hasAnimatedSinceResize&&(Jy.hasAnimatedSinceResize=!1,this.nodes.forEach(ED)))})}o&&this.root.registerSharedNode(o,this),this.options.animate!==!1&&h&&(o||l)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:f,hasRelativeLayoutChanged:m,layout:y})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const b=this.options.transition||h.getDefaultTransition()||r8,{onLayoutAnimationStart:x,onLayoutAnimationComplete:w}=h.getProps(),v=!this.targetLayout||!EL(this.targetLayout,y),C=!f&&m;if(this.options.layoutRoot||this.resumeFrom||C||f&&(v||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0);const N={...WC(b,"layout"),onPlay:x,onComplete:w};(h.shouldReduceMotion||this.options.layoutRoot)&&(N.delay=0,N.type=!1),this.startAnimation(N),this.setAnimationOrigin(d,C)}else f||ED(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=y})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const i=this.getStack();i&&i.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,this.eventHandlers.clear(),ko(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(e8),this.animationId++)}getTransformTemplate(){const{visualElement:i}=this.options;return i&&i.getProps().transformTemplate}willUpdate(i=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&$L(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let d=0;d<this.path.length;d++){const f=this.path[d];f.shouldResetTransform=!0,f.updateScroll("snapshot"),f.options.layoutRoot&&f.willUpdate(!1)}const{layoutId:o,layout:l}=this.options;if(o===void 0&&!l)return;const h=this.getTransformTemplate();this.prevTransformTemplateValue=h?h(this.latestValues,""):void 0,this.updateSnapshot(),i&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(ND);return}if(this.animationId<=this.animationCommitId){this.nodes.forEach(kD);return}this.animationCommitId=this.animationId,this.isUpdating?(this.isUpdating=!1,this.nodes.forEach(Jq),this.nodes.forEach(Hq),this.nodes.forEach(qq)):this.nodes.forEach(kD),this.clearAllSnapshots();const o=Ks.now();us.delta=Ti(0,1e3/60,o-us.timestamp),us.timestamp=o,us.isProcessing=!0,sS.update.process(us),sS.preRender.process(us),sS.render.process(us),us.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,HC.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(Yq),this.sharedNodes.forEach(t8)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,Xt.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){Xt.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure(),this.snapshot&&!Es(this.snapshot.measuredBox.x)&&!Es(this.snapshot.measuredBox.y)&&(this.snapshot=void 0))}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const i=this.layout;this.layout=this.measure(!1),this.layoutVersion++,this.layoutCorrected=On(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:o}=this.options;o&&o.notify("LayoutMeasure",this.layout.layoutBox,i?i.layoutBox:void 0)}updateScroll(i="measure"){let o=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===i&&(o=!1),o&&this.instance){const l=s(this.instance);this.scroll={animationId:this.root.animationId,phase:i,isRoot:l,offset:t(this.instance),wasRoot:this.scroll?this.scroll.isRoot:l}}}resetTransform(){if(!r)return;const i=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,o=this.projectionDelta&&!kL(this.projectionDelta),l=this.getTransformTemplate(),h=l?l(this.latestValues,""):void 0,d=h!==this.prevTransformTemplateValue;i&&this.instance&&(o||Sl(this.latestValues)||d)&&(r(this.instance,h),this.shouldResetTransform=!1,this.scheduleRender())}measure(i=!0){const o=this.measurePageBox();let l=this.removeElementScroll(o);return i&&(l=this.removeTransform(l)),a8(l),{animationId:this.root.animationId,measuredBox:o,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:i}=this.options;if(!i)return On();const o=i.measureViewportBox();if(!(this.scroll?.wasRoot||this.path.some(i8))){const{scroll:h}=this.root;h&&(kc(o.x,h.offset.x),kc(o.y,h.offset.y))}return o}removeElementScroll(i){const o=On();if(sa(o,i),this.scroll?.wasRoot)return o;for(let l=0;l<this.path.length;l++){const h=this.path[l],{scroll:d,options:f}=h;h!==this.root&&d&&f.layoutScroll&&(d.wasRoot&&sa(o,i),kc(o.x,d.offset.x),kc(o.y,d.offset.y))}return o}applyTransform(i,o=!1){const l=On();sa(l,i);for(let h=0;h<this.path.length;h++){const d=this.path[h];!o&&d.options.layoutScroll&&d.scroll&&d!==d.root&&Ec(l,{x:-d.scroll.offset.x,y:-d.scroll.offset.y}),Sl(d.latestValues)&&Ec(l,d.latestValues)}return Sl(this.latestValues)&&Ec(l,this.latestValues),l}removeTransform(i){const o=On();sa(o,i);for(let l=0;l<this.path.length;l++){const h=this.path[l];if(!h.instance||!Sl(h.latestValues))continue;aT(h.latestValues)&&h.updateSnapshot();const d=On(),f=h.measurePageBox();sa(d,f),xD(o,h.latestValues,h.snapshot?h.snapshot.layoutBox:void 0,d)}return Sl(this.latestValues)&&xD(o,this.latestValues),o}setTargetDelta(i){this.targetDelta=i,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(i){this.options={...this.options,...i,crossfade:i.crossfade!==void 0?i.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==us.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(i=!1){const o=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=o.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=o.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=o.isSharedProjectionDirty);const l=!!this.resumingFrom||this!==o;if(!(i||l&&this.isSharedProjectionDirty||this.isProjectionDirty||this.parent?.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:f}=this.options;if(!this.layout||!(d||f))return;this.resolvedRelativeTargetAt=us.timestamp;const m=this.getClosestProjectingParent();m&&this.linkedParentVersion!==m.layoutVersion&&!m.options.layoutRoot&&this.removeRelativeTarget(),!this.targetDelta&&!this.relativeTarget&&(m&&m.layout?this.createRelativeTarget(m,this.layout.layoutBox,m.layout.layoutBox):this.removeRelativeTarget()),!(!this.relativeTarget&&!this.targetDelta)&&(this.target||(this.target=On(),this.targetWithTransforms=On()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),pq(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):sa(this.target,this.layout.layoutBox),oL(this.target,this.targetDelta)):sa(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget&&(this.attemptToResolveRelativeTarget=!1,m&&!!m.resumingFrom==!!this.resumingFrom&&!m.options.layoutScroll&&m.target&&this.animationProgress!==1?this.createRelativeTarget(m,this.target,m.target):this.relativeParent=this.relativeTarget=void 0))}getClosestProjectingParent(){if(!(!this.parent||aT(this.parent.latestValues)||iL(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}createRelativeTarget(i,o,l){this.relativeParent=i,this.linkedParentVersion=i.layoutVersion,this.forceRelativeParentToResolveTarget(),this.relativeTarget=On(),this.relativeTargetOrigin=On(),w0(this.relativeTargetOrigin,o,l),sa(this.relativeTarget,this.relativeTargetOrigin)}removeRelativeTarget(){this.relativeParent=this.relativeTarget=void 0}calcProjection(){const i=this.getLead(),o=!!this.resumingFrom||this!==i;let l=!0;if((this.isProjectionDirty||this.parent?.isProjectionDirty)&&(l=!1),o&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(l=!1),this.resolvedRelativeTargetAt===us.timestamp&&(l=!1),l)return;const{layout:h,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(h||d))return;sa(this.layoutCorrected,this.layout.layoutBox);const f=this.treeScale.x,m=this.treeScale.y;k6(this.layoutCorrected,this.treeScale,this.path,o),i.layout&&!i.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(i.target=i.layout.layoutBox,i.targetWithTransforms=On());const{target:y}=i;if(!y){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(gD(this.prevProjectionDelta.x,this.projectionDelta.x),gD(this.prevProjectionDelta.y,this.projectionDelta.y)),Df(this.projectionDelta,this.layoutCorrected,y,this.latestValues),(this.treeScale.x!==f||this.treeScale.y!==m||!CD(this.projectionDelta.x,this.prevProjectionDelta.x)||!CD(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",y))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(i=!0){if(this.options.visualElement?.scheduleRender(),i){const o=this.getStack();o&&o.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=$c(),this.projectionDelta=$c(),this.projectionDeltaWithTransform=$c()}setAnimationOrigin(i,o=!1){const l=this.snapshot,h=l?l.latestValues:{},d={...this.latestValues},f=$c();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!o;const m=On(),y=l?l.source:void 0,b=this.layout?this.layout.source:void 0,x=y!==b,w=this.getStack(),v=!w||w.members.length<=1,C=!!(x&&!v&&this.options.crossfade===!0&&!this.path.some(s8));this.animationProgress=0;let N;this.mixTargetDelta=k=>{const E=k/1e3;$D(f.x,i.x,E),$D(f.y,i.y,E),this.setTargetDelta(f),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(w0(m,this.layout.layoutBox,this.relativeParent.layout.layoutBox),n8(this.relativeTarget,this.relativeTargetOrigin,m,E),N&&Vq(this.relativeTarget,N)&&(this.isProjectionDirty=!1),N||(N=On()),sa(N,this.relativeTarget)),x&&(this.animationValues=d,Fq(d,h,this.latestValues,E,C,v)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(i){this.notifyListeners("animationStart"),this.currentAnimation?.stop(),this.resumingFrom?.currentAnimation?.stop(),this.pendingAnimation&&(ko(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=Xt.update(()=>{Jy.hasAnimatedSinceResize=!0,this.motionValue||(this.motionValue=Fc(0)),this.currentAnimation=_q(this.motionValue,[0,1e3],{...i,velocity:0,isSync:!0,onUpdate:o=>{this.mixTargetDelta(o),i.onUpdate&&i.onUpdate(o)},onStop:()=>{},onComplete:()=>{i.onComplete&&i.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const i=this.getStack();i&&i.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(Wq),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const i=this.getLead();let{targetWithTransforms:o,target:l,layout:h,latestValues:d}=i;if(!(!o||!l||!h)){if(this!==i&&this.layout&&h&&_L(this.options.animationType,this.layout.layoutBox,h.layoutBox)){l=this.target||On();const f=Es(this.layout.layoutBox.x);l.x.min=i.target.x.min,l.x.max=l.x.min+f;const m=Es(this.layout.layoutBox.y);l.y.min=i.target.y.min,l.y.max=l.y.min+m}sa(o,l),Ec(o,d),Df(this.projectionDeltaWithTransform,this.layoutCorrected,o,d)}}registerSharedNode(i,o){this.sharedNodes.has(i)||this.sharedNodes.set(i,new Uq),this.sharedNodes.get(i).add(o);const h=o.options.initialPromotionConfig;o.promote({transition:h?h.transition:void 0,preserveFollowOpacity:h&&h.shouldPreserveFollowOpacity?h.shouldPreserveFollowOpacity(o):void 0})}isLead(){const i=this.getStack();return i?i.lead===this:!0}getLead(){const{layoutId:i}=this.options;return i?this.getStack()?.lead||this:this}getPrevLead(){const{layoutId:i}=this.options;return i?this.getStack()?.prevLead:void 0}getStack(){const{layoutId:i}=this.options;if(i)return this.root.sharedNodes.get(i)}promote({needsReset:i,transition:o,preserveFollowOpacity:l}={}){const h=this.getStack();h&&h.promote(this,l),i&&(this.projectionDelta=void 0,this.needsReset=!0),o&&this.setOptions({transition:o})}relegate(){const i=this.getStack();return i?i.relegate(this):!1}resetSkewAndRotation(){const{visualElement:i}=this.options;if(!i)return;let o=!1;const{latestValues:l}=i;if((l.z||l.rotate||l.rotateX||l.rotateY||l.rotateZ||l.skewX||l.skewY)&&(o=!0),!o)return;const h={};l.z&&mS("z",i,h,this.animationValues);for(let d=0;d<pS.length;d++)mS(`rotate${pS[d]}`,i,h,this.animationValues),mS(`skew${pS[d]}`,i,h,this.animationValues);i.render();for(const d in h)i.setStaticValue(d,h[d]),this.animationValues&&(this.animationValues[d]=h[d]);i.scheduleRender()}applyProjectionStyles(i,o){if(!this.instance||this.isSVG)return;if(!this.isVisible){i.visibility="hidden";return}const l=this.getTransformTemplate();if(this.needsReset){this.needsReset=!1,i.visibility="",i.opacity="",i.pointerEvents=Yy(o?.pointerEvents)||"",i.transform=l?l(this.latestValues,""):"none";return}const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){this.options.layoutId&&(i.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,i.pointerEvents=Yy(o?.pointerEvents)||""),this.hasProjected&&!Sl(this.latestValues)&&(i.transform=l?l({},""):"none",this.hasProjected=!1);return}i.visibility="";const d=h.animationValues||h.latestValues;this.applyTransformsToTarget();let f=jq(this.projectionDeltaWithTransform,this.treeScale,d);l&&(f=l(d,f)),i.transform=f;const{x:m,y}=this.projectionDelta;i.transformOrigin=`${m.origin*100}% ${y.origin*100}% 0`,h.animationValues?i.opacity=h===this?d.opacity??this.latestValues.opacity??1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:i.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const b in rT){if(d[b]===void 0)continue;const{correct:x,applyTo:w,isCSSVariable:v}=rT[b],C=f==="none"?d[b]:x(d[b],h);if(w){const N=w.length;for(let k=0;k<N;k++)i[w[k]]=C}else v?this.options.visualElement.renderState.vars[b]=C:i[b]=C}this.options.layoutId&&(i.pointerEvents=h===this?Yy(o?.pointerEvents)||"":"none")}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(i=>i.currentAnimation?.stop()),this.root.nodes.forEach(ND),this.root.sharedNodes.clear()}}}function Hq(n){n.updateLayout()}function qq(n){const e=n.resumeFrom?.snapshot||n.snapshot;if(n.isLead()&&n.layout&&e&&n.hasListeners("didUpdate")){const{layoutBox:t,measuredBox:s}=n.layout,{animationType:r}=n.options,a=e.source!==n.layout.source;r==="size"?Pr(d=>{const f=a?e.measuredBox[d]:e.layoutBox[d],m=Es(f);f.min=t[d].min,f.max=f.min+m}):_L(r,e.layoutBox,t)&&Pr(d=>{const f=a?e.measuredBox[d]:e.layoutBox[d],m=Es(t[d]);f.max=f.min+m,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+m)});const i=$c();Df(i,t,e.layoutBox);const o=$c();a?Df(o,n.applyTransform(s,!0),e.measuredBox):Df(o,t,e.layoutBox);const l=!kL(i);let h=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:f,layout:m}=d;if(f&&m){const y=On();w0(y,e.layoutBox,f.layoutBox);const b=On();w0(b,t,m.layoutBox),EL(y,b)||(h=!0),d.options.layoutRoot&&(n.relativeTarget=b,n.relativeTargetOrigin=y,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:t,snapshot:e,delta:o,layoutDelta:i,hasLayoutChanged:l,hasRelativeLayoutChanged:h})}else if(n.isLead()){const{onExitComplete:t}=n.options;t&&t()}n.options.transition=void 0}function Kq(n){n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function Xq(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function Yq(n){n.clearSnapshot()}function ND(n){n.clearMeasurements()}function kD(n){n.isLayoutDirty=!1}function Jq(n){const{visualElement:e}=n.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),n.resetTransform()}function ED(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function Zq(n){n.resolveTargetDelta()}function Qq(n){n.calcProjection()}function e8(n){n.resetSkewAndRotation()}function t8(n){n.removeLeadSnapshot()}function $D(n,e,t){n.translate=en(e.translate,0,t),n.scale=en(e.scale,1,t),n.origin=e.origin,n.originPoint=e.originPoint}function ID(n,e,t,s){n.min=en(e.min,t.min,s),n.max=en(e.max,t.max,s)}function n8(n,e,t,s){ID(n.x,e.x,t.x,s),ID(n.y,e.y,t.y,s)}function s8(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const r8={duration:.45,ease:[.4,0,.1,1]},_D=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),AD=_D("applewebkit/")&&!_D("chrome/")?Math.round:Hr;function RD(n){n.min=AD(n.min),n.max=AD(n.max)}function a8(n){RD(n.x),RD(n.y)}function _L(n,e,t){return n==="position"||n==="preserve-aspect"&&!fq(TD(e),TD(t),.2)}function i8(n){return n!==n.root&&n.scroll?.wasRoot}const o8=IL({attachResizeListener:(n,e)=>jf(n,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),gS={current:void 0},AL=IL({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!gS.current){const n=new o8({});n.mount(window),n.setOptions({layoutScroll:!0}),gS.current=n}return gS.current},resetTransform:(n,e)=>{n.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),l8={pan:{Feature:$q},drag:{Feature:Eq,ProjectionNode:AL,MeasureLayout:TL}};function DD(n,e,t){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",t==="Start");const r="onHover"+t,a=s[r];a&&Xt.postRender(()=>a(e,xp(e)))}class u8 extends Po{mount(){const{current:e}=this.node;e&&(this.unmount=AH(e,(t,s)=>(DD(this.node,s,"Start"),r=>DD(this.node,r,"End"))))}unmount(){}}class c8 extends Po{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=gp(jf(this.node.current,"focus",()=>this.onFocus()),jf(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function OD(n,e,t){const{props:s}=n;if(n.current instanceof HTMLButtonElement&&n.current.disabled)return;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",t==="Start");const r="onTap"+(t==="End"?"":t),a=s[r];a&&Xt.postRender(()=>a(e,xp(e)))}class h8 extends Po{mount(){const{current:e}=this.node;e&&(this.unmount=FH(e,(t,s)=>(OD(this.node,s,"Start"),(r,{success:a})=>OD(this.node,r,a?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const dT=new WeakMap,yS=new WeakMap,d8=n=>{const e=dT.get(n.target);e&&e(n)},f8=n=>{n.forEach(d8)};function p8({root:n,...e}){const t=n||document;yS.has(t)||yS.set(t,{});const s=yS.get(t),r=JSON.stringify(e);return s[r]||(s[r]=new IntersectionObserver(f8,{root:n,...e})),s[r]}function m8(n,e,t){const s=p8(e);return dT.set(n,t),s.observe(n),()=>{dT.delete(n),s.unobserve(n)}}const g8={some:0,all:1};class y8 extends Po{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:s,amount:r="some",once:a}=e,i={root:t?t.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:g8[r]},o=l=>{const{isIntersecting:h}=l;if(this.isInView===h||(this.isInView=h,a&&!h&&this.hasEnteredView))return;h&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",h);const{onViewportEnter:d,onViewportLeave:f}=this.node.getProps(),m=h?d:f;m&&m(l)};return m8(this.node.current,i,o)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(b8(e,t))&&this.startObserver()}unmount(){}}function b8({viewport:n={}},{viewport:e={}}={}){return t=>n[t]!==e[t]}const x8={inView:{Feature:y8},tap:{Feature:h8},focus:{Feature:c8},hover:{Feature:u8}},w8={layout:{ProjectionNode:AL,MeasureLayout:TL}},v8={...oq,...x8,...l8,...w8},yl=T6(v8,L6);const S8=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),T8=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(e,t,s)=>s?s.toUpperCase():t.toLowerCase()),FD=n=>{const e=T8(n);return e.charAt(0).toUpperCase()+e.slice(1)},RL=(...n)=>n.filter((e,t,s)=>!!e&&e.trim()!==""&&s.indexOf(e)===t).join(" ").trim(),C8=n=>{for(const e in n)if(e.startsWith("aria-")||e==="role"||e==="title")return!0};var N8={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const k8=Ce.forwardRef(({color:n="currentColor",size:e=24,strokeWidth:t=2,absoluteStrokeWidth:s,className:r="",children:a,iconNode:i,...o},l)=>Ce.createElement("svg",{ref:l,...N8,width:e,height:e,stroke:n,strokeWidth:s?Number(t)*24/Number(e):t,className:RL("lucide",r),...!a&&!C8(o)&&{"aria-hidden":"true"},...o},[...i.map(([h,d])=>Ce.createElement(h,d)),...Array.isArray(a)?a:[a]]));const er=(n,e)=>{const t=Ce.forwardRef(({className:s,...r},a)=>Ce.createElement(k8,{ref:a,iconNode:e,className:RL(`lucide-${S8(FD(n))}`,`lucide-${n}`,s),...r}));return t.displayName=FD(n),t};const E8=[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]],$8=er("activity",E8);const I8=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]],_8=er("circle-check",I8);const A8=[["rect",{width:"14",height:"14",x:"8",y:"8",rx:"2",ry:"2",key:"17jyea"}],["path",{d:"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",key:"zix9uf"}]],R8=er("copy",A8);const D8=[["path",{d:"M12 20v2",key:"1lh1kg"}],["path",{d:"M12 2v2",key:"tus03m"}],["path",{d:"M17 20v2",key:"1rnc9c"}],["path",{d:"M17 2v2",key:"11trls"}],["path",{d:"M2 12h2",key:"1t8f8n"}],["path",{d:"M2 17h2",key:"7oei6x"}],["path",{d:"M2 7h2",key:"asdhe0"}],["path",{d:"M20 12h2",key:"1q8mjw"}],["path",{d:"M20 17h2",key:"1fpfkl"}],["path",{d:"M20 7h2",key:"1o8tra"}],["path",{d:"M7 20v2",key:"4gnj0m"}],["path",{d:"M7 2v2",key:"1i4yhu"}],["rect",{x:"4",y:"4",width:"16",height:"16",rx:"2",key:"1vbyd7"}],["rect",{x:"8",y:"8",width:"8",height:"8",rx:"1",key:"z9xiuo"}]],O8=er("cpu",D8);const F8=[["path",{d:"M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",key:"1357e3"}],["path",{d:"M3 3v5h5",key:"1xhq8a"}],["path",{d:"M12 7v5l4 2",key:"1fdv2h"}]],LD=er("history",F8);const L8=[["rect",{width:"18",height:"11",x:"3",y:"11",rx:"2",ry:"2",key:"1w4ew1"}],["path",{d:"M7 11V7a5 5 0 0 1 10 0v4",key:"fwvmzm"}]],M8=er("lock",L8);const z8=[["path",{d:"m16 17 5-5-5-5",key:"1bji2h"}],["path",{d:"M21 12H9",key:"dn1m92"}],["path",{d:"M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",key:"1uf3rs"}]],P8=er("log-out",z8);const B8=[["path",{d:"m21 21-4.34-4.34",key:"14j7rj"}],["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}]],V8=er("search",B8);const U8=[["circle",{cx:"18",cy:"5",r:"3",key:"gq8acd"}],["circle",{cx:"6",cy:"12",r:"3",key:"w7nqdw"}],["circle",{cx:"18",cy:"19",r:"3",key:"1xt0gg"}],["line",{x1:"8.59",x2:"15.42",y1:"13.51",y2:"17.49",key:"47mynk"}],["line",{x1:"15.41",x2:"8.59",y1:"6.51",y2:"10.49",key:"1n3mei"}]],j8=er("share-2",U8);const W8=[["path",{d:"M16 17h6v-6",key:"t6n2it"}],["path",{d:"m22 17-8.5-8.5-5 5L2 7",key:"x473p"}]],MD=er("trending-down",W8);const G8=[["path",{d:"M16 7h6v6",key:"box55l"}],["path",{d:"m22 7-8.5 8.5-5-5L2 17",key:"1t1m79"}]],zD=er("trending-up",G8);const H8=[["path",{d:"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",key:"wmoenq"}],["path",{d:"M12 9v4",key:"juzpu7"}],["path",{d:"M12 17h.01",key:"p32p05"}]],q8=er("triangle-alert",H8);const K8=[["path",{d:"M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978",key:"1n3hpd"}],["path",{d:"M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978",key:"rfe1zi"}],["path",{d:"M18 9h1.5a1 1 0 0 0 0-5H18",key:"7xy6bh"}],["path",{d:"M4 22h16",key:"57wxv0"}],["path",{d:"M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z",key:"1mhfuq"}],["path",{d:"M6 9H4.5a1 1 0 0 1 0-5H6",key:"tex48p"}]],X8=er("trophy",K8);const Y8=[["path",{d:"M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",key:"1xq2db"}]],PD=er("zap",Y8);function cb(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t}function J8(n,e,t,s){function r(a){return a instanceof t?a:new t(function(i){i(a)})}return new(t||(t=Promise))(function(a,i){function o(d){try{h(s.next(d))}catch(f){i(f)}}function l(d){try{h(s.throw(d))}catch(f){i(f)}}function h(d){d.done?a(d.value):r(d.value).then(o,l)}h((s=s.apply(n,e||[])).next())})}const Z8=n=>n?(...e)=>n(...e):(...e)=>fetch(...e);class r2 extends Error{constructor(e,t="FunctionsError",s){super(e),this.name=t,this.context=s}}class Q8 extends r2{constructor(e){super("Failed to send a request to the Edge Function","FunctionsFetchError",e)}}class BD extends r2{constructor(e){super("Relay Error invoking the Edge Function","FunctionsRelayError",e)}}class VD extends r2{constructor(e){super("Edge Function returned a non-2xx status code","FunctionsHttpError",e)}}var fT;(function(n){n.Any="any",n.ApNortheast1="ap-northeast-1",n.ApNortheast2="ap-northeast-2",n.ApSouth1="ap-south-1",n.ApSoutheast1="ap-southeast-1",n.ApSoutheast2="ap-southeast-2",n.CaCentral1="ca-central-1",n.EuCentral1="eu-central-1",n.EuWest1="eu-west-1",n.EuWest2="eu-west-2",n.EuWest3="eu-west-3",n.SaEast1="sa-east-1",n.UsEast1="us-east-1",n.UsWest1="us-west-1",n.UsWest2="us-west-2"})(fT||(fT={}));class eK{constructor(e,{headers:t={},customFetch:s,region:r=fT.Any}={}){this.url=e,this.headers=t,this.region=r,this.fetch=Z8(s)}setAuth(e){this.headers.Authorization=`Bearer ${e}`}invoke(e){return J8(this,arguments,void 0,function*(t,s={}){var r;let a,i;try{const{headers:o,method:l,body:h,signal:d,timeout:f}=s;let m={},{region:y}=s;y||(y=this.region);const b=new URL(`${this.url}/${t}`);y&&y!=="any"&&(m["x-region"]=y,b.searchParams.set("forceFunctionRegion",y));let x;h&&(o&&!Object.prototype.hasOwnProperty.call(o,"Content-Type")||!o)?typeof Blob<"u"&&h instanceof Blob||h instanceof ArrayBuffer?(m["Content-Type"]="application/octet-stream",x=h):typeof h=="string"?(m["Content-Type"]="text/plain",x=h):typeof FormData<"u"&&h instanceof FormData?x=h:(m["Content-Type"]="application/json",x=JSON.stringify(h)):x=h;let w=d;f&&(i=new AbortController,a=setTimeout(()=>i.abort(),f),d?(w=i.signal,d.addEventListener("abort",()=>i.abort())):w=i.signal);const v=yield this.fetch(b.toString(),{method:l||"POST",headers:Object.assign(Object.assign(Object.assign({},m),this.headers),o),body:x,signal:w}).catch(E=>{throw new Q8(E)}),C=v.headers.get("x-relay-error");if(C&&C==="true")throw new BD(v);if(!v.ok)throw new VD(v);let N=((r=v.headers.get("Content-Type"))!==null&&r!==void 0?r:"text/plain").split(";")[0].trim(),k;return N==="application/json"?k=yield v.json():N==="application/octet-stream"||N==="application/pdf"?k=yield v.blob():N==="text/event-stream"?k=v:N==="multipart/form-data"?k=yield v.formData():k=yield v.text(),{data:k,error:null,response:v}}catch(o){return{data:null,error:o,response:o instanceof VD||o instanceof BD?o.context:void 0}}finally{a&&clearTimeout(a)}})}}var tK=class extends Error{constructor(n){super(n.message),this.name="PostgrestError",this.details=n.details,this.hint=n.hint,this.code=n.code}},nK=class{constructor(n){var e,t;this.shouldThrowOnError=!1,this.method=n.method,this.url=n.url,this.headers=new Headers(n.headers),this.schema=n.schema,this.body=n.body,this.shouldThrowOnError=(e=n.shouldThrowOnError)!==null&&e!==void 0?e:!1,this.signal=n.signal,this.isMaybeSingle=(t=n.isMaybeSingle)!==null&&t!==void 0?t:!1,n.fetch?this.fetch=n.fetch:this.fetch=fetch}throwOnError(){return this.shouldThrowOnError=!0,this}setHeader(n,e){return this.headers=new Headers(this.headers),this.headers.set(n,e),this}then(n,e){var t=this;this.schema===void 0||(["GET","HEAD"].includes(this.method)?this.headers.set("Accept-Profile",this.schema):this.headers.set("Content-Profile",this.schema)),this.method!=="GET"&&this.method!=="HEAD"&&this.headers.set("Content-Type","application/json");const s=this.fetch;let r=s(this.url.toString(),{method:this.method,headers:this.headers,body:JSON.stringify(this.body),signal:this.signal}).then(async a=>{let i=null,o=null,l=null,h=a.status,d=a.statusText;if(a.ok){var f,m;if(t.method!=="HEAD"){var y;const v=await a.text();v===""||(t.headers.get("Accept")==="text/csv"||t.headers.get("Accept")&&(!((y=t.headers.get("Accept"))===null||y===void 0)&&y.includes("application/vnd.pgrst.plan+text"))?o=v:o=JSON.parse(v))}const x=(f=t.headers.get("Prefer"))===null||f===void 0?void 0:f.match(/count=(exact|planned|estimated)/),w=(m=a.headers.get("content-range"))===null||m===void 0?void 0:m.split("/");x&&w&&w.length>1&&(l=parseInt(w[1])),t.isMaybeSingle&&t.method==="GET"&&Array.isArray(o)&&(o.length>1?(i={code:"PGRST116",details:`Results contain ${o.length} rows, application/vnd.pgrst.object+json requires 1 row`,hint:null,message:"JSON object requested, multiple (or no) rows returned"},o=null,l=null,h=406,d="Not Acceptable"):o.length===1?o=o[0]:o=null)}else{var b;const x=await a.text();try{i=JSON.parse(x),Array.isArray(i)&&a.status===404&&(o=[],i=null,h=200,d="OK")}catch{a.status===404&&x===""?(h=204,d="No Content"):i={message:x}}if(i&&t.isMaybeSingle&&(!(i==null||(b=i.details)===null||b===void 0)&&b.includes("0 rows"))&&(i=null,h=200,d="OK"),i&&t.shouldThrowOnError)throw new tK(i)}return{error:i,data:o,count:l,status:h,statusText:d}});return this.shouldThrowOnError||(r=r.catch(a=>{var i;let o="";const l=a?.cause;if(l){var h,d,f,m;const b=(h=l?.message)!==null&&h!==void 0?h:"",x=(d=l?.code)!==null&&d!==void 0?d:"";o=`${(f=a?.name)!==null&&f!==void 0?f:"FetchError"}: ${a?.message}`,o+=`

Caused by: ${(m=l?.name)!==null&&m!==void 0?m:"Error"}: ${b}`,x&&(o+=` (${x})`),l?.stack&&(o+=`
${l.stack}`)}else{var y;o=(y=a?.stack)!==null&&y!==void 0?y:""}return{error:{message:`${(i=a?.name)!==null&&i!==void 0?i:"FetchError"}: ${a?.message}`,details:o,hint:"",code:""},data:null,count:null,status:0,statusText:""}})),r.then(n,e)}returns(){return this}overrideTypes(){return this}},sK=class extends nK{select(n){let e=!1;const t=(n??"*").split("").map(s=>/\s/.test(s)&&!e?"":(s==='"'&&(e=!e),s)).join("");return this.url.searchParams.set("select",t),this.headers.append("Prefer","return=representation"),this}order(n,{ascending:e=!0,nullsFirst:t,foreignTable:s,referencedTable:r=s}={}){const a=r?`${r}.order`:"order",i=this.url.searchParams.get(a);return this.url.searchParams.set(a,`${i?`${i},`:""}${n}.${e?"asc":"desc"}${t===void 0?"":t?".nullsfirst":".nullslast"}`),this}limit(n,{foreignTable:e,referencedTable:t=e}={}){const s=typeof t>"u"?"limit":`${t}.limit`;return this.url.searchParams.set(s,`${n}`),this}range(n,e,{foreignTable:t,referencedTable:s=t}={}){const r=typeof s>"u"?"offset":`${s}.offset`,a=typeof s>"u"?"limit":`${s}.limit`;return this.url.searchParams.set(r,`${n}`),this.url.searchParams.set(a,`${e-n+1}`),this}abortSignal(n){return this.signal=n,this}single(){return this.headers.set("Accept","application/vnd.pgrst.object+json"),this}maybeSingle(){return this.method==="GET"?this.headers.set("Accept","application/json"):this.headers.set("Accept","application/vnd.pgrst.object+json"),this.isMaybeSingle=!0,this}csv(){return this.headers.set("Accept","text/csv"),this}geojson(){return this.headers.set("Accept","application/geo+json"),this}explain({analyze:n=!1,verbose:e=!1,settings:t=!1,buffers:s=!1,wal:r=!1,format:a="text"}={}){var i;const o=[n?"analyze":null,e?"verbose":null,t?"settings":null,s?"buffers":null,r?"wal":null].filter(Boolean).join("|"),l=(i=this.headers.get("Accept"))!==null&&i!==void 0?i:"application/json";return this.headers.set("Accept",`application/vnd.pgrst.plan+${a}; for="${l}"; options=${o};`),a==="json"?this:this}rollback(){return this.headers.append("Prefer","tx=rollback"),this}returns(){return this}maxAffected(n){return this.headers.append("Prefer","handling=strict"),this.headers.append("Prefer",`max-affected=${n}`),this}};const UD=new RegExp("[,()]");var xc=class extends sK{eq(n,e){return this.url.searchParams.append(n,`eq.${e}`),this}neq(n,e){return this.url.searchParams.append(n,`neq.${e}`),this}gt(n,e){return this.url.searchParams.append(n,`gt.${e}`),this}gte(n,e){return this.url.searchParams.append(n,`gte.${e}`),this}lt(n,e){return this.url.searchParams.append(n,`lt.${e}`),this}lte(n,e){return this.url.searchParams.append(n,`lte.${e}`),this}like(n,e){return this.url.searchParams.append(n,`like.${e}`),this}likeAllOf(n,e){return this.url.searchParams.append(n,`like(all).{${e.join(",")}}`),this}likeAnyOf(n,e){return this.url.searchParams.append(n,`like(any).{${e.join(",")}}`),this}ilike(n,e){return this.url.searchParams.append(n,`ilike.${e}`),this}ilikeAllOf(n,e){return this.url.searchParams.append(n,`ilike(all).{${e.join(",")}}`),this}ilikeAnyOf(n,e){return this.url.searchParams.append(n,`ilike(any).{${e.join(",")}}`),this}regexMatch(n,e){return this.url.searchParams.append(n,`match.${e}`),this}regexIMatch(n,e){return this.url.searchParams.append(n,`imatch.${e}`),this}is(n,e){return this.url.searchParams.append(n,`is.${e}`),this}isDistinct(n,e){return this.url.searchParams.append(n,`isdistinct.${e}`),this}in(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&UD.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`in.(${t})`),this}notIn(n,e){const t=Array.from(new Set(e)).map(s=>typeof s=="string"&&UD.test(s)?`"${s}"`:`${s}`).join(",");return this.url.searchParams.append(n,`not.in.(${t})`),this}contains(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cs.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cs.{${e.join(",")}}`):this.url.searchParams.append(n,`cs.${JSON.stringify(e)}`),this}containedBy(n,e){return typeof e=="string"?this.url.searchParams.append(n,`cd.${e}`):Array.isArray(e)?this.url.searchParams.append(n,`cd.{${e.join(",")}}`):this.url.searchParams.append(n,`cd.${JSON.stringify(e)}`),this}rangeGt(n,e){return this.url.searchParams.append(n,`sr.${e}`),this}rangeGte(n,e){return this.url.searchParams.append(n,`nxl.${e}`),this}rangeLt(n,e){return this.url.searchParams.append(n,`sl.${e}`),this}rangeLte(n,e){return this.url.searchParams.append(n,`nxr.${e}`),this}rangeAdjacent(n,e){return this.url.searchParams.append(n,`adj.${e}`),this}overlaps(n,e){return typeof e=="string"?this.url.searchParams.append(n,`ov.${e}`):this.url.searchParams.append(n,`ov.{${e.join(",")}}`),this}textSearch(n,e,{config:t,type:s}={}){let r="";s==="plain"?r="pl":s==="phrase"?r="ph":s==="websearch"&&(r="w");const a=t===void 0?"":`(${t})`;return this.url.searchParams.append(n,`${r}fts${a}.${e}`),this}match(n){return Object.entries(n).forEach(([e,t])=>{this.url.searchParams.append(e,`eq.${t}`)}),this}not(n,e,t){return this.url.searchParams.append(n,`not.${e}.${t}`),this}or(n,{foreignTable:e,referencedTable:t=e}={}){const s=t?`${t}.or`:"or";return this.url.searchParams.append(s,`(${n})`),this}filter(n,e,t){return this.url.searchParams.append(n,`${e}.${t}`),this}},rK=class{constructor(n,{headers:e={},schema:t,fetch:s}){this.url=n,this.headers=new Headers(e),this.schema=t,this.fetch=s}select(n,e){const{head:t=!1,count:s}=e??{},r=t?"HEAD":"GET";let a=!1;const i=(n??"*").split("").map(o=>/\s/.test(o)&&!a?"":(o==='"'&&(a=!a),o)).join("");return this.url.searchParams.set("select",i),s&&this.headers.append("Prefer",`count=${s}`),new xc({method:r,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch})}insert(n,{count:e,defaultToNull:t=!0}={}){var s;const r="POST";if(e&&this.headers.append("Prefer",`count=${e}`),t||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const a=n.reduce((i,o)=>i.concat(Object.keys(o)),[]);if(a.length>0){const i=[...new Set(a)].map(o=>`"${o}"`);this.url.searchParams.set("columns",i.join(","))}}return new xc({method:r,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(s=this.fetch)!==null&&s!==void 0?s:fetch})}upsert(n,{onConflict:e,ignoreDuplicates:t=!1,count:s,defaultToNull:r=!0}={}){var a;const i="POST";if(this.headers.append("Prefer",`resolution=${t?"ignore":"merge"}-duplicates`),e!==void 0&&this.url.searchParams.set("on_conflict",e),s&&this.headers.append("Prefer",`count=${s}`),r||this.headers.append("Prefer","missing=default"),Array.isArray(n)){const o=n.reduce((l,h)=>l.concat(Object.keys(h)),[]);if(o.length>0){const l=[...new Set(o)].map(h=>`"${h}"`);this.url.searchParams.set("columns",l.join(","))}}return new xc({method:i,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(a=this.fetch)!==null&&a!==void 0?a:fetch})}update(n,{count:e}={}){var t;const s="PATCH";return e&&this.headers.append("Prefer",`count=${e}`),new xc({method:s,url:this.url,headers:this.headers,schema:this.schema,body:n,fetch:(t=this.fetch)!==null&&t!==void 0?t:fetch})}delete({count:n}={}){var e;const t="DELETE";return n&&this.headers.append("Prefer",`count=${n}`),new xc({method:t,url:this.url,headers:this.headers,schema:this.schema,fetch:(e=this.fetch)!==null&&e!==void 0?e:fetch})}},aK=class DL{constructor(e,{headers:t={},schema:s,fetch:r}={}){this.url=e,this.headers=new Headers(t),this.schemaName=s,this.fetch=r}from(e){if(!e||typeof e!="string"||e.trim()==="")throw new Error("Invalid relation name: relation must be a non-empty string.");return new rK(new URL(`${this.url}/${e}`),{headers:new Headers(this.headers),schema:this.schemaName,fetch:this.fetch})}schema(e){return new DL(this.url,{headers:this.headers,schema:e,fetch:this.fetch})}rpc(e,t={},{head:s=!1,get:r=!1,count:a}={}){var i;let o;const l=new URL(`${this.url}/rpc/${e}`);let h;s||r?(o=s?"HEAD":"GET",Object.entries(t).filter(([f,m])=>m!==void 0).map(([f,m])=>[f,Array.isArray(m)?`{${m.join(",")}}`:`${m}`]).forEach(([f,m])=>{l.searchParams.append(f,m)})):(o="POST",h=t);const d=new Headers(this.headers);return a&&d.set("Prefer",`count=${a}`),new xc({method:o,url:l,headers:d,schema:this.schemaName,body:h,fetch:(i=this.fetch)!==null&&i!==void 0?i:fetch})}};class iK{constructor(){}static detectEnvironment(){var e;if(typeof WebSocket<"u")return{type:"native",constructor:WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocket<"u")return{type:"native",constructor:globalThis.WebSocket};if(typeof global<"u"&&typeof global.WebSocket<"u")return{type:"native",constructor:global.WebSocket};if(typeof globalThis<"u"&&typeof globalThis.WebSocketPair<"u"&&typeof globalThis.WebSocket>"u")return{type:"cloudflare",error:"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",workaround:"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."};if(typeof globalThis<"u"&&globalThis.EdgeRuntime||typeof navigator<"u"&&(!((e=navigator.userAgent)===null||e===void 0)&&e.includes("Vercel-Edge")))return{type:"unsupported",error:"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",workaround:"Use serverless functions or a different deployment target for WebSocket functionality."};if(typeof process<"u"){const t=process.versions;if(t&&t.node){const s=t.node,r=parseInt(s.replace(/^v/,"").split(".")[0]);return r>=22?typeof globalThis.WebSocket<"u"?{type:"native",constructor:globalThis.WebSocket}:{type:"unsupported",error:`Node.js ${r} detected but native WebSocket not found.`,workaround:"Provide a WebSocket implementation via the transport option."}:{type:"unsupported",error:`Node.js ${r} detected without native WebSocket support.`,workaround:`For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}}}return{type:"unsupported",error:"Unknown JavaScript runtime without WebSocket support.",workaround:"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."}}static getWebSocketConstructor(){const e=this.detectEnvironment();if(e.constructor)return e.constructor;let t=e.error||"WebSocket not supported in this environment.";throw e.workaround&&(t+=`

Suggested solution: ${e.workaround}`),new Error(t)}static createWebSocket(e,t){const s=this.getWebSocketConstructor();return new s(e,t)}static isWebSocketSupported(){try{const e=this.detectEnvironment();return e.type==="native"||e.type==="ws"}catch{return!1}}}const oK="2.89.0",lK=`realtime-js/${oK}`,OL="1.0.0",uK="2.0.0",jD=OL,pT=1e4,cK=1e3,hK=100;var mo;(function(n){n[n.connecting=0]="connecting",n[n.open=1]="open",n[n.closing=2]="closing",n[n.closed=3]="closed"})(mo||(mo={}));var Dn;(function(n){n.closed="closed",n.errored="errored",n.joined="joined",n.joining="joining",n.leaving="leaving"})(Dn||(Dn={}));var ca;(function(n){n.close="phx_close",n.error="phx_error",n.join="phx_join",n.reply="phx_reply",n.leave="phx_leave",n.access_token="access_token"})(ca||(ca={}));var mT;(function(n){n.websocket="websocket"})(mT||(mT={}));var kl;(function(n){n.Connecting="connecting",n.Open="open",n.Closing="closing",n.Closed="closed"})(kl||(kl={}));class dK{constructor(e){this.HEADER_LENGTH=1,this.USER_BROADCAST_PUSH_META_LENGTH=6,this.KINDS={userBroadcastPush:3,userBroadcast:4},this.BINARY_ENCODING=0,this.JSON_ENCODING=1,this.BROADCAST_EVENT="broadcast",this.allowedMetadataKeys=[],this.allowedMetadataKeys=e??[]}encode(e,t){if(e.event===this.BROADCAST_EVENT&&!(e.payload instanceof ArrayBuffer)&&typeof e.payload.event=="string")return t(this._binaryEncodeUserBroadcastPush(e));let s=[e.join_ref,e.ref,e.topic,e.event,e.payload];return t(JSON.stringify(s))}_binaryEncodeUserBroadcastPush(e){var t;return this._isArrayBuffer((t=e.payload)===null||t===void 0?void 0:t.payload)?this._encodeBinaryUserBroadcastPush(e):this._encodeJsonUserBroadcastPush(e)}_encodeBinaryUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:new ArrayBuffer(0);return this._encodeUserBroadcastPush(e,this.BINARY_ENCODING,r)}_encodeJsonUserBroadcastPush(e){var t,s;const r=(s=(t=e.payload)===null||t===void 0?void 0:t.payload)!==null&&s!==void 0?s:{},i=new TextEncoder().encode(JSON.stringify(r)).buffer;return this._encodeUserBroadcastPush(e,this.JSON_ENCODING,i)}_encodeUserBroadcastPush(e,t,s){var r,a;const i=e.topic,o=(r=e.ref)!==null&&r!==void 0?r:"",l=(a=e.join_ref)!==null&&a!==void 0?a:"",h=e.payload.event,d=this.allowedMetadataKeys?this._pick(e.payload,this.allowedMetadataKeys):{},f=Object.keys(d).length===0?"":JSON.stringify(d);if(l.length>255)throw new Error(`joinRef length ${l.length} exceeds maximum of 255`);if(o.length>255)throw new Error(`ref length ${o.length} exceeds maximum of 255`);if(i.length>255)throw new Error(`topic length ${i.length} exceeds maximum of 255`);if(h.length>255)throw new Error(`userEvent length ${h.length} exceeds maximum of 255`);if(f.length>255)throw new Error(`metadata length ${f.length} exceeds maximum of 255`);const m=this.USER_BROADCAST_PUSH_META_LENGTH+l.length+o.length+i.length+h.length+f.length,y=new ArrayBuffer(this.HEADER_LENGTH+m);let b=new DataView(y),x=0;b.setUint8(x++,this.KINDS.userBroadcastPush),b.setUint8(x++,l.length),b.setUint8(x++,o.length),b.setUint8(x++,i.length),b.setUint8(x++,h.length),b.setUint8(x++,f.length),b.setUint8(x++,t),Array.from(l,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(o,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(i,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(h,v=>b.setUint8(x++,v.charCodeAt(0))),Array.from(f,v=>b.setUint8(x++,v.charCodeAt(0)));var w=new Uint8Array(y.byteLength+s.byteLength);return w.set(new Uint8Array(y),0),w.set(new Uint8Array(s),y.byteLength),w.buffer}decode(e,t){if(this._isArrayBuffer(e)){let s=this._binaryDecode(e);return t(s)}if(typeof e=="string"){const s=JSON.parse(e),[r,a,i,o,l]=s;return t({join_ref:r,ref:a,topic:i,event:o,payload:l})}return t({})}_binaryDecode(e){const t=new DataView(e),s=t.getUint8(0),r=new TextDecoder;if(s===this.KINDS.userBroadcast)return this._decodeUserBroadcast(e,t,r)}_decodeUserBroadcast(e,t,s){const r=t.getUint8(1),a=t.getUint8(2),i=t.getUint8(3),o=t.getUint8(4);let l=this.HEADER_LENGTH+4;const h=s.decode(e.slice(l,l+r));l=l+r;const d=s.decode(e.slice(l,l+a));l=l+a;const f=s.decode(e.slice(l,l+i));l=l+i;const m=e.slice(l,e.byteLength),y=o===this.JSON_ENCODING?JSON.parse(s.decode(m)):m,b={type:this.BROADCAST_EVENT,event:d,payload:y};return i>0&&(b.meta=JSON.parse(f)),{join_ref:null,ref:null,topic:h,event:this.BROADCAST_EVENT,payload:b}}_isArrayBuffer(e){var t;return e instanceof ArrayBuffer||((t=e?.constructor)===null||t===void 0?void 0:t.name)==="ArrayBuffer"}_pick(e,t){return!e||typeof e!="object"?{}:Object.fromEntries(Object.entries(e).filter(([s])=>t.includes(s)))}}class FL{constructor(e,t){this.callback=e,this.timerCalc=t,this.timer=void 0,this.tries=0,this.callback=e,this.timerCalc=t}reset(){this.tries=0,clearTimeout(this.timer),this.timer=void 0}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var Bt;(function(n){n.abstime="abstime",n.bool="bool",n.date="date",n.daterange="daterange",n.float4="float4",n.float8="float8",n.int2="int2",n.int4="int4",n.int4range="int4range",n.int8="int8",n.int8range="int8range",n.json="json",n.jsonb="jsonb",n.money="money",n.numeric="numeric",n.oid="oid",n.reltime="reltime",n.text="text",n.time="time",n.timestamp="timestamp",n.timestamptz="timestamptz",n.timetz="timetz",n.tsrange="tsrange",n.tstzrange="tstzrange"})(Bt||(Bt={}));const WD=(n,e,t={})=>{var s;const r=(s=t.skipTypes)!==null&&s!==void 0?s:[];return e?Object.keys(e).reduce((a,i)=>(a[i]=fK(i,n,e,r),a),{}):{}},fK=(n,e,t,s)=>{const r=e.find(o=>o.name===n),a=r?.type,i=t[n];return a&&!s.includes(a)?LL(a,i):gT(i)},LL=(n,e)=>{if(n.charAt(0)==="_"){const t=n.slice(1,n.length);return yK(e,t)}switch(n){case Bt.bool:return pK(e);case Bt.float4:case Bt.float8:case Bt.int2:case Bt.int4:case Bt.int8:case Bt.numeric:case Bt.oid:return mK(e);case Bt.json:case Bt.jsonb:return gK(e);case Bt.timestamp:return bK(e);case Bt.abstime:case Bt.date:case Bt.daterange:case Bt.int4range:case Bt.int8range:case Bt.money:case Bt.reltime:case Bt.text:case Bt.time:case Bt.timestamptz:case Bt.timetz:case Bt.tsrange:case Bt.tstzrange:return gT(e);default:return gT(e)}},gT=n=>n,pK=n=>{switch(n){case"t":return!0;case"f":return!1;default:return n}},mK=n=>{if(typeof n=="string"){const e=parseFloat(n);if(!Number.isNaN(e))return e}return n},gK=n=>{if(typeof n=="string")try{return JSON.parse(n)}catch{return n}return n},yK=(n,e)=>{if(typeof n!="string")return n;const t=n.length-1,s=n[t];if(n[0]==="{"&&s==="}"){let a;const i=n.slice(1,t);try{a=JSON.parse("["+i+"]")}catch{a=i?i.split(","):[]}return a.map(o=>LL(e,o))}return n},bK=n=>typeof n=="string"?n.replace(" ","T"):n,ML=n=>{const e=new URL(n);return e.protocol=e.protocol.replace(/^ws/i,"http"),e.pathname=e.pathname.replace(/\/+$/,"").replace(/\/socket\/websocket$/i,"").replace(/\/socket$/i,"").replace(/\/websocket$/i,""),e.pathname===""||e.pathname==="/"?e.pathname="/api/broadcast":e.pathname=e.pathname+"/api/broadcast",e.href};class bS{constructor(e,t,s={},r=pT){this.channel=e,this.event=t,this.payload=s,this.timeout=r,this.sent=!1,this.timeoutTimer=void 0,this.ref="",this.receivedResp=null,this.recHooks=[],this.refEvent=null}resend(e){this.timeout=e,this._cancelRefEvent(),this.ref="",this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){this._hasReceived("timeout")||(this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref,join_ref:this.channel._joinRef()}))}updatePayload(e){this.payload=Object.assign(Object.assign({},this.payload),e)}receive(e,t){var s;return this._hasReceived(e)&&t((s=this.receivedResp)===null||s===void 0?void 0:s.response),this.recHooks.push({status:e,callback:t}),this}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket._makeRef(),this.refEvent=this.channel._replyEventName(this.ref);const e=t=>{this._cancelRefEvent(),this._cancelTimeout(),this.receivedResp=t,this._matchReceive(t)};this.channel._on(this.refEvent,{},e),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}trigger(e,t){this.refEvent&&this.channel._trigger(this.refEvent,{status:e,response:t})}destroy(){this._cancelRefEvent(),this._cancelTimeout()}_cancelRefEvent(){this.refEvent&&this.channel._off(this.refEvent,{})}_cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=void 0}_matchReceive({status:e,response:t}){this.recHooks.filter(s=>s.status===e).forEach(s=>s.callback(t))}_hasReceived(e){return this.receivedResp&&this.receivedResp.status===e}}var GD;(function(n){n.SYNC="sync",n.JOIN="join",n.LEAVE="leave"})(GD||(GD={}));class Of{constructor(e,t){this.channel=e,this.state={},this.pendingDiffs=[],this.joinRef=null,this.enabled=!1,this.caller={onJoin:()=>{},onLeave:()=>{},onSync:()=>{}};const s=t?.events||{state:"presence_state",diff:"presence_diff"};this.channel._on(s.state,{},r=>{const{onJoin:a,onLeave:i,onSync:o}=this.caller;this.joinRef=this.channel._joinRef(),this.state=Of.syncState(this.state,r,a,i),this.pendingDiffs.forEach(l=>{this.state=Of.syncDiff(this.state,l,a,i)}),this.pendingDiffs=[],o()}),this.channel._on(s.diff,{},r=>{const{onJoin:a,onLeave:i,onSync:o}=this.caller;this.inPendingSyncState()?this.pendingDiffs.push(r):(this.state=Of.syncDiff(this.state,r,a,i),o())}),this.onJoin((r,a,i)=>{this.channel._trigger("presence",{event:"join",key:r,currentPresences:a,newPresences:i})}),this.onLeave((r,a,i)=>{this.channel._trigger("presence",{event:"leave",key:r,currentPresences:a,leftPresences:i})}),this.onSync(()=>{this.channel._trigger("presence",{event:"sync"})})}static syncState(e,t,s,r){const a=this.cloneDeep(e),i=this.transformState(t),o={},l={};return this.map(a,(h,d)=>{i[h]||(l[h]=d)}),this.map(i,(h,d)=>{const f=a[h];if(f){const m=d.map(w=>w.presence_ref),y=f.map(w=>w.presence_ref),b=d.filter(w=>y.indexOf(w.presence_ref)<0),x=f.filter(w=>m.indexOf(w.presence_ref)<0);b.length>0&&(o[h]=b),x.length>0&&(l[h]=x)}else o[h]=d}),this.syncDiff(a,{joins:o,leaves:l},s,r)}static syncDiff(e,t,s,r){const{joins:a,leaves:i}={joins:this.transformState(t.joins),leaves:this.transformState(t.leaves)};return s||(s=()=>{}),r||(r=()=>{}),this.map(a,(o,l)=>{var h;const d=(h=e[o])!==null&&h!==void 0?h:[];if(e[o]=this.cloneDeep(l),d.length>0){const f=e[o].map(y=>y.presence_ref),m=d.filter(y=>f.indexOf(y.presence_ref)<0);e[o].unshift(...m)}s(o,d,l)}),this.map(i,(o,l)=>{let h=e[o];if(!h)return;const d=l.map(f=>f.presence_ref);h=h.filter(f=>d.indexOf(f.presence_ref)<0),e[o]=h,r(o,h,l),h.length===0&&delete e[o]}),e}static map(e,t){return Object.getOwnPropertyNames(e).map(s=>t(s,e[s]))}static transformState(e){return e=this.cloneDeep(e),Object.getOwnPropertyNames(e).reduce((t,s)=>{const r=e[s];return"metas"in r?t[s]=r.metas.map(a=>(a.presence_ref=a.phx_ref,delete a.phx_ref,delete a.phx_ref_prev,a)):t[s]=r,t},{})}static cloneDeep(e){return JSON.parse(JSON.stringify(e))}onJoin(e){this.caller.onJoin=e}onLeave(e){this.caller.onLeave=e}onSync(e){this.caller.onSync=e}inPendingSyncState(){return!this.joinRef||this.joinRef!==this.channel._joinRef()}}var HD;(function(n){n.ALL="*",n.INSERT="INSERT",n.UPDATE="UPDATE",n.DELETE="DELETE"})(HD||(HD={}));var Ff;(function(n){n.BROADCAST="broadcast",n.PRESENCE="presence",n.POSTGRES_CHANGES="postgres_changes",n.SYSTEM="system"})(Ff||(Ff={}));var gi;(function(n){n.SUBSCRIBED="SUBSCRIBED",n.TIMED_OUT="TIMED_OUT",n.CLOSED="CLOSED",n.CHANNEL_ERROR="CHANNEL_ERROR"})(gi||(gi={}));class Ic{constructor(e,t={config:{}},s){var r,a;if(this.topic=e,this.params=t,this.socket=s,this.bindings={},this.state=Dn.closed,this.joinedOnce=!1,this.pushBuffer=[],this.subTopic=e.replace(/^realtime:/i,""),this.params.config=Object.assign({broadcast:{ack:!1,self:!1},presence:{key:"",enabled:!1},private:!1},t.config),this.timeout=this.socket.timeout,this.joinPush=new bS(this,ca.join,this.params,this.timeout),this.rejoinTimer=new FL(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Dn.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(i=>i.send()),this.pushBuffer=[]}),this._onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this._joinRef()}`),this.state=Dn.closed,this.socket._remove(this)}),this._onError(i=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,i),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("timeout",()=>{this._isJoining()&&(this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this.joinPush.receive("error",i=>{this._isLeaving()||this._isClosed()||(this.socket.log("channel",`error ${this.topic}`,i),this.state=Dn.errored,this.rejoinTimer.scheduleTimeout())}),this._on(ca.reply,{},(i,o)=>{this._trigger(this._replyEventName(o),i)}),this.presence=new Of(this),this.broadcastEndpointURL=ML(this.socket.endPoint),this.private=this.params.config.private||!1,!this.private&&(!((a=(r=this.params.config)===null||r===void 0?void 0:r.broadcast)===null||a===void 0)&&a.replay))throw`tried to use replay on public channel '${this.topic}'. It must be a private channel.`}subscribe(e,t=this.timeout){var s,r,a;if(this.socket.isConnected()||this.socket.connect(),this.state==Dn.closed){const{config:{broadcast:i,presence:o,private:l}}=this.params,h=(r=(s=this.bindings.postgres_changes)===null||s===void 0?void 0:s.map(y=>y.filter))!==null&&r!==void 0?r:[],d=!!this.bindings[Ff.PRESENCE]&&this.bindings[Ff.PRESENCE].length>0||((a=this.params.config.presence)===null||a===void 0?void 0:a.enabled)===!0,f={},m={broadcast:i,presence:Object.assign(Object.assign({},o),{enabled:d}),postgres_changes:h,private:l};this.socket.accessTokenValue&&(f.access_token=this.socket.accessTokenValue),this._onError(y=>e?.(gi.CHANNEL_ERROR,y)),this._onClose(()=>e?.(gi.CLOSED)),this.updateJoinPayload(Object.assign({config:m},f)),this.joinedOnce=!0,this._rejoin(t),this.joinPush.receive("ok",async({postgres_changes:y})=>{var b;if(this.socket._isManualToken()||this.socket.setAuth(),y===void 0){e?.(gi.SUBSCRIBED);return}else{const x=this.bindings.postgres_changes,w=(b=x?.length)!==null&&b!==void 0?b:0,v=[];for(let C=0;C<w;C++){const N=x[C],{filter:{event:k,schema:E,table:_,filter:R}}=N,D=y&&y[C];if(D&&D.event===k&&Ic.isFilterValueEqual(D.schema,E)&&Ic.isFilterValueEqual(D.table,_)&&Ic.isFilterValueEqual(D.filter,R))v.push(Object.assign(Object.assign({},N),{id:D.id}));else{this.unsubscribe(),this.state=Dn.errored,e?.(gi.CHANNEL_ERROR,new Error("mismatch between server and client bindings for postgres changes"));return}}this.bindings.postgres_changes=v,e&&e(gi.SUBSCRIBED);return}}).receive("error",y=>{this.state=Dn.errored,e?.(gi.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(y).join(", ")||"error")))}).receive("timeout",()=>{e?.(gi.TIMED_OUT)})}return this}presenceState(){return this.presence.state}async track(e,t={}){return await this.send({type:"presence",event:"track",payload:e},t.timeout||this.timeout)}async untrack(e={}){return await this.send({type:"presence",event:"untrack"},e)}on(e,t,s){return this.state===Dn.joined&&e===Ff.PRESENCE&&(this.socket.log("channel",`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),this.unsubscribe().then(async()=>await this.subscribe())),this._on(e,t,s)}async httpSend(e,t,s={}){var r;if(t==null)return Promise.reject("Payload is required for httpSend()");const a={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(a.Authorization=`Bearer ${this.socket.accessTokenValue}`);const i={method:"POST",headers:a,body:JSON.stringify({messages:[{topic:this.subTopic,event:e,payload:t,private:this.private}]})},o=await this._fetchWithTimeout(this.broadcastEndpointURL,i,(r=s.timeout)!==null&&r!==void 0?r:this.timeout);if(o.status===202)return{success:!0};let l=o.statusText;try{const h=await o.json();l=h.error||h.message||l}catch{}return Promise.reject(new Error(l))}async send(e,t={}){var s,r;if(!this._canPush()&&e.type==="broadcast"){console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");const{event:a,payload:i}=e,o={apikey:this.socket.apiKey?this.socket.apiKey:"","Content-Type":"application/json"};this.socket.accessTokenValue&&(o.Authorization=`Bearer ${this.socket.accessTokenValue}`);const l={method:"POST",headers:o,body:JSON.stringify({messages:[{topic:this.subTopic,event:a,payload:i,private:this.private}]})};try{const h=await this._fetchWithTimeout(this.broadcastEndpointURL,l,(s=t.timeout)!==null&&s!==void 0?s:this.timeout);return await((r=h.body)===null||r===void 0?void 0:r.cancel()),h.ok?"ok":"error"}catch(h){return h.name==="AbortError"?"timed out":"error"}}else return new Promise(a=>{var i,o,l;const h=this._push(e.type,e,t.timeout||this.timeout);e.type==="broadcast"&&!(!((l=(o=(i=this.params)===null||i===void 0?void 0:i.config)===null||o===void 0?void 0:o.broadcast)===null||l===void 0)&&l.ack)&&a("ok"),h.receive("ok",()=>a("ok")),h.receive("error",()=>a("error")),h.receive("timeout",()=>a("timed out"))})}updateJoinPayload(e){this.joinPush.updatePayload(e)}unsubscribe(e=this.timeout){this.state=Dn.leaving;const t=()=>{this.socket.log("channel",`leave ${this.topic}`),this._trigger(ca.close,"leave",this._joinRef())};this.joinPush.destroy();let s=null;return new Promise(r=>{s=new bS(this,ca.leave,{},e),s.receive("ok",()=>{t(),r("ok")}).receive("timeout",()=>{t(),r("timed out")}).receive("error",()=>{r("error")}),s.send(),this._canPush()||s.trigger("ok",{})}).finally(()=>{s?.destroy()})}teardown(){this.pushBuffer.forEach(e=>e.destroy()),this.pushBuffer=[],this.rejoinTimer.reset(),this.joinPush.destroy(),this.state=Dn.closed,this.bindings={}}async _fetchWithTimeout(e,t,s){const r=new AbortController,a=setTimeout(()=>r.abort(),s),i=await this.socket.fetch(e,Object.assign(Object.assign({},t),{signal:r.signal}));return clearTimeout(a),i}_push(e,t,s=this.timeout){if(!this.joinedOnce)throw`tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;let r=new bS(this,e,t,s);return this._canPush()?r.send():this._addToPushBuffer(r),r}_addToPushBuffer(e){if(e.startTimeout(),this.pushBuffer.push(e),this.pushBuffer.length>hK){const t=this.pushBuffer.shift();t&&(t.destroy(),this.socket.log("channel",`discarded push due to buffer overflow: ${t.event}`,t.payload))}}_onMessage(e,t,s){return t}_isMember(e){return this.topic===e}_joinRef(){return this.joinPush.ref}_trigger(e,t,s){var r,a;const i=e.toLocaleLowerCase(),{close:o,error:l,leave:h,join:d}=ca;if(s&&[o,l,h,d].indexOf(i)>=0&&s!==this._joinRef())return;let m=this._onMessage(i,t,s);if(t&&!m)throw"channel onMessage callbacks must return the payload, modified or unmodified";["insert","update","delete"].includes(i)?(r=this.bindings.postgres_changes)===null||r===void 0||r.filter(y=>{var b,x,w;return((b=y.filter)===null||b===void 0?void 0:b.event)==="*"||((w=(x=y.filter)===null||x===void 0?void 0:x.event)===null||w===void 0?void 0:w.toLocaleLowerCase())===i}).map(y=>y.callback(m,s)):(a=this.bindings[i])===null||a===void 0||a.filter(y=>{var b,x,w,v,C,N;if(["broadcast","presence","postgres_changes"].includes(i))if("id"in y){const k=y.id,E=(b=y.filter)===null||b===void 0?void 0:b.event;return k&&((x=t.ids)===null||x===void 0?void 0:x.includes(k))&&(E==="*"||E?.toLocaleLowerCase()===((w=t.data)===null||w===void 0?void 0:w.type.toLocaleLowerCase()))}else{const k=(C=(v=y?.filter)===null||v===void 0?void 0:v.event)===null||C===void 0?void 0:C.toLocaleLowerCase();return k==="*"||k===((N=t?.event)===null||N===void 0?void 0:N.toLocaleLowerCase())}else return y.type.toLocaleLowerCase()===i}).map(y=>{if(typeof m=="object"&&"ids"in m){const b=m.data,{schema:x,table:w,commit_timestamp:v,type:C,errors:N}=b;m=Object.assign(Object.assign({},{schema:x,table:w,commit_timestamp:v,eventType:C,new:{},old:{},errors:N}),this._getPayloadRecords(b))}y.callback(m,s)})}_isClosed(){return this.state===Dn.closed}_isJoined(){return this.state===Dn.joined}_isJoining(){return this.state===Dn.joining}_isLeaving(){return this.state===Dn.leaving}_replyEventName(e){return`chan_reply_${e}`}_on(e,t,s){const r=e.toLocaleLowerCase(),a={type:r,filter:t,callback:s};return this.bindings[r]?this.bindings[r].push(a):this.bindings[r]=[a],this}_off(e,t){const s=e.toLocaleLowerCase();return this.bindings[s]&&(this.bindings[s]=this.bindings[s].filter(r=>{var a;return!(((a=r.type)===null||a===void 0?void 0:a.toLocaleLowerCase())===s&&Ic.isEqual(r.filter,t))})),this}static isEqual(e,t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(const s in e)if(e[s]!==t[s])return!1;return!0}static isFilterValueEqual(e,t){return(e??void 0)===(t??void 0)}_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout(),this.socket.isConnected()&&this._rejoin()}_onClose(e){this._on(ca.close,{},e)}_onError(e){this._on(ca.error,{},t=>e(t))}_canPush(){return this.socket.isConnected()&&this._isJoined()}_rejoin(e=this.timeout){this._isLeaving()||(this.socket._leaveOpenTopic(this.topic),this.state=Dn.joining,this.joinPush.resend(e))}_getPayloadRecords(e){const t={new:{},old:{}};return(e.type==="INSERT"||e.type==="UPDATE")&&(t.new=WD(e.columns,e.record)),(e.type==="UPDATE"||e.type==="DELETE")&&(t.old=WD(e.columns,e.old_record)),t}}const xS=()=>{},Iy={HEARTBEAT_INTERVAL:25e3,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100},xK=[1e3,2e3,5e3,1e4],wK=1e4,vK=`
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;class SK{constructor(e,t){var s;if(this.accessTokenValue=null,this.apiKey=null,this._manuallySetToken=!1,this.channels=new Array,this.endPoint="",this.httpEndpoint="",this.headers={},this.params={},this.timeout=pT,this.transport=null,this.heartbeatIntervalMs=Iy.HEARTBEAT_INTERVAL,this.heartbeatTimer=void 0,this.pendingHeartbeatRef=null,this.heartbeatCallback=xS,this.ref=0,this.reconnectTimer=null,this.vsn=jD,this.logger=xS,this.conn=null,this.sendBuffer=[],this.serializer=new dK,this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.accessToken=null,this._connectionState="disconnected",this._wasManualDisconnect=!1,this._authPromise=null,this._resolveFetch=r=>r?(...a)=>r(...a):(...a)=>fetch(...a),!(!((s=t?.params)===null||s===void 0)&&s.apikey))throw new Error("API key is required to connect to Realtime");this.apiKey=t.params.apikey,this.endPoint=`${e}/${mT.websocket}`,this.httpEndpoint=ML(e),this._initializeOptions(t),this._setupReconnectionTimer(),this.fetch=this._resolveFetch(t?.fetch)}connect(){if(!(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected())){if(this._setConnectionState("connecting"),this.accessToken&&!this._authPromise&&this._setAuthSafely("connect"),this.transport)this.conn=new this.transport(this.endpointURL());else try{this.conn=iK.createWebSocket(this.endpointURL())}catch(e){this._setConnectionState("disconnected");const t=e.message;throw t.includes("Node.js")?new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`):new Error(`WebSocket not available: ${t}`)}this._setupConnectionHandlers()}}endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:this.vsn}))}disconnect(e,t){if(!this.isDisconnecting())if(this._setConnectionState("disconnecting",!0),this.conn){const s=setTimeout(()=>{this._setConnectionState("disconnected")},100);this.conn.onclose=()=>{clearTimeout(s),this._setConnectionState("disconnected")},typeof this.conn.close=="function"&&(e?this.conn.close(e,t??""):this.conn.close()),this._teardownConnection()}else this._setConnectionState("disconnected")}getChannels(){return this.channels}async removeChannel(e){const t=await e.unsubscribe();return this.channels.length===0&&this.disconnect(),t}async removeAllChannels(){const e=await Promise.all(this.channels.map(t=>t.unsubscribe()));return this.channels=[],this.disconnect(),e}log(e,t,s){this.logger(e,t,s)}connectionState(){switch(this.conn&&this.conn.readyState){case mo.connecting:return kl.Connecting;case mo.open:return kl.Open;case mo.closing:return kl.Closing;default:return kl.Closed}}isConnected(){return this.connectionState()===kl.Open}isConnecting(){return this._connectionState==="connecting"}isDisconnecting(){return this._connectionState==="disconnecting"}channel(e,t={config:{}}){const s=`realtime:${e}`,r=this.getChannels().find(a=>a.topic===s);if(r)return r;{const a=new Ic(`realtime:${e}`,t,this);return this.channels.push(a),a}}push(e){const{topic:t,event:s,payload:r,ref:a}=e,i=()=>{this.encode(e,o=>{var l;(l=this.conn)===null||l===void 0||l.send(o)})};this.log("push",`${t} ${s} (${a})`,r),this.isConnected()?i():this.sendBuffer.push(i)}async setAuth(e=null){this._authPromise=this._performAuth(e);try{await this._authPromise}finally{this._authPromise=null}}_isManualToken(){return this._manuallySetToken}async sendHeartbeat(){var e;if(!this.isConnected()){try{this.heartbeatCallback("disconnected")}catch(t){this.log("error","error in heartbeat callback",t)}return}if(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null,this.log("transport","heartbeat timeout. Attempting to re-establish connection");try{this.heartbeatCallback("timeout")}catch(t){this.log("error","error in heartbeat callback",t)}this._wasManualDisconnect=!1,(e=this.conn)===null||e===void 0||e.close(cK,"heartbeat timeout"),setTimeout(()=>{var t;this.isConnected()||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout()},Iy.HEARTBEAT_TIMEOUT_FALLBACK);return}this.pendingHeartbeatRef=this._makeRef(),this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.pendingHeartbeatRef});try{this.heartbeatCallback("sent")}catch(t){this.log("error","error in heartbeat callback",t)}this._setAuthSafely("heartbeat")}onHeartbeat(e){this.heartbeatCallback=e}flushSendBuffer(){this.isConnected()&&this.sendBuffer.length>0&&(this.sendBuffer.forEach(e=>e()),this.sendBuffer=[])}_makeRef(){let e=this.ref+1;return e===this.ref?this.ref=0:this.ref=e,this.ref.toString()}_leaveOpenTopic(e){let t=this.channels.find(s=>s.topic===e&&(s._isJoined()||s._isJoining()));t&&(this.log("transport",`leaving duplicate topic "${e}"`),t.unsubscribe())}_remove(e){this.channels=this.channels.filter(t=>t.topic!==e.topic)}_onConnMessage(e){this.decode(e.data,t=>{if(t.topic==="phoenix"&&t.event==="phx_reply")try{this.heartbeatCallback(t.payload.status==="ok"?"ok":"error")}catch(h){this.log("error","error in heartbeat callback",h)}t.ref&&t.ref===this.pendingHeartbeatRef&&(this.pendingHeartbeatRef=null);const{topic:s,event:r,payload:a,ref:i}=t,o=i?`(${i})`:"",l=a.status||"";this.log("receive",`${l} ${s} ${r} ${o}`.trim(),a),this.channels.filter(h=>h._isMember(s)).forEach(h=>h._trigger(r,a,i)),this._triggerStateCallbacks("message",t)})}_clearTimer(e){var t;e==="heartbeat"&&this.heartbeatTimer?(clearInterval(this.heartbeatTimer),this.heartbeatTimer=void 0):e==="reconnect"&&((t=this.reconnectTimer)===null||t===void 0||t.reset())}_clearAllTimers(){this._clearTimer("heartbeat"),this._clearTimer("reconnect")}_setupConnectionHandlers(){this.conn&&("binaryType"in this.conn&&(this.conn.binaryType="arraybuffer"),this.conn.onopen=()=>this._onConnOpen(),this.conn.onerror=e=>this._onConnError(e),this.conn.onmessage=e=>this._onConnMessage(e),this.conn.onclose=e=>this._onConnClose(e),this.conn.readyState===mo.open&&this._onConnOpen())}_teardownConnection(){if(this.conn){if(this.conn.readyState===mo.open||this.conn.readyState===mo.connecting)try{this.conn.close()}catch(e){this.log("error","Error closing connection",e)}this.conn.onopen=null,this.conn.onerror=null,this.conn.onmessage=null,this.conn.onclose=null,this.conn=null}this._clearAllTimers(),this._terminateWorker(),this.channels.forEach(e=>e.teardown())}_onConnOpen(){this._setConnectionState("connected"),this.log("transport",`connected to ${this.endpointURL()}`),(this._authPromise||(this.accessToken&&!this.accessTokenValue?this.setAuth():Promise.resolve())).then(()=>{this.flushSendBuffer()}).catch(t=>{this.log("error","error waiting for auth on connect",t),this.flushSendBuffer()}),this._clearTimer("reconnect"),this.worker?this.workerRef||this._startWorkerHeartbeat():this._startHeartbeat(),this._triggerStateCallbacks("open")}_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs)}_startWorkerHeartbeat(){this.workerUrl?this.log("worker",`starting worker for from ${this.workerUrl}`):this.log("worker","starting default worker");const e=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(e),this.workerRef.onerror=t=>{this.log("worker","worker error",t.message),this._terminateWorker()},this.workerRef.onmessage=t=>{t.data.event==="keepAlive"&&this.sendHeartbeat()},this.workerRef.postMessage({event:"start",interval:this.heartbeatIntervalMs})}_terminateWorker(){this.workerRef&&(this.log("worker","terminating worker"),this.workerRef.terminate(),this.workerRef=void 0)}_onConnClose(e){var t;this._setConnectionState("disconnected"),this.log("transport","close",e),this._triggerChanError(),this._clearTimer("heartbeat"),this._wasManualDisconnect||(t=this.reconnectTimer)===null||t===void 0||t.scheduleTimeout(),this._triggerStateCallbacks("close",e)}_onConnError(e){this._setConnectionState("disconnected"),this.log("transport",`${e}`),this._triggerChanError(),this._triggerStateCallbacks("error",e)}_triggerChanError(){this.channels.forEach(e=>e._trigger(ca.error))}_appendParams(e,t){if(Object.keys(t).length===0)return e;const s=e.match(/\?/)?"&":"?",r=new URLSearchParams(t);return`${e}${s}${r}`}_workerObjectUrl(e){let t;if(e)t=e;else{const s=new Blob([vK],{type:"application/javascript"});t=URL.createObjectURL(s)}return t}_setConnectionState(e,t=!1){this._connectionState=e,e==="connecting"?this._wasManualDisconnect=!1:e==="disconnecting"&&(this._wasManualDisconnect=t)}async _performAuth(e=null){let t,s=!1;if(e)t=e,s=!0;else if(this.accessToken)try{t=await this.accessToken()}catch(r){this.log("error","Error fetching access token from callback",r),t=this.accessTokenValue}else t=this.accessTokenValue;s?this._manuallySetToken=!0:this.accessToken&&(this._manuallySetToken=!1),this.accessTokenValue!=t&&(this.accessTokenValue=t,this.channels.forEach(r=>{const a={access_token:t,version:lK};t&&r.updateJoinPayload(a),r.joinedOnce&&r._isJoined()&&r._push(ca.access_token,{access_token:t})}))}async _waitForAuthIfNeeded(){this._authPromise&&await this._authPromise}_setAuthSafely(e="general"){this._isManualToken()||this.setAuth().catch(t=>{this.log("error",`Error setting auth in ${e}`,t)})}_triggerStateCallbacks(e,t){try{this.stateChangeCallbacks[e].forEach(s=>{try{s(t)}catch(r){this.log("error",`error in ${e} callback`,r)}})}catch(s){this.log("error",`error triggering ${e} callbacks`,s)}}_setupReconnectionTimer(){this.reconnectTimer=new FL(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded(),this.isConnected()||this.connect()},Iy.RECONNECT_DELAY)},this.reconnectAfterMs)}_initializeOptions(e){var t,s,r,a,i,o,l,h,d,f,m,y;switch(this.transport=(t=e?.transport)!==null&&t!==void 0?t:null,this.timeout=(s=e?.timeout)!==null&&s!==void 0?s:pT,this.heartbeatIntervalMs=(r=e?.heartbeatIntervalMs)!==null&&r!==void 0?r:Iy.HEARTBEAT_INTERVAL,this.worker=(a=e?.worker)!==null&&a!==void 0?a:!1,this.accessToken=(i=e?.accessToken)!==null&&i!==void 0?i:null,this.heartbeatCallback=(o=e?.heartbeatCallback)!==null&&o!==void 0?o:xS,this.vsn=(l=e?.vsn)!==null&&l!==void 0?l:jD,e?.params&&(this.params=e.params),e?.logger&&(this.logger=e.logger),(e?.logLevel||e?.log_level)&&(this.logLevel=e.logLevel||e.log_level,this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel})),this.reconnectAfterMs=(h=e?.reconnectAfterMs)!==null&&h!==void 0?h:(b=>xK[b-1]||wK),this.vsn){case OL:this.encode=(d=e?.encode)!==null&&d!==void 0?d:((b,x)=>x(JSON.stringify(b))),this.decode=(f=e?.decode)!==null&&f!==void 0?f:((b,x)=>x(JSON.parse(b)));break;case uK:this.encode=(m=e?.encode)!==null&&m!==void 0?m:this.serializer.encode.bind(this.serializer),this.decode=(y=e?.decode)!==null&&y!==void 0?y:this.serializer.decode.bind(this.serializer);break;default:throw new Error(`Unsupported serializer version: ${this.vsn}`)}if(this.worker){if(typeof window<"u"&&!window.Worker)throw new Error("Web Worker is not supported");this.workerUrl=e?.workerUrl}}}var Wf=class extends Error{constructor(n,e){super(n),this.name="IcebergError",this.status=e.status,this.icebergType=e.icebergType,this.icebergCode=e.icebergCode,this.details=e.details,this.isCommitStateUnknown=e.icebergType==="CommitStateUnknownException"||[500,502,504].includes(e.status)&&e.icebergType?.includes("CommitState")===!0}isNotFound(){return this.status===404}isConflict(){return this.status===409}isAuthenticationTimeout(){return this.status===419}};function TK(n,e,t){const s=new URL(e,n);if(t)for(const[r,a]of Object.entries(t))a!==void 0&&s.searchParams.set(r,a);return s.toString()}async function CK(n){return!n||n.type==="none"?{}:n.type==="bearer"?{Authorization:`Bearer ${n.token}`}:n.type==="header"?{[n.name]:n.value}:n.type==="custom"?await n.getHeaders():{}}function NK(n){const e=n.fetchImpl??globalThis.fetch;return{async request({method:t,path:s,query:r,body:a,headers:i}){const o=TK(n.baseUrl,s,r),l=await CK(n.auth),h=await e(o,{method:t,headers:{...a?{"Content-Type":"application/json"}:{},...l,...i},body:a?JSON.stringify(a):void 0}),d=await h.text(),f=(h.headers.get("content-type")||"").includes("application/json"),m=f&&d?JSON.parse(d):d;if(!h.ok){const y=f?m:void 0,b=y?.error;throw new Wf(b?.message??`Request failed with status ${h.status}`,{status:h.status,icebergType:b?.type,icebergCode:b?.code,details:y})}return{status:h.status,headers:h.headers,data:m}}}}function _y(n){return n.join("")}var kK=class{constructor(n,e=""){this.client=n,this.prefix=e}async listNamespaces(n){const e=n?{parent:_y(n.namespace)}:void 0;return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces`,query:e})).data.namespaces.map(s=>({namespace:s}))}async createNamespace(n,e){const t={namespace:n.namespace,properties:e?.properties};return(await this.client.request({method:"POST",path:`${this.prefix}/namespaces`,body:t})).data}async dropNamespace(n){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${_y(n.namespace)}`})}async loadNamespaceMetadata(n){return{properties:(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${_y(n.namespace)}`})).data.properties}}async namespaceExists(n){try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${_y(n.namespace)}`}),!0}catch(e){if(e instanceof Wf&&e.status===404)return!1;throw e}}async createNamespaceIfNotExists(n,e){try{return await this.createNamespace(n,e)}catch(t){if(t instanceof Wf&&t.status===409)return;throw t}}};function cc(n){return n.join("")}var EK=class{constructor(n,e="",t){this.client=n,this.prefix=e,this.accessDelegation=t}async listTables(n){return(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${cc(n.namespace)}/tables`})).data.identifiers}async createTable(n,e){const t={};return this.accessDelegation&&(t["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${cc(n.namespace)}/tables`,body:e,headers:t})).data.metadata}async updateTable(n,e){const t=await this.client.request({method:"POST",path:`${this.prefix}/namespaces/${cc(n.namespace)}/tables/${n.name}`,body:e});return{"metadata-location":t.data["metadata-location"],metadata:t.data.metadata}}async dropTable(n,e){await this.client.request({method:"DELETE",path:`${this.prefix}/namespaces/${cc(n.namespace)}/tables/${n.name}`,query:{purgeRequested:String(e?.purge??!1)}})}async loadTable(n){const e={};return this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation),(await this.client.request({method:"GET",path:`${this.prefix}/namespaces/${cc(n.namespace)}/tables/${n.name}`,headers:e})).data.metadata}async tableExists(n){const e={};this.accessDelegation&&(e["X-Iceberg-Access-Delegation"]=this.accessDelegation);try{return await this.client.request({method:"HEAD",path:`${this.prefix}/namespaces/${cc(n.namespace)}/tables/${n.name}`,headers:e}),!0}catch(t){if(t instanceof Wf&&t.status===404)return!1;throw t}}async createTableIfNotExists(n,e){try{return await this.createTable(n,e)}catch(t){if(t instanceof Wf&&t.status===409)return await this.loadTable({namespace:n.namespace,name:e.name});throw t}}},$K=class{constructor(n){let e="v1";n.catalogName&&(e+=`/${n.catalogName}`);const t=n.baseUrl.endsWith("/")?n.baseUrl:`${n.baseUrl}/`;this.client=NK({baseUrl:t,auth:n.auth,fetchImpl:n.fetch}),this.accessDelegation=n.accessDelegation?.join(","),this.namespaceOps=new kK(this.client,e),this.tableOps=new EK(this.client,e,this.accessDelegation)}async listNamespaces(n){return this.namespaceOps.listNamespaces(n)}async createNamespace(n,e){return this.namespaceOps.createNamespace(n,e)}async dropNamespace(n){await this.namespaceOps.dropNamespace(n)}async loadNamespaceMetadata(n){return this.namespaceOps.loadNamespaceMetadata(n)}async listTables(n){return this.tableOps.listTables(n)}async createTable(n,e){return this.tableOps.createTable(n,e)}async updateTable(n,e){return this.tableOps.updateTable(n,e)}async dropTable(n,e){await this.tableOps.dropTable(n,e)}async loadTable(n){return this.tableOps.loadTable(n)}async namespaceExists(n){return this.namespaceOps.namespaceExists(n)}async tableExists(n){return this.tableOps.tableExists(n)}async createNamespaceIfNotExists(n,e){return this.namespaceOps.createNamespaceIfNotExists(n,e)}async createTableIfNotExists(n,e){return this.tableOps.createTableIfNotExists(n,e)}},hb=class extends Error{constructor(n){super(n),this.__isStorageError=!0,this.name="StorageError"}};function Qt(n){return typeof n=="object"&&n!==null&&"__isStorageError"in n}var IK=class extends hb{constructor(n,e,t){super(n),this.name="StorageApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},yT=class extends hb{constructor(n,e){super(n),this.name="StorageUnknownError",this.originalError=e}};const a2=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),_K=()=>Response,bT=n=>{if(Array.isArray(n))return n.map(t=>bT(t));if(typeof n=="function"||n!==Object(n))return n;const e={};return Object.entries(n).forEach(([t,s])=>{const r=t.replace(/([-_][a-z])/gi,a=>a.toUpperCase().replace(/[-_]/g,""));e[r]=bT(s)}),e},AK=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},RK=n=>!n||typeof n!="string"||n.length===0||n.length>100||n.trim()!==n||n.includes("/")||n.includes("\\")?!1:/^[\w!.\*'() &$@=;:+,?-]+$/.test(n);function Gf(n){"@babel/helpers - typeof";return Gf=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Gf(n)}function DK(n,e){if(Gf(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(Gf(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function OK(n){var e=DK(n,"string");return Gf(e)=="symbol"?e:e+""}function FK(n,e,t){return(e=OK(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function qD(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function He(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?qD(Object(t),!0).forEach(function(s){FK(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):qD(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const wS=n=>{var e;return n.msg||n.message||n.error_description||(typeof n.error=="string"?n.error:(e=n.error)===null||e===void 0?void 0:e.message)||JSON.stringify(n)},LK=async(n,e,t)=>{n instanceof await _K()&&!t?.noResolveJson?n.json().then(s=>{const r=n.status||500,a=s?.statusCode||r+"";e(new IK(wS(s),r,a))}).catch(s=>{e(new yT(wS(s),s))}):e(new yT(wS(n),n))},MK=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"||!s?r:(AK(s)?(r.headers=He({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,e?.duplex&&(r.duplex=e.duplex),He(He({},r),t))};async function wp(n,e,t,s,r,a){return new Promise((i,o)=>{n(t,MK(e,s,r,a)).then(l=>{if(!l.ok)throw l;return s?.noResolveJson?l:l.json()}).then(l=>i(l)).catch(l=>LK(l,o,s))})}async function Hf(n,e,t,s){return wp(n,"GET",e,t,s)}async function la(n,e,t,s,r){return wp(n,"POST",e,s,r,t)}async function xT(n,e,t,s,r){return wp(n,"PUT",e,s,r,t)}async function zK(n,e,t,s){return wp(n,"HEAD",e,He(He({},t),{},{noResolveJson:!0}),s)}async function i2(n,e,t,s,r){return wp(n,"DELETE",e,s,r,t)}var PK=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e}then(n,e){return this.execute().then(n,e)}async execute(){var n=this;try{return{data:(await n.downloadFn()).body,error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Qt(e))return{data:null,error:e};throw e}}};let zL;zL=Symbol.toStringTag;var BK=class{constructor(n,e){this.downloadFn=n,this.shouldThrowOnError=e,this[zL]="BlobDownloadBuilder",this.promise=null}asStream(){return new PK(this.downloadFn,this.shouldThrowOnError)}then(n,e){return this.getPromise().then(n,e)}catch(n){return this.getPromise().catch(n)}finally(n){return this.getPromise().finally(n)}getPromise(){return this.promise||(this.promise=this.execute()),this.promise}async execute(){var n=this;try{return{data:await(await n.downloadFn()).blob(),error:null}}catch(e){if(n.shouldThrowOnError)throw e;if(Qt(e))return{data:null,error:e};throw e}}};const VK={limit:100,offset:0,sortBy:{column:"name",order:"asc"}},KD={cacheControl:"3600",contentType:"text/plain;charset=UTF-8",upsert:!1};var UK=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1,this.url=n,this.headers=e,this.bucketId=t,this.fetch=a2(s)}throwOnError(){return this.shouldThrowOnError=!0,this}async uploadOrUpdate(n,e,t,s){var r=this;try{let a;const i=He(He({},KD),s);let o=He(He({},r.headers),n==="POST"&&{"x-upsert":String(i.upsert)});const l=i.metadata;typeof Blob<"u"&&t instanceof Blob?(a=new FormData,a.append("cacheControl",i.cacheControl),l&&a.append("metadata",r.encodeMetadata(l)),a.append("",t)):typeof FormData<"u"&&t instanceof FormData?(a=t,a.has("cacheControl")||a.append("cacheControl",i.cacheControl),l&&!a.has("metadata")&&a.append("metadata",r.encodeMetadata(l))):(a=t,o["cache-control"]=`max-age=${i.cacheControl}`,o["content-type"]=i.contentType,l&&(o["x-metadata"]=r.toBase64(r.encodeMetadata(l))),(typeof ReadableStream<"u"&&a instanceof ReadableStream||a&&typeof a=="object"&&"pipe"in a&&typeof a.pipe=="function")&&!i.duplex&&(i.duplex="half")),s?.headers&&(o=He(He({},o),s.headers));const h=r._removeEmptyFolders(e),d=r._getFinalPath(h),f=await(n=="PUT"?xT:la)(r.fetch,`${r.url}/object/${d}`,a,He({headers:o},i?.duplex?{duplex:i.duplex}:{}));return{data:{path:h,id:f.Id,fullPath:f.Key},error:null}}catch(a){if(r.shouldThrowOnError)throw a;if(Qt(a))return{data:null,error:a};throw a}}async upload(n,e,t){return this.uploadOrUpdate("POST",n,e,t)}async uploadToSignedUrl(n,e,t,s){var r=this;const a=r._removeEmptyFolders(n),i=r._getFinalPath(a),o=new URL(r.url+`/object/upload/sign/${i}`);o.searchParams.set("token",e);try{let l;const h=He({upsert:KD.upsert},s),d=He(He({},r.headers),{"x-upsert":String(h.upsert)});return typeof Blob<"u"&&t instanceof Blob?(l=new FormData,l.append("cacheControl",h.cacheControl),l.append("",t)):typeof FormData<"u"&&t instanceof FormData?(l=t,l.append("cacheControl",h.cacheControl)):(l=t,d["cache-control"]=`max-age=${h.cacheControl}`,d["content-type"]=h.contentType),{data:{path:a,fullPath:(await xT(r.fetch,o.toString(),l,{headers:d})).Key},error:null}}catch(l){if(r.shouldThrowOnError)throw l;if(Qt(l))return{data:null,error:l};throw l}}async createSignedUploadUrl(n,e){var t=this;try{let s=t._getFinalPath(n);const r=He({},t.headers);e?.upsert&&(r["x-upsert"]="true");const a=await la(t.fetch,`${t.url}/object/upload/sign/${s}`,{},{headers:r}),i=new URL(t.url+a.url),o=i.searchParams.get("token");if(!o)throw new hb("No token returned by API");return{data:{signedUrl:i.toString(),path:n,token:o},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async update(n,e,t){return this.uploadOrUpdate("PUT",n,e,t)}async move(n,e,t){var s=this;try{return{data:await la(s.fetch,`${s.url}/object/move`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers}),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async copy(n,e,t){var s=this;try{return{data:{path:(await la(s.fetch,`${s.url}/object/copy`,{bucketId:s.bucketId,sourceKey:n,destinationKey:e,destinationBucket:t?.destinationBucket},{headers:s.headers})).Key},error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async createSignedUrl(n,e,t){var s=this;try{let r=s._getFinalPath(n),a=await la(s.fetch,`${s.url}/object/sign/${r}`,He({expiresIn:e},t?.transform?{transform:t.transform}:{}),{headers:s.headers});const i=t?.download?`&download=${t.download===!0?"":t.download}`:"";return a={signedUrl:encodeURI(`${s.url}${a.signedURL}${i}`)},{data:a,error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async createSignedUrls(n,e,t){var s=this;try{const r=await la(s.fetch,`${s.url}/object/sign/${s.bucketId}`,{expiresIn:e,paths:n},{headers:s.headers}),a=t?.download?`&download=${t.download===!0?"":t.download}`:"";return{data:r.map(i=>He(He({},i),{},{signedUrl:i.signedURL?encodeURI(`${s.url}${i.signedURL}${a}`):null})),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}download(n,e){const t=typeof e?.transform<"u"?"render/image/authenticated":"object",s=this.transformOptsToQueryString(e?.transform||{}),r=s?`?${s}`:"",a=this._getFinalPath(n),i=()=>Hf(this.fetch,`${this.url}/${t}/${a}${r}`,{headers:this.headers,noResolveJson:!0});return new BK(i,this.shouldThrowOnError)}async info(n){var e=this;const t=e._getFinalPath(n);try{return{data:bT(await Hf(e.fetch,`${e.url}/object/info/${t}`,{headers:e.headers})),error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async exists(n){var e=this;const t=e._getFinalPath(n);try{return await zK(e.fetch,`${e.url}/object/${t}`,{headers:e.headers}),{data:!0,error:null}}catch(s){if(e.shouldThrowOnError)throw s;if(Qt(s)&&s instanceof yT){const r=s.originalError;if([400,404].includes(r?.status))return{data:!1,error:s}}throw s}}getPublicUrl(n,e){const t=this._getFinalPath(n),s=[],r=e?.download?`download=${e.download===!0?"":e.download}`:"";r!==""&&s.push(r);const a=typeof e?.transform<"u"?"render/image":"object",i=this.transformOptsToQueryString(e?.transform||{});i!==""&&s.push(i);let o=s.join("&");return o!==""&&(o=`?${o}`),{data:{publicUrl:encodeURI(`${this.url}/${a}/public/${t}${o}`)}}}async remove(n){var e=this;try{return{data:await i2(e.fetch,`${e.url}/object/${e.bucketId}`,{prefixes:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async list(n,e,t){var s=this;try{const r=He(He(He({},VK),e),{},{prefix:n||""});return{data:await la(s.fetch,`${s.url}/object/list/${s.bucketId}`,r,{headers:s.headers},t),error:null}}catch(r){if(s.shouldThrowOnError)throw r;if(Qt(r))return{data:null,error:r};throw r}}async listV2(n,e){var t=this;try{const s=He({},n);return{data:await la(t.fetch,`${t.url}/object/list-v2/${t.bucketId}`,s,{headers:t.headers},e),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}encodeMetadata(n){return JSON.stringify(n)}toBase64(n){return typeof Buffer<"u"?Buffer.from(n).toString("base64"):btoa(n)}_getFinalPath(n){return`${this.bucketId}/${n.replace(/^\/+/,"")}`}_removeEmptyFolders(n){return n.replace(/^\/|\/$/g,"").replace(/\/+/g,"/")}transformOptsToQueryString(n){const e=[];return n.width&&e.push(`width=${n.width}`),n.height&&e.push(`height=${n.height}`),n.resize&&e.push(`resize=${n.resize}`),n.format&&e.push(`format=${n.format}`),n.quality&&e.push(`quality=${n.quality}`),e.join("&")}};const PL="2.89.0",BL={"X-Client-Info":`storage-js/${PL}`};var jK=class{constructor(n,e={},t,s){this.shouldThrowOnError=!1;const r=new URL(n);s?.useNewHostname&&/supabase\.(co|in|red)$/.test(r.hostname)&&!r.hostname.includes("storage.supabase.")&&(r.hostname=r.hostname.replace("supabase.","storage.supabase.")),this.url=r.href.replace(/\/$/,""),this.headers=He(He({},BL),e),this.fetch=a2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async listBuckets(n){var e=this;try{const t=e.listBucketOptionsToQueryString(n);return{data:await Hf(e.fetch,`${e.url}/bucket${t}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await Hf(e.fetch,`${e.url}/bucket/${n}`,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async createBucket(n,e={public:!1}){var t=this;try{return{data:await la(t.fetch,`${t.url}/bucket`,{id:n,name:n,type:e.type,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async updateBucket(n,e){var t=this;try{return{data:await xT(t.fetch,`${t.url}/bucket/${n}`,{id:n,name:n,public:e.public,file_size_limit:e.fileSizeLimit,allowed_mime_types:e.allowedMimeTypes},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(Qt(s))return{data:null,error:s};throw s}}async emptyBucket(n){var e=this;try{return{data:await la(e.fetch,`${e.url}/bucket/${n}/empty`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await i2(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}listBucketOptionsToQueryString(n){const e={};return n&&("limit"in n&&(e.limit=String(n.limit)),"offset"in n&&(e.offset=String(n.offset)),n.search&&(e.search=n.search),n.sortColumn&&(e.sortColumn=n.sortColumn),n.sortOrder&&(e.sortOrder=n.sortOrder)),Object.keys(e).length>0?"?"+new URLSearchParams(e).toString():""}},WK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=He(He({},BL),e),this.fetch=a2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await la(e.fetch,`${e.url}/bucket`,{name:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async listBuckets(n){var e=this;try{const t=new URLSearchParams;n?.limit!==void 0&&t.set("limit",n.limit.toString()),n?.offset!==void 0&&t.set("offset",n.offset.toString()),n?.sortColumn&&t.set("sortColumn",n.sortColumn),n?.sortOrder&&t.set("sortOrder",n.sortOrder),n?.search&&t.set("search",n.search);const s=t.toString(),r=s?`${e.url}/bucket?${s}`:`${e.url}/bucket`;return{data:await Hf(e.fetch,r,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await i2(e.fetch,`${e.url}/bucket/${n}`,{},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(Qt(t))return{data:null,error:t};throw t}}from(n){var e=this;if(!RK(n))throw new hb("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");const t=new $K({baseUrl:this.url,catalogName:n,auth:{type:"custom",getHeaders:async()=>e.headers},fetch:this.fetch}),s=this.shouldThrowOnError;return new Proxy(t,{get(r,a){const i=r[a];return typeof i!="function"?i:async(...o)=>{try{return{data:await i.apply(r,o),error:null}}catch(l){if(s)throw l;return{data:null,error:l}}}}})}};const o2={"X-Client-Info":`storage-js/${PL}`,"Content-Type":"application/json"};var VL=class extends Error{constructor(n){super(n),this.__isStorageVectorsError=!0,this.name="StorageVectorsError"}};function pr(n){return typeof n=="object"&&n!==null&&"__isStorageVectorsError"in n}var vS=class extends VL{constructor(n,e,t){super(n),this.name="StorageVectorsApiError",this.status=e,this.statusCode=t}toJSON(){return{name:this.name,message:this.message,status:this.status,statusCode:this.statusCode}}},GK=class extends VL{constructor(n,e){super(n),this.name="StorageVectorsUnknownError",this.originalError=e}};const l2=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),HK=n=>{if(typeof n!="object"||n===null)return!1;const e=Object.getPrototypeOf(n);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)},XD=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),qK=async(n,e,t)=>{if(n&&typeof n=="object"&&"status"in n&&"ok"in n&&typeof n.status=="number"&&!t?.noResolveJson){const s=n.status||500,r=n;if(typeof r.json=="function")r.json().then(a=>{const i=a?.statusCode||a?.code||s+"";e(new vS(XD(a),s,i))}).catch(()=>{const a=s+"";e(new vS(r.statusText||`HTTP ${s} error`,s,a))});else{const a=s+"";e(new vS(r.statusText||`HTTP ${s} error`,s,a))}}else e(new GK(XD(n),n))},KK=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return s?(HK(s)?(r.headers=He({"Content-Type":"application/json"},e?.headers),r.body=JSON.stringify(s)):r.body=s,He(He({},r),t)):r};async function XK(n,e,t,s,r,a){return new Promise((i,o)=>{n(t,KK(e,s,r,a)).then(l=>{if(!l.ok)throw l;if(s?.noResolveJson)return l;const h=l.headers.get("content-type");return!h||!h.includes("application/json")?{}:l.json()}).then(l=>i(l)).catch(l=>qK(l,o,s))})}async function mr(n,e,t,s,r){return XK(n,"POST",e,s,r,t)}var YK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=He(He({},o2),e),this.fetch=l2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createIndex(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/CreateIndex`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getIndex(n,e){var t=this;try{return{data:await mr(t.fetch,`${t.url}/GetIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers}),error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(pr(s))return{data:null,error:s};throw s}}async listIndexes(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/ListIndexes`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteIndex(n,e){var t=this;try{return{data:await mr(t.fetch,`${t.url}/DeleteIndex`,{vectorBucketName:n,indexName:e},{headers:t.headers})||{},error:null}}catch(s){if(t.shouldThrowOnError)throw s;if(pr(s))return{data:null,error:s};throw s}}},JK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=He(He({},o2),e),this.fetch=l2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async putVectors(n){var e=this;try{if(n.vectors.length<1||n.vectors.length>500)throw new Error("Vector batch size must be between 1 and 500 items");return{data:await mr(e.fetch,`${e.url}/PutVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getVectors(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/GetVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async listVectors(n){var e=this;try{if(n.segmentCount!==void 0){if(n.segmentCount<1||n.segmentCount>16)throw new Error("segmentCount must be between 1 and 16");if(n.segmentIndex!==void 0&&(n.segmentIndex<0||n.segmentIndex>=n.segmentCount))throw new Error(`segmentIndex must be between 0 and ${n.segmentCount-1}`)}return{data:await mr(e.fetch,`${e.url}/ListVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async queryVectors(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/QueryVectors`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteVectors(n){var e=this;try{if(n.keys.length<1||n.keys.length>500)throw new Error("Keys batch size must be between 1 and 500 items");return{data:await mr(e.fetch,`${e.url}/DeleteVectors`,n,{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}},ZK=class{constructor(n,e={},t){this.shouldThrowOnError=!1,this.url=n.replace(/\/$/,""),this.headers=He(He({},o2),e),this.fetch=l2(t)}throwOnError(){return this.shouldThrowOnError=!0,this}async createBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/CreateVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async getBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/GetVectorBucket`,{vectorBucketName:n},{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async listBuckets(n={}){var e=this;try{return{data:await mr(e.fetch,`${e.url}/ListVectorBuckets`,n,{headers:e.headers}),error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}async deleteBucket(n){var e=this;try{return{data:await mr(e.fetch,`${e.url}/DeleteVectorBucket`,{vectorBucketName:n},{headers:e.headers})||{},error:null}}catch(t){if(e.shouldThrowOnError)throw t;if(pr(t))return{data:null,error:t};throw t}}},QK=class extends ZK{constructor(n,e={}){super(n,e.headers||{},e.fetch)}from(n){return new e9(this.url,this.headers,n,this.fetch)}async createBucket(n){var e=()=>super.createBucket,t=this;return e().call(t,n)}async getBucket(n){var e=()=>super.getBucket,t=this;return e().call(t,n)}async listBuckets(n={}){var e=()=>super.listBuckets,t=this;return e().call(t,n)}async deleteBucket(n){var e=()=>super.deleteBucket,t=this;return e().call(t,n)}},e9=class extends YK{constructor(n,e,t,s){super(n,e,s),this.vectorBucketName=t}async createIndex(n){var e=()=>super.createIndex,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName}))}async listIndexes(n={}){var e=()=>super.listIndexes,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName}))}async getIndex(n){var e=()=>super.getIndex,t=this;return e().call(t,t.vectorBucketName,n)}async deleteIndex(n){var e=()=>super.deleteIndex,t=this;return e().call(t,t.vectorBucketName,n)}index(n){return new t9(this.url,this.headers,this.vectorBucketName,n,this.fetch)}},t9=class extends JK{constructor(n,e,t,s,r){super(n,e,r),this.vectorBucketName=t,this.indexName=s}async putVectors(n){var e=()=>super.putVectors,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async getVectors(n){var e=()=>super.getVectors,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async listVectors(n={}){var e=()=>super.listVectors,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async queryVectors(n){var e=()=>super.queryVectors,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}async deleteVectors(n){var e=()=>super.deleteVectors,t=this;return e().call(t,He(He({},n),{},{vectorBucketName:t.vectorBucketName,indexName:t.indexName}))}},n9=class extends jK{constructor(n,e={},t,s){super(n,e,t,s)}from(n){return new UK(this.url,this.headers,n,this.fetch)}get vectors(){return new QK(this.url+"/vector",{headers:this.headers,fetch:this.fetch})}get analytics(){return new WK(this.url+"/iceberg",this.headers,this.fetch)}};const UL="2.89.0",wc=30*1e3,wT=3,SS=wT*wc,s9="http://localhost:9999",r9="supabase.auth.token",a9={"X-Client-Info":`gotrue-js/${UL}`},vT="X-Supabase-Api-Version",jL={"2024-01-01":{timestamp:Date.parse("2024-01-01T00:00:00.0Z"),name:"2024-01-01"}},i9=/^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,o9=600*1e3;class qf extends Error{constructor(e,t,s){super(e),this.__isAuthError=!0,this.name="AuthError",this.status=t,this.code=s}}function Be(n){return typeof n=="object"&&n!==null&&"__isAuthError"in n}class l9 extends qf{constructor(e,t,s){super(e,t,s),this.name="AuthApiError",this.status=t,this.code=s}}function u9(n){return Be(n)&&n.name==="AuthApiError"}class El extends qf{constructor(e,t){super(e),this.name="AuthUnknownError",this.originalError=t}}class Ri extends qf{constructor(e,t,s,r){super(e,s,r),this.name=t,this.status=s}}class dr extends Ri{constructor(){super("Auth session missing!","AuthSessionMissingError",400,void 0)}}function c9(n){return Be(n)&&n.name==="AuthSessionMissingError"}class hc extends Ri{constructor(){super("Auth session or user missing","AuthInvalidTokenResponseError",500,void 0)}}class Ay extends Ri{constructor(e){super(e,"AuthInvalidCredentialsError",400,void 0)}}class Ry extends Ri{constructor(e,t=null){super(e,"AuthImplicitGrantRedirectError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}function h9(n){return Be(n)&&n.name==="AuthImplicitGrantRedirectError"}class YD extends Ri{constructor(e,t=null){super(e,"AuthPKCEGrantCodeExchangeError",500,void 0),this.details=null,this.details=t}toJSON(){return{name:this.name,message:this.message,status:this.status,details:this.details}}}class d9 extends Ri{constructor(){super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.","AuthPKCECodeVerifierMissingError",400,"pkce_code_verifier_not_found")}}class ST extends Ri{constructor(e,t){super(e,"AuthRetryableFetchError",t,void 0)}}function TS(n){return Be(n)&&n.name==="AuthRetryableFetchError"}class JD extends Ri{constructor(e,t,s){super(e,"AuthWeakPasswordError",t,"weak_password"),this.reasons=s}}class TT extends Ri{constructor(e){super(e,"AuthInvalidJwtError",400,"invalid_jwt")}}const v0="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""),ZD=` 	
\r=`.split(""),f9=(()=>{const n=new Array(128);for(let e=0;e<n.length;e+=1)n[e]=-1;for(let e=0;e<ZD.length;e+=1)n[ZD[e].charCodeAt(0)]=-2;for(let e=0;e<v0.length;e+=1)n[v0[e].charCodeAt(0)]=e;return n})();function QD(n,e,t){if(n!==null)for(e.queue=e.queue<<8|n,e.queuedBits+=8;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(v0[s]),e.queuedBits-=6}else if(e.queuedBits>0)for(e.queue=e.queue<<6-e.queuedBits,e.queuedBits=6;e.queuedBits>=6;){const s=e.queue>>e.queuedBits-6&63;t(v0[s]),e.queuedBits-=6}}function WL(n,e,t){const s=f9[n];if(s>-1)for(e.queue=e.queue<<6|s,e.queuedBits+=6;e.queuedBits>=8;)t(e.queue>>e.queuedBits-8&255),e.queuedBits-=8;else{if(s===-2)return;throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`)}}function eO(n){const e=[],t=i=>{e.push(String.fromCodePoint(i))},s={utf8seq:0,codepoint:0},r={queue:0,queuedBits:0},a=i=>{g9(i,s,t)};for(let i=0;i<n.length;i+=1)WL(n.charCodeAt(i),r,a);return e.join("")}function p9(n,e){if(n<=127){e(n);return}else if(n<=2047){e(192|n>>6),e(128|n&63);return}else if(n<=65535){e(224|n>>12),e(128|n>>6&63),e(128|n&63);return}else if(n<=1114111){e(240|n>>18),e(128|n>>12&63),e(128|n>>6&63),e(128|n&63);return}throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`)}function m9(n,e){for(let t=0;t<n.length;t+=1){let s=n.charCodeAt(t);if(s>55295&&s<=56319){const r=(s-55296)*1024&65535;s=(n.charCodeAt(t+1)-56320&65535|r)+65536,t+=1}p9(s,e)}}function g9(n,e,t){if(e.utf8seq===0){if(n<=127){t(n);return}for(let s=1;s<6;s+=1)if((n>>7-s&1)===0){e.utf8seq=s;break}if(e.utf8seq===2)e.codepoint=n&31;else if(e.utf8seq===3)e.codepoint=n&15;else if(e.utf8seq===4)e.codepoint=n&7;else throw new Error("Invalid UTF-8 sequence");e.utf8seq-=1}else if(e.utf8seq>0){if(n<=127)throw new Error("Invalid UTF-8 sequence");e.codepoint=e.codepoint<<6|n&63,e.utf8seq-=1,e.utf8seq===0&&t(e.codepoint)}}function Ac(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};for(let r=0;r<n.length;r+=1)WL(n.charCodeAt(r),t,s);return new Uint8Array(e)}function y9(n){const e=[];return m9(n,t=>e.push(t)),new Uint8Array(e)}function Fl(n){const e=[],t={queue:0,queuedBits:0},s=r=>{e.push(r)};return n.forEach(r=>QD(r,t,s)),QD(null,t,s),e.join("")}function b9(n){return Math.round(Date.now()/1e3)+n}function x9(){return Symbol("auth-callback")}const ls=()=>typeof window<"u"&&typeof document<"u",bl={tested:!1,writable:!1},GL=()=>{if(!ls())return!1;try{if(typeof globalThis.localStorage!="object")return!1}catch{return!1}if(bl.tested)return bl.writable;const n=`lswt-${Math.random()}${Math.random()}`;try{globalThis.localStorage.setItem(n,n),globalThis.localStorage.removeItem(n),bl.tested=!0,bl.writable=!0}catch{bl.tested=!0,bl.writable=!1}return bl.writable};function w9(n){const e={},t=new URL(n);if(t.hash&&t.hash[0]==="#")try{new URLSearchParams(t.hash.substring(1)).forEach((r,a)=>{e[a]=r})}catch{}return t.searchParams.forEach((s,r)=>{e[r]=s}),e}const HL=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),v9=n=>typeof n=="object"&&n!==null&&"status"in n&&"ok"in n&&"json"in n&&typeof n.json=="function",vc=async(n,e,t)=>{await n.setItem(e,JSON.stringify(t))},xl=async(n,e)=>{const t=await n.getItem(e);if(!t)return null;try{return JSON.parse(t)}catch{return t}},os=async(n,e)=>{await n.removeItem(e)};class db{constructor(){this.promise=new db.promiseConstructor((e,t)=>{this.resolve=e,this.reject=t})}}db.promiseConstructor=Promise;function CS(n){const e=n.split(".");if(e.length!==3)throw new TT("Invalid JWT structure");for(let s=0;s<e.length;s++)if(!i9.test(e[s]))throw new TT("JWT not in base64url format");return{header:JSON.parse(eO(e[0])),payload:JSON.parse(eO(e[1])),signature:Ac(e[2]),raw:{header:e[0],payload:e[1]}}}async function S9(n){return await new Promise(e=>{setTimeout(()=>e(null),n)})}function T9(n,e){return new Promise((s,r)=>{(async()=>{for(let a=0;a<1/0;a++)try{const i=await n(a);if(!e(a,null,i)){s(i);return}}catch(i){if(!e(a,i)){r(i);return}}})()})}function C9(n){return("0"+n.toString(16)).substr(-2)}function N9(){const e=new Uint32Array(56);if(typeof crypto>"u"){const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",s=t.length;let r="";for(let a=0;a<56;a++)r+=t.charAt(Math.floor(Math.random()*s));return r}return crypto.getRandomValues(e),Array.from(e,C9).join("")}async function k9(n){const t=new TextEncoder().encode(n),s=await crypto.subtle.digest("SHA-256",t),r=new Uint8Array(s);return Array.from(r).map(a=>String.fromCharCode(a)).join("")}async function E9(n){if(!(typeof crypto<"u"&&typeof crypto.subtle<"u"&&typeof TextEncoder<"u"))return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),n;const t=await k9(n);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}async function dc(n,e,t=!1){const s=N9();let r=s;t&&(r+="/PASSWORD_RECOVERY"),await vc(n,`${e}-code-verifier`,r);const a=await E9(s);return[a,s===a?"plain":"s256"]}const $9=/^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;function I9(n){const e=n.headers.get(vT);if(!e||!e.match($9))return null;try{return new Date(`${e}T00:00:00.0Z`)}catch{return null}}function _9(n){if(!n)throw new Error("Missing exp claim");const e=Math.floor(Date.now()/1e3);if(n<=e)throw new Error("JWT has expired")}function A9(n){switch(n){case"RS256":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"ES256":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error("Invalid alg claim")}}const R9=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;function fc(n){if(!R9.test(n))throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")}function NS(){const n={};return new Proxy(n,{get:(e,t)=>{if(t==="__isUserNotAvailableProxy")return!0;if(typeof t=="symbol"){const s=t.toString();if(s==="Symbol(Symbol.toPrimitive)"||s==="Symbol(Symbol.toStringTag)"||s==="Symbol(util.inspect.custom)")return}throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`)},set:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)},deleteProperty:(e,t)=>{throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)}})}function D9(n,e){return new Proxy(n,{get:(t,s,r)=>{if(s==="__isInsecureUserWarningProxy")return!0;if(typeof s=="symbol"){const a=s.toString();if(a==="Symbol(Symbol.toPrimitive)"||a==="Symbol(Symbol.toStringTag)"||a==="Symbol(util.inspect.custom)"||a==="Symbol(nodejs.util.inspect.custom)")return Reflect.get(t,s,r)}return!e.value&&typeof s=="string"&&(console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),e.value=!0),Reflect.get(t,s,r)}})}function tO(n){return JSON.parse(JSON.stringify(n))}const Tl=n=>n.msg||n.message||n.error_description||n.error||JSON.stringify(n),O9=[502,503,504];async function nO(n){var e;if(!v9(n))throw new ST(Tl(n),0);if(O9.includes(n.status))throw new ST(Tl(n),n.status);let t;try{t=await n.json()}catch(a){throw new El(Tl(a),a)}let s;const r=I9(n);if(r&&r.getTime()>=jL["2024-01-01"].timestamp&&typeof t=="object"&&t&&typeof t.code=="string"?s=t.code:typeof t=="object"&&t&&typeof t.error_code=="string"&&(s=t.error_code),s){if(s==="weak_password")throw new JD(Tl(t),n.status,((e=t.weak_password)===null||e===void 0?void 0:e.reasons)||[]);if(s==="session_not_found")throw new dr}else if(typeof t=="object"&&t&&typeof t.weak_password=="object"&&t.weak_password&&Array.isArray(t.weak_password.reasons)&&t.weak_password.reasons.length&&t.weak_password.reasons.reduce((a,i)=>a&&typeof i=="string",!0))throw new JD(Tl(t),n.status,t.weak_password.reasons);throw new l9(Tl(t),n.status||500,s)}const F9=(n,e,t,s)=>{const r={method:n,headers:e?.headers||{}};return n==="GET"?r:(r.headers=Object.assign({"Content-Type":"application/json;charset=UTF-8"},e?.headers),r.body=JSON.stringify(s),Object.assign(Object.assign({},r),t))};async function Ge(n,e,t,s){var r;const a=Object.assign({},s?.headers);a[vT]||(a[vT]=jL["2024-01-01"].name),s?.jwt&&(a.Authorization=`Bearer ${s.jwt}`);const i=(r=s?.query)!==null&&r!==void 0?r:{};s?.redirectTo&&(i.redirect_to=s.redirectTo);const o=Object.keys(i).length?"?"+new URLSearchParams(i).toString():"",l=await L9(n,e,t+o,{headers:a,noResolveJson:s?.noResolveJson},{},s?.body);return s?.xform?s?.xform(l):{data:Object.assign({},l),error:null}}async function L9(n,e,t,s,r,a){const i=F9(e,s,r,a);let o;try{o=await n(t,Object.assign({},i))}catch(l){throw console.error(l),new ST(Tl(l),0)}if(o.ok||await nO(o),s?.noResolveJson)return o;try{return await o.json()}catch(l){await nO(l)}}function aa(n){var e;let t=null;P9(n)&&(t=Object.assign({},n),n.expires_at||(t.expires_at=b9(n.expires_in)));const s=(e=n.user)!==null&&e!==void 0?e:n;return{data:{session:t,user:s},error:null}}function sO(n){const e=aa(n);return!e.error&&n.weak_password&&typeof n.weak_password=="object"&&Array.isArray(n.weak_password.reasons)&&n.weak_password.reasons.length&&n.weak_password.message&&typeof n.weak_password.message=="string"&&n.weak_password.reasons.reduce((t,s)=>t&&typeof s=="string",!0)&&(e.data.weak_password=n.weak_password),e}function yo(n){var e;return{data:{user:(e=n.user)!==null&&e!==void 0?e:n},error:null}}function M9(n){return{data:n,error:null}}function z9(n){const{action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:a}=n,i=cb(n,["action_link","email_otp","hashed_token","redirect_to","verification_type"]),o={action_link:e,email_otp:t,hashed_token:s,redirect_to:r,verification_type:a},l=Object.assign({},i);return{data:{properties:o,user:l},error:null}}function rO(n){return n}function P9(n){return n.access_token&&n.refresh_token&&n.expires_in}const kS=["global","local","others"];class B9{constructor({url:e="",headers:t={},fetch:s}){this.url=e,this.headers=t,this.fetch=HL(s),this.mfa={listFactors:this._listFactors.bind(this),deleteFactor:this._deleteFactor.bind(this)},this.oauth={listClients:this._listOAuthClients.bind(this),createClient:this._createOAuthClient.bind(this),getClient:this._getOAuthClient.bind(this),updateClient:this._updateOAuthClient.bind(this),deleteClient:this._deleteOAuthClient.bind(this),regenerateClientSecret:this._regenerateOAuthClientSecret.bind(this)}}async signOut(e,t=kS[0]){if(kS.indexOf(t)<0)throw new Error(`@supabase/auth-js: Parameter scope must be one of ${kS.join(", ")}`);try{return await Ge(this.fetch,"POST",`${this.url}/logout?scope=${t}`,{headers:this.headers,jwt:e,noResolveJson:!0}),{data:null,error:null}}catch(s){if(Be(s))return{data:null,error:s};throw s}}async inviteUserByEmail(e,t={}){try{return await Ge(this.fetch,"POST",`${this.url}/invite`,{body:{email:e,data:t.data},headers:this.headers,redirectTo:t.redirectTo,xform:yo})}catch(s){if(Be(s))return{data:{user:null},error:s};throw s}}async generateLink(e){try{const{options:t}=e,s=cb(e,["options"]),r=Object.assign(Object.assign({},s),t);return"newEmail"in s&&(r.new_email=s?.newEmail,delete r.newEmail),await Ge(this.fetch,"POST",`${this.url}/admin/generate_link`,{body:r,headers:this.headers,xform:z9,redirectTo:t?.redirectTo})}catch(t){if(Be(t))return{data:{properties:null,user:null},error:t};throw t}}async createUser(e){try{return await Ge(this.fetch,"POST",`${this.url}/admin/users`,{body:e,headers:this.headers,xform:yo})}catch(t){if(Be(t))return{data:{user:null},error:t};throw t}}async listUsers(e){var t,s,r,a,i,o,l;try{const h={nextPage:null,lastPage:0,total:0},d=await Ge(this.fetch,"GET",`${this.url}/admin/users`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(a=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&a!==void 0?a:""},xform:rO});if(d.error)throw d.error;const f=await d.json(),m=(i=d.headers.get("x-total-count"))!==null&&i!==void 0?i:0,y=(l=(o=d.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&l!==void 0?l:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},f),h),error:null}}catch(h){if(Be(h))return{data:{users:[]},error:h};throw h}}async getUserById(e){fc(e);try{return await Ge(this.fetch,"GET",`${this.url}/admin/users/${e}`,{headers:this.headers,xform:yo})}catch(t){if(Be(t))return{data:{user:null},error:t};throw t}}async updateUserById(e,t){fc(e);try{return await Ge(this.fetch,"PUT",`${this.url}/admin/users/${e}`,{body:t,headers:this.headers,xform:yo})}catch(s){if(Be(s))return{data:{user:null},error:s};throw s}}async deleteUser(e,t=!1){fc(e);try{return await Ge(this.fetch,"DELETE",`${this.url}/admin/users/${e}`,{headers:this.headers,body:{should_soft_delete:t},xform:yo})}catch(s){if(Be(s))return{data:{user:null},error:s};throw s}}async _listFactors(e){fc(e.userId);try{const{data:t,error:s}=await Ge(this.fetch,"GET",`${this.url}/admin/users/${e.userId}/factors`,{headers:this.headers,xform:r=>({data:{factors:r},error:null})});return{data:t,error:s}}catch(t){if(Be(t))return{data:null,error:t};throw t}}async _deleteFactor(e){fc(e.userId),fc(e.id);try{return{data:await Ge(this.fetch,"DELETE",`${this.url}/admin/users/${e.userId}/factors/${e.id}`,{headers:this.headers}),error:null}}catch(t){if(Be(t))return{data:null,error:t};throw t}}async _listOAuthClients(e){var t,s,r,a,i,o,l;try{const h={nextPage:null,lastPage:0,total:0},d=await Ge(this.fetch,"GET",`${this.url}/admin/oauth/clients`,{headers:this.headers,noResolveJson:!0,query:{page:(s=(t=e?.page)===null||t===void 0?void 0:t.toString())!==null&&s!==void 0?s:"",per_page:(a=(r=e?.perPage)===null||r===void 0?void 0:r.toString())!==null&&a!==void 0?a:""},xform:rO});if(d.error)throw d.error;const f=await d.json(),m=(i=d.headers.get("x-total-count"))!==null&&i!==void 0?i:0,y=(l=(o=d.headers.get("link"))===null||o===void 0?void 0:o.split(","))!==null&&l!==void 0?l:[];return y.length>0&&(y.forEach(b=>{const x=parseInt(b.split(";")[0].split("=")[1].substring(0,1)),w=JSON.parse(b.split(";")[1].split("=")[1]);h[`${w}Page`]=x}),h.total=parseInt(m)),{data:Object.assign(Object.assign({},f),h),error:null}}catch(h){if(Be(h))return{data:{clients:[]},error:h};throw h}}async _createOAuthClient(e){try{return await Ge(this.fetch,"POST",`${this.url}/admin/oauth/clients`,{body:e,headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Be(t))return{data:null,error:t};throw t}}async _getOAuthClient(e){try{return await Ge(this.fetch,"GET",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Be(t))return{data:null,error:t};throw t}}async _updateOAuthClient(e,t){try{return await Ge(this.fetch,"PUT",`${this.url}/admin/oauth/clients/${e}`,{body:t,headers:this.headers,xform:s=>({data:s,error:null})})}catch(s){if(Be(s))return{data:null,error:s};throw s}}async _deleteOAuthClient(e){try{return await Ge(this.fetch,"DELETE",`${this.url}/admin/oauth/clients/${e}`,{headers:this.headers,noResolveJson:!0}),{data:null,error:null}}catch(t){if(Be(t))return{data:null,error:t};throw t}}async _regenerateOAuthClientSecret(e){try{return await Ge(this.fetch,"POST",`${this.url}/admin/oauth/clients/${e}/regenerate_secret`,{headers:this.headers,xform:t=>({data:t,error:null})})}catch(t){if(Be(t))return{data:null,error:t};throw t}}}function aO(n={}){return{getItem:e=>n[e]||null,setItem:(e,t)=>{n[e]=t},removeItem:e=>{delete n[e]}}}const pc={debug:!!(globalThis&&GL()&&globalThis.localStorage&&globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug")==="true")};class qL extends Error{constructor(e){super(e),this.isAcquireTimeout=!0}}class V9 extends qL{}async function U9(n,e,t){pc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquire lock",n,e);const s=new globalThis.AbortController;return e>0&&setTimeout(()=>{s.abort(),pc.debug&&console.log("@supabase/gotrue-js: navigatorLock acquire timed out",n)},e),await Promise.resolve().then(()=>globalThis.navigator.locks.request(n,e===0?{mode:"exclusive",ifAvailable:!0}:{mode:"exclusive",signal:s.signal},async r=>{if(r){pc.debug&&console.log("@supabase/gotrue-js: navigatorLock: acquired",n,r.name);try{return await t()}finally{pc.debug&&console.log("@supabase/gotrue-js: navigatorLock: released",n,r.name)}}else{if(e===0)throw pc.debug&&console.log("@supabase/gotrue-js: navigatorLock: not immediately available",n),new V9(`Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`);if(pc.debug)try{const a=await globalThis.navigator.locks.query();console.log("@supabase/gotrue-js: Navigator LockManager state",JSON.stringify(a,null,"  "))}catch(a){console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state",a)}return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),await t()}}))}function j9(){if(typeof globalThis!="object")try{Object.defineProperty(Object.prototype,"__magic__",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__}catch{typeof self<"u"&&(self.globalThis=self)}}function KL(n){if(!/^0x[a-fA-F0-9]{40}$/.test(n))throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);return n.toLowerCase()}function W9(n){return parseInt(n,16)}function G9(n){const e=new TextEncoder().encode(n);return"0x"+Array.from(e,s=>s.toString(16).padStart(2,"0")).join("")}function H9(n){var e;const{chainId:t,domain:s,expirationTime:r,issuedAt:a=new Date,nonce:i,notBefore:o,requestId:l,resources:h,scheme:d,uri:f,version:m}=n;{if(!Number.isInteger(t))throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${t}`);if(!s)throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');if(i&&i.length<8)throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${i}`);if(!f)throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');if(m!=="1")throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${m}`);if(!((e=n.statement)===null||e===void 0)&&e.includes(`
`))throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`)}const y=KL(n.address),b=d?`${d}://${s}`:s,x=n.statement?`${n.statement}
`:"",w=`${b} wants you to sign in with your Ethereum account:
${y}

${x}`;let v=`URI: ${f}
Version: ${m}
Chain ID: ${t}${i?`
Nonce: ${i}`:""}
Issued At: ${a.toISOString()}`;if(r&&(v+=`
Expiration Time: ${r.toISOString()}`),o&&(v+=`
Not Before: ${o.toISOString()}`),l&&(v+=`
Request ID: ${l}`),h){let C=`
Resources:`;for(const N of h){if(!N||typeof N!="string")throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${N}`);C+=`
- ${N}`}v+=C}return`${w}
${v}`}class Cn extends Error{constructor({message:e,code:t,cause:s,name:r}){var a;super(e,{cause:s}),this.__isWebAuthnError=!0,this.name=(a=r??(s instanceof Error?s.name:void 0))!==null&&a!==void 0?a:"Unknown Error",this.code=t}}class S0 extends Cn{constructor(e,t){super({code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:t,message:e}),this.name="WebAuthnUnknownError",this.originalError=t}}function q9({error:n,options:e}){var t,s,r;const{publicKey:a}=e;if(!a)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new Cn({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else if(n.name==="ConstraintError"){if(((t=a.authenticatorSelection)===null||t===void 0?void 0:t.requireResidentKey)===!0)return new Cn({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:n});if(e.mediation==="conditional"&&((s=a.authenticatorSelection)===null||s===void 0?void 0:s.userVerification)==="required")return new Cn({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:n});if(((r=a.authenticatorSelection)===null||r===void 0?void 0:r.userVerification)==="required")return new Cn({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:n})}else{if(n.name==="InvalidStateError")return new Cn({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:n});if(n.name==="NotAllowedError")return new Cn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="NotSupportedError")return a.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new Cn({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:n}):new Cn({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:n});if(n.name==="SecurityError"){const i=window.location.hostname;if(XL(i)){if(a.rp.id!==i)return new Cn({message:`The RP ID "${a.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new Cn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="TypeError"){if(a.user.id.byteLength<1||a.user.id.byteLength>64)return new Cn({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:n})}else if(n.name==="UnknownError")return new Cn({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new Cn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}function K9({error:n,options:e}){const{publicKey:t}=e;if(!t)throw Error("options was missing required publicKey property");if(n.name==="AbortError"){if(e.signal instanceof AbortSignal)return new Cn({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:n})}else{if(n.name==="NotAllowedError")return new Cn({message:n.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n});if(n.name==="SecurityError"){const s=window.location.hostname;if(XL(s)){if(t.rpId!==s)return new Cn({message:`The RP ID "${t.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:n})}else return new Cn({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:n})}else if(n.name==="UnknownError")return new Cn({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:n})}return new Cn({message:"a Non-Webauthn related error has occurred",code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:n})}class X9{createNewAbortSignal(){if(this.controller){const t=new Error("Cancelling existing WebAuthn API call for new one");t.name="AbortError",this.controller.abort(t)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}}const Y9=new X9;function J9(n){if(!n)throw new Error("Credential creation options are required");if(typeof PublicKeyCredential<"u"&&"parseCreationOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseCreationOptionsFromJSON=="function")return PublicKeyCredential.parseCreationOptionsFromJSON(n);const{challenge:e,user:t,excludeCredentials:s}=n,r=cb(n,["challenge","user","excludeCredentials"]),a=Ac(e).buffer,i=Object.assign(Object.assign({},t),{id:Ac(t.id).buffer}),o=Object.assign(Object.assign({},r),{challenge:a,user:i});if(s&&s.length>0){o.excludeCredentials=new Array(s.length);for(let l=0;l<s.length;l++){const h=s[l];o.excludeCredentials[l]=Object.assign(Object.assign({},h),{id:Ac(h.id).buffer,type:h.type||"public-key",transports:h.transports})}}return o}function Z9(n){if(!n)throw new Error("Credential request options are required");if(typeof PublicKeyCredential<"u"&&"parseRequestOptionsFromJSON"in PublicKeyCredential&&typeof PublicKeyCredential.parseRequestOptionsFromJSON=="function")return PublicKeyCredential.parseRequestOptionsFromJSON(n);const{challenge:e,allowCredentials:t}=n,s=cb(n,["challenge","allowCredentials"]),r=Ac(e).buffer,a=Object.assign(Object.assign({},s),{challenge:r});if(t&&t.length>0){a.allowCredentials=new Array(t.length);for(let i=0;i<t.length;i++){const o=t[i];a.allowCredentials[i]=Object.assign(Object.assign({},o),{id:Ac(o.id).buffer,type:o.type||"public-key",transports:o.transports})}}return a}function Q9(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n;return{id:n.id,rawId:n.id,response:{attestationObject:Fl(new Uint8Array(n.response.attestationObject)),clientDataJSON:Fl(new Uint8Array(n.response.clientDataJSON))},type:"public-key",clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function eX(n){var e;if("toJSON"in n&&typeof n.toJSON=="function")return n.toJSON();const t=n,s=n.getClientExtensionResults(),r=n.response;return{id:n.id,rawId:n.id,response:{authenticatorData:Fl(new Uint8Array(r.authenticatorData)),clientDataJSON:Fl(new Uint8Array(r.clientDataJSON)),signature:Fl(new Uint8Array(r.signature)),userHandle:r.userHandle?Fl(new Uint8Array(r.userHandle)):void 0},type:"public-key",clientExtensionResults:s,authenticatorAttachment:(e=t.authenticatorAttachment)!==null&&e!==void 0?e:void 0}}function XL(n){return n==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n)}function iO(){var n,e;return!!(ls()&&"PublicKeyCredential"in window&&window.PublicKeyCredential&&"credentials"in navigator&&typeof((n=navigator?.credentials)===null||n===void 0?void 0:n.create)=="function"&&typeof((e=navigator?.credentials)===null||e===void 0?void 0:e.get)=="function")}async function tX(n){try{const e=await navigator.credentials.create(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new S0("Browser returned unexpected credential type",e)}:{data:null,error:new S0("Empty credential response",e)}}catch(e){return{data:null,error:q9({error:e,options:n})}}}async function nX(n){try{const e=await navigator.credentials.get(n);return e?e instanceof PublicKeyCredential?{data:e,error:null}:{data:null,error:new S0("Browser returned unexpected credential type",e)}:{data:null,error:new S0("Empty credential response",e)}}catch(e){return{data:null,error:K9({error:e,options:n})}}}const sX={hints:["security-key"],authenticatorSelection:{authenticatorAttachment:"cross-platform",requireResidentKey:!1,userVerification:"preferred",residentKey:"discouraged"},attestation:"direct"},rX={userVerification:"preferred",hints:["security-key"],attestation:"direct"};function T0(...n){const e=r=>r!==null&&typeof r=="object"&&!Array.isArray(r),t=r=>r instanceof ArrayBuffer||ArrayBuffer.isView(r),s={};for(const r of n)if(r)for(const a in r){const i=r[a];if(i!==void 0)if(Array.isArray(i))s[a]=i;else if(t(i))s[a]=i;else if(e(i)){const o=s[a];e(o)?s[a]=T0(o,i):s[a]=T0(i)}else s[a]=i}return s}function aX(n,e){return T0(sX,n,e||{})}function iX(n,e){return T0(rX,n,e||{})}class oX{constructor(e){this.client=e,this.enroll=this._enroll.bind(this),this.challenge=this._challenge.bind(this),this.verify=this._verify.bind(this),this.authenticate=this._authenticate.bind(this),this.register=this._register.bind(this)}async _enroll(e){return this.client.mfa.enroll(Object.assign(Object.assign({},e),{factorType:"webauthn"}))}async _challenge({factorId:e,webauthn:t,friendlyName:s,signal:r},a){try{const{data:i,error:o}=await this.client.mfa.challenge({factorId:e,webauthn:t});if(!i)return{data:null,error:o};const l=r??Y9.createNewAbortSignal();if(i.webauthn.type==="create"){const{user:h}=i.webauthn.credential_options.publicKey;h.name||(h.name=`${h.id}:${s}`),h.displayName||(h.displayName=h.name)}switch(i.webauthn.type){case"create":{const h=aX(i.webauthn.credential_options.publicKey,a?.create),{data:d,error:f}=await tX({publicKey:h,signal:l});return d?{data:{factorId:e,challengeId:i.id,webauthn:{type:i.webauthn.type,credential_response:d}},error:null}:{data:null,error:f}}case"request":{const h=iX(i.webauthn.credential_options.publicKey,a?.request),{data:d,error:f}=await nX(Object.assign(Object.assign({},i.webauthn.credential_options),{publicKey:h,signal:l}));return d?{data:{factorId:e,challengeId:i.id,webauthn:{type:i.webauthn.type,credential_response:d}},error:null}:{data:null,error:f}}}}catch(i){return Be(i)?{data:null,error:i}:{data:null,error:new El("Unexpected error in challenge",i)}}}async _verify({challengeId:e,factorId:t,webauthn:s}){return this.client.mfa.verify({factorId:t,challengeId:e,webauthn:s})}async _authenticate({factorId:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},a){if(!t)return{data:null,error:new qf("rpId is required for WebAuthn authentication")};try{if(!iO())return{data:null,error:new El("Browser does not support WebAuthn",null)};const{data:i,error:o}=await this.challenge({factorId:e,webauthn:{rpId:t,rpOrigins:s},signal:r},{request:a});if(!i)return{data:null,error:o};const{webauthn:l}=i;return this._verify({factorId:e,challengeId:i.challengeId,webauthn:{type:l.type,rpId:t,rpOrigins:s,credential_response:l.credential_response}})}catch(i){return Be(i)?{data:null,error:i}:{data:null,error:new El("Unexpected error in authenticate",i)}}}async _register({friendlyName:e,webauthn:{rpId:t=typeof window<"u"?window.location.hostname:void 0,rpOrigins:s=typeof window<"u"?[window.location.origin]:void 0,signal:r}={}},a){if(!t)return{data:null,error:new qf("rpId is required for WebAuthn registration")};try{if(!iO())return{data:null,error:new El("Browser does not support WebAuthn",null)};const{data:i,error:o}=await this._enroll({friendlyName:e});if(!i)return await this.client.mfa.listFactors().then(d=>{var f;return(f=d.data)===null||f===void 0?void 0:f.all.find(m=>m.factor_type==="webauthn"&&m.friendly_name===e&&m.status!=="unverified")}).then(d=>d?this.client.mfa.unenroll({factorId:d?.id}):void 0),{data:null,error:o};const{data:l,error:h}=await this._challenge({factorId:i.id,friendlyName:i.friendly_name,webauthn:{rpId:t,rpOrigins:s},signal:r},{create:a});return l?this._verify({factorId:i.id,challengeId:l.challengeId,webauthn:{rpId:t,rpOrigins:s,type:l.webauthn.type,credential_response:l.webauthn.credential_response}}):{data:null,error:h}}catch(i){return Be(i)?{data:null,error:i}:{data:null,error:new El("Unexpected error in register",i)}}}}j9();const lX={url:s9,storageKey:r9,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,headers:a9,flowType:"implicit",debug:!1,hasCustomAuthorizationHeader:!1,throwOnError:!1};async function oO(n,e,t){return await t()}const mc={};class Kf{get jwks(){var e,t;return(t=(e=mc[this.storageKey])===null||e===void 0?void 0:e.jwks)!==null&&t!==void 0?t:{keys:[]}}set jwks(e){mc[this.storageKey]=Object.assign(Object.assign({},mc[this.storageKey]),{jwks:e})}get jwks_cached_at(){var e,t;return(t=(e=mc[this.storageKey])===null||e===void 0?void 0:e.cachedAt)!==null&&t!==void 0?t:Number.MIN_SAFE_INTEGER}set jwks_cached_at(e){mc[this.storageKey]=Object.assign(Object.assign({},mc[this.storageKey]),{cachedAt:e})}constructor(e){var t,s,r;this.userStorage=null,this.memoryStorage=null,this.stateChangeEmitters=new Map,this.autoRefreshTicker=null,this.visibilityChangedCallback=null,this.refreshingDeferred=null,this.initializePromise=null,this.detectSessionInUrl=!0,this.hasCustomAuthorizationHeader=!1,this.suppressGetSessionWarning=!1,this.lockAcquired=!1,this.pendingInLock=[],this.broadcastChannel=null,this.logger=console.log;const a=Object.assign(Object.assign({},lX),e);if(this.storageKey=a.storageKey,this.instanceID=(t=Kf.nextInstanceID[this.storageKey])!==null&&t!==void 0?t:0,Kf.nextInstanceID[this.storageKey]=this.instanceID+1,this.logDebugMessages=!!a.debug,typeof a.debug=="function"&&(this.logger=a.debug),this.instanceID>0&&ls()){const i=`${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;console.warn(i),this.logDebugMessages&&console.trace(i)}if(this.persistSession=a.persistSession,this.autoRefreshToken=a.autoRefreshToken,this.admin=new B9({url:a.url,headers:a.headers,fetch:a.fetch}),this.url=a.url,this.headers=a.headers,this.fetch=HL(a.fetch),this.lock=a.lock||oO,this.detectSessionInUrl=a.detectSessionInUrl,this.flowType=a.flowType,this.hasCustomAuthorizationHeader=a.hasCustomAuthorizationHeader,this.throwOnError=a.throwOnError,a.lock?this.lock=a.lock:this.persistSession&&ls()&&(!((s=globalThis?.navigator)===null||s===void 0)&&s.locks)?this.lock=U9:this.lock=oO,this.jwks||(this.jwks={keys:[]},this.jwks_cached_at=Number.MIN_SAFE_INTEGER),this.mfa={verify:this._verify.bind(this),enroll:this._enroll.bind(this),unenroll:this._unenroll.bind(this),challenge:this._challenge.bind(this),listFactors:this._listFactors.bind(this),challengeAndVerify:this._challengeAndVerify.bind(this),getAuthenticatorAssuranceLevel:this._getAuthenticatorAssuranceLevel.bind(this),webauthn:new oX(this)},this.oauth={getAuthorizationDetails:this._getAuthorizationDetails.bind(this),approveAuthorization:this._approveAuthorization.bind(this),denyAuthorization:this._denyAuthorization.bind(this),listGrants:this._listOAuthGrants.bind(this),revokeGrant:this._revokeOAuthGrant.bind(this)},this.persistSession?(a.storage?this.storage=a.storage:GL()?this.storage=globalThis.localStorage:(this.memoryStorage={},this.storage=aO(this.memoryStorage)),a.userStorage&&(this.userStorage=a.userStorage)):(this.memoryStorage={},this.storage=aO(this.memoryStorage)),ls()&&globalThis.BroadcastChannel&&this.persistSession&&this.storageKey){try{this.broadcastChannel=new globalThis.BroadcastChannel(this.storageKey)}catch(i){console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available",i)}(r=this.broadcastChannel)===null||r===void 0||r.addEventListener("message",async i=>{this._debug("received broadcast notification from other tab or client",i),await this._notifyAllSubscribers(i.data.event,i.data.session,!1)})}this.initialize()}isThrowOnErrorEnabled(){return this.throwOnError}_returnResult(e){if(this.throwOnError&&e&&e.error)throw e.error;return e}_logPrefix(){return`GoTrueClient@${this.storageKey}:${this.instanceID} (${UL}) ${new Date().toISOString()}`}_debug(...e){return this.logDebugMessages&&this.logger(this._logPrefix(),...e),this}async initialize(){return this.initializePromise?await this.initializePromise:(this.initializePromise=(async()=>await this._acquireLock(-1,async()=>await this._initialize()))(),await this.initializePromise)}async _initialize(){var e;try{let t={},s="none";if(ls()&&(t=w9(window.location.href),this._isImplicitGrantCallback(t)?s="implicit":await this._isPKCECallback(t)&&(s="pkce")),ls()&&this.detectSessionInUrl&&s!=="none"){const{data:r,error:a}=await this._getSessionFromURL(t,s);if(a){if(this._debug("#_initialize()","error detecting session from URL",a),h9(a)){const l=(e=a.details)===null||e===void 0?void 0:e.code;if(l==="identity_already_exists"||l==="identity_not_found"||l==="single_identity_not_deletable")return{error:a}}return await this._removeSession(),{error:a}}const{session:i,redirectType:o}=r;return this._debug("#_initialize()","detected session in URL",i,"redirect type",o),await this._saveSession(i),setTimeout(async()=>{o==="recovery"?await this._notifyAllSubscribers("PASSWORD_RECOVERY",i):await this._notifyAllSubscribers("SIGNED_IN",i)},0),{error:null}}return await this._recoverAndRefresh(),{error:null}}catch(t){return Be(t)?this._returnResult({error:t}):this._returnResult({error:new El("Unexpected error during initialization",t)})}finally{await this._handleVisibilityChange(),this._debug("#_initialize()","end")}}async signInAnonymously(e){var t,s,r;try{const a=await Ge(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{data:(s=(t=e?.options)===null||t===void 0?void 0:t.data)!==null&&s!==void 0?s:{},gotrue_meta_security:{captcha_token:(r=e?.options)===null||r===void 0?void 0:r.captchaToken}},xform:aa}),{data:i,error:o}=a;if(o||!i)return this._returnResult({data:{user:null,session:null},error:o});const l=i.session,h=i.user;return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",l)),this._returnResult({data:{user:h,session:l},error:null})}catch(a){if(Be(a))return this._returnResult({data:{user:null,session:null},error:a});throw a}}async signUp(e){var t,s,r;try{let a;if("email"in e){const{email:d,password:f,options:m}=e;let y=null,b=null;this.flowType==="pkce"&&([y,b]=await dc(this.storage,this.storageKey)),a=await Ge(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,redirectTo:m?.emailRedirectTo,body:{email:d,password:f,data:(t=m?.data)!==null&&t!==void 0?t:{},gotrue_meta_security:{captcha_token:m?.captchaToken},code_challenge:y,code_challenge_method:b},xform:aa})}else if("phone"in e){const{phone:d,password:f,options:m}=e;a=await Ge(this.fetch,"POST",`${this.url}/signup`,{headers:this.headers,body:{phone:d,password:f,data:(s=m?.data)!==null&&s!==void 0?s:{},channel:(r=m?.channel)!==null&&r!==void 0?r:"sms",gotrue_meta_security:{captcha_token:m?.captchaToken}},xform:aa})}else throw new Ay("You must provide either an email or phone number and a password");const{data:i,error:o}=a;if(o||!i)return await os(this.storage,`${this.storageKey}-code-verifier`),this._returnResult({data:{user:null,session:null},error:o});const l=i.session,h=i.user;return i.session&&(await this._saveSession(i.session),await this._notifyAllSubscribers("SIGNED_IN",l)),this._returnResult({data:{user:h,session:l},error:null})}catch(a){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(a))return this._returnResult({data:{user:null,session:null},error:a});throw a}}async signInWithPassword(e){try{let t;if("email"in e){const{email:a,password:i,options:o}=e;t=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{email:a,password:i,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:sO})}else if("phone"in e){const{phone:a,password:i,options:o}=e;t=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=password`,{headers:this.headers,body:{phone:a,password:i,gotrue_meta_security:{captcha_token:o?.captchaToken}},xform:sO})}else throw new Ay("You must provide either an email or phone number and a password");const{data:s,error:r}=t;if(r)return this._returnResult({data:{user:null,session:null},error:r});if(!s||!s.session||!s.user){const a=new hc;return this._returnResult({data:{user:null,session:null},error:a})}return s.session&&(await this._saveSession(s.session),await this._notifyAllSubscribers("SIGNED_IN",s.session)),this._returnResult({data:Object.assign({user:s.user,session:s.session},s.weak_password?{weakPassword:s.weak_password}:null),error:r})}catch(t){if(Be(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOAuth(e){var t,s,r,a;return await this._handleProviderSignIn(e.provider,{redirectTo:(t=e.options)===null||t===void 0?void 0:t.redirectTo,scopes:(s=e.options)===null||s===void 0?void 0:s.scopes,queryParams:(r=e.options)===null||r===void 0?void 0:r.queryParams,skipBrowserRedirect:(a=e.options)===null||a===void 0?void 0:a.skipBrowserRedirect})}async exchangeCodeForSession(e){return await this.initializePromise,this._acquireLock(-1,async()=>this._exchangeCodeForSession(e))}async signInWithWeb3(e){const{chain:t}=e;switch(t){case"ethereum":return await this.signInWithEthereum(e);case"solana":return await this.signInWithSolana(e);default:throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`)}}async signInWithEthereum(e){var t,s,r,a,i,o,l,h,d,f,m;let y,b;if("message"in e)y=e.message,b=e.signature;else{const{chain:x,wallet:w,statement:v,options:C}=e;let N;if(ls())if(typeof w=="object")N=w;else{const F=window;if("ethereum"in F&&typeof F.ethereum=="object"&&"request"in F.ethereum&&typeof F.ethereum.request=="function")N=F.ethereum;else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")}else{if(typeof w!="object"||!C?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");N=w}const k=new URL((t=C?.url)!==null&&t!==void 0?t:window.location.href),E=await N.request({method:"eth_requestAccounts"}).then(F=>F).catch(()=>{throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")});if(!E||E.length===0)throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");const _=KL(E[0]);let R=(s=C?.signInWithEthereum)===null||s===void 0?void 0:s.chainId;if(!R){const F=await N.request({method:"eth_chainId"});R=W9(F)}const D={domain:k.host,address:_,statement:v,uri:k.href,version:"1",chainId:R,nonce:(r=C?.signInWithEthereum)===null||r===void 0?void 0:r.nonce,issuedAt:(i=(a=C?.signInWithEthereum)===null||a===void 0?void 0:a.issuedAt)!==null&&i!==void 0?i:new Date,expirationTime:(o=C?.signInWithEthereum)===null||o===void 0?void 0:o.expirationTime,notBefore:(l=C?.signInWithEthereum)===null||l===void 0?void 0:l.notBefore,requestId:(h=C?.signInWithEthereum)===null||h===void 0?void 0:h.requestId,resources:(d=C?.signInWithEthereum)===null||d===void 0?void 0:d.resources};y=H9(D),b=await N.request({method:"personal_sign",params:[G9(y),_]})}try{const{data:x,error:w}=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"ethereum",message:y,signature:b},!((f=e.options)===null||f===void 0)&&f.captchaToken?{gotrue_meta_security:{captcha_token:(m=e.options)===null||m===void 0?void 0:m.captchaToken}}:null),xform:aa});if(w)throw w;if(!x||!x.session||!x.user){const v=new hc;return this._returnResult({data:{user:null,session:null},error:v})}return x.session&&(await this._saveSession(x.session),await this._notifyAllSubscribers("SIGNED_IN",x.session)),this._returnResult({data:Object.assign({},x),error:w})}catch(x){if(Be(x))return this._returnResult({data:{user:null,session:null},error:x});throw x}}async signInWithSolana(e){var t,s,r,a,i,o,l,h,d,f,m,y;let b,x;if("message"in e)b=e.message,x=e.signature;else{const{chain:w,wallet:v,statement:C,options:N}=e;let k;if(ls())if(typeof v=="object")k=v;else{const _=window;if("solana"in _&&typeof _.solana=="object"&&("signIn"in _.solana&&typeof _.solana.signIn=="function"||"signMessage"in _.solana&&typeof _.solana.signMessage=="function"))k=_.solana;else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")}else{if(typeof v!="object"||!N?.url)throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");k=v}const E=new URL((t=N?.url)!==null&&t!==void 0?t:window.location.href);if("signIn"in k&&k.signIn){const _=await k.signIn(Object.assign(Object.assign(Object.assign({issuedAt:new Date().toISOString()},N?.signInWithSolana),{version:"1",domain:E.host,uri:E.href}),C?{statement:C}:null));let R;if(Array.isArray(_)&&_[0]&&typeof _[0]=="object")R=_[0];else if(_&&typeof _=="object"&&"signedMessage"in _&&"signature"in _)R=_;else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");if("signedMessage"in R&&"signature"in R&&(typeof R.signedMessage=="string"||R.signedMessage instanceof Uint8Array)&&R.signature instanceof Uint8Array)b=typeof R.signedMessage=="string"?R.signedMessage:new TextDecoder().decode(R.signedMessage),x=R.signature;else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")}else{if(!("signMessage"in k)||typeof k.signMessage!="function"||!("publicKey"in k)||typeof k!="object"||!k.publicKey||!("toBase58"in k.publicKey)||typeof k.publicKey.toBase58!="function")throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");b=[`${E.host} wants you to sign in with your Solana account:`,k.publicKey.toBase58(),...C?["",C,""]:[""],"Version: 1",`URI: ${E.href}`,`Issued At: ${(r=(s=N?.signInWithSolana)===null||s===void 0?void 0:s.issuedAt)!==null&&r!==void 0?r:new Date().toISOString()}`,...!((a=N?.signInWithSolana)===null||a===void 0)&&a.notBefore?[`Not Before: ${N.signInWithSolana.notBefore}`]:[],...!((i=N?.signInWithSolana)===null||i===void 0)&&i.expirationTime?[`Expiration Time: ${N.signInWithSolana.expirationTime}`]:[],...!((o=N?.signInWithSolana)===null||o===void 0)&&o.chainId?[`Chain ID: ${N.signInWithSolana.chainId}`]:[],...!((l=N?.signInWithSolana)===null||l===void 0)&&l.nonce?[`Nonce: ${N.signInWithSolana.nonce}`]:[],...!((h=N?.signInWithSolana)===null||h===void 0)&&h.requestId?[`Request ID: ${N.signInWithSolana.requestId}`]:[],...!((f=(d=N?.signInWithSolana)===null||d===void 0?void 0:d.resources)===null||f===void 0)&&f.length?["Resources",...N.signInWithSolana.resources.map(R=>`- ${R}`)]:[]].join(`
`);const _=await k.signMessage(new TextEncoder().encode(b),"utf8");if(!_||!(_ instanceof Uint8Array))throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");x=_}}try{const{data:w,error:v}=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=web3`,{headers:this.headers,body:Object.assign({chain:"solana",message:b,signature:Fl(x)},!((m=e.options)===null||m===void 0)&&m.captchaToken?{gotrue_meta_security:{captcha_token:(y=e.options)===null||y===void 0?void 0:y.captchaToken}}:null),xform:aa});if(v)throw v;if(!w||!w.session||!w.user){const C=new hc;return this._returnResult({data:{user:null,session:null},error:C})}return w.session&&(await this._saveSession(w.session),await this._notifyAllSubscribers("SIGNED_IN",w.session)),this._returnResult({data:Object.assign({},w),error:v})}catch(w){if(Be(w))return this._returnResult({data:{user:null,session:null},error:w});throw w}}async _exchangeCodeForSession(e){const t=await xl(this.storage,`${this.storageKey}-code-verifier`),[s,r]=(t??"").split("/");try{if(!s&&this.flowType==="pkce")throw new d9;const{data:a,error:i}=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=pkce`,{headers:this.headers,body:{auth_code:e,code_verifier:s},xform:aa});if(await os(this.storage,`${this.storageKey}-code-verifier`),i)throw i;if(!a||!a.session||!a.user){const o=new hc;return this._returnResult({data:{user:null,session:null,redirectType:null},error:o})}return a.session&&(await this._saveSession(a.session),await this._notifyAllSubscribers("SIGNED_IN",a.session)),this._returnResult({data:Object.assign(Object.assign({},a),{redirectType:r??null}),error:i})}catch(a){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(a))return this._returnResult({data:{user:null,session:null,redirectType:null},error:a});throw a}}async signInWithIdToken(e){try{const{options:t,provider:s,token:r,access_token:a,nonce:i}=e,o=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,body:{provider:s,id_token:r,access_token:a,nonce:i,gotrue_meta_security:{captcha_token:t?.captchaToken}},xform:aa}),{data:l,error:h}=o;if(h)return this._returnResult({data:{user:null,session:null},error:h});if(!l||!l.session||!l.user){const d=new hc;return this._returnResult({data:{user:null,session:null},error:d})}return l.session&&(await this._saveSession(l.session),await this._notifyAllSubscribers("SIGNED_IN",l.session)),this._returnResult({data:l,error:h})}catch(t){if(Be(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async signInWithOtp(e){var t,s,r,a,i;try{if("email"in e){const{email:o,options:l}=e;let h=null,d=null;this.flowType==="pkce"&&([h,d]=await dc(this.storage,this.storageKey));const{error:f}=await Ge(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{email:o,data:(t=l?.data)!==null&&t!==void 0?t:{},create_user:(s=l?.shouldCreateUser)!==null&&s!==void 0?s:!0,gotrue_meta_security:{captcha_token:l?.captchaToken},code_challenge:h,code_challenge_method:d},redirectTo:l?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:f})}if("phone"in e){const{phone:o,options:l}=e,{data:h,error:d}=await Ge(this.fetch,"POST",`${this.url}/otp`,{headers:this.headers,body:{phone:o,data:(r=l?.data)!==null&&r!==void 0?r:{},create_user:(a=l?.shouldCreateUser)!==null&&a!==void 0?a:!0,gotrue_meta_security:{captcha_token:l?.captchaToken},channel:(i=l?.channel)!==null&&i!==void 0?i:"sms"}});return this._returnResult({data:{user:null,session:null,messageId:h?.message_id},error:d})}throw new Ay("You must provide either an email or phone number.")}catch(o){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(o))return this._returnResult({data:{user:null,session:null},error:o});throw o}}async verifyOtp(e){var t,s;try{let r,a;"options"in e&&(r=(t=e.options)===null||t===void 0?void 0:t.redirectTo,a=(s=e.options)===null||s===void 0?void 0:s.captchaToken);const{data:i,error:o}=await Ge(this.fetch,"POST",`${this.url}/verify`,{headers:this.headers,body:Object.assign(Object.assign({},e),{gotrue_meta_security:{captcha_token:a}}),redirectTo:r,xform:aa});if(o)throw o;if(!i)throw new Error("An error occurred on token verification.");const l=i.session,h=i.user;return l?.access_token&&(await this._saveSession(l),await this._notifyAllSubscribers(e.type=="recovery"?"PASSWORD_RECOVERY":"SIGNED_IN",l)),this._returnResult({data:{user:h,session:l},error:null})}catch(r){if(Be(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}}async signInWithSSO(e){var t,s,r,a,i;try{let o=null,l=null;this.flowType==="pkce"&&([o,l]=await dc(this.storage,this.storageKey));const h=await Ge(this.fetch,"POST",`${this.url}/sso`,{body:Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},"providerId"in e?{provider_id:e.providerId}:null),"domain"in e?{domain:e.domain}:null),{redirect_to:(s=(t=e.options)===null||t===void 0?void 0:t.redirectTo)!==null&&s!==void 0?s:void 0}),!((r=e?.options)===null||r===void 0)&&r.captchaToken?{gotrue_meta_security:{captcha_token:e.options.captchaToken}}:null),{skip_http_redirect:!0,code_challenge:o,code_challenge_method:l}),headers:this.headers,xform:M9});return!((a=h.data)===null||a===void 0)&&a.url&&ls()&&!(!((i=e.options)===null||i===void 0)&&i.skipBrowserRedirect)&&window.location.assign(h.data.url),this._returnResult(h)}catch(o){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(o))return this._returnResult({data:null,error:o});throw o}}async reauthenticate(){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._reauthenticate())}async _reauthenticate(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;if(s)throw s;if(!t)throw new dr;const{error:r}=await Ge(this.fetch,"GET",`${this.url}/reauthenticate`,{headers:this.headers,jwt:t.access_token});return this._returnResult({data:{user:null,session:null},error:r})})}catch(e){if(Be(e))return this._returnResult({data:{user:null,session:null},error:e});throw e}}async resend(e){try{const t=`${this.url}/resend`;if("email"in e){const{email:s,type:r,options:a}=e,{error:i}=await Ge(this.fetch,"POST",t,{headers:this.headers,body:{email:s,type:r,gotrue_meta_security:{captcha_token:a?.captchaToken}},redirectTo:a?.emailRedirectTo});return this._returnResult({data:{user:null,session:null},error:i})}else if("phone"in e){const{phone:s,type:r,options:a}=e,{data:i,error:o}=await Ge(this.fetch,"POST",t,{headers:this.headers,body:{phone:s,type:r,gotrue_meta_security:{captcha_token:a?.captchaToken}}});return this._returnResult({data:{user:null,session:null,messageId:i?.message_id},error:o})}throw new Ay("You must provide either an email or phone number and a type")}catch(t){if(Be(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async getSession(){return await this.initializePromise,await this._acquireLock(-1,async()=>this._useSession(async t=>t))}async _acquireLock(e,t){this._debug("#_acquireLock","begin",e);try{if(this.lockAcquired){const s=this.pendingInLock.length?this.pendingInLock[this.pendingInLock.length-1]:Promise.resolve(),r=(async()=>(await s,await t()))();return this.pendingInLock.push((async()=>{try{await r}catch{}})()),r}return await this.lock(`lock:${this.storageKey}`,e,async()=>{this._debug("#_acquireLock","lock acquired for storage key",this.storageKey);try{this.lockAcquired=!0;const s=t();for(this.pendingInLock.push((async()=>{try{await s}catch{}})()),await s;this.pendingInLock.length;){const r=[...this.pendingInLock];await Promise.all(r),this.pendingInLock.splice(0,r.length)}return await s}finally{this._debug("#_acquireLock","lock released for storage key",this.storageKey),this.lockAcquired=!1}})}finally{this._debug("#_acquireLock","end")}}async _useSession(e){this._debug("#_useSession","begin");try{const t=await this.__loadSession();return await e(t)}finally{this._debug("#_useSession","end")}}async __loadSession(){this._debug("#__loadSession()","begin"),this.lockAcquired||this._debug("#__loadSession()","used outside of an acquired lock!",new Error().stack);try{let e=null;const t=await xl(this.storage,this.storageKey);if(this._debug("#getSession()","session from storage",t),t!==null&&(this._isValidSession(t)?e=t:(this._debug("#getSession()","session from storage is not valid"),await this._removeSession())),!e)return{data:{session:null},error:null};const s=e.expires_at?e.expires_at*1e3-Date.now()<SS:!1;if(this._debug("#__loadSession()",`session has${s?"":" not"} expired`,"expires_at",e.expires_at),!s){if(this.userStorage){const i=await xl(this.userStorage,this.storageKey+"-user");i?.user?e.user=i.user:e.user=NS()}if(this.storage.isServer&&e.user&&!e.user.__isUserNotAvailableProxy){const i={value:this.suppressGetSessionWarning};e.user=D9(e.user,i),i.value&&(this.suppressGetSessionWarning=!0)}return{data:{session:e},error:null}}const{data:r,error:a}=await this._callRefreshToken(e.refresh_token);return a?this._returnResult({data:{session:null},error:a}):this._returnResult({data:{session:r},error:null})}finally{this._debug("#__loadSession()","end")}}async getUser(e){if(e)return await this._getUser(e);await this.initializePromise;const t=await this._acquireLock(-1,async()=>await this._getUser());return t.data.user&&(this.suppressGetSessionWarning=!0),t}async _getUser(e){try{return e?await Ge(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:e,xform:yo}):await this._useSession(async t=>{var s,r,a;const{data:i,error:o}=t;if(o)throw o;return!(!((s=i.session)===null||s===void 0)&&s.access_token)&&!this.hasCustomAuthorizationHeader?{data:{user:null},error:new dr}:await Ge(this.fetch,"GET",`${this.url}/user`,{headers:this.headers,jwt:(a=(r=i.session)===null||r===void 0?void 0:r.access_token)!==null&&a!==void 0?a:void 0,xform:yo})})}catch(t){if(Be(t))return c9(t)&&(await this._removeSession(),await os(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({data:{user:null},error:t});throw t}}async updateUser(e,t={}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._updateUser(e,t))}async _updateUser(e,t={}){try{return await this._useSession(async s=>{const{data:r,error:a}=s;if(a)throw a;if(!r.session)throw new dr;const i=r.session;let o=null,l=null;this.flowType==="pkce"&&e.email!=null&&([o,l]=await dc(this.storage,this.storageKey));const{data:h,error:d}=await Ge(this.fetch,"PUT",`${this.url}/user`,{headers:this.headers,redirectTo:t?.emailRedirectTo,body:Object.assign(Object.assign({},e),{code_challenge:o,code_challenge_method:l}),jwt:i.access_token,xform:yo});if(d)throw d;return i.user=h.user,await this._saveSession(i),await this._notifyAllSubscribers("USER_UPDATED",i),this._returnResult({data:{user:i.user},error:null})})}catch(s){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(s))return this._returnResult({data:{user:null},error:s});throw s}}async setSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._setSession(e))}async _setSession(e){try{if(!e.access_token||!e.refresh_token)throw new dr;const t=Date.now()/1e3;let s=t,r=!0,a=null;const{payload:i}=CS(e.access_token);if(i.exp&&(s=i.exp,r=s<=t),r){const{data:o,error:l}=await this._callRefreshToken(e.refresh_token);if(l)return this._returnResult({data:{user:null,session:null},error:l});if(!o)return{data:{user:null,session:null},error:null};a=o}else{const{data:o,error:l}=await this._getUser(e.access_token);if(l)throw l;a={access_token:e.access_token,refresh_token:e.refresh_token,user:o.user,token_type:"bearer",expires_in:s-t,expires_at:s},await this._saveSession(a),await this._notifyAllSubscribers("SIGNED_IN",a)}return this._returnResult({data:{user:a.user,session:a},error:null})}catch(t){if(Be(t))return this._returnResult({data:{session:null,user:null},error:t});throw t}}async refreshSession(e){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._refreshSession(e))}async _refreshSession(e){try{return await this._useSession(async t=>{var s;if(!e){const{data:i,error:o}=t;if(o)throw o;e=(s=i.session)!==null&&s!==void 0?s:void 0}if(!e?.refresh_token)throw new dr;const{data:r,error:a}=await this._callRefreshToken(e.refresh_token);return a?this._returnResult({data:{user:null,session:null},error:a}):r?this._returnResult({data:{user:r.user,session:r},error:null}):this._returnResult({data:{user:null,session:null},error:null})})}catch(t){if(Be(t))return this._returnResult({data:{user:null,session:null},error:t});throw t}}async _getSessionFromURL(e,t){try{if(!ls())throw new Ry("No browser detected.");if(e.error||e.error_description||e.error_code)throw new Ry(e.error_description||"Error in URL with unspecified error_description",{error:e.error||"unspecified_error",code:e.error_code||"unspecified_code"});switch(t){case"implicit":if(this.flowType==="pkce")throw new YD("Not a valid PKCE flow url.");break;case"pkce":if(this.flowType==="implicit")throw new Ry("Not a valid implicit grant flow url.");break;default:}if(t==="pkce"){if(this._debug("#_initialize()","begin","is PKCE flow",!0),!e.code)throw new YD("No code detected.");const{data:C,error:N}=await this._exchangeCodeForSession(e.code);if(N)throw N;const k=new URL(window.location.href);return k.searchParams.delete("code"),window.history.replaceState(window.history.state,"",k.toString()),{data:{session:C.session,redirectType:null},error:null}}const{provider_token:s,provider_refresh_token:r,access_token:a,refresh_token:i,expires_in:o,expires_at:l,token_type:h}=e;if(!a||!o||!i||!h)throw new Ry("No session defined in URL");const d=Math.round(Date.now()/1e3),f=parseInt(o);let m=d+f;l&&(m=parseInt(l));const y=m-d;y*1e3<=wc&&console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${y}s, should have been closer to ${f}s`);const b=m-f;d-b>=120?console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",b,m,d):d-b<0&&console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",b,m,d);const{data:x,error:w}=await this._getUser(a);if(w)throw w;const v={provider_token:s,provider_refresh_token:r,access_token:a,expires_in:f,expires_at:m,refresh_token:i,token_type:h,user:x.user};return window.location.hash="",this._debug("#_getSessionFromURL()","clearing window.location.hash"),this._returnResult({data:{session:v,redirectType:e.type},error:null})}catch(s){if(Be(s))return this._returnResult({data:{session:null,redirectType:null},error:s});throw s}}_isImplicitGrantCallback(e){return typeof this.detectSessionInUrl=="function"?this.detectSessionInUrl(new URL(window.location.href),e):!!(e.access_token||e.error_description)}async _isPKCECallback(e){const t=await xl(this.storage,`${this.storageKey}-code-verifier`);return!!(e.code&&t)}async signOut(e={scope:"global"}){return await this.initializePromise,await this._acquireLock(-1,async()=>await this._signOut(e))}async _signOut({scope:e}={scope:"global"}){return await this._useSession(async t=>{var s;const{data:r,error:a}=t;if(a)return this._returnResult({error:a});const i=(s=r.session)===null||s===void 0?void 0:s.access_token;if(i){const{error:o}=await this.admin.signOut(i,e);if(o&&!(u9(o)&&(o.status===404||o.status===401||o.status===403)))return this._returnResult({error:o})}return e!=="others"&&(await this._removeSession(),await os(this.storage,`${this.storageKey}-code-verifier`)),this._returnResult({error:null})})}onAuthStateChange(e){const t=x9(),s={id:t,callback:e,unsubscribe:()=>{this._debug("#unsubscribe()","state change callback with id removed",t),this.stateChangeEmitters.delete(t)}};return this._debug("#onAuthStateChange()","registered callback with id",t),this.stateChangeEmitters.set(t,s),(async()=>(await this.initializePromise,await this._acquireLock(-1,async()=>{this._emitInitialSession(t)})))(),{data:{subscription:s}}}async _emitInitialSession(e){return await this._useSession(async t=>{var s,r;try{const{data:{session:a},error:i}=t;if(i)throw i;await((s=this.stateChangeEmitters.get(e))===null||s===void 0?void 0:s.callback("INITIAL_SESSION",a)),this._debug("INITIAL_SESSION","callback id",e,"session",a)}catch(a){await((r=this.stateChangeEmitters.get(e))===null||r===void 0?void 0:r.callback("INITIAL_SESSION",null)),this._debug("INITIAL_SESSION","callback id",e,"error",a),console.error(a)}})}async resetPasswordForEmail(e,t={}){let s=null,r=null;this.flowType==="pkce"&&([s,r]=await dc(this.storage,this.storageKey,!0));try{return await Ge(this.fetch,"POST",`${this.url}/recover`,{body:{email:e,code_challenge:s,code_challenge_method:r,gotrue_meta_security:{captcha_token:t.captchaToken}},headers:this.headers,redirectTo:t.redirectTo})}catch(a){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(a))return this._returnResult({data:null,error:a});throw a}}async getUserIdentities(){var e;try{const{data:t,error:s}=await this.getUser();if(s)throw s;return this._returnResult({data:{identities:(e=t.user.identities)!==null&&e!==void 0?e:[]},error:null})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}}async linkIdentity(e){return"token"in e?this.linkIdentityIdToken(e):this.linkIdentityOAuth(e)}async linkIdentityOAuth(e){var t;try{const{data:s,error:r}=await this._useSession(async a=>{var i,o,l,h,d;const{data:f,error:m}=a;if(m)throw m;const y=await this._getUrlForProvider(`${this.url}/user/identities/authorize`,e.provider,{redirectTo:(i=e.options)===null||i===void 0?void 0:i.redirectTo,scopes:(o=e.options)===null||o===void 0?void 0:o.scopes,queryParams:(l=e.options)===null||l===void 0?void 0:l.queryParams,skipBrowserRedirect:!0});return await Ge(this.fetch,"GET",y,{headers:this.headers,jwt:(d=(h=f.session)===null||h===void 0?void 0:h.access_token)!==null&&d!==void 0?d:void 0})});if(r)throw r;return ls()&&!(!((t=e.options)===null||t===void 0)&&t.skipBrowserRedirect)&&window.location.assign(s?.url),this._returnResult({data:{provider:e.provider,url:s?.url},error:null})}catch(s){if(Be(s))return this._returnResult({data:{provider:e.provider,url:null},error:s});throw s}}async linkIdentityIdToken(e){return await this._useSession(async t=>{var s;try{const{error:r,data:{session:a}}=t;if(r)throw r;const{options:i,provider:o,token:l,access_token:h,nonce:d}=e,f=await Ge(this.fetch,"POST",`${this.url}/token?grant_type=id_token`,{headers:this.headers,jwt:(s=a?.access_token)!==null&&s!==void 0?s:void 0,body:{provider:o,id_token:l,access_token:h,nonce:d,link_identity:!0,gotrue_meta_security:{captcha_token:i?.captchaToken}},xform:aa}),{data:m,error:y}=f;return y?this._returnResult({data:{user:null,session:null},error:y}):!m||!m.session||!m.user?this._returnResult({data:{user:null,session:null},error:new hc}):(m.session&&(await this._saveSession(m.session),await this._notifyAllSubscribers("USER_UPDATED",m.session)),this._returnResult({data:m,error:y}))}catch(r){if(await os(this.storage,`${this.storageKey}-code-verifier`),Be(r))return this._returnResult({data:{user:null,session:null},error:r});throw r}})}async unlinkIdentity(e){try{return await this._useSession(async t=>{var s,r;const{data:a,error:i}=t;if(i)throw i;return await Ge(this.fetch,"DELETE",`${this.url}/user/identities/${e.identity_id}`,{headers:this.headers,jwt:(r=(s=a.session)===null||s===void 0?void 0:s.access_token)!==null&&r!==void 0?r:void 0})})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}}async _refreshAccessToken(e){const t=`#_refreshAccessToken(${e.substring(0,5)}...)`;this._debug(t,"begin");try{const s=Date.now();return await T9(async r=>(r>0&&await S9(200*Math.pow(2,r-1)),this._debug(t,"refreshing attempt",r),await Ge(this.fetch,"POST",`${this.url}/token?grant_type=refresh_token`,{body:{refresh_token:e},headers:this.headers,xform:aa})),(r,a)=>{const i=200*Math.pow(2,r);return a&&TS(a)&&Date.now()+i-s<wc})}catch(s){if(this._debug(t,"error",s),Be(s))return this._returnResult({data:{session:null,user:null},error:s});throw s}finally{this._debug(t,"end")}}_isValidSession(e){return typeof e=="object"&&e!==null&&"access_token"in e&&"refresh_token"in e&&"expires_at"in e}async _handleProviderSignIn(e,t){const s=await this._getUrlForProvider(`${this.url}/authorize`,e,{redirectTo:t.redirectTo,scopes:t.scopes,queryParams:t.queryParams});return this._debug("#_handleProviderSignIn()","provider",e,"options",t,"url",s),ls()&&!t.skipBrowserRedirect&&window.location.assign(s),{data:{provider:e,url:s},error:null}}async _recoverAndRefresh(){var e,t;const s="#_recoverAndRefresh()";this._debug(s,"begin");try{const r=await xl(this.storage,this.storageKey);if(r&&this.userStorage){let i=await xl(this.userStorage,this.storageKey+"-user");!this.storage.isServer&&Object.is(this.storage,this.userStorage)&&!i&&(i={user:r.user},await vc(this.userStorage,this.storageKey+"-user",i)),r.user=(e=i?.user)!==null&&e!==void 0?e:NS()}else if(r&&!r.user&&!r.user){const i=await xl(this.storage,this.storageKey+"-user");i&&i?.user?(r.user=i.user,await os(this.storage,this.storageKey+"-user"),await vc(this.storage,this.storageKey,r)):r.user=NS()}if(this._debug(s,"session from storage",r),!this._isValidSession(r)){this._debug(s,"session is not valid"),r!==null&&await this._removeSession();return}const a=((t=r.expires_at)!==null&&t!==void 0?t:1/0)*1e3-Date.now()<SS;if(this._debug(s,`session has${a?"":" not"} expired with margin of ${SS}s`),a){if(this.autoRefreshToken&&r.refresh_token){const{error:i}=await this._callRefreshToken(r.refresh_token);i&&(console.error(i),TS(i)||(this._debug(s,"refresh failed with a non-retryable error, removing the session",i),await this._removeSession()))}}else if(r.user&&r.user.__isUserNotAvailableProxy===!0)try{const{data:i,error:o}=await this._getUser(r.access_token);!o&&i?.user?(r.user=i.user,await this._saveSession(r),await this._notifyAllSubscribers("SIGNED_IN",r)):this._debug(s,"could not get user data, skipping SIGNED_IN notification")}catch(i){console.error("Error getting user data:",i),this._debug(s,"error getting user data, skipping SIGNED_IN notification",i)}else await this._notifyAllSubscribers("SIGNED_IN",r)}catch(r){this._debug(s,"error",r),console.error(r);return}finally{this._debug(s,"end")}}async _callRefreshToken(e){var t,s;if(!e)throw new dr;if(this.refreshingDeferred)return this.refreshingDeferred.promise;const r=`#_callRefreshToken(${e.substring(0,5)}...)`;this._debug(r,"begin");try{this.refreshingDeferred=new db;const{data:a,error:i}=await this._refreshAccessToken(e);if(i)throw i;if(!a.session)throw new dr;await this._saveSession(a.session),await this._notifyAllSubscribers("TOKEN_REFRESHED",a.session);const o={data:a.session,error:null};return this.refreshingDeferred.resolve(o),o}catch(a){if(this._debug(r,"error",a),Be(a)){const i={data:null,error:a};return TS(a)||await this._removeSession(),(t=this.refreshingDeferred)===null||t===void 0||t.resolve(i),i}throw(s=this.refreshingDeferred)===null||s===void 0||s.reject(a),a}finally{this.refreshingDeferred=null,this._debug(r,"end")}}async _notifyAllSubscribers(e,t,s=!0){const r=`#_notifyAllSubscribers(${e})`;this._debug(r,"begin",t,`broadcast = ${s}`);try{this.broadcastChannel&&s&&this.broadcastChannel.postMessage({event:e,session:t});const a=[],i=Array.from(this.stateChangeEmitters.values()).map(async o=>{try{await o.callback(e,t)}catch(l){a.push(l)}});if(await Promise.all(i),a.length>0){for(let o=0;o<a.length;o+=1)console.error(a[o]);throw a[0]}}finally{this._debug(r,"end")}}async _saveSession(e){this._debug("#_saveSession()",e),this.suppressGetSessionWarning=!0,await os(this.storage,`${this.storageKey}-code-verifier`);const t=Object.assign({},e),s=t.user&&t.user.__isUserNotAvailableProxy===!0;if(this.userStorage){!s&&t.user&&await vc(this.userStorage,this.storageKey+"-user",{user:t.user});const r=Object.assign({},t);delete r.user;const a=tO(r);await vc(this.storage,this.storageKey,a)}else{const r=tO(t);await vc(this.storage,this.storageKey,r)}}async _removeSession(){this._debug("#_removeSession()"),this.suppressGetSessionWarning=!1,await os(this.storage,this.storageKey),await os(this.storage,this.storageKey+"-code-verifier"),await os(this.storage,this.storageKey+"-user"),this.userStorage&&await os(this.userStorage,this.storageKey+"-user"),await this._notifyAllSubscribers("SIGNED_OUT",null)}_removeVisibilityChangedCallback(){this._debug("#_removeVisibilityChangedCallback()");const e=this.visibilityChangedCallback;this.visibilityChangedCallback=null;try{e&&ls()&&window?.removeEventListener&&window.removeEventListener("visibilitychange",e)}catch(t){console.error("removing visibilitychange callback failed",t)}}async _startAutoRefresh(){await this._stopAutoRefresh(),this._debug("#_startAutoRefresh()");const e=setInterval(()=>this._autoRefreshTokenTick(),wc);this.autoRefreshTicker=e,e&&typeof e=="object"&&typeof e.unref=="function"?e.unref():typeof Deno<"u"&&typeof Deno.unrefTimer=="function"&&Deno.unrefTimer(e),setTimeout(async()=>{await this.initializePromise,await this._autoRefreshTokenTick()},0)}async _stopAutoRefresh(){this._debug("#_stopAutoRefresh()");const e=this.autoRefreshTicker;this.autoRefreshTicker=null,e&&clearInterval(e)}async startAutoRefresh(){this._removeVisibilityChangedCallback(),await this._startAutoRefresh()}async stopAutoRefresh(){this._removeVisibilityChangedCallback(),await this._stopAutoRefresh()}async _autoRefreshTokenTick(){this._debug("#_autoRefreshTokenTick()","begin");try{await this._acquireLock(0,async()=>{try{const e=Date.now();try{return await this._useSession(async t=>{const{data:{session:s}}=t;if(!s||!s.refresh_token||!s.expires_at){this._debug("#_autoRefreshTokenTick()","no session");return}const r=Math.floor((s.expires_at*1e3-e)/wc);this._debug("#_autoRefreshTokenTick()",`access token expires in ${r} ticks, a tick lasts ${wc}ms, refresh threshold is ${wT} ticks`),r<=wT&&await this._callRefreshToken(s.refresh_token)})}catch(t){console.error("Auto refresh tick failed with error. This is likely a transient error.",t)}}finally{this._debug("#_autoRefreshTokenTick()","end")}})}catch(e){if(e.isAcquireTimeout||e instanceof qL)this._debug("auto refresh token tick lock not available");else throw e}}async _handleVisibilityChange(){if(this._debug("#_handleVisibilityChange()"),!ls()||!window?.addEventListener)return this.autoRefreshToken&&this.startAutoRefresh(),!1;try{this.visibilityChangedCallback=async()=>await this._onVisibilityChanged(!1),window?.addEventListener("visibilitychange",this.visibilityChangedCallback),await this._onVisibilityChanged(!0)}catch(e){console.error("_handleVisibilityChange",e)}}async _onVisibilityChanged(e){const t=`#_onVisibilityChanged(${e})`;this._debug(t,"visibilityState",document.visibilityState),document.visibilityState==="visible"?(this.autoRefreshToken&&this._startAutoRefresh(),e||(await this.initializePromise,await this._acquireLock(-1,async()=>{if(document.visibilityState!=="visible"){this._debug(t,"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");return}await this._recoverAndRefresh()}))):document.visibilityState==="hidden"&&this.autoRefreshToken&&this._stopAutoRefresh()}async _getUrlForProvider(e,t,s){const r=[`provider=${encodeURIComponent(t)}`];if(s?.redirectTo&&r.push(`redirect_to=${encodeURIComponent(s.redirectTo)}`),s?.scopes&&r.push(`scopes=${encodeURIComponent(s.scopes)}`),this.flowType==="pkce"){const[a,i]=await dc(this.storage,this.storageKey),o=new URLSearchParams({code_challenge:`${encodeURIComponent(a)}`,code_challenge_method:`${encodeURIComponent(i)}`});r.push(o.toString())}if(s?.queryParams){const a=new URLSearchParams(s.queryParams);r.push(a.toString())}return s?.skipBrowserRedirect&&r.push(`skip_http_redirect=${s.skipBrowserRedirect}`),`${e}?${r.join("&")}`}async _unenroll(e){try{return await this._useSession(async t=>{var s;const{data:r,error:a}=t;return a?this._returnResult({data:null,error:a}):await Ge(this.fetch,"DELETE",`${this.url}/factors/${e.factorId}`,{headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token})})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}}async _enroll(e){try{return await this._useSession(async t=>{var s,r;const{data:a,error:i}=t;if(i)return this._returnResult({data:null,error:i});const o=Object.assign({friendly_name:e.friendlyName,factor_type:e.factorType},e.factorType==="phone"?{phone:e.phone}:e.factorType==="totp"?{issuer:e.issuer}:{}),{data:l,error:h}=await Ge(this.fetch,"POST",`${this.url}/factors`,{body:o,headers:this.headers,jwt:(s=a?.session)===null||s===void 0?void 0:s.access_token});return h?this._returnResult({data:null,error:h}):(e.factorType==="totp"&&l.type==="totp"&&(!((r=l?.totp)===null||r===void 0)&&r.qr_code)&&(l.totp.qr_code=`data:image/svg+xml;utf-8,${l.totp.qr_code}`),this._returnResult({data:l,error:null}))})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}}async _verify(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:a}=t;if(a)return this._returnResult({data:null,error:a});const i=Object.assign({challenge_id:e.challengeId},"webauthn"in e?{webauthn:Object.assign(Object.assign({},e.webauthn),{credential_response:e.webauthn.type==="create"?Q9(e.webauthn.credential_response):eX(e.webauthn.credential_response)})}:{code:e.code}),{data:o,error:l}=await Ge(this.fetch,"POST",`${this.url}/factors/${e.factorId}/verify`,{body:i,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});return l?this._returnResult({data:null,error:l}):(await this._saveSession(Object.assign({expires_at:Math.round(Date.now()/1e3)+o.expires_in},o)),await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED",o),this._returnResult({data:o,error:l}))})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}})}async _challenge(e){return this._acquireLock(-1,async()=>{try{return await this._useSession(async t=>{var s;const{data:r,error:a}=t;if(a)return this._returnResult({data:null,error:a});const i=await Ge(this.fetch,"POST",`${this.url}/factors/${e.factorId}/challenge`,{body:e,headers:this.headers,jwt:(s=r?.session)===null||s===void 0?void 0:s.access_token});if(i.error)return i;const{data:o}=i;if(o.type!=="webauthn")return{data:o,error:null};switch(o.webauthn.type){case"create":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:J9(o.webauthn.credential_options.publicKey)})})}),error:null};case"request":return{data:Object.assign(Object.assign({},o),{webauthn:Object.assign(Object.assign({},o.webauthn),{credential_options:Object.assign(Object.assign({},o.webauthn.credential_options),{publicKey:Z9(o.webauthn.credential_options.publicKey)})})}),error:null}}})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}})}async _challengeAndVerify(e){const{data:t,error:s}=await this._challenge({factorId:e.factorId});return s?this._returnResult({data:null,error:s}):await this._verify({factorId:e.factorId,challengeId:t.id,code:e.code})}async _listFactors(){var e;const{data:{user:t},error:s}=await this.getUser();if(s)return{data:null,error:s};const r={all:[],phone:[],totp:[],webauthn:[]};for(const a of(e=t?.factors)!==null&&e!==void 0?e:[])r.all.push(a),a.status==="verified"&&r[a.factor_type].push(a);return{data:r,error:null}}async _getAuthenticatorAssuranceLevel(){var e,t;const{data:{session:s},error:r}=await this.getSession();if(r)return this._returnResult({data:null,error:r});if(!s)return{data:{currentLevel:null,nextLevel:null,currentAuthenticationMethods:[]},error:null};const{payload:a}=CS(s.access_token);let i=null;a.aal&&(i=a.aal);let o=i;((t=(e=s.user.factors)===null||e===void 0?void 0:e.filter(d=>d.status==="verified"))!==null&&t!==void 0?t:[]).length>0&&(o="aal2");const h=a.amr||[];return{data:{currentLevel:i,nextLevel:o,currentAuthenticationMethods:h},error:null}}async _getAuthorizationDetails(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?await Ge(this.fetch,"GET",`${this.url}/oauth/authorizations/${e}`,{headers:this.headers,jwt:s.access_token,xform:a=>({data:a,error:null})}):this._returnResult({data:null,error:new dr})})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}}async _approveAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:a}=s;if(a)return this._returnResult({data:null,error:a});if(!r)return this._returnResult({data:null,error:new dr});const i=await Ge(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"approve"},xform:o=>({data:o,error:null})});return i.data&&i.data.redirect_url&&ls()&&!t?.skipBrowserRedirect&&window.location.assign(i.data.redirect_url),i})}catch(s){if(Be(s))return this._returnResult({data:null,error:s});throw s}}async _denyAuthorization(e,t){try{return await this._useSession(async s=>{const{data:{session:r},error:a}=s;if(a)return this._returnResult({data:null,error:a});if(!r)return this._returnResult({data:null,error:new dr});const i=await Ge(this.fetch,"POST",`${this.url}/oauth/authorizations/${e}/consent`,{headers:this.headers,jwt:r.access_token,body:{action:"deny"},xform:o=>({data:o,error:null})});return i.data&&i.data.redirect_url&&ls()&&!t?.skipBrowserRedirect&&window.location.assign(i.data.redirect_url),i})}catch(s){if(Be(s))return this._returnResult({data:null,error:s});throw s}}async _listOAuthGrants(){try{return await this._useSession(async e=>{const{data:{session:t},error:s}=e;return s?this._returnResult({data:null,error:s}):t?await Ge(this.fetch,"GET",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:t.access_token,xform:r=>({data:r,error:null})}):this._returnResult({data:null,error:new dr})})}catch(e){if(Be(e))return this._returnResult({data:null,error:e});throw e}}async _revokeOAuthGrant(e){try{return await this._useSession(async t=>{const{data:{session:s},error:r}=t;return r?this._returnResult({data:null,error:r}):s?(await Ge(this.fetch,"DELETE",`${this.url}/user/oauth/grants`,{headers:this.headers,jwt:s.access_token,query:{client_id:e.clientId},noResolveJson:!0}),{data:{},error:null}):this._returnResult({data:null,error:new dr})})}catch(t){if(Be(t))return this._returnResult({data:null,error:t});throw t}}async fetchJwk(e,t={keys:[]}){let s=t.keys.find(o=>o.kid===e);if(s)return s;const r=Date.now();if(s=this.jwks.keys.find(o=>o.kid===e),s&&this.jwks_cached_at+o9>r)return s;const{data:a,error:i}=await Ge(this.fetch,"GET",`${this.url}/.well-known/jwks.json`,{headers:this.headers});if(i)throw i;return!a.keys||a.keys.length===0||(this.jwks=a,this.jwks_cached_at=r,s=a.keys.find(o=>o.kid===e),!s)?null:s}async getClaims(e,t={}){try{let s=e;if(!s){const{data:y,error:b}=await this.getSession();if(b||!y.session)return this._returnResult({data:null,error:b});s=y.session.access_token}const{header:r,payload:a,signature:i,raw:{header:o,payload:l}}=CS(s);t?.allowExpired||_9(a.exp);const h=!r.alg||r.alg.startsWith("HS")||!r.kid||!("crypto"in globalThis&&"subtle"in globalThis.crypto)?null:await this.fetchJwk(r.kid,t?.keys?{keys:t.keys}:t?.jwks);if(!h){const{error:y}=await this.getUser(s);if(y)throw y;return{data:{claims:a,header:r,signature:i},error:null}}const d=A9(r.alg),f=await crypto.subtle.importKey("jwk",h,d,!0,["verify"]);if(!await crypto.subtle.verify(d,f,i,y9(`${o}.${l}`)))throw new TT("Invalid JWT signature");return{data:{claims:a,header:r,signature:i},error:null}}catch(s){if(Be(s))return this._returnResult({data:null,error:s});throw s}}}Kf.nextInstanceID={};const uX=Kf,cX="2.89.0";let wf="";typeof Deno<"u"?wf="deno":typeof document<"u"?wf="web":typeof navigator<"u"&&navigator.product==="ReactNative"?wf="react-native":wf="node";const hX={"X-Client-Info":`supabase-js-${wf}/${cX}`},dX={headers:hX},fX={schema:"public"},pX={autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0,flowType:"implicit"},mX={};function Xf(n){"@babel/helpers - typeof";return Xf=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Xf(n)}function gX(n,e){if(Xf(n)!="object"||!n)return n;var t=n[Symbol.toPrimitive];if(t!==void 0){var s=t.call(n,e);if(Xf(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(n)}function yX(n){var e=gX(n,"string");return Xf(e)=="symbol"?e:e+""}function bX(n,e,t){return(e=yX(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function lO(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(r){return Object.getOwnPropertyDescriptor(n,r).enumerable})),t.push.apply(t,s)}return t}function an(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?lO(Object(t),!0).forEach(function(s){bX(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):lO(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}const xX=n=>n?(...e)=>n(...e):(...e)=>fetch(...e),wX=()=>Headers,vX=(n,e,t)=>{const s=xX(t),r=wX();return async(a,i)=>{var o;const l=(o=await e())!==null&&o!==void 0?o:n;let h=new r(i?.headers);return h.has("apikey")||h.set("apikey",n),h.has("Authorization")||h.set("Authorization",`Bearer ${l}`),s(a,an(an({},i),{},{headers:h}))}};function SX(n){return n.endsWith("/")?n:n+"/"}function TX(n,e){var t,s;const{db:r,auth:a,realtime:i,global:o}=n,{db:l,auth:h,realtime:d,global:f}=e,m={db:an(an({},l),r),auth:an(an({},h),a),realtime:an(an({},d),i),storage:{},global:an(an(an({},f),o),{},{headers:an(an({},(t=f?.headers)!==null&&t!==void 0?t:{}),(s=o?.headers)!==null&&s!==void 0?s:{})}),accessToken:async()=>""};return n.accessToken?m.accessToken=n.accessToken:delete m.accessToken,m}function CX(n){const e=n?.trim();if(!e)throw new Error("supabaseUrl is required.");if(!e.match(/^https?:\/\//i))throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");try{return new URL(SX(e))}catch{throw Error("Invalid supabaseUrl: Provided URL is malformed.")}}var NX=class extends uX{constructor(n){super(n)}},kX=class{constructor(n,e,t){var s,r;this.supabaseUrl=n,this.supabaseKey=e;const a=CX(n);if(!e)throw new Error("supabaseKey is required.");this.realtimeUrl=new URL("realtime/v1",a),this.realtimeUrl.protocol=this.realtimeUrl.protocol.replace("http","ws"),this.authUrl=new URL("auth/v1",a),this.storageUrl=new URL("storage/v1",a),this.functionsUrl=new URL("functions/v1",a);const i=`sb-${a.hostname.split(".")[0]}-auth-token`,o={db:fX,realtime:mX,auth:an(an({},pX),{},{storageKey:i}),global:dX},l=TX(t??{},o);if(this.storageKey=(s=l.auth.storageKey)!==null&&s!==void 0?s:"",this.headers=(r=l.global.headers)!==null&&r!==void 0?r:{},l.accessToken)this.accessToken=l.accessToken,this.auth=new Proxy({},{get:(d,f)=>{throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(f)} is not possible`)}});else{var h;this.auth=this._initSupabaseAuthClient((h=l.auth)!==null&&h!==void 0?h:{},this.headers,l.global.fetch)}this.fetch=vX(e,this._getAccessToken.bind(this),l.global.fetch),this.realtime=this._initRealtimeClient(an({headers:this.headers,accessToken:this._getAccessToken.bind(this)},l.realtime)),this.accessToken&&this.accessToken().then(d=>this.realtime.setAuth(d)).catch(d=>console.warn("Failed to set initial Realtime auth token:",d)),this.rest=new aK(new URL("rest/v1",a).href,{headers:this.headers,schema:l.db.schema,fetch:this.fetch}),this.storage=new n9(this.storageUrl.href,this.headers,this.fetch,t?.storage),l.accessToken||this._listenForAuthEvents()}get functions(){return new eK(this.functionsUrl.href,{headers:this.headers,customFetch:this.fetch})}from(n){return this.rest.from(n)}schema(n){return this.rest.schema(n)}rpc(n,e={},t={head:!1,get:!1,count:void 0}){return this.rest.rpc(n,e,t)}channel(n,e={config:{}}){return this.realtime.channel(n,e)}getChannels(){return this.realtime.getChannels()}removeChannel(n){return this.realtime.removeChannel(n)}removeAllChannels(){return this.realtime.removeAllChannels()}async _getAccessToken(){var n=this,e,t;if(n.accessToken)return await n.accessToken();const{data:s}=await n.auth.getSession();return(e=(t=s.session)===null||t===void 0?void 0:t.access_token)!==null&&e!==void 0?e:n.supabaseKey}_initSupabaseAuthClient({autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,storageKey:a,flowType:i,lock:o,debug:l,throwOnError:h},d,f){const m={Authorization:`Bearer ${this.supabaseKey}`,apikey:`${this.supabaseKey}`};return new NX({url:this.authUrl.href,headers:an(an({},m),d),storageKey:a,autoRefreshToken:n,persistSession:e,detectSessionInUrl:t,storage:s,userStorage:r,flowType:i,lock:o,debug:l,throwOnError:h,fetch:f,hasCustomAuthorizationHeader:Object.keys(this.headers).some(y=>y.toLowerCase()==="authorization")})}_initRealtimeClient(n){return new SK(this.realtimeUrl.href,an(an({},n),{},{params:an(an({},{apikey:this.supabaseKey}),n?.params)}))}_listenForAuthEvents(){return this.auth.onAuthStateChange((n,e)=>{this._handleTokenChanged(n,"CLIENT",e?.access_token)})}_handleTokenChanged(n,e,t){(n==="TOKEN_REFRESHED"||n==="SIGNED_IN")&&this.changedAccessToken!==t?(this.changedAccessToken=t,this.realtime.setAuth(t)):n==="SIGNED_OUT"&&(this.realtime.setAuth(),e=="STORAGE"&&this.auth.signOut(),this.changedAccessToken=void 0)}};const YL=(n,e,t)=>new kX(n,e,t);function EX(){if(typeof window<"u"||typeof process>"u")return!1;const n=process.version;if(n==null)return!1;const e=n.match(/^v(\d+)\./);return e?parseInt(e[1],10)<=18:!1}EX()&&console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");const JL={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_SUPABASE_ANON_KEY:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",VITE_SUPABASE_URL:"https://brrjoheinakfhohesogc.supabase.co"},Bl=eM;(function(n,e){const t=eM,s=n();for(;;)try{if(parseInt(t(268))/1+-parseInt(t(253))/2*(-parseInt(t(262))/3)+parseInt(t(257))/4*(parseInt(t(254))/5)+-parseInt(t(264))/6*(parseInt(t(246))/7)+parseInt(t(249))/8*(-parseInt(t(270))/9)+parseInt(t(259))/10+parseInt(t(265))/11===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(C0,254073);const ZL=JL[Bl(244)],QL=JL[Bl(252)];(!ZL||!QL)&&console[Bl(260)](Bl(258));const $X={getItem:n=>{const e=Bl;return typeof chrome!==e(261)&&chrome[e(247)]&&chrome[e(247)][e(266)]?new Promise(t=>{const s=e;chrome[s(247)][s(266)][s(250)]([n],r=>t(r[n]||null))}):localStorage[e(269)](n)},setItem:(n,e)=>{const t=Bl;typeof chrome<"u"&&chrome.storage&&chrome[t(247)].local?chrome.storage[t(266)][t(263)]({[n]:e}):localStorage[t(245)](n,e)},removeItem:n=>{const e=Bl;typeof chrome!==e(261)&&chrome.storage&&chrome[e(247)][e(266)]?chrome[e(247)].local.remove([n]):localStorage.removeItem(n)}};function C0(){const n=["7149SQMnFS","set","156504hPaRWg","1148730IpIGGn","local","single","65979XfbENo","getItem","333gnkJKG","VITE_SUPABASE_URL","setItem","7EwQEer","storage","profiles","109552CTrSyZ","get","select","VITE_SUPABASE_ANON_KEY","302kveYHl","123545gWekIb","from","subscription_tier, stripe_customer_id, stripe_subscription_id, billing_info","4anafHU","Missing Supabase Environment Variables!","2318840eFHUcm","error","undefined"];return C0=function(){return n},C0()}const Vr=YL(ZL,QL,{auth:{storage:$X,autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0}});function eM(n,e){return n=n-244,C0()[n]}const tM=Ce.createContext(),IX=({children:n})=>{const[e,t]=Ce.useState(null),[s,r]=Ce.useState(null),[a,i]=Ce.useState({alpha:.35,beta:.3,gamma:.2,delta:.1,omega:.5,iterations:0}),[o,l]=Ce.useState(!0);Ce.useEffect(()=>{f(),Vr.auth.getSession().then(({data:{session:y}})=>{t(y?.user||null),y?.user?h(y.user.id,y.user.email):l(!1)});const{data:{subscription:m}}=Vr.auth.onAuthStateChange((y,b)=>{t(b?.user||null),b?.user?h(b.user.id,b.user.email):(r(null),l(!1))});return()=>m.unsubscribe()},[]);const h=async(m,y)=>{try{let{data:b,error:x}=await Vr.from("profiles").select("*").eq("id",m).single();if(x&&x.code==="PGRST116"){const{data:w,error:v}=await Vr.from("profiles").insert([{id:m,email:y,subscription_tier:"free",upload_count:0,last_upload_date:new Date().toISOString().split("T")[0]}]).select().single();v||(b=w)}r(b)}catch(b){console.error("Profile fetch error:",b)}finally{l(!1)}},d=()=>{e&&h(e.id,e.email)},f=async()=>{try{const{data:m,error:y}=await Vr.from("neural_state").select("*").eq("id","global_master").single();m&&!y&&i(m)}catch(m){console.error("Neural state sync error:",m)}};return me.jsx(tM.Provider,{value:{user:e,profile:s,neuralState:a,loading:o,refreshProfile:d,fetchNeuralState:f,setUser:t,setProfile:r,setNeuralState:i},children:n})},_X=()=>Ce.useContext(tM);(function(n,e){const t=va,s=n();for(;;)try{if(parseInt(t(343))/1*(-parseInt(t(318))/2)+-parseInt(t(305))/3+parseInt(t(350))/4+parseInt(t(322))/5+parseInt(t(342))/6+parseInt(t(339))/7*(parseInt(t(348))/8)+-parseInt(t(309))/9===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(N0,367464);const CT=(n,e)=>{const t=va;if(!n||n[t(346)]<e)return[];const s=[];for(let r=e-1;r<n[t(346)];r++){const a=n[t(323)](r-e+1,r+1)[t(329)]((i,o)=>i+o,0);s.push(a/e)}return s},Lf=(n,e)=>{if(n[va(346)]<e)return[];const s=2/(e+1);let r=[n[0]];for(let a=1;a<n.length;a++)r.push(n[a]*s+r[a-1]*(1-s));return r},AX=(n,e=14)=>{const t=va;if(n.length<e+1)return[];let s=0,r=0;for(let h=1;h<=e;h++){const d=n[h]-n[h-1];d>=0?s+=d:r+=Math.abs(d)}let a=s/e,i=r/e;const o=[];let l=i===0?100:a/i;o.push(100-100/(1+l));for(let h=e+1;h<n[t(346)];h++){const d=n[h]-n[h-1];d>=0?(a=(a*(e-1)+d)/e,i=(i*(e-1)+0)/e):(a=(a*(e-1)+0)/e,i=(i*(e-1)+Math[t(315)](d))/e),l=i===0?100:a/i,o[t(312)](100-100/(1+l))}return o},RX=(n,e=20,t=2)=>{const s=va;if(n[s(346)]<e)return[];const r=[],a=[],i=CT(n,e);for(let o=0;o<i[s(346)];o++){const l=n[s(323)](o,o+e),h=i[o],d=l[s(316)](y=>Math[s(353)](y-h,2)),f=d.reduce((y,b)=>y+b,0)/e,m=Math[s(347)](f);a[s(312)](h+t*m),r[s(312)](h-t*m)}return{basis:i,upper:a,lower:r}};function va(n,e){return n=n-304,N0()[n]}const DX=(n,e=12,t=26,s=9)=>{const r=va,a=Lf(n,e),i=Lf(n,t),o=[],l=Math[r(352)](a[r(346)],i[r(346)]);for(let f=0;f<l;f++)o[r(312)](a[f]-i[f]);const h=Lf(o,s),d=[];for(let f=0;f<Math[r(352)](o[r(346)],h[r(346)]);f++)d.push(o[f]-h[f]);return{macdLine:o,signalLine:h,histogram:d}},OX=(n,e=[],t=[],s=[])=>{const r=va;if(n[r(346)]<50)return[{name:r(306),sentiment:"Neutral",confidence:0}];const a=n[n[r(346)]-1],i=n[n.length-2],o=s.length>0?s[s.length-1]:i,l=e[r(346)]>0?e[e[r(346)]-1]:Math[r(308)](a,o),h=t.length>0?t[t[r(346)]-1]:Math.min(a,o),d=Math[r(315)](a-o),f=l-h||1e-4,m=(a+o)/2,y=a>o,b=a<o;let x=[];d/f<.1&&(m>l-f*.2?x[r(312)]({name:r(328),sentiment:r(313),icon:"zap"}):m<h+f*.2?x[r(312)]({name:r(321),sentiment:"Bearish",icon:"trending-down"}):x[r(312)]({name:r(341),sentiment:r(311),icon:r(317)}));const w=Math[r(352)](o,a)-h,v=l-Math[r(308)](o,a);if(w>d*2&&v<d*.5&&x[r(312)]({name:"Hammer",sentiment:r(313),icon:r(326)}),v>d*2&&w<d*.5&&x[r(312)]({name:r(y?314:325),sentiment:y?"Bullish":r(330),icon:y?"zap":r(333)}),s[r(346)]>1){const V=s[s[r(346)]-2],q=n[n.length-2],ne=q<V,Q=q>V;y&&ne&&a>V&&o<q?x[r(312)]({name:r(351),sentiment:r(313),icon:r(334)}):b&&Q&&a<V&&o>q&&x[r(312)]({name:r(349),sentiment:"Bearish",icon:"trending-down"})}if(s.length>1){const V=s[s[r(346)]-2],q=n[n[r(346)]-2],ne=e[e[r(346)]-2]||Math[r(308)](V,q),Q=t[t[r(346)]-2]||Math[r(352)](V,q);l<ne&&h>Q&&x[r(312)]({name:r(327),sentiment:r(y?313:330),icon:"activity"})}d/f>.9&&x[r(312)]({name:r(y?335:336),sentiment:r(y?313:330),icon:r(334)});const C=CT(n.slice(-20),10),N=CT(n[r(323)](-50),40),k=C[C[r(346)]-1],E=N[N[r(346)]-1],_=k>E,{upper:R,lower:D}=RX(n,20),F=R[R[r(346)]-1],L=D[D[r(346)]-1];return(F-L)/a<.05&&x.push({name:r(338),sentiment:r(311),icon:"activity"}),x.length===0&&(_?x[r(312)]({name:"Bullish Continuation",sentiment:r(313),icon:r(307)}):x.push({name:r(337),sentiment:r(330),icon:r(333)})),x},FX=(n,e,t,s=14)=>{const r=va;let a=[];const i=Array[r(332)](n)&&Array[r(332)](e)&&Array[r(332)](t),o=i?n.length:Array[r(332)](n)?n[r(346)]:0;if(o<s+1)return[];for(let f=1;f<o;f++){let m;if(i){const y=n[f],b=e[f],x=t[f-1];m=Math[r(308)](y-b,Math[r(315)](y-x),Math[r(315)](b-x))}else{const y=n[f],b=n[f-1],x=Math[r(315)](y-b);m=Math[r(308)](x,y*.0075)}a[r(312)](m)}const l=[];let h=a[r(323)](0,s)[r(329)]((f,m)=>f+m,0)/s;l.push(h);for(let f=s;f<a[r(346)];f++){const m=(l[l[r(346)]-1]*(s-1)+a[f])/s;l[r(312)](m)}return[...new Array(o-l.length)[r(319)](l[0]),...l]},LX=(n,e,t)=>{const s=va,r=Array[s(332)](n)?n:[];if(r[s(346)]<20)return{support:Math[s(352)](...r),resistance:Math[s(308)](...r),strength:{s:1,r:1}};const a=Array.isArray(e)&&Array.isArray(t)&&e[s(346)]===r[s(346)],i=[],o=5;for(let m=o;m<r[s(346)]-o;m++)if(a){const y=e.slice(m-o,m+o+1),b=e[m];y[s(344)](v=>v<=b)&&i[s(312)]({price:b,type:s(324)});const x=t.slice(m-o,m+o+1),w=t[m];x[s(344)](v=>v>=w)&&i[s(312)]({price:w,type:s(320)})}else{const y=r[s(323)](m-o,m+o+1),b=r[m],x=y[s(344)](v=>v<=b),w=y.every(v=>v>=b);x&&i[s(312)]({price:b,type:s(324)}),w&&i[s(312)]({price:b,type:s(320)})}const l=r[r[s(346)]-1],h=(m,y)=>{const b=s,x=i[b(304)](N=>N[b(310)]===m&&(m==="Support"?N.price<y:N[b(345)]>y));if(x[b(346)]===0)return{price:m===b(320)?Math.min(...r):Math[b(308)](...r),strength:1};const w=x[b(340)]((N,k)=>Math[b(315)](N[b(345)]-y)-Math[b(315)](k.price-y)),v=w[0][b(345)],C=i[b(304)](N=>N[b(310)]===m&&Math.abs(N[b(345)]-v)/v<.005).length;return{price:v,strength:Math[b(352)](5,C)}},d=h(s(320),l),f=h(s(324),l);return{support:d.price,resistance:f[s(345)],strength:{s:d[s(331)],r:f.strength}}},MX=(n,e,t,s)=>{const r=va;if(!s||s[r(346)]===0||s[r(346)]!==t.length)return t;let a=0,i=0;const o=[];for(let l=0;l<t[r(346)];l++){const h=(n[l]+e[l]+t[l])/3;a+=h*s[l],i+=s[l],o[r(312)](i===0?h:a/i)}return o},zX=n=>{const e=va;if(!n||n[e(346)]<50)return .5;const t=Lf(n[e(323)](-20),10),s=Lf(n.slice(-50),40),r=t[t[e(346)]-1],a=s[s[e(346)]-1];let i=.5;r>a&&(i=.75),r<a&&(i=.25);const o=n[n[e(346)]-1];return o>r&&r>a&&(i=.9),o<r&&r<a&&(i=.1),i};function N0(){const n=["reduce","Bearish","strength","isArray","trending-down","zap","Bullish Marubozu","Bearish Marubozu","Bearish Continuation","Volatility Squeeze","329PwcgRz","sort","Doji Star","3781536dUJXNB","9qCTfTy","every","price","length","sqrt","103144mGBVPL","Bearish Engulfing","2023812PJXvtP","Bullish Engulfing","min","pow","filter","163053fXlbHv","Insufficient Data","trending-up","max","14463819EnZjAX","type","Neutral","push","Bullish","Inverted Hammer","abs","map","minus","43094baBcAY","fill","Support","Gravestone Doji","2403245CrGrSW","slice","Resistance","Shooting Star","thumbs-up","Harami (Inside Bar)","Dragonfly Doji"];return N0=function(){return n},N0()}const PX=1e-7,BX=1e-4;class u2{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class fb{refCount(e){return js("refCount")}incRef(e){return js("incRef")}timerAvailable(){return!0}time(e){return js("time")}read(e){return js("read")}readSync(e){return js("readSync")}readToGPU(e,t){return js("readToGPU")}numDataIds(){return js("numDataIds")}disposeData(e,t){return js("disposeData")}write(e,t,s){return js("write")}move(e,t,s,r,a){return js("move")}createTensorFromGPUData(e,t,s){return js("createTensorFromGPUData")}memory(){return js("memory")}floatPrecision(){return js("floatPrecision")}epsilon(){return this.floatPrecision()===32?PX:BX}dispose(){return js("dispose")}}function js(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function c2(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,wi(n,e,t)}function VX(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,wi(n,t,s),wi(e,t,s)}function $o(n,e,t){return Math.max(n,Math.min(e,t))}function pb(n){return n%2===0?n:n+1}function wi(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function nM(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function UX(n,e){const t=Math.random();return e*t+(1-t)*n}function jX(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function O(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Jn(n,e,t=""){O(lt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function cu(n){O(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function he(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function WX(n){return n.length===0}function sM(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function lt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Hl(n){return n%1===0}function GX(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function k0(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function HX(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return c2(e),e}function Vl(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function NT(n,e=r=>0,t,s){return new Promise((r,a)=>{let i=0;const o=()=>{if(n()){r();return}i++;const l=e(i);if(t!=null&&i>=t){a();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function h2(n,e){let t=1,s=-1;for(let a=0;a<n.length;++a)if(n[a]>=0)t*=n[a];else if(n[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(n[a]<0)throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function at(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),O(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),O(n.every(s=>Hl(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Di(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||r?null:at(e,n).sort();let i=0;for(let o=0;o<n.length;++o){if(a!=null){if(a[i]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(a[i]==null||a[i]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),a[i]<=o&&i++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function zn(n,e){return tn(n,e)}function tn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function rM(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function aM(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function d2(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Yf(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function iM(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Fa(n){return typeof n=="string"||n instanceof String}function oM(n){return typeof n=="boolean"}function E0(n){return typeof n=="number"}function hu(n){return Array.isArray(n)?hu(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":E0(n)?"float32":Fa(n)?"string":oM(n)?"bool":"float32"}function Io(n){return!!(n&&n.constructor&&n.call&&n.apply)}function $0(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Pe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function lM(n,e,t,s=!1){const r=new Array;if(e.length===1){const a=e[0]*(s?2:1);for(let i=0;i<a;i++)r[i]=t[n+i]}else{const a=e[0],i=e.slice(1),o=i.reduce((l,h)=>l*h)*(s?2:1);for(let l=0;l<a;l++)r[l]=lM(n+l*o,i,t,s)}return r}function vr(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,a)=>r*a)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return lM(0,n,e,t)}function uM(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function mb(n,e){const t=Yn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Yn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function f2(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return vr(n,new Float32Array(t));if(e==="int32")return vr(n,new Int32Array(t));if(e==="bool")return vr(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function tr(n){n.forEach(e=>{O(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function fa(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function du(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Ni(n){return n&&n.then&&typeof n.then=="function"}const uO="tfjsflags";class cM{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=qX,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ni(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);uO in e&&e[uO].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=XX(r,a)})}}function qX(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(KX(e,s[0],s[1]),s.join("="))),e}function KX(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function XX(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ie(){return p2}let p2=null;function YX(n){p2=n}let ES;function hM(){if(ES==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");ES=n}return ES}function JX(){const n=hM();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function m2(n,e){const t=JX();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const vp="Abs",eh="Acos",th="Acosh",fu="Add",Sp="AddN",gb="All",yb="Any",Tp="ArgMax",Cp="ArgMin",nh="Asin",sh="Asinh",rh="Atan",ah="Atanh",ih="Atan2",Np="AvgPool",bb="AvgPoolGrad",kp="AvgPool3D",xb="AvgPool3DGrad",Ep="BatchMatMul",$p="BatchToSpaceND",wb="Bincount",Ip="BitwiseAnd",dM="BroadcastTo",vb="BroadcastArgs",oh="Cast",lh="Ceil",uh="ClipByValue",Sb="Complex",_p="ComplexAbs",Ap="Concat",Rp="Conv2D",Tb="Conv2DBackpropFilter",Dp="Conv2DBackpropInput",Op="Conv3D",Cb="Conv3DBackpropFilterV2",Nb="Conv3DBackpropInputV2",ch="Cos",hh="Cosh",kb="Cumprod",Fp="Cumsum",Eb="CropAndResize",$b="DenseBincount",Ib="DepthToSpace",Lp="DepthwiseConv2dNative",_b="DepthwiseConv2dNativeBackpropFilter",Ab="DepthwiseConv2dNativeBackpropInput",Rb="Diag",Mp="Dilation2D",I0="Dilation2DBackpropInput",_0="Dilation2DBackpropFilter",Db="Draw",dh="RealDiv",Ob="Einsum",fh="Elu",Fb="EluGrad",ph="Erf",zp="Equal",mh="Exp",Pp="ExpandDims",gh="Expm1",Lb="FFT",Mb="Fill",zb="FlipLeftRight",yh="Floor",bh="FloorDiv",Bp="FusedBatchNorm",Vp="GatherV2",Pb="GatherNd",Up="Greater",xh="GreaterEqual",wh="Identity",Bb="IFFT",Vb="Imag",vh="IsFinite",Sh="IsInf",Th="IsNan",jp="LeakyRelu",Wp="Less",Gp="LessEqual",Ub="LinSpace",Ch="Log",Nh="Log1p",Hp="LogicalAnd",qp="LogicalNot",Kp="LogicalOr",ZX="LogicalXor",fM="LogSoftmax",QX="LowerBound",Xp="LRN",jb="LRNGrad",e7="MatrixBandPart",Yp="Max",kh="Maximum",Jp="MaxPool",Wb="MaxPoolGrad",Zp="MaxPool3D",Gb="MaxPool3DGrad",Hb="MaxPoolWithArgmax",Qp="Mean",em="Min",Eh="Minimum",tm="MirrorPad",$h="Mod",qb="Multinomial",Ih="Multiply",nm="Neg",sm="NotEqual",Kb="NonMaxSuppressionV3",Xb="NonMaxSuppressionV4",Yb="NonMaxSuppressionV5",rm="OnesLike",am="OneHot",im="Pack",om="PadV2",t7="Pool",_h="Pow",lm="Prelu",um="Prod",Jb="RaggedGather",Zb="RaggedRange",Qb="RaggedTensorToTensor",ex="Range",tx="Real",Ah="Reciprocal",Rh="Relu",cm="Reshape",hm="ResizeNearestNeighbor",nx="ResizeNearestNeighborGrad",dm="ResizeBilinear",sx="ResizeBilinearGrad",Dh="Relu6",fm="Reverse",Oh="Round",Fh="Rsqrt",rx="ScatterNd",ax="TensorScatterUpdate",ix="SearchSorted",pm="Select",Lh="Selu",mm="Slice",Mh="Sin",zh="Sinh",Ph="Sign",Bh="Sigmoid",Vh="Softplus",Uh="Sqrt",gm="Sum",ym="SpaceToBatchND",bm="SplitV",xm="Softmax",ox="SparseFillEmptyRows",lx="SparseReshape",ux="SparseSegmentMean",cx="SparseSegmentSum",hx="SparseToDense",jh="SquaredDifference",dx="Square",wm="StaticRegexReplace",fx="StridedSlice",px="StringNGrams",mx="StringSplit",gx="StringToHashBucketFast",Wh="Sub",Gh="Tan",Hh="Tanh",qh="Tile",yx="TopK",bx="Transform",Ul="Transpose",xx="Unique",vm="Unpack",Sm="UnsortedSegmentSum",n7="UpperBound",Tm="ZerosLike",Kh="Step",A0="FromPixels",wx="RotateWithOffset",Jf="_FusedMatMul",Zf="FusedConv2D",Qf="FusedDepthwiseConv2D";function gr(...n){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(...n)}function s7(...n){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.log(...n)}const Mc=m2("kernelRegistry",()=>new Map),ep=m2("gradRegistry",()=>new Map);function tp(n,e){const t=g2(n,e);return Mc.get(t)}function kT(n){return ep.get(n)}function R0(n){const e=Mc.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[a,i]=r,[o]=a.split("_");o===n&&t.push(i)}return t}function vx(n){const{kernelName:e,backendName:t}=n,s=g2(e,t);Mc.has(s)&&gr(`The kernel '${e}' for backend '${t}' is already registered`),Mc.set(s,n)}function pM(n){const{kernelName:e}=n;ep.has(e)&&ie().getBool("DEBUG")&&gr(`Overriding the gradient for '${e}'`),ep.set(e,n)}function r7(n,e){const t=g2(n,e);if(!Mc.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Mc.delete(t)}function a7(n){if(!ep.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);ep.delete(n)}function i7(n,e){R0(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});vx(r)})}function g2(n,e){return`${e}_${n}`}function mM(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var $S,cO;function o7(){if(cO)return $S;cO=1,$S=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(L,A,V){this.low=L|0,this.high=A|0,this.unsigned=!!V}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(L){return(L&&L.__isLong__)===!0}e.isLong=t;var s={},r={};function a(L,A){var V,q,ne;return A?(L>>>=0,(ne=0<=L&&L<256)&&(q=r[L],q)?q:(V=o(L,(L|0)<0?-1:0,!0),ne&&(r[L]=V),V)):(L|=0,(ne=-128<=L&&L<128)&&(q=s[L],q)?q:(V=o(L,L<0?-1:0,!1),ne&&(s[L]=V),V))}e.fromInt=a;function i(L,A){if(isNaN(L))return A?C:v;if(A){if(L<0)return C;if(L>=b)return R}else{if(L<=-x)return D;if(L+1>=x)return _}return L<0?i(-L,A).neg():o(L%y|0,L/y|0,A)}e.fromNumber=i;function o(L,A,V){return new e(L,A,V)}e.fromBits=o;var l=Math.pow;function h(L,A,V){if(L.length===0)throw Error("empty string");if(L==="NaN"||L==="Infinity"||L==="+Infinity"||L==="-Infinity")return v;if(typeof A=="number"?(V=A,A=!1):A=!!A,V=V||10,V<2||36<V)throw RangeError("radix");var q;if((q=L.indexOf("-"))>0)throw Error("interior hyphen");if(q===0)return h(L.substring(1),A,V).neg();for(var ne=i(l(V,8)),Q=v,B=0;B<L.length;B+=8){var U=Math.min(8,L.length-B),X=parseInt(L.substring(B,B+U),V);if(U<8){var K=i(l(V,U));Q=Q.mul(K).add(i(X))}else Q=Q.mul(ne),Q=Q.add(i(X))}return Q.unsigned=A,Q}e.fromString=h;function d(L,A){return typeof L=="number"?i(L,A):typeof L=="string"?h(L,A):o(L.low,L.high,typeof A=="boolean"?A:L.unsigned)}e.fromValue=d;var f=65536,m=1<<24,y=f*f,b=y*y,x=b/2,w=a(m),v=a(0);e.ZERO=v;var C=a(0,!0);e.UZERO=C;var N=a(1);e.ONE=N;var k=a(1,!0);e.UONE=k;var E=a(-1);e.NEG_ONE=E;var _=o(-1,2147483647,!1);e.MAX_VALUE=_;var R=o(-1,-1,!0);e.MAX_UNSIGNED_VALUE=R;var D=o(0,-2147483648,!1);e.MIN_VALUE=D;var F=e.prototype;return F.toInt=function(){return this.unsigned?this.low>>>0:this.low},F.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},F.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(D)){var V=i(A),q=this.div(V),ne=q.mul(V).sub(this);return q.toString(A)+ne.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var Q=i(l(A,6),this.unsigned),B=this,U="";;){var X=B.div(Q),K=B.sub(X.mul(Q)).toInt()>>>0,se=K.toString(A);if(B=X,B.isZero())return se+U;for(;se.length<6;)se="0"+se;U=""+se+U}},F.getHighBits=function(){return this.high},F.getHighBitsUnsigned=function(){return this.high>>>0},F.getLowBits=function(){return this.low},F.getLowBitsUnsigned=function(){return this.low>>>0},F.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,V=31;V>0&&(A&1<<V)==0;V--);return this.high!=0?V+33:V+1},F.isZero=function(){return this.high===0&&this.low===0},F.eqz=F.isZero,F.isNegative=function(){return!this.unsigned&&this.high<0},F.isPositive=function(){return this.unsigned||this.high>=0},F.isOdd=function(){return(this.low&1)===1},F.isEven=function(){return(this.low&1)===0},F.equals=function(A){return t(A)||(A=d(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},F.eq=F.equals,F.notEquals=function(A){return!this.eq(A)},F.neq=F.notEquals,F.ne=F.notEquals,F.lessThan=function(A){return this.comp(A)<0},F.lt=F.lessThan,F.lessThanOrEqual=function(A){return this.comp(A)<=0},F.lte=F.lessThanOrEqual,F.le=F.lessThanOrEqual,F.greaterThan=function(A){return this.comp(A)>0},F.gt=F.greaterThan,F.greaterThanOrEqual=function(A){return this.comp(A)>=0},F.gte=F.greaterThanOrEqual,F.ge=F.greaterThanOrEqual,F.compare=function(A){if(t(A)||(A=d(A)),this.eq(A))return 0;var V=this.isNegative(),q=A.isNegative();return V&&!q?-1:!V&&q?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},F.comp=F.compare,F.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(N)},F.neg=F.negate,F.add=function(A){t(A)||(A=d(A));var V=this.high>>>16,q=this.high&65535,ne=this.low>>>16,Q=this.low&65535,B=A.high>>>16,U=A.high&65535,X=A.low>>>16,K=A.low&65535,se=0,P=0,j=0,te=0;return te+=Q+K,j+=te>>>16,te&=65535,j+=ne+X,P+=j>>>16,j&=65535,P+=q+U,se+=P>>>16,P&=65535,se+=V+B,se&=65535,o(j<<16|te,se<<16|P,this.unsigned)},F.subtract=function(A){return t(A)||(A=d(A)),this.add(A.neg())},F.sub=F.subtract,F.multiply=function(A){if(this.isZero())return v;if(t(A)||(A=d(A)),n){var V=n.mul(this.low,this.high,A.low,A.high);return o(V,n.get_high(),this.unsigned)}if(A.isZero())return v;if(this.eq(D))return A.isOdd()?D:v;if(A.eq(D))return this.isOdd()?D:v;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(w)&&A.lt(w))return i(this.toNumber()*A.toNumber(),this.unsigned);var q=this.high>>>16,ne=this.high&65535,Q=this.low>>>16,B=this.low&65535,U=A.high>>>16,X=A.high&65535,K=A.low>>>16,se=A.low&65535,P=0,j=0,te=0,oe=0;return oe+=B*se,te+=oe>>>16,oe&=65535,te+=Q*se,j+=te>>>16,te&=65535,te+=B*K,j+=te>>>16,te&=65535,j+=ne*se,P+=j>>>16,j&=65535,j+=Q*K,P+=j>>>16,j&=65535,j+=B*X,P+=j>>>16,j&=65535,P+=q*se+ne*K+Q*X+B*U,P&=65535,o(te<<16|oe,P<<16|j,this.unsigned)},F.mul=F.multiply,F.divide=function(A){if(t(A)||(A=d(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var V=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return o(V,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?C:v;var q,ne,Q;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return C;if(A.gt(this.shru(1)))return k;Q=C}else{if(this.eq(D)){if(A.eq(N)||A.eq(E))return D;if(A.eq(D))return N;var B=this.shr(1);return q=B.div(A).shl(1),q.eq(v)?A.isNegative()?N:E:(ne=this.sub(A.mul(q)),Q=q.add(ne.div(A)),Q)}else if(A.eq(D))return this.unsigned?C:v;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();Q=v}for(ne=this;ne.gte(A);){q=Math.max(1,Math.floor(ne.toNumber()/A.toNumber()));for(var U=Math.ceil(Math.log(q)/Math.LN2),X=U<=48?1:l(2,U-48),K=i(q),se=K.mul(A);se.isNegative()||se.gt(ne);)q-=X,K=i(q,this.unsigned),se=K.mul(A);K.isZero()&&(K=N),Q=Q.add(K),ne=ne.sub(se)}return Q},F.div=F.divide,F.modulo=function(A){if(t(A)||(A=d(A)),n){var V=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return o(V,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},F.mod=F.modulo,F.rem=F.modulo,F.not=function(){return o(~this.low,~this.high,this.unsigned)},F.and=function(A){return t(A)||(A=d(A)),o(this.low&A.low,this.high&A.high,this.unsigned)},F.or=function(A){return t(A)||(A=d(A)),o(this.low|A.low,this.high|A.high,this.unsigned)},F.xor=function(A){return t(A)||(A=d(A)),o(this.low^A.low,this.high^A.high,this.unsigned)},F.shiftLeft=function(A){return t(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?o(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):o(0,this.low<<A-32,this.unsigned)},F.shl=F.shiftLeft,F.shiftRight=function(A){return t(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?o(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):o(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},F.shr=F.shiftRight,F.shiftRightUnsigned=function(A){if(t(A)&&(A=A.toInt()),A&=63,A===0)return this;var V=this.high;if(A<32){var q=this.low;return o(q>>>A|V<<32-A,V>>>A,this.unsigned)}else return A===32?o(V,0,this.unsigned):o(V>>>A-32,0,this.unsigned)},F.shru=F.shiftRightUnsigned,F.shr_u=F.shiftRightUnsigned,F.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},F.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},F.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},F.toBytesLE=function(){var A=this.high,V=this.low;return[V&255,V>>>8&255,V>>>16&255,V>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},F.toBytesBE=function(){var A=this.high,V=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,V>>>24,V>>>16&255,V>>>8&255,V&255]},e.fromBytes=function(A,V,q){return q?e.fromBytesLE(A,V):e.fromBytesBE(A,V)},e.fromBytesLE=function(A,V){return new e(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,V)},e.fromBytesBE=function(A,V){return new e(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],V)},$S}var gM=o7();const yM=TC(gM),l7=IG({__proto__:null,default:yM},[gM]);const $l=yM||l7;function Cm(n){return $l.fromString(n,!0,16)}const bM=Cm("c3a5c85c97cb3127"),Cl=Cm("b492b66fbe98f273"),ps=Cm("9ae16a3b2f90404f");function ET(n){return n.xor(n.shru(47))}function xM(n,e,t){const s=n.slice(e,e+t);return $l.fromBytes(Array.from(s),!0,!0)}function Lt(n,e){return xM(n,e,8)}function hO(n,e){return xM(n,e,4)}function Fn(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function So(n,e,t=Cm("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function u7(n,e,t,s,r,a){r=r.add(n),a=Fn(a.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(t),a=a.add(Fn(r,44)),[r.add(s),a.add(i)]}function Dy(n,e,t,s){return u7(Lt(n,e),Lt(n,e+8),Lt(n,e+16),Lt(n,e+24),t,s)}function c7(n,e=n.length){if(e>=8){const t=ps.add(e*2),s=Lt(n,0).add(ps),r=Lt(n,e-8),a=Fn(r,37).mul(t).add(s),i=Fn(s,25).add(r).mul(t);return So(a,i,t)}if(e>=4){const t=ps.add(e*2),s=hO(n,0);return So(s.shl(3).add(e),hO(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],a=t+(s<<8),i=e+(r<<2);return ET(ps.mul(a).xor(bM.mul(i))).mul(ps)}return ps}function h7(n,e=n.length){const t=ps.add(e*2),s=Lt(n,0).mul(Cl),r=Lt(n,8),a=Lt(n,e-8).mul(t),i=Lt(n,e-16).mul(ps);return So(Fn(s.add(r),43).add(Fn(a,30)).add(i),s.add(Fn(r.add(ps),18)).add(a),t)}function d7(n,e=n.length){const t=ps.add(e*2),s=Lt(n,0).mul(ps),r=Lt(n,8),a=Lt(n,e-8).mul(t),i=Lt(n,e-16).mul(ps),o=Fn(s.add(r),43).add(Fn(a,30)).add(i),l=So(o,s.add(Fn(r.add(ps),18)).add(a),t),h=Lt(n,16).mul(t),d=Lt(n,24),f=o.add(Lt(n,e-32)).mul(t),m=l.add(Lt(n,e-24)).mul(t);return So(Fn(h.add(d),43).add(Fn(f,30)).add(m),h.add(Fn(d.add(s),18)).add(f),t)}function wM(n,e=n.length){const t=$l.fromNumber(81,!0);if(e<=32)return e<=16?c7(n,e):h7(n,e);if(e<=64)return d7(n,e);let s=t,r=t.mul(Cl).add(113),a=ET(r.mul(ps).add(113)).mul(ps),i=[$l.UZERO,$l.UZERO],o=[$l.UZERO,$l.UZERO];s=s.mul(ps).add(Lt(n,0));let l=0;const h=(e-1>>6)*64,d=h+(e-1&63)-63;do s=Fn(s.add(r).add(i[0]).add(Lt(n,l+8)),37).mul(Cl),r=Fn(r.add(i[1]).add(Lt(n,l+48)),42).mul(Cl),s=s.xor(o[1]),r=r.add(i[0]).add(Lt(n,l+40)),a=Fn(a.add(o[0]),33).mul(Cl),i=Dy(n,l,i[1].mul(Cl),s.add(o[0])),o=Dy(n,l+32,a.add(o[1]),r.add(Lt(n,l+16))),[a,s]=[s,a],l+=64;while(l!==h);const f=Cl.add(a.and(255).shl(1));return l=d,o[0]=o[0].add(e-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),s=Fn(s.add(r).add(i[0]).add(Lt(n,l+8)),37).mul(f),r=Fn(r.add(i[1]).add(Lt(n,l+48)),42).mul(f),s=s.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(Lt(n,l+40))),a=Fn(a.add(o[0]),33).mul(f),i=Dy(n,l,i[1].mul(f),s.add(o[0])),o=Dy(n,l+32,a.add(o[1]),r.add(Lt(n,l+16))),[a,s]=[s,a],So(So(i[0],o[0],f).add(ET(r).mul(bM)).add(a),So(i[1],o[1],f).add(s),f)}function Oi(n,e){return e==="string"?Pa(n):Bo([n],e)}function f7(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Bo(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Wa(n)),ie().getBool("DEBUG")&&rM(n,e),f7(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Gn(){return ie().platform.now()}function vM(n,e){return ie().platform.fetch(n,e)}function Pa(n,e="utf-8"){return e=e||"utf-8",ie().platform.encode(n,e)}function ki(n,e="utf-8"){return e=e||"utf-8",ie().platform.decode(n,e)}function kn(n){return ie().platform.isTypedArray!=null?ie().platform.isTypedArray(n):mM(n)}function Wa(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Ni(n)||n==null||kn(n)&&t)e.push(n);else if(Array.isArray(n)||kn(n))for(let s=0;s<n.length;++s)Wa(n[s],e,t);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Wa(n[r],e,t)}return e}const p7=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:lt,arraysEqualWithNull:sM,assert:O,assertNonNegativeIntegerDimensions:tr,assertNonNull:cu,assertShapesMatch:Jn,bytesFromStringArray:iM,bytesPerElement:Yf,checkConversionForErrors:rM,clamp:$o,computeStrides:Pe,convertBackendValuesAndArrayBuffer:uM,createScalarValue:Oi,createShuffledIndices:HX,decodeString:ki,distSquared:jX,encodeString:Pa,fetch:vM,fingerPrint64:wM,flatten:Wa,getArrayFromDType:tn,getTypedArrayFromDType:zn,hasEncodingLoss:d2,hexToLong:Cm,indexToLoc:du,inferDtype:hu,inferFromImplicitShape:h2,isBoolean:oM,isFunction:Io,isInt:Hl,isNumber:E0,isPromise:Ni,isScalarShape:WX,isString:Fa,isTypedArray:kn,isValidDtype:aM,locToIndex:fa,makeOnesTypedArray:mb,makeZerosNestedTypedArray:f2,makeZerosTypedArray:Yn,nearestDivisor:$0,nearestLargerEven:pb,now:Gn,parseAxisParam:at,randUniform:UX,repeatedTry:NT,rightPad:Vl,shuffle:c2,shuffleCombo:VX,sizeFromShape:he,sizeToSquarishShape:k0,squeezeShape:Di,sum:nM,swap:wi,tanh:GX,toNestedArray:vr,toTypedArray:Bo},Symbol.toStringTag,{value:"Module"}));class m7{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new y7)}profileKernel(e,t,s){let r;const a=()=>{r=s()};let i;const o=Gn();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const h of r)h.dataSync();i=Promise.resolve({kernelMs:Gn()-o})}if(ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<r.length;h++){const d=r[h];d.data().then(f=>{g7(f,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then(h=>h.kernelMs),extraInfo:i.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:a,extraInfo:i}=e;s.forEach(o=>{Promise.all([o.data(),r,i]).then(l=>{this.logger.logKernelProfile(t,o,l[0],l[1],a,l[2])})})}}function g7(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class y7{logKernelProfile(e,t,s,r,a,i){const o=typeof r=="number"?Vl(`${r}ms`,9):r.error,l=Vl(e,25),h=t.rank,d=t.size,f=Vl(t.shape.toString(),14);let m="";for(const y in a){const b=a[y];if(b!=null){const x=b.shape||t.shape,w=x.length;m+=`${y}: ${w}D ${w>0?x:""} `}}console.log(`%c${l}	%c${o}	%c${h}D ${f}	%c${d}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function b7(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const h=n[l],d=h.inputs;for(const f in d){const m=d[f];let y=!1;for(let b=0;b<e.length;b++)if(s[m.id]){h.outputs.forEach(x=>s[x.id]=!0),y=!0,r[h.id]=!0;break}if(y)break}}const a={};a[t.id]=!0;const i={};for(let l=n.length-1;l>=0;l--){const h=n[l],d=h.inputs;for(let f=0;f<h.outputs.length;f++)if(a[h.outputs[f].id]){for(const m in d)a[d[m].id]=!0,i[h.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const h=n[l];if(r[h.id]&&i[h.id]){const d={};for(const m in h.inputs){const y=h.inputs[m];s[y.id]&&(d[m]=y)}const f=Object.assign({},h);f.inputs=d,f.outputs=h.outputs,o.push(f)}}return o}function x7(n,e,t,s){for(let r=e.length-1;r>=0;r--){const a=e[r],i=[];if(a.outputs.forEach(l=>{const h=n[l.id];h!=null?i.push(h):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const h=t(()=>o[l]());if(h.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${h.dtype}'`);const d=a.inputs[l];if(!lt(h.shape,d.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${h.shape}', which does not match the shape of the input '${d.shape}'`);if(n[d.id]==null)n[d.id]=h;else{const f=n[d.id];n[d.id]=s(f,h),f.dispose()}}}}const dO=20,pf=3,IS=7;function w7(n,e,t,s){const r=Pe(e),a=v7(n,e,t,r),i=e.length,o=Zy(n,e,t,r,a),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${i}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(h=>"    "+h).join(`
`)),l.join(`
`)}function v7(n,e,t,s){const r=he(e),a=s[s.length-1],i=new Array(a).fill(0),o=e.length,l=t==="complex64"?Sf(n):n;if(o>1)for(let h=0;h<r/a;h++){const d=h*a;for(let f=0;f<a;f++)i[f]=Math.max(i[f],vf(l[d+f],0,t).length)}return i}function vf(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(IS))} + ${parseFloat(n[1].toFixed(IS))}j`:Fa(n)?s=`'${n}'`:t==="bool"?s=SM(n):s=parseFloat(n.toFixed(IS)).toString(),Vl(s,e)}function SM(n){return n===0?"false":"true"}function Zy(n,e,t,s,r,a=!0){const i=t==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(t==="complex64"){const x=Sf(n);return[vf(x[0],0,t)]}return t==="bool"?[SM(n[0])]:[n[0].toString()]}if(l===1){if(o>dO){const w=pf*i;let v=Array.from(n.slice(0,w)),C=Array.from(n.slice((o-pf)*i,o*i));return t==="complex64"&&(v=Sf(v),C=Sf(C)),["["+v.map((N,k)=>vf(N,r[k],t)).join(", ")+", ..., "+C.map((N,k)=>vf(N,r[o-pf+k],t)).join(", ")+"]"]}return["["+(t==="complex64"?Sf(n):Array.from(n)).map((w,v)=>vf(w,r[v],t)).join(", ")+"]"]}const h=e.slice(1),d=s.slice(1),f=s[0]*i,m=[];if(o>dO){for(let x=0;x<pf;x++){const w=x*f,v=w+f;m.push(...Zy(n.slice(w,v),h,t,d,r,!1))}m.push("...");for(let x=o-pf;x<o;x++){const w=x*f,v=w+f;m.push(...Zy(n.slice(w,v),h,t,d,r,x===o-1))}}else for(let x=0;x<o;x++){const w=x*f,v=w+f;m.push(...Zy(n.slice(w,v),h,t,d,r,x===o-1))}const y=l===2?",":"";m[0]="["+(o>0?m[0]+y:"");for(let x=1;x<m.length-1;x++)m[x]=" "+m[x]+y;let b=`,
`;for(let x=2;x<l;x++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(a?"":b),m}function Sf(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class bn{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=he(e),s!=null){const r=s.length;O(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||tn(t,this.size),this.strides=Pe(e)}set(e,...t){t.length===0&&(t=[0]),O(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ha().makeTensor(this.values,this.shape,this.dtype)}}let ha=null,Sc=null;function S7(n){ha=n}function T7(n){Sc=n}class bt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=he(e),this.strides=Pe(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Sc.buffer(this.shape,this.dtype,e)}bufferSync(){return Sc.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return vr(this.shape,e,this.dtype==="complex64")}arraySync(){return vr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=ha().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>ki(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ha().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ha().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ki(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ha().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ha().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Sc.print(this,e)}clone(){return this.throwIfDisposed(),Sc.clone(this)}toString(e=!1){const t=this.dataSync();return w7(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Sc.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),ha().makeVariable(this,e,t,s)}}Object.defineProperty(bt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function fe(){return m2("Tensor",()=>bt)}fe();class np extends bt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!lt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ha().disposeTensor(this),this.dataId=e.dataId,ha().incRef(this,null)}dispose(){ha().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(np,Symbol.hasInstance,{value:n=>n instanceof bt&&n.assign!=null&&n.assign instanceof Function});var $T;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})($T||($T={}));var IT;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(IT||(IT={}));var _T;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(_T||(_T={}));var AT;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(AT||(AT={}));var RT;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(RT||(RT={}));const C7={float32:AT,int32:IT,bool:_T,complex64:RT};function _s(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return C7[n][e]}function Sx(n){return _s(n,"int32")}function TM(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function CM(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Jt(n,e){if(n.dtype===e.dtype)return[n,e];const t=_s(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function NM(n,e){O(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Tx(n,e){return e.some(t=>t.id===n.id)}function Ei(n){const e=[];return kM(n,e,new Set),e}function kM(n,e,t){if(n==null)return;if(n instanceof bt){e.push(n);return}if(!N7(n))return;const s=n;for(const r in s){const a=s[r];t.has(a)||(t.add(a),kM(a,e,t))}}function N7(n){return Array.isArray(n)||typeof n=="object"}const k7=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:NM,getTensorsInContainer:Ei,isTensorInList:Tx,makeTypesMatch:Jt},Symbol.toStringTag,{value:"Module"}));function _S(n){return n.kernelName!=null}class fO{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class zc{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fO}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(gr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new m7(this.backendInstance),!0}setupRegisteredKernels(){R0(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){R0(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof fb)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,a=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,gr(`Initialization of backend ${e} failed`),gr(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return gr(`Initialization of backend ${e} failed`),gr(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:a}=this.initializeBackend(s);if(a||r)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,a=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,a,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return zc.nextTensorId++}nextVariableId(){return zc.nextVariableId++}clone(e){const t=W.runKernel(wh,{x:e}),s={x:e},r=i=>({x:()=>{const o="float32",l={x:i},h={dtype:o};return W.runKernel(oh,l,h)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,a,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(tp(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let a=0;s.forEach(l=>{a+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const h=_S(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(_S(e)){const{kernelName:b,inputs:x,attrs:w}=e;this.backendName==null&&this.backend;const v=tp(b,this.backendName);O(v!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),o=()=>{const C=this.backend.numDataIds();l=v.kernelFunc({inputs:x,attrs:w,backend:this.backend});const N=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,C,N);const k=N.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(r){const E=this.getTensorsForGradient(b,x,k);s=this.saveTensorsForBackwardMode(E)}return k}}else{const{forwardFunc:b}=e,x=w=>{r&&(s=w.map(v=>this.keep(this.clone(v))))};o=()=>{const w=this.backend.numDataIds();l=this.tidy(()=>b(this.backend,x));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,w,v),v}}const{inputs:d,attrs:f}=e,m=_S(e)?null:e.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(y=this.profiler.profileKernel(h,d,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),t=y.outputs)}),r&&this.addTapeNode(h,d,t,m,s,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(b=>d[b]!=null?d[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=kT(e);if(r!=null){const a=r.inputsToSave||[],i=r.outputsToSave||[];let o;r.saveAllInputs?(O(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(h=>t[h])):o=a.map(h=>t[h]);const l=s.filter((h,d)=>i[d]);return o.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let a=e;s==="string"&&Fa(e[0])&&(a=e.map(l=>Pa(l)));const i=r.write(a,t,s),o=new bt(t,s,i,this.nextTensorId());if(this.trackTensor(o,r),s==="string"){const l=this.state.tensorInfo.get(i),h=iM(a);this.state.numBytes+=h-l.bytes,l.bytes=h}return o}makeTensorFromDataId(e,t,s,r){s=s||"float32";const a={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:r,dtype:a}=e,i=new bt(r,a,s,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const a=new np(e,t,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Yf(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof np||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Yf(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:a},l=kT(e);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=h=>(h=h.map((d,f)=>{if(d==null){const m=s[f],y=Yn(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return d}),r(h.length>1?h:h[0],a,i))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ei(e),s=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(e,t,s,r=!1){if(O(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));O(a instanceof bt,()=>"The result y returned by f() must be a tensor.");const i=b7(this.state.activeTape,t,a);if(!r&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=s??E7(a.shape),x7(o,i,h=>this.tidy(h),$7);const l=t.map(h=>o[h.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(h=>{for(const d of h.saved)d.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(e){return O(Io(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{O(t.every(o=>o instanceof bt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((o,l)=>{r[l]=o});const a=(o,l)=>(s=e(...t,l),O(s.value instanceof bt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),O(Io(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(o,l)=>{const h=s.gradFunc(o,l),d=Array.isArray(h)?h:[h];O(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),O(d.every(m=>m instanceof bt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return d.forEach((m,y)=>{f[y]=()=>m}),f};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Gn(),s=await this.backend.time(e);return s.wallMs=Gn()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fO;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}zc.nextTensorId=0;zc.nextVariableId=0;function E7(n){const e=mb(he(n),"float32");return W.makeTensor(e,n,"float32")}function EM(){const n=hM();if(n._tfengine==null){const e=new cM(n);n._tfengine=new zc(e)}return YX(n._tfengine.ENV),S7(()=>n._tfengine),n._tfengine}const W=EM();function $7(n,e){const t={a:n,b:e};return W.runKernel(fu,t)}function I7(){return typeof navigator<"u"&&navigator!=null}let DT;function _7(n){DT=n}function y2(n){if(DT!==void 0)return DT;if(n||I7()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function b2(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const A7=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:b2,isMobile:y2,mockIsMobile:_7},Symbol.toStringTag,{value:"Module"}));const As=ie();As.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});As.registerFlag("IS_BROWSER",()=>b2());As.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");As.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));As.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));As.registerFlag("PROD",()=>!1);As.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>As.getBool("DEBUG"));As.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);As.registerFlag("IS_TEST",()=>!1);As.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>As.getBool("DEBUG"));As.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);As.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);As.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ga(n,e){let t=n;if(kn(n))return e==="string"?[]:[n.length];if(TM(n)){const r=n.channels||"RGBA";return[n.height,n.width*r.length]}else if(CM(n))return[n.buffer.size/(e==null?4:Yf(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||kn(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&$M(n,s,[]),s}function $M(n,e,t){if(t=t||[],!Array.isArray(n)&&!kn(n)){O(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}O(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),O(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)$M(n[r],s,t.concat(r))}function pO(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function M(n,e,t,s="numeric"){if(n instanceof fe())return pO(s,n.dtype,e,t),n;let r=hu(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),pO(s,r,e,t),n==null||!kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const a=Ga(n,r);!kn(n)&&!Array.isArray(n)&&(n=[n]);const o=r!=="string"?Bo(n,r):Wa(n,[],!0);return W.makeTensor(o,a,r)}function sp(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,i)=>M(a,`${e}[${i}]`,t,s))}const x2="__op";function G(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+x2;const r=(...a)=>{W.startScope(t);try{const i=s(...a);return Ni(i)&&console.error("Cannot return a Promise inside of tidy."),W.endScope(i),i}catch(i){throw W.endScope(null),i}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}function R7(n,e){const t=M(n,"real","complex"),s=M(e,"imag","complex");Jn(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return W.runKernel(Sb,r)}const $i=G({complex_:R7});function Vo(n,e,t,s){if(s==null)s=hu(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(CM(n)||TM(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return W.backend.createTensorFromGPUData(n,e||t,s)}if(!kn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){tr(e);const r=he(e),a=he(t);O(r===a,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${a}`);for(let i=0;i<t.length;++i){const o=t[i],l=i===t.length-1?o!==he(e.slice(i)):!0;O(t[i]===e[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!kn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Bo(n,s):Wa(n,[],!0),W.makeTensor(n,e,s)}function Xs(n,e,t){const s=Ga(n,t);return Vo(n,e,s,t)}const ql={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Sa{static join(e){return new Sa(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>kn(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=t-e,a=new ArrayBuffer(r),i=new Uint8Array(a);let o=0;for(let l=s;l<this.shards.length;l++){const h=this.shards[l],f=e+o-h.start,m=o,b=Math.min(t,h.end)-h.start,x=new Uint8Array(h.buffer,f,b-f);if(i.set(x,m),o+=x.length,t<h.end)break}return a}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(r){return e<r.start?-1:e>=r.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=D7(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function D7(n,e){let t=0,s=n.length;for(;t<=s;){const r=Math.floor((s-t)/2)+t,a=e(n[r]);if(a===0)return r;a<0?s=r:t=r+1}return-1}function O7(){ie().set("PROD",!0)}function F7(){ie().set("DEBUG",!0)}function L7(){ie().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function M7(n){ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function z7(){W.disposeVariables()}function ua(){return W}function OT(){return W.memory()}function P7(n){return W.profile(n)}function re(n,e){return W.tidy(n,e)}function Je(n){Ei(n).forEach(t=>t.dispose())}function En(n){return W.keep(n)}function B7(n){return W.time(n)}function V7(n){return W.setBackend(n)}function U7(){return W.ready()}function IM(){return W.backendName}function j7(n){W.removeBackend(n)}function W7(n){return W.findBackend(n)}function G7(n){return W.findBackendFactory(n)}function w2(n,e,t=1){return W.registerBackend(n,e,t)}function v2(){return W.backend}function H7(n,e){ie().setPlatform(n,e)}const _o=4;async function FT(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<r.length;++i){const o=r[i],l=Array.isArray(n)?n[i].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const h={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const d=new Promise(async f=>{const m=await l.bytes(),y=m.reduce((w,v)=>w+v.length,0)+_o*m.length,b=new Uint8Array(y);let x=0;for(let w=0;w<m.length;w++){const v=m[w],C=new Uint8Array(new Uint32Array([v.length]).buffer);b.set(C,x),x+=_o,b.set(v,x),x+=v.length}f(b)});s.push(d)}else s.push(l.data());e!=null&&(h.group=e),t.push(h)}const a=await Promise.all(s);return{data:X7(a),specs:t}}function S2(n,e){const t=new Sa(n),s={};let r=0;for(const a of e){const i=q7(a,(o,l)=>t.slice(r+o,r+l));s[a.name]=_M(a,t.slice(r,r+i)),r+=i}return s}function q7(n,e){const t=he(n.shape);let s;if("quantization"in n){const r=n.quantization;s=ql[r.dtype]}else if(n.dtype==="string"){let r=0;for(let a=0;a<t;a++)r+=_o+new Uint32Array(e(r,r+_o))[0];return r}else s=ql[n.dtype];return t*s}async function K7(n,e){const t=he(n.shape);let s;if("quantization"in n){const r=n.quantization;s=ql[r.dtype]}else if(n.dtype==="string"){let r=0;for(let a=0;a<t;a++)r+=_o+new Uint32Array(await e(r,r+_o))[0];return r}else s=ql[n.dtype];return t*s}function _M(n,e){const t=n.name,s=n.dtype,r=n.shape,a=he(r);let i,o=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const h=ql[l.dtype],d=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(d.length);for(let f=0;f<d.length;f++){const m=d[f];i[f]=m*l.scale+l.min}}else if(l.dtype==="float16")i=tY()(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(s==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(d.length);for(let f=0;f<d.length;f++){const m=d[f];i[f]=Math.round(m*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=a*h}else if(s==="string"){const l=he(n.shape);i=[];for(let h=0;h<l;h++){const d=new Uint32Array(e.slice(o,o+_o))[0];o+=_o;const f=new Uint8Array(e.slice(o,o+d));i.push(f),o+=d}}else{const l=ql[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const h=new Float32Array(i.length/2),d=new Float32Array(i.length/2);for(let b=0;b<h.length;b++)h[b]=i[b*2],d[b]=i[b*2+1];const f=Xs(h,r,"float32"),m=Xs(d,r,"float32"),y=$i(f,m);return f.dispose(),m.dispose(),y}else throw new Error(`Unsupported dtype in weight '${t}': ${s}`);o+=a*l}return Xs(i,r,s)}async function mO(n,e,t){let s=new Uint8Array(e);for(;s.byteLength<t;){const{done:r,value:a}=await n.read();if(r&&a==null){const o=t-s.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}const i=new Uint8Array(s.length+a.byteLength);i.set(s,0),i.set(new Uint8Array(a),s.length),s=i}return s.buffer}async function AM(n,e){const t={},s=n.getReader();let r=new ArrayBuffer(0);for(const a of e){const i=await K7(a,async(h,d)=>(r=await mO(s,r,d),r.slice(h,d)));r=await mO(s,r,i);const o=r.slice(0,i);r=r.slice(i);const l=_M(a,o);if(t[a.name]=l,IM()==="webgpu"){const h=v2();"uploadToGPU"in h&&he(l.shape)>=ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&h.uploadToGPU(l.dataId)}}return t}function X7(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}const T2=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function gO(n){return T2?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Y7(n){if(T2)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function J7(n){if(T2){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function RM(n){return Sa.join(n)}function yO(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function DM(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function C2(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function N2(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),C2(n,t,s)}function Nm(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:gO(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:gO(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Sa(n.weightData).byteLength}}function D0(n){const e=[];for(const t of n)e.push(...t.weights);return e}function Z7(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Q7(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function eY(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function tY(){const n=Z7(),e=Q7(),t=eY();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let i=0;i<s.length;i++){const o=s[i],l=n[t[o>>10]+(o&1023)]+e[o>>10];a[i]=l}return new Float32Array(r)}}class qt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return qt.instance==null&&(qt.instance=new qt),qt.instance}static registerSaveRouter(e){qt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){qt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return qt.getHandlers(e,"save")}static getLoadHandlers(e,t){return qt.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?qt.getInstance().loadRouters:qt.getInstance().saveRouters).forEach(i=>{const o=i(e,s);o!==null&&r.push(o)}),r}}const nY=n=>qt.registerSaveRouter(n),sY=n=>qt.registerLoadRouter(n),OM=n=>qt.getSaveHandlers(n),FM=(n,e)=>qt.getLoadHandlers(n,e);const LT="tensorflowjs",MT=1,Ll="models_store",bo="model_info_store";function LM(){if(!ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function zT(n){const e=n.result;e.createObjectStore(Ll,{keyPath:"modelPath"}),e.createObjectStore(bo,{keyPath:"modelPath"})}class Kl{constructor(e){if(this.indexedDB=LM(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const a=this.indexedDB.open(LT,MT);a.onupgradeneeded=()=>zT(a),a.onsuccess=()=>{const i=a.result;if(t==null){const o=i.transaction(Ll,"readonly"),h=o.objectStore(Ll).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(h.result.modelArtifacts)},h.onerror=d=>(i.close(),r(h.error)),o.oncomplete=()=>i.close()}else{t.weightData=Sa.join(t.weightData);const o=Nm(t),l=i.transaction(bo,"readwrite");let h=l.objectStore(bo),d;try{d=h.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(m){return r(m)}let f;d.onsuccess=()=>{f=i.transaction(Ll,"readwrite");const m=f.objectStore(Ll);let y;try{y=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(b){return r(b)}y.onsuccess=()=>s({modelArtifactsInfo:o}),y.onerror=b=>{h=l.objectStore(bo);const x=h.delete(this.modelPath);x.onsuccess=()=>(i.close(),r(y.error)),x.onerror=w=>(i.close(),r(y.error))}},d.onerror=m=>(i.close(),r(d.error)),l.oncomplete=()=>{f==null?i.close():f.oncomplete=()=>i.close()}}},a.onerror=i=>r(a.error)})}}Kl.URL_SCHEME="indexeddb://";const MM=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Kl.URL_SCHEME)?rY(n.slice(Kl.URL_SCHEME.length)):null;qt.registerSaveRouter(MM);qt.registerLoadRouter(MM);function rY(n){return new Kl(n)}function aY(n){return n.startsWith(Kl.URL_SCHEME)?n.slice(Kl.URL_SCHEME.length):n}class iY{constructor(){this.indexedDB=LM()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(LT,MT);s.onupgradeneeded=()=>zT(s),s.onsuccess=()=>{const r=s.result,a=r.transaction(bo,"readonly"),o=a.objectStore(bo).getAll();o.onsuccess=()=>{const l={};for(const h of o.result)l[h.modelPath]=h.modelArtifactsInfo;e(l)},o.onerror=l=>(r.close(),t(o.error)),a.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=aY(e),new Promise((t,s)=>{const r=this.indexedDB.open(LT,MT);r.onupgradeneeded=()=>zT(r),r.onsuccess=()=>{const a=r.result,i=a.transaction(bo,"readwrite"),o=i.objectStore(bo),l=o.get(e);let h;l.onsuccess=()=>{if(l.result==null)return a.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=o.delete(e),f=()=>{h=a.transaction(Ll,"readwrite");const y=h.objectStore(Ll).delete(e);y.onsuccess=()=>t(l.result.modelArtifactsInfo),y.onerror=b=>s(l.error)};d.onsuccess=f,d.onerror=m=>(f(),a.close(),s(l.error))}},l.onerror=d=>(a.close(),s(l.error)),i.oncomplete=()=>{h==null?a.close():h.oncomplete=()=>a.close()}},r.onerror=a=>s(r.error)})}}const vi="/",Tc="tensorflowjs_models",zM="info",oY="model_topology",lY="weight_specs",uY="weight_data",cY="model_metadata";function PM(n){return{info:[Tc,n,zM].join(vi),topology:[Tc,n,oY].join(vi),weightSpecs:[Tc,n,lY].join(vi),weightData:[Tc,n,uY].join(vi),modelMetadata:[Tc,n,cY].join(vi)}}function BM(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function hY(n){const e=n.split(vi);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(vi)}function dY(n){return n.startsWith(Xl.URL_SCHEME)?n.slice(Xl.URL_SCHEME.length):n}class Xl{constructor(e){if(!ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=PM(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Nm(e),a=Sa.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Y7(a));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw BM(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=J7(i),t}}Xl.URL_SCHEME="localstorage://";const VM=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xl.URL_SCHEME)?fY(n.slice(Xl.URL_SCHEME.length)):null;qt.registerSaveRouter(VM);qt.registerLoadRouter(VM);function fY(n){return new Xl(n)}class pY{constructor(){O(ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),O(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Tc+vi,s=vi+zM;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(s)){const i=hY(a);e[i]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=dY(e);const t=PM(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return BM(t),s}}const Rc="://";class fs{constructor(){this.managers={}}static getInstance(){return fs.instance==null&&(fs.instance=new fs),fs.instance}static registerManager(e,t){O(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Rc)&&(e=e.slice(0,e.indexOf(Rc))),O(e.length>0,()=>"scheme must not be an empty string.");const s=fs.getInstance();O(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=fs.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(fs.getInstance().managers)}}function Qy(n){if(n.indexOf(Rc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fs.getSchemes().join(",")}`);return{scheme:n.split(Rc)[0],path:n.split(Rc)[1]}}async function UM(n,e,t=!1){O(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=qt.getLoadHandlers(n);O(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),O(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],a=qt.getSaveHandlers(e);O(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),O(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=a[0],o=Qy(n).scheme,l=Qy(n).path,h=o===Qy(n).scheme,d=await r.load();t&&h&&await fs.getManager(o).removeModel(l);const f=await i.save(d);return t&&!h&&await fs.getManager(o).removeModel(l),f.modelArtifactsInfo}async function mY(){const n=fs.getSchemes(),e={};for(const t of n){const s=await fs.getManager(t).listModels();for(const r in s){const a=t+Rc+r;e[a]=s[r]}}return e}async function gY(n){const e=Qy(n);return fs.getManager(e.scheme).removeModel(e.path)}async function yY(n,e){return UM(n,e,!1)}async function bY(n,e){return UM(n,e,!0)}class xY{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return mM(e)}}if(ie().get("IS_BROWSER")){ie().setPlatform("browser",new xY);try{fs.registerManager(Xl.URL_SCHEME,new pY)}catch{}try{fs.registerManager(Kl.URL_SCHEME,new iY)}catch{}}const wY={importFetch:()=>require("node-fetch")};let AS;class vY{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ie().global.fetch!=null?ie().global.fetch(e,t):(AS==null&&(AS=wY.importFetch()),AS(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ie().get("IS_NODE")&&!ie().get("IS_BROWSER")&&ie().setPlatform("node",new vY);function tt(n,e="float32",t){return e=e||"float32",tr(n),new bn(n,e,t)}function SY(n,e){const t=M(n,"x","cast");if(!aM(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return W.runKernel(oh,s,r)}const Ne=G({cast_:SY});function TY(n){const t={x:M(n,"x","clone","string_or_numeric")};return W.runKernel(wh,t)}const Ba=G({clone_:TY});function k2(n,e=!1){console.log(n.toString(e))}EM();const CY={buffer:tt,cast:Ne,clone:Ba,print:k2};T7(CY);function NY(n,e){let t=M(n,"a","add"),s=M(e,"b","add");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(fu,r)}const we=G({add_:NY});function kY(n,e){let t=M(n,"a","floorDiv"),s=M(e,"b","floorDiv");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(bh,r)}const Cx=G({floorDiv_:kY});function EY(n,e){let t=M(n,"a","div"),s=M(e,"b","div");if([t,s]=Jt(t,s),t.dtype==="int32"&&s.dtype==="int32")return Cx(t,s);const r={a:t,b:s},a={};return W.runKernel(dh,r,a)}const Fe=G({div_:EY});function $Y(n,e){let t=M(n,"a","mul"),s=M(e,"b","mul");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(Ih,r)}const Y=G({mul_:$Y});function IY(n){const e=M(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return W.runKernel(_p,t)}else{const t={x:e};return W.runKernel(vp,t)}}const mn=G({abs_:IY});function _Y(n){const t={x:M(n,"x","acos")};return W.runKernel(eh,t)}const E2=G({acos_:_Y});function AY(n){const t={x:M(n,"x","acosh")};return W.runKernel(th,t)}const $2=G({acosh_:AY});function RY(n){O(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),O(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,a)=>M(r,`tensors${a}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!lt(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return W.runKernel(Sp,s)}const jM=G({addN_:RY});function DY(n,e=null,t=!1){const r={x:M(n,"x","all","bool")},a={axis:e,keepDims:t};return W.runKernel(gb,r,a)}const Nx=G({all_:DY});function OY(n,e=null,t=!1){const r={x:M(n,"x","any","bool")},a={axis:e,keepDims:t};return W.runKernel(yb,r,a)}const rp=G({any_:OY});function FY(n,e=0){const s={x:M(n,"x","argMax")},r={axis:e};return W.runKernel(Tp,s,r)}const Yl=G({argMax_:FY});function LY(n,e=0){const s={x:M(n,"x","argMin")},r={axis:e};return W.runKernel(Cp,s,r)}const I2=G({argMin_:LY});function MY(n){const t={x:M(n,"x","asin")};return W.runKernel(nh,t)}const _2=G({asin_:MY});function zY(n){const t={x:M(n,"x","asinh")};return W.runKernel(sh,t)}const A2=G({asinh_:zY});function PY(n){const t={x:M(n,"x","atan")};return W.runKernel(rh,t)}const R2=G({atan_:PY});function BY(n,e){let t=M(n,"a","atan2"),s=M(e,"b","atan2");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(ih,r)}const D2=G({atan2_:BY});function VY(n){const t={x:M(n,"x","atanh")};return W.runKernel(ah,t)}const O2=G({atanh_:VY});function km(n,e,t,s,r="NHWC",a){const i=n[3],o=[...e,i],l=Li(r);return Vn(n,o,t,a,s,null,null,l)}function Kr(n,e,t,s,r,a,i="channelsLast"){const[o,l]=ap(e);let h;if(i==="channelsLast")h=[o,l,n[3],n[3]];else if(i==="channelsFirst")h=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Vn(n,h,t,s,r,a,!1,i)}function Fi(n,e,t,s,r,a,i="NDHWC"){const[o,l,h]=PT(e);let d,f;if(i==="NDHWC")f="channelsLast",d=[o,l,h,n[4],n[4]];else if(i==="NCDHW")f="channelsFirst",d=[o,l,h,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Uo(n,d,t,s,r,!1,f,a)}function Vn(n,e,t,s,r,a,i=!1,o="channelsLast"){let[l,h,d,f]=[-1,-1,-1,-1];if(o==="channelsLast")[l,h,d,f]=n;else if(o==="channelsFirst")[l,f,h,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,y,,b]=e,[x,w]=ap(t),[v,C]=ap(s),N=Dc(m,v),k=Dc(y,C),{padInfo:E,outHeight:_,outWidth:R}=WY(r,h,d,x,w,N,k,a,o),D=i?b*f:b;let F;return o==="channelsFirst"?F=[l,D,_,R]:o==="channelsLast"&&(F=[l,_,R,D]),{batchSize:l,dataFormat:o,inHeight:h,inWidth:d,inChannels:f,outHeight:_,outWidth:R,outChannels:D,padInfo:E,strideHeight:x,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:N,effectiveFilterWidth:k,dilationHeight:v,dilationWidth:C,inShape:n,outShape:F,filterShape:e}}function Uo(n,e,t,s,r,a=!1,i="channelsLast",o){let[l,h,d,f,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,h,d,f,m]=n;else if(i==="channelsFirst")[l,m,h,d,f]=n;else throw new Error(`Unknown dataFormat ${i}`);const[y,b,x,,w]=e,[v,C,N]=PT(t),[k,E,_]=PT(s),R=Dc(y,k),D=Dc(b,E),F=Dc(x,_),{padInfo:L,outDepth:A,outHeight:V,outWidth:q}=GY(r,h,d,f,v,C,N,R,D,F,o),ne=a?w*m:w;let Q;return i==="channelsFirst"?Q=[l,ne,A,V,q]:i==="channelsLast"&&(Q=[l,A,V,q,ne]),{batchSize:l,dataFormat:i,inDepth:h,inHeight:d,inWidth:f,inChannels:m,outDepth:A,outHeight:V,outWidth:q,outChannels:ne,padInfo:L,strideDepth:v,strideHeight:C,strideWidth:N,filterDepth:y,filterHeight:b,filterWidth:x,effectiveFilterDepth:R,effectiveFilterHeight:D,effectiveFilterWidth:F,dilationDepth:k,dilationHeight:E,dilationWidth:_,inShape:n,outShape:Q,filterShape:e}}function UY(n,e,t,s,r){s==null&&(s=F2(n,e,t));const a=n[0],i=n[1],o=ip((a-e+2*s)/t+1,r),l=ip((i-e+2*s)/t+1,r);return[o,l]}function jY(n,e,t,s,r,a){r==null&&(r=F2(n,e[0],s[0]));const i=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*r>=e[o]&&(i[o]=ip((n[o]-e[o]+2*r)/s[o]+1,a));return i}function F2(n,e,t,s=1){const r=Dc(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function ap(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function PT(n){return typeof n=="number"?[n,n,n]:n}function Dc(n,e){return e<=1?n:n+(n-1)*(e-1)}function WY(n,e,t,s,r,a,i,o,l){let h,d,f;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const y=UY([e,t],a,s,n,o);d=y[0],f=y[1]}else if(n==="same"){d=Math.ceil(e/s),f=Math.ceil(t/r);const m=Math.max(0,(d-1)*s+a-e),y=Math.max(0,(f-1)*r+i-t),b=Math.floor(m/2),x=m-b,w=Math.floor(y/2),v=y-w;h={top:b,bottom:x,left:w,right:v,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-a+1)/s),f=Math.ceil((t-i+1)/r);else if(typeof n=="object"){const m=l==="channelsLast"?n[1][0]:n[2][0],y=l==="channelsLast"?n[1][1]:n[2][1],b=l==="channelsLast"?n[2][0]:n[3][0],x=l==="channelsLast"?n[2][1]:n[3][1];h={top:m,bottom:y,left:b,right:x,type:m===0&&y===0&&b===0&&x===0?"VALID":"EXPLICIT"},d=ip((e-a+m+y)/s+1,o),f=ip((t-i+b+x)/r+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outHeight:d,outWidth:f}}function GY(n,e,t,s,r,a,i,o,l,h,d){let f,m,y,b;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const w=jY([e,t,s,1],[o,l,h],1,[r,a,i],n,d);m=w[0],y=w[1],b=w[2]}else if(n==="same"){m=Math.ceil(e/r),y=Math.ceil(t/a),b=Math.ceil(s/i);const x=(m-1)*r+o-e,w=(y-1)*a+l-t,v=(b-1)*i+h-s,C=Math.floor(x/2),N=x-C,k=Math.floor(w/2),E=w-k,_=Math.floor(v/2),R=v-_;f={top:k,bottom:E,left:_,right:R,front:C,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:m,outHeight:y,outWidth:b}}function ip(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ao(n){const[e,t,s]=ap(n);return e===1&&t===1&&s===1}function Zn(n,e){return Ao(n)||Ao(e)}function Jl(n){return ap(n).every(e=>e>0)}function Li(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ws(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")O(Hl(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{O(Hl(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function HY(n,e){const s={x:M(n,"x","reshape","string_or_numeric")},r={shape:e};return W.runKernel(cm,s,r)}const J=G({reshape_:HY});function qY(n,e,t,s,r){const a=M(n,"x","avgPool","float32"),i=1;O(Zn(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=J(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ws("avgPool",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let f=W.runKernel(Np,h,d);return f=Ne(f,a.dtype),l?J(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Em=G({avgPool_:qY});function KY(n,e,t,s,r,a="NDHWC"){const i=M(n,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=J(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),O(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),O(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ws("avgPool3d",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:a};let f=W.runKernel(kp,h,d);return f=Ne(f,o.dtype),l?J(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const L2=G({avgPool3d_:KY});function XY(n,e=0){O(n.length>=1,()=>"Pass at least one tensor to concat");const t=sp(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return Ba(t[0]);const s=t,r={axis:e};return W.runKernel(Ap,s,r)}const ln=G({concat_:XY});function YY(n,e,t=!1,s=!1){let r=M(n,"a","matMul"),a=M(e,"b","matMul");[r,a]=Jt(r,a);const i={a:r,b:a},o={transposeA:t,transposeB:s};return W.runKernel(Ep,i,o)}const rt=G({matMul_:YY});function JY(n){const t={x:M(n,"x","sigmoid","float32")};return W.runKernel(Bh,t)}const pa=G({sigmoid_:JY});function ZY(n,e,t){const s=M(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},a={begin:e,size:t};return W.runKernel(mm,r,a)}const dt=G({slice_:ZY});function QY(n){const t={x:M(n,"x","tanh","float32")};return W.runKernel(Hh,t)}const Ro=G({tanh_:QY});function eJ(n,e,t,s,r,a){const i=M(n,"forgetBias","basicLSTMCell"),o=M(e,"lstmKernel","basicLSTMCell"),l=M(t,"lstmBias","basicLSTMCell"),h=M(s,"data","basicLSTMCell"),d=M(r,"c","basicLSTMCell"),f=M(a,"h","basicLSTMCell"),m=ln([h,f],1),y=rt(m,o),b=we(y,l),x=b.shape[0],w=b.shape[1]/4,v=[x,w],C=dt(b,[0,0],v),N=dt(b,[0,w],v),k=dt(b,[0,w*2],v),E=dt(b,[0,w*3],v),_=we(Y(pa(C),Ro(N)),Y(d,pa(we(i,k)))),R=Y(Ro(_),pa(E));return[_,R]}const WM=G({basicLSTMCell_:eJ});function tJ(n,e,t){const s=M(n,"x","batchToSpaceND"),r=e.reduce((o,l)=>o*l);O(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),O(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),O(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const a={x:s},i={blockShape:e,crops:t};return W.runKernel($p,a,i)}const $m=G({batchToSpaceND_:tJ});function nJ(n){let e;return n.rank===0||n.rank===1?e=J(n,[1,1,1,n.size]):n.rank===2?e=J(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function sJ(n,e,t,s,r,a){a==null&&(a=.001);const i=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;s!=null&&(d=M(s,"offset","batchNorm")),O(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(h==null||o.rank===h.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:nJ(i),scale:h,offset:d,mean:o,variance:l},y={varianceEpsilon:a},b=W.runKernel(Bp,m,y);return J(b,i.shape)}const Xh=G({batchNorm_:sJ});function rJ(n,e,t,s,r,a){const i=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),O(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),O(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),O(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),h!=null&&O(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&O(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),Xh(i,o,l,d,h,a)}const M2=G({batchNorm2d_:rJ});function aJ(n,e,t,s,r,a){const i=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),O(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),O(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),O(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),h!=null&&O(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&O(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),Xh(i,o,l,d,h,a)}const z2=G({batchNorm3d_:aJ});function iJ(n,e,t,s,r,a){const i=M(n,"x","batchNorm"),o=M(e,"mean","batchNorm"),l=M(t,"variance","batchNorm");let h;r!=null&&(h=M(r,"scale","batchNorm"));let d;return s!=null&&(d=M(s,"offset","batchNorm")),O(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),O(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),O(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),h!=null&&O(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&O(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),Xh(i,o,l,d,h,a)}const P2=G({batchNorm4d_:iJ});function oJ(n,e,t){const s=M(n,"x","bincount"),r=M(e,"weights","bincount");O(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const a={x:s,weights:r},i={size:t};return W.runKernel(wb,a,i)}const B2=G({bincount_:oJ});function lJ(n,e){const t=M(n,"x","bitwiseAnd"),s=M(e,"y","bitwiseAnd");if(!lt(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return W.runKernel(Ip,r)}const GM=G({bitwiseAnd_:lJ});function uJ(n,e){const t=M(n,"s0","broadcastArgs","int32"),s=M(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return W.runKernel(vb,r)}const HM=G({broadcastArgs_:uJ});function cJ(n,e){let t=M(n,"broadcastTo","x");const s=t.shape;if(tr(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=J(t,h)}const r=t.shape,a=Array.from(e);for(let h=e.length-1;h>=0;h--)if(r[h]===e[h])a[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(a.map((h,d)=>h>1?d:-1).filter(h=>h>=0).length===0)return Ba(t);const o={x:t},l={reps:a};return W.runKernel(qh,o,l)}const jl=G({broadcastTo_:cJ});function hJ(n){const t={x:M(n,"x","ceil","float32")};return W.runKernel(lh,t)}const V2=G({ceil_:hJ});function pu(n,e,t){tr(n),t=t||hu(e);const s={shape:n,value:e,dtype:t};return W.runKernel(Mb,{},s)}function dJ(n,e,t){const s=M(n,"x","clipByValue");if(O(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return pu(s.shape,e,s.dtype);const r={x:s},a={clipValueMin:e,clipValueMax:t};return W.runKernel(uh,r,a)}const Rs=G({clipByValue_:dJ});function fJ(n){return ln(n,0)}const U2=G({concat1d_:fJ});function pJ(n,e){return ln(n,e)}const j2=G({concat2d_:pJ});function mJ(n,e){return ln(n,e)}const W2=G({concat3d_:mJ});function gJ(n,e){return ln(n,e)}const G2=G({concat4d_:gJ});function yJ(n,e,t,s,r="NHWC",a=[1,1],i){const o=M(n,"x","conv2d","float32"),l=M(e,"filter","conv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=J(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(h.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${h.rank}.`),O(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ws("conv2d",s,i);const f=r==="NHWC"?h.shape[3]:h.shape[1];O(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`),O(Zn(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),O(Jl(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),O(Jl(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:h,filter:l},y={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i},b=W.runKernel(Rp,m,y);return d?J(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Ii=G({conv2d_:yJ});function bJ(n,e,t,s,r="NWC",a=1,i){const o=M(n,"x","conv1d"),l=M(e,"filter","conv1d");let h=o,d=!1;o.rank===2&&(d=!0,h=J(o,[1,o.shape[0],o.shape[1]])),O(h.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${h.rank}.`),O(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ws("conv1d",s,i),O(h.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${h.shape[2]}) must match input depth for filter ${l.shape[1]}.`),O(Zn(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),O(Jl(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),O(Jl(t),()=>"Error in conv1D: Stride should be larger than 0."),O(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=J(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=J(h,[h.shape[0],1,h.shape[1],h.shape[2]]),w=Ii(m,f,[1,t],s,"NHWC",[1,a],i);return d?J(w,[w.shape[2],w.shape[3]]):J(w,[w.shape[0],w.shape[2],w.shape[3]])}const kx=G({conv1d_:bJ});function xJ(n,e,t,s,r,a="NHWC",i){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,l=e,h=!1;e.rank===3&&(h=!0,l=J(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),O(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),O(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),O(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=a==="NHWC"?o[3]:o[1],f=a==="NHWC"?l.shape[3]:l.shape[1];O(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),O(f===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${t.shape[3]}.`),ws("conv2dDerInput",r,i);const m={dy:l,filter:t},y={strides:s,pad:r,dataFormat:a,dimRoundingMode:i,inputShape:o},b=W.runKernel(Dp,m,y);return h?J(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const H2=G({conv2DBackpropInput_:xJ});function wJ(n,e,t,s,r,a){const i=M(n,"x","conv2dTranspose"),o=M(e,"filter","conv2dTranspose");return H2(t,i,o,s,r,"NHWC",a)}const Ex=G({conv2dTranspose_:wJ});function vJ(n,e,t,s,r="NDHWC",a=[1,1,1]){const i=M(n,"x","conv3d"),o=M(e,"filter","conv3d");let l=i,h=!1;i.rank===4&&(h=!0,l=J(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),O(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),O(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),O(Zn(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),O(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),O(Jl(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),O(Jl(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:l,filter:o},f={strides:t,pad:s,dataFormat:r,dilations:a},m=W.runKernel(Op,d,f);return h?J(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const q2=G({conv3d_:vJ});function SJ(n,e,t,s,r){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,i=e,o=!1;e.rank===4&&(o=!0,i=J(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const l=a[4],h=i.shape[4];O(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),O(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),O(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),O(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),O(h===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[4]}.`);const d={dy:i,filter:t},f={pad:r,strides:s,inputShape:a},m=W.runKernel(Nb,d,f);return o?J(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const qM=G({conv3DBackpropInput_:SJ});function TJ(n,e,t,s,r){const a=M(n,"x","conv3dTranspose"),i=M(e,"filter","conv3dTranspose");return qM(t,a,i,s,r)}const K2=G({conv3dTranspose_:TJ});function CJ(n){const t={x:M(n,"x","cos","float32")};return W.runKernel(ch,t)}const Im=G({cos_:CJ});function NJ(n){const t={x:M(n,"x","cosh","float32")};return W.runKernel(hh,t)}const $x=G({cosh_:NJ});function kJ(n,e=0,t=!1,s=!1){const a={x:M(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:s};return W.runKernel(kb,a,i)}const op=G({cumprod_:kJ});function EJ(n,e=0,t=!1,s=!1){const a={x:M(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:s};return W.runKernel(Fp,a,i)}const Ix=G({cumsum_:EJ});function $J(n,e,t,s=!1){const r=M(n,"x","denseBincount"),a=M(e,"weights","denseBincount");O(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),O(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const i={x:r,weights:a},o={size:t,binaryOutput:s};return W.runKernel($b,i,o)}const O0=G({denseBincount_:$J});function IJ(n,e,t="NHWC"){const s=M(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],a=t==="NHWC"?s.shape[2]:s.shape[3],i=t==="NHWC"?s.shape[3]:s.shape[1];O(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),O(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),O(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${s.shape}`),O(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:e,dataFormat:t};return W.runKernel(Ib,o,l)}const X2=G({depthToSpace_:IJ});function _J(n,e,t,s,r="NHWC",a=[1,1],i){const o=M(n,"x","depthwiseConv2d","float32"),l=M(e,"filter","depthwiseConv2d","float32");let h=o,d=!1;o.rank===3&&(d=!0,h=J(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(h.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),O(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=r==="NHWC"?h.shape[3]:h.shape[1];O(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`),ws("depthwiseConv2d",s,i);const m={x:h,filter:l},y={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i},b=W.runKernel(Lp,m,y);return d?J(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Yh=G({depthwiseConv2d_:_J});function AJ(n){const t={x:M(n,"x","diag")};return W.runKernel(Rb,t)}const KM=G({diag_:AJ});function RJ(n,e,t,s,r=[1,1],a="NHWC"){const i=M(n,"x","dilation2d"),o=M(e,"filter","dilation2d");O(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),O(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),O(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,h=!1;i.rank===3&&(l=J(i,[1,i.shape[0],i.shape[1],i.shape[2]]),h=!0),O(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const d={x:l,filter:o},f={strides:t,pad:s,dilations:r},m=W.runKernel(Mp,d,f);return h?J(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Y2=G({dilation2d_:RJ});function Zl(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const a=t-1-r,i=n[a]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(a)}return s}function xn(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],a=e.length-s-1,i=e[a];(r==null||r===1&&i>1)&&t.unshift(a)}return t}function Ze(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let r=0;r<t;r++){let a=n[n.length-r-1];a==null&&(a=1);let i=e[e.length-r-1];if(i==null&&(i=1),a===1)s[t-r-1]=i;else if(i===1)s[t-r-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else s[t-r-1]=a}return s}const DJ=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Ze,getBroadcastDims:Zl,getReductionAxes:xn},Symbol.toStringTag,{value:"Module"}));function OJ(n,e){let t=M(n,"a","equal","string_or_numeric"),s=M(e,"b","equal","string_or_numeric");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(zp,r)}const Ys=G({equal_:OJ});function FJ(n,e,t){const s=M(e,"a","where"),r=M(t,"b","where"),a=M(n,"condition","where","bool"),i=Ze(Ze(a.shape,s.shape),r.shape),o=jl(a,i),l=jl(s,i),h=jl(r,i),d={condition:o,t:l,e:h};return W.runKernel(pm,d)}const Mn=G({where_:FJ});function LJ(n){const t={x:M(n,"x","zerosLike")};return W.runKernel(Tm,t)}const ft=G({zerosLike_:LJ});function MJ(n,e){let t=M(n,"a","div"),s=M(e,"b","div");[t,s]=Jt(t,s);const r=Fe(t,s),a=ft(r),i=Ys(s,a);return Mn(i,a,r)}const J2=G({divNoNan_:MJ});function zJ(n,e){const t=M(n,"t1","dot"),s=M(e,"t2","dot");O((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],a=s.rank===1?s.size:s.shape[0];if(O(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),t.rank===1&&s.rank===1){const i=J(t,[1,-1]),o=J(s,[-1,1]),l=rt(i,o);return J(l,[])}else if(t.rank===1&&s.rank===2){const i=J(t,[1,-1]),o=J(s,[s.shape[0],s.shape[1]]),l=rt(i,o);return J(l,[l.size])}else if(t.rank===2&&s.rank===1){const i=J(s,[-1,1]),o=rt(t,i);return J(o,[o.size])}else{const i=J(s,[s.shape[0],s.shape[1]]);return rt(t,i)}}const Z2=G({dot_:zJ});function PJ(n,...e){const t=e.map((r,a)=>M(r,`tensors${a}`,"einsum")),s={equation:n};return W.runKernel(Ob,t,s)}const Il=G({einsum_:PJ});function BJ(n){const t={x:M(n,"x","elu","float32")};return W.runKernel(fh,t)}const Jh=G({elu_:BJ});function VJ(n,e){const t=M(n,"x","ensureShape","string_or_numeric");if(!sM(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const XM=G({ensureShape_:VJ});function UJ(n){let e=M(n,"x","erf");O(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ne(e,"float32"));const t={x:e};return W.runKernel(ph,t)}const _x=G({erf_:UJ});function Q2(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function YM(n,e,t){const s=n.length+e.length,r=[];let a=0,i=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?r.push(n[a++]):r.push(e[i++]);return r}function Un(n,e){const t=[],s=n.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&t.push(n[a]);const r=e.map(a=>n[a]);return[t,r]}function un(n,e){const t=e.map(s=>1);return YM(n,t,e)}function Qn(n,e,t){O(Q2(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Zt(n,e){if(Q2(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function jo(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function cn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}function jJ(n,e=null,t=!1){const r={x:M(n,"x","max")},a={reductionIndices:e,keepDims:t};return W.runKernel(Yp,r,a)}const Sr=G({max_:jJ});function WJ(n,e=null,t=!1){const r={x:M(n,"x","min")},a={axis:e,keepDims:t};return W.runKernel(em,r,a)}const Pc=G({min_:WJ});function GJ(n,e){let t=M(n,"base","pow"),s=M(e,"exp","pow");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(_h,r)}const Ha=G({pow_:GJ});function ze(n,e){if((kn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&kn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Vo(n,[],[],e)}function HJ(n){const t={x:M(n,"x","sqrt","float32")};return W.runKernel(Uh,t)}const Pn=G({sqrt_:HJ});function qJ(n){const e=M(n,"x","square"),t={};return W.runKernel("Square",{x:e},t)}const $t=G({square_:qJ});function KJ(n,e=null,t=!1){let s=M(n,"x","sum");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},a={axis:e,keepDims:t};return W.runKernel(gm,r,a)}const Re=G({sum_:KJ});function XJ(n,e="euclidean",t=null,s=!1){n=M(n,"x","norm");const r=JM(n,e,t);let a=r.shape;if(s){const i=at(t,n.shape);a=un(r.shape,i)}return J(r,a)}function JM(n,e,t=null){if(n.rank===0)return mn(n);if(n.rank!==1&&t===null)return JM(J(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Re(mn(n),t);if(e===1/0)return Sr(mn(n),t);if(e===-1/0)return Pc(mn(n),t);if(e==="euclidean"||e===2)return Pn(Re(Ha(mn(n),ze(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Sr(Re(mn(n),t[0]),t[1]-1);if(e===1/0)return Sr(Re(mn(n),t[1]),t[0]);if(e===-1/0)return Pc(Re(mn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Pn(Re($t(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Zh=G({norm_:XJ});function YJ(n,e=null,t=!1){return Zh(n,"euclidean",e,t)}const eN=G({euclideanNorm_:YJ});function JJ(n){const t={x:M(n,"x","exp")};return W.runKernel(mh,t)}const Ds=G({exp_:JJ});function ZJ(n,e=0){const t=M(n,"x","expandDims","string_or_numeric");O(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return W.runKernel(Pp,s,r)}const Hn=G({expandDims_:ZJ});function QJ(n){const t={x:M(n,"x","expm1")};return W.runKernel(gh,t)}const tN=G({expm1_:QJ});function eZ(n,e){const t=M(n,"x","tile","string_or_numeric");O(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return W.runKernel(qh,s,r)}const br=G({tile_:eZ});function tZ(n,e,t,s="float32"){e==null&&(e=n);const r=tt([n,e],s),a=n<=e?n:e;for(let o=0;o<a;++o)r.set(1,o,o);const i=J(r.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return br(Hn(i,0),[t[0],1,1]);if(t.length===2)return br(Hn(Hn(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return br(Hn(Hn(Hn(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Ax=G({eye_:tZ});function nZ(n){const t={x:M(n,"x","floor","float32")};return W.runKernel(yh,t)}const Qh=G({floor_:nZ});function sZ(n,e,t=0,s=0){const r=M(n,"x","gather"),a=M(e,"indices","gather","int32"),i={x:r,indices:a},o={axis:t,batchDims:s};return W.runKernel(Vp,i,o)}const ed=G({gather_:sZ});function rZ(n,e){let t=M(n,"a","greater","string_or_numeric"),s=M(e,"b","greater","string_or_numeric");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Up,r)}const vs=G({greater_:rZ});function aZ(n,e){let t=M(n,"a","greaterEqual","string_or_numeric"),s=M(e,"b","greaterEqual","string_or_numeric");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(xh,r)}const Mi=G({greaterEqual_:aZ});function iZ(n){const t={input:M(n,"input","imag")};return W.runKernel(Vb,t)}const _m=G({imag_:iZ});function oZ(n){const t={x:M(n,"x","isFinite")};return W.runKernel(vh,t)}const nN=G({isFinite_:oZ});function lZ(n){const t={x:M(n,"x","isInf")};return W.runKernel(Sh,t)}const sN=G({isInf_:lZ});function uZ(n){const t={x:M(n,"x","isNaN")};return W.runKernel(Th,t)}const rN=G({isNaN_:uZ});function cZ(n,e=.2){const s={x:M(n,"x","leakyRelu")},r={alpha:e};return W.runKernel(jp,s,r)}const Am=G({leakyRelu_:cZ});function hZ(n,e){let t=M(n,"a","less","string_or_numeric"),s=M(e,"b","less","string_or_numeric");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Wp,r)}const Bc=G({less_:hZ});function dZ(n,e){let t=M(n,"a","lessEqual","string_or_numeric"),s=M(e,"b","lessEqual","string_or_numeric");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Gp,r)}const Wo=G({lessEqual_:dZ});function ZM(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return W.runKernel(Ub,{},s)}function fZ(n,e=5,t=1,s=1,r=.5){const a=M(n,"x","localResponseNormalization");O(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),O(Hl(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=J(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},h={depthRadius:e,bias:t,alpha:s,beta:r},d=W.runKernel(Xp,l,h);return o?J(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const aN=G({localResponseNormalization_:fZ});function pZ(n){const t={x:M(n,"x","log","float32")};return W.runKernel(Ch,t)}const Js=G({log_:pZ});function mZ(n){const t={x:M(n,"x","log1p")};return W.runKernel(Nh,t)}const Rm=G({log1p_:mZ});function gZ(n){return O(Io(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=M(e,"x","tf.grad","string_or_numeric"),r=t!=null?M(t,"dy","tf.grad"):null;return W.tidy(()=>{const{value:a,grads:i}=W.gradients(()=>n(s),[s],r);return r!=null&&Jn(a.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Rx(i),i[0]})}}function yZ(n){return O(Io(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{O(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=sp(e,"args","tf.grads","string_or_numeric"),r=t!=null?M(t,"dy","tf.grads"):null;return W.tidy(()=>{const{value:a,grads:i}=W.gradients(()=>n(...s),s,r);return r!=null&&Jn(a.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Rx(i),i})}}function bZ(n){return O(Io(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{O(e instanceof bt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),O(t==null||t instanceof bt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=W.gradients(()=>n(e),[e],t);return Rx(s),{grad:s[0],value:r}}}function xZ(n){return O(Io(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{O(Array.isArray(e)&&e.every(r=>r instanceof bt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),O(t==null||t instanceof bt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=W.gradients(()=>n(...e),e,t);return t!=null&&Jn(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Rx(s.grads),s}}function QM(n,e){O(Io(n),()=>"The f passed in variableGrads(f) must be a function"),O(e==null||Array.isArray(e)&&e.every(h=>h instanceof np),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const h in W.registeredVariables)e.push(W.registeredVariables[h])}const s=t?e.filter(h=>!h.trainable):null,r=e.length;e=e.filter(h=>h.trainable),O(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:i,grads:o}=W.gradients(n,e,null,a);O(o.some(h=>h!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),O(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return e.forEach((h,d)=>{o[d]!=null&&(l[h.name]=o[d])}),s?.forEach(h=>l[h.name]=null),{value:i,grads:l}}function qa(n){return W.customGrad(n)}function Rx(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function wZ(n){const t={x:M(n,"x","neg")};return W.runKernel(nm,t)}const Mt=G({neg_:wZ});function vZ(n){const t={x:M(n,"x","softplus")};return W.runKernel(Vh,t)}const mu=G({softplus_:vZ});function SZ(n){const e=M(n,"x","logSigmoid");return qa(s=>({value:Mt(mu(Mt(s))),gradFunc:i=>Y(i,pa(Mt(s)))}))(e)}const iN=G({logSigmoid_:SZ});function TZ(n,e){let t=M(n,"a","sub"),s=M(e,"b","sub");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel(Wh,r)}const Ae=G({sub_:TZ});function CZ(n,e=-1){const t=M(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return qa((r,a)=>{const o=Sr(r,e,!0),l=Ae(r,o),h=Ae(Ne(l,"float32"),Js(Re(Ds(l),e,!0)));return a([h]),{value:h,gradFunc:(f,m)=>{const[y]=m,b=!0,x=Ds(y);return Ae(f,Y(Re(f,e,b),x))}}})(t)}const Dx=G({logSoftmax_:CZ});function NZ(n,e=null,t=!1){const s=M(n,"x","logSumExp"),r=at(e,s.shape),a=Sr(s,r,!0),i=Ae(s,a),o=Ds(i),l=Re(o,r),h=Js(l),d=we(J(a,h.shape),h);if(t){const f=un(d.shape,r);return J(d,f)}return d}const Dm=G({logSumExp_:NZ});function kZ(n,e){const t=M(n,"a","logicalAnd","bool"),s=M(e,"b","logicalAnd","bool");Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Hp,r)}const qr=G({logicalAnd_:kZ});function EZ(n){const t={x:M(n,"x","logicalNot","bool")};return W.runKernel(qp,t)}const Om=G({logicalNot_:EZ});function $Z(n,e){const t=M(n,"a","logicalOr","bool"),s=M(e,"b","logicalOr","bool");Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Kp,r)}const Ox=G({logicalOr_:$Z});function IZ(n,e){const t=M(n,"a","logicalXor","bool"),s=M(e,"b","logicalXor","bool");return Ze(t.shape,s.shape),qr(Ox(n,e),Om(qr(n,e)))}const oN=G({logicalXor_:IZ});const Oy=2147483648;function _Z(n,e,t="left"){const s=M(n,"sortedSequence","searchSorted"),r=M(e,"values","searchSorted"),a=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],o=J(s,[-1,a]),l=J(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(he(l.shape)>=Oy)throw new Error(`values tensor size must less than ${Oy}`);if(o.shape[1]>=Oy)throw new Error(`trailing dim_size must less than ${Oy} for int32 output type, was ${o.shape[1]}`);const h={sortedSequence:o,values:l},d={side:t};return W.runKernel(ix,h,d)}const Fx=G({searchSorted_:_Z});function ez(n,e){return Fx(n,e,"left")}function AZ(n,e,t,s,r){const a=M(n,"x","maxPool"),i=1;let o=a,l=!1;a.rank===3&&(l=!0,o=J(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),O(Zn(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ws("maxPool",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r},f=W.runKernel(Jp,h,d);return l?J(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Fm=G({maxPool_:AZ});function RZ(n,e=[1,1,1],t,s,r,a="NDHWC"){const i=M(n,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=J(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),O(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ws("maxPool3d",s,r);const h={x:o},d={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:a},f=W.runKernel(Zp,h,d);return l?J(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const lN=G({maxPool3d_:RZ});function DZ(n,e,t,s,r=!1){const i={x:M(n,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=W.runKernel(Hb,i,o);return{result:l[0],indexes:l[1]}}const tz=G({maxPoolWithArgmax_:DZ});function OZ(n,e){let t=M(n,"a","maximum"),s=M(e,"b","maximum");[t,s]=Jt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(kh,r)}const Xa=G({maximum_:OZ});function FZ(n,e=null,t=!1){const r={x:M(n,"x","mean")},a={axis:e,keepDims:t};return W.runKernel(Qp,r,a)}const Kt=G({mean_:FZ});function gn(n,e="float32"){if(tr(n),e==="complex64"){const s=gn(n,"float32"),r=gn(n,"float32");return $i(s,r)}const t=Yn(he(n),e);return W.makeTensor(t,n,e)}function $s(n,e="float32"){if(tr(n),e==="complex64"){const s=$s(n,"float32"),r=gn(n,"float32");return $i(s,r)}const t=mb(he(n),e);return W.makeTensor(t,n,e)}function nz(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=M(n,"x","meshgrid",n instanceof bt?n.dtype:"float32");if(e===void 0)return[s];let r=M(e,"y","meshgrid",e instanceof bt?e.dtype:"float32");const a=he(s.shape),i=he(r.shape);return t==="xy"?(s=J(s,[1,-1]),r=J(r,[-1,1]),[rt($s([i,1],s.dtype),s),rt(r,$s([1,a],r.dtype))]):(s=J(s,[-1,1]),r=J(r,[1,-1]),[rt(s,$s([1,i],s.dtype)),rt($s([a,1],r.dtype),r)])}function LZ(n,e){let t=M(n,"a","minimum"),s=M(e,"b","minimum");[t,s]=Jt(t,s),t.dtype==="bool"&&(t=Ne(t,"int32"),s=Ne(s,"int32")),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(Eh,r)}const Do=G({minimum_:LZ});function MZ(n,e,t){O(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=M(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)O(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),O(e[o][0]>=0&&e[o][0]<=s.shape[o]-r&&e[o][1]>=0&&e[o][1]<=s.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`);const a={paddings:e,mode:t},i={x:s};return W.runKernel(tm,i,a)}const uN=G({mirrorPad_:MZ});function zZ(n,e){let t=M(n,"a","mod"),s=M(e,"b","mod");[t,s]=Jt(t,s);const r={a:t,b:s};return W.runKernel($h,r)}const cN=G({mod_:zZ});function PZ(n,e=null,t=!1){n=M(n,"x","moments");const s=at(e,n.shape),r=Kt(n,s,t);let a=r.shape;t||(a=un(r.shape,s));const i=$t(Ae(Ne(n,"float32"),J(r,a))),o=Kt(i,s,t);return{mean:r,variance:o}}const Lm=G({moments_:PZ});function BZ(n,e,t,s){const r=M(e,"data","multiRNNCell"),a=sp(t,"c","multiRNNCell"),i=sp(s,"h","multiRNNCell");let o=r;const l=[];for(let f=0;f<n.length;f++){const m=n[f](o,a[f],i[f]);l.push(m[0]),l.push(m[1]),o=m[1]}const h=[],d=[];for(let f=0;f<l.length;f+=2)h.push(l[f]),d.push(l[f+1]);return[h,d]}const sz=G({multiRNNCell_:BZ});function VZ(n,e,t,s=!1){const r=M(n,"logits","multinomial"),a=r.size,i=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const l={logits:i===1?J(r,[1,-1]):r},h={numSamples:e,seed:t,normalized:s},d=W.runKernel(qb,l,h);return i===1?J(d,[d.size]):d}const rz=G({multinomial_:VZ});function UZ(n,e){let t=M(n,"a","notEqual","string_or_numeric"),s=M(e,"b","notEqual","string_or_numeric");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s};return W.runKernel(sm,r)}const Ql=G({notEqual_:UZ});function jZ(n,e,t=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:M(n,"indices","oneHot","int32")},o={dtype:r,depth:e,onValue:t,offValue:s};return W.runKernel(am,i,o)}const Vc=G({oneHot_:jZ});function WZ(n){const t={x:M(n,"x","onesLike")};return W.runKernel(rm,t)}const Zs=G({onesLike_:WZ});function GZ(n,e){const t=M(n,"v1","outerProduct"),s=M(e,"v2","outerProduct");O(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=J(t,[-1,1]),a=J(s,[1,-1]);return rt(r,a)}const az=G({outerProduct_:GZ});function HZ(n,e,t=0){const s=M(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},a={x:s};return W.runKernel(om,a,r)}const zi=G({pad_:HZ});function qZ(n,e,t=0){return O(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),zi(n,[e],t)}const iz=G({pad1d_:qZ});function KZ(n,e,t=0){return O(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,e,t)}const oz=G({pad2d_:KZ});function XZ(n,e,t=0){return O(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,e,t)}const lz=G({pad3d_:XZ});function YZ(n,e,t=0){return O(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,e,t)}const uz=G({pad4d_:YZ});function JZ(n,e,t){const s=M(n,"x","spaceToBatchND");O(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),O(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),O(s.shape.reduce((i,o,l)=>l>0&&l<=e.length?i&&(o+t[l-1][0]+t[l-1][1])%e[l-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},a={blockShape:e,paddings:t};return W.runKernel(ym,r,a)}const Mm=G({spaceToBatchND_:JZ});function ZZ(n,e,t,s,r,a,i){r==null&&(r=[1,1]),a==null&&(a=1),s===0&&(s="valid");const o=M(n,"x","maxPool");let l=o,h=!1;o.rank===3&&(h=!0,l=J(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(Zn(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const d=Kr(l.shape,e,a,r,s),f=[d.dilationHeight,d.dilationWidth];let m;s==="same"?m=eQ([d.filterHeight,d.filterWidth],f):m=[[0,0],[0,0]];const y=f[0]===1&&f[1]===1,[b,x]=QZ([d.inHeight,d.inWidth],f,m),w=y?s:"valid",v=y?l:Mm(l,f,b),N=(t==="avg"?()=>Em(v,e,a,w,i):()=>Fm(v,e,a,w,i))(),k=y?N:$m(N,f,x);return h?J(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function QZ(n,e,t){const s=t.map(d=>d[0]),r=t.map(d=>d[1]),a=n.concat(s,r),i=e.map((d,f)=>(d-a[f]%d)%d),o=r.map((d,f)=>d+i[f]),l=e.map((d,f)=>[s[f],o[f]]),h=e.map((d,f)=>[0,i[f]]);return[l,h]}function eQ(n,e){const s=n.map((i,o)=>i+(i-1)*(e[o]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),a=s.map((i,o)=>i-r[o]);return s.map((i,o)=>[r[o],a[o]])}const hN=G({pool_:ZZ});function tQ(n,e){const t=M(n,"x","prelu"),s=M(e,"alpha","prelu"),r={x:t,alpha:s};return W.runKernel(lm,r)}const zm=G({prelu_:tQ});function nQ(n,e=null,t=!1){let s=M(n,"x","prod");s.dtype==="bool"&&(s=Ne(s,"int32"));const r={x:s},a={axis:e,keepDims:t};return W.runKernel(um,r,a)}const dN=G({prod_:nQ});function sQ(n,e,t,s){const r=n.map((d,f)=>M(d,`tensors${f}`,"raggedGather","int32")),a=M(e,"paramsDenseValues","raggedGather"),i=M(t,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:a,indices:i},l={outputRaggedRank:s},h=W.runKernel(Jb,o,l);return{outputNestedSplits:h.slice(0,h.length-1),outputDenseValues:h[h.length-1]}}const cz=G({raggedGather_:sQ});function rQ(n,e,t){const s=M(n,"starts","raggedRange"),r=M(e,"limits","raggedRange",s.dtype),a=M(t,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:a},o=W.runKernel(Zb,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const hz=G({raggedRange_:rQ});function aQ(n,e,t,s,r){const a=M(n,"shape","raggedTensorToTensor","int32"),i=M(e,"values","raggedTensorToTensor"),o=M(t,"defaultValue","raggedTensorToTensor",i.dtype),l=s.map((f,m)=>M(f,`tensors${m}`,"raggedTensorToTensor","int32")),h={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},d={rowPartitionTypes:r};return W.runKernel(Qb,h,d)}const dz=G({raggedTensorToTensor_:aQ});function iQ(n,e,t){tr(n);const s=he(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let a=0;a<s;a++)r[a]=e();return W.makeTensor(r,n,t)}const fz=G({rand_:iQ});var e0={exports:{}},oQ=e0.exports,bO;function lQ(){return bO||(bO=1,(function(n){(function(e,t,s){function r(l){var h=this,d=o();h.next=function(){var f=2091639*h.s0+h.c*23283064365386963e-26;return h.s0=h.s1,h.s1=h.s2,h.s2=f-(h.c=f|0)},h.c=1,h.s0=d(" "),h.s1=d(" "),h.s2=d(" "),h.s0-=d(l),h.s0<0&&(h.s0+=1),h.s1-=d(l),h.s1<0&&(h.s1+=1),h.s2-=d(l),h.s2<0&&(h.s2+=1),d=null}function a(l,h){return h.c=l.c,h.s0=l.s0,h.s1=l.s1,h.s2=l.s2,h}function i(l,h){var d=new r(l),f=h&&h.state,m=d.next;return m.int32=function(){return d.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,f&&(typeof f=="object"&&a(f,d),m.state=function(){return a(d,{})}),m}function o(){var l=4022871197,h=function(d){d=String(d);for(var f=0;f<d.length;f++){l+=d.charCodeAt(f);var m=.02519603282416938*l;l=m>>>0,m-=l,m*=l,l=m>>>0,m-=l,l+=m*4294967296}return(l>>>0)*23283064365386963e-26};return h}t&&t.exports?t.exports=i:this.alea=i})(oQ,n)})(e0)),e0.exports}var t0={exports:{}},uQ=t0.exports,xO;function cQ(){return xO||(xO=1,(function(n){(function(e,t,s){function r(o){var l=this,h="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},o===(o|0)?l.x=o:h+=o;for(var d=0;d<h.length+64;d++)l.x^=h.charCodeAt(d)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var h=new r(o),d=l&&l.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},f.int32=h.next,f.quick=f,d&&(typeof d=="object"&&a(d,h),f.state=function(){return a(h,{})}),f}t&&t.exports?t.exports=i:this.xor128=i})(uQ,n)})(t0)),t0.exports}var n0={exports:{}},hQ=n0.exports,wO;function dQ(){return wO||(wO=1,(function(n){(function(e,t,s){function r(o){var l=this,h="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:h+=o;for(var d=0;d<h.length+64;d++)l.x^=h.charCodeAt(d)|0,d==h.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var h=new r(o),d=l&&l.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},f.int32=h.next,f.quick=f,d&&(typeof d=="object"&&a(d,h),f.state=function(){return a(h,{})}),f}t&&t.exports?t.exports=i:this.xorwow=i})(hQ,n)})(n0)),n0.exports}var s0={exports:{}},fQ=s0.exports,vO;function pQ(){return vO||(vO=1,(function(n){(function(e,t,s){function r(o){var l=this;l.next=function(){var d=l.x,f=l.i,m,y;return m=d[f],m^=m>>>7,y=m^m<<24,m=d[f+1&7],y^=m^m>>>10,m=d[f+3&7],y^=m^m>>>3,m=d[f+4&7],y^=m^m<<7,m=d[f+7&7],m=m^m<<13,y^=m^m<<9,d[f]=y,l.i=f+1&7,y};function h(d,f){var m,y=[];if(f===(f|0))y[0]=f;else for(f=""+f,m=0;m<f.length;++m)y[m&7]=y[m&7]<<15^f.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?y[7]=-1:y[m],d.x=y,d.i=0,m=256;m>0;--m)d.next()}h(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var h=new r(o),d=l&&l.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},f.int32=h.next,f.quick=f,d&&(d.x&&a(d,h),f.state=function(){return a(h,{})}),f}t&&t.exports?t.exports=i:this.xorshift7=i})(fQ,n)})(s0)),s0.exports}var r0={exports:{}},mQ=r0.exports,SO;function gQ(){return SO||(SO=1,(function(n){(function(e,t,s){function r(o){var l=this;l.next=function(){var d=l.w,f=l.X,m=l.i,y,b;return l.w=d=d+1640531527|0,b=f[m+34&127],y=f[m=m+1&127],b^=b<<13,y^=y<<17,b^=b>>>15,y^=y>>>12,b=f[m]=b^y,l.i=m,b+(d^d>>>16)|0};function h(d,f){var m,y,b,x,w,v=[],C=128;for(f===(f|0)?(y=f,f=null):(f=f+"\0",y=0,C=Math.max(C,f.length)),b=0,x=-32;x<C;++x)f&&(y^=f.charCodeAt((x+32)%f.length)),x===0&&(w=y),y^=y<<10,y^=y>>>15,y^=y<<4,y^=y>>>13,x>=0&&(w=w+1640531527|0,m=v[x&127]^=y+w,b=m==0?b+1:0);for(b>=128&&(v[(f&&f.length||0)&127]=-1),b=127,x=512;x>0;--x)y=v[b+34&127],m=v[b=b+1&127],y^=y<<13,m^=m<<17,y^=y>>>15,m^=m>>>12,v[b]=y^m;d.w=w,d.X=v,d.i=b}h(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var h=new r(o),d=l&&l.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},f.int32=h.next,f.quick=f,d&&(d.X&&a(d,h),f.state=function(){return a(h,{})}),f}t&&t.exports?t.exports=i:this.xor4096=i})(mQ,n)})(r0)),r0.exports}var a0={exports:{}},yQ=a0.exports,TO;function bQ(){return TO||(TO=1,(function(n){(function(e,t,s){function r(o){var l=this,h="";l.next=function(){var f=l.b,m=l.c,y=l.d,b=l.a;return f=f<<25^f>>>7^m,m=m-y|0,y=y<<24^y>>>8^b,b=b-f|0,l.b=f=f<<20^f>>>12^m,l.c=m=m-y|0,l.d=y<<16^m>>>16^b,l.a=b-f|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):h+=o;for(var d=0;d<h.length+20;d++)l.b^=h.charCodeAt(d)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var h=new r(o),d=l&&l.state,f=function(){return(h.next()>>>0)/4294967296};return f.double=function(){do var m=h.next()>>>11,y=(h.next()>>>0)/4294967296,b=(m+y)/(1<<21);while(b===0);return b},f.int32=h.next,f.quick=f,d&&(typeof d=="object"&&a(d,h),f.state=function(){return a(h,{})}),f}t&&t.exports?t.exports=i:this.tychei=i})(yQ,n)})(a0)),a0.exports}var i0={exports:{}};const xQ={},wQ=Object.freeze(Object.defineProperty({__proto__:null,default:xQ},Symbol.toStringTag,{value:"Module"})),vQ=_G(wQ);var SQ=i0.exports,CO;function TQ(){return CO||(CO=1,(function(n){(function(e,t,s){var r=256,a=6,i=52,o="random",l=s.pow(r,a),h=s.pow(2,i),d=h*2,f=r-1,m;function y(k,E,_){var R=[];E=E==!0?{entropy:!0}:E||{};var D=v(w(E.entropy?[k,N(t)]:k??C(),3),R),F=new b(R),L=function(){for(var A=F.g(a),V=l,q=0;A<h;)A=(A+q)*r,V*=r,q=F.g(1);for(;A>=d;)A/=2,V/=2,q>>>=1;return(A+q)/V};return L.int32=function(){return F.g(4)|0},L.quick=function(){return F.g(4)/4294967296},L.double=L,v(N(F.S),t),(E.pass||_||function(A,V,q,ne){return ne&&(ne.S&&x(ne,F),A.state=function(){return x(F,{})}),q?(s[o]=A,V):A})(L,D,"global"in E?E.global:this==s,E.state)}function b(k){var E,_=k.length,R=this,D=0,F=R.i=R.j=0,L=R.S=[];for(_||(k=[_++]);D<r;)L[D]=D++;for(D=0;D<r;D++)L[D]=L[F=f&F+k[D%_]+(E=L[D])],L[F]=E;(R.g=function(A){for(var V,q=0,ne=R.i,Q=R.j,B=R.S;A--;)V=B[ne=f&ne+1],q=q*r+B[f&(B[ne]=B[Q=f&Q+V])+(B[Q]=V)];return R.i=ne,R.j=Q,q})(r)}function x(k,E){return E.i=k.i,E.j=k.j,E.S=k.S.slice(),E}function w(k,E){var _=[],R=typeof k,D;if(E&&R=="object")for(D in k)try{_.push(w(k[D],E-1))}catch{}return _.length?_:R=="string"?k:k+"\0"}function v(k,E){for(var _=k+"",R,D=0;D<_.length;)E[f&D]=f&(R^=E[f&D]*19)+_.charCodeAt(D++);return N(E)}function C(){try{var k;return m&&(k=m.randomBytes)?k=k(r):(k=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(k)),N(k)}catch{var E=e.navigator,_=E&&E.plugins;return[+new Date,e,_,e.screen,N(t)]}}function N(k){return String.fromCharCode.apply(0,k)}if(v(s.random(),t),n.exports){n.exports=y;try{m=vQ}catch{}}else s["seed"+o]=y})(typeof self<"u"?self:SQ,[],Math)})(i0)),i0.exports}var RS,NO;function CQ(){if(NO)return RS;NO=1;var n=lQ(),e=cQ(),t=dQ(),s=pQ(),r=gQ(),a=bQ(),i=TQ();return i.alea=n,i.xor128=e,i.xorwow=t,i.xorshift7=s,i.xor4096=r,i.tychei=a,RS=i,RS}var td=CQ();const NQ=.001,pz=.1;function kQ(n,e,t){return t==null&&(t=fN()),BT(n,e,(s,r)=>pN(s,r,t))}function fN(){return W.backend.floatPrecision()===32?NQ:pz}function BT(n,e,t){let s=!0;if((kn(n)||kn(e))&&(s=!1),kn(n)&&kn(e)&&(s=!0),s){const i=n.constructor.name,o=e.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(n)&&Array.isArray(e)){const i=Ga(n),o=Ga(e);if(!lt(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}const r=kn(n)?n:Wa(n),a=kn(e)?e:Wa(e);if(r.length!==a.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${a.length}.
Actual:   ${r}.
Expected: ${a}.`);for(let i=0;i<a.length;++i){const o=r[i],l=a[i];if(!t(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${r}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function EQ(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function $Q(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return Fa(n)||Fa(n[0])||Fa(e)||Fa(e[0])?BT(n,t,(s,r)=>s==r):BT(n,e,(s,r)=>pN(s,r,0))}function IQ(n,e,t){if(t==null&&(t=fN()),!pN(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function pN(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function _Q(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function AQ(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function mz(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?mz(t):n[e]=Pa(t)}return n}function RQ(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function DQ(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const OQ=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:pz,createVideoElement:RQ,encodeStrings:mz,expectArrayBuffersEqual:AQ,expectArraysClose:kQ,expectArraysEqual:$Q,expectNumbersClose:IQ,expectPromiseToFail:EQ,expectValuesInRange:_Q,play:DQ,testEpsilon:fN},Symbol.toStringTag,{value:"Module"}));class mN{constructor(e,t,s,r,a){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=td.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,a,i;do r=2*this.random()-1,a=2*this.random()-1,i=r*r+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class FQ{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const a=r||Math.random();this.randu=td.alea(a.toString()),this.randn=new mN(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,a,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<t||Math.log(a)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class LQ{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=td.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function MQ(n,e,t=1,s="float32",r){if(tr(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new FQ(e,t,s,r),i=tt(n,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const gz=G({randomGamma_:MQ});function zQ(n,e=0,t=1,s,r){if(tr(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new mN(e,t,s,!1,r),i=tt(n,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Lx=G({randomNormal_:zQ});function PQ(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Lx(n,0,1,e,t)}const yz=G({randomStandardNormal_:PQ});function BQ(n,e=0,t=1,s="float32",r){tr(n);const a=tt(n,s),i=new LQ(e,t,null,r);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Go=G({randomUniform_:BQ});function VQ(n,e,t,s){return Go(n,e,t,"int32",s)}const bz=G({randomUniformInt_:VQ});function eu(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return W.runKernel(ex,{},r)}function UQ(n){const t={input:M(n,"input","real")};return W.runKernel(tx,t)}const Uc=G({real_:UQ});function jQ(n){const t={x:M(n,"x","reciprocal")};return W.runKernel(Ah,t)}const gN=G({reciprocal_:jQ});function WQ(n){const t={x:M(n,"x","relu")};return W.runKernel(Rh,t)}const Ta=G({relu_:WQ});function GQ(n){const t={x:M(n,"x","relu6")};return W.runKernel(Dh,t)}const Mx=G({relu6_:GQ});function HQ(n,e){const s={x:M(n,"x","reverse")},r={dims:e};return W.runKernel(fm,s,r)}const Tr=G({reverse_:HQ});function qQ(n){const e=M(n,"x","reverse");return O(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Tr(e,0)}const xz=G({reverse1d_:qQ});function KQ(n,e){const t=M(n,"x","reverse");return O(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Tr(t,e)}const wz=G({reverse2d_:KQ});function XQ(n,e){const t=M(n,"x","reverse");return O(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Tr(t,e)}const vz=G({reverse3d_:XQ});function YQ(n,e){const t=M(n,"x","reverse");return O(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Tr(t,e)}const Sz=G({reverse4d_:YQ});function JQ(n){const t={x:M(n,"x","round")};return W.runKernel(Oh,t)}const zx=G({round_:JQ});function ZQ(n){const t={x:M(n,"x","rsqrt","float32")};return W.runKernel(Fh,t)}const Px=G({rsqrt_:ZQ});function QQ(n){const t={x:M(n,"x","selu")};return W.runKernel(Lh,t)}const Bx=G({selu_:QQ});function eee(n,e,t,s,r,a=[1,1],i="NHWC"){const o=M(n,"x","separableConv2d"),l=M(e,"depthwiseFilter","separableConv2d"),h=M(t,"pointwiseFilter","separableConv2d");let d=o,f=!1;if(o.rank===3&&(f=!0,d=J(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");O(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),O(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),O(h.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),O(h.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${h.shape[0]}.`),O(h.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${h.shape[1]}.`);const m=l.shape[2],y=l.shape[3];O(h.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${h.shape[2]}.`);const b=Yh(d,l,s,r,i,a),w=Ii(b,h,1,"valid",i);return f?J(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const Vx=G({separableConv2d_:eee});async function tee(n,e){const t=M(n,"x","setdiff1d"),s=M(e,"y","setdiff1d");O(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),O(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),O(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),a=await s.data(),i=new Set(a);let o=0;for(let d=0;d<r.length;d++)i.has(r[d])||o++;const l=new bn([o],t.dtype),h=new bn([o],"int32");for(let d=0,f=0;d<r.length;d++)i.has(r[d])||(l.values[f]=r[d],h.values[f]=d,f++);return[l.toTensor(),h.toTensor()]}const Tz=tee;function nee(n){const t={x:M(n,"x","sign")};return W.runKernel(Ph,t)}const yN=G({sign_:nee});function see(n){const t={x:M(n,"x","sin","float32")};return W.runKernel(Mh,t)}const Ux=G({sin_:see});function ree(n){const t={x:M(n,"x","sinh")};return W.runKernel(zh,t)}const jx=G({sinh_:ree});function aee(n,e,t){const s=M(n,"x","slice1d");return O(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),dt(s,[e],[t])}const Pm=G({slice1d_:aee});function iee(n,e,t){const s=M(n,"x","slice2d");return O(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),dt(s,e,t)}const Wx=G({slice2d_:iee});function oee(n,e,t){const s=M(n,"x","slice3d");return O(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),dt(s,e,t)}const Bm=G({slice3d_:oee});function lee(n,e,t){const s=M(n,"x","slice4d");return O(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),dt(s,e,t)}const jc=G({slice4d_:lee});function uee(n,e=-1){const t=M(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return W.runKernel(xm,s,r)}const Vm=G({softmax_:uee});function cee(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Lb,e)}const Um=G({fft_:cee});function hee(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(Bb,e)}const Wc=G({ifft_:hee});function dee(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=J(n,[t,e]);s=Wc(r)}else{const r=[t,2*(e-1)],a=J(Uc(n),[t,e]),i=J(_m(n),[t,e]),o=Tr(dt(a,[0,1],[t,e-2]),1),l=Y(Tr(dt(i,[0,1],[t,e-2]),1),ze(-1)),h=ln([a,o],1),d=ln([i,l],1),f=J($i(h,d),[r[0],r[1]]);s=Wc(f)}if(s=Uc(s),n.rank===3&&n.shape[0]!==0){const r=s,a=n.shape[0];s=J(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}const Gx=G({irfft_:dee});function fee(n,e,t=0){const r={x:M(n,"x","split")},a={numOrSizeSplits:e,axis:t};return W.runKernel(bm,r,a)}const Is=G({split_:fee});function pee(n,e){O(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const b=n.shape.map(w=>0),x=n.shape.map(w=>w);x[n.shape.length-1]=e,r=dt(n,b,x),t=e}else if(e!=null&&e>t){const b=n.shape.map(x=>x);b[n.shape.length-1]=e-t,r=ln([n,gn(b)],n.shape.length-1),t=e}else r=n;const a=ft(r),i=J($i(r,a),[s,t]),o=Um(i),l=Math.floor(t/2)+1,h=Uc(o),d=_m(o),f=Is(h,[l,t-l],h.shape.length-1),m=Is(d,[l,t-l],d.shape.length-1),y=r.shape.slice();return y[r.shape.length-1]=l,J($i(f[0],m[0]),y)}const jm=G({rfft_:pee});function mee(n,e){let t=M(n,"a","squaredDifference"),s=M(e,"b","squaredDifference");[t,s]=Jt(t,s),Ze(t.shape,s.shape);const r={a:t,b:s},a={};return W.runKernel(jh,r,a)}const Hx=G({squaredDifference_:mee});function gee(n,e){const t=M(n,"x","squeeze","string_or_numeric");return J(t,Di(t.shape,e).newShape)}const Ho=G({squeeze_:gee});function yee(n,e=0){const t=sp(n,"tensors","stack","string_or_numeric");O(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&O(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return W.runKernel(im,s,r)}const bs=G({stack_:yee});function bee(n,e=0){const s={x:M(n,"x","step")},r={alpha:e};return W.runKernel(Kh,s,r)}const gu=G({step_:bee});function xee(n,e,t,s,r=0,a=0,i=0,o=0,l=0){const d={x:M(n,"x","stridedSlice","string_or_numeric")},f={begin:e,end:t,strides:s,beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return W.runKernel(fx,d,f)}const bN=G({stridedSlice_:xee});function wee(n){const t={x:M(n,"x","tan","float32")};return W.runKernel(Gh,t)}const xN=G({tan_:wee});function Xn(n,e){cu(n);const t=Ga(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Vo(n,null,t,e)}function To(n,e,t){if(cu(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Ga(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Vo(n,e,s,t)}function qx(n,e,t){if(cu(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Ga(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Vo(n,e,s,t)}function Cz(n,e,t){if(cu(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Ga(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Vo(n,e,s,t)}function Nz(n,e,t){if(cu(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Ga(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Vo(n,e,s,t)}function kz(n,e,t){if(cu(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Ga(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Vo(n,e,s,t)}function wN(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(a+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(a+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(a+` update.rank != ${r+n.length-s}`);for(let i=0;i<r;++i)if(t.shape[i]!==e.shape[i])throw new Error(a+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-r;++i)if(t.shape[i+r]!==n[i+s])throw new Error(a+` updates.shape[${i+r}] (${t.shape[i+r]}) != shape[${i+r}] (${n[i+r]})`)}function Kx(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}wN(t,e,n)}function qo(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,a=t.length;let i=1;for(let f=r;f<a;++f)i*=t[f];const o=r<1?1:r,l=he(e.shape)/o,h=[...Pe(t.slice(0,r)),1],d=he(t);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:h,outputSize:d}}const vee=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:qo,validateInput:Kx,validateUpdateShape:wN},Symbol.toStringTag,{value:"Module"}));function See(n,e,t){const s=M(n,"tensor","tensorScatterupdate"),r=M(e,"indices","tensorScatterupdate","int32"),a=M(t,"updates","tensorScatterupdate");if(Kx(a,r,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const i={tensor:s,indices:r,updates:a},o={};return W.runKernel(ax,i,o)}const Ez=G({tensorScatterUpdate_:See});function Tee(n,e=1,t=!0){const s=M(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const a={x:s},i={k:e,sorted:t},[o,l]=W.runKernel(yx,a,i);return{values:o,indices:l}}const vN=G({topk_:Tee});function Cee(n,e=0,t=1,s,r){if(tr(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new mN(e,t,s,!0,r),i=tt(n,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Xx=G({truncatedNormal_:Cee});function Nee(n,e=0){const t=M(n,"x","unique","string_or_numeric");O(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[a,i]=W.runKernel(xx,s,r);return{values:a,indices:i}}const SN=G({unique_:Nee});function kee(n,e,t){const s=M(n,"x","unsortedSegmentSum"),r=M(e,"segmentIds","unsortedSegmentSum","int32");O(Hl(t),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:r},i={numSegments:t};return W.runKernel(Sm,a,i)}const Yx=G({unsortedSegmentSum_:kee});function Eee(n,e=0){const t=M(n,"x","unstack","string_or_numeric");O(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return W.runKernel(vm,s,r)}const Cr=G({unstack_:Eee});function $z(n,e){return Fx(n,e,"right")}function TN(n,e=!0,t,s){return W.makeVariable(n,e,t,s)}function Jx(n,e){const t=[];for(let a=0;a<e.length;a++)e[a]&&t.push(a);const s=tt(n,"int32"),r=tt([t.length,n.length],"int32");for(let a=0;a<t.length;a++){const i=s.indexToLoc(t[a]),o=a*n.length;r.values.set(i,o)}return r.toTensor()}async function $ee(n){const e=M(n,"condition","whereAsync","bool"),t=await e.data(),s=Jx(e.shape,t);return n!==e&&e.dispose(),s}const CN=$ee;async function Iee(n,e,t){const s=M(n,"tensor","boolMask"),r=M(e,"mask","boolMask","bool"),a=t??0,i=r.rank,o=s.shape;O(i>0,()=>"mask cannot be scalar"),Jn(o.slice(a,a+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=a;x<a+i;x++)l*=o[x];const h=o.slice(0,a).concat([l],o.slice(a+i)),d=J(s,h),f=J(r,[-1]),m=await CN(f),y=Ho(m,[1]),b=ed(d,y,a);return n!==s&&s.dispose(),e!==r&&r.dispose(),y.dispose(),d.dispose(),f.dispose(),m.dispose(),b}const Iz=Iee;function _ee(n,e,t){const s=M(n,"x","transpose");if(e==null&&(e=s.shape.map((i,o)=>o).reverse()),O(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{O(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},a={perm:e};return s.dtype==="complex64"?re(()=>{let i=Uc(s),o=_m(s);return i=W.runKernel(Ul,{x:i},a),o=W.runKernel(Ul,{x:o},a),t&&(o=Mt(o)),$i(i,o)}):W.runKernel(Ul,r,a)}const ut=G({transpose_:_ee});function Aee(n,e,t,s,r=!0){const a=M(n,"v","movingAverage"),i=M(e,"x","movingAverage"),o=M(t,"decay","movingAverage");NM(a,i),O(lt(a.shape,i.shape),()=>"Shape mismatch in v and x");const l=ze(1),h=Ae(l,o);let d=Y(Ae(i,a),h);if(r){O(s!=null,()=>"When using zeroDebias: true, step is required.");const f=M(s,"step","movingAverage");d=Fe(d,Ae(l,Ha(o,f)))}return we(a,d)}const _z=G({movingAverage_:Aee});function Ree(n,e,t){tr(t);const s=M(n,"indices","scatterND","int32"),r=M(e,"updates","scatterND");Kx(r,s,t);const a={indices:s,updates:r},i={shape:t};return W.runKernel(rx,a,i)}const Az=G({scatterND_:Ree});function Dee(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,a=n.rank>1?n.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Oee(n,e,t,s=0){tr(t);const r=M(n,"sparseIndices","sparseToDense","int32"),a=M(e,"sparseValues","sparseToDense","string_or_numeric"),i=M(s,"defaultValue","sparseToDense",a.dtype);Dee(r,a,t,i);const o={sparseIndices:r,sparseValues:a,defaultValue:i},l={outputShape:t};return W.runKernel(hx,o,l)}const Rz=G({sparseToDense_:Oee});function Fee(n,e){const t=M(e,"indices","gatherND","int32"),r={params:M(n,"x","gatherND","string_or_numeric"),indices:t};return W.runKernel(Pb,r)}const Dz=G({gatherND_:Fee});function Lee(n,e){if(e==null)return n.shape.slice();if(lt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}function Mee(n,e,t,s){const r=M(n,"x","dropout");if(O(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),O(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof bt?r.clone():r;const a=Lee(r,t),i=1-e,o=Fe(Qh(we(Go(a,0,1,"float32",s),i)),i);return Y(r,o)}const NN=G({dropout_:Mee});function kN(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Zx(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let a=0;a<n;++a){const i=2*Math.PI*a/(n+s-1);r[a]=e-t*Math.cos(i)}return Xn(r,"float32")}async function zee(n,e,t=1){const s=M(n,"predictions","inTopK"),r=M(e,"targets","inTopK");O(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),O(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Jn(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];O(t>0&&t<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${t}`);const i=await s.data(),o=await r.data(),[l,h]=[i.length/a,a],d=zn("bool",l);for(let f=0;f<l;f++){const m=f*h,y=i.subarray(m,m+h),b=[];for(let x=0;x<y.length;x++)b.push({value:y[x],index:x});b.sort((x,w)=>w.value-x.value),d[f]=0;for(let x=0;x<t;x++)if(b[x].index===o[f]){d[f]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Xs(d,r.shape,"bool")}const Oz=zee;function Pee(n,e,t,s,r,a="NHWC",i){let o=n;n.rank===3&&(o=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=J(e,[1,e.shape[0],e.shape[1],e.shape[2]])),O(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),O(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),O(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const h=a==="NHWC"?o.shape[3]:o.shape[1],d=a==="NHWC"?l.shape[3]:l.shape[1];O(h===t[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${t[2]}.`),O(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),ws("conv2dDerFilter",r,i);const f={x:o,dy:l},m={strides:s,pad:r,dataFormat:a,dimRoundingMode:i,filterShape:t};return W.runKernel(Tb,f,m)}const EN=G({conv2DBackpropFilter_:Pee});function Qx(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Y(n,gu(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ew(n,e){let t=e;const s=xn(n.shape,e.shape);return s.length>0&&(t=Re(t,s)),J(t,n.shape)}function tw(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Ta(n);if(e==="elu")return Jh(n);if(e==="relu6")return Mx(n);if(e==="prelu")return zm(n,t);if(e==="leakyrelu")return Am(n,s);if(e==="sigmoid")return pa(n);throw new Error(`Unknown fused activation ${e}.`)}const nw=(n,e)=>!(n>0)||e==="linear";function Bee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(l=l||"linear",nw(W.state.gradientDepth,l)===!1){O(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=Ii(n,e,t,s,r,a,i);return o!=null&&(_=we(_,o)),tw(_,l,h,d)}const f=M(n,"x","conv2d","float32"),m=M(e,"filter","conv2d","float32");let y=f,b=!1;f.rank===3&&(b=!0,y=J(f,[1,f.shape[0],f.shape[1],f.shape[2]])),O(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),O(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),ws("fused conv2d",s,i);const x=r==="NHWC"?y.shape[3]:y.shape[1];O(m.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${m.shape[2]}.`),O(Zn(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const w=Vn(y.shape,m.shape,t,a,s,i);let v;o!=null&&(v=M(o,"bias","fused conv2d"),[v]=Jt(v,f),r==="NHWC"?Ze(w.outShape,v.shape):(O(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),O(v.shape.length===0||v.shape[0]===w.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${w.outChannels})`)));let C;if(h!=null){const _=h.shape;if(O(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)O(_[0]===1||_[0]===w.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${w.outChannels}).`);else if(_.length===3)try{Ze(_,w.outShape)}catch{const D=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${w.outShape}).`;throw Error(D)}C=M(h,"prelu weights","fused conv2d")}const N=(_,R)=>{O(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[D,F,L,A]=R,V=Qx(_,L,l);O(Ao(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const q=H2(F.shape,V,D,t,s),ne=EN(F,V,D.shape,t,s),Q=[q,ne];if(A!=null){const B=ew(A,V);Q.push(B)}return Q},k={x:y,filter:m,bias:v,preluActivationWeights:C},E={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return o==null?qa((R,D,F)=>{let L=W.runKernel(Zf,k,E);return F([D,R,L]),b&&(L=J(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:N}})(y,m):qa((R,D,F,L)=>{let A=W.runKernel(Zf,k,E);return L([D,R,A,F]),b&&(A=J(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:N}})(y,m,v)}const Fz=G({fusedConv2d_:Bee});function Vee(n,e,t,s,r,a=[1,1],i){let o=n;n.rank===3&&(o=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=J(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={x:o,dy:l},d={strides:s,pad:r,dimRoundingMode:i,dilations:a,filterShape:t};return W.runKernel(_b,h,d)}const Lz=G({depthwiseConv2dNativeBackpropFilter_:Vee});function Uee(n,e,t,s,r,a=[1,1],i){let o=e,l=!1;e.rank===3&&(l=!0,o=J(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const h={dy:o,filter:t},d={strides:s,pad:r,dimRoundingMode:i,dilations:a,inputShape:n},f=W.runKernel(Ab,h,d);return l?J(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Mz=G({depthwiseConv2dNativeBackpropInput_:Uee});function jee({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:h,leakyreluAlpha:d}){if(nw(W.state.gradientDepth,l)===!1){let E=Yh(n,e,t,s,r,a,i);return o!=null&&(E=we(E,o)),tw(E,l,h,d)}const f=M(n,"x","depthwiseConv2d","float32"),m=M(e,"filter","depthwiseConv2d","float32");let y=f,b=!1;f.rank===3&&(b=!0,y=J(f,[1,f.shape[0],f.shape[1],f.shape[2]])),O(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),O(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),O(y.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),a==null&&(a=[1,1]),O(Zn(t,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ws("fused depthwiseConv2d",s,i);const x=Vn(y.shape,m.shape,t,a,s,i,!0);let w;o!=null&&(w=M(o,"bias","fused conv2d"),[w]=Jt(w,f),Ze(x.outShape,w.shape));let v;h!=null&&(v=M(h,"prelu weights","fused depthwiseConv2d"));const C=(E,_)=>{O(Ao(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[R,D,F,L]=_,A=Qx(E,F,l),V=Mz(D.shape,A,R,t,s,a,i),q=Lz(D,A,R.shape,t,s,a,i);if(L!=null){const ne=ew(w,A);return[V,q,ne]}return[V,q]},N={x:y,filter:m,bias:w,preluActivationWeights:v},k={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:d};return o==null?qa((_,R,D)=>{let F=W.runKernel(Qf,N,k);return D([R,_,F]),b&&(F=J(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:C}})(y,m):qa((_,R,D,F)=>{let L=W.runKernel(Qf,N,k);return F([R,_,L,D]),b&&(L=J(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:C}})(y,m,w)}const Wee=G({fusedDepthwiseConv2d_:jee});function Gee({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(nw(W.state.gradientDepth,a)===!1){let A=rt(n,e,t,s);return r!=null&&(A=we(A,r)),tw(A,a,i,o)}let l=M(n,"a","fused matMul"),h=M(e,"b","fused matMul");[l,h]=Jt(l,h);const d=t?l.shape[l.rank-2]:l.shape[l.rank-1],f=s?h.shape[h.rank-1]:h.shape[h.rank-2],m=t?l.shape[l.rank-1]:l.shape[l.rank-2],y=s?h.shape[h.rank-2]:h.shape[h.rank-1],b=l.shape.slice(0,-2),x=h.shape.slice(0,-2),w=he(b),v=he(x);O(d===f,()=>`Error in fused matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${l.shape} and ${h.shape} and transposeA=${t} and transposeB=${s} must match.`);const N=Ze(l.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,y]),k=t?J(l,[w,d,m]):J(l,[w,m,d]),E=s?J(h,[v,y,f]):J(h,[v,f,y]);let _;r!=null&&(_=M(r,"bias","fused matMul"),[_]=Jt(_,l),Ze(N,_.shape));let R;i!=null&&(R=M(i,"prelu weights","fused matMul"));const D=(A,V)=>{const[q,ne,Q,B]=V,U=Qx(J(A,Q.shape),Q,a);let X,K;if(!t&&!s?(X=rt(U,ne,!1,!0),K=rt(q,U,!0,!1)):!t&&s?(X=rt(U,ne,!1,!1),K=rt(U,q,!0,!1)):t&&!s?(X=rt(ne,U,!1,!0),K=rt(q,U,!1,!1)):(X=rt(ne,U,!0,!0),K=rt(U,q,!0,!0)),r!=null){const se=ew(B,U);return[X,K,se]}else return[X,K]},F={a:k,b:E,bias:_,preluActivationWeights:R},L={transposeA:t,transposeB:s,activation:a,leakyreluAlpha:o};return r==null?qa((V,q,ne)=>{const Q=W.runKernel(Jf,F,L);return ne([V,q,Q]),{value:J(Q,N),gradFunc:D}})(k,E):qa((V,q,ne,Q)=>{const B=W.runKernel(Jf,F,L);return Q([V,q,B,ne]),{value:J(B,N),gradFunc:D}})(k,E,_)}const VT=G({fusedMatMul_:Gee});const zz=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Fz,depthwiseConv2d:Wee,matMul:VT},Symbol.toStringTag,{value:"Module"}));function Hee(n){return Zx(n,.54,.46)}const qee=G({hammingWindow_:Hee});function Kee(n){return Zx(n,.5,.5)}const Pz=G({hannWindow_:Kee});function Xee(n,e,t,s=!1,r=0){let a=0;const i=[];for(;a+e<=n.size;)i.push(dt(n,a,e)),a+=t;if(s)for(;a<n.size;){const o=a+e-n.size,l=ln([dt(n,a,e-o),pu([o],r)]);i.push(l),a+=t}return i.length===0?To([],[0,e]):J(ln(i),[i.length,e])}const Bz=G({frame_:Xee});function Yee(n,e,t,s,r=Pz){s==null&&(s=kN(e));const a=Bz(n,e,t),i=Y(a,r(e));return jm(i,s)}const Jee=G({stft_:Yee});function Zee(n,e,t,s,r="bilinear",a=0){const i=M(n,"image","cropAndResize"),o=M(e,"boxes","cropAndResize","float32"),l=M(t,"boxInd","cropAndResize","int32"),h=o.shape[0];O(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),O(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${o.shape}.`),O(l.rank===1&&l.shape[0]===h,()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${o.shape}.`),O(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),O(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),O(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:i,boxes:o,boxInd:l},f={method:r,extrapolationValue:a,cropSize:s};return W.runKernel(Eb,d,f)}const Qee=G({cropAndResize_:Zee});function ete(n){const e=M(n,"image","flipLeftRight","float32");O(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return W.runKernel(zb,t,{})}const tte=G({flipLeftRight_:ete});function nte(n){const e=M(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),O(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,br(e,r)}const ste=G({grayscaleToRGB_:nte});function rte(n){const e=M(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),O(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,a=Ne(e,"float32"),i=Xn([.2989,.587,.114]);let o;switch(e.rank){case 2:o=Il("ij,j->i",a,i);break;case 3:o=Il("ijk,k->ij",a,i);break;case 4:o=Il("ijkl,l->ijk",a,i);break;case 5:o=Il("ijklm,m->ijkl",a,i);break;case 6:o=Il("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Hn(o,-1),Ne(o,r)}const ate=G({rgbToGrayscale_:rte});function ite(n,e,t=0,s=.5){const r=M(n,"image","rotateWithOffset","float32");O(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},i={radians:e,fillValue:t,center:s};return W.runKernel(wx,a,i)}const ote=G({rotateWithOffset_:ite});function nd(n,e,t,s,r,a){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=n.shape[0];return t=Math.min(t,i),O(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),O(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),O(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),O(e.rank===1,()=>"scores must be a 1D tensor"),O(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),O(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}function lte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const a=M(n,"boxes","nonMaxSuppression","float32"),i=M(e,"scores","nonMaxSuppression","float32"),o=nd(a,i,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return W.runKernel(Kb,{boxes:a,scores:i},l)}const ute=G({nonMaxSuppression_:lte});function cte(n,e,t){const s=hte(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function hte(n,e,t){return fte(n,e,t||dte)}function dte(n,e){return n>e?1:n<e?-1:0}function fte(n,e,t){let s=0,r=n.length,a=0,i=!1;for(;s<r;){a=s+(r-s>>>1);const o=t(e,n[a]);o>0?s=a+1:(r=a,i=!o)}return i?s:-s-1}function sw(n,e,t,s,r){return $N(n,e,t,s,r,0)}function rw(n,e,t,s,r,a){return $N(n,e,t,s,r,0,!1,a,!0)}function aw(n,e,t,s,r,a){return $N(n,e,t,s,r,a,!0)}function $N(n,e,t,s,r,a,i=!1,o=!1,l=!1){const h=[];for(let w=0;w<e.length;w++)e[w]>r&&h.push({score:e[w],boxIndex:w,suppressBeginIndex:0});h.sort(kO);const d=a>0?-.5/a:0,f=[],m=[];for(;f.length<t&&h.length>0;){const w=h.pop(),{score:v,boxIndex:C,suppressBeginIndex:N}=w;if(v<r)break;let k=!1;for(let E=f.length-1;E>=N;--E){const _=pte(n,C,f[E]);if(_>=s){k=!0;break}if(w.score=w.score*mte(s,d,_),w.score<=r)break}w.suppressBeginIndex=f.length,k||(w.score===v?(f.push(C),m.push(w.score)):w.score>r&&cte(h,w,kO))}const y=f.length,b=t-y;o&&b>0&&(f.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const x={selectedIndices:f};return i&&(x.selectedScores=m),l&&(x.validOutputs=y),x}function pte(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),a=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),h=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),y=(o-a)*(l-i),b=(f-h)*(m-d);if(y<=0||b<=0)return 0;const x=Math.max(a,h),w=Math.max(i,d),v=Math.min(o,f),C=Math.min(l,m),N=Math.max(v-x,0)*Math.max(C-w,0);return N/(y+b-N)}function mte(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function kO(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function gte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const a=M(n,"boxes","nonMaxSuppressionAsync"),i=M(e,"scores","nonMaxSuppressionAsync"),o=nd(a,i,t,s,r);t=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),h=l[0],d=l[1],{selectedIndices:f}=sw(h,d,t,s,r);return a!==n&&a.dispose(),i!==e&&i.dispose(),Xn(f,"int32")}const yte=gte;function bte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=M(n,"boxes","nonMaxSuppression"),o=M(e,"scores","nonMaxSuppression"),l=nd(i,o,t,s,r,a);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,a=l.softNmsSigma;const h={boxes:i,scores:o},d={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:a},f=W.runKernel(Yb,h,d);return{selectedIndices:f[0],selectedScores:f[1]}}const xte=G({nonMaxSuppressionWithScore_:bte});async function wte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const i=M(n,"boxes","nonMaxSuppressionAsync"),o=M(e,"scores","nonMaxSuppressionAsync"),l=nd(i,o,t,s,r,a);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,a=l.softNmsSigma;const h=await Promise.all([i.data(),o.data()]),d=h[0],f=h[1],{selectedIndices:m,selectedScores:y}=aw(d,f,t,s,r,a);return i!==n&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:Xn(m,"int32"),selectedScores:Xn(y)}}const vte=wte;function Ste(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=M(n,"boxes","nonMaxSuppression"),o=M(e,"scores","nonMaxSuppression"),l=nd(i,o,t,s,r,null),h=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,m={boxes:i,scores:o},y={maxOutputSize:h,iouThreshold:d,scoreThreshold:f,padToMaxOutputSize:a},b=W.runKernel(Xb,m,y);return{selectedIndices:b[0],validOutputs:b[1]}}const Tte=G({nonMaxSuppressionPadded_:Ste});async function Cte(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const i=M(n,"boxes","nonMaxSuppressionAsync"),o=M(e,"scores","nonMaxSuppressionAsync"),l=nd(i,o,t,s,r,null),h=l.maxOutputSize,d=l.iouThreshold,f=l.scoreThreshold,[m,y]=await Promise.all([i.data(),o.data()]),{selectedIndices:b,validOutputs:x}=rw(m,y,h,d,f,a);return i!==n&&i.dispose(),o!==e&&o.dispose(),{selectedIndices:Xn(b,"int32"),validOutputs:ze(x,"int32")}}const Nte=Cte;function kte(n,e,t=!1,s=!1){const r=M(n,"images","resizeBilinear");O(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),O(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;r.rank===3&&(i=!0,a=J(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:a},l={alignCorners:t,halfPixelCenters:s,size:e},h=W.runKernel(dm,o,l);return i?J(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Vz=G({resizeBilinear_:kte});function Ete(n,e,t=!1,s=!1){const r=M(n,"images","resizeNearestNeighbor");O(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),O(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),O(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,i=!1;r.rank===3&&(i=!0,a=J(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const o={images:a},l={alignCorners:t,halfPixelCenters:s,size:e},h=W.runKernel(hm,o,l);return i?J(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Uz=G({resizeNearestNeighbor_:Ete});function $te(n,e="binary",t=!1,s=.5){const r=M(n,"image","threshold"),a=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1];let h=Y(Xn([s]),255),d,f,m,y;if(O(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),O(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),O(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),O(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,f,m]=Is(r,[1,1,1],-1);const w=Y(d,a),v=Y(f,i),C=Y(m,o);y=we(we(w,v),C)}else y=n;if(e==="otsu"){const w=B2(Ne(zx(y),"int32"),Xs([]),256);h=Ite(w,l)}const b=t?Wo(y,h):vs(y,h);return Ne(Y(b,255),"int32")}function Ite(n,e){let t=Xn([-1]),s=Xn([0]),r=Xn([0]),a,i,o,l,h,d;for(let f=0;f<n.size-1;f++){a=dt(n,0,f+1),i=dt(n,f+1),h=Fe(Re(a),e),d=Fe(Re(i),e);const m=Re(Y(a,eu(0,a.size)));o=Fe(m,Re(a));const y=pu(i.shape,a.size),b=we(eu(0,i.size),y),x=Y(i,b);l=Fe(Re(x),Re(i));const w=Ae(o,l),v=Ae(o,l),C=Y(h,d);r=Y(Y(C,w),v);const N=vs(r,s);s=Mn(N,r,s),t=Mn(N,Xn([f]),t)}return t}const _te=G({threshold_:$te});function Ate(n,e,t="nearest",s="constant",r=0,a){const i=M(n,"image","transform","float32"),o=M(e,"transforms","transform","float32");O(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),O(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),O(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},h={interpolation:t,fillMode:s,fillValue:r,outputShape:a};return W.runKernel(bx,l,h)}const Rte=G({transform_:Ate});function Dte(n,e,t){const s=M(n,"a","bandPart");O(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,i]=s.shape.slice(-2);let o,l;typeof e=="number"?(O(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),O(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),o=M(e<0?a:e,"numLower","bandPart")):(O(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Mn(Bc(e,0),a,Do(e,a))),typeof t=="number"?(O(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),O(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),l=M(t<0?i:t,"numUpper","bandPart")):(O(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Mn(Bc(t,0),i,Do(t,i)));const h=J(eu(0,a,1,"int32"),[-1,1]),d=eu(0,i,1,"int32"),f=Ae(h,d),m=qr(Wo(f,o),Mi(f,Mt(l))),y=gn([a,i],s.dtype);return J(bs(Cr(J(s,[-1,a,i])).map(b=>Mn(m,b,y))),r)}const Ote=G({bandPart_:Dte});function Fte(n){let e;if(Array.isArray(n)){e=!1,O(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let a=1;a<n.length;++a)O(n[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${r})`)}else e=!0,n=Is(n,n.shape[0],0).map(r=>Ho(r,[0]));O(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(W.tidy(()=>{let a=s[r];if(r>0)for(let i=0;i<r;++i){const o=Y(Re(Y(t[i],a)),t[i]);a=Ae(a,o)}return Fe(a,Zh(a,"euclidean"))}));return e?bs(t,0):t}const Lte=G({gramSchmidt_:Fte});function Mte(n,e=!1){if(O(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return EO(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,h)=>l*h),s=Cr(J(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],a=[];s.forEach(l=>{const[h,d]=EO(l,e);r.push(h),a.push(d)});const i=J(bs(r,0),n.shape),o=J(bs(a,0),n.shape);return[i,o]}}function EO(n,e=!1){return W.tidy(()=>{O(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=Ax(t),a=Ba(n);const i=To([[1]],[1,1]);let o=Ba(i);const l=t>=s?s:t;for(let h=0;h<l;++h){const d=a,f=o,m=r;[o,a,r]=W.tidy(()=>{const y=dt(a,[h,h],[t-h,1]),b=Zh(y),x=dt(a,[h,h],[1,1]),w=Mn(vs(x,0),To([[-1]]),To([[1]])),v=Ae(x,Y(w,b)),C=Fe(y,v);C.shape[0]===1?o=Ba(i):o=ln([i,dt(C,[1,0],[C.shape[0]-1,C.shape[1]])],0);const N=Mt(Fe(rt(w,v),b)),k=dt(a,[h,0],[t-h,s]),E=Y(N,o),_=ut(o);if(h===0)a=Ae(k,rt(E,rt(_,k)));else{const F=Ae(k,rt(E,rt(_,k)));a=ln([dt(a,[0,0],[h,s]),F],0)}const R=ut(E),D=dt(r,[0,h],[t,r.shape[1]-h]);if(h===0)r=Ae(D,rt(rt(D,o),R));else{const F=Ae(D,rt(rt(D,o),R));r=ln([dt(r,[0,0],[t,h]),F],1)}return[o,a,r]}),Je([d,f,m])}return!e&&t>s&&(r=dt(r,[0,0],[t,s]),a=dt(a,[0,0],[s,s])),[r,a]})}const zte=G({qr_:Mte});var ms;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ms||(ms={}));function Pte(n,e,t=ms.SUM_BY_NONZERO_WEIGHTS){const s=M(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=M(e,"weights","computeWeightedLoss"));const a=r==null?s:Y(s,r);if(t===ms.NONE)return a;if(t===ms.SUM)return Re(a);if(t===ms.MEAN){if(r==null)return Kt(a);{const i=s.size/r.size,o=Fe(Re(a),Re(r));return i>1?Fe(o,ze(i)):o}}if(t===ms.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Fe(Re(a),ze(s.size));{const i=Y(r,$s(s.shape)),o=Ne(Re(Ql(i,ze(0))),"float32");return Fe(Re(a),o)}}throw Error(`Unknown reduction: ${t}`)}const Pi=G({computeWeightedLoss_:Pte});function Bte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){const r=M(n,"labels","absoluteDifference"),a=M(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=M(t,"weights","absoluteDifference")),Jn(r.shape,a.shape,"Error in absoluteDifference: ");const o=mn(Ae(r,a));return Pi(o,i,s)}const Vte=G({absoluteDifference_:Bte});function Ute(n,e,t,s,r=ms.SUM_BY_NONZERO_WEIGHTS){const a=M(n,"labels","cosineDistance"),i=M(e,"predictions","cosineDistance");let o=null;s!=null&&(o=M(s,"weights","cosineDistance")),Jn(a.shape,i.shape,"Error in cosineDistance: ");const l=ze(1),h=Ae(l,Re(Y(a,i),t,!0));return Pi(h,o,r)}const jte=G({cosineDistance_:Ute});function Wte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){let r=M(n,"labels","hingeLoss");const a=M(e,"predictions","hingeLoss");let i=null;t!=null&&(i=M(t,"weights","hingeLoss")),Jn(r.shape,a.shape,"Error in hingeLoss: ");const o=ze(1);r=Ae(Y(ze(2),r),o);const l=Ta(Ae(o,Y(r,a)));return Pi(l,i,s)}const Gte=G({hingeLoss_:Wte});function Hte(n,e,t,s=1,r=ms.SUM_BY_NONZERO_WEIGHTS){const a=M(n,"labels","huberLoss"),i=M(e,"predictions","huberLoss");let o=null;t!=null&&(o=M(t,"weights","huberLoss")),Jn(a.shape,i.shape,"Error in huberLoss: ");const l=ze(s),h=mn(Ae(i,a)),d=Do(h,l),f=Ae(h,d),m=we(Y(ze(.5),$t(d)),Y(l,f));return Pi(m,o,r)}const qte=G({huberLoss_:Hte});function Kte(n,e,t,s=1e-7,r=ms.SUM_BY_NONZERO_WEIGHTS){const a=M(n,"labels","logLoss"),i=M(e,"predictions","logLoss");let o=null;t!=null&&(o=M(t,"weights","logLoss")),Jn(a.shape,i.shape,"Error in logLoss: ");const l=ze(1),h=ze(s),d=Mt(Y(a,Js(we(i,h)))),f=Y(Ae(l,a),Js(we(Ae(l,i),h))),m=Ae(d,f);return Pi(m,o,r)}const Xte=G({logLoss_:Kte});function Yte(n,e,t,s=ms.SUM_BY_NONZERO_WEIGHTS){const r=M(n,"labels","meanSquaredError"),a=M(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=M(t,"weights","meanSquaredError")),Jn(r.shape,a.shape,"Error in meanSquaredError: ");const o=Hx(r,a);return Pi(o,i,s)}const Jte=G({meanSquaredError_:Yte});function Zte(n,e){const t=M(n,"labels","sigmoidCrossEntropyWithLogits"),s=M(e,"logits","sigmoidCrossEntropyWithLogits");Jn(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Ta(s),a=Y(s,t),i=Rm(Ds(Mt(mn(s))));return we(Ae(r,a),i)}function Qte(n,e,t,s=0,r=ms.SUM_BY_NONZERO_WEIGHTS){let a=M(n,"multiClassLabels","sigmoidCrossEntropy");const i=M(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=M(t,"weights","sigmoidCrossEntropy")),Jn(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const h=ze(s),d=ze(1),f=ze(.5);a=we(Y(a,Ae(d,h)),Y(f,h))}const l=Zte(a,i);return Pi(l,o,r)}const ene=G({sigmoidCrossEntropy_:Qte});function tne(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return qa((r,a,i)=>{const l=Dm(a,[t],!0),h=Ae(Ne(a,"float32"),l);i([r,h]);const d=Mt(Y(h,r));return{value:Re(d,[t]),gradFunc:(y,b)=>{const[x,w]=b,v=un(y.shape,[t]);return[Y(J(y,v),Ae(Ne(x,"float32"),Ds(w))),Y(J(y,v),Ae(Ds(w),Ne(x,"float32")))]}}})(n,e)}function nne(n,e,t,s=0,r=ms.SUM_BY_NONZERO_WEIGHTS){let a=M(n,"onehotLabels","softmaxCrossEntropy");const i=M(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=M(t,"weights","softmaxCrossEntropy")),Jn(a.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const h=ze(s),d=ze(1),f=ze(a.shape[1]);a=we(Y(a,Ae(d,h)),Fe(h,f))}const l=tne(a,i);return Pi(l,o,r)}const sne=G({softmaxCrossEntropy_:nne});function rne(n,e,t,s){const r=M(n,"indices","sparseFillEmptyRows","int32"),a=M(e,"values","sparseFillEmptyRows"),i=M(t,"denseShape","sparseFillEmptyRows","int32"),o=M(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:r,values:a,denseShape:i,defaultValue:o},h=W.runKernel(ox,l);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}const ane=G({sparseFillEmptyRows_:rne});function ine(n,e,t){const s=M(n,"inputIndices","sparseReshape","int32"),r=M(e,"inputShape","sparseReshape","int32"),a=M(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:s,inputShape:r,newShape:a},o=W.runKernel(lx,i);return{outputIndices:o[0],outputShape:o[1]}}const one=G({sparseReshape_:ine});function lne(n,e,t){const s=M(n,"data","sparseSegmentMean"),r=M(e,"indices","sparseSegmentMean","int32"),a=M(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const i={data:s,indices:r,segmentIds:a};return W.runKernel(ux,i)}const une=G({sparseSegmentMean_:lne});function cne(n,e,t){const s=M(n,"data","sparseSegmentSum"),r=M(e,"indices","sparseSegmentSum","int32"),a=M(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const i={data:s,indices:r,segmentIds:a};return W.runKernel(cx,i)}const hne=G({sparseSegmentSum_:cne});function dne(n,e,t,s,r,a,i,o){const l=M(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const h=M(e,"dataSplits","stringNGrams");if(h.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const d={separator:t,nGramWidths:s,leftPad:r,rightPad:a,padWidth:i,preserveShortSequences:o},f={data:l,dataSplits:h},m=W.runKernel(px,f,d);return{nGrams:m[0],nGramsSplits:m[1]}}const fne=G({stringNGrams_:dne});function pne(n,e,t=!0){const s=M(n,"input","stringSplit","string"),r=M(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:t},i={input:s,delimiter:r},o=W.runKernel(mx,i,a);return{indices:o[0],values:o[1],shape:o[2]}}const mne=G({stringSplit_:pne});function gne(n,e){const t=M(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return W.runKernel(gx,r,s)}const yne=G({stringToHashBucketFast_:gne});function bne(n,e,t,s=!0){const r=M(n,"input","staticRegexReplace","string"),a={pattern:e,rewrite:t,replaceGlobal:s};return W.runKernel(wm,{x:r},a)}const xne=G({staticRegexReplace_:bne});const jz={fft:Um,ifft:Wc,rfft:jm,irfft:Gx},Wz={hammingWindow:qee,hannWindow:Pz,frame:Bz,stft:Jee},Wr={flipLeftRight:tte,grayscaleToRGB:ste,resizeNearestNeighbor:Uz,resizeBilinear:Vz,rgbToGrayscale:ate,rotateWithOffset:ote,cropAndResize:Qee,nonMaxSuppression:ute,nonMaxSuppressionAsync:yte,nonMaxSuppressionWithScore:xte,nonMaxSuppressionWithScoreAsync:vte,nonMaxSuppressionPadded:Tte,nonMaxSuppressionPaddedAsync:Nte,threshold:_te,transform:Rte},IN={bandPart:Ote,gramSchmidt:Lte,qr:zte},Gz={absoluteDifference:Vte,computeWeightedLoss:Pi,cosineDistance:jte,hingeLoss:Gte,huberLoss:qte,logLoss:Xte,meanSquaredError:Jte,sigmoidCrossEntropy:ene,softmaxCrossEntropy:sne},Hz={sparseFillEmptyRows:ane,sparseReshape:one,sparseSegmentMean:une,sparseSegmentSum:hne},qz={stringNGrams:fne,stringSplit:mne,stringToHashBucketFast:yne,staticRegexReplace:xne};const wne=new Map,UT=new Map;class yu{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yr{constructor(){this.classNameMap={}}static getMap(){return yr.instance==null&&(yr.instance=new yr),yr.instance}static register(e){yr.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ve(n,e,t){O(n.className!=null,()=>"Class being registered does not have the static className property defined."),O(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),O(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,r=e+">"+s;return yr.register(n),wne.set(r,n),UT.set(n,r),n}function vne(n){return UT.has(n)?UT.get(n):n.className}const Sne=Object.freeze(Object.defineProperty({__proto__:null,Serializable:yu,SerializationMap:yr,getRegisteredName:vne,registerClass:ve},Symbol.toStringTag,{value:"Module"}));class Bi extends yu{minimize(e,t=!1,s){const{value:r,grads:a}=this.computeGradients(e,s);if(s!=null){const i=s.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return Je(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return QM(e,t)}dispose(){this.iterations_!=null&&Je(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ze(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Bi,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class _N extends Bi{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=W.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:re(()=>ft(a).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:re(()=>ft(a).variable(i))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;re(()=>{const d=we(Y(l,this.rho),Y($t(o),1-this.rho)),f=Y(Fe(Pn(we(h,this.epsilon)),Pn(we(l,this.epsilon))),o),m=we(Y(h,this.rho),Y($t(f),1-this.rho));l.assign(d),h.assign(m);const y=we(Y(f,-this.learningRate),a);a.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Je(this.accumulatedGrads.map(e=>e.variable)),Je(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class AN extends Bi{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=W.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:re(()=>pu(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const o=this.accumulatedGrads[r].variable;re(()=>{const l=we(o,$t(i));o.assign(l);const h=we(Y(Fe(i,Pn(we(l,W.backend.epsilon()))),-this.learningRate),a);a.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Je(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class RN extends Bi{static get className(){return"Adam"}constructor(e,t,s,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],re(()=>{this.accBeta1=ze(t).variable(),this.accBeta2=ze(s).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);re(()=>{const s=Ae(1,this.accBeta1),r=Ae(1,this.accBeta2);t.forEach((a,i)=>{const o=W.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:re(()=>ft(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:re(()=>ft(o).variable(l))});const h=Array.isArray(e)?e[i].tensor:e[a];if(h==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedSecondMoment[i].variable,m=we(Y(d,this.beta1),Y(h,1-this.beta1)),y=we(Y(f,this.beta2),Y($t(h),1-this.beta2)),b=Fe(m,s),x=Fe(y,r);d.assign(m),f.assign(y);const w=we(Y(Fe(b,we(Pn(x),this.epsilon)),-this.learningRate),o);o.assign(w)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Je(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Je(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),re(()=>{this.accBeta1.assign(Ha(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ha(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class DN extends Bi{static get className(){return"Adamax"}constructor(e,t,s,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],re(()=>{this.iteration=ze(0).variable(),this.accBeta1=ze(t).variable()}),r==null&&(this.epsilon=W.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);re(()=>{const s=Ae(1,this.accBeta1),r=Fe(-this.learningRate,we(Y(this.iteration,this.decay),1));t.forEach((a,i)=>{const o=W.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:ft(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:ft(o).variable(l)});const h=Array.isArray(e)?e[i].tensor:e[a];if(h==null)return;const d=this.accumulatedFirstMoment[i].variable,f=this.accumulatedWeightedInfNorm[i].variable,m=we(Y(d,this.beta1),Y(h,1-this.beta1)),y=Y(f,this.beta2),b=mn(h),x=Xa(y,b);d.assign(m),f.assign(x);const w=we(Y(Fe(r,s),Fe(m,we(x,this.epsilon))),o);o.assign(w)}),this.iteration.assign(we(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Je(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Je(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class iw extends Bi{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const i=W.registeredVariables[s];re(()=>{const o=we(Y(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=En(ze(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class ON extends iw{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=ze(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=W.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:re(()=>ft(a).variable(!1))});const i=this.accumulations[r].variable,o=Array.isArray(e)?e[r].tensor:e[s];o!=null&&re(()=>{let l;const h=we(Y(this.m,i),o);this.useNesterov?l=we(Y(this.c,we(o,Y(h,this.m))),a):l=we(Y(this.c,h),a),i.assign(h),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Je(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class FN extends Bi{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=W.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=W.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:re(()=>ft(a).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:re(()=>ft(a).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:re(()=>ft(a).variable(i))});const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const l=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;re(()=>{const d=we(Y(l,this.decay),Y($t(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[r].variable,m=we(Y(f,this.decay),Y(o,1-this.decay)),y=Fe(Y(o,this.learningRate),Pn(Ae(d,we($t(m),this.epsilon)))),b=we(Y(h,this.momentum),y);l.assign(d),f.assign(m),h.assign(b);const x=Ae(a,b);a.assign(x)}else{const f=we(Y(l,this.decay),Y($t(o),1-this.decay)),m=we(Y(h,this.momentum),Fe(Y(o,this.learningRate),Pn(we(f,this.epsilon))));l.assign(f),h.assign(m);const y=Ae(a,m);a.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Je(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Je(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Je(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Tne=[_N,AN,RN,DN,ON,FN,iw];function Cne(){for(const n of Tne)ve(n)}const Nne="model",kne=".json",Ene=".weights.bin";function $O(n){return new Promise(e=>setTimeout(e)).then(n)}class tu{constructor(e){if(!ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(tu.URL_SCHEME)&&(e=e.slice(tu.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Nne),this.modelJsonFileName=e+kne,this.weightDataFileName=e+Ene}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Sa.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=DM(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await $O(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await $O(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Nm(e)}}}}tu.URL_SCHEME="downloads://";class $ne{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const a=JSON.parse(r.target.result),i=a.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const l=N2(a,h=>this.loadWeights(h));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const i of e)t.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),a=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(a).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((s,r)=>{const a=new FileReader;a.onload=i=>{const o=i.target.result;s(o)},a.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(a=>yO(a.name)),r={};for(const a of e)a.paths.forEach(i=>{const o=yO(i);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const Ine=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(tu.URL_SCHEME)?_ne(n.slice(tu.URL_SCHEME.length)):null;qt.registerSaveRouter(Ine);function _ne(n="model"){return new tu(n)}function Ane(n){return new $ne(n)}function IO(n,e,t,s){i(n),t=t??0,s=s??1,o(t,s);let r=0;const a=l=>(l.then(h=>{const d=t+ ++r/n.length*(s-t);return e(d),h}),l);function i(l){O(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,h){O(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),O(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${h}`),O(h>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${h}`)}return Promise.all(n.map(a))}async function Kz(n,e){e==null&&(e={});const t=e.fetchFunc==null?ie().platform.fetch:e.fetchFunc,s=n.map(f=>t(f,e.requestInit,{isBinary:!0})),o=(e.onProgress==null?await Promise.all(s):await IO(s,e.onProgress,0,.5)).map(f=>f.arrayBuffer());return e.onProgress==null?await Promise.all(o):await IO(o,e.onProgress,.5,1)}function Rne(n,e){var t;const s=e.fetchFunc==null?ie().platform.fetch:e.fetchFunc;let r=0,a;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var o;r<n.length;){a||(a=(await s(n[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:h}=await a.read();if(l){r++,a=void 0,(o=e.onProgress)===null||o===void 0||o.call(e,r/n.length);continue}i.enqueue(h);return}i.close()}})}async function Xz(n,e="",t,s){return Yz(i=>Kz(i,{requestInit:s}))(n,e,t)}function Yz(n){return async(e,t="",s)=>{const r=e.map(()=>!1),a={},i=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((y,b)=>{let x=0;y.weights.forEach(w=>{const v="quantization"in w?w.quantization.dtype:w.dtype,C=ql[v]*he(w.shape),N=()=>{r[b]=!0,a[b]==null&&(a[b]=[]),a[b].push({manifestEntry:w,groupOffset:x,sizeBytes:C})};s!=null?s.forEach((k,E)=>{k===w.name&&(N(),i[E]=!0)}):N(),o.push(w.name),x+=C})}),!i.every(y=>y)){const y=s.filter((b,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${y.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=r.reduce((y,b,x)=>(b&&y.push(x),y),[]),h=[];l.forEach(y=>{e[y].paths.forEach(b=>{const x=t+(t.endsWith("/")?"":"/")+b;h.push(x)})});const d=await n(h),f={};let m=0;return l.forEach(y=>{const b=e[y].paths.length,x=new Sa(d.slice(m,m+b));a[y].forEach(v=>{const C=x.slice(v.groupOffset,v.groupOffset+v.sizeBytes),N=S2(C,[v.manifestEntry]);for(const k in N)f[k]=N[k]}),m+=b}),f}}const Dne="application/octet-stream",One="application/json";class LN{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(O(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ie().platform.fetch,O(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&O(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=DM(e,s);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:One}),"model.json"),e.weightData!=null){const i=Sa.join(e.weightData);t.body.append("model.weights.bin",new Blob([i],{type:Dne}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Nm(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return N2(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),s=D0(e.weightsManifest),r=()=>Rne(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=Fne(t),a=this.weightPathPrefix||s,i=[],o=[];for(const l of e)for(const h of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(h)):i.push(a+h+r);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(e){const t=await this.getWeightUrls(e),s=D0(e),r=await Kz(t,this.loadOptions);return[s,r]}}LN.URL_SCHEME_REGEX=/^https?:\/\//;function Fne(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function jT(n){return n.match(LN.URL_SCHEME_REGEX)!=null}const Jz=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>jT(s)):t=jT(n),t)return MN(n,e)}return null};qt.registerSaveRouter(Jz);qt.registerLoadRouter(Jz);function MN(n,e){return new LN(n,e)}function Zz(n,e){return MN(n,e)}class DS{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Qz{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Lne{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function eP(n,e,t,s){const r=arguments;return new Lne(F0(...r))}function F0(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new DS(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new DS({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new DS({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function Mne(n){return new Qz(n)}function zne(n){return new Qz(n)}const zN=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Sa,browserFiles:Ane,browserHTTPRequest:Zz,concatenateArrayBuffers:RM,copyModel:yY,decodeWeights:S2,decodeWeightsStream:AM,encodeWeights:FT,fromMemory:eP,fromMemorySync:F0,getLoadHandlers:FM,getModelArtifactsForJSON:N2,getModelArtifactsForJSONSync:C2,getModelArtifactsInfoForJSON:Nm,getSaveHandlers:OM,getWeightSpecs:D0,http:MN,isHTTPScheme:jT,listModels:mY,loadWeights:Xz,moveModel:bY,registerLoadRouter:sY,registerSaveRouter:nY,removeModel:gY,weightsLoaderFactory:Yz,withSaveHandler:Mne,withSaveHandlerSync:zne},Symbol.toStringTag,{value:"Module"}));function Pne(n,e,t){const s=M(n,"labels","confusionMatrix"),r=M(e,"predictions","confusionMatrix");O(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),O(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),O(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),O(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),O(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const a=Vc(Ne(s,"int32"),t),i=Vc(Ne(r,"int32"),t),o=ut(a),l=rt(o,i);return Ne(l,"int32")}const Bne=G({confusionMatrix_:Pne});const Vne=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Bne},Symbol.toStringTag,{value:"Module"}));let wl,_O=!1;function tP(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,a=!1,i=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)a=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(tp(A0,W.backendName)!=null){const b={pixels:n},x={numChannels:e};return W.runKernel(A0,b,x)}const[h,d]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let f;if(i)f=n.getContext("2d").getImageData(0,0,h,d).data;else if(s||t)f=n.data;else if(a||r||o){if(wl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")wl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else wl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});wl.canvas.width=h,wl.canvas.height=d,wl.drawImage(n,0,0,h,d),f=wl.getImageData(0,0,h,d).data}let m;if(e===4)m=new Int32Array(f);else{const b=h*d;m=new Int32Array(b*e);for(let x=0;x<b;x++)for(let w=0;w<e;++w)m[x*e+w]=f[x*4+w]}return qx(m,[d,h,e],"int32")}function Une(n){return n!=null&&n.data instanceof Uint8Array}function jne(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Wne(n){return n!=null&&n.width!==0&&n.height!==0}function Gne(n){return jne()&&!(n instanceof ImageBitmap)&&Wne(n)&&!Une(n)}async function Hne(n,e=3){let t=null;if(ie().getBool("WRAP_TO_IMAGEBITMAP")&&Gne(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return tP(t,e)}function nP(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function qne(n){const e=n?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function Kne(n,e){let t=M(n,"img","toPixels");if(!(n instanceof bt)){const h=t;t=Ne(h,"int32"),h.dispose()}nP(t);const[s,r]=t.shape.slice(0,2),a=t.rank===2?1:t.shape[2],i=await t.data(),o=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(r*s*4);for(let h=0;h<s*r;++h){const d=[0,0,0,255];for(let m=0;m<a;m++){const y=i[h*a+m];if(t.dtype==="float32"){if(y<0||y>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${y}.`)}else if(t.dtype==="int32"&&(y<0||y>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${y}.`);a===1?(d[0]=y*o,d[1]=y*o,d[2]=y*o):d[m]=y*o}const f=h*4;l[f+0]=Math.round(d[0]),l[f+1]=Math.round(d[1]),l[f+2]=Math.round(d[2]),l[f+3]=Math.round(d[3])}if(e!=null){_O||tp(Db,W.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),_O=!0),e.width=r,e.height=s;const h=e.getContext("2d"),d=new ImageData(l,r,s);h.putImageData(d,0,0)}return t!==n&&t.dispose(),l}function Xne(n,e,t){let s=M(n,"img","draw");if(!(n instanceof bt)){const i=s;s=Ne(i,"int32"),i.dispose()}nP(s),qne(t?.imageOptions);const r={image:s},a={canvas:e,options:t};W.runKernel(Db,r,a)}const sP=G({fromPixels_:tP}),Yne=Object.freeze(Object.defineProperty({__proto__:null,draw:Xne,fromPixels:sP,fromPixelsAsync:Hne,toPixels:Kne},Symbol.toStringTag,{value:"Module"}));function ow(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(he(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,a=r[r.length-1];let i=1;for(let f=0;f<r.length-1;++f)i*=r[f];const o=n.shape,l=r.slice();l.pop();let h=1;for(let f=a;f<t;++f)h*=o[f],l.push(o[f]);const d=[...Pe(n.shape).map(f=>f/h),1].slice(0,a);return[l,i,h,d]}const Jne=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:ow},Symbol.toStringTag,{value:"Module"}));const WT=-2,Zne=-1;function PN(n,e,t){const s=n.shape.length;O(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),O(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)O(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function Qne(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function BN(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function rP(n,e,t,s){const r=[...n];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<t;a++)a===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function aP(n,e,t){return t<=n?t:t-(e-1)}function iP(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function ese(n,e,t,s,r,a,i,o,l){const h=n.length;let d=new Array(h),f=new Array(h),m=new Array(h);if(e.length&&t>0){const y=e[0],b=t+1;d=oP(i,y,b,s,n),f=lP(o,y,b,r,n),m=rP(a,y,b,n)}else for(let y=0;y<h;y++)d[y]=cP(i,s,a,n,y,l),f[y]=hP(o,r,a,n,y,l),m[y]=uP(a,y,l);return{begin:d,end:f,strides:m}}function oP(n,e,t,s,r){const a=[...r],i=iP(t,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const l=aP(e,t,o);let h=s[l];n&1<<l&&(h=0),a[o]=h}return a}function lP(n,e,t,s,r){const a=[...r],i=iP(t,e);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=aP(e,t,o);let h=s[l];n&1<<l&&(h=Number.MAX_SAFE_INTEGER),a[o]=h}for(let o=0;o<a.length;o++){const l=r[o];a[o]<0&&(a[o]+=l),a[o]=$o(0,a[o],r[o])}return a}function uP(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function cP(n,e,t,s,r,a){let i=e[r];const o=t[r]||1;(n&1<<r||a&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),i=$o(0,i,l-1),i}function hP(n,e,t,s,r,a){let i=e[r];const o=t[r]||1;(n&1<<r||a&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=s[r];return i<0&&(i+=l),o>0?i=$o(0,i,l):i=$o(-1,i,l-1),i}function VN(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function UN(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function lw(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{O(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return t==null?a=new Array(r).fill(-1):typeof t=="number"?a=[t,...new Array(r-1).fill(-1)]:t.length<r?a=t.concat(new Array(r-t.length).fill(-1)):a=t,a=a.map((i,o)=>i>=0?i:(O(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,a]}function jN(n,e,t,s,r,a,i,o,l){let h;if(s==null?(h=new Array(e.length),h.fill(1)):h=s,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const f={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:h.slice(),beginMask:r,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let N=0;N<f.dims;N++)d&&(1<<N&o)!==0&&f.numAddAxisAfterEllipsis++,1<<N&i&&(d=!0);d||(f.ellipsisMask|=1<<f.dims,f.dims++);const m={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};tse(f,m);let y=!0,b=!0,x=!0;const w=[],v=[];for(let N=0;N<n.length;++N){if(m.strides[N]===0)throw Error(`strides[${N}] must be non-zero`);const k=!!(m.shrinkAxisMask&1<<N),E=n[N];if(E===-1){w.push(k?1:-1);continue}const _=[m.beginMask&1<<N,m.endMask&1<<N],R=[m.strides[N]>0?0:-1,m.strides[N]>0?E:E-1];if(k&&m.strides[N]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&m.strides[N]===1;const D=!!(m.beginMask&1<<N&&m.endMask&1<<N);if(m.beginValid&&m.endValid){if(k){const V=m.begin[N]<0?E+m.begin[N]:m.begin[N];if(m.begin[N]=V,m.end[N]=m.begin[N]+1,V<0||V>=E)throw Error(`slice index ${m.begin[N]} of dimension ${N} out of bounds.`)}else m.begin[N]=AO(m.begin[N],0,m.strides[N],E,_,R),m.end[N]=AO(m.end[N],1,m.strides[N],E,_,R);const A=m.strides[N]===1&&m.begin[N]===0&&m.end[N]===E;y=y&&A,b=b&&(N===0&&m.strides[N]===1||A)}else y=y&&m.strides[N]===1&&D,b=b&&(N===0&&m.strides[N]===1||D);let F,L=!1;if(m.beginValid&&m.endValid?(F=m.end[N]-m.begin[N],L=!0):k?(F=1,L=!0):D&&E>=0&&(m.strides[N]<0?F=-E:F=E,L=!0),L){let A;F===0||F<0!=m.strides[N]<0?A=0:A=Math.trunc(F/m.strides[N])+(F%m.strides[N]!==0?1:0),w.push(A)}else w.push(-1)}for(let N=0;N<m.finalShapeGatherIndices.length;++N){const k=m.finalShapeGatherIndices[N];k>=0?v.push(w[k]):k===WT&&v.push(1)}return{finalShapeSparse:v.filter((N,k)=>m.finalShapeGatherIndices[k]!==WT),finalShape:v,isIdentity:y,sliceDim0:b,isSimpleSlice:x,begin:m.begin,end:m.end,strides:m.strides}}function tse(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(WT),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(Zne),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function AO(n,e,t,s,r,a){if(r[e])return t>0?a[e]:a[e+1&1];{const i=n<0?s+n:n;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const dP=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:PN,computeFlatOffset:UN,computeOutShape:BN,getNormalizedAxes:ese,isSliceContinous:VN,maskToAxes:Qne,parseSliceParams:lw,sliceInfo:jN,startForAxis:cP,startIndicesWithElidedDims:oP,stopForAxis:hP,stopIndicesWithElidedDims:lP,stridesForAxis:uP,stridesWithElidedDims:rP},Symbol.toStringTag,{value:"Module"}));const fP="4.22.0";class pP{static sgd(e){return new iw(e)}static momentum(e,t,s=!1){return new ON(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,a=!1){return new FN(e,t,s,r,a)}static adam(e=.001,t=.9,s=.999,r=null){return new RN(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new _N(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,a=0){return new DN(e,t,s,r,a)}static adagrad(e,t=.1){return new AN(e,t)}}const Nl=pP;const nse=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function WN(){return new Promise(n=>nse(()=>n()))}function GN(n,e){const t=n[0].length;n.forEach((r,a)=>{O(r.length===t,()=>`Error in concat${t}D: rank of tensors[${a}] must be the same as the rank of the rest (${t})`)}),O(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,a)=>{for(let i=0;i<t;i++)O(i===e||r[i]===s[i],()=>`Error in concat${t}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function Va(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}var da;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(da||(da={}));function mP(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let r=1;r<t.length;++r){const a=t[r],i=s[s.length-t.length+r],o=s[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+n}] = ${a} but shape[${r+n}] = ${o}`)}else s[i]=a}return s}function gP(n){const e={FIRST_DIM_SIZE:da.FIRST_DIM_SIZE,VALUE_ROWIDS:da.VALUE_ROWIDS,ROW_LENGTHS:da.ROW_LENGTHS,ROW_SPLITS:da.ROW_SPLITS,ROW_LIMITS:da.ROW_LIMITS,ROW_STARTS:da.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function yP(n){return n.length===0?0:n[0]===da.FIRST_DIM_SIZE?n.length-1:n.length}function bP(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(t,s-1);++r){const a=n[r],i=e[r+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-n.length}] = ${a} but ragged tensor input.flatValues.shape[${r-n.length}] = ${i}`)}}const HN=30;function uw(n){return n<=HN?n:$0(n,Math.floor(Math.sqrt(n)))}function qN(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}function Wm(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const a=e.length;for(let i=0;i<a;++i)r=r.concat([n[i+1]/e[i],e[i]]);r=r.concat(n.slice(a+1))}return r}function Gm(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],a=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?a.push(i):r.push(i);s.push(...r),s.push(0),s.push(...a)}return s}function Hm(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let a=1;a<n.length;++a)a<=e.length?s?r.push(e[a-1]*n[a]):r.push(n[a]/e[a-1]):r.push(n[a]);return r}function KN(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function XN(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}const cw=1.7580993408473768,hw=1.0507009873554805;const YN=.3275911,JN=.254829592,ZN=-.284496736,QN=1.421413741,ek=-1.453152027,tk=1.061405429;function _i(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function xP(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function wP(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function vP(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function nk(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function SP(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function TP(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const a=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:t,imag:s}}function CP(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),a=Math.sin(s);return{real:r,imag:a}}const OS="->",sse=/->/g,RO=",",DO="...";function sk(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(sse,"").length)/OS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${OS}").`);const[s,r]=n.split(OS);O(s.indexOf(DO)===-1,()=>`The ellipsis notation ("${DO}") is not supported yet.`);const a=s.split(RO),i=a.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let m=0;m<r.length;++m){const y=r[m];if(!a.some(b=>b.indexOf(y)!==-1))throw new Error(`Output subscripts contain the label ${y} not present in the input subscripts.`);o.indexOf(y)===-1&&o.push(y)}for(let m=0;m<s.length;++m){const y=s[m];o.indexOf(y)===-1&&y!==RO&&o.push(y)}const l=new Array(a.length);for(let m=0;m<i;++m){if(new Set(a[m].split("")).size!==a[m].length)throw new Error(`Found duplicate axes in input component ${a[m]}. Support for duplicate axes in input is not implemented yet.`);l[m]=[];for(let y=0;y<a[m].length;++y)l[m].push(o.indexOf(a[m][y]))}const h=o.length,d=r.length,f=[];for(let m=d;m<h;++m)f.push(m);return{allDims:o,summedDims:f,idDims:l}}function rk(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function ak(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const a=t[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=a[i]:O(s[e[r][i]]===a[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function ik(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let i=0;i<r;++i)s.push([]);const a=[];for(let i=0;i<t.length;++i){const o=t[i],l=rse(e,o);for(const h of l)a.indexOf(h)===-1&&(s[i].push(h),a.push(h))}return{path:t,steps:s}}function ok(n){return n.every((e,t)=>e===t)}function rse(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function lk(n,e,t=0){let s=[];if(typeof e=="number")O(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((i,o)=>(o===-1&&(i+=1),i),0);O(r<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const i=e.reduce((o,l)=>l>0?o+l:o);e[a]=n.shape[t]-i}O(n.shape[t]===e.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}function NP(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function kP(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function EP(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}function $P(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function IP(n,e){return`size ${n} must be non-negative, not ${e}`}function _P(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function AP(n,e){const t=he(n),s=he(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function RP(n,e){const t=he(n),s=he(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}function GT(){return"segment ids must be >= 0"}function DP(){return"segment ids are not increasing"}function OP(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function FP(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}function LP(n,e){let t=!1,s;for(n<=HN?(s=n,t=!0):s=$0(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=$0(n,s+1);return s}function MP(n,e,t){const s=[],r=n.length;for(let a=0;a<r;a++)a!==e?s.push(n[a]):s.push(t);return s}function uk(n,e,t,s){const r=e.shape.length,a=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let f=0;f<s;++f)if(n.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const i=n.shape[t],o=[];let l=1,h=1,d=1;for(let f=0;f<s;++f)o.push(n.shape[f]),l*=n.shape[f];for(let f=s;f<t;f++)o.push(n.shape[f]),h*=n.shape[f];for(let f=s;f<r;f++)o.push(e.shape[f]);for(let f=t+1;f<a;f++)o.push(n.shape[f]),d*=n.shape[f];return{batchSize:l,sliceSize:d,outerSize:h,dimSize:i,outputShape:o}}const ase=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:uk,computeOutShape:MP,segOpComputeOptimalWindowSize:LP},Symbol.toStringTag,{value:"Module"}));function Ai(n){try{return n.map(e=>ki(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function zP(n){return n.map(e=>Pa(e))}const PP=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:JN,ERF_A2:ZN,ERF_A3:QN,ERF_A4:ek,ERF_A5:tk,ERF_P:YN,PARALLELIZE_THRESHOLD:HN,get RowPartitionType(){return da},SELU_SCALE:hw,SELU_SCALEALPHA:cw,applyActivation:tw,assertAndGetBroadcastShape:Ze,assertAxesAreInnerMostDims:Qn,assertParamsConsistent:GN,assignToTypedArray:SP,axesAreInnerMostDims:Q2,calculateShapes:qo,checkEinsumDimSizes:ak,checkPadOnDimRoundingMode:ws,combineLocations:YM,combineRaggedTensorToTensorShapes:mP,complexWithEvenIndex:wP,complexWithOddIndex:vP,computeConv2DInfo:Vn,computeConv3DInfo:Uo,computeDefaultPad:F2,computeDilation2DInfo:km,computeOptimalWindowSize:uw,computeOutAndReduceShapes:Un,computeOutShape:Va,computePool2DInfo:Kr,computePool3DInfo:Fi,convertConv2DDataFormat:Li,decodeEinsumEquation:sk,eitherStridesOrDilationsAreOne:Zn,expandShapeToKeepDim:un,exponent:CP,exponents:TP,fromStringArrayToUint8:zP,fromUint8ToStringArray:Ai,getAxesPermutation:Zt,getBroadcastDims:Zl,getComplexWithIndex:nk,getEinsumComputePath:ik,getEinsumPermutation:rk,getFusedBiasGradient:ew,getFusedDyActivation:Qx,getImageCenter:qN,getInnerMostAxes:cn,getPermuted:Gm,getRaggedRank:yP,getReductionAxes:xn,getReshaped:Wm,getReshapedPermuted:Hm,getRowPartitionTypesHelper:gP,getSliceBeginCoords:KN,getSliceSize:XN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:NP,getSparseFillEmptyRowsNegativeIndexErrorMessage:kP,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:EP,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:_P,getSparseReshapeInputOutputMismatchErrorMessage:RP,getSparseReshapeInputOutputMultipleErrorMessage:AP,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:$P,getSparseReshapeNegativeOutputDimErrorMessage:IP,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:FP,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:GT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:DP,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:OP,getUndoAxesPermutation:jo,isIdentityPermutation:ok,log:s7,mergeRealAndImagArrays:_i,prepareAndValidate:ow,prepareSplitSize:lk,segment_util:ase,shouldFuse:nw,slice_util:dP,splitRealAndImagArrays:xP,stridesOrDilationsArePositive:Jl,tupleValuesAreOne:Ao,upcastType:_s,validateDefaultValueShape:bP,validateInput:Kx,validateUpdateShape:wN,warn:gr},Symbol.toStringTag,{value:"Module"}));const ise=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:sw,nonMaxSuppressionV4Impl:rw,nonMaxSuppressionV5Impl:aw,whereImpl:Jx},Symbol.toStringTag,{value:"Module"}));Cne();const BP={kernelName:vp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,gu(Ne(t,"float32"),-1))}}};const ose={kernelName:eh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=$t(Ne(t,"float32")),r=Pn(Ae(ze(1),s));return Mt(Fe(n,r))}}}};const lse={kernelName:th,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pn(Ae($t(Ne(t,"float32")),1));return Fe(n,s)}}}};const use={kernelName:fu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{let o=n;const l=xn(t.shape,r);return l.length>0&&(o=Re(o,l)),J(o,t.shape)},b:()=>{let o=n;const l=xn(s.shape,r);return l.length>0&&(o=Re(o,l)),J(o,s.shape)}}}};const cse={kernelName:Sp,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,r)=>{t[r]=()=>n.clone()}),t}};const hse={kernelName:Tp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ft(t)}}};const dse={kernelName:Cp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ft(t)}}};const fse={kernelName:nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,Pn(Ae(ze(1),$t(Ne(t,"float32")))))}}};const pse={kernelName:sh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Pn(we(ze(1),$t(Ne(t,"float32"))));return Fe(n,s)}}}};const mse={kernelName:ih,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{const o=we($t(t),$t(s));let l=Y(n,Fe(s,o));const h=xn(t.shape,r);return h.length>0&&(l=Re(l,h)),J(l,t.shape)},b:()=>{const o=we($t(t),$t(s));let l=Mt(Y(n,Fe(t,o)));const h=xn(s.shape,r);return h.length>0&&(l=Re(l,h)),J(l,s.shape)}}}};const gse={kernelName:rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,we($t(Ne(t,"float32")),1))}}};const yse={kernelName:ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,Ae(ze(1),$t(Ne(t,"float32"))))}}};function bse(n,e,t,s,r,a){const i=M(n,"dy","avgPool3dGrad"),o=M(e,"input","avgPool3dGrad");let l=i,h=o,d=!1;o.rank===4&&(d=!0,l=J(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=J(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),O(h.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),ws("avgPool3dGrad",r,a);const f={dy:l,input:h},m={filterSize:t,strides:s,pad:r,dimRoundingMode:a},y=W.runKernel(xb,f,m);return d?J(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const xse=G({avgPool3dGrad_:bse});const wse={kernelName:kp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:a,pad:i,dimRoundingMode:o}=t;return{x:()=>xse(n,s,r,a,i,o)}}};function vse(n,e,t,s,r){const a=M(n,"dy","avgPoolGrad"),i=M(e,"input","avgPoolGrad");O(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,h=!1;i.rank===3&&(h=!0,o=J(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=J(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),O(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const d={dy:l,input:o},f={filterSize:t,strides:s,pad:r},m=W.runKernel(bb,d,f);return h?J(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const Sse=G({avgPoolGrad_:vse});const Tse={kernelName:Np,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:r,strides:a,pad:i}=t;return{x:()=>Sse(n,s,r,a,i)}}};const Cse={kernelName:Ep,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,r]=e,{transposeA:a,transposeB:i}=t;return!a&&!i?{a:()=>rt(n,r,!1,!0),b:()=>rt(s,n,!0,!1)}:!a&&i?{a:()=>rt(n,r,!1,!1),b:()=>rt(n,s,!0,!1)}:a&&!i?{a:()=>rt(r,n,!1,!0),b:()=>rt(s,n,!1,!1)}:{a:()=>rt(r,n,!0,!0),b:()=>rt(n,s,!0,!0)}}};const Nse={kernelName:$p,gradFunc:(n,e,t)=>{const{blockShape:s,crops:r}=t;return{x:()=>Mm(n,s,r)}}};const kse={kernelName:dM,gradFunc:(n,e,t)=>{const s=t,r=s.inputShape,a=s.shape,i=Array.from(a);for(let l=r.length-1;l>=0;l--)if(r[l]===a[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Re(n,o,!0)}}};const Ese={kernelName:oh,gradFunc:n=>({x:()=>n.clone()})};const $se={kernelName:lh,gradFunc:n=>({x:()=>ft(n)})};const Ise={kernelName:uh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:r,clipValueMax:a}=t;return{x:()=>Mn(qr(Mi(s,r),Wo(s,a)),n,ft(n))}}};const _se={kernelName:_p,inputsToSave:["x"],gradFunc:BP.gradFunc};const Ase={kernelName:Ap,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:r}=t,a=at(r,e[0].shape)[0],i=s.map(l=>l[a]);return Is(n,i,a).map(l=>()=>l)}};const Rse={kernelName:Rp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{dilations:a,strides:i,pad:o,dataFormat:l}=t;return O(Ao(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>H2(s.shape,n,r,i,o,l),filter:()=>EN(s,n,r.shape,i,o,l)}}};const Dse={kernelName:Dp,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=t;return{dy:()=>Ii(n,r,a,i,o,1,l),filter:()=>EN(n,s,r.shape,a,i,o,l)}}};function Ose(n,e,t,s,r){let a=n;n.rank===4&&(a=J(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=e;i.rank===4&&(i=J(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),O(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),O(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),O(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),O(a.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${t[3]}.`),O(i.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:a,dy:i},l={strides:s,pad:r,filterShape:t};return W.runKernel(Cb,o,l)}const Fse=G({conv3DBackpropFilter_:Ose});const Lse={kernelName:Op,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:a}=t;O(Ao(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,o]=e;return{x:()=>qM(i.shape,n,o,r,a),filter:()=>Fse(i,n,o.shape,r,a)}}};const Mse={kernelName:ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(Mt(Ux(Ne(t,"float32"))),n)}}};const zse={kernelName:hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(jx(Ne(t,"float32")),n)}}};const Pse={kernelName:Fp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r,exclusive:a,reverse:i}=t;return{x:()=>{const o=Zt([r],s.rank);let l=Ix(n,r,a,!i);return o!=null&&(l=ut(l,o)),l}}}};const Bse={kernelName:Lp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:i}=t,o=s??[1,1];O(Ao(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,h]=e;return O(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),O(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${h.rank}.`),O(l.shape[3]===h.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),O(Zn(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),ws("depthwiseConv2d",a,i),{x:()=>Mz(l.shape,n,h,r,a,o,i),filter:()=>Lz(l,n,h.shape,r,a,o,i)}}};const Vse={kernelName:Mp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,r]=e,a={x:s,filter:r,dy:n},i={x:s,filter:r,dy:n};return{x:()=>W.runKernel(I0,a,t),filter:()=>W.runKernel(_0,i,t)}}};const Use={kernelName:fh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>W.runKernel(Fb,s)}}};const jse={kernelName:ph,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=Y(Ds(Mt($t(t))),2/Math.sqrt(Math.PI));return{x:()=>Y(n,s)}}};const Wse={kernelName:mh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,t)}}};const Gse={kernelName:Pp,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>J(n,t.shape)}}};const Hse={kernelName:gh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,Ds(t))}}};const qse={kernelName:yh,gradFunc:n=>({x:()=>ft(n)})};const Kse={kernelName:bh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{const o=Fe(n,Ne(s,"float32")),l=xn(t.shape,r);return l.length>0?J(Re(o,l),t.shape):o},b:()=>{let o=Y(n,Ne(t,"float32"));const l=xn(s.shape,r);l.length>0&&(o=J(Re(o,l),s.shape));const h=$t(s);return Mt(Fe(o,Ne(h,"float32")))}}}};const Xse={kernelName:Bp,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[r,a,i,o]=e,l=o??ze(1),h=xn(a.shape,r.shape),d=[];if(a.rank===1){for(let k=0;k<r.shape.length-1;++k)d.push(r.shape[k]);d.push(1)}const f=Ae(r,a),m=Y(n,l),y=Px(we(i,ze(s))),b=Y(Y(Y(y,y),y),ze(-.5));return{x:()=>a.rank===1?J(Y(Y(n,br(J(y,[1,1,1,a.shape[0]]),d)),l),r.shape):J(Y(Y(n,y),l),r.shape),mean:()=>{let k=Y(Y(y,ze(-1)),m);return a.rank===1&&(k=Re(k,h)),J(k,a.shape)},variance:()=>{let k=Y(Y(b,f),m);return a.rank===1&&(k=Re(k,h)),J(k,a.shape)},scale:()=>{const k=Y(f,y);let E=Y(n,k);return a.rank===1&&(E=Re(E,h)),J(E,a.shape)},offset:()=>{let k=n;return a.rank===1&&(k=Re(k,h)),J(k,a.shape)}}}};const Yse={kernelName:Vp,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,r]=e,{axis:a,batchDims:i}=t,o=at(a,s.shape)[0],l=(h,d,f)=>()=>{const m=h.shape,y=d.size,b=m.slice(0,o),x=b.length,w=m.slice(a,m.length).slice(1),v=w.length,C=OO(0,x),N=OO(x+1,x+1+v),k=FO([b,[y],w]),E=J(f,k),_=J(d,[y]),R=FO([[x],C,N]),D=ut(E,R);let F=Yx(D,_,h.shape[o]);const L=jo(R);return F=ut(F,L),F};if(i===1){const h=s.shape[0],d=s.split(h,0);return{x:()=>bs(d.map((y,b)=>l(y,r.slice(b,1),n.slice(b,1))())).reshape(s.shape),indices:()=>r}}else return{x:l(s,r,n),indices:()=>r}}};function OO(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function FO(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}const Jse={kernelName:xh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ft(t),b:()=>ft(s)}}};const Zse={kernelName:wh,gradFunc:n=>({x:()=>Ne(n,"float32")})};const Qse={kernelName:vh,gradFunc:n=>({x:()=>ft(n)})};const ere={kernelName:Sh,gradFunc:n=>({x:()=>ft(n)})};const tre={kernelName:Th,gradFunc:n=>({x:()=>ft(n)})};const nre={kernelName:jp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:r}=t,a=vs(s,0);return{x:()=>Mn(a,n,Y(n,r))}}};const sre={kernelName:Nh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,we(t,1))}}};const rre={kernelName:Ch,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,Ne(t,"float32"))}}};const are={kernelName:fM,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;return{logits:()=>{const i=Ds(s);return Ae(n,Y(Re(n,r,!0),i))}}}};function ire(n,e,t,s=5,r=1,a=1,i=.5){const o={x:n,y:e,dy:t},l={depthRadius:s,bias:r,alpha:a,beta:i};return W.runKernel(jb,o,l)}const ore=G({localResponseNormalizationBackprop_:ire});const lre={kernelName:Xp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{depthRadius:a,bias:i,alpha:o,beta:l}=t;return{x:()=>ore(s,r,n,a,i,o,l)}}};function VP(n,e,t,s){return e.rank<t.rank&&(e=J(e,un(e.shape,s))),n.rank<t.rank&&(n=J(n,un(n.shape,s))),{x:()=>Y(n,Ne(Ys(t,e),n.dtype))}}const LO={kernelName:Yp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:r}=s,a=e[0],i=e[1],o=at(r,a.shape),l=VP(n,i,a,o);return{x:()=>l.x()}}};const ure={kernelName:kh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Y(n,Ne(Mi(t,s),"float32")),b:()=>Y(n,Ne(Bc(t,s),"float32"))}}};function cre(n,e,t,s,r,a,i){const o=M(n,"dy","maxPool3dGrad"),l=M(e,"input","maxPool3dGrad"),h=M(t,"output","maxPool3dGrad");let d=o,f=l,m=h,y=!1;l.rank===4&&(y=!0,d=J(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),f=J(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=J(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),O(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),O(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),O(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),ws("maxPool3dGrad",a,i);const b={dy:d,input:f,output:m},x={filterSize:s,strides:r,pad:a,dimRoundingMode:i},w=W.runKernel(Gb,b,x);return y?J(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const hre=G({maxPool3dGrad_:cre});const dre={kernelName:Zp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=t;return{x:()=>hre(n,s,r,a,i,o,l)}}};function fre(n,e,t,s,r,a,i){const o=M(n,"dy","maxPoolGrad"),l=M(e,"input","maxPoolGrad"),h=M(t,"output","maxPoolGrad");O(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),O(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),O(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ws("maxPoolGrad",a,i);const d={dy:o,input:l,output:h},f={filterSize:s,strides:r,pad:a,dimRoundingMode:i};return W.runKernel(Wb,d,f)}const pre=G({maxPoolGrad_:fre});const mre={kernelName:Jp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,r]=e,{filterSize:a,strides:i,pad:o}=t;return{x:()=>pre(n,s,r,a,i,o)}}};const gre={kernelName:Qp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t,a=at(r,s.shape),o=Un(s.shape,a)[1],l=he(o);return{x:()=>{const d=s.shape.slice();a.forEach(y=>{d[y]=1});const f=J(n,d);return Fe(Y(f,$s(s.shape,"float32")),l)}}}};const yre={kernelName:em,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:r}=s,[a,i]=e,o=at(r,a.shape),l=VP(n,i,a,o);return{x:()=>l.x()}}};const bre={kernelName:Eh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>Y(n,Ne(Wo(t,s),"float32")),b:()=>Y(n,Ne(vs(t,s),"float32"))}}};const xre={kernelName:tm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,a=r.map(i=>i[0]);return{x:()=>dt(n,a,s.shape)}}};const wre={kernelName:$h,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{const o=xn(t.shape,r);return o.length>0?J(Re(n,o),t.shape):n},b:()=>{const o=Y(n,Mt(Qh(Fe(t,s)))),l=xn(s.shape,r);return l.length>0?J(Re(o,l),s.shape):o}}}};const vre={kernelName:Ih,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{const o=Y(n,Ne(s,"float32")),l=xn(t.shape,r);return l.length>0?J(Re(o,l),t.shape):o},b:()=>{const o=Y(n,Ne(t,"float32")),l=xn(s.shape,r);return l.length>0?J(Re(o,l),s.shape):o}}}};const Sre={kernelName:nm,gradFunc:n=>({x:()=>Mt(n)})};const Tre={kernelName:am,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>gn(t.shape,"float32")}}};const Cre={kernelName:rm,gradFunc:n=>({x:()=>ft(n)})};const Nre={kernelName:im,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Cr(n,s).map(a=>()=>a)}};const MO={kernelName:om,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:r}=t,a=r.map(i=>i[0]);return{x:()=>dt(n,a,s.shape)}}};const kre={kernelName:_h,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,r]=e,a=t,i=s,o=Ze(a.shape,i.shape);return{a:()=>{const d=Ne(i,"float32");let f=Y(n,Y(d,Ha(a,Ae(d,ze(1)))));const m=xn(a.shape,o);return m.length>0&&(f=Re(f,m)),J(f,a.shape)},b:()=>{const d=vs(a,0),f=Mn(d,Js(a),ft(a));let m=Y(n,Y(r,f));const y=xn(i.shape,o);return y.length>0&&(m=Re(m,y)),J(m,i.shape)}}}};const Ere={kernelName:lm,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,r=vs(t,0);return{x:()=>Mn(r,n,Y(n,s)),alpha:()=>{let a=Mn(r,ft(n),Y(n,t));const i=xn(s.shape,n.shape);return i.length>0&&(a=Re(a,i)),J(a,s.shape)}}}};function $re(n,e,t){const s=n.shape.slice();s[t]=1;const r=J(e,s),a=op(n,t,!0,!1),i=op(n,t,!0,!0),o=Y(a,i);return Y(r,o)}function Ire(n,e,t){const s=n.shape.length,r=s-t.length,a=Zt(t,s);let i=n;a!=null&&(i=ut(n,a));const o=i.shape.slice(),h=o.splice(s-t.length,t.length).reduce((m,y)=>m*y,1);o.push(h);const d=i.reshape(o);let f=$re(d,e,r);if(f=f.reshape(i.shape),a!=null){const m=jo(a);f=ut(f,m)}return f}const _re={kernelName:um,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:r}=t;let a=[];return r==null?a=s.shape.map((i,o)=>o):typeof r=="number"?a=[r]:a=r,{x:()=>Ire(s,n,a)}}};const Are={kernelName:dh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{const o=Fe(n,Ne(s,"float32")),l=xn(t.shape,r);return l.length>0?J(Re(o,l),t.shape):o},b:()=>{let o=Y(n,Ne(t,"float32"));const l=xn(s.shape,r);l.length>0&&(o=J(Re(o,l),s.shape));const h=$t(s);return Mt(Fe(o,Ne(h,"float32")))}}}};const Rre={kernelName:Ah,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,Mt($t(t)))}}};const Dre={kernelName:Dh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=Y(Wo(t,6),gu(t));return{x:()=>Y(n,Ne(s,"float32"))}}};const Ore={kernelName:Rh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,Ne(gu(t),"float32"))}}};const Fre={kernelName:cm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>J(n,t.shape)}}};const Lre={kernelName:dm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(sx,r,t)}}};const Mre={kernelName:hm,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,r={dy:n,images:s};return{images:()=>W.runKernel(nx,r,t)}}};const zre={kernelName:fm,gradFunc:(n,e,t)=>{const{dims:s}=t,r=at(s,n.shape);return{x:()=>Tr(n,r)}}};const Pre={kernelName:Oh,gradFunc:n=>({x:()=>ft(n)})};const Bre={kernelName:Fh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Mt(Fe(n,Y(Ha(t,1.5),2)))}}};const Vre={kernelName:pm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ne(ft(t),"float32"),t:()=>Y(n,Ne(t,n.dtype)),e:()=>Y(n,Ne(Om(t),n.dtype))}}};const Ure={kernelName:Lh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=vs(t,ze(0)),r=ze(cw),a=ze(hw),i=Y(n,a),o=Y(Y(n,r),Ds(Ne(t,"float32")));return Mn(s,i,o)}}}};const jre={kernelName:Bh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,Y(t,Ae(ze(1),t)))}}};const Wre={kernelName:Ph,gradFunc:n=>({x:()=>ft(n)})};const Gre={kernelName:Mh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(Im(Ne(t,"float32")),n)}}};const Hre={kernelName:zh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y($x(Ne(t,"float32")),n)}}};const qre={kernelName:mm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:r,size:a}=t,i=s.shape,[o,l]=lw(s,r,a),h=[];for(let d=0;d<n.rank;d++)h.push([o[d],i[d]-o[d]-l[d]]);return{x:()=>zi(n,h)}}};const Kre={kernelName:xm,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:r}=t,a=!0,i=Y(n,s);return{logits:()=>Ae(i,Y(Re(i,[r],a),s))}}};const Xre={kernelName:Vh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,pa(t))}}};const zO={kernelName:ym,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:r}=t;return{x:()=>$m(n,s,r)}}};const PO={kernelName:bm,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>ln(n,s)}}};const Yre={kernelName:Uh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,Y(Pn(Ne(t,"float32")),2))}}};const Jre={kernelName:dx,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(n,Y(Ne(t,"float32"),2))}}};const Zre={kernelName:jh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=ze(2);return{a:()=>Y(n,Y(r,Ae(t,s))),b:()=>Y(n,Y(r,Ae(s,t)))}}};const Qre={kernelName:Kh,gradFunc:n=>({x:()=>ft(n)})};const eae={kernelName:Wh,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,r=Ze(t.shape,s.shape);return{a:()=>{let o=n;const l=xn(t.shape,r);return l.length>0&&(o=Re(o,l)),J(o,t.shape)},b:()=>{let o=n;const l=xn(s.shape,r);return l.length>0&&(o=Re(o,l)),J(Mt(o),s.shape)}}}};const tae={kernelName:gm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,r=s.shape.slice(),{axis:a}=t;at(a,s.shape).forEach(h=>{r[h]=1});const o=J(n,r),l=Y(o,$s(s.shape,"float32"));return{x:()=>l}}};const nae={kernelName:Gh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,$t(Im(t)))}}};const sae={kernelName:Hh,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Y(Ae(ze(1),$t(t)),n)}}};const rae={kernelName:qh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:r}=t;return{x:()=>{let i=ft(s);if(s.rank===1)for(let o=0;o<r[0];++o)i=we(i,dt(n,[o*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)i=we(i,dt(n,[o*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let h=0;h<r[2];++h)i=we(i,dt(n,[o*s.shape[0],l*s.shape[1],h*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let o=0;o<r[0];++o)for(let l=0;l<r[1];++l)for(let h=0;h<r[2];++h)for(let d=0;d<r[3];++d)i=we(i,dt(n,[o*s.shape[0],l*s.shape[1],h*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return i}}}};const aae={kernelName:Ul,gradFunc:(n,e,t)=>{const s=t,{perm:r}=s,a=jo(r);return{x:()=>ut(n,a)}}};const iae={kernelName:vm,gradFunc:(n,e,t)=>{const s=t,{axis:r}=s;return{value:()=>bs(n,r)}}};const oae={kernelName:Sm,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>lae(n,t)}}};function lae(n,e){const t=Xa(e,ft(e)),s=ed(n,t);let r=Mi(e,ze(0,"int32"));const a=s.rank-r.rank;for(let o=0;o<a;++o)r=Hn(r,o+1);r=qr(r,$s(s.shape,"bool"));const i=ft(s);return Mn(r,s,i)}const uae={kernelName:Tm,gradFunc:n=>({x:()=>ft(n)})};const cae=[BP,ose,lse,use,cse,hse,dse,fse,pse,mse,gse,yse,wse,Tse,Cse,Nse,kse,Ese,$se,Ise,_se,Ase,Dse,Rse,Lse,Mse,zse,Pse,Bse,Vse,Are,Use,jse,Wse,Gse,Hse,Kse,qse,Xse,Yse,Jse,Zse,Qse,ere,tre,nre,sre,rre,are,lre,LO,LO,ure,dre,mre,gre,yre,bre,xre,wre,vre,Sre,Tre,Cre,Nre,MO,MO,kre,Ere,_re,Rre,Dre,Ore,Fre,Lre,Mre,zre,Pre,Bre,Vre,Ure,jre,Wre,Gre,Hre,qre,Kre,Xre,zO,zO,PO,PO,Yre,Zre,Jre,Qre,eae,tae,nae,sae,rae,aae,iae,oae,uae];for(const n of cae)pM(n);fe().prototype.abs=function(){return this.throwIfDisposed(),mn(this)};fe().prototype.acos=function(){return this.throwIfDisposed(),E2(this)};fe().prototype.acosh=function(){return this.throwIfDisposed(),$2(this)};fe().prototype.add=function(n){return this.throwIfDisposed(),we(this,n)};fe().prototype.all=function(n,e){return this.throwIfDisposed(),Nx(this,n,e)};fe().prototype.any=function(n,e){return this.throwIfDisposed(),rp(this,n,e)};fe().prototype.argMax=function(n){return this.throwIfDisposed(),Yl(this,n)};fe().prototype.argMin=function(n){return this.throwIfDisposed(),I2(this,n)};fe().prototype.asScalar=function(){return this.throwIfDisposed(),O(this.size===1,()=>"The array must have only 1 element."),J(this,[])};fe().prototype.asType=function(n){return this.throwIfDisposed(),Ne(this,n)};fe().prototype.as1D=function(){return this.throwIfDisposed(),J(this,[this.size])};fe().prototype.as2D=function(n,e){return this.throwIfDisposed(),J(this,[n,e])};fe().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),J(this,[n,e,t])};fe().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),J(this,[n,e,t,s])};fe().prototype.as5D=function(n,e,t,s,r){return this.throwIfDisposed(),J(this,[n,e,t,s,r])};fe().prototype.asin=function(){return this.throwIfDisposed(),_2(this)};fe().prototype.asinh=function(){return this.throwIfDisposed(),A2(this)};fe().prototype.atan=function(){return this.throwIfDisposed(),R2(this)};fe().prototype.atan2=function(n){return this.throwIfDisposed(),D2(this,n)};fe().prototype.atanh=function(){return this.throwIfDisposed(),O2(this)};fe().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),Em(this,n,e,t,s)};fe().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),$m(this,n,e)};fe().prototype.batchNorm=function(n,e,t,s,r){return this.throwIfDisposed(),Xh(this,n,e,t,s,r)};fe().prototype.broadcastTo=function(n){return this.throwIfDisposed(),jl(this,n)};fe().prototype.cast=function(n){return this.throwIfDisposed(),Ne(this,n)};fe().prototype.ceil=function(){return this.throwIfDisposed(),V2(this)};fe().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Rs(this,n,e)};fe().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof bt&&(n=[n]),ln([this,...n],e)};fe().prototype.conv1d=function(n,e,t,s,r,a){return this.throwIfDisposed(),kx(this,n,e,t,s,r,a)};fe().prototype.conv2dTranspose=function(n,e,t,s,r){return this.throwIfDisposed(),Ex(this,n,e,t,s,r)};fe().prototype.conv2d=function(n,e,t,s,r,a){return this.throwIfDisposed(),Ii(this,n,e,t,s,r,a)};fe().prototype.cos=function(){return this.throwIfDisposed(),Im(this)};fe().prototype.cosh=function(){return this.throwIfDisposed(),$x(this)};fe().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),op(this,n,e,t)};fe().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),Ix(this,n,e,t)};fe().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),X2(this,n,e)};fe().prototype.depthwiseConv2d=function(n,e,t,s,r,a){return this.throwIfDisposed(),Yh(this,n,e,t,s,r,a)};fe().prototype.dilation2d=function(n,e,t,s,r){return this.throwIfDisposed(),Y2(this,n,e,t,s,r)};fe().prototype.divNoNan=function(n){return this.throwIfDisposed(),J2(this,n)};fe().prototype.div=function(n){return this.throwIfDisposed(),Fe(this,n)};fe().prototype.dot=function(n){return this.throwIfDisposed(),Z2(this,n)};fe().prototype.elu=function(){return this.throwIfDisposed(),Jh(this)};fe().prototype.equal=function(n){return this.throwIfDisposed(),Ys(this,n)};fe().prototype.erf=function(){return this.throwIfDisposed(),_x(this)};fe().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),eN(this,n,e)};fe().prototype.exp=function(){return this.throwIfDisposed(),Ds(this)};fe().prototype.expandDims=function(n){return this.throwIfDisposed(),Hn(this,n)};fe().prototype.expm1=function(){return this.throwIfDisposed(),tN(this)};fe().prototype.fft=function(){return this.throwIfDisposed(),Um(this)};fe().prototype.flatten=function(){return this.throwIfDisposed(),J(this,[this.size])};fe().prototype.floor=function(){return this.throwIfDisposed(),Qh(this)};fe().prototype.floorDiv=function(n){return this.throwIfDisposed(),Cx(this,n)};fe().prototype.gather=function(n,e,t){return this.throwIfDisposed(),ed(this,n,e,t)};fe().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Mi(this,n)};fe().prototype.greater=function(n){return this.throwIfDisposed(),vs(this,n)};fe().prototype.ifft=function(){return this.throwIfDisposed(),Wc(this)};fe().prototype.irfft=function(){return this.throwIfDisposed(),Gx(this)};fe().prototype.isFinite=function(){return this.throwIfDisposed(),nN(this)};fe().prototype.isInf=function(){return this.throwIfDisposed(),sN(this)};fe().prototype.isNaN=function(){return this.throwIfDisposed(),rN(this)};fe().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Am(this,n)};fe().prototype.lessEqual=function(n){return this.throwIfDisposed(),Wo(this,n)};fe().prototype.less=function(n){return this.throwIfDisposed(),Bc(this,n)};fe().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),aN(this,n,e,t,s)};fe().prototype.logSigmoid=function(){return this.throwIfDisposed(),iN(this)};fe().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Dx(this,n)};fe().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Dm(this,n,e)};fe().prototype.log=function(){return this.throwIfDisposed(),Js(this)};fe().prototype.log1p=function(){return this.throwIfDisposed(),Rm(this)};fe().prototype.logicalAnd=function(n){return this.throwIfDisposed(),qr(this,n)};fe().prototype.logicalNot=function(){return this.throwIfDisposed(),Om(this)};fe().prototype.logicalOr=function(n){return this.throwIfDisposed(),Ox(this,n)};fe().prototype.logicalXor=function(n){return this.throwIfDisposed(),oN(this,n)};fe().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),rt(this,n,e,t)};fe().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),Fm(this,n,e,t,s)};fe().prototype.max=function(n,e){return this.throwIfDisposed(),Sr(this,n,e)};fe().prototype.maximum=function(n){return this.throwIfDisposed(),Xa(this,n)};fe().prototype.mean=function(n,e){return this.throwIfDisposed(),Kt(this,n,e)};fe().prototype.min=function(n,e){return this.throwIfDisposed(),Pc(this,n,e)};fe().prototype.minimum=function(n){return this.throwIfDisposed(),Do(this,n)};fe().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),uN(this,n,e)};fe().prototype.mod=function(n){return this.throwIfDisposed(),cN(this,n)};fe().prototype.mul=function(n){return this.throwIfDisposed(),Y(this,n)};fe().prototype.neg=function(){return this.throwIfDisposed(),Mt(this)};fe().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Zh(this,n,e,t)};fe().prototype.notEqual=function(n){return this.throwIfDisposed(),Ql(this,n)};fe().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),Vc(this,n,e,t)};fe().prototype.onesLike=function(){return this.throwIfDisposed(),Zs(this)};fe().prototype.pad=function(n,e){return this.throwIfDisposed(),zi(this,n,e)};fe().prototype.pool=function(n,e,t,s,r,a){return this.throwIfDisposed(),hN(this,n,e,t,s,r,a)};fe().prototype.pow=function(n){return this.throwIfDisposed(),Ha(this,n)};fe().prototype.prelu=function(n){return this.throwIfDisposed(),zm(this,n)};fe().prototype.prod=function(n,e){return this.throwIfDisposed(),dN(this,n,e)};fe().prototype.reciprocal=function(){return this.throwIfDisposed(),gN(this)};fe().prototype.relu=function(){return this.throwIfDisposed(),Ta(this)};fe().prototype.relu6=function(){return this.throwIfDisposed(),Mx(this)};fe().prototype.reshapeAs=function(n){return this.throwIfDisposed(),J(this,n.shape)};fe().prototype.reshape=function(n){return this.throwIfDisposed(),J(this,n)};fe().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),Vz(this,n,e,t)};fe().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),Uz(this,n,e,t)};fe().prototype.reverse=function(n){return this.throwIfDisposed(),Tr(this,n)};fe().prototype.rfft=function(){return this.throwIfDisposed(),jm(this)};fe().prototype.round=function(){return this.throwIfDisposed(),zx(this)};fe().prototype.rsqrt=function(){return this.throwIfDisposed(),Px(this)};fe().prototype.selu=function(){return this.throwIfDisposed(),Bx(this)};fe().prototype.separableConv2d=function(n,e,t,s,r,a){return this.throwIfDisposed(),Vx(this,n,e,t,s,r,a)};fe().prototype.sigmoid=function(){return this.throwIfDisposed(),pa(this)};fe().prototype.sign=function(){return this.throwIfDisposed(),yN(this)};fe().prototype.sin=function(){return this.throwIfDisposed(),Ux(this)};fe().prototype.sinh=function(){return this.throwIfDisposed(),jx(this)};fe().prototype.slice=function(n,e){return this.throwIfDisposed(),dt(this,n,e)};fe().prototype.softmax=function(n){return this.throwIfDisposed(),Vm(this,n)};fe().prototype.softplus=function(){return this.throwIfDisposed(),mu(this)};fe().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),Mm(this,n,e)};fe().prototype.split=function(n,e){return this.throwIfDisposed(),Is(this,n,e)};fe().prototype.sqrt=function(){return this.throwIfDisposed(),Pn(this)};fe().prototype.square=function(){return this.throwIfDisposed(),$t(this)};fe().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Hx(this,n)};fe().prototype.squeeze=function(n){return this.throwIfDisposed(),Ho(this,n)};fe().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof bt?[this,n]:[this,...n];return bs(t,e)};fe().prototype.step=function(n){return this.throwIfDisposed(),gu(this,n)};fe().prototype.stridedSlice=function(n,e,t,s,r,a,i,o){return this.throwIfDisposed(),bN(this,n,e,t,s,r,a,i,o)};fe().prototype.sub=function(n){return this.throwIfDisposed(),Ae(this,n)};fe().prototype.sum=function(n,e){return this.throwIfDisposed(),Re(this,n,e)};fe().prototype.tan=function(){return this.throwIfDisposed(),xN(this)};fe().prototype.tanh=function(){return this.throwIfDisposed(),Ro(this)};fe().prototype.tile=function(n){return this.throwIfDisposed(),br(this,n)};fe().prototype.toBool=function(){return this.throwIfDisposed(),Ne(this,"bool")};fe().prototype.toFloat=function(){return this.throwIfDisposed(),Ne(this,"float32")};fe().prototype.toInt=function(){return this.throwIfDisposed(),Ne(this,"int32")};fe().prototype.topk=function(n,e){return this.throwIfDisposed(),vN(this,n,e)};fe().prototype.transpose=function(n){return this.throwIfDisposed(),ut(this,n)};fe().prototype.unique=function(n){return this.throwIfDisposed(),SN(this,n)};fe().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),Yx(this,n,e)};fe().prototype.unstack=function(n){return this.throwIfDisposed(),Cr(this,n)};fe().prototype.where=function(n,e){return this.throwIfDisposed(),Mn(n,this,e)};fe().prototype.zerosLike=function(){return this.throwIfDisposed(),ft(this)};class Ra extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ra.prototype)}}class Gr extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Gr.prototype)}}class Z extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Z.prototype)}}class et extends Error{constructor(e){super(e),Object.setPrototypeOf(this,et.prototype)}}class ck extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ck.prototype)}}class UP{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}function nu(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function Da(n,e){if(!n)throw new ck(e)}function BO(n,e){let t=0;for(const s of n)s===e&&t++;return t}function ks(n){return n.length===1?n[0]:n}function Ct(n){return Array.isArray(n)?n:[n]}function yi(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function _l(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Mr={};function hk(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function HT(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>HT(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:HT(s))}}}function qm(n,e={},t={},s="object",r=!1){if(typeof n=="string"){const a=n;let i;if(a in t)i=t[a];else if(a in Mr)i=Mr[a];else if(i=e[a],i==null)throw new Z(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=n;if(a.className==null||a.config==null)throw new Z(`${s}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,l;if(i in t?[o,l]=t[i]:i in Mr?[o,l]=Mr.className:i in e&&([o,l]=e[i]),o==null)throw new Z(`Unknown ${s}: ${i}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const h={};for(const y of Object.keys(Mr))h[y]=Mr[y];for(const y of Object.keys(t))h[y]=t[y];const d=a.config;d.customObjects=h;const f=Object.assign({},Mr);for(const y of Object.keys(t))Mr[y]=t[y];HT(a.config);const m=l(o,a.config,t,r);return Mr=Object.assign({},f),m}else{const h=Object.assign({},Mr);for(const f of Object.keys(t))Mr[f]=t[f];const d=new o(a.config);return Mr=Object.assign({},h),d}}}function hae(n,e){return n<e?-1:n>e?1:0}function Fy(n,e){return-1*hae(n,e)}function Co(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function dae(n){if(n==null)throw new Z(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function bu(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new Z(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function dk(n,e,t=0,s=1/0){return Da(t>=0),Da(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(r=>typeof r===e)}function Ln(n,e){Array.isArray(n)?(O(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Ln(t,`element ${s+1} of ${e}`))):O(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${jP(n)}.`)}function jP(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>jP(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function fae(n,e,t){let s=t!=null?t():Gn(),r;return(...i)=>{const o=t!=null?t():Gn();return o-s<e||(s=o,r=n(...i)),r}}function WP(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let pae=0;function GP(){return pae++}const Ly={};function dw(n=""){return n in Ly||(Ly[n]=0),Ly[n]+=1,n+Ly[n].toString()}const mae=["channelsFirst","channelsLast"],gae=["nearest","bilinear"],yae=["valid","same","causal"],bae=["max","avg"],xae=["sum","mul","concat","ave"];const gc=new Map;function hn(n){bu(mae,"DataFormat",n)}function wae(n){bu(gae,"InterpolationFormat",n)}function Nr(n){bu(yae,"PaddingMode",n)}function HP(n){bu(bae,"PoolMode",n)}const Mf=[],VO="/";function Wl(n,e){Mf.push(n);try{const t=e();return Mf.pop(),t}catch(t){throw Mf.pop(),t}}function vae(){return Mf.length===0?"":Mf.join(VO)+VO}function qP(n){if(!XP(n))throw new Error("Not a valid tensor name: '"+n+"'");return vae()+n}function KP(n){if(!XP(n))throw new Error("Not a valid tensor name: '"+n+"'");gc.has(n)||gc.set(n,0);const e=gc.get(n);if(gc.set(n,gc.get(n)+1),e>0){const t=`${n}_${e}`;return gc.set(t,1),t}else return n}const Sae=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function XP(n){return!!n.match(Sae)}function Tae(n){return n===parseInt(n.toString(),10)}function No(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let r=e;r<t;++r)s*=n[r];return s}function Gc(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Oo(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function ya(n,e){if(e<n)throw new Z(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}let FS;function $n(){return FS==null&&(FS=v2().epsilon()),FS}function ba(){return"channelsLast"}function Ua(n,e){return Ne(n,e)}function Km(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),J(n,t)}function Cae(n,e){return re(()=>{if(n.shape.length!==2)throw new Z(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Km(n,1);return qT(t,[1,e,1])})}function Nae(n){const e=[No(n.shape)];return J(n,e)}function kae(n){if(n.rank<=1)throw new Z(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],No(n.shape,1)];return J(n,e)}function Gl(n,e,t){return re(()=>{switch(n.rank){case 1:return Pm(n,e,t);case 2:return Wx(n,[e,0],[t,n.shape[1]]);case 3:return Bm(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return jc(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return dt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return dt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function LS(n,e,t){return re(()=>{switch(n.rank){case 1:return Pm(n,e,t);case 2:return Wx(n,[0,e],[n.shape[0],t]);case 3:return Bm(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return jc(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new Z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function My(n,e,t,s){return re(()=>{switch(n.rank){case 1:return Pm(n,e,t);case 2:switch(s){case 1:return Gl(n,e,t);case 2:return LS(n,e,t);default:throw new Z(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Gl(n,e,t);case 2:return Bm(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return LS(n,e,t);default:throw new Z(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Gl(n,e,t);case 2:return jc(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return jc(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return LS(n,e,t);default:throw new Z(`The axis is not within the rank of the tensor ${s}`)}default:throw new Z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function fk(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),ln(n,e)}function UO(n,e){switch(n.rank){case 1:return U2([n,e]);case 2:return j2([n,e],0);case 3:return W2([n,e],0);case 4:return G2([n,e],0);default:throw new Z(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function qT(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new Z(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return br(n,e)}function fw(n,e=0,t=1,s,r){return Lx(n,e,t,s,r)}function ja(n,e,t,s){if(n.rank<2||e.rank<2)throw new et(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=n.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(r!==a)throw new et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return VT({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?KT(n.rank,s,ba()):null,activation:t});{const r=n.shape.slice(),a=r.pop();n=J(n,[-1,a]);const i=e.shape.slice(),o=i.pop(),l=i.pop(),h=[...i,o],d=Array.from({length:e.rank},(b,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=J(ut(e,d),[l,-1]);const f=[...r,...h];return J(VT({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?KT(n.rank,s,ba()):null,activation:t}),f)}}function YP(n,e,t){return re(()=>(Array.isArray(e)?e=Xn(e,"int32"):e=Ne(e,"int32"),ed(n,e,t)))}function Xm(n){return Y(n,n)}function KT(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new Z(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?J(e,[1,s[0],1,1,1]):J(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?J(e,[1,1,1,1,s[0]]):J(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?J(e,[1,s[0],1,1]):J(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?J(e,[1,1,1,s[0]]):J(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?J(e,[1,s[0],1]):J(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?J(e,[1,1,s[0]]):J(e,[1].concat(s))}else if(n<3)return e;throw new Z(`Unsupported input rank by biasAdd: ${e.rank}`)}function Ca(n,e,t){return re(()=>(t==null&&(t=ba()),hn(t),we(n,KT(n.rank,e,t))))}function Eae(n,e=1){if(e!==1)throw new et(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Jh(n)}function $ae(n){return re(()=>Fe(n,we(mn(n),1)))}function JP(n,e,t,s){return re(()=>NN(n,e,t,s))}function Iae(n){return re(()=>{const e=we(.5,Y(.2,n));return Rs(e,0,1)})}function Ym(n,e,t=!1){return t?n():e()}const _ae=["fanIn","fanOut","fanAvg"],Aae=["normal","uniform","truncatedNormal"];function Rae(n){bu(_ae,"FanMode",n)}function Dae(n){bu(Aae,"Distribution",n)}class Xr extends yu{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class pk extends Xr{apply(e,t){return gn(e,t)}}pk.className="Zeros";ve(pk);class pw extends Xr{apply(e,t){return $s(e,t)}}pw.className="Ones";ve(pw);class mk extends Xr{constructor(e){if(super(),typeof e!="object")throw new Z(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Z(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return re(()=>Y(ze(this.value),$s(e,t)))}getConfig(){return{value:this.value}}}mk.className="Constant";ve(mk);class gk extends Xr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Go(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}gk.className="RandomUniform";ve(gk);class yk extends Xr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new et(`randomNormal does not support dType ${t}.`);return fw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}yk.className="RandomNormal";ve(yk);class bk extends Xr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new et(`truncatedNormal does not support dType ${t}.`);return Xx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}bk.className="TruncatedNormal";ve(bk);class xk extends Xr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return re(()=>{if(e.length!==2||e[0]!==e[1])throw new Z("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,Ax(e[0]))})}getConfig(){return{gain:this.gain}}}xk.className="Identity";ve(xk);function Oae(n,e="channelsLast"){let t,s;if(hn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const r=No(n,2);t=n[1]*r,s=n[0]*r}else if(e==="channelsLast"){const r=No(n,0,n.length-2);t=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=No(n);t=Math.sqrt(r),s=Math.sqrt(r)}return[t,s]}class Os extends Xr{constructor(e){if(super(),e.scale<0)throw new Z(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Rae(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Dae(this.distribution),this.seed=e.seed}apply(e,t){const s=Oae(e),r=s[0],a=s[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(r+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new et(`${this.getClassName()} does not support dType ${t}.`);return Xx(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*i);return Go(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Os.className="VarianceScaling";ve(Os);class mw extends Os{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}mw.className="GlorotUniform";ve(mw);class gw extends Os{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}gw.className="GlorotNormal";ve(gw);class yw extends Os{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}yw.className="HeNormal";ve(yw);class bw extends Os{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}bw.className="HeUniform";ve(bw);class xw extends Os{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Os.className}}xw.className="LeCunNormal";ve(xw);class ww extends Os{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Os.className}}ww.className="LeCunUniform";ve(ww);class wk extends Xr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return re(()=>{if(e.length<2)throw new et("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=he(e.slice(0,-1)),r=e[e.length-1],a=s*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(r,s),Math.min(r,s)],o=fw(i,0,1,t,this.seed),l=IN.qr(o,!1);let h=l[0];const f=l[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return h=Y(h,f.sign()),s<r&&(h=h.transpose()),Y(ze(this.gain),h.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}wk.className="Orthogonal";ve(wk);const jO={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function WO(n,e={}){return qm(n,yr.getMap().classNameMap,e,"initializer")}function Yt(n){return hk(n)}function Wt(n){if(typeof n=="string"){const e=n in jO?jO[n]:n;if(e==="GlorotNormal")return new gw;if(e==="GlorotUniform")return new mw;if(e==="HeNormal")return new yw;if(e==="HeUniform")return new bw;if(e==="LeCunNormal")return new xw;if(e==="LeCunUniform")return new ww;{const t={};return t.className=e,t.config={},WO(t)}}else return n instanceof Xr?n:WO(n)}function XT(n){return Array.isArray(n)&&Array.isArray(n[0])}function L0(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function qe(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new Z(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function wt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new Z(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function M0(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,r)=>s*r);return e}const GO="Variable";class ZP{constructor(e,t="float32",s=GO,r=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=GP(),s=s??GO,this.originalName=qP(s),this.name=KP(this.originalName),this.trainable_=r,this.constraint=a,this.val=TN(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Fae(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Fae(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function YT(n){return n.map(e=>e.read())}function vk(n){n.forEach(e=>{e[0].write(e[1])})}class yn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class xa{constructor(e,t,s,r,a,i,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=GP(),i!=null&&(this.originalName=qP(i),this.name=KP(this.originalName)),this.rank=t.length}}let Lae=0;class vw{constructor(e,t){this.callArgs=t,this.id=Lae++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Mae=0;class it extends yu{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Mae++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=yi(s)+"_"+dw(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),s=[a].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Gr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Z(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ks(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ks(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ra(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ra(`Layer ${this.name} is not connected, no input to return.`);return ks(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ra(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ra(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ks(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ct(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Ct(this.inputSpec);if(t.length!==s.length)throw new Z(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const a=t[r],i=s[r];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new Z(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new Z(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new Z(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new Z(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const l=a.shape;for(const h in i.axes){const d=Number(h),f=i.axes[h],m=d>=0?l[d]:l[l.length+d];if(f!=null&&[f,null].indexOf(m)===-1)throw new Z(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${f} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const h=i.shape[l],d=a.shape[l];if(h!=null&&d!=null&&h!==d)throw new Z(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Ct(e),r=Bae(e),a=Vae(e);if(r===a)throw new Z("Arguments to apply() must be all SymbolicTensors or all Tensors");return Wl(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const o of Ct(e))i.push(o.shape);this.build(ks(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let i=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,i);const o=Ct(i),l=[];for(let h of o)s.indexOf(h)!==-1&&(h=h.clone()),l.push(h);if(i=ks(l),this.activityRegularizer!=null)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=zae(e),o=this.computeOutputShape(i);let l;const h=Pae(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((d,f)=>new xa(h,d,this,Ct(e),t,this.name,f)):l=new xa(h,o,this,Ct(e),t,this.name),this.addInboundNode(e,l,null,null,i,o,t),this._refCount++,this.activityRegularizer!=null)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ra(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ra(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Gr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return M0(this.weights)}build(e){this.built=!0}getWeights(e=!1){return YT(e?this.trainableWeights:this.weights)}setWeights(e){re(()=>{const t=this.weights;if(t.length!==e.length)throw new Z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],r=YT(t);for(let a=0;a<r.length;++a){const i=r[a],o=t[a],l=e[a];if(!lt(i.shape,l.shape))throw new Z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}vk(s)})}addWeight(e,t,s,r,a,i,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new Z(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=l!=null?l():Wt("zeros"));const h=r.apply(t,s),d=new ZP(h,s,e,i,o);return h.dispose(),a!=null&&this.addLoss(()=>a.apply(d.read())),i==null&&(i=!0),i?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ct(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),a=Ct(t),i=Ct(r);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(e,t,s,r,a,i,o=null){const l=Ct(e);t=Ct(t),s=Ct(s),r=Ct(r),a=L0(a),i=L0(i);const h=[],d=[],f=[];for(const m of l)h.push(m.sourceLayer),d.push(m.nodeIndex),f.push(m.tensorIndex);new vw({outboundLayer:this,inboundLayers:h,nodeIndices:d,tensorIndices:f,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:r,inputShapes:a,outputShapes:i},o);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function zae(n){n=Ct(n);const e=[];for(const t of n)e.push(t.shape);return ks(e)}function Pae(n){return"float32"}function QP(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let a=0;a<s.inboundLayers.length;a++){const i=s.inputTensors[a],o=s.inboundLayers[a],l=s.nodeIndices[a],h=QP(i,o,l);for(const d of h)r.indexOf(d)===-1&&r.push(d)}return r}}}function Bae(n){let e=!0;for(const t of Ct(n))if(!(t instanceof xa)){e=!1;break}return e}function Vae(n){let e=!0;for(const t of Ct(n))if(t instanceof xa){e=!1;break}return e}class sd extends it{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:dw("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const r=new xa(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new vw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}sd.className="InputLayer";ve(sd);function eB(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new Z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new sd({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function Uae(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ne(e,n.dtype)}catch{throw new Z(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class xo{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof xo)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Uae(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new Z(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof xa){if(this.id2Value[e.id]==null)throw new Z(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Z(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof xa){if(this.id2Value[e.id]==null)throw new Z(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Z(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Je(this.id2Mask)}}const z0=new UP,P0=new UP;function jae(n){z0?.setMaxEntries(n),P0?.setMaxEntries(n)}function Tf(n,e,t,s){const r=t==null?!1:t.training,a=Array.isArray(n),i=a?n:[n],o=i.map(b=>b.name),l=[],h=e.names();for(const b of o)h.indexOf(b)!==-1?l.push(e.getValue(b)):l.push(null);const d=o.join(",")+"|"+e.names().sort().join(",");let f=z0.get(d),m;if(f==null){const b=Wae(i,e);f=b.sorted,m=b.recipientCounts,z0.put(d,f),P0.put(d,m)}m={},r||Object.assign(m,P0.get(d));const y=new xo(e);for(let b=0;b<f.length;++b){const x=f[b],w=x.sourceLayer;if(w instanceof sd)continue;const v=[],C=[],N=[];let k=!1;for(const F of x.inputs){const L=y.getValue(F),A=y.getMask(F);v.push(L),C.push(A),A!=null&&(k=!0),r||(m[F.name]--,m[F.name]===0&&!e.hasKey(F)&&o.indexOf(F.name)===-1&&!L.isDisposed&&F.sourceLayer.stateful!==!0&&N.push(L))}k&&(t=t||{},t.mask=C[0]);const E=Ct(w.apply(v,t));let _=null;w.supportsMasking&&(_=w.computeMask(v,C));const R=Hae(x),D=Array.isArray(R)?R:[R];for(let F=0;F<D.length;++F){y.hasKey(D[F])||y.add(D[F],E[F],Array.isArray(_)?_[0]:_);const L=o.indexOf(D[F].name);L!==-1&&(l[L]=E[F])}r||Je(N)}return y.disposeMasks(),a?l:l[0]}function Wae(n,e){O(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const r=HO(n[0],e);t=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of n){const{sorted:i,recipientMap:o}=HO(a,e);for(const l of i)r.has(l.name)||(t.push(l),r.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(h=>s[l].add(h))}}return{sorted:t,recipientCounts:Gae(s)}}function Gae(n){const e={};for(const t in n)e[t]=n[t].size;return e}function HO(n,e){const t=new Set,s=[],r={};for(const o of e.names())t.add(o);const a=[],i=[];for(a.push(n);a.length>0;){const o=a[a.length-1];if(t.has(o.name)){a.pop();continue}const l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),s.push(o),t.add(o.name),l&&i.pop();else{i.push(a.length-1);for(const h of o.inputs)r[h.name]==null&&(r[h.name]=new Set),r[h.name].add(o.name),!t.has(h.name)&&a.push(h)}}return{sorted:s,recipientMap:r}}function Hae(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}const qae=ie();qae.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,jae);function Sk(n,e){return re(()=>Pn(Re(Y(n,n),e,!0)))}class Jm extends yu{getConfig(){return{}}}class Tk extends Jm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return re(()=>{const t=Sk(e,this.axis),s=Rs(t,0,this.maxValue);return Y(e,Fe(s,we($n(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Tk.className="MaxNorm";ve(Tk);class Ck extends Jm{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return re(()=>Fe(e,we($n(),Sk(e,this.axis))))}getConfig(){return{axis:this.axis}}}Ck.className="UnitNorm";ve(Ck);class Nk extends Jm{apply(e){return Ta(e)}}Nk.className="NonNeg";ve(Nk);class kk extends Jm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return re(()=>{const t=Sk(e,this.axis),s=we(Y(this.rate,Rs(t,this.minValue,this.maxValue)),Y(1-this.rate,t));return Y(e,Fe(s,we($n(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}kk.className="MinMaxNorm";ve(kk);const qO={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function In(n){return hk(n)}function KO(n,e={}){return qm(n,yr.getMap().classNameMap,e,"constraint")}function _n(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in qO?qO[n]:n,config:{}};return KO(t)}else return n instanceof Jm?n:KO(n)}function Kae(n){return new Tk(n)}function Xae(n){return new Ck(n)}function Yae(){return new Nk}function Jae(n){return new kk(n)}const Zae=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Kae,minMaxNorm:Jae,nonNeg:Yae,unitNorm:Xae},Symbol.toStringTag,{value:"Module"}));function Qae(){return new pk}function eie(){return new pw}function tie(n){return new mk(n)}function nie(n){return new gk(n)}function sie(n){return new yk(n)}function rie(n){return new bk(n)}function aie(n){return new xk(n)}function iie(n){return new Os(n)}function oie(n){return new mw(n)}function lie(n){return new gw(n)}function uie(n){return new yw(n)}function cie(n){return new bw(n)}function hie(n){return new xw(n)}function die(n){return new ww(n)}function fie(n){return new wk(n)}const pie=Object.freeze(Object.defineProperty({__proto__:null,constant:tie,glorotNormal:lie,glorotUniform:oie,heNormal:uie,heUniform:cie,identity:aie,leCunNormal:hie,leCunUniform:die,ones:eie,orthogonal:fie,randomNormal:sie,randomUniform:nie,truncatedNormal:rie,varianceScaling:iie,zeros:Qae},Symbol.toStringTag,{value:"Module"}));async function po(n){if(n==null)return;const e=[],t=[],s=[];for(const r in n){const a=n[r];if(typeof a!="number"){const i=a;e.push(i.data()),t.push(r),s.push(i)}}if(e.length>0){const r=await Promise.all(e);for(let a=0;a<r.length;++a)n[t[a]]=r[a][0];Je(s)}}function tB(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var XO;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(XO||(XO={}));const mie=125;class Hc{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class nB{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class gie extends Hc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const r in t){const a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*s;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const o=re(()=>we(this.totals[r],Y(a,s)));this.totals[r]=o,i?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:re(()=>{const r=Y(Fe(1,this.seen),this.totals[s]);t[s]=r,this.totals[s].dispose(),En(t[s])}))}}class sB extends Hc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];e.push(l.data()),t.push(a),s.push(o)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][s[a]].dispose(),this.history[t[a]][s[a]]=r[a][0]}}class rB extends Hc{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||WN,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=mie),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");E0(this.yieldEvery)&&(this.maybeWait=fae(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const r=[];this.yield!=null&&(await po(s),r.push(this.yield(e,t,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await po(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await po(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await po(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await po(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):E0(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await po(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await po(e),await this.trainEnd(e))}}function aB(n,e){return n==null&&(n={}),n instanceof Hc?[n]:Array.isArray(n)&&n[0]instanceof Hc?n:Ct(n).map(s=>new rB(s,e))}class fr{constructor(){}static registerCallbackConstructor(e,t){O(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),fr.checkForDuplicate(t),fr.constructors[e]==null&&(fr.constructors[e]=[]),fr.constructors[e].push(t)}static checkForDuplicate(e){for(const t in fr.constructors)fr.constructors[+t].forEach(r=>{if(r===e)throw new Z("Duplicate callback constructor.")})}static clear(){fr.constructors={}}static createCallbacks(e){const t=[];for(const s in fr.constructors){const r=+s;e>=r&&t.push(...fr.constructors[r])}return t.map(s=>new s)}}fr.constructors={};function iB(n,e,t,s,r,a,i,o,l){const h=new sB,d=[new gie,...fr.createCallbacks(e)];n!=null&&d.push(...n),d.push(h);const f=new nB(d);return f.setParams({epochs:t,initialEpoch:s,samples:r,steps:a,batchSize:i,verbose:e,doValidation:o,metrics:l}),{callbackList:f,history:h}}function ma(n,e={},t=!1){return qm(n,yr.getMap().classNameMap,e,"layer",t)}function B0(n,e){return re(()=>{n.dtype!=="float32"&&(n=Ne(n,"float32"));const t=Re(Xm(n),e,!0),s=pu(t.shape,$n()),r=Pn(Xa(t,s));return Fe(n,r)})}function xu(n,e){return re(()=>Kt(Xm(Ae(e,n)),-1))}function Sw(n,e){return re(()=>Kt(mn(Ae(e,n)),-1))}function rd(n,e){return re(()=>{const t=Ae(n,e),s=Rs(mn(n),$n(),Number.MAX_VALUE),r=mn(Fe(t,s));return Y(100,Kt(r,-1))})}function yie(n,e){return re(()=>{const t=Rs(e,$n(),Number.MAX_VALUE),s=Js(we(1,t)),r=Rs(n,$n(),Number.MAX_VALUE),a=Js(we(1,r));return Kt(Xm(Ae(s,a)),-1)})}function bie(n,e){return re(()=>{const t=Xa(0,Ae(1,Y(n,e)));return Kt(Xm(t),-1)})}function xie(n,e){return re(()=>{const t=Xa(0,Ae(1,Y(n,e)));return Kt(t,-1)})}function wie(n,e){return re(()=>{const t=Re(Y(n,e),-1),s=Sr(Y(Ae(1,n),e),-1);return Xa(0,we(1,Ae(s,t)))})}function vie(n,e){return re(()=>{const t=Math.log(2),s=Ae(e,n),r=Ae(we(s,mu(Y(-2,s))),t);return Kt(r,-1)})}function lp(n,e,t=!1){return re(()=>{if(t)e=Vm(e);else{const s=Re(e,e.shape.length-1,!0);e=Fe(e,s)}return e=Rs(e,$n(),1-$n()),Mt(Re(Y(Ne(n,"float32"),Js(e)),e.shape.length-1))})}function V0(n,e,t=!1){return re(()=>{const s=Ne(Qh(Nae(n)),"int32");e=Rs(e,$n(),1-$n());const r=e.shape,a=J(Vc(s,r[r.length-1]),r);return lp(a,e,t)})}function Sie(n,e){if(!lt(n.shape,e.shape))throw new Z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return re(()=>{const t=Ta(e),s=Mt(mn(e));return we(Ae(t,Y(e,n)),Rm(Ds(s)))})}function Tw(n,e){return re(()=>{let t;return t=Rs(e,$n(),1-$n()),t=Js(Fe(t,Ae(1,t))),Kt(Sie(n,t),-1)})}function Tie(n,e){return re(()=>{const t=Rs(n,$n(),1),s=Rs(e,$n(),1);return Re(Y(n,Js(Fe(t,s))),-1)})}function Cie(n,e){return re(()=>{const t=Js(we($n(),e));return Kt(Ae(e,Y(n,t)),-1)})}function Ek(n,e){return re(()=>{const t=B0(n,-1),s=B0(e,-1),r=Y(t,s);return Mt(Re(r,-1))})}const U0={meanSquaredError:xu,meanAbsoluteError:Sw,meanAbsolutePercentageError:rd,meanSquaredLogarithmicError:yie,squaredHinge:bie,hinge:xie,categoricalHinge:wie,logcosh:vie,categoricalCrossentropy:lp,sparseCategoricalCrossentropy:V0,binaryCrossentropy:Tw,kullbackLeiblerDivergence:Tie,poisson:Cie,cosineProximity:Ek};function MS(n){if(typeof n=="string"){if(n in U0)return U0[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Z(e)}else return n}function $k(n,e){return re(()=>{const t=Y(.5,Zs(e)),s=Ua(vs(e,t),n.dtype);return Kt(Ys(n,s),-1)})}function Ik(n,e){return re(()=>Ua(Ys(Yl(n,-1),Yl(e,-1)),"float32"))}function oB(n,e){return re(()=>Ne(Re(qr(Ys(n,1),Ys(e,1))),"float32"))}function Nie(n,e){return re(()=>Ne(Re(qr(Ys(n,1),Ys(e,0))),"float32"))}function kie(n,e){return re(()=>Ne(Re(qr(Ys(n,0),Ys(e,1))),"float32"))}function lB(n,e){return re(()=>{const t=oB(n,e),s=kie(n,e),r=we(t,s);return Ne(Mn(vs(r,0),Fe(t,r),0),"float32")})}function Eie(n,e){return re(()=>{const t=oB(n,e),s=Nie(n,e),r=we(t,s);return Ne(Mn(vs(r,0),Fe(t,r),0),"float32")})}function uB(n,e){return Tw(n,e)}function cB(n,e){return n.rank===e.rank&&(n=Ho(n,[n.rank-1])),e=Yl(e,-1),e.dtype!==n.dtype&&(e=Ne(e,n.dtype)),Ne(Ys(n,e),"float32")}function $ie(n,e){return re(()=>{const t=n.sub(e).square().sum(),s=n.sub(n.mean()).square().sum();return ze(1).sub(t.div(s))})}const Iie=xu,_ie=xu,Aie=Sw,Rie=Sw,Die=rd,Oie=rd,_k=lp,Fie=Ek,hB=V0,j0={binaryAccuracy:$k,categoricalAccuracy:Ik,precision:lB,categoricalCrossentropy:_k,sparseCategoricalCrossentropy:hB,mse:Iie,MSE:_ie,mae:Aie,MAE:Rie,mape:Die,MAPE:Oie,cosine:Fie};function Lie(n){if(typeof n=="string"&&n in j0)return j0[n];if(typeof n!="string"&&n!=null)return n;throw new Z(`Unknown metric ${n}`)}function zy(n){if(Da(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(U0))if(U0[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(j0))if(j0[t]===n){e=t;break}return e!==void 0?e:n.name}}function Mie(n){const e={Adagrad:()=>Nl.adagrad(.01),Adadelta:()=>Nl.adadelta(1,.95,$n()),Adam:()=>Nl.adam(.001,.9,.999,$n()),Adamax:()=>Nl.adamax(.002,.9,.999,$n(),0),RMSProp:()=>Nl.rmsprop(.001,.9,0,$n()),SGD:()=>Nl.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new Z(`Unknown Optimizer ${n}`)}const YO=1*1024*1024;function JO(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!JT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>YO&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${YO}.`)}}function JT(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!JT(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!JT(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function zie(n,e,t,s=console.log){const r=Bie(n),a=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let i;if(!r){a.push("Receives inputs"),i=[];for(const d in n.nodesByDepth)i.push(...n.nodesByDepth[d])}s("_".repeat(e)),W0(a,t,s),s("=".repeat(e));const o=n.layers;for(let d=0;d<o.length;++d)r?Vie(o[d],t,s):Uie(o[d],t,i,s),s((d===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Pie(n),h=M0(n.nonTrainableWeights);s(`Total params: ${l+h}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${h}`),s("_".repeat(e))}function Pie(n){let e;return n.collectedTrainableWeights!=null?e=M0(n.collectedTrainableWeights):e=M0(n.trainableWeights),e}function Bie(n){let e=!0;const t=[],s=[];for(const r in n.nodesByDepth)t.push(n.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of n.layers){let a=!1;for(const i of r.inboundNodes)if(s.indexOf(i)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function W0(n,e,t=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);t(s)}function Vie(n,e,t){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const a=n.name,i=n.getClassName(),o=[`${a} (${i})`,r,s,n.countParams().toString()];W0(o,e,t)}function Uie(n,e,t,s){let r,a;try{a=n.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=[];for(const f of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(f)===-1))for(let m=0;m<f.inboundLayers.length;++m){const y=f.inboundLayers[m].name,b=f.nodeIndices[m],x=f.tensorIndices[m];i.push(`${y}[${b}][${x}]`)}const o=n.name,l=n.getClassName(),h=i.length===0?"":i[0],d=[`${o} (${l})`,a,r,n.countParams().toString(),h];W0(d,e,s);for(let f=1;f<i.length;++f)W0(["","","","",i[f]],e,s)}function dB(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function up(n,e){if(n===null)return null;if(typeof n=="string")return _l(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const a=n[r];dB(e,r,a)?t.push(a):t.push(up(a,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s];if(s==="name"&&typeof r=="string")t[s]=r;else{const a=_l(s);t[a]=up(r,a)}}return t}}function ZT(n,e){if(n==null)return null;if(typeof n=="string")return yi(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let r=0;r<s;++r){const a=n[r];dB(e,r,a)?t.push(a):t.push(ZT(a,e))}return t}else{const t={};for(const s of Object.keys(n)){const r=n[s],a=yi(s);(s==="name"||s==="className")&&typeof r=="string"?t[a]=r:t[a]=ZT(r,s)}return t}}const Cw="4.22.0";const jie=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class oa extends it{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const C=this.getClassName().toLowerCase();this.name=dw(C)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Co(this.inputs).length!==this.inputs.length)throw new Z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(C=>C.name)}`);Co(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(C=>C.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const C of this.outputs){const N=C.sourceLayer,k=C.nodeIndex,E=C.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(E)}for(const C of this.inputs){const N=C.sourceLayer,k=C.nodeIndex,E=C.tensorIndex;Da(k===0,"input layer has >1 nodes"),Da(E===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let C=0;C<this.inputLayers.length;C++){const N=this.inputLayers[C];if(!(N instanceof sd))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${C} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(const C of this.outputLayers)this.outputNames.push(C.name);this.internalInputShapes=this.inputs.map(C=>C.shape),this.internalOutputShapes=this.outputs.map(C=>C.shape);const t={},s={},r={},a={},i={},o=[],l=(C,N,k,E,_,R)=>{(E==null||_==null||R==null)&&(E=C.sourceLayer,_=C.nodeIndex,R=C.tensorIndex);const D=E.inboundNodes[_];if(k.indexOf(D)!==-1)throw new Gr(`The tensor ${C.name} at layer "${E.name}" is part of a cycle.`);if(N.indexOf(D)!==-1)return;this.containerNodes.add(oa.nodeKey(E,_)),E.id in i||(i[E.id]=Object.keys(i).length),k.indexOf(D)===-1&&k.push(D);const F=D.inboundLayers.length;for(let L=0;L<F;L++){const A=D.inputTensors[L],V=D.inboundLayers[L],q=D.nodeIndices[L],ne=D.tensorIndices[L];l(A,N,k,V,q,ne)}for(N.push(D);k.indexOf(D)>=0;)k.splice(k.indexOf(D),1);o.push(D)},h=[],d=[];for(const C of this.outputs)l(C,h,d);const f=o.slice().reverse();for(const C of f){s[C.id]=C,C.id in t||(t[C.id]=0);let N=t[C.id];const k=r[C.outboundLayer.id]==null?0:r[C.outboundLayer.id];N=Math.max(N,k),r[C.outboundLayer.id]=N,a[C.outboundLayer.id]=C.outboundLayer,t[C.id]=N;for(let E=0;E<C.inboundLayers.length;E++){const _=C.inboundLayers[E],R=C.nodeIndices[E],D=_.inboundNodes[R],F=t[D.id]==null?0:t[D.id];t[D.id]=Math.max(N+1,F),s[D.id]=D}}const m={};for(const C in t){const N=t[C];N in m||(m[N]=[]),m[N].push(s[C])}const y={};for(const C in r){const N=r[C];N in y||(y[N]=[]),y[N].push(a[C])}let b=Object.keys(y).map(C=>parseInt(C,10)).sort(Fy);this.layers=[];for(const C of b){const N=y[C];N.sort((k,E)=>{const _=i[k.id],R=i[E.id];return _<R?-1:_>R?1:0});for(const k of N)k instanceof oa&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=y,b=Object.keys(m).map(C=>parseInt(C,10)).sort(Fy);const x=this.inputs.slice(),w=[];for(const C of b)for(const N of m[C]){const k=N.outboundLayer;if(k!=null){for(const E of N.inputTensors)if(x.indexOf(E)===-1)throw new Gr(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${k.name}". The following previous layers were accessed without issue: ${w}`);for(const E of N.outputTensors)x.push(E);w.push(k.name)}}this.nodesByDepth=m;const v=this.layers.map(C=>C.name);for(const C of v){const N=v.filter(k=>k===C).length;if(N!==1)throw new Gr(`The name "${C}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new vw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(C=>null),outputMasks:this.outputs.map(C=>null),inputShapes:this.inputs.map(C=>C.shape),outputShapes:this.outputs.map(C=>C.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let r=0;const a=jie(e);a&&this.parseWeights(e);for(const o of this.layers)for(const[l,h]of o.weights.entries()){const d=a?`${h.name.split("/").slice(0,-1).join("/")+"/"}${l}`:h.originalName;if(s[d]!=null)throw new Z(`Duplicate weight name: ${d}`);s[d]=h,r++}const i=[];for(const o in e){let l=o;if(s[o]==null){const h=o.split("/");l=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(s[l]!=null)i.push([s[l],e[o]]);else if(t)throw new Z(`Provided weight data has no target variable: ${o}`);delete s[l]}if(t){const o=[];for(const l in s)o.push(l);if(o.length>0)throw new Z(`${o.length} of ${r} weights are not set: ${o}`)}vk(i)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=s.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Cw}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=ZT(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return re(()=>{e=Ct(e);const s=new xo;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return Tf(this.outputs,s,t)})}computeMask(e,t){return re(()=>{e=Ct(e);let s;return t==null?s=nu(null,e.length):s=Ct(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=L0(e);if(t.length!==this.inputLayers.length)throw new Z(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const l=this.inputLayers[o],h=t[o],d=l.name+"_0_0";s[d]=h}const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Fy);if(r.length>1)for(const o of r){const l=this.nodesByDepth[o];for(const h of l){const d=h.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const f=[];for(let x=0;x<h.inboundLayers.length;x++){const w=h.inboundLayers[x],v=h.nodeIndices[x],C=h.tensorIndices[x],N=`${w.name}_${v}_${C}`,k=s[N];f.push(k)}const m=d.computeOutputShape(ks(f)),y=L0(m),b=d.inboundNodes.indexOf(h);for(let x=0;x<y.length;x++){const w=`${d.name}_${b}_${x}`;s[w]=y[x]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],h=this.outputLayersNodeIndices[o],d=this.outputLayersTensorIndices[o],f=`${l.name}_${h}_${d}`;i.push(f)}for(let o=0;o<i.length;o++){const l=i[o];Da(l in s),a.push(s[l])}return ks(a)}runInternalGraph(e,t){t==null&&(t=nu(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const h=this.inputs[l],d=e[l],f=t[l];s[h.id]=[d,f]}const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Fy);for(const l of r){const h=this.nodesByDepth[l];for(const d of h){const f=d.outboundLayer,m=d.inputTensors,y=d.outputTensors,b=new Array;for(const x of m)x.id in s&&b.push(s[x.id]);if(b.length===m.length){let x={},w,v,C,N;if(d.callArgs!=null&&(x=d.callArgs),b.length===1){const[k,E]=b[0];x.mask==null&&(x.mask=E),C=Ct(f.call(k,x)),N=Ct(f.computeMask(k,E)),w=[k],v=[E]}else w=b.map(k=>k[0]),v=b.map(k=>k[1]),x.mask==null&&(x.mask=v),C=Ct(f.call(w,x)),N=Ct(f.computeMask(w,v));if(f.activityRegularizer)throw new et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<y.length;++k){const E=y[k],_=C[k],R=N[k];s[E.id]=[_,R]}}}}const a=[],i=[],o=[];for(const l of this.outputs){Da(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[h,d]=s[l.id];o.push(h.shape),a.push(h),i.push(d)}return[a,i,o]}buildNodeConversionMap(e){const t={};let s;for(const r of this.layers){s=r instanceof oa?1:0;for(let a=0;a<r.inboundNodes.length;a++){const i=oa.nodeKey(r,a);this.containerNodes.has(i)&&(t[i]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new Z("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new Z(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return re(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const r=oa.nodeKey(t,s);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),h=[];for(let f=0;f<i.inboundNodes.length;f++){const m=i.inboundNodes[f],y=oa.nodeKey(i,f);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const x=[];for(let w=0;w<m.inboundLayers.length;w++){const v=m.inboundLayers[w],C=m.nodeIndices[w],N=m.tensorIndices[w],k=oa.nodeKey(v,C);let E=t[k];E==null&&(E=0),x.push([v.name,E,N,b])}h.push(x)}}}const d={};d.name=i.name,d.className=o,d.config=l,d.inboundNodes=h,s.push(d)}e.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],h=oa.nodeKey(o,l);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const f=this.inputLayersTensorIndices[i];r.push([o.name,d,f])}e.inputLayers=r;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],h=oa.nodeKey(o,l);if(!this.containerNodes.has(h))continue;let d=t[h];d==null&&(d=0);const f=this.outputLayersTensorIndices[i];a.push([o.name,d,f])}return e.outputLayers=a,e}static fromConfig(e,t,s={},r=!1){const a={},i={};function o(w,v){w.name in i?i[w.name].push(v):i[w.name]=[v]}function l(w,v){const C=[];let N;for(const k of v){const E=k[0],_=k[1],R=k[2];if(N=k[3]==null?{}:k[3],!(E in a)){o(w,v);return}const D=a[E];if(D.inboundNodes.length<=_){o(w,v);return}const F=D.inboundNodes[_];C.push(F.outputTensors[R])}C.length>0&&w.apply(ks(C),N)}function h(w){const v=w.name,C=ma(w,t.customObjects!=null?t.customObjects:{});C.setFastWeightInitDuringBuild(r),a[v]=C,w.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new Z(`Corrupted configuration, expected array for nodeData: ${k}`);o(C,k)})}const d=t.name,f=t.layers;for(const w of f)h(w);for(;!dae(i);)for(const w of f){const v=a[w.name];if(v.name in i){const C=i[v.name];delete i[v.name];for(const N of C)l(v,N)}}const m=[],y=[],b=t.inputLayers;for(const w of b){const v=w[0],C=w[1],N=w[2];Da(v in a);const E=a[v].inboundNodes[C].outputTensors;m.push(E[N])}const x=t.outputLayers;for(const w of x){const v=w[0],C=w[1],N=w[2];Da(v in a);const E=a[v].inboundNodes[C].outputTensors;y.push(E[N])}return new e({inputs:m,outputs:y,name:d})}get stateful(){if(this._stateful)throw new Z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){re(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function Wie(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const r=[];return e.forEach(a=>{a in n?r.push(n[a]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function fB(n,e){return Wie(n,e,"classWeight")}async function pB(n,e,t,s){if(t!=null){const r=re(()=>{if(n.shape.length===1)return Ba(n);if(n.shape.length===2){if(n.shape[1]>1)return Yl(n,1);if(n.shape[1]===1)return J(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await r.data());Je(r);const i=[];return a.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(t[o])}),Xn(i,"float32")}else return null}function Gie(n,e){return Y(n,e)}const Hie=32;function mB(n,e){let t,s;const r=e;t=r.xs,s=r.ys,O(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=ZO("input",n.inputNames,t),i=ZO("output",n.outputNames,s),o=a[0].shape[0];O(a.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),O(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<a.length;l++)O(a[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<i.length;l++)O(i[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:a,ys:i}}function ZO(n,e,t){if(t instanceof bt)return[t];if(Array.isArray(t))return O(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const r of e){if(t[r]==null)throw new Z(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(t[r])}return s}}function qie(n){if(n.length===3)throw new et("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Kie(n,e,t){const s=t.batchesPerEpoch!=null;if(O(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),O(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),O(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=t.validationData!=null;let a,i;if(r)if(QO(t.validationData))O(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const w=qie(t.validationData);a=w.xs,i=w.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let h;r?h=l.slice().concat(l.map(w=>"val_"+w)):h=l.slice();const d=aB(t.callbacks,t.yieldEvery),f=t.verbose==null?1:t.verbose,{callbackList:m,history:y}=iB(d,f,t.epochs,null,null,Xie(e,t),null,r,h);m.setModel(n),n.history=y,await m.onTrainBegin(),n.stopTraining_=!1;let b=t.initialEpoch==null?0:t.initialEpoch,x=await e.iterator();for(;b<t.epochs;){const w={};await m.onEpochBegin(b);let v=0,C=0;for(s||(x=await e.iterator());!s||v<t.batchesPerEpoch;){const N=await x.next();if(s&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){const{xs:k,ys:E}=mB(n,N.value),_={};_.batch=C,_.size=k[0].shape[0],await m.onBatchBegin(C,_);const R=[];if(t.classWeight!=null){const L=fB(t.classWeight,n.outputNames);for(let A=0;A<L.length;++A)R.push(await pB(E[A],null,L[A]))}const D=k.concat(E).concat(R),F=o(D);Je(D);for(let L=0;L<l.length;++L){const A=l[L],V=F[L];_[A]=V,En(V)}await m.onBatchEnd(C,_),tB(_),C++,v++}if(s?v>=t.batchesPerEpoch:N.done){if(r){let k;QO(t.validationData)?k=Ct(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):k=Ct(n.evaluate(a,i,{batchSize:t.validationBatchSize==null?Hie:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)w[`val_${n.metricsNames[E]}`]=k[E]}break}if(n.stopTraining_)break}if(await m.onEpochEnd(b,w),b++,n.stopTraining_)break}return await m.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Xie(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function QO(n){return typeof n.iterator=="function"}function Yie(n){return typeof n.next=="function"}async function Jie(n,e,t){t=t||{};const s=t.batches!=null,r=n.testFunction;let a=[];if(t.verbose>0)throw new et("Verbose mode is not implemented yet.");O(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const i=Yie(e)?e:await e.iterator();let o=0,l=0;for(;!s||l<t.batches;){const h=await i.next();if(a=re(()=>{if(h.value){const{xs:d,ys:f}=mB(n,h.value),m=d.concat(f),y=re(()=>r(m));if(Je(m),l===0)for(let x=0;x<y.length;++x)a.push(ze(0));const b=m[0].shape[0];for(let x=0;x<y.length;++x){const w=y[x],v=a[x];a[x]=re(()=>we(a[x],Y(b,w))),l>0&&Je(v)}Je(y),o+=b,++l}return a}),h.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let h=0;h<a.length;++h){const d=a[h];a[h]=Fe(a[h],o),Je(d)}return ks(a)}function zS(n){O(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function mf(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Gl(s,e,t-e)):Gl(n,e,t-e)}function QT(n,e){return re(()=>n==null?null:Array.isArray(n)?n.map(t=>QT(t,e)):YP(n,e.dtype==="int32"?e:Ne(e,"int32")))}function PS(n,e){const t=[];let s=0,r=null;for(;s<n;)r=s+e,r>=n&&(r=n),t.push([s,r]),s=r;return t}function gB(n){const e=[];n instanceof bt&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(Km(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function ra(n,e){if(n==null)return;const t=[];if(e instanceof bt)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const a=e[r];t.push(a.id)}const s=[];if(n instanceof bt)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{t.indexOf(r.id)===-1&&s.push(r)});else if(n!=null)for(const r in n){const a=n[r];t.indexOf(a.id)===-1&&s.push(a)}s.forEach(r=>{r.isDisposed||r.dispose()})}function Zie(n){return n instanceof bt}function eC(n){return Array.isArray(n)}function e3(n){return!Zie(n)&&!eC(n)}function t3(n,e,t,s=!0,r=""){if(e==null||e.length===0){if(n!=null){let i=!1;if(eC(n)&&n.length>0)i=!0;else if(e3(n)){for(const o in n)if(n.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new Z(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(i=>null);let a;if(e3(n)){n=n,a=[];for(const i of e){if(n[i]==null)throw new Z(`No data provided for "${i}". Need data for each key in: ${e}`);a.push(n[i])}}else if(eC(n)){if(n=n,n.length!==e.length)throw new Z(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);a=n}else{if(n=n,e.length>1)throw new Z(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);a=[n]}if(a=gB(a),t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;const o=a[i];if(o.shape.length!==t[i].length)throw new Z(`Error when checking ${r}: expected ${e[i]} to have ${t[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<t[i].length;++l){if(l===0&&!s)continue;const h=o.shape[l],d=t[i][l];if(d!=null&&d>=0&&h!==d)throw new Z(`${r} expected a batch of elements where each example has shape [${t[i].slice(1,t[i].length)}] (i.e.,tensor shape [*,${t[i].slice(1,t[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function Qie(n,e,t){const s=Co(n.map(a=>a.shape[0]));s.sort();const r=Co(e.map(a=>a.shape[0]));if(r.sort(),s.length>1)throw new Z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(a=>a.shape))}`);if(r.length>1)throw new Z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>0&&r.length>0&&!lt(s,r))throw new Z(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function eoe(n,e,t){const s=[xu,Tw,lp];for(let r=0;r<n.length;++r){const a=n[r],i=e[r],o=t[r];if(i!=null){if(i===lp&&a.shape[a.shape.length-1]===1)throw new Z(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(i)!==-1){const l=a.shape.slice(1),h=o.slice(1);for(let d=0;d<l.length;++d){const f=l[d],m=h[d];if(m!=null&&f!==m)throw new Z(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function n3(n,e,t,s=!0,r=""){let a;if(Array.isArray(n)){if(n.length!==e.length)throw new Z(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);a=n}else{if(e.length>1)throw new Z(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);a=[n]}if(t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;const o=a[i];if(o.shape.length!==t[i].length)throw new Z(`Error when checking ${r}: expected ${e[i]} to have ${t[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<t[i].length;++l){if(l===0&&!s)continue;const h=o.shape[l],d=t[i][l];if(d!=null&&d!==h)throw new Z(`Error when checking ${r}: expected ${e[i]} to have shape ${JSON.stringify(t[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function toe(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const r of e){let a=t.hasOwnProperty(r)?t[r]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}const noe="layers-model";class Si extends oa{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new Z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");zie(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Mie(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Bi))throw new Z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new Z(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),t.push(MS(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>MS(o))}else{const i=MS(e.loss);this.outputs.forEach(o=>{t.push(i)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Wl("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=toe(e.metrics,this.outputNames),a=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};Wl("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const o=r[i];(h=>{let f,m,y;for(const b of h){if(typeof b=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(b)!==-1){const w=this.internalOutputShapes[i];w[w.length-1]===1||this.lossFunctions[i]===Tw?["accuracy","acc"].indexOf(b)!==-1?m=$k:["crossentropy","ce"].indexOf(b)!==-1&&(m=uB):this.lossFunctions[i]===V0?["accuracy","acc"].indexOf(b)!==-1?m=cB:["crossentropy","ce"].indexOf(b)!==-1&&(m=hB):["accuracy","acc"].indexOf(b)!==-1?m=Ik:["crossentropy","ce"].indexOf(b)!==-1&&(m=_k);let v;["accuracy","acc"].indexOf(b)!==-1?v="acc":["crossentropy","ce"].indexOf(b)!==-1&&(v="ce"),y=m,f=""+v}else y=Lie(b),f=""+zy(b);let x;Wl(f,()=>{x=y}),a(i,f,x)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const r=s.batchSize==null?32:s.batchSize;zS(r);const i=this.standardizeUserDataXY(e,t,!0,r);try{const o=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,h=this.testLoop(l,o,r,s.verbose,s.steps);return ks(h)}finally{ra(i[0],e),ra(i[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Jie(this,e,t)}checkNumSamples(e,t,s,r="steps"){let a;if(s!=null){if(a=null,t!=null)throw new Z(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new Z(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Z("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),r=s?t:[t],a=this.retrieveSymbolicTensors(r),i=new xo;if(e instanceof bt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Z(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],e[l])}else for(const l of this.inputs){const h=e[l.name];if(h==null)throw new Z(`No value is provided for the model's input ${l.name}`);i.add(l,h)}const o=Tf(a,i);return s?o:o[0]}retrieveSymbolicTensors(e){const t=nu(null,e.length);let s=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],i=a.map(o=>o.name);for(let o=0;o<e.length;++o){const l=i.indexOf(e[o]);if(l!==-1&&(t[o]=a[l],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw t.forEach((a,i)=>{a==null&&r.push(e[i])}),new Z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,s=!1){return re(()=>{const r=this.checkNumSamples(e);if(s)throw new et("Verbose predictLoop() is not implemented yet.");const a=PS(r,t),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)re(()=>{const h=a[o][0],d=a[o][1],f=mf(e,h,d),m=[];if(Array.isArray(f))for(let b=0;b<f.length;++b)m.push({key:this.inputs[b],value:f[b]});else m.push({key:this.inputs[0],value:f});const y=new xo(m);return Tf(this.outputs,y)}).forEach((h,d)=>i[d].push(h));return ks(i.map(o=>ln(o,0)))})}predict(e,t={}){const s=gB(e);n3(s,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return zS(r),this.predictLoop(s,r)}finally{ra(s,e)}}predictOnBatch(e){n3(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,r){if(this.optimizer_==null)throw new Gr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===V0?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(e=t3(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=t3(t,this.feedOutputNames,a,!1,"target"),Qie(e,t),eoe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new Z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,r,a=!0,i){const[o,l]=this.standardizeUserDataXY(e,t,a,i);if(s!=null)throw new Error("sample weight is not supported yet.");let h=null;if(r!=null){const d=fB(r,this.outputNames);h=[];for(let f=0;f<d.length;++f)h.push(await pB(l[f],null,d[f]))}return[o,l,h]}testLoop(e,t,s,r=0,a){return re(()=>{const i=this.checkNumSamples(t,s,a,"steps"),o=[];if(r>0)throw new et("Verbose mode is not implemented yet.");if(a!=null)throw new et("steps mode in testLoop() is not implemented yet");{const l=PS(i,s),h=Xn(ya(0,i));for(let d=0;d<l.length;++d){const f=l[d][0],m=l[d][1],y=Gl(h,f,m-f),b=QT(t,y),x=e(b);if(d===0)for(let w=0;w<x.length;++w)o.push(ze(0));for(let w=0;w<x.length;++w){const v=x[w];o[w]=we(o[w],Y(m-f,v))}}for(let d=0;d<o.length;++d)o[d]=Fe(o[d],i)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const r=e[s];let a=r;if(BO(e,r)>1){const i=BO(e.slice(0,s),r);a+=`_${i}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const f=[];for(let x=0;x<this.inputs.length;++x)f.push({key:this.inputs[x],value:s[x]});const m=new xo(f),y=Tf(this.outputs,m,{training:!0});let b;for(let x=0;x<this.lossFunctions.length;++x){const w=this.lossFunctions[x];let v=w(r[x],y[x]);a[x]!=null&&(v=Gie(v,a[x]));const C=Kt(v);t.push(C),x===0?b=v:b=we(b,v)}for(let x=0;x<this.metricsTensors.length;++x){let w;if(this.outputs.length>1&&x<this.outputs.length)w=t[x];else{const v=this.metricsTensors[x][0],C=this.metricsTensors[x][1];w=Kt(v(r[C],y[C]))}En(w),i.push(w)}return b=Kt(b),this.calculateLosses().forEach(x=>{b=we(b,x)}),b},l=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(o,!0,l)].concat(i)}}makeTestFunction(){this.testFunction=e=>re(()=>{const t=[];let s;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let h=0;h<this.inputs.length;++h)i.push({key:this.inputs[h],value:r[h]});const o=new xo(i),l=Tf(this.outputs,o);for(let h=0;h<this.lossFunctions.length;++h){const d=this.lossFunctions[h],f=Kt(d(a[h],l[h]));h===0?s=f:s=we(s,f),t.push(s)}for(let h=0;h<this.metricsTensors.length;++h){const d=this.metricsTensors[h][0],f=this.metricsTensors[h][1],m=Kt(d(a[f],l[f]));t.push(m)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,i,o,l,h,d,f,m;try{const y=s.batchSize==null?32:s.batchSize;zS(y);const x=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,y);r=x[0],a=x[1],m=x[2];let w=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(w=!0,s.validationData.length===2)l=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new et("validationData including sample weights is not supported yet."):new Z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const L=await this.standardizeUserData(l,h,null,null,!0,y);d=L[0],f=L[1],v=d.concat(f)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){w=!0;const F=Math.floor(r[0].shape[0]*(1-s.validationSplit)),L=r[0].shape[0];d=mf(r,F,L),i=r,r=mf(r,0,F),f=mf(a,F,L),o=a,a=mf(a,0,F),v=d.concat(f)}else s.validationSteps!=null&&(w=!0);const C=r.concat(a).concat(m);this.checkTrainableWeightsConsistency();const N=this.makeTrainFunction(),k=this.getDedupedMetricsNames();let E,_;w?(this.makeTestFunction(),E=this.testFunction,_=k.slice().concat(k.map(F=>"val_"+F))):(E=null,v=[],_=k.slice());const R=aB(s.callbacks,s.yieldEvery);return await this.fitLoop(N,C,k,y,s.epochs,s.verbose,R,E,v,s.shuffle,_,s.initialEpoch,null,null)}finally{this.isTraining=!1,ra(r,e),ra(a,t),ra(i,e),ra(o,t),ra(d,l),ra(f,h),m!=null&&Je(m)}}async fitLoop(e,t,s,r,a,i,o,l,h,d,f,m,y,b){r==null&&(r=32),a==null&&(a=1),d==null&&(d=!0),m==null&&(m=0);let x=!1;if(l!=null&&h!=null&&(x=!0),b!=null&&(x=!0,y==null))throw new Z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const w=this.checkNumSamples(t,r,y,"steps_per_epoch");let v;w!=null&&(v=ya(0,w)),i==null&&(i=1);const{callbackList:C,history:N}=iB(o,i,a,m,w,y,r,x,f);C.setModel(this),this.history=N,await C.onTrainBegin(),this.stopTraining_=!1;for(let k=m;k<a;++k){await C.onEpochBegin(k);const E={};if(y!=null)throw new et("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new et("batch shuffling is not implemneted yet");d&&c2(v);const _=Xn(v),R=PS(w,r);for(let D=0;D<R.length;++D){const F={};if(await C.onBatchBegin(D,F),re(()=>{const L=R[D][0],A=R[D][1],V=Gl(_,L,A-L);F.batch=D,F.size=A-L;const q=QT(t,V),ne=e(q);for(let Q=0;Q<s.length;++Q){const B=s[Q],U=ne[Q];F[B]=U,En(U)}if(D===R.length-1&&x){const Q=this.testLoop(l,h,r);for(let B=0;B<s.length;++B){const U=s[B],X=Q[B];En(X),E["val_"+U]=X}}}),await C.onBatchEnd(D,F),tB(F),this.stopTraining_)break}_.dispose()}if(await C.onEpochEnd(k,E),this.stopTraining_)break}return await C.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Kie(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),r=s[0],a=s[1],o=this.makeTrainFunction()(r.concat(a)),l=[];for(const h of o){const d=await h.data();l.push(d[0])}return Je(o),ra(s[0],e),ra(s[1],t),ks(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,a=this.getWeights(s);for(let i=0;i<r.length;++i)s&&!r[i].trainable||t.push({name:r[i].originalName,tensor:a[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=OT().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-OT().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=yi(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>yi(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const r of t)if(typeof s[r]=="string")e[r]=yi(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[yi(zy(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>yi(zy(e)));{const e={};for(const t in this.metrics)e[t]=yi(zy(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=up(e.optimizer_config),s=ma(t);let r;if(typeof e.loss=="string")r=_l(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>_l(i));else if(e.loss!=null){r={};for(const i in e.loss)r[i]=_l(e.loss[i])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(i=>_l(i));else if(e.metrics!=null){a={};for(const i in e.metrics)a[i]=_l(e.metrics[i])}this.compile({loss:r,metrics:a,optimizer:s})}async save(e,t){if(typeof e=="string"){const h=OM(e);if(h.length===0)throw new Z(`Cannot find any save handlers for URL '${e}'`);if(h.length>1)throw new Z(`Found more than one (${h.length}) save handlers for URL '${e}'`);e=h[0]}if(e.save==null)throw new Z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await FT(this.getNamedWeights(t)),o={modelTopology:this.toJSON(null,!1),format:noe,generatedBy:`TensorFlow.js tfjs-layers v${Cw}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const h="optimizer",{data:d,specs:f}=await FT(await this.optimizer.getWeights(),h);s.specs.push(...f),s.data=RM([s.data,d])}return this.userDefinedMetadata!=null&&(JO(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=s.data,o.weightSpecs=s.specs,e.save(o)}setUserDefinedMetadata(e){JO(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Si.className="Model";ve(Si);class yB extends Si{}yB.className="Functional";ve(yB);async function soe(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=up(t),r=ma(s,e);if(n.weightsManifest!=null){const a=await Xz(n.weightsManifest,n.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(const o of r.weights)i[o.originalName]=a[o.originalName];r.loadWeights(i),Je(a)}return r}async function roe(n,e){if(e==null&&(e={}),typeof n=="string"){const t=FM(n,e);if(t.length===0)t.push(Zz(n,e));else if(t.length>1)throw new Z(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return aoe(n,void 0,e)}async function aoe(n,e,t){if(t==null&&(t={}),n.load==null)throw new Z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let r=s.modelTopology;r.model_config!=null&&(r=r.model_config);const a=t.strict==null?!0:t.strict,i=s.weightData!=null&&s.weightSpecs!=null&&a,o=ma(up(r),e,i),l=s.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),s.userDefinedMetadata!=null&&o.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new Z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:h,optimizerWeights:d}=ioe(s.weightData,s.weightSpecs);o.loadWeights(h,a),o.optimizer!=null&&d.length>0&&await o.optimizer.setWeights(d),Je(h),Je(d.map(f=>f.tensor))}return o}function ioe(n,e){const t=S2(n,e),s={},r=[];return e.forEach(a=>{a.group==="optimizer"?r.push({name:a.name,tensor:t[a.name]}):s[a.name]=t[a.name]}),{modelWeights:s,optimizerWeights:r}}class su extends Si{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:dw("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new Z(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof su||e instanceof Si;let s;if(t){if(s=e,s.outputs.length!==1)throw new Z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new Z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=eB({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new Z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=QP(this.outputs[0])}this.inboundNodes=[],new vw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:nu(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(wt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Si({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new Gr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},r=!1){let a,i={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Z("Legacy serialization format not supported yet.");a=t}else O(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,i=t;const o=new e(i);if(!(o instanceof su))throw new et(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const d=ma(l,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(e){if(this.model==null)throw new Z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}su.className="Sequential";ve(su);function ooe(n){return new Si(n)}function loe(n){return new su(n)}function bB(n){return eB(n)}function uoe(n,e){fr.registerCallbackConstructor(n,e)}let cs=class extends yu{getConfig(){return{}}};class xB extends cs{apply(e,t=1){return Eae(e,t)}}xB.className="elu";ve(xB);class wB extends cs{apply(e){return Bx(e)}}wB.className="selu";ve(wB);class vB extends cs{apply(e){return Ta(e)}}vB.className="relu";ve(vB);class SB extends cs{apply(e){return re(()=>Do(6,Ta(e)))}}SB.className="relu6";ve(SB);class TB extends cs{apply(e){return e}}TB.className="linear";ve(TB);class CB extends cs{apply(e){return pa(e)}}CB.className="sigmoid";ve(CB);class NB extends cs{apply(e){return Iae(e)}}NB.className="hardSigmoid";ve(NB);class kB extends cs{apply(e){return mu(e)}}kB.className="softplus";ve(kB);class EB extends cs{apply(e){return $ae(e)}}EB.className="softsign";ve(EB);class $B extends cs{apply(e){return Ro(e)}}$B.className="tanh";ve($B);let Ak=class extends cs{apply(e,t=-1){return Vm(e,t)}};Ak.className="softmax";ve(Ak);class IB extends cs{apply(e,t=-1){return Dx(e,t)}}IB.className="logSoftmax";ve(IB);class _B extends cs{apply(e){return re(()=>re(()=>{const t=Math.sqrt(2),s=Y(.5,we(1,_x(Fe(e,t))));return Y(e,s)}))}}_B.className="gelu";ve(_B);class AB extends cs{apply(e){return re(()=>Y(.5,Y(e,we(1,Ro(Y(Pn(Fe(2,Math.PI)),we(e,Y(.044715,Ha(e,3)))))))))}}AB.className="gelu_new";ve(AB);class RB extends cs{apply(e){return re(()=>Y(e,Ro(mu(e))))}}RB.className="mish";ve(RB);class DB extends cs{apply(e,t=1){return re(()=>Y(pa(Y(e,t)),e))}}DB.className="swish";ve(DB);function Fo(n){return n.getClassName()}function BS(n,e={}){return qm(n,yr.getMap().classNameMap,e,"activation")}function Lo(n){if(n==null){const e={};return e.className="linear",e.config={},BS(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},BS(e)}else return n instanceof cs?n:BS(n)}function Rk(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class OB extends yu{}class Zm extends OB{constructor(e){super(),Rk(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return re(()=>{let t=gn([1]);return this.hasL1&&(t=we(t,Re(Y(this.l1,mn(e))))),this.hasL2&&(t=we(t,Re(Y(this.l2,Xm(e))))),J(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Zm.className="L1L2";ve(Zm);function coe(n){return Rk(n),new Zm({l1:n!=null?n.l1:null,l2:0})}function hoe(n){return Rk(n),new Zm({l2:n!=null?n.l2:null,l1:0})}const s3={l1l2:"L1L2"};function Ot(n){return hk(n)}function r3(n,e={}){return qm(n,yr.getMap().classNameMap,e,"regularizer")}function Gt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in s3?s3[n]:n,config:{}};return r3(t)}else return n instanceof OB?n:r3(n)}class Dk extends it{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=qe(e);let s=Ta(e);return this.maxValue!=null&&(s=Rs(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Dk.className="ReLU";ve(Dk);class Ok extends it{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=qe(e);return Am(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Ok.className="LeakyReLU";ve(Ok);class Fk extends it{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Wt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Gt(e.alphaRegularizer),this.alphaConstraint=_n(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Z(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=wt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new yn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=qe(e),zm(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Yt(this.alphaInitializer),alphaRegularizer:Ot(this.alphaRegularizer),alphaConstraint:In(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Fk.className="PReLU";ve(Fk);let Lk=class extends it{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=qe(e);return Jh(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Lk.className="ELU";ve(Lk);class Mk extends it{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=qe(e);return Y(s,Ne(vs(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Mk.className="ThresholdedReLU";ve(Mk);class zk extends it{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Ak().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return re(()=>{let s=qe(e);const r=t.mask;if(r!=null){const a=Y(Ae($s(s.shape),Ne(r,s.dtype)),ze(-1e9));s=we(s,a)}return this.axis instanceof Array?this.axis.length>1?Ds(Ae(s,Dm(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}zk.className="Softmax";ve(zk);function Oc(n,e,t){if(typeof n=="number")return nu(n,e);if(n.length!==e)throw new Z(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const r=n[s];if(!Tae(r))throw new Z(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function ga(n,e,t,s,r=1){if(n==null)return n;const a=e+(e-1)*(r-1);let i;return t==="same"?i=n:i=n-a+1,Math.floor((i+s-1)/s)}function Oa(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Oo([t-e,0]);else if(s==="same")n=n*e;else throw new Z(`Unsupport padding mode: ${s}.`);return n}function Pk(n,e){return re(()=>(hn(e),e==="channelsFirst"?ut(n,[0,2,3,1]):n))}function FB(n,e){return re(()=>(hn(e),e==="channelsFirst"?ut(n,[0,2,3,4,1]):n))}function doe(n,e,t,s=1,r="valid",a,i=1){return re(()=>{if(a==null&&(a=ba()),hn(a),n.shape.length!==3)throw new Z(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new Z(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new Z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(n=ut(n,[0,2,1])),r==="causal")throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=kx(n,e,s,r==="same"?"same":"valid","NWC",i);return t!=null&&(o=Ca(o,t)),o})}function a3(n,e,t,s=[1,1],r="valid",a,i,o=null){return re(()=>{if(a==null&&(a=ba()),hn(a),n.rank!==3&&n.rank!==4)throw new Z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=Pk(n,a);if(r==="causal")throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Fz({x:l,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:t,activation:o}),a==="channelsFirst"&&(l=ut(l,[0,3,1,2])),l})}function foe(n,e,t,s=[1,1,1],r="valid",a,i){return re(()=>{if(a==null&&(a=ba()),hn(a),n.rank!==4&&n.rank!==5)throw new Z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=FB(n,a);if(r==="causal")throw new et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=q2(o,e,s,r==="same"?"same":"valid","NDHWC",i),t!=null&&(o=Ca(o,t)),a==="channelsFirst"&&(o=ut(o,[0,4,1,2,3])),o})}class Nw extends it{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Nw.verifyArgs(t),this.rank=e,Ln(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Oc(t.kernelSize,e,"kernelSize"),this.strides=Oc(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Nr(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,hn(this.dataFormat),this.activation=Lo(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=Wt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=_n(t.biasConstraint),this.biasRegularizer=Gt(t.biasRegularizer),this.activityRegularizer=Gt(t.activityRegularizer),this.dilationRate=Oc(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Da("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!dk(e.kernelSize,"number",1,3))throw new Z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Fo(this.activation),useBias:this.useBias,biasInitializer:Yt(this.biasInitializer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),biasConstraint:In(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class ad extends Nw{constructor(e,t){super(e,t),this.kernel=null,ad.verifyArgs(t),this.filters=t.filters,Ln(this.filters,"filters"),this.kernelInitializer=Wt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=_n(t.kernelConstraint),this.kernelRegularizer=Gt(t.kernelRegularizer)}build(e){e=wt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Z(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return re(()=>{e=qe(e);let s;const r=this.bias==null?null:this.bias.read(),a=WP(this.activation.getClassName());if(a!=null&&this.rank===2)s=a3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)s=doe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=a3(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=foe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new et("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=wt(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<s.length;++a){const i=ga(s[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);t.push(i)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Yt(this.kernelInitializer),kernelRegularizer:Ot(this.kernelRegularizer),kernelConstraint:In(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class id extends ad{constructor(e){super(2,e),id.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!dk(e.kernelSize,"number",1,2))throw new Z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}id.className="Conv2D";ve(id);class od extends ad{constructor(e){super(3,e),od.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}od.className="Conv3D";ve(od);class Bk extends id{constructor(e){if(super(e),this.inputSpec=[new yn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wt(e),e.length!==4)throw new Z("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return re(()=>{let s=qe(e);if(s.shape.length!==4)throw new Z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,a=r[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=r[i],h=r[o],d=this.kernelSize[0],f=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=Oa(l,m,d,this.padding),x=Oa(h,y,f,this.padding),w=[a,b,x,this.filters];this.dataFormat!=="channelsLast"&&(s=ut(s,[0,2,3,1]));let v=Ex(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=ut(v,[0,3,1,2])),this.bias!=null&&(v=Ca(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=wt(e);const t=e.slice();let s,r,a;this.dataFormat==="channelsFirst"?(s=1,r=2,a=3):(s=3,r=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],h=this.strides[1];return t[s]=this.filters,t[r]=Oa(t[r],l,i,this.padding),t[a]=Oa(t[a],h,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Bk.className="Conv2DTranspose";ve(Bk);class Vk extends od{constructor(e){if(super(e),this.inputSpec=[new yn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wt(e),e.length!==5)throw new Z("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new yn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return re(()=>{let s=qe(e);if(s.shape.length!==5)throw new Z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,a=r[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const h=r[l],d=r[i],f=r[o],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],x=this.strides[0],w=this.strides[1],v=this.strides[2],C=Oa(h,x,m,this.padding),N=Oa(d,w,y,this.padding),k=Oa(f,v,b,this.padding),E=[a,C,N,k,this.filters];this.dataFormat!=="channelsLast"&&(s=ut(s,[0,2,3,4,1]));let _=K2(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(_=ut(_,[0,4,1,2,3])),this.bias!==null&&(_=Ca(_,this.bias.read(),this.dataFormat)),this.activation!==null&&(_=this.activation.apply(_)),_})}computeOutputShape(e){e=wt(e);const t=e.slice();let s,r,a,i;this.dataFormat==="channelsFirst"?(s=1,r=2,a=3,i=4):(s=4,r=1,a=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],h=this.kernelSize[2],d=this.strides[0],f=this.strides[1],m=this.strides[2];return t[s]=this.filters,t[r]=Oa(t[r],d,o,this.padding),t[a]=Oa(t[a],f,l,this.padding),t[i]=Oa(t[i],m,h,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Vk.className="Conv3DTranspose";ve(Vk);class LB extends ad{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Gt(t.depthwiseRegularizer),this.depthwiseConstraint=_n(t.depthwiseConstraint),this.pointwiseInitializer=Wt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Gt(t.pointwiseRegularizer),this.pointwiseConstraint=_n(t.pointwiseConstraint)}build(e){if(e=wt(e),e.length<this.rank+2)throw new Z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],r=this.kernelSize.concat([s,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(s*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new yn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return re(()=>{e=qe(e);let s;if(this.rank===1)throw new et("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ut(e,[0,2,3,1])),s=Vx(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Ca(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=ut(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Yt(this.depthwiseInitializer),e.pointwiseInitializer=Yt(this.pointwiseInitializer),e.depthwiseRegularizer=Ot(this.depthwiseRegularizer),e.pointwiseRegularizer=Ot(this.pointwiseRegularizer),e.depthwiseConstraint=In(this.depthwiseConstraint),e.pointwiseConstraint=In(this.pointwiseConstraint),e}}LB.className="SeparableConv";class Uk extends LB{constructor(e){super(2,e)}}Uk.className="SeparableConv2D";ve(Uk);class Qm extends ad{constructor(e){super(1,e),Qm.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!dk(e.kernelSize,"number",1,1))throw new Z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Qm.className="Conv1D";ve(Qm);class jk extends it{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return re(()=>{if(e=qe(e),this.dataFormat==="channelsLast"){const s=My(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return My(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=My(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return My(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}jk.className="Cropping2D";ve(jk);class Wk extends it{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,wae(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return re(()=>{let s=qe(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=ut(s,[0,2,3,1]);const a=this.size[0]*r[2],i=this.size[1]*r[3],o=this.interpolation==="nearest"?Wr.resizeNearestNeighbor(s,[a,i]):Wr.resizeBilinear(s,[a,i]);return ut(o,[0,3,1,2])}else{const a=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?Wr.resizeNearestNeighbor(s,[a,i]):Wr.resizeBilinear(s,[a,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Wk.className="UpSampling2D";ve(Wk);function poe(n,e,t=[1,1],s="valid",r,a){return re(()=>{r==null&&(r=ba()),hn(r);let i=Pk(n,r);if(n.rank!==4)throw new Z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new Z(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=Yh(i,e,t,s==="same"?"same":"valid","NHWC",a),r==="channelsFirst"&&(i=ut(i,[0,3,1,2])),i})}class Gk extends Nw{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Wt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=_n(e.depthwiseConstraint),this.depthwiseRegularizer=Gt(e.depthwiseRegularizer)}build(e){if(e=wt(e),e.length<4)throw new Z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return re(()=>{e=qe(e);let s=poe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Ca(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=wt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=ga(t,this.kernelSize[0],this.padding,this.strides[0]),i=ga(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,i]:[e[0],a,i,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Yt(this.depthwiseInitializer),e.depthwiseRegularizer=Ot(this.depthwiseRegularizer),e.depthwiseConstraint=In(this.depthwiseRegularizer),e}}Gk.className="DepthwiseConv2D";ve(Gk);function MB(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new Z("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function r(a){return a==null||Array.isArray(a)?a:[a]}return e=r(e),t=r(t),{inputs:n,initialState:e,constants:t}}function zB(n,e,t,s=!1,r,a,i=!1,o=!1){return re(()=>{const l=e.shape.length;if(l<3)throw new Z(`Input should be at least 3D, but is ${l}D.`);const h=[1,0].concat(ya(2,l));e=ut(e,h),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Ne(Ne(r,"bool"),"float32"),r.rank===l-1&&(r=Hn(r,-1)),r=ut(r,h)),s&&(e=Tr(e,0),r!=null&&(r=Tr(r,0)));const d=[];let f,m=t;const y=e.shape[0],b=Cr(e);let x;r!=null&&(x=Cr(r));for(let v=0;v<y;++v){const C=b[v],N=re(()=>n(C,m));if(r==null)f=N[0],m=N[1];else{const k=re(()=>{const E=x[v],_=Ae(Zs(E),E),R=we(Y(N[0],E),Y(m[0],_)),D=m.map((F,L)=>we(Y(N[1][L],E),Y(F,_)));return{output:R,newStates:D}});f=k.output,m=k.newStates}o&&d.push(f)}let w;return o&&(w=bs(d,1)),[f,w,m]})}class Na extends it{constructor(e){super(e);let t;if(e.cell==null)throw new Z("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new $w({cells:e.cell}):t=e.cell,t.stateSize==null)throw new Z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new yn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ya(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){XT(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const a=[];for(const i of t)a.push([e[0],i]);return[r].concat(a)}else return r}computeMask(e,t){return re(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(a=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new et("Constants support is not implemented in RNN yet.");XT(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new yn({shape:[t,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!lt(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new Z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new yn({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){re(()=>{if(!this.stateful)throw new Ra("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new Z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gn([s,r])):this.states_=[gn([s,this.cell.stateSize])];else if(e==null)Je(this.states_),this.keptStates!=null&&(Je(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>gn([s,r])):this.states_[0]=gn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Je(this.states_);for(let r=0;r<this.states_.length;++r){const a=e[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[s,i];if(!lt(a.shape,o))throw new Z(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[r]=a}}this.states_=this.states_.map(r=>En(r.clone()))})}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const a=MB(e,s,r,this.numConstants);e=a.inputs,s=a.initialState,r=a.constants;let i=[],o=[];if(s!=null){t.initialState=s,i=i.concat(s),this.stateSpec=[];for(const h of s)this.stateSpec.push(new yn({shape:h.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof xa){const h=[e].concat(i),d=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=f,m}else return super.apply(e,t)}call(e,t){return re(()=>{const s=t==null?null:t.mask,r=t==null?null:t.training;let a=t==null?null:t.initialState;e=qe(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new Z(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:r},h=zB((b,x)=>{const w=this.cell.call([b].concat(x),o);return[w[0],w.slice(1)]},e,a,this.goBackwards,s,null,this.unroll,this.returnSequences),d=h[0],f=h[1],m=h[2];this.stateful&&this.resetStates(m,r);const y=this.returnSequences?f:d;return this.returnState?[y].concat(m):y})}getInitialState(e){return re(()=>{let t=gn(e.shape);return t=Re(t,[1,2]),t=Km(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?qT(t,[1,s]):t):this.cell.stateSize>1?[qT(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Na.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const r=t.cell,a=ma(r,s);return new e(Object.assign(t,{cell:a}))}}Na.className="RNN";ve(Na);class eg extends it{}class kw extends eg{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ln(this.units,"units"),this.activation=Lo(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Oo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Oo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return re(()=>{if(e=e,e.length!==2)throw new Z(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=ja(Y(e,i),this.kernel.read()):a=ja(e,this.kernel.read()),this.bias!=null&&(a=Ca(a,this.bias.read())),o!=null&&(s=Y(s,o));let l=we(a,ja(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Fo(this.activation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),recurrentConstraint:In(this.recurrentConstraint),biasConstraint:In(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}kw.className="SimpleRNNCell";ve(kw);class Hk extends Na{constructor(e){e.cell=new kw(e),super(e)}call(e,t){return re(()=>{this.cell.dropoutMask!=null&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}}Hk.className="SimpleRNN";ve(Hk);class Ew extends eg{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Z("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ln(this.units,"units"),this.activation=Lo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Lo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Oo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Oo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return re(()=>{if(e=e,e.length!==2)throw new Z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,h;0<this.dropout&&this.dropout<1&&(e=Y(e,a[0]));let d=ja(e,this.kernel.read());this.useBias&&(d=Ca(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,i[0]));const f=this.recurrentKernel.read(),[m,y]=Is(f,[2*this.units,this.units],f.rank-1),b=ja(r,m),[x,w,v]=Is(d,3,d.rank-1),[C,N]=Is(b,2,b.rank-1);o=this.recurrentActivation.apply(we(x,C)),l=this.recurrentActivation.apply(we(w,N));const k=ja(Y(l,r),y);h=this.activation.apply(we(v,k));const E=we(Y(o,r),Y(we(1,Mt(o)),h));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Fo(this.activation),recurrentActivation:Fo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),recurrentConstraint:In(this.recurrentConstraint),biasConstraint:In(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Ew.className="GRUCell";ve(Ew);class qk extends Na{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Ew(e),super(e)}call(e,t){return re(()=>{this.cell.dropoutMask!=null&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}qk.className="GRU";ve(qk);class tg extends eg{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ln(this.units,"units"),this.activation=Lo(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Lo(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Wt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Gt(e.kernelRegularizer),this.recurrentRegularizer=Gt(e.recurrentRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.kernelConstraint=_n(e.kernelConstraint),this.recurrentConstraint=_n(e.recurrentConstraint),this.biasConstraint=_n(e.biasConstraint),this.dropout=Gc([1,Oo([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Gc([1,Oo([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=wt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;r=new(t=class extends Xr{apply(l,h){const d=a.apply([i]),f=new pw().apply([i]),m=a.apply([i*2]);return UO(UO(d,f),m)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return re(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,h,d,f;0<this.dropout&&this.dropout<1&&(e=Y(e,i[0]));let m=ja(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,o[0])),m=we(m,ja(r,this.recurrentKernel.read())),this.useBias&&(m=Ca(m,this.bias.read()));const[y,b,x,w]=Is(m,4,m.rank-1);l=this.recurrentActivation.apply(y),h=this.recurrentActivation.apply(b),d=we(Y(h,a),Y(l,this.activation.apply(x))),f=this.recurrentActivation.apply(w);const v=Y(f,this.activation.apply(d));return[v,v,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Fo(this.activation),recurrentActivation:Fo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),recurrentInitializer:Yt(this.recurrentInitializer),biasInitializer:Yt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ot(this.kernelRegularizer),recurrentRegularizer:Ot(this.recurrentRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),recurrentConstraint:In(this.recurrentConstraint),biasConstraint:In(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}tg.className="LSTMCell";ve(tg);class Kk extends Na{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new tg(e),super(e)}call(e,t){return re(()=>{this.cell.dropoutMask!=null&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Kk.className="LSTM";ve(Kk);class $w extends eg{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return re(()=>{e=e;let s=e.slice(1);const r=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?r.push(s.splice(0,o.stateSize.length)):r.push(s.splice(0,1));r.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=r[o],o===0?i=[e[0]].concat(s):i=[i[0]].concat(s),i=l.call(i,t),a.push(i.slice(1))}s=[];for(const o of a.slice().reverse())s.push(...o);return[i[0]].concat(s)})}build(e){XT(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,r)=>{Wl(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,s={}){const r=[];for(const a of t.cells)r.push(ma(a,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return YT(e)}setWeights(e){const t=[];for(const s of this.cells){const r=s.weights.length,a=e.splice(r);for(let i=0;i<s.weights.length;++i)t.push([s.weights[i],a[i]])}vk(t)}}$w.className="StackedRNNCells";ve($w);function Mo(n){const{ones:e,rate:t,training:s=!1,count:r=1,dropoutFunc:a}=n,i=()=>a!=null?a(e(),t):JP(e(),t),o=()=>Ym(i,e,s);return!r||r<=1?En(o().clone()):Array(r).fill(void 0).map(o).map(h=>En(h.clone()))}var moe=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(n);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(t[s[r]]=n[s[r]]);return t};class PB extends Na{constructor(e){if(e.unroll)throw new et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new yn({ndim:5})]}call(e,t){return re(()=>{if(this.cell.dropoutMask!=null&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Z("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:s,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return re(()=>{const{stateSize:t}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),a=[r[0],...r.slice(2)],i=gn(a);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e,t=!1){re(()=>{if(!this.stateful)throw new Ra("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),a=[r[0],...r.slice(2)];if(s[0]==null)throw new Z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gn(a)):this.states_=[gn(a)];else if(e==null)Je(this.states_),this.keptStates!=null&&(Je(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gn(a)):this.states_[0]=gn(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Je(this.states_);for(let o=0;o<this.states_.length;++o){const l=e[o],h=a;if(!lt(l.shape,h))throw new Z(`State ${o} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>En(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:r,padding:a,strides:i,dilationRate:o}=this.cell,l=t==="channelsFirst",h=e[l?3:2],d=e[l?4:3],f=ga(h,r[0],a,i[0],o[0]),m=ga(d,r[1],a,i[1],o[1]);return[...e.slice(0,2),...l?[s,f,m]:[f,m,s]]}}PB.className="ConvRNN2D";class Iw extends tg{constructor(e){const{filters:t,kernelSize:s,strides:r,padding:a,dataFormat:i,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ln(this.filters,"filters"),this.kernelSize=Oc(s,2,"kernelSize"),this.kernelSize.forEach(l=>Ln(l,"kernelSize")),this.strides=Oc(r||1,2,"strides"),this.strides.forEach(l=>Ln(l,"strides")),this.padding=a||"valid",Nr(this.padding),this.dataFormat=i||"channelsLast",hn(this.dataFormat),this.dilationRate=Oc(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ln(l,"dilationRate"))}build(e){var t;e=wt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new Z(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],a=4,i=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const h=this.biasInitializer,d=this.filters;l=new(t=class extends Xr{apply(m,y){const b=h.apply([d]),x=$s([d]),w=h.apply([d*2]);return fk([b,x,w])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return re(()=>{if(e.length!==3)throw new Z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,r=e[0],a=e[1],i=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Mo({ones:()=>Zs(r),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,h=(se,P,j)=>!P||!P[j]?se:Y(P[j],se);let d=h(r,l,0),f=h(r,l,1),m=h(r,l,2),y=h(r,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Mo({ones:()=>Zs(a),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const b=this.recurrentDropoutMask;let x=h(a,b,0),w=h(a,b,1),v=h(a,b,2),C=h(a,b,3);const N=3,[k,E,_,R]=Is(this.kernel.read(),o,N),[D,F,L,A]=this.useBias?Is(this.bias.read(),o):[null,null,null,null];d=this.inputConv(d,k,D,this.padding),f=this.inputConv(f,E,F,this.padding),m=this.inputConv(m,_,L,this.padding),y=this.inputConv(y,R,A,this.padding);const[V,q,ne,Q]=Is(this.recurrentKernel.read(),o,N);x=this.recurrentConv(x,V),w=this.recurrentConv(w,q),v=this.recurrentConv(v,ne),C=this.recurrentConv(C,Q);const B=this.recurrentActivation.apply(we(d,x)),U=this.recurrentActivation.apply(we(f,w)),X=we(Y(U,i),Y(B,this.activation.apply(we(m,v)))),K=Y(this.recurrentActivation.apply(we(y,C)),this.activation.apply(X));return[K,K,X]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=moe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),r)}inputConv(e,t,s,r){const a=Ii(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Ca(a,s,this.dataFormat):a}recurrentConv(e,t){return Ii(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Iw.className="ConvLSTM2DCell";ve(Iw);class Xk extends PB{constructor(e){const t=new Iw(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Xk.className="ConvLSTM2D";ve(Xk);class _w extends it{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return s}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,a=this.getNoiseShape(s);return Ym(()=>JP(s,this.rate,a,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}_w.className="Dropout";ve(_w);class Yk extends _w{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Yk.className="SpatialDropout1D";ve(Yk);class Jk extends it{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ln(this.units,"units"),this.activation=Lo(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Wt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Wt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=_n(e.kernelConstraint),this.biasConstraint=_n(e.biasConstraint),this.kernelRegularizer=Gt(e.kernelRegularizer),this.biasRegularizer=Gt(e.biasRegularizer),this.activityRegularizer=Gt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=wt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=wt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e),r=WP(this.activation.getClassName());let a;return r!=null?a=ja(s,this.kernel.read(),r,this.bias?this.bias.read():null):(a=ja(s,this.kernel.read()),this.bias!=null&&(a=Ca(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:Fo(this.activation),useBias:this.useBias,kernelInitializer:Yt(this.kernelInitializer),biasInitializer:Yt(this.biasInitializer),kernelRegularizer:Ot(this.kernelRegularizer),biasRegularizer:Ot(this.biasRegularizer),activityRegularizer:Ot(this.activityRegularizer),kernelConstraint:In(this.kernelConstraint),biasConstraint:In(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Jk.className="Dense";ve(Jk);class Zk extends it{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=wt(e);for(const t of e.slice(1))if(t==null)throw new Z(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],No(e,1)]}call(e,t){return re(()=>{this.invokeCallHook(e,t);let s=qe(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let a=2;a<s.rank;++a)r.push(a);r.push(1),s=ut(s,r)}return kae(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Zk.className="Flatten";ve(Zk);class Qk extends it{constructor(e){super(e),this.supportsMasking=!0,this.activation=Lo(e.activation)}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e);return this.activation.apply(s)})}getConfig(){const e={activation:Fo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Qk.className="Activation";ve(Qk);class eE extends it{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return re(()=>(e=qe(e),Cae(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}eE.className="RepeatVector";ve(eE);class tE extends it{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",r=t.slice();let a=1,i=null;for(let l=0;l<r.length;++l){const h=r[l];if(this.isUnknown(h))if(i===null)i=l;else throw new Z("Can only specifiy one unknown dimension.");else a*=h}const o=No(e);if(i!==null){if(a===0||o%a!==0)throw new Z(s);r[i]=o/a}else if(o!==a)throw new Z(s);return r}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e),r=s.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return J(s,a)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}tE.className="Reshape";ve(tE);class nE extends it{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=ya(1,e.dims.length+1);if(!lt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new yn({ndim:this.dims.length+1})]}computeOutputShape(e){e=wt(e);const t=e.slice();return this.dims.forEach((s,r)=>{t[r+1]=e[s]}),t}call(e,t){return ut(qe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}nE.className="Permute";ve(nE);class sE extends it{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=qe(e);return rp(Ql(s,this.maskValue),-1)}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e),i=rp(Ql(s,this.maskValue),-1,!0);return Y(s,Ne(i,s.dtype))})}}sE.className="Masking";ve(sE);class rE extends it{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ct(e.inputLength))}this.inputDim=e.inputDim,Ln(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ln(this.outputDim,"outputDim"),this.embeddingsInitializer=Wt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Gt(e.embeddingsRegularizer),this.activityRegularizer=Gt(e.activityRegularizer),this.embeddingsConstraint=_n(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return re(()=>this.maskZero?(e=qe(e),Ql(e,ft(e))):null)}computeOutputShape(e){if(e=wt(e),this.inputLength==null)return[...e,this.outputDim];const t=Ct(this.inputLength);if(t.length!==e.length-1)throw new Z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<t.length;++r){const a=t[r],i=e[r+1];if(a!=null&&i!=null&&a!==i)throw new Z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[s]=i),s++}}return[e[0],...t,this.outputDim]}call(e,t){return re(()=>{this.invokeCallHook(e,t);let s=qe(e);s.dtype!=="int32"&&(s=Ua(s,"int32"));const r=YP(this.embeddings.read(),J(s,[s.size]));return J(r,wt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Yt(this.embeddingsInitializer),embeddingsRegularizer:Ot(this.embeddingsRegularizer),activityRegularizer:Ot(this.activityRegularizer),embeddingsConstraint:In(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}rE.className="Embedding";ve(rE);class wu extends it{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new et}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],i=t[r];if(a==null||i==null||a<0||i<0)s.push(null);else if(a===1)s.push(i);else if(i===1)s.push(a);else{if(a!==i)throw new Z("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(a)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[wt(e)]),e=e,e.length<2)throw new Z(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=Co(t),t.length>1)throw new Z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const i=e[a]==null?null:e[a].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=e.map(a=>a.length);e.indexOf(null)===-1&&Co(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return re(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){const a=Oo(r);for(let i of e){const o=i.rank;for(let l=0;l<a-o;++l)i=Km(i,1);s.push(i)}return this.mergeFunction(s)}else{let a=!1;for(const l of e){const h=l.rank;if(h==null){const d=l.shape,f=d[0],m=d.slice(1).concat([f]);let y=J(l,[f].concat(No(d.slice(1))));y=ut(y,[1,0]),y=J(y,m),s.push(y),a=!0}else if(h>1){const d=ya(1,h).concat([0]);s.push(ut(l,d)),a=!0}else s.push(l)}let i=this.mergeFunction(s);const o=i.rank;if(a){if(o==null){const l=i.shape,h=l.length,d=l[h-1],f=[d].concat(l.slice(0,l.length-1));i=J(ut(J(i,[-1,d]),[1,0]),f)}else if(o>1){const l=[o-1].concat(ya(0,o-1));i=ut(i,l)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=Co(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return re(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Z("`mask` should be an Array");if(!Array.isArray(e))throw new Z("`inputs` should be an Array");if(t.length!==e.length)throw new Z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Hn(r,0));let s=t[0];for(let r=1;r<t.length-1;++r)s=qr(s,t[r]);return s})}}class aE extends wu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return t})}}aE.className="Add";ve(aE);class iE extends wu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Y(t,e[s]);return t})}}iE.className="Multiply";ve(iE);class oE extends wu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=we(t,e[s]);return Y(1/e.length,t)})}}oE.className="Average";ve(oE);class lE extends wu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Xa(t,e[s]);return t})}}lE.className="Maximum";ve(lE);class uE extends wu{constructor(e){super(e)}mergeFunction(e){return re(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Do(t,e[s]);return t})}}uE.className="Minimum";ve(uE);class cE extends wu{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Z("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const s=[];for(let r=0;r<e.length;++r){const a=e[r].slice();a.splice(this.axis,1);let i=!1;for(const o of s)if(lt(o,a)){i=!0;break}i||s.push(a)}if(s.length>1)throw new Z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return re(()=>fk(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Z("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const a of t.slice(1)){if(s[r]==null||a[r]==null){s[r]=null;break}s[r]+=a[r]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Z("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Z("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Z(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return re(()=>{let s=!0;if(t.forEach(i=>{if(i!=null){s=!1;return}}),s)return null;const r=[];for(let i=0;i<e.length;++i)t[i]==null?r.push(Ne(Zs(e[i]),"bool")):t[i].rank<e[i].rank?r.push(Hn(t[i],-1)):r.push(t[i]);const a=ln(r,this.axis);return Nx(a,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}cE.className="Concatenate";ve(cE);function gf(n,e){for(;n<0;)n+=e;return n}function goe(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new et("batchDot is not implemented for tensors of 4D or higher rank yet");if(O(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),O(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new et("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=e.shape.length;t==null&&(t=[s-1,r-2]);const a=t;return re(()=>{let i;if(s>r){i=s-r;const l=[];for(let h=0;h<i;++h)l.push(1);e=J(e,e.shape.concat(l))}else if(r>s){i=r-s;const l=[];for(let h=0;h<i;++h)l.push(1);n=J(n,n.shape.concat(l))}else i=0;let o;if(n.shape.length===2&&e.shape.length===2)a[0]===a[1]?o=Re(Y(n,e),a[0]):o=Re(Y(ut(n,[1,0]),e),a[1]);else{const l=a[0]!==n.shape.length-1,h=a[1]===e.shape.length-1;o=rt(n,e,l,h)}if(i>0){let l;s>r?l=s+r-3:l=s-1;const h=[];for(let d=l;d<l+i;++d)h.push(d);o=Ho(o,h)}return o.shape.length===1&&(o=Hn(o,1)),o})}class hE extends wu{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);if(t[r[0]]!==s[r[1]])throw new Z(`Dimension incompatibility: ${t[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,i)=>gf(a,e[i].shape.length)):r=[gf(this.axes,t.shape.length),gf(this.axes,s.shape.length)],this.normalize&&(t=B0(t,r[0]),s=B0(s,r[1])),goe(t,s,r)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[gf(this.axes,e.length),gf(this.axes,t.length)],s}computeOutputShape(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,s);t.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const a=t.concat(s);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}hE.className="Dot";ve(hE);class dE extends it{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e);return Ym(()=>we(fw(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}dE.className="GaussianNoise";ve(dE);class fE extends it{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return re(()=>{this.invokeCallHook(e,t);const s=qe(e);return this.rate>0&&this.rate<1?Ym(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return Y(s,fw(s.shape,1,a))},()=>s,t.training||!1):s})}}fE.className="GaussianDropout";ve(fE);class pE extends it{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||qe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return re(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Ym(()=>{const a=qe(e),o=-1.6732632423543772*1.0507009873554805;let l=Mi(Go(s),this.rate);l=Ua(l,"float32");const h=((1-this.rate)*(1+this.rate*o**2))**-.5,d=-h*o*this.rate,f=we(Y(a,l),Y(we(l,-1),o));return we(Y(f,h),d)},()=>qe(e),t.training||!1)}return e})}}pE.className="AlphaDropout";ve(pE);function cp(n,e,t,s,r,a=.001){let i;if(n.rank===2)i=M2(n,e,t,s,r,a);else if(n.rank===3)i=z2(n,e,t,s,r,a);else if(n.rank===4)i=P2(n,e,t,s,r,a);else throw new et(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return i}function yoe(n,e,t,s,r=.001){return re(()=>{const a=Lm(n,s),i=a.mean,o=a.variance;return[cp(n,i,o,t,e,r),i,o]})}function boe(n,e,t,s,r=.001){return re(()=>{const a=Lm(n,s),i=a.mean,o=a.variance,l=[];for(const b of ya(0,n.rank))s.indexOf(b)!==-1?l.push(1):l.push(n.shape[b]);const h=J(i,l),d=J(o,l),f=e==null?null:J(e,l),m=t==null?null:J(t,l);return[cp(n,h,d,m,f,r),i,o]})}function xoe(n,e,t,s,r=.001){return lt(s.slice().sort(),ya(0,n.rank-1))?yoe(n,e,t,s,r):boe(n,e,t,s,r)}class mE extends it{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Wt(e.betaInitializer||"zeros"),this.gammaInitializer=Wt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Wt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Wt(e.movingVarianceInitializer||"ones"),this.betaConstraint=_n(e.betaConstraint),this.gammaConstraint=_n(e.gammaConstraint),this.betaRegularizer=Gt(e.betaRegularizer),this.gammaRegularizer=Gt(e.gammaRegularizer)}build(e){e=wt(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new Z(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new yn({ndim:e.length,axes:{[t]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return re(()=>{const s=t.training==null?!1:t.training,r=qe(e),a=r.shape,i=a.length,o=ya(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const h=nu(1,i);h[l]=a[l];const d=o.slice();d.sort();const f=!lt(d,ya(0,i).slice(0,i-1)),m=()=>{if(f){const C=J(this.movingMean.read(),h),N=J(this.movingVariance.read(),h),k=this.center?J(this.beta.read(),h):null,E=this.scale?J(this.gamma.read(),h):null;return cp(r,C,N,k,E,this.epsilon)}else return cp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return m();const[y,b,x]=xoe(r,this.gamma.read(),this.beta.read(),o,this.epsilon),w=(C,N,k)=>{re(()=>{const E=1-k,_=C.read(),R=Y(Ae(_,N),E);C.write(Ae(_,R))})};return w(this.movingMean,b,this.momentum),w(this.movingVariance,x,this.momentum),y})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yt(this.betaInitializer),gammaInitializer:Yt(this.gammaInitializer),movingMeanInitializer:Yt(this.movingMeanInitializer),movingVarianceInitializer:Yt(this.movingVarianceInitializer),betaRegularizer:Ot(this.betaRegularizer),gammaRegularizer:Ot(this.gammaRegularizer),betaConstraint:In(this.betaConstraint),gammaConstraint:In(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}mE.className="BatchNormalization";ve(mE);class gE extends it{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Wt(e.betaInitializer||"zeros"),this.gammaInitializer=Wt(e.gammaInitializer||"ones"),this.betaRegularizer=Gt(e.betaRegularizer),this.gammaRegularizer=Gt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=wt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Co(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const s=qe(e),r=s.shape,a=r.length;return re(()=>{let{mean:o,variance:l}=Lm(s,this.axis,!0);const h=nu(1,a);for(const x of this.axis)h[x]=r[x];const d=x=>x!=null&&x.shape.length!==a?J(x,h):x;let f=this.scale?d(this.gamma.read()):null,m=this.center?d(this.beta.read()):null;const y=[],b=[];for(let x=0;x<a;++x)this.axis.indexOf(x)!==-1?(y.push(r[x]),b.push(1)):(y.push(1),b.push(r[x]));return o=br(o,y),l=br(l,y),f!=null&&(f=br(f,b)),m!=null&&(m=br(m,b)),cp(s,o,l,m,f,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yt(this.betaInitializer),gammaInitializer:Yt(this.gammaInitializer),betaRegularizer:Ot(this.betaRegularizer),gammaRegularizer:Ot(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}gE.className="LayerNormalization";ve(gE);function woe(n,e,t){return re(()=>{if(n.rank!==4)throw new Z(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=ba()),t!=="channelsLast"&&t!=="channelsFirst")throw new Z(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],zi(n,s)})}class yE extends it{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ba():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){e=wt(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return re(()=>woe(qe(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}yE.className="ZeroPadding2D";ve(yE);function Aw(n,e,t,s,r,a){return re(()=>{hn(r),HP(a),Nr(s),t==null&&(t=[1,1]),s==null&&(s="valid"),r==null&&(r=ba()),a==null&&(a="max"),n=Pk(n,r);let i;const o=s==="same"?"same":"valid";return a==="max"?i=Fm(n,e,t,o):i=Em(n,e,t,o),r==="channelsFirst"&&(i=ut(i,[0,3,1,2])),i})}function BB(n,e,t,s,r,a){return re(()=>{hn(r),HP(a),Nr(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),r==null&&(r=ba()),a==null&&(a="max"),n=FB(n,r);let i;const o=s==="same"?"same":"valid";return a==="max"?i=lN(n,e,t,o):i=L2(n,e,t,o),r==="channelsFirst"&&(i=ut(i,[0,4,1,2,3])),i})}class VB extends it{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ln(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ln(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Nr(this.padding),this.inputSpec=[new yn({ndim:3})]}computeOutputShape(e){e=wt(e);const t=ga(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return re(()=>{this.invokeCallHook(e,t),e=Km(qe(e),2);const s=this.poolingFunction(qe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ho(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class bE extends VB{constructor(e){super(e)}poolingFunction(e,t,s,r,a){return hn(a),Nr(r),Aw(e,t,s,r,a,"max")}}bE.className="MaxPooling1D";ve(bE);class xE extends VB{constructor(e){super(e)}poolingFunction(e,t,s,r,a){return hn(a),Nr(r),Aw(e,t,s,r,a,"avg")}}xE.className="AveragePooling1D";ve(xE);class UB extends it{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ln(this.poolSize,"poolSize"),Ln(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),Nr(this.padding),this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){e=wt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=ga(t,this.poolSize[0],this.padding,this.strides[0]),s=ga(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return re(()=>(this.invokeCallHook(e,t),this.poolingFunction(qe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class wE extends UB{constructor(e){super(e)}poolingFunction(e,t,s,r,a){return hn(a),Nr(r),Aw(e,t,s,r,a,"max")}}wE.className="MaxPooling2D";ve(wE);class vE extends UB{constructor(e){super(e)}poolingFunction(e,t,s,r,a){return hn(a),Nr(r),Aw(e,t,s,r,a,"avg")}}vE.className="AveragePooling2D";ve(vE);class jB extends it{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ln(this.poolSize,"poolSize"),Ln(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),Nr(this.padding),this.inputSpec=[new yn({ndim:5})]}computeOutputShape(e){e=wt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=ga(t,this.poolSize[0],this.padding,this.strides[0]),s=ga(s,this.poolSize[1],this.padding,this.strides[1]),r=ga(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,r]:[e[0],t,s,r,e[4]]}call(e,t){return re(()=>(this.invokeCallHook(e,t),this.poolingFunction(qe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class SE extends jB{constructor(e){super(e)}poolingFunction(e,t,s,r,a){return hn(a),Nr(r),BB(e,t,s,r,a,"max")}}SE.className="MaxPooling3D";ve(SE);class TE extends jB{constructor(e){super(e)}poolingFunction(e,t,s,r,a){return hn(a),Nr(r),BB(e,t,s,r,a,"avg")}}TE.className="AveragePooling3D";ve(TE);class WB extends it{constructor(e){super(e),this.inputSpec=[new yn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new et}}class CE extends WB{constructor(e){super(e||{})}call(e,t){return re(()=>{const s=qe(e);return Kt(s,1)})}}CE.className="GlobalAveragePooling1D";ve(CE);class NE extends WB{constructor(e){super(e||{})}call(e,t){return re(()=>{const s=qe(e);return Sr(s,1)})}}NE.className="GlobalMaxPooling1D";ve(NE);class GB extends it{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,hn(this.dataFormat),this.inputSpec=[new yn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new et}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class kE extends GB{call(e,t){return re(()=>{const s=qe(e);return this.dataFormat==="channelsLast"?Kt(s,[1,2]):Kt(s,[2,3])})}}kE.className="GlobalAveragePooling2D";ve(kE);class EE extends GB{call(e,t){return re(()=>{const s=qe(e);return this.dataFormat==="channelsLast"?Sr(s,[1,2]):Sr(s,[2,3])})}}EE.className="GlobalMaxPooling2D";ve(EE);class HB extends it{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const r=t.layer,a=ma(r,s);delete t.layer;const i={layer:a};return Object.assign(i,t),new e(i)}}class $E extends HB{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=wt(e),e.length<3)throw new Z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=wt(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,t){return re(()=>(e=qe(e),zB((i,o)=>[qe(this.layer.call(i,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}$E.className="TimeDistributed";ve($E);function voe(n){bu(xae,"BidirectionalMergeMode",n)}const Soe="concat";class IE extends HB{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=ma(s),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=ma(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Soe:e.mergeMode,voe(this.mergeMode),e.weights)throw new et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,r,a;return this.returnState&&(a=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[s].concat(a).concat(a.slice()):ks(r)}apply(e,t){let s=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const a=MB(e,s,r,this.numConstants);if(e=a.inputs,s=a.initialState,r=a.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,t);const i=[],o=[];if(s!=null){const h=s.length;if(h%2>0)throw new Z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,i.push(...s);const d=s.map(f=>new yn({shape:f.shape}));this.forwardLayer.stateSpec=d.slice(0,h/2),this.backwardLayer.stateSpec=d.slice(h/2),o.push(...d)}if(r!=null)throw new et("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof xa;for(const h of i)if(h instanceof xa!==l)throw new Z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const h=[e].concat(i),d=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=d;const m=super.apply(h,t);return this.inputSpec=f,m}else return super.apply(e,t)}call(e,t){return re(()=>{const s=t.initialState;let r,a;if(s==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),h=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:h}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Tr(a,1));let o;return this.mergeMode==="concat"?o=fk([r,a]):this.mergeMode==="sum"?o=we(r,a):this.mergeMode==="ave"?o=Y(.5,we(r,a)):this.mergeMode==="mul"?o=Y(r,a):this.mergeMode==null&&(o=[r,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Wl(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Wl(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(s)?s.concat(a).concat(a):[s].concat(a).concat(a)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=ma(t.layer);if(delete t.layer,t.numConstants!=null)throw new et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=s,new e(r)}}IE.className="Bidirectional";ve(IE);class _E extends it{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return re(()=>(e=qe(e),e.dtype!=="float32"&&(e=Ua(e,"float32")),we(Y(e,this.scale),this.offset)))}}_E.className="Rescaling";ve(_E);const{resizeBilinear:Toe,cropAndResize:Coe}=Wr;class AE extends it{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,r,a,i,o,l){return re(()=>{let h,d=!1;const f=t/i,m=s/o,y=(r+t)/i,b=(a+s)/o,x=[f,m,y,b],w=[];e.rank===3?(d=!0,h=bs([e])):h=e;for(let E=0;E<h.shape[0];E++)w.push(x);const v=Xs(w,[w.length,4]),C=eu(0,w.length,1,"int32"),k=Coe(h,v,C,[r,a],"nearest");return Ua(d?qe(Cr(k)):k,l)})}upsize(e,t,s,r){return re(()=>{const a=Toe(e,[t,s]);return Ua(a,r)})}call(e,t){return re(()=>{const s=qe(e),r=s.dtype,a=s.shape,i=a[a.length-3],o=a[a.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let h=0;return o!==this.width&&(h=Math.floor((o-this.width)/2),h===0&&(h=1)),l>=0&&h>=0?this.centerCrop(s,l,h,this.height,this.width,i,o,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wt(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}AE.className="CenterCrop";ve(AE);function Noe(n,e,t,s){let r=qe(n);if(r.dtype!=="int32"&&(r=Ua(r,"int32")),e==="int")return r;const a=r.shape;if(r.rank===0&&(r=Hn(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Hn(r,-1)),r.rank>2)throw new Z(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(e),o=r;let l;if(typeof s<"u"&&e==="count"?l=O0(o,s,t,i):l=O0(o,[],t,i),e!=="tfIdf")return l;if(s)return Y(l,s);throw new Z("When outputMode is 'tfIdf', weights must be provided.")}class RE extends it{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=wt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return re(()=>{e=qe(e),e.dtype!=="int32"&&(e=Ua(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new Z(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=qe(t.countWeights)}const r=Sr(e),a=Pc(e),i=vs(this.numTokens,r).bufferSync().get(0),o=Mi(a,0).bufferSync().get(0);if(!(i&&o))throw new Z(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Noe(e,this.outputMode,this.numTokens,s)})}}RE.className="CategoryEncoding";ve(RE);const koe=["bilinear","nearest"],i3=new Set(koe);class DE extends it{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(i3.has(e.interpolation))this.interpolation=e.interpolation;else throw new Z(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=wt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return re(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Wr.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Wr.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...i3]} are supported`)})}}DE.className="Resizing";ve(DE);class qB{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}qB.className="RandomSeed";class KB extends it{constructor(e){super(e),this.randomGenerator=new qB(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}KB.className="BaseRandomLayer";const Eoe=["bilinear","nearest"],o3=new Set(Eoe);class OE extends KB{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Z(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Z(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Z(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(o3.has(s))this.interpolation=s;else throw new Z(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return re(()=>{const s=qe(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=Go([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return Wr.resizeBilinear(e,i);case"nearest":return Wr.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...o3]} are supported`)}})}}OE.className="RandomWidth";ve(OE);function $oe(n){return new sd(n)}function Ioe(n){return new Lk(n)}function _oe(n){return new Dk(n)}function Aoe(n){return new Ok(n)}function Roe(n){return new Fk(n)}function Doe(n){return new zk(n)}function Ooe(n){return new Mk(n)}function Foe(n){return new Qm(n)}function Loe(n){return new id(n)}function Moe(n){return new Bk(n)}function zoe(n){return new od(n)}function Poe(n){return new Vk(n)}function Boe(n){return new Uk(n)}function Voe(n){return new jk(n)}function Uoe(n){return new Wk(n)}function joe(n){return new Gk(n)}function Woe(n){return new Qk(n)}function Goe(n){return new Jk(n)}function Hoe(n){return new _w(n)}function qoe(n){return new Yk(n)}function Koe(n){return new Zk(n)}function Xoe(n){return new eE(n)}function Yoe(n){return new tE(n)}function Joe(n){return new nE(n)}function Zoe(n){return new rE(n)}function Qoe(n){return new aE(n)}function ele(n){return new oE(n)}function tle(n){return new cE(n)}function nle(n){return new lE(n)}function sle(n){return new uE(n)}function rle(n){return new iE(n)}function ale(n){return new hE(n)}function ile(n){return new mE(n)}function ole(n){return new gE(n)}function lle(n){return new yE(n)}function FE(n){return new xE(n)}function ule(n){return FE(n)}function cle(n){return FE(n)}function LE(n){return new vE(n)}function hle(n){return LE(n)}function dle(n){return LE(n)}function ME(n){return new TE(n)}function fle(n){return ME(n)}function ple(n){return ME(n)}function mle(n){return new CE(n)}function gle(n){return new kE(n)}function XB(n){return new NE(n)}function YB(n){return new EE(n)}function JB(n){return new bE(n)}function ZB(n){return new wE(n)}function yle(n){return new SE(n)}function ble(n){return new qk(n)}function xle(n){return new Ew(n)}function wle(n){return new Kk(n)}function vle(n){return new tg(n)}function Sle(n){return new Hk(n)}function Tle(n){return new kw(n)}function Cle(n){return new Xk(n)}function Nle(n){return new Iw(n)}function kle(n){return new Na(n)}function Ele(n){return new $w(n)}function $le(n){return new IE(n)}function Ile(n){return new $E(n)}const _le=XB,Ale=YB,Rle=JB,Dle=ZB;function Ole(n){return new dE(n)}function Fle(n){return new fE(n)}function Lle(n){return new pE(n)}function Mle(n){return new sE(n)}function zle(n){return new _E(n)}function Ple(n){return new AE(n)}function Ble(n){return new DE(n)}function Vle(n){return new RE(n)}function Ule(n){return new OE(n)}const jle=Object.freeze(Object.defineProperty({__proto__:null,Layer:it,RNN:Na,RNNCell:eg,activation:Woe,add:Qoe,alphaDropout:Lle,average:ele,averagePooling1d:FE,averagePooling2d:LE,averagePooling3d:ME,avgPool1d:ule,avgPool2d:hle,avgPool3d:fle,avgPooling1d:cle,avgPooling2d:dle,avgPooling3d:ple,batchNormalization:ile,bidirectional:$le,categoryEncoding:Vle,centerCrop:Ple,concatenate:tle,conv1d:Foe,conv2d:Loe,conv2dTranspose:Moe,conv3d:zoe,conv3dTranspose:Poe,convLstm2d:Cle,convLstm2dCell:Nle,cropping2D:Voe,dense:Goe,depthwiseConv2d:joe,dot:ale,dropout:Hoe,elu:Ioe,embedding:Zoe,flatten:Koe,gaussianDropout:Fle,gaussianNoise:Ole,globalAveragePooling1d:mle,globalAveragePooling2d:gle,globalMaxPool1d:_le,globalMaxPool2d:Ale,globalMaxPooling1d:XB,globalMaxPooling2d:YB,gru:ble,gruCell:xle,input:bB,inputLayer:$oe,layerNormalization:ole,leakyReLU:Aoe,lstm:wle,lstmCell:vle,masking:Mle,maxPool1d:Rle,maxPool2d:Dle,maxPooling1d:JB,maxPooling2d:ZB,maxPooling3d:yle,maximum:nle,minimum:sle,multiply:rle,permute:Joe,prelu:Roe,randomWidth:Ule,reLU:_oe,repeatVector:Xoe,rescaling:zle,reshape:Yoe,resizing:Ble,rnn:kle,separableConv2d:Boe,simpleRNN:Sle,simpleRNNCell:Tle,softmax:Doe,spatialDropout1d:qoe,stackedRNNCells:Ele,thresholdedReLU:Ooe,timeDistributed:Ile,upSampling2d:Uoe,zeroPadding2d:lle},Symbol.toStringTag,{value:"Module"}));function Wle(n,e){return $k(n,e)}function Gle(n,e){return uB(n,e)}function Hle(n,e){return cB(n,e)}function qle(n,e){return Ik(n,e)}function Kle(n,e){return _k(n,e)}function Xle(n,e){return lB(n,e)}function Yle(n,e){return Eie(n,e)}function Jle(n,e){return Ek(n,e)}function Zle(n,e){return Sw(n,e)}function Qle(n,e){return rd(n,e)}function eue(n,e){return rd(n,e)}function tue(n,e){return rd(n,e)}function nue(n,e){return xu(n,e)}function sue(n,e){return xu(n,e)}function rue(n,e){return xu(n,e)}function aue(n,e){return $ie(n,e)}const iue=Object.freeze(Object.defineProperty({__proto__:null,MAPE:eue,MSE:sue,binaryAccuracy:Wle,binaryCrossentropy:Gle,categoricalAccuracy:qle,categoricalCrossentropy:Kle,cosineProximity:Jle,mape:tue,meanAbsoluteError:Zle,meanAbsolutePercentageError:Qle,meanSquaredError:nue,mse:rue,precision:Xle,r2Score:aue,recall:Yle,sparseCategoricalAccuracy:Hle},Symbol.toStringTag,{value:"Module"}));const oue=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:soe},Symbol.toStringTag,{value:"Module"}));function lue(n){return new Zm(n)}function uue(n){return coe(n)}function cue(n){return hoe(n)}const hue=Object.freeze(Object.defineProperty({__proto__:null,l1:uue,l1l2:lue,l2:cue},Symbol.toStringTag,{value:"Module"}));class QB extends Hc{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Si))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function Py(n,e){return n<e}function l3(n,e){return n>e}class e4 extends QB{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new et("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Py:this.mode==="max"?this.monitorFunc=l3:this.monitor.indexOf("acc")!==-1?this.monitorFunc=l3:this.monitorFunc=Py,this.monitorFunc===Py&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Py?1/0:-1/0}async onEpochEnd(e,t){await po(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function due(n){return new e4(n)}const fue={earlyStopping:due};const pue=ie();pue.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ws;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ws||(Ws={}));var u3;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(u3||(u3={}));const zE={};function mue(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};zE[n]=t}function t4(n){return zE[n]}function gue(n){delete zE[n]}function $(n,e,t,s,r){const a=e.inputParams[n];if(a&&a.inputIndexStart!==void 0){const o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,h=o<0?e.inputNames.length+o:o;if(a.type==="tensor")return qn(e.inputNames[h],t,s,r);if(a.type==="tensors"){const m=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((b,x)=>{var w;return((w=m[x])===null||w===void 0?void 0:w.op)!=="NoOp"}).map(b=>qn(b,t,s,r))}const d=qn(e.inputNames[h],t,s,r),f=d.dataSync();return a.type==="number"?f[0]:vr(d.shape,f)}const i=e.attrParams[n];return i&&i.value}function qn(n,e,t,s){const[r,a]=Hs(n,t);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const i=t.currentContextIds.find(o=>!!e[G0(r,o)]);return i!==void 0?e[G0(r,i)][a]:void 0}function c3(n,e,t){return e[G0(n,t.currentContextId)]}function bi(n,e){const[t,s,r]=Hs(n,e);return[G0(t,e&&e.currentContextId),s,r]}function G0(n,e){return e?`${n}-${e}`:n}function Hs(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const a=e.parseNodeNameCache.get(n);if(a!=null)return a}const s=n.split(":");let r;if(s.length===1)r=[n,0,void 0];else{const a=s[0],i=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[a,o,i]}return t&&e.parseNodeNameCache.set(n,r),r}function o0(n,e,t){let s=$("pad",n,e,t);if(s==="explicit"){s=$("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[a*2],r[a][1]=s[a*2+1];return r}return s}function xi(n){return n.kept?n:Ba(n)}const yue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bue=Object.freeze(Object.defineProperty({__proto__:null,json:yue},Symbol.toStringTag,{value:"Module"}));const xue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wue=Object.freeze(Object.defineProperty({__proto__:null,json:xue},Symbol.toStringTag,{value:"Module"}));const vue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Sue=Object.freeze(Object.defineProperty({__proto__:null,json:vue},Symbol.toStringTag,{value:"Module"}));const Tue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Cue=Object.freeze(Object.defineProperty({__proto__:null,json:Tue},Symbol.toStringTag,{value:"Module"}));const Nue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],kue=Object.freeze(Object.defineProperty({__proto__:null,json:Nue},Symbol.toStringTag,{value:"Module"}));const Eue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$ue=Object.freeze(Object.defineProperty({__proto__:null,json:Eue},Symbol.toStringTag,{value:"Module"}));const Iue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_ue=Object.freeze(Object.defineProperty({__proto__:null,json:Iue},Symbol.toStringTag,{value:"Module"}));const Aue=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Rue=Object.freeze(Object.defineProperty({__proto__:null,json:Aue},Symbol.toStringTag,{value:"Module"}));const Due=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Oue=Object.freeze(Object.defineProperty({__proto__:null,json:Due},Symbol.toStringTag,{value:"Module"}));const Fue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Lue=Object.freeze(Object.defineProperty({__proto__:null,json:Fue},Symbol.toStringTag,{value:"Module"}));const Mue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],zue=Object.freeze(Object.defineProperty({__proto__:null,json:Mue},Symbol.toStringTag,{value:"Module"}));const Pue=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Bue=Object.freeze(Object.defineProperty({__proto__:null,json:Pue},Symbol.toStringTag,{value:"Module"}));const Vue=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Uue=Object.freeze(Object.defineProperty({__proto__:null,json:Vue},Symbol.toStringTag,{value:"Module"}));const jue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Wue=Object.freeze(Object.defineProperty({__proto__:null,json:jue},Symbol.toStringTag,{value:"Module"}));const Gue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Hue=Object.freeze(Object.defineProperty({__proto__:null,json:Gue},Symbol.toStringTag,{value:"Module"}));const que=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Kue=Object.freeze(Object.defineProperty({__proto__:null,json:que},Symbol.toStringTag,{value:"Module"}));const Xue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Yue=Object.freeze(Object.defineProperty({__proto__:null,json:Xue},Symbol.toStringTag,{value:"Module"}));const Jue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Zue=Object.freeze(Object.defineProperty({__proto__:null,json:Jue},Symbol.toStringTag,{value:"Module"}));const Que=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],ece=Object.freeze(Object.defineProperty({__proto__:null,json:Que},Symbol.toStringTag,{value:"Module"}));class h3{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[bue,wue,Sue,Cue,kue,$ue,_ue,Rue,Oue,Lue,zue,Bue,Uue,Wue,Hue,Kue,Yue,Zue,ece],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],a=[],i=[],o=s.reduce((x,w)=>(x[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?r.push(x[w.name]):w.op==="Const"?a.push(x[w.name]):(w.input==null||w.input.length===0)&&i.push(x[w.name]),x),{});let l=[];const h=[];let d={},f={};t!=null&&(d=this.mapSignatureEntries(t.inputs),f=this.mapSignatureEntries(t.outputs));const m=Object.keys(o);m.forEach(x=>{const w=o[x];w.inputNames.forEach((v,C)=>{const[N,,k]=bi(v),E=o[N];if(E.outputs!=null){const _=E.outputs.indexOf(k);if(_!==-1){const R=`${N}:${_}`;w.inputNames[C]=R}}w.inputs.push(E),E.children.push(w)})}),Object.keys(f).length===0?m.forEach(x=>{const w=o[x];w.children.length===0&&h.push(w)}):Object.keys(f).forEach(x=>{const[w]=bi(x),v=o[w];v!=null&&(v.signatureKey=f[x],h.push(v))}),Object.keys(d).length>0?Object.keys(d).forEach(x=>{const[w]=bi(x),v=o[w];v&&(v.signatureKey=d[x],l.push(v))}):l=r;let y={};e.library!=null&&e.library.function!=null&&(y=e.library.function.reduce((x,w)=>(x[w.signature.name]=this.mapFunction(w),x),{}));const b={nodes:o,inputs:l,outputs:h,weights:a,placeholders:r,signature:t,functions:y};return i.length>0&&(b.initNodes=i),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=t4(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,a)=>{const i=a.type;let o;switch(a.type){case"string":o=tC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=tC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=lC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=lC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=sC(e.attr,a.tfName,a.defaultValue||0),o===void 0&&a.tfDeprecatedName&&(o=sC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=oC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=oC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=nC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=nC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=cC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=cC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=iC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=iC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=uC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=uC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=rC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=rC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=aC(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=aC(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=d3(e.attr,a.tfName,a.defaultValue),o===void 0&&a.tfDeprecatedName&&(o=d3(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:o,type:i},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let a={};t!=null&&(a=t.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op==="Const"&&r.push(f[m.name]),f),{}));const i=[],o=[];e.signature.inputArg.forEach(f=>{const[m]=bi(f.name),y={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:PE(f.type),type:"dtype"}},children:[]};y.signatureKey=f.name,i.push(y),a[m]=y}),Object.keys(a).forEach(f=>{const m=a[f];m.inputNames.forEach((y,b)=>{const[x,,w]=bi(y),v=a[x];if(v.outputs!=null){const C=v.outputs.indexOf(w);if(C!==-1){const N=`${x}:${C}`;m.inputNames[b]=N}}m.inputs.push(v),v.children.push(m)})});const h=e.ret;e.signature.outputArg.forEach(f=>{const[m,y]=bi(h[f.name]),b=a[m];b!=null&&(b.defaultOutput=y,o.push(b))});const d=this.mapArgsToSignature(e);return{nodes:a,inputs:i,outputs:o,weights:r,placeholders:s,signature:d}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function tce(n){const e=ie().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function n4(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):tce(n);return e?t:t.toLowerCase()}function tC(n,e,t,s=!1){const r=n[e];return r!=null?n4(r.s,s):t}function nC(n,e,t){const s=n[e];return s?s.b:t}function sC(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function PE(n){switch(typeof n=="string"&&(n=Ws[n]),n){case Ws.DT_FLOAT:case Ws.DT_HALF:return"float32";case Ws.DT_INT32:case Ws.DT_INT64:case Ws.DT_INT8:case Ws.DT_UINT8:return"int32";case Ws.DT_BOOL:return"bool";case Ws.DT_DOUBLE:return"float32";case Ws.DT_STRING:return"string";case Ws.DT_COMPLEX64:case Ws.DT_COMPLEX128:return"complex64";default:return null}}function d3(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function rC(n,e,t){const s=n[e];return s&&s.type?PE(s.type):t}function aC(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>PE(r)):t}function s4(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function iC(n,e,t){const s=n[e];return s&&s.shape?s4(s.shape):t}function oC(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function lC(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(a=>n4(a,s)):t}function uC(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>s4(r)):t}function cC(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}class nce{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return qn(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return qn(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return sC(this.node.rawAttrs,e,t);if(s.s!=null)return tC(this.node.rawAttrs,e,t);if(s.b!=null)return nC(this.node.rawAttrs,e,t);if(s.shape!=null)return iC(this.node.rawAttrs,e,t);if(s.type!=null)return rC(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return oC(this.node.rawAttrs,e,t);if(s.list.s!=null)return lC(this.node.rawAttrs,e,t);if(s.list.shape!=null)return uC(this.node.rawAttrs,e,t);if(s.list.b!=null)return cC(this.node.rawAttrs,e,t);if(s.list.type!=null)return aC(this.node.rawAttrs,e,t)}return t}}const es=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:x2,abs:mn,acos:E2,acosh:$2,add:we,addN:jM,all:Nx,any:rp,argMax:Yl,argMin:I2,asin:_2,asinh:A2,atan:R2,atan2:D2,atanh:O2,avgPool:Em,avgPool3d:L2,basicLSTMCell:WM,batchNorm:Xh,batchNorm2d:M2,batchNorm3d:z2,batchNorm4d:P2,batchToSpaceND:$m,bincount:B2,bitwiseAnd:GM,booleanMaskAsync:Iz,broadcastArgs:HM,broadcastTo:jl,buffer:tt,cast:Ne,ceil:V2,clipByValue:Rs,clone:Ba,complex:$i,concat:ln,concat1d:U2,concat2d:j2,concat3d:W2,concat4d:G2,conv1d:kx,conv2d:Ii,conv2dTranspose:Ex,conv3d:q2,conv3dTranspose:K2,cos:Im,cosh:$x,cosineWindow:Zx,cumprod:op,cumsum:Ix,denseBincount:O0,depthToSpace:X2,depthwiseConv2d:Yh,diag:KM,dilation2d:Y2,div:Fe,divNoNan:J2,dot:Z2,dropout:NN,einsum:Il,elu:Jh,enclosingPowerOfTwo:kN,ensureShape:XM,equal:Ys,erf:_x,euclideanNorm:eN,exp:Ds,expandDims:Hn,expm1:tN,eye:Ax,fft:Um,fill:pu,floor:Qh,floorDiv:Cx,fused:zz,gather:ed,gatherND:Dz,greater:vs,greaterEqual:Mi,ifft:Wc,imag:_m,image:Wr,inTopKAsync:Oz,irfft:Gx,isFinite:nN,isInf:sN,isNaN:rN,leakyRelu:Am,less:Bc,lessEqual:Wo,linalg:IN,linspace:ZM,localResponseNormalization:aN,log:Js,log1p:Rm,logSigmoid:iN,logSoftmax:Dx,logSumExp:Dm,logicalAnd:qr,logicalNot:Om,logicalOr:Ox,logicalXor:oN,losses:Gz,lowerBound:ez,matMul:rt,max:Sr,maxPool:Fm,maxPool3d:lN,maxPoolWithArgmax:tz,maximum:Xa,mean:Kt,meshgrid:nz,min:Pc,minimum:Do,mirrorPad:uN,mod:cN,moments:Lm,movingAverage:_z,mul:Y,multiRNNCell:sz,multinomial:rz,neg:Mt,norm:Zh,notEqual:Ql,oneHot:Vc,ones:$s,onesLike:Zs,op:G,outerProduct:az,pad:zi,pad1d:iz,pad2d:oz,pad3d:lz,pad4d:uz,pool:hN,pow:Ha,prelu:zm,print:k2,prod:dN,raggedGather:cz,raggedRange:hz,raggedTensorToTensor:dz,rand:fz,randomGamma:gz,randomNormal:Lx,randomStandardNormal:yz,randomUniform:Go,randomUniformInt:bz,range:eu,real:Uc,reciprocal:gN,relu:Ta,relu6:Mx,reshape:J,reverse:Tr,reverse1d:xz,reverse2d:wz,reverse3d:vz,reverse4d:Sz,rfft:jm,round:zx,rsqrt:Px,scalar:ze,scatterND:Az,searchSorted:Fx,selu:Bx,separableConv2d:Vx,setdiff1dAsync:Tz,sigmoid:pa,sign:yN,signal:Wz,sin:Ux,sinh:jx,slice:dt,slice1d:Pm,slice2d:Wx,slice3d:Bm,slice4d:jc,softmax:Vm,softplus:mu,spaceToBatchND:Mm,sparse:Hz,sparseToDense:Rz,spectral:jz,split:Is,sqrt:Pn,square:$t,squaredDifference:Hx,squeeze:Ho,stack:bs,step:gu,stridedSlice:bN,string:qz,sub:Ae,sum:Re,tan:xN,tanh:Ro,tensor:Xs,tensor1d:Xn,tensor2d:To,tensor3d:qx,tensor4d:Cz,tensor5d:Nz,tensor6d:kz,tensorScatterUpdate:Ez,tile:br,topk:vN,transpose:ut,truncatedNormal:Xx,unique:SN,unsortedSegmentSum:Yx,unstack:Cr,upperBound:$z,variable:TN,where:Mn,whereAsync:CN,zeros:gn,zerosLike:ft},Symbol.toStringTag,{value:"Module"}));const sce=(n,e,t,s=es)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add($("a",n,e,t),$("b",n,e,t))];case"AddN":return[s.addN($("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod($("a",n,e,t),$("b",n,e,t))];case"Mul":return[s.mul($("a",n,e,t),$("b",n,e,t))];case"RealDiv":case"Div":return[s.div($("a",n,e,t),$("b",n,e,t))];case"DivNoNan":return[s.divNoNan($("a",n,e,t),$("b",n,e,t))];case"FloorDiv":return[s.floorDiv($("a",n,e,t),$("b",n,e,t))];case"Sub":return[s.sub($("a",n,e,t),$("b",n,e,t))];case"Minimum":return[s.minimum($("a",n,e,t),$("b",n,e,t))];case"Maximum":return[s.maximum($("a",n,e,t),$("b",n,e,t))];case"Pow":return[s.pow($("a",n,e,t),$("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference($("a",n,e,t),$("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const rce=(n,e,t,s=es)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs($("x",n,e,t))];case"Acos":return[s.acos($("x",n,e,t))];case"Acosh":return[s.acosh($("x",n,e,t))];case"Asin":return[s.asin($("x",n,e,t))];case"Asinh":return[s.asinh($("x",n,e,t))];case"Atan":return[s.atan($("x",n,e,t))];case"Atan2":return[s.atan2($("x",n,e,t),$("y",n,e,t))];case"Atanh":return[s.atanh($("x",n,e,t))];case"Ceil":return[s.ceil($("x",n,e,t))];case"Complex":return[s.complex($("real",n,e,t),$("imag",n,e,t))];case"Cos":return[s.cos($("x",n,e,t))];case"Cosh":return[s.cosh($("x",n,e,t))];case"Elu":return[s.elu($("x",n,e,t))];case"Erf":return[s.erf($("x",n,e,t))];case"Exp":return[s.exp($("x",n,e,t))];case"Expm1":return[s.expm1($("x",n,e,t))];case"Floor":return[s.floor($("x",n,e,t))];case"Log":return[s.log($("x",n,e,t))];case"Log1p":return[s.log1p($("x",n,e,t))];case"Imag":return[s.imag($("x",n,e,t))];case"Neg":return[s.neg($("x",n,e,t))];case"Reciprocal":return[s.reciprocal($("x",n,e,t))];case"Real":return[s.real($("x",n,e,t))];case"Relu":return[s.relu($("x",n,e,t))];case"Round":return[s.round($("x",n,e,t))];case"Selu":return[s.selu($("x",n,e,t))];case"Sigmoid":return[s.sigmoid($("x",n,e,t))];case"Sin":return[s.sin($("x",n,e,t))];case"Sign":return[s.sign($("x",n,e,t))];case"Sinh":return[s.sinh($("x",n,e,t))];case"Softplus":return[s.softplus($("x",n,e,t))];case"Sqrt":return[s.sqrt($("x",n,e,t))];case"Square":return[s.square($("x",n,e,t))];case"Tanh":return[s.tanh($("x",n,e,t))];case"Tan":return[s.tan($("x",n,e,t))];case"ClipByValue":return[s.clipByValue($("x",n,e,t),$("clipValueMin",n,e,t),$("clipValueMax",n,e,t))];case"Relu6":return[s.relu6($("x",n,e,t))];case"Rsqrt":return[s.rsqrt(qn(n.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu($("x",n,e,t),$("alpha",n,e,t))];case"Prelu":return[s.prelu($("x",n,e,t),$("alpha",n,e,t))];case"IsNan":return[s.isNaN(qn(n.inputNames[0],e,t))];case"IsInf":return[s.isInf(qn(n.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(qn(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Br(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){O(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],a=e[s];O(r<0||a<0||r===a,()=>t+` Shapes ${n} and ${e} must match`)}}}function f3(n){return!(typeof n=="number"||n.some(e=>e<0))}function yf(n,e,t){let s=hC(n,t);const r=!f3(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(a=>{s=hC(a.shape,s)}),!f3(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function hC(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],a=e[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:a}return t}class ace{constructor(e,t,s,r,a,i,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=ze(0),En(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Br(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,En(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Xs([],[0].concat(this.elementShape));const s=this.readMany(e);return Br(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),bs(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Xs([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Br(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ln(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Cr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:t.size/s,i=[];re(()=>{t=J(t,[1,s,a]);for(let l=0;l<e.length;++l){const d=[0,l===0?0:r[l-1],0],f=[1,e[l],a];i[l]=J(dt(t,d,f),this.elementShape)}return i});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,i)}}class ru{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e?.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);Br(t,a.shape,"TensorList shape mismatch: "),En(a)}),this.idTensor=ze(0),this.maxNumElements=r,En(this.idTensor)}copy(){return new ru([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Br(e,this.elementShape,"TensorList shape mismatch: ");const r=yf(this.elementShape,this.tensors,e);return re(()=>{const a=this.tensors.map(i=>J(i,r));return bs(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=yf(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Br(r.shape,e,"TensorList shape mismatch: "),J(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Br(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");En(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new ru([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Br(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=yf(this.elementShape,this.tensors,t);return J(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Br(this.elementShape,t.shape,"TensorList shape mismatch: "),En(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Br(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=yf(this.elementShape,this.tensors,s);return e.length===0?Xs([],[0].concat(r)):re(()=>{const a=e.map(i=>J(this.tensors[i],r));return bs(a,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Br(this.elementShape,t,"TensorList shape mismatch: ");const s=yf(this.elementShape,this.tensors,t);return this.size()===0?Xs([],[0].concat(s)):re(()=>{const r=this.tensors.map(a=>J(a,s));return ln(r,0)})}}function ice(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Br(r,e,"TensorList shape mismatch: ");const a=Cr(n);return new ru(a,e,s)}function oce(n,e,t,s){return new ru([],n,e,s)}function lce(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new ru([],t,n.dtype,s),i=Cr(n,0);return e.forEach((o,l)=>{a.setItem(o,i[l])}),a}function uce(n,e,t){let s=0;const r=e.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const a=n.shape.slice(1),i=hC(a,t),o=s===0?0:n.size/s,l=re(()=>{const d=[];n=J(n,[1,s,o]);for(let f=0;f<e.length;++f){const y=[0,f===0?0:r[f-1],0],b=[1,e[f],o];d[f]=J(dt(n,y,b),i)}return n.dispose(),d}),h=new ru([],t,n.dtype,e.length);for(let d=0;d<l.length;d++)h.setItem(d,l[d]);return h}const cce=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=$("thenBranch",n,e,t),r=$("elseBranch",n,e,t),a=$("cond",n,e,t),i=$("args",n,e,t);return(await a.data())[0]?t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=$("body",n,e,t),r=$("cond",n,e,t),a=$("args",n,e,t),i=await t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap),o=a.map(d=>d.id);let l=await i[0].data();i.forEach(d=>{!d.kept&&o.indexOf(d.id)===-1&&d.dispose()});let h=a;for(;l[0];){const d=h;h=await t.functionMap[s].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);const f=h.map(y=>y.id);d.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&f.indexOf(y.id)===-1&&y.dispose()});const m=await t.functionMap[r].executeFunctionAsync(h,t.tensorArrayMap,t.tensorListMap);l=await m[0].data(),m.forEach(y=>{!y.kept&&o.indexOf(y.id)===-1&&f.indexOf(y.id)===-1&&y.dispose()})}return h}case"LoopCond":{const s=$("pred",n,e,t);return[xi(s)]}case"Switch":{const s=$("pred",n,e,t);let r=$("data",n,e,t);return r.kept||(r=xi(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>qn(r,e,t)!==void 0);if(s){const r=qn(s,e,t);return[xi(r)]}return}case"Enter":{const s=$("frameName",n,e,t),r=$("tensor",n,e,t);return t.enterFrame(s),[xi(r)]}case"Exit":{const s=$("tensor",n,e,t);return t.exitFrame(),[xi(s)]}case"NextIteration":{const s=$("tensor",n,e,t);return t.nextIteration(),[xi(s)]}case"TensorArrayV3":{const s=$("size",n,e,t),r=$("dtype",n,e,t),a=$("elementShape",n,e,t),i=$("dynamicSize",n,e,t),o=$("clearAfterRead",n,e,t),l=$("identicalElementShapes",n,e,t),h=$("name",n,e,t),d=new ace(h,r,s,a,l,i,o);return t.addTensorArray(d),[d.idTensor,ze(1)]}case"TensorArrayWriteV3":{const s=$("tensorArrayId",n,e,t),r=$("index",n,e,t),a=$("tensor",n,e,t),i=t.getTensorArray(s.id);return i.write(r,a),[i.idTensor]}case"TensorArrayReadV3":{const s=$("tensorArrayId",n,e,t),r=$("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=$("tensorArrayId",n,e,t),r=$("indices",n,e,t),a=$("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,a)]}case"TensorArrayScatterV3":{const s=$("tensorArrayId",n,e,t),r=$("indices",n,e,t),a=$("tensor",n,e,t),i=t.getTensorArray(s.id);return i.scatter(r,a),[i.idTensor]}case"TensorArrayConcatV3":{const s=$("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),a=$("dtype",n,e,t);return[r.concat(a)]}case"TensorArraySplitV3":{const s=$("tensorArrayId",n,e,t),r=$("tensor",n,e,t),a=$("lengths",n,e,t),i=t.getTensorArray(s.id);return i.split(a,r),[i.idTensor]}case"TensorArraySizeV3":{const s=$("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[ze(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=$("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=$("tensorListId",n,e,t),r=$("index",n,e,t),a=$("tensor",n,e,t),i=t.getTensorList(s.id);return i.setItem(r,a),[i.idTensor]}case"TensorListGetItem":{const s=$("tensorListId",n,e,t),r=$("index",n,e,t),a=$("elementShape",n,e,t),i=$("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=$("indices",n,e,t),r=$("tensor",n,e,t),a=$("elementShape",n,e,t),i=$("numElements",n,e,t),o=lce(r,s,a,i);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=$("elementShape",n,e,t),r=$("elementDType",n,e,t);let a;n.op==="TensorListReserve"?a="numElements":a="maxNumElements";const i=$(a,n,e,t),o=n.op==="TensorListReserve"?-1:i,l=oce(s,r,i,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=$("tensorListId",n,e,t),r=$("indices",n,e,t),a=$("elementShape",n,e,t),i=$("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,i,a)]}case"TensorListStack":{const s=$("tensorListId",n,e,t),r=$("elementShape",n,e,t),a=$("elementDType",n,e,t),i=$("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,a,i)]}case"TensorListFromTensor":{const s=$("tensor",n,e,t),r=$("elementShape",n,e,t),a=$("elementDType",n,e,t),i=ice(s,r,a);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=$("tensorListId",n,e,t),r=t.getTensorList(s.id),a=$("dtype",n,e,t),i=$("elementShape",n,e,t);return[r.concat(a,i)]}case"TensorListPushBack":{const s=$("tensorListId",n,e,t),r=$("tensor",n,e,t),a=t.getTensorList(s.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const s=$("tensorListId",n,e,t),r=$("elementShape",n,e,t),a=$("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,a)]}case"TensorListSplit":{const s=$("tensor",n,e,t),r=$("elementShape",n,e,t),a=$("lengths",n,e,t),i=uce(s,a,r);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=$("tensorListId",n,e,t),r=t.getTensorList(s.id);return[ze(r.size(),"int32")]}case"TensorListResize":{const s=$("tensorListId",n,e,t),r=$("size",n,e,t),i=t.getTensorList(s.id).resize(r);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function p3(n,e,t){const[s,r]=$("fusedOps",n,e,t),a=s==="biasadd",i=!a,o=r==="prelu",l=s==="fusedbatchnorm",h=$("numArgs",n,e,t);if(a){if(o&&h!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&h!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=$("strides",n,e,t),f=o0(n,e,t),m=$("dataFormat",n,e,t).toUpperCase(),y=$("dilations",n,e,t);let[b,x]=$("args",n,e,t);i&&(x=b,b=void 0);const w=$("leakyreluAlpha",n,e,t);return{stride:d,pad:f,dataFormat:m,dilations:y,biasArg:b,preluArg:x,activationFunc:r,leakyreluAlpha:w}}const hce=(n,e,t,s=es)=>{switch(n.op){case"Conv1D":{const r=$("stride",n,e,t),a=$("pad",n,e,t),i=$("dataFormat",n,e,t).toUpperCase(),o=$("dilation",n,e,t);return[s.conv1d($("x",n,e,t),$("filter",n,e,t),r,a,i,o)]}case"Conv2D":{const r=$("strides",n,e,t),a=o0(n,e,t),i=$("dataFormat",n,e,t).toUpperCase(),o=$("dilations",n,e,t);return[s.conv2d($("x",n,e,t),$("filter",n,e,t),[r[1],r[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:h,activationFunc:d,leakyreluAlpha:f}=p3(n,e,t);return[s.fused.conv2d({x:$("x",n,e,t),filter:$("filter",n,e,t),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:h,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:h,activationFunc:d,leakyreluAlpha:f}=p3(n,e,t);return[s.fused.depthwiseConv2d({x:$("x",n,e,t),filter:$("filter",n,e,t),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:d,preluActivationWeights:h,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=$("outputShape",n,e,t),a=$("strides",n,e,t),i=o0(n,e,t);return[s.conv2dTranspose($("x",n,e,t),$("filter",n,e,t),r,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=$("strides",n,e,t),a=o0(n,e,t),i=$("dilations",n,e,t),o=$("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d($("input",n,e,t),$("filter",n,e,t),[r[1],r[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("dataFormat",n,e,t).toUpperCase(),o=$("dilations",n,e,t);return[s.conv3d($("x",n,e,t),$("filter",n,e,t),[r[1],r[2],r[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("kernelSize",n,e,t);return[s.avgPool($("x",n,e,t),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("kernelSize",n,e,t);return[s.maxPool($("x",n,e,t),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("kernelSize",n,e,t),o=$("includeBatchInIndex",n,e,t),{result:l,indexes:h}=s.maxPoolWithArgmax($("x",n,e,t),[i[1],i[2]],[r[1],r[2]],a,o);return[l,h]}case"AvgPool3D":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("kernelSize",n,e,t);return[s.avgPool3d($("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("kernelSize",n,e,t);return[s.maxPool3d($("x",n,e,t),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=$("strides",n,e,t),a=$("pad",n,e,t),i=$("dilations",n,e,t),o=r[1],l=r[2],h=i[1],d=i[2];return[s.dilation2d($("x",n,e,t),$("filter",n,e,t),[o,l],a,[h,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const dce=(n,e,t,s=es)=>{switch(n.op){case"Fill":{const r=$("shape",n,e,t),a=$("dtype",n,e,t),i=$("value",n,e,t);return[s.fill(r,i,a)]}case"LinSpace":{const r=$("start",n,e,t),a=$("stop",n,e,t),i=$("num",n,e,t);return[s.linspace(r,a,i)]}case"Multinomial":{const r=$("logits",n,e,t),a=$("numSamples",n,e,t),i=$("seed",n,e,t);return[s.multinomial(r,a,i)]}case"OneHot":{const r=$("indices",n,e,t),a=$("depth",n,e,t),i=$("onValue",n,e,t),o=$("offValue",n,e,t),l=$("dtype",n,e,t);return[s.oneHot(r,a,i,o,l)]}case"Ones":return[s.ones($("shape",n,e,t),$("dtype",n,e,t))];case"OnesLike":return[s.onesLike($("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal($("shape",n,e,t),$("dtype",n,e,t),$("seed",n,e,t))];case"RandomUniform":return[s.randomUniform($("shape",n,e,t),$("minval",n,e,t),$("maxval",n,e,t),$("dtype",n,e,t))];case"RandomUniformInt":return[s.randomUniformInt($("shape",n,e,t),$("minval",n,e,t),$("maxval",n,e,t),$("seed",n,e,t))];case"Range":{const r=$("start",n,e,t),a=$("stop",n,e,t),i=$("step",n,e,t);return[s.range(r,a,i,$("dtype",n,e,t))]}case"TruncatedNormal":{const r=$("shape",n,e,t),a=$("mean",n,e,t),i=$("stdDev",n,e,t),o=$("seed",n,e,t);return[s.truncatedNormal(r,a,i,$("dtype",n,e,t),o)]}case"Zeros":return[s.zeros($("shape",n,e,t),$("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function VS(n,e,t){const s=$("boxes",n,e,t),r=$("scores",n,e,t),a=$("maxOutputSize",n,e,t),i=$("iouThreshold",n,e,t),o=$("scoreThreshold",n,e,t),l=$("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}const fce=async(n,e,t,s,r=es)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:h,softNmsSigma:d}=VS(n,e,t),f=await r.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,h,d);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:h}=VS(n,e,t),d=$("padToMaxOutputSize",n,e,t),f=await r.image.nonMaxSuppressionPaddedAsync(a,i,o,l,h,d);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:h}=VS(n,e,t);return[await r.image.nonMaxSuppressionAsync(a,i,o,l,h)]}case"Where":{const a=r.cast($("condition",n,e,t),"bool"),i=[await r.whereAsync(a)];return a.dispose(),i}case"ListDiff":return r.setdiff1dAsync($("x",n,e,t),$("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const pce=(n,e,t,s=es)=>{switch(n.op){case"LowerBound":{const r=$("sortedSequence",n,e,t),a=$("values",n,e,t);return[s.lowerBound(r,a)]}case"TopKV2":{const r=$("x",n,e,t),a=$("k",n,e,t),i=$("sorted",n,e,t),o=s.topk(r,a,i);return[o.values,o.indices]}case"UpperBound":{const r=$("sortedSequence",n,e,t),a=$("values",n,e,t);return[s.upperBound(r,a)]}case"Unique":{const r=$("x",n,e,t),a=s.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=$("x",n,e,t),a=$("axis",n,e,t),i=s.unique(r,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const mce=(n,e,t,s=es)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=$("default",n,e,t);return[qn(n.name,e,t)||r];case"Placeholder":return[qn(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const d=$("x",n,e,t);return[xi(d)]}case"IdentityN":return $("x",n,e,t).map(d=>xi(d));case"Snapshot":const a=$("x",n,e,t);return[xi(a)];case"Shape":return[s.tensor1d($("x",n,e,t).shape,"int32")];case"ShapeN":return $("x",n,e,t).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar($("x",n,e,t).size,"int32")];case"Rank":return[s.scalar($("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=$("x",n,e,t),o=$("data",n,e,t),l=$("message",n,e,t),h=$("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,h));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class gce{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ze(0),this.tensorMap=new Map,En(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ze(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),re(()=>{const r=Cr(t),a=s.length,i=r.length;O(a===i,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${i} elements.`);for(let o=0;o<a;o++){const l=s[o],h=r[o];En(h),this.tensorMap.set(l,h)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return re(()=>{const r=[];for(let a=0;a<s.length;a++){const i=s[a],o=this.findWithDefault(i,t);r.push(o)}return bs(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const yce=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(n.name);if(r!=null)return[r];{const a=$("keyDType",n,e,t),i=$("valueDType",n,e,t),o=new gce(a,i);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=$("tableHandle",n,e,t,s),a=$("keys",n,e,t),i=$("values",n,e,t);return[await s.getHashTableById(r.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=$("tableHandle",n,e,t,s),a=$("keys",n,e,t),i=$("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=$("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const bce=(n,e,t,s=es)=>{switch(n.op){case"ResizeBilinear":{const r=$("images",n,e,t),a=$("size",n,e,t),i=$("alignCorners",n,e,t),o=$("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(r,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const r=$("images",n,e,t),a=$("size",n,e,t),i=$("alignCorners",n,e,t),o=$("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(r,[a[0],a[1]],i,o)]}case"CropAndResize":{const r=$("image",n,e,t),a=$("boxes",n,e,t),i=$("boxInd",n,e,t),o=$("cropSize",n,e,t),l=$("method",n,e,t),h=$("extrapolationValue",n,e,t);return[s.image.cropAndResize(r,a,i,o,l,h)]}case"ImageProjectiveTransformV3":{const r=$("images",n,e,t),a=$("transforms",n,e,t),i=$("outputShape",n,e,t),o=$("fillValue",n,e,t),l=$("interpolation",n,e,t),h=$("fillMode",n,e,t);return[s.image.transform(r,a,l.toLowerCase(),h.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const xce=(n,e,t,s=es)=>{switch(n.op){case"Equal":return[s.equal($("a",n,e,t),$("b",n,e,t))];case"NotEqual":return[s.notEqual($("a",n,e,t),$("b",n,e,t))];case"Greater":return[s.greater($("a",n,e,t),$("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual($("a",n,e,t),$("b",n,e,t))];case"Less":return[s.less($("a",n,e,t),$("b",n,e,t))];case"LessEqual":return[s.lessEqual($("a",n,e,t),$("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd($("a",n,e,t),$("b",n,e,t))];case"LogicalNot":return[s.logicalNot($("a",n,e,t))];case"LogicalOr":return[s.logicalOr($("a",n,e,t),$("b",n,e,t))];case"Select":case"SelectV2":return[s.where($("condition",n,e,t),$("a",n,e,t),$("b",n,e,t))];case"BitwiseAnd":return[s.bitwiseAnd($("a",n,e,t),$("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const wce=(n,e,t,s=es)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul($("a",n,e,t),$("b",n,e,t),$("transposeA",n,e,t),$("transposeB",n,e,t))];case"Einsum":return[s.einsum($("equation",n,e,t),...$("tensors",n,e,t))];case"Transpose":return[s.transpose($("x",n,e,t),$("perm",n,e,t))];case"_FusedMatMul":const[r,a]=$("fusedOps",n,e,t),i=r==="biasadd",o=a==="prelu",l=$("numArgs",n,e,t),h=$("leakyreluAlpha",n,e,t);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,f]=$("args",n,e,t);return[s.fused.matMul({a:$("a",n,e,t),b:$("b",n,e,t),transposeA:$("transposeA",n,e,t),transposeB:$("transposeB",n,e,t),bias:d,activation:a,preluActivationWeights:f,leakyreluAlpha:h})];case"MatrixBandPart":return[s.linalg.bandPart($("a",n,e,t),$("numLower",n,e,t),$("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const vce=(n,e,t,s=es)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm($("x",n,e,t),$("axis",n,e,t),$("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm($("x",n,e,t),$("mean",n,e,t),$("variance",n,e,t),$("offset",n,e,t),$("scale",n,e,t),$("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm($("x",n,e,t),$("mean",n,e,t),$("variance",n,e,t),$("offset",n,e,t),$("scale",n,e,t),$("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization($("x",n,e,t),$("radius",n,e,t),$("bias",n,e,t),$("alpha",n,e,t),$("beta",n,e,t))];case"Softmax":return[s.softmax($("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Sce=(n,e,t,s=es)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=s.raggedGather($("paramsNestedSplits",n,e,t),$("paramsDenseValues",n,e,t),$("indices",n,e,t),$("outputRaggedRank",n,e,t));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=s.raggedRange($("starts",n,e,t),$("limits",n,e,t),$("splits",n,e,t));return[r,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor($("shape",n,e,t),$("values",n,e,t),$("defaultValue",n,e,t),$("rowPartitionTensors",n,e,t),$("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Tce=(n,e,t,s=es)=>{switch(n.op){case"Max":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.max($("x",n,e,t),o,l)]}case"Mean":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.mean($("x",n,e,t),o,l)]}case"Min":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.min($("x",n,e,t),o,l)]}case"Sum":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.sum($("x",n,e,t),o,l)]}case"All":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.all($("x",n,e,t),o,l)]}case"Any":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.any($("x",n,e,t),o,l)]}case"ArgMax":{const o=$("axis",n,e,t);return[s.argMax($("x",n,e,t),o)]}case"ArgMin":{const o=$("axis",n,e,t);return[s.argMin($("x",n,e,t),o)]}case"Prod":{const o=$("axis",n,e,t),l=$("keepDims",n,e,t);return[s.prod($("x",n,e,t),o,l)]}case"Cumprod":{const o=$("axis",n,e,t),l=$("exclusive",n,e,t),h=$("reverse",n,e,t);return[s.cumprod($("x",n,e,t),o,l,h)]}case"Cumsum":{const o=$("axis",n,e,t),l=$("exclusive",n,e,t),h=$("reverse",n,e,t);return[s.cumsum($("x",n,e,t),o,l,h)]}case"Bincount":const r=$("x",n,e,t),a=$("weights",n,e,t),i=$("size",n,e,t);return[s.bincount(r,a,i)];case"DenseBincount":{const o=$("x",n,e,t),l=$("weights",n,e,t),h=$("size",n,e,t),d=$("binaryOutput",n,e,t);return[s.denseBincount(o,l,h,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Cce=(n,e,t,s=es)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=$("n",n,e,t),a=$("axis",n,e,t);let i=$("tensors",n,e,t);return i=i.slice(0,r),[s.concat(i,a)]}case"Gather":{const r=$("x",n,e,t),a=$("indices",n,e,t);return[s.gather(r,s.cast(a,"int32"),0)]}case"GatherV2":{const r=$("axis",n,e,t),a=$("batchDims",n,e,t),i=$("x",n,e,t),o=$("indices",n,e,t);return[s.gather(i,s.cast(o,"int32"),r,a)]}case"Reverse":{const r=$("dims",n,e,t),a=[];for(let o=0;o<r.length;o++)r[o]&&a.push(o);const i=$("x",n,e,t);return[s.reverse(i,a)]}case"ReverseV2":{const r=$("axis",n,e,t),a=$("x",n,e,t);return[s.reverse(a,r)]}case"Slice":{const r=$("begin",n,e,t),a=$("size",n,e,t);return[s.slice($("x",n,e,t),r,a)]}case"StridedSlice":{const r=$("begin",n,e,t),a=$("end",n,e,t),i=$("strides",n,e,t),o=$("beginMask",n,e,t),l=$("endMask",n,e,t),h=$("ellipsisMask",n,e,t),d=$("newAxisMask",n,e,t),f=$("shrinkAxisMask",n,e,t),m=$("x",n,e,t);return[s.stridedSlice(m,r,a,i,o,l,h,d,f)]}case"Pack":return re(()=>{const r=$("axis",n,e,t),a=$("tensors",n,e,t),i=a[0].shape,o=s.squeeze(a[0]).shape,l=a.map(h=>{const d=lt(h.shape,i);if(!d&&!lt(s.squeeze(h).shape,o))throw new Error("the input tensors shape does not match");return d?h:s.reshape(h,i)});return[s.stack(l,r)]});case"Unpack":{const r=$("axis",n,e,t),a=$("tensor",n,e,t);return s.unstack(a,r)}case"Tile":{const r=$("reps",n,e,t);return[s.tile($("x",n,e,t),r)]}case"Split":case"SplitV":{const r=$("axis",n,e,t),a=$("numOrSizeSplits",n,e,t),i=$("x",n,e,t);return s.split(i,a,r)}case"ScatterNd":{const r=$("indices",n,e,t),a=$("values",n,e,t),i=$("shape",n,e,t);return[s.scatterND(r,a,i)]}case"GatherNd":{const r=$("x",n,e,t),a=$("indices",n,e,t);return[s.gatherND(r,a)]}case"SparseToDense":{const r=$("sparseIndices",n,e,t),a=$("outputShape",n,e,t),i=$("sparseValues",n,e,t),o=$("defaultValue",n,e,t);return[s.sparseToDense(r,i,a,i.dtype===o.dtype?o:s.cast(o,i.dtype))]}case"TensorScatterUpdate":{const r=$("indices",n,e,t),a=$("values",n,e,t),i=$("tensor",n,e,t);return[s.tensorScatterUpdate(i,r,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Nce=(n,e,t,s=es)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows($("indices",n,e,t),$("values",n,e,t),$("denseShape",n,e,t),$("defaultValue",n,e,t));return[r,a,i,o]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=s.sparse.sparseReshape($("inputIndices",n,e,t),$("inputShape",n,e,t),$("newShape",n,e,t));return[r,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean($("data",n,e,t),$("indices",n,e,t),$("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum($("data",n,e,t),$("indices",n,e,t),$("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const kce=(n,e,t,s=es)=>{switch(n.op){case"FFT":return[s.fft($("x",n,e,t))];case"IFFT":return[s.ifft($("x",n,e,t))];case"RFFT":return[s.rfft($("x",n,e,t))];case"IRFFT":return[s.irfft($("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Ece=(n,e,t,s=es)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace($("input",n,e,t),$("pattern",n,e,t),$("rewrite",n,e,t),$("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=s.string.stringNGrams($("data",n,e,t),$("dataSplits",n,e,t),$("separator",n,e,t),$("nGramWidths",n,e,t),$("leftPad",n,e,t),$("rightPad",n,e,t),$("padWidth",n,e,t),$("preserveShortSequences",n,e,t));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:i}=s.string.stringSplit($("input",n,e,t),$("delimiter",n,e,t),$("skipEmpty",n,e,t));return[r,a,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast($("input",n,e,t),$("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const $ce=(n,e,t,s=es)=>{switch(n.op){case"Cast":return[s.cast($("x",n,e,t),$("dtype",n,e,t))];case"ExpandDims":{const r=$("axis",n,e,t);return[s.expandDims($("x",n,e,t),r)]}case"Squeeze":{const r=$("axis",n,e,t);return[s.squeeze($("x",n,e,t),r)]}case"Reshape":return[s.reshape($("x",n,e,t),$("shape",n,e,t))];case"EnsureShape":return[s.ensureShape($("x",n,e,t),$("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad($("x",n,e,t),$("padding",n,e,t),$("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad($("x",n,e,t),$("padding",n,e,t),$("constantValue",n,e,t))];case"SpaceToBatchND":{const r=$("blockShape",n,e,t),a=$("paddings",n,e,t);return[s.spaceToBatchND($("x",n,e,t),r,a)]}case"BatchToSpaceND":{const r=$("blockShape",n,e,t),a=$("crops",n,e,t);return[s.batchToSpaceND($("x",n,e,t),r,a)]}case"DepthToSpace":{const r=$("blockSize",n,e,t),a=$("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace($("x",n,e,t),r,a)]}case"BroadcastTo":return[s.broadcastTo($("x",n,e,t),$("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs($("s0",n,e,t),$("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function m3(n,e,t,s,r=re){const a=((i,o,l)=>{switch(i.category){case"arithmetic":return r(()=>sce(i,o,l));case"basic_math":return r(()=>rce(i,o,l));case"control":return cce(i,o,l);case"convolution":return r(()=>hce(i,o,l));case"creation":return r(()=>dce(i,o,l));case"dynamic":return fce(i,o,l);case"evaluation":return r(()=>pce(i,o,l));case"image":return r(()=>bce(i,o,l));case"graph":return r(()=>mce(i,o,l));case"logical":return r(()=>xce(i,o,l));case"matrices":return r(()=>wce(i,o,l));case"normalization":return r(()=>vce(i,o,l));case"ragged":return r(()=>Sce(i,o,l));case"reduction":return r(()=>Tce(i,o,l));case"slice_join":return r(()=>Cce(i,o,l));case"sparse":return r(()=>Nce(i,o,l));case"spectral":return r(()=>kce(i,o,l));case"string":return r(()=>Ece(i,o,l));case"transformation":return r(()=>$ce(i,o,l));case"hash_table":return yce(i,o,l,s);case"custom":const h=t4(i.op);if(h&&h.customExecutor)return h.customExecutor(new nce(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Ni(a)?a.then(i=>[].concat(i)):[].concat(a)}class g3{constructor(e={},t={},s={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function y3(n,e,t,s){const r=new Set,a=[];let i=null,o=null;const l=new Set,h=new Set(Object.keys(n).map(m=>Hs(m)[0]));s=s||[];const d=new Set(s.map(m=>Hs(m.name)[0])),f=[...e];for(;f.length>0;){const m=f.pop();if((Al(m)||Lce(m)||Mce(m))&&i==null&&(i=m,o=i.children.map(y=>y.name).filter(y=>r.has(y))),r.add(m.name),t[m.name]==null&&!h.has(m.name)&&!d.has(m.name)){if(m.inputs.length===0){a.push(m.name);continue}m.inputs.forEach(y=>{l.has(y.name)||(l.add(y.name),f.push(y))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:a,dynamicNode:i,syncInputs:o}}function Ice(n,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(w=>Hs(w)[0]).map(w=>n.nodes[w]),a=n.initNodes||[],i=w=>t.has(typeof w=="string"?w:w.name);function o(w){return[...new Map(w.map(v=>[v.name,v])).values()]}const l=o([...r,...n.weights,...a]).filter(i),h=o([...l,...Object.values(n.nodes)]).filter(i),d=new Map(h.map(w=>[w.name,w])),f={};for(const w of h){f[w.name]=f[w.name]||0;for(const v of w.children)i(v)||(f[v.name]=Number.POSITIVE_INFINITY),f[v.name]=(f[v.name]||0)+1}const m=Object.entries(f).filter(([,w])=>w===0).map(([w])=>w),y=[...m];for(;m.length>0;){const w=m.pop(),v=d.get(w);for(const C of v.children.filter(i))--f[C.name]===0&&(y.push(C.name),m.push(C.name))}const b=y.map(w=>d.get(w)),x=_ce(b,l);return Ace(x,l),x}function _ce(n,e){const t=new Map(n.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),o=t.get(i);for(const l of o.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return n.filter(i=>r.has(i.name))}class By extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Ace(n,e){const t=new Map(n.map((o,l)=>[o.name,l])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),a=new Set(n.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(const o of n){for(const l of o.children.filter(i)){if(!t.has(l.name))throw new By(`Child ${l.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(l.name))throw new By(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(const l of o.inputs){if(!t.has(l.name))throw new By(`Input ${l.name} of node ${o.name} is unreachable.`);if(t.get(l.name)>t.get(o.name))throw new By(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function Rce(n){const e=new Map(n.map((o,l)=>[o.name,l])),t=Number.MAX_SAFE_INTEGER,s=n.map((o,l)=>Al(o)?t:l),r=o=>{const l=s[e.get(o.name)];return l??-1},a=n.map((o,l)=>o.children.map(r).reduce((h,d)=>Math.max(h,d),s[l])),i=new Map;for(let o=0;o<n.length;++o){const l=a[o];if(l===t)continue;const h=n[o],d=n[l];i.has(d.name)||i.set(d.name,[]),i.get(d.name).push(h)}return i}const Dce=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Oce=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Fce=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Al(n){return Dce.has(n.op)}function Lce(n){return Oce.has(n.op)}function Mce(n){return Fce.has(n.op)}class H0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new H0(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(a=>a.name).sort(),r=t.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=y3(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:i}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const h=t.map(f=>f.name),d=Object.keys(e);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=Ice(this.graph,s),l=Rce(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return En(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(m=>this.graph.nodes[Hs(m)[0]]),a=t.map(m=>Hs(m)[0]),i=new Set(a);let o=a.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(r,o);let h=this.compiledMap.get(l);h==null&&(h=this.compile(e,o),this.compiledMap.set(l,h));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const d={},f={};return re(()=>{const m=new g3(this.weightMap,d,f,this.functionExecutorMap,this.parseNodeNameCache),y=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(v=>{const[C,N]=Hs(v,m),k=[];k[N]=e[v],y[C]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[C]=this.cloneTensorList(k))});const b=this.getFrozenTensorIds(y),{orderedNodes:x,nodeLiveUntilMap:w}=h;for(const v of x){if(y[v.name])continue;const C=m3(v,y,m,this._resourceManager);if(Ni(C))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);y[v.name]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(C)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,y,m,b,i,w.get(v.name))}return this.parent==null&&m.dispose(b),t.map(v=>qn(v,y,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,a,i,o){if(!(Al(t)||i.has(e))){for(const l of s[e])l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length);for(const l of t.inputs){if(Al(l))continue;const h=c3(l.name,s,r);if(h!=null)for(const d of h){if(!d||d.kept||a.has(d.id))continue;const f=o[d.id];f===1?(d.dispose(),delete o[d.id]):f!=null&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,a,i){function o(l){return Al(l)||a.has(l.name)}if(!(Al(e)||i==null))for(const l of i){if(o(l))continue;const h=c3(l.name,t,s);for(const d of h)!d||d.kept||r.has(d.id)||d.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},a={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const i=new g3(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,i,t,s),l=t.map(m=>qn(m,o,i)),h=l.map(m=>m.id),d=Object.keys(e).map(m=>e[m].id),f=new Set([...h,...d,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(y=>{y&&!y.isDisposed&&!f.has(y.id)&&y.dispose()})}),this.parent==null&&i.dispose(f),l}async executeFunctionAsync(e,t,s){const r=e.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const a=Object.keys(e),i=a.map(k=>this.graph.nodes[Hs(k)[0]]),o=s.map(k=>Hs(k)[0]),l=new Set(o);let h=o.map(k=>this.graph.nodes[k]);h.length===0&&(h=this._outputs);const{usedNodes:d,missingInputs:f,dynamicNode:m,syncInputs:y}=y3(e,h,this.weightMap,this._initNodes),b=[...i,...this.graph.weights,...this._initNodes||[]].map(k=>({node:k,contexts:t.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(k=>{const[E,_]=Hs(k),R=[];R[_]=e[k],x[E]=R});const w={},v=this.getFrozenTensorIds(x),C={};for(;b.length>0;){const k=this.processStack(i,b,t,x,C,v,l,w,d);await Promise.all(k)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=h.filter(k=>!Al(k)&&!qn(k.name,x,t)).map(k=>k.name);if(N.length>0){let k="";throw m!=null&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${y}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${a}]. Consider providing the following inputs: [${f}]. ${k}`)}return x}processStack(e,t,s,r,a,i,o,l,h){const d=[];for(;t.length>0;){const f=t.pop();s.currentContext=f.contexts;let m="";if(f.node.op==="Enter"&&$("isConstant",f.node,r,s)&&([m]=bi(f.node.name,s)),r[f.node.name]==null){const y=m3(f.node,r,s,this._resourceManager);m||([m]=bi(f.node.name,s));const b=s.currentContext;Ni(y)?d.push(y.then(x=>(r[m]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(x)),s.currentContext=b,this.checkTensorForDisposal(m,f.node,r,s,i,o,l),this.processChildNodes(f.node,t,s,r,a,h),x))):(r[m]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(y)),this.checkTensorForDisposal(m,f.node,r,s,i,o,l),this.processChildNodes(f.node,t,s,r,a,h))}else this.processChildNodes(f.node,t,s,r,a,h)}return d}processChildNodes(e,t,s,r,a,i){e.children.forEach(o=>{const[l]=bi(o.name,s);a[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(h=>!!qn(h,r,s))&&(a[l]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(h=>!!qn(h,r,s))&&(a[l]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Hs(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const i=a.attrParams.shape.value,o=i.length===s.shape.length&&s.shape.every((l,h)=>i[h]===-1||i[h]===l);O(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&O(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const a in e){const i=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[a];i!=null?r[i.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Hs(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const a=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return a!=null?a.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Hs(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class zce{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Pce="?tfjs-format=file",Bce="model.json";class BE{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=zN){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new zce}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ni(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await AM(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new H0(h3.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=h3.Instance.transformGraph(e.modelInitializer);this.initializer=new H0(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof bt?[e]:e,s={};return t.forEach((r,a)=>s[this.structuredOutputKeys[a]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof bt)&&!Array.isArray(e)){const a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(const i in a){const o=a[i];o.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,i)=>{var o,l,h;const d=(h=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[i])===null||h===void 0?void 0:h.resourceId;return d!=null?a[i]=this.resourceIdToCapturedInput[d]:a[i]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const a=s[r],i=t[a];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Je(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Vce(n,e={},t=zN){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=jce(n));const s=new BE(n,e,t);return await s.load(),s}function Uce(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,r]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const a=D0(s.weightsManifest),i=C2(s,a,r);e=F0(i)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=F0(n);else throw new Error("Unknown model format");const t=new BE(e);return t.load(),t}function jce(n){return n.endsWith("/")||(n=n+"/"),`${n}${Bce}${Pce}`}const r4="4.22.0";function Wce(n,e){return q0(n,e)}function q0(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(qc(n)){const a=Array.isArray(n)?[]:{};s.add(n);for(const i in n){const o=n[i],l=q0(o,e,t,s);a[i]=l}return s.delete(n),n.__proto__&&(a.__proto__=n.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,r.value),r.value}function Gce(n,e=i4){return a4(n,e)}function a4(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const r=e(n);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(qc(s)){const a=Array.isArray(s)?[]:{};t.add(s);for(const i in s){const o=n.map(h=>h[i]),l=a4(o,e,t);a[i]=l}return t.delete(s),a}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return r.value}function i4(n){return n===null?null:qc(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function o4(n,e){const t=new Map;q0(n,e,t);for(const r of Array.from(t.keys())){const a=t.get(r);if(Ni(a)){const i=await a;t.set(r,i)}}return q0(n,e,t)}function qc(n){let e=!1;if(ie().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof bt)&&!(n instanceof Promise)&&!e)}function Hce(n){return n==null||qce(n)||Array.isArray(n)||typeof n=="object"&&n instanceof bt||kn(n)}function qce(n){return n===null||typeof n!="object"&&typeof n!="function"}function Kce(n){return Wce(n,Xce)}function Xce(n){return n instanceof bt?{value:n.clone(),recurse:!1}:qc(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class l4{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}class Rw extends l4{constructor(){super(Rw.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let r=0;r<s;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Rw.INITIAL_CAPACITY=32;function u4(n){return new Zce(n)}function VE(n){return new Qce(n)}function Yce(n,e){return new c4(n,e)}function Jce(n,e=wo.FAIL){return new lhe(n,e)}class Bn{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new ihe(this,e)}filter(e){return new rhe(this,e)}map(e){return new ahe(this,e)}mapAsync(e){return new b3(this,e)}serialMapAsync(e){return new b3(this,e).serial()}flatmap(e){return new ohe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new she(this,e,t)}columnMajorBatch(e,t=!0,s=i4){return this.rowMajorBatch(e,t).map(a=>Gce(a,s))}concatenate(e,t){return new c4(u4([this,e]),t)}take(e){return e<0||e==null?this:new nhe(this,e)}skip(e){return e<0||e==null?this:new the(this,e)}prefetch(e){return new h4(this,e)}shuffle(e,t){return new uhe(this,e,t)}serial(){return new ehe(this)}}class Zce extends Bn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Kce(e),done:!1}}}class Qce extends Bn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class ehe extends Bn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class the extends Bn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Je(e.value)}return this.upstream.next()}}class nhe extends Bn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class she extends Bn{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class rhe extends Bn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Je(e.value)}}}class ahe extends Bn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Ei(e.value),s=this.transform(e.value),r=Ei(s);for(const a of t)Tx(a,r)||a.dispose();return{value:s,done:!1}}}class ihe extends Bn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class b3 extends Bn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Ei(e.value),s=await this.transform(e.value),r=Ei(s);for(const a of t)Tx(a,r)||a.dispose();return{value:s,done:!1}}}class UE extends Bn{constructor(){super(),this.outputQueue=new Rw,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class ohe extends UE{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Ei(e.value),s=this.transform(e.value),r=Ei(s);this.outputQueue.pushAll(s);for(const a of t)Tx(a,r)||a.dispose();return!0}}class c4 extends Bn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var wo;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(wo||(wo={}));class lhe extends Bn{constructor(e,t=wo.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function r(i){return i instanceof Bn?{value:i.next().then(l=>(t++,l.done&&s++,l.value)),recurse:!1}:{value:null,recurse:!0}}const a=await o4(this.iterators,r);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case wo.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case wo.SHORTEST:return{value:null,done:!0};case wo.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class h4 extends Bn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new l4(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class uhe extends h4{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=td.alea(s||Gn().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}class ld{constructor(){this.size=null}batch(e,t=!0){const s=this;O(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Gs(async()=>(await s.iterator()).columnMajorBatch(e,t,dhe),r)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,Gs(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,Gs(async()=>(await t.iterator()).filter(r=>re(()=>e(r))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Gs(async()=>(await t.iterator()).map(s=>re(()=>e(s))),this.size)}mapAsync(e){const t=this;return Gs(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Gs(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,Gs(async()=>{const r=VE(async()=>({value:await t.iterator(),done:!1}));return Yce(r.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,Gs(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=td.alea(t||Gn().toString());return Gs(async()=>{let i=a.int32();return s&&(i+=a.int32()),(await r.iterator()).shuffle(e,i.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,Gs(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}ld.MAX_BUFFER_SIZE=1e4;function Gs(n,e=null){return new class extends ld{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function che(n){return Gs(async()=>u4(n),n.length)}function hhe(n){if(!qc(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return Gs(async()=>{const t=await o4(n,s=>{if(s instanceof ld)return{value:s.iterator(),recurse:!1};if(qc(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return Jce(t,wo.SHORTEST)},e)}function dhe(n){if(n===null)return null;const e=n[0];return Hce(e)?{value:fhe(n),recurse:!1}:{value:null,recurse:!0}}function fhe(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof bt?bs(n):Xs(n)}class d4 extends ld{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}const Vy='"',bf=Symbol("out"),x3=Symbol("field"),Uy=Symbol("quote"),US=Symbol("quoteafterquote"),w3=Symbol("quoteinquote");class f4 extends ld{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&O(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,a)=>(r[a]=r[a]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(O(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new d4(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(O(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let a=0;a<this.fullColumnNames.length;a++){const i=this.fullColumnNames[a],o=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!o)){const l=t[a];let h=null;if(l==="")if(o&&o.default!==void 0)h=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);h=void 0}else{const d=Number(l);if(isNaN(d))o&&o.dtype==="bool"?h=this.getBoolean(l):h=l;else if(!o||!o.dtype)h=d;else switch(o.dtype){case"float32":h=d;break;case"int32":h=Math.floor(d);break;case"bool":h=this.getBoolean(l);break;default:h=d}}o&&o.isLabel?r[i]=h:s[i]=h}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const a=e.length;let i=bf;for(let o=0;o<a;o++)switch(i){case bf:switch(e.charAt(o)){case Vy:r=o+1,i=Uy;break;case this.delimiter:if(r=o+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),i=bf;break;default:i=x3,r=o;break}break;case x3:e.charAt(o)===this.delimiter&&(s.push(e.substring(r,o)),i=bf,r=o+1);break;case Uy:e.charAt(o)===Vy&&(i=US);break;case US:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(r,o-1)),i=bf,r=o+1;break;case Vy:i=Uy;break;default:i=w3;break}break;case w3:e.charAt(o)===Vy&&(i=Uy);break}if(i===US?s.push(e.substring(r,a-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}class jE extends Bn{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ie().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new jE(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,a)=>s.set(r,a*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(he(t));return s.set(e,s.length-e.length),Xs(s,t)}}class WE extends Bn{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Xn([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-s)/2,i=(1-r)/2,o=a+s,l=r+i;this.cropBox=To([i,a,l,o],[1,4])}else this.cropBox=To([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ie().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new WE(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&O(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=sP(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return re(()=>{const t=Hn(Ne(e,"float32"),0);let s;s=Wr.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return J(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class p4{}class m4 extends Bn{split(e){return new phe(this,e)}}class phe extends m4{constructor(e,t){super(),this.upstream=e,this.impl=new mhe(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class mhe extends UE{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}class ghe extends Bn{decodeUTF8(){return new yhe(this)}}class yhe extends m4{constructor(e){super(),this.upstream=e,this.impl=new bhe(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class bhe extends UE{constructor(e){if(super(),this.upstream=e,ie().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return ie().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}class g4 extends ghe{constructor(e,t={}){super(),this.file=e,this.options=t,O(e instanceof Uint8Array||(ie().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const a=new FileReader;a.onload=o=>{let l=a.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(l)},a.onabort=o=>s(new Error("Aborted")),a.onerror=o=>s(new Error(o.type));const i=this.file.slice(this.offset,r);a.readAsArrayBuffer(i)}this.offset=r}),done:!1}}}async function xhe(n,e={},t){let s,r;typeof n=="string"?s=n:(s=n.url,r=whe(n));const a=await vM(s,r);if(a.ok){const i=new Uint8Array(await a.arrayBuffer());return new g4(i,e)}else throw new Error(a.statusText)}const whe=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});function y4(n){return typeof n=="string"&&n.slice(0,7)==="file://"}class b4 extends p4{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(y4(this.input)&&ie().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new g4(this.input,this.options)}}class x4 extends p4{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return y4(this.url)?new b4(this.url,this.fileOptions).iterator():xhe(this.url,this.fileOptions)}}function vhe(n,e={}){return new f4(new x4(n),e)}function She(n){const e=VE(n);return Gs(async()=>e)}function The(n){return Gs(async()=>{const e=await n();return VE(()=>e.next())})}async function Che(n,e){return WE.create(n,e)}async function Nhe(n){return jE.create(n)}const w4="4.22.0";const khe=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:f4,Dataset:ld,FileDataSource:b4,TextLineDataset:d4,URLDataSource:x4,array:che,csv:vhe,func:She,generator:The,microphone:Nhe,version_data:w4,webcam:Che,zip:hhe},Symbol.toStringTag,{value:"Module"}));function Oe(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const Ehe=Jx;class ng extends fb{nextDataId(){return ng.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new u2(this,ua())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ie().get("IS_NODE")&&gr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Fa(s[0])){const a=s.map(i=>Pa(i));r=this.write(a,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return _i(r,a)}return uM(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>ki(r));return tt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tt(e.shape,e.dtype,t)}makeOutput(e,t,s){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Gn();return e(),{kernelMs:Gn()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Oe([e],"where");const t=this.readSync(e.dataId);return Ehe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ng.nextDataId=0;function v4(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const $he=n=>{const{x:e}=n.inputs,t=n.backend;Oe(e,"abs");let s=new Float32Array(he(e.shape));const r=t.data.get(e.dataId).values;return s=v4(r),t.makeOutput(s,e.shape,e.dtype)},Ihe={kernelName:vp,backendName:"cpu",kernelFunc:$he};function dn(n){return(e,t,s,r,a)=>{const i=Ze(e,t),o=i.length,l=Pe(i),h=he(i),d=zn(a,h),f=e.length,m=t.length,y=Pe(e),b=Pe(t),x=Zl(e,i),w=Zl(t,i);if(x.length+w.length===0)for(let v=0;v<d.length;++v)d[v]=n(s[v%s.length],r[v%r.length]);else for(let v=0;v<d.length;++v){const C=du(v,o,l),N=C.slice(-f);x.forEach(R=>N[R]=0);const k=fa(N,f,y),E=C.slice(-m);w.forEach(R=>E[R]=0);const _=fa(E,m,b);d[v]=n(s[k],r[_])}return[d,i]}}function qs(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,a=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(o.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",a),imag:t.makeTensorInfo(r.shape,"float32",i)},o}const _he={kernelName:Sb,backendName:"cpu",kernelFunc:qs};function K0(n,e,t="float32"){if(t==="complex64"){const r=K0(n,e,"float32"),a=K0(n,e,"float32");return qs({inputs:{real:r,imag:a},backend:n})}const s=Yn(he(e),t);return n.makeTensorInfo(e,t,s)}function Ka(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Ahe={kernelName:wh,backendName:"cpu",kernelFunc:Ka};function au(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,a=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,a)}const Rhe={kernelName:tx,backendName:"cpu",kernelFunc:au};function S4(n,e,t,s){if(s==="int32"){const r=Int32Array.from(n);return[e,"int32",r]}if(s==="bool"){const r=Bo([0],t),[a,i]=dn((o,l)=>o!==l?1:0)(e,[],n,r,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function zo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return Ka({inputs:{x:r},backend:t});const d=K0(t,r.shape,r.dtype),f=zo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),m=qs({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),m}if(r.dtype==="complex64"){const d=au({inputs:{input:r},backend:t}),f=zo({inputs:{x:d},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(d),f}if(!d2(r.dtype,a)){const d=Ka({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:a}}const i=t.data.get(r.dataId).values,[o,l,h]=S4(i,r.shape,r.dtype,a);return t.makeTensorInfo(o,l,h)}const Dhe={kernelName:oh,backendName:"cpu",kernelFunc:zo};function An(n,e,t,s){return t==null?({inputs:r,backend:a})=>{const{a:i,b:o}=r,l=a;Oe([i,o],n);const h=l.data.get(i.dataId).values,d=l.data.get(o.dataId).values,f=i.dtype==="string"?Ai(h):h,m=i.dtype==="string"?Ai(d):d,y=s||i.dtype,[b,x]=e(i.shape,o.shape,f,m,y);return l.makeTensorInfo(x,y,b)}:({inputs:r,backend:a})=>{const{a:i,b:o}=r,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const h=zo({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(h.dataId),f=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,y=l.data.get(f.dataId).values,b=l.data.get(m.dataId).values,x=zo({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),w=l.data.get(x.dataId),v=w.complexTensorInfos.real,C=w.complexTensorInfos.imag,N=l.data.get(v.dataId).values,k=l.data.get(C.dataId).values,[E,_,R]=t(i.shape,o.shape,y,b,N,k),D=l.makeTensorInfo(R,"float32",E),F=l.makeTensorInfo(R,"float32",_),L=qs({inputs:{real:D,imag:F},backend:l});return l.disposeIntermediateTensorInfo(h),l.disposeIntermediateTensorInfo(x),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(F),L}else{const h=l.data.get(i.dataId).values,d=l.data.get(o.dataId).values,f=s||i.dtype,[m,y]=e(i.shape,o.shape,h,d,f);return l.makeTensorInfo(y,f,m)}}}function GE(n){return(e,t,s,r,a,i)=>{const o=Ze(e,t),l=he(o),h=o.length,d=Pe(o),f=zn("float32",l),m=zn("float32",l),y=Zl(e,o),b=Zl(t,o),x=_i(s,r),w=_i(a,i),v=e.length,C=Pe(e),N=t.length,k=Pe(t);if(y.length+b.length===0)for(let E=0;E<f.length;E++){const _=E%x.length,R=E%w.length,D=n(x[_*2],x[_*2+1],w[R*2],w[R*2+1]);f[E]=D.real,m[E]=D.imag}else for(let E=0;E<f.length;E++){const _=du(E,h,d),R=_.slice(-v);y.forEach(V=>R[V]=0);const D=fa(R,v,C),F=_.slice(-N);b.forEach(V=>F[V]=0);const L=fa(F,N,k),A=n(x[D*2],x[D*2+1],w[L*2],w[L*2+1]);f[E]=A.real,m[E]=A.imag}return[f,m,o]}}const T4=dn(((n,e)=>n+e)),Ohe=GE(((n,e,t,s)=>({real:n+t,imag:e+s}))),Kc=An(fu,T4,Ohe),Fhe={kernelName:fu,backendName:"cpu",kernelFunc:Kc};function HE(n,e,t,s,r){const a=he(s),i=Yn(r,t);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(a>0?i[l]+=e[o]:i[l]+=1)}return i}function C4(n,e,t,s=!1){const r=n.shape[0],a=n.shape[1],i=tt([r,t],e.dtype);for(let o=0;o<r;o++)for(let l=0;l<a;l++){const h=n.get(o,l);if(h<0)throw new Error("Input x must be non-negative!");h>=t||(s?i.set(1,o,h):e.size>0?i.set(i.get(o,h)+e.get(o,l),o,h):i.set(i.get(o,h)+1,o,h))}return i}const N4=dn(((n,e)=>n&e)),Lhe=An(Ip,N4),Mhe={kernelName:Ip,backendName:"cpu",kernelFunc:Lhe};function Ya(n){return(e,t,s)=>{const r=tn(t,e.length);for(let a=0;a<e.length;++a)r[a]=n(e[a],s);return r}}function Nt(n,e,t){const s=Ya(e);return Ko(n,s,t)}function Ko(n,e,t){return({inputs:s,attrs:r,backend:a})=>{const{x:i}=s;Oe(i,n);const o=a,l=o.data.get(i.dataId).values;let h;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");h=Ai(l)}else h=l;const d=t||i.dtype,f=e(h,d,r);return o.makeTensorInfo(i.shape,d,f)}}const k4=Ya(n=>Math.ceil(n)),zhe=Ko(lh,k4),Phe={kernelName:lh,backendName:"cpu",kernelFunc:zhe};function E4(n,e,t,s){const r=tn(t,he(e));if(s&&t!=="string"){let a=0;n.forEach(i=>{const o=he(i.shape);r.set(i.vals,a),a+=o})}else{let a=0;n.forEach(i=>{const o=t==="string"?Ai(i.vals):i.vals;let l=0;for(let h=0;h<i.shape[0];++h){const d=h*e[1]+a;for(let f=0;f<i.shape[1];++f)r[d+f]=o[l++]}a+=i.shape[1]})}return r}const $4=dn((n,e)=>n===e?1:0),I4=An(zp,$4,null,"bool"),Bhe={kernelName:zp,backendName:"cpu",kernelFunc:I4};const _4=Ya(n=>Math.exp(n)),A4=Ko(mh,_4,"float32"),Vhe={kernelName:mh,backendName:"cpu",kernelFunc:A4};const R4=Ya(n=>Math.expm1(n)),Uhe=Ko(gh,R4),jhe={kernelName:gh,backendName:"cpu",kernelFunc:Uhe};const D4=Ya(n=>Math.floor(n)),Whe=Ko(yh,D4),Ghe={kernelName:yh,backendName:"cpu",kernelFunc:Whe};const O4=dn((n,e)=>Math.floor(n/e)),Hhe=An(bh,O4,null,"int32"),qhe={kernelName:bh,backendName:"cpu",kernelFunc:Hhe};function F4(n,e,t,s,r,a,i,o,l){const h=tt([s,a],t);for(let d=0;d<s;d++){const f=[];let m=0;for(let y=0;y<r;y++){const b=n[d*r+y];m+=b*i[y],f.push(b)}if(m<0||m>=l/a)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let y=0;y<a;y++)h.values[d*a+y]=e.get(...e.indexToLoc(m*a+y))}return h}function L4(n,e,t){const s=tt(t,n.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),o=i[0],l=i[2],h=e.locToIndex([o,l]);i[2]=e.values[h];const d=n.locToIndex(i);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const M4=dn((n,e)=>n>e?1:0),Khe=An(Up,M4,null,"bool"),Xhe={kernelName:Up,backendName:"cpu",kernelFunc:Khe};const z4=dn((n,e)=>n>=e?1:0),Yhe=An(xh,z4,null,"bool"),Jhe={kernelName:xh,backendName:"cpu",kernelFunc:Yhe};const P4=dn((n,e)=>n<e?1:0),Zhe=An(Wp,P4,null,"bool"),Qhe={kernelName:Wp,backendName:"cpu",kernelFunc:Zhe};const B4=dn((n,e)=>n<=e?1:0),ede=An(Gp,B4,null,"bool"),tde={kernelName:Gp,backendName:"cpu",kernelFunc:ede};function V4(n,e,t){const s=(e-n)/(t-1),r=Yn(t,"float32");r[0]=n;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}const U4=Ya(n=>Math.log(n)),nde=Ko(Ch,U4),sde={kernelName:Ch,backendName:"cpu",kernelFunc:nde};function j4(n,e,t,s){const r=zn(s,he(t));for(let a=0;a<r.length;++a){const i=a*e;let o=n[i];for(let l=0;l<e;++l){const h=n[i+l];(Number.isNaN(h)||h>o)&&(o=h)}r[a]=o}return r}const W4=dn(((n,e)=>Math.max(n,e))),rde=An(kh,W4),ade={kernelName:kh,backendName:"cpu",kernelFunc:rde};const G4=dn(((n,e)=>Math.min(n,e))),ide=An(Eh,G4),ode={kernelName:Eh,backendName:"cpu",kernelFunc:ide};const qE=dn(((n,e)=>n*e)),lde=GE(((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t}))),Dw=An(Ih,qE,lde),ude={kernelName:Ih,backendName:"cpu",kernelFunc:Dw};function H4(n,e,t){const s=Oi(-1,t);return qE([],e,s,n,t)}function cde(n){const{inputs:e,backend:t}=n,{x:s}=e;Oe(s,"neg");const r=t.data.get(s.dataId).values,[a,i]=H4(r,s.shape,s.dtype);return t.makeTensorInfo(i,s.dtype,a)}const hde={kernelName:nm,backendName:"cpu",kernelFunc:cde};const q4=dn(((n,e)=>n!==e?1:0)),dde=An(sm,q4,null,"bool"),fde={kernelName:sm,backendName:"cpu",kernelFunc:dde};function KE(n,e,t,s,r){const a=e.length,i=he(e),o=Pe(e),l=Pe(r),h=zn(t,he(r));for(let d=0;d<i;++d){const f=du(d,a,o),m=new Array(f.length);for(let b=0;b<m.length;b++)m[b]=f[s[b]];const y=fa(m,a,l);h[y]=n[d]}return h}function Fs(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:a}=t;Oe(r,"transpose");const i=r.shape.length,o=new Array(i);for(let f=0;f<o.length;f++)o[f]=r.shape[a[f]];const l=s.data.get(r.dataId).values,h=KE(l,r.shape,r.dtype,a,o);return{dataId:s.write(h,o,r.dtype),shape:o,dtype:r.dtype}}const pde={kernelName:Ul,backendName:"cpu",kernelFunc:Fs};function K4(n,e,t,s){const[r,a]=Un(n,s),i=_s(e,"int32"),o=Yn(he(r),i),l=he(a);for(let h=0;h<o.length;++h){const d=h*l;let f=1;for(let m=0;m<l;++m)f*=t[d+m];o[h]=f}return{outVals:o,outShape:r,outDtype:i}}function mde(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s;Oe(r,"prod");const o=r.shape.length,l=at(a,r.shape),h=Zt(l,o);let d=l,f=r;const m=[];h!=null&&(f=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),m.push(f),d=cn(d.length,o));const y=t.data.get(f.dataId).values,{outVals:b,outShape:x,outDtype:w}=K4(f.shape,f.dtype,y,d);let v=x;return i&&(v=un(x,l)),m.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.makeTensorInfo(v,w,b)}const gde={kernelName:um,backendName:"cpu",kernelFunc:mde};function yde(n,e,t){n.forEach((s,r)=>{if(s<0||s>=t){const a=du(r,e.length,Pe(e)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${t})`)}})}function bde(n,e){for(let t=0;t<n.length;++t){const s=n[t],r=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}function xde(n,e,t,s){const r=[];let a=0;const i=e.length-1+t.length,o=new Array(i).fill(null).map(()=>[0]);bde(t,s);let l=1;for(let h=0;h<e.length-1;++h){l*=e[h];const d=e[h+1];for(let f=1;f<l+1;++f)o[h].push(f*d)}for(let h=0;h<n.length;++h){let d=n[h],f=n[h]+1;for(let m=0;m<t.length;++m){const y=t[m],b=m+e.length-1;if(b>=0){const x=o[b],w=x[x.length-1]-y[d];for(let v=d;v<f;++v)o[b].push(y[v+1]+w)}d=y[d],f=y[f]}f!==d&&(r.push([d,f]),a+=f-d)}return{outSplits:o,valueSlices:r,numValues:a}}function wde(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,r=tn("int32",s);e.push(r),n[t].forEach((a,i)=>r[i]=a)}return e}function v3(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function vde(n,e,t,s,r,a){const i=v3(e,2)[1],o=v3(a,2)[1];let l=0;for(const h of t)for(let d=h[0];d<h[1];++d){for(let f=0;f<s;++f)r[l*o+f]=n[d*i+f];++l}}function Sde(n,e,t,s,r){const a=e.slice();a[0]=r;const i=tn(t,he(a)),o=n.length,l=o===0?0:o/e[0];return vde(n,e,s,l,i,a),[i,a]}function X4(n,e,t,s,r,a,i,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(yde(a,i,l),s.length===0)throw new Error("params.rank must be nonzero");const h=s[0],{outSplits:d,valueSlices:f,numValues:m}=xde(a,i,n,h),y=wde(d),b=Sde(t,s,r,f,m);return[y,b[0],b[1]]}const S3=2147483647;function Y4(n,e,t,s,r,a,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=r.length===0,h=i.length===0,d=[];o||d.push(e[0]),l||d.push(r[0]),h||d.push(i[0]);for(let w=1;w<d.length;++w)if(d[w]!==d[w-1])throw new Error("starts, limits, and deltas must have the same shape");const f=d.length===0?1:d[0],m=tn("int32",f+1);m[0]=0;for(let w=0;w<f;++w){const v=o?n[0]:n[w],C=l?s[0]:s[w],N=h?a[0]:a[w];if(N===0)throw new Error("Requires delta != 0");let k;if(N>0&&C<v||N<0&&C>v)k=0;else if(k=Math.ceil(Math.abs((C-v)/N)),k>S3)throw new Error(`Requires ((limit - start) / delta) <= ${S3}`);m[w+1]=m[w]+k}const y=m[f],b=tn(t,y);let x=0;for(let w=0;w<f;++w){const v=m[w+1]-m[w];let C=o?n[0]:n[w];const N=h?a[0]:a[w];for(let k=0;k<v;++k)b[x++]=C,C+=N}return[m,b]}var zr=da;class X0{constructor(e,t,s,r,a,i,o,l,h,d){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=r,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=gP(d),this.raggedRank=yP(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===zr.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===zr.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case zr.VALUE_ROWIDS:return X0.getMaxWidthValueRowID(t);case zr.ROW_SPLITS:return X0.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${zr[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let r=0;r<t-1;++r){const a=e[r+1]-e[r];a>s&&(s=a)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,r=e[0],a=0;for(let i=1;i<t;++i){const o=e[i];o!==r&&(r=o,a=Math.max(i-s,a),s=i)}return Math.max(t-s,a)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return C3(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;bP(s,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=mP(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(e,t,s){const r=Math.min(e,s),a=[];let i=0;for(let o=0;o<r;++o,i+=t)a.push(i);for(let o=r;o<e;++o)a.push(-1);return O(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,s,r){const a=e.length,i=[];for(let o=0;o<a-1;++o){const l=e[o+1]-e[o];let h=Math.min(r,l),d=t[o];d===-1&&(h=0);for(let f=0;f<h;++f)i.push(d),d+=s;for(let f=0;f<l-h;++f)i.push(-1)}if(a>0&&i.length!==e[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,s,r){const a=e.length,i=[];if(a===0)return[];let o=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let h=t[l];i.push(h);for(let d=1;d<a;++d){const f=e[d];if(f===l)h>=0&&(++o,o<r?h+=s:h=-1);else{if(o=0,l=f,f>=t.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${t.length}`);h=t[f]}i.push(h)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,s,r){const a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case zr.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,s,r);case zr.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,s,r);default:throw new Error(`Unsupported partition type: ${zr[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case zr.FIRST_DIM_SIZE:return e[0];case zr.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zr.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${zr[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const a=C3(s,!1),i=tn(this.valuesDType,he(a));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,r[0],s[0]);for(let h=1;h<=this.raggedRank;++h)l=this.calculateOutputIndex(h-1,l,r[h],s[h]);this.setOutput(this.raggedRank,l,i,a)}return[a,i]}setOutput(e,t,s,r){if(s.length===0)return;const a=this.values,i=s;let o=r.slice();o=o.slice(e+1);const l=he(o),h=t.length;let d=this.defaultValue;if(d.length!==l&&d.length!==1){const b=this.defaultValueShape;re(()=>{const x=J(d,b);d=jl(x,o).dataSync()})}let f=0,m=0,y=0;for(let b=0;b<=h;++b){let x=b<h?t[b]:-1;if(x===y){++y;continue}if(m<y){const w=a.subarray(f*l),v=i.subarray(m*l),C=(y-m)*l;T3(v,w,C)}if(b>=h){const w=s.length;x=Math.floor(w/l)}if(x>y)if(this.defaultValue.length===1)i.subarray(y*l,x*l).fill(this.defaultValue[0]),y=x;else for(;x>y;){const w=i.slice(y*l);T3(w,d,l),++y}x<0?(f=b+1,m=y):(f=b,m=y,y=m+1)}}}function T3(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function C3(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function J4(n,e,t,s,r,a,i,o,l,h){return new X0(n,e,t,s,r,a,i,o,l,h).compute()}function Z4(n,e,t,s){const r=n===e,a=n<e&&t<0,i=e<n&&t>1;if(r||a||i)return Yn(0,s);const o=Math.abs(Math.ceil((e-n)/t)),l=Yn(o,s);e<n&&t===1&&(t=-1),l[0]=n;for(let h=1;h<l.length;h++)l[h]=l[h-1]+t;return l}const Q4=Ya(n=>1/Math.sqrt(n)),Tde=Ko(Fh,Q4),Cde={kernelName:Fh,backendName:"cpu",kernelFunc:Tde};function Ml(n,e,t,s,r,a,i,o,l,h){const d=[s/r,r],f=n.values,m=e.values;if(s===0)return tt(t,e.dtype);const y=l instanceof bn?l:tt(d,e.dtype);typeof l=="string"||typeof l=="number"?y.values.fill(l):typeof l=="boolean"&&y.values.fill(+l);for(let b=0;b<a;b++){const x=[];let w=0;for(let v=0;v<i;v++){const C=f[b*i+v];x.push(C),w+=C*o[v]}if(w<0||w>=s/r)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let v=0;v<r;v++)h?y.values[w*r+v]+=m[b*r+v]:y.values[w*r+v]=e.rank===0?m[0]:m[b*r+v]}return y}const Nde=Ya(n=>1/(1+Math.exp(-n))),eV=Nt(Bh,n=>1/(1+Math.exp(-n))),kde={kernelName:Bh,backendName:"cpu",kernelFunc:eV};function tV(n,e,t,s,r){const a=VN(s,e,t),i=he(t),o=Pe(s);if(a){const f=UN(e,o);return r==="string"?n.slice(f,f+i):n.subarray(f,f+i)}const l=r==="string"?Ai(n):n,h=tt(s,r,l),d=tt(t,r);for(let f=0;f<d.size;++f){const m=d.indexToLoc(f),y=m.map((b,x)=>b+e[x]);d.set(h.get(...y),...m)}return r==="string"?zP(d.values):d.values}function iu(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,size:i}=s;Oe(r,"slice");const[o,l]=lw(r,a,i);PN(r,o,l);const h=t.data.get(r.dataId).values,d=tV(h,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const Ede={kernelName:mm,backendName:"cpu",kernelFunc:iu};function nV(n,e,t,s,r,a,i){const o=e[0],l=a[0],h=new Array(l),d=new Array(o),f=e[1];if(l===0){if(o!==0)throw new Error(NP(o));const w=tn(t,0),v=tn(r,0);return[w,[0,f],v,h,d]}let m=!0,y=0;const b=new Array(l).fill(0);for(let w=0;w<o;++w){const v=n[w*f];if(v<0)throw new Error(kP(w,v));if(v>=l)throw new Error(EP(w,v,l));++b[v],m=m&&v>=y,y=v}let x=!0;for(let w=0;w<l;++w){const v=b[w]===0;h[w]=v,x=x&&!v,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(x&&m){const w=n,v=s;for(let C=0;C<o;++C)d[C]=C;return[w,[o,f],v,h,d]}else{const w=b[l-1],v=tn(t,w*f),C=tn(r,w),N=new Array(l).fill(0);for(let k=0;k<o;++k){const E=n[k*f],_=N[E],R=(E===0?0:b[E-1])+_;N[E]++;for(let D=0;D<f;++D)v[R*f+D]=n[k*f+D];C[R]=s[k],d[k]=R}for(let k=0;k<l;++k)if(N[k]===0){const _=k===0?0:b[k-1];v[_*f+0]=k;for(let R=1;R<f;++R)v[_*f+R]=0;C[_]=i}return[v,[w,f],C,h,d]}}function sV(n,e,t,s,r){const a=he(s),i=e[0],o=r.length,l=[];let h=1,d=-1;for(let w=0;w<o;++w){const v=r[w];if(v===-1){if(d!==-1)throw new Error($P(d,w));d=w,l.push(1)}else{if(v<0)throw new Error(IP(w,v));h*=v,l.push(v)}}if(d!==-1){if(h<=0)throw new Error(_P());const w=Math.trunc(a/h);if(h*w!==a)throw new Error(AP(s,l));l[d]=w}if(he(l)!==a)throw new Error(RP(s,l));const m=s.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*s[w+1]}const b=[];if(o>0){b[o-1]=1;for(let w=o-2;w>=0;--w)b[w]=b[w+1]*l[w+1]}const x=tn(t,i*o);for(let w=0;w<i;++w){let v=0;for(let C=0;C<m;++C)v+=n[w*m+C]*y[C];for(let C=0;C<o;++C)x[w*o+C]=Math.trunc(v/b[C]),v%=b[C]}return[x,[i,o],l]}function XE(n,e,t,s,r,a=!1,i=0){const o=s.length,l=[e[0],n.length/e[0]],h=l[1],f=o>0?r[o-1]+1:0;if(f<0)throw new Error(GT());const m=e.slice();m[0]=f;const y=m.reduce((N,k)=>N*k,1),b=tn(t,y);if(o===0)return f>0&&b.fill(i),[b,m];if(f<=0)throw new Error(GT());let x=0,w=1,v=0,C=r[x];for(;;){let N=0;if(w<o){if(N=r[w],C===N){++w;continue}if(C>=N)throw new Error(DP())}if(C<0||C>=f)throw new Error(OP(C,f));C>v&&b.fill(i,v*h,C*h);for(let k=x;k<w;++k){const E=s[k];if(E<0||E>=l[0])throw new Error(FP(k,s[k],l[0]));for(let _=0;_<h;_++)b[C*h+_]+=n[E*h+_]}if(a)for(let k=0;k<h;k++)b[C*h+k]/=w-x;if(x=w,++w,v=C+1,C=N,w>o)break}return v<f&&b.fill(i,v*h,f*h),[b,m]}const $de=Ya(n=>Math.sqrt(n)),Ide=Nt(Uh,n=>Math.sqrt(n)),_de={kernelName:Uh,backendName:"cpu",kernelFunc:Ide};const rV=dn(((n,e)=>{const t=n-e;return t*t})),Ade=An(jh,rV),Rde={kernelName:jh,backendName:"cpu",kernelFunc:Ade};const aV=Ya((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:r}=e;return n.replace(new RegExp(t,s?"g":""),r)}),Dde=Ko(wm,aV),Ode={kernelName:wm,backendName:"cpu",kernelFunc:Dde};function iV(n,e,t,s){const r=tt(n,e.dtype);for(let a=0;a<r.size;a++){const i=r.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*t[l]+s[l];r.set(e.get(...o),...i)}return r}class Fde{constructor(e,t,s,r,a,i){this.separator=Pa(e),this.nGramWidths=t,this.leftPad=Pa(s),this.rightPad=Pa(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,a,i){for(let o=0;o<a;++o){const l=this.getPadWidth(i),h=Math.max(0,l-o),d=Math.max(0,l-(a-(o+1))),f=i-(h+d),m=t+(h>0?0:o-l);let y=0;y+=h*this.leftPad.length;for(let C=0;C<f;++C)y+=e[m+C].length;y+=d*this.rightPad.length;const b=h+d+f-1;y+=b*this.separator.length,s[r+o]=new Uint8Array(y);const x=s[r+o];let w=0;const v=C=>C.forEach(N=>x[w++]=N);for(let C=0;C<h;++C)v(this.leftPad),v(this.separator);for(let C=0;C<f-1;++C)v(e[m+C]),v(this.separator);if(f>0){v(e[m+f-1]);for(let C=0;C<d;++C)v(this.separator),v(this.rightPad)}else{for(let C=0;C<d-1;++C)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let h=1;h<r;++h){let d=t[h]>=l;if(d=d&&t[h]<=s,!d)throw new Error(`Invalid split value ${t[h]}, must be in [${l}, ${s}]`);l=t[h]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const a=r-1,i=tn("int32",r);if(s===0||r===0){const l=new Array(s);for(let h=0;h<=a;++h)i[h]=0;return[l,i]}i[0]=0;for(let l=1;l<=a;++l){const h=t[l]-t[l-1];let d=0;this.nGramWidths.forEach(f=>{d+=this.getNumNGrams(h,f)}),this.preserveShort&&h>0&&d===0&&(d=1),i[l]=i[l-1]+d}const o=new Array(i[a]);for(let l=0;l<a;++l){const h=t[l];let d=i[l];if(this.nGramWidths.forEach(f=>{const m=t[l+1]-t[l],y=this.getNumNGrams(m,f);this.createNGrams(e,h,o,d,y,f),d+=y}),this.preserveShort&&d===i[l]){const f=t[l+1]-t[l];if(f===0)continue;const m=f+2*this.padWidth;this.createNGrams(e,h,o,d,1,m)}}return[o,i]}}function oV(n,e,t,s,r,a,i,o){return new Fde(t,s,r,a,i,o).compute(n,e)}function Lde(n,e,t,s){if(!n.length)return;if(e.length===0){for(let a=0;a<n.length;++a)s.push(n.subarray(a,a+1));return}if(e.length===1){const a=e[0];let i=n.indexOf(a);for(;i!==-1;){const o=n.subarray(0,i);(!t||o.length!==0)&&s.push(o),n=n.subarray(i+1),i=n.indexOf(a)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let a=0;a<n.length+1;a++)if(a===n.length||e.indexOf(n[a])!==-1){const i=n.subarray(r,a);(!t||i.length!==0)&&s.push(i),r=a+1}}function lV(n,e,t){const s=n.length,r=[];let a=0,i=0;const o=new Array(s);for(let m=0;m<s;++m){const y=r.length;Lde(n[m],e,t,r);const b=r.length-y;o[m]=b,a+=b,i=Math.max(i,b)}const l=tn("int32",a*2),h=new Array(a),d=[s,i];let f=0;for(let m=0;m<s;++m)for(let y=0;y<o[m];++y)l[f*2]=m,l[f*2+1]=y,h[f]=r[f],++f;return[l,h,d]}function uV(n,e){const t=tn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=wM(n[s]).modulo(e).getLowBitsUnsigned();return t}const cV=dn(((n,e)=>n-e)),Mde=GE(((n,e,t,s)=>({real:n-t,imag:e-s}))),YE=An(Wh,cV,Mde),zde={kernelName:Wh,backendName:"cpu",kernelFunc:YE};function hV(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=tt(t,n.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),i=new Array(n.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%n.shape[l];const o=n.locToIndex(i);s.values[r]=n.values[o]}return s}const Cf=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function dV(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,l=e-t+1,h=Math.log(o),d=.5*Math.exp(2*h/3),f=.5*Math.sqrt(h*d*(o-d)/o)*Math.sign(l-o/2),m=Math.max(t,Math.floor(e-l*d/o+f)),y=Math.min(s,Math.floor(e+(o-l)*d/o+f));dV(n,e,m,y)}const r=n[e];let a=t,i=s;for(wi(n,t,e),Cf(n[s],r)>0&&wi(n,t,s);a<i;){for(wi(n,a,i),a++,i--;Cf(n[a],r)<0;)a=a+1;for(;Cf(n[i],r)>0;)i=i-1}Cf(n[t],r)===0?wi(n,t,i):(i=i+1,wi(n,i,s)),i<=e&&(t=i+1),e<=i&&(s=i-1)}}function fV(n,e,t,s,r){const a=e[e.length-1],[i,o]=[n.length/a,a],l=zn(t,i*s),h=zn("int32",i*s);for(let f=0;f<i;f++){const m=f*o,y=n.subarray(m,m+o);let b=new Array(y.length);y.forEach((C,N)=>b[N]={value:C,index:N}),s<b.length&&(dV(b,s),b=b.slice(0,s)),r&&b.sort(Cf);const x=f*s,w=l.subarray(x,x+s),v=h.subarray(x,x+s);for(let C=0;C<s;C++)w[C]=b[C].value,v[C]=b[C].index}const d=e.slice();return d[d.length-1]=s,[tt(d,t,l),tt(d,"int32",h)]}function pV(n,e,t,s){const r=at(e,t)[0],a=[1,t[0],1];for(let b=0;b<r;b++)a[0]*=t[b];a[1]=t[r];for(let b=r+1;b<t.length;b++)a[2]*=t[b];const i=new Map,o=new Int32Array(t[r]),l=new bn(a,s,n),h=[],d=a[0]===1&&a[2]===1;for(let b=0;b<t[r];b++){let x;if(d)x=n[b].toString();else{const v=[];for(let C=0;C<a[0];C++)for(let N=0;N<a[2];N++)v.push(l.get(C,b,N));x=v.join(",")}const w=i.get(x);if(w!=null)o[b]=w;else{const v=i.size;i.set(x,v),o[b]=v,h.push(b)}}const f=a.slice();f[1]=i.size;const m=new bn(f,s);h.forEach((b,x)=>{for(let w=0;w<a[0];w++)for(let v=0;v<a[2];v++)m.set(l.get(w,b,v),w,x,v)});const y=t.slice();return y[r]=f[1],{outputValues:m.values,outputShape:y,indices:o}}const mV=Object.freeze(Object.defineProperty({__proto__:null,addImpl:T4,bincountImpl:HE,bincountReduceImpl:C4,bitwiseAndImpl:N4,castImpl:S4,ceilImpl:k4,concatImpl:E4,equalImpl:$4,expImpl:_4,expm1Impl:R4,floorDivImpl:O4,floorImpl:D4,gatherNdImpl:F4,gatherV2Impl:L4,greaterEqualImpl:z4,greaterImpl:M4,lessEqualImpl:B4,lessImpl:P4,linSpaceImpl:V4,logImpl:U4,maxImpl:j4,maximumImpl:W4,minimumImpl:G4,multiplyImpl:qE,negImpl:H4,notEqualImpl:q4,prodImpl:K4,raggedGatherImpl:X4,raggedRangeImpl:Y4,raggedTensorToTensorImpl:J4,rangeImpl:Z4,rsqrtImpl:Q4,scatterImpl:Ml,sigmoidImpl:Nde,simpleAbsImpl:v4,sliceImpl:tV,sparseFillEmptyRowsImpl:nV,sparseReshapeImpl:sV,sparseSegmentReductionImpl:XE,sqrtImpl:$de,squaredDifferenceImpl:rV,staticRegexReplaceImpl:aV,stridedSliceImpl:iV,stringNGramsImpl:oV,stringSplitImpl:lV,stringToHashBucketFastImpl:uV,subImpl:cV,tileImpl:hV,topKImpl:fV,transposeImpl:KE,uniqueImpl:pV},Symbol.toStringTag,{value:"Module"}));const gV="4.22.0";w2("cpu",()=>new ng,1);const yV=Nt(fh,n=>n>=0?n:Math.exp(n)-1),Pde={kernelName:fh,backendName:"cpu",kernelFunc:yV};function bV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:a}=s;Oe([r],"leakyRelu");const i=he(r.shape),o=t.data.get(r.dataId).values,l=zn("float32",i);for(let h=0;h<o.length;h++)l[h]=o[h]<0?a*o[h]:o[h];return t.makeTensorInfo(r.shape,"float32",l)}const Bde={kernelName:jp,backendName:"cpu",kernelFunc:bV};const Vde=dn((n,e)=>n<0?e*n:n);function xV(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;Oe([s,r],"prelu");const a=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,[o,l]=Vde(s.shape,r.shape,a,i,"float32");return t.makeTensorInfo(l,"float32",o)}const Ude={kernelName:lm,backendName:"cpu",kernelFunc:xV};const wV=Nt(Rh,n=>Math.max(0,n)),jde={kernelName:Rh,backendName:"cpu",kernelFunc:wV};const vV=Nt(Dh,n=>Math.min(Math.max(0,n),6)),Wde={kernelName:Dh,backendName:"cpu",kernelFunc:vV};function Y0(n,e,t,s,r){if(t==="linear")return Ka({inputs:{x:e},backend:n});if(t==="relu")return wV({inputs:{x:e},backend:n});if(t==="elu")return yV({inputs:{x:e},backend:n});if(t==="relu6")return vV({inputs:{x:e},backend:n});if(t==="prelu")return xV({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return bV({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return eV({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function zt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:a}=s,i=he(r.shape),o=h2(a,i),l=he(o);O(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const h=t.data.get(r.dataId);if(h.complexTensorInfos!=null){const d=h.complexTensorInfos.real,f=h.complexTensorInfos.imag;d.shape=o,f.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const Gde={kernelName:cm,backendName:"cpu",kernelFunc:zt};function SV(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a}=e,{transposeA:i,transposeB:o}=s;Oe([r,a],"matMul");const l=r.shape.length,h=a.shape.length,d=i?r.shape[l-2]:r.shape[l-1],f=o?a.shape[h-1]:a.shape[h-2],m=i?r.shape[l-1]:r.shape[l-2],y=o?a.shape[h-2]:a.shape[h-1],b=r.shape.slice(0,-2),x=a.shape.slice(0,-2),w=he(b),v=he(x),N=Ze(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([m,y]);O(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const k=i?[w,d,m]:[w,m,d],E=o?[v,y,f]:[v,f,y],_=zt({inputs:{x:r},backend:t,attrs:{shape:k}}),R=zt({inputs:{x:a},backend:t,attrs:{shape:E}}),D=i?_.shape[1]:_.shape[2],F=i?_.shape[2]:_.shape[1],L=o?R.shape[1]:R.shape[2],A=Math.max(w,v),V=t.data.get(_.dataId).values,q=t.data.get(R.dataId).values,ne=Pe(_.shape),Q=Pe(R.shape),[B,U,X]=i?[ne[0],1,ne[1]]:[ne[0],ne[1],1],[K,se,P]=o?[1,Q[1],Q[0]]:[Q[1],1,Q[0]],j=F*L,te=tt([A,F,L],_.dtype),oe=te.values,pe=t.blockSize;for(let xe=0;xe<A;xe++){const Te=xe%w,_e=xe%v;for(let $e=0;$e<F;$e+=pe){const Ue=Math.min($e+pe,F);for(let Se=0;Se<L;Se+=pe){const je=Math.min(Se+pe,L);for(let Ye=0;Ye<D;Ye+=pe){const Ke=Math.min(Ye+pe,D);for(let ot=$e;ot<Ue;ot++)for(let gt=Se;gt<je;gt++){let Pt=0;for(let _t=Ye;_t<Ke;_t++){const nr=V[Te*B+ot*U+_t*X],nn=q[_t*K+gt*se+_e*P];Pt+=nr*nn}oe[xe*j+(ot*L+gt)]+=Pt}}}}}return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(N,te.dtype,te.values)}const Hde={kernelName:Ep,backendName:"cpu",kernelFunc:SV};function qde(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:h,activation:d,leakyreluAlpha:f}=s;let m,y,b;const x=[];m=SV({inputs:{a:r,b:a},attrs:{transposeA:l,transposeB:h},backend:t}),i&&(y=Kc({inputs:{a:m,b:i},backend:t}),x.push(m),m=y),d&&(b=Y0(t,m,d,o,f),x.push(m),m=b);for(const v of x)t.disposeIntermediateTensorInfo(v);return m}const Kde={kernelName:Jf,backendName:"cpu",kernelFunc:qde};const Xde=Nt(eh,n=>Math.acos(n)),Yde={kernelName:eh,backendName:"cpu",kernelFunc:Xde};const Jde=Nt(th,n=>Math.acosh(n)),Zde={kernelName:th,backendName:"cpu",kernelFunc:Jde};function Qde(n){const{inputs:e,backend:t}=n,s=e;Oe(e,"addN");const r=s.map(o=>t.data.get(o.dataId).values),a=tt(s[0].shape,s[0].dtype),i=a.values;for(let o=0;o<s.length;o++){const l=r[o];for(let h=0;h<i.length;h++)i[h]+=l[h]}return t.makeTensorInfo(a.shape,a.dtype,a.values)}const efe={kernelName:Sp,backendName:"cpu",kernelFunc:Qde};function tfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s;Oe(r,"all");const o=at(a,r.shape);let l=o;const h=Zt(l,r.shape.length);let d=r;h!=null&&(d=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),l=cn(l.length,r.shape.length)),Qn("all",l,d.shape.length);const[f,m]=Un(d.shape,l),y=he(m),b=Yn(he(f),d.dtype),x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const C=v*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];N=N&&E}b[v]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(f,d.dtype,b);if(i){const v=un(f,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(w),C}return w}const nfe={kernelName:gb,backendName:"cpu",kernelFunc:tfe};function sfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s;Oe(r,"any");const o=at(a,r.shape);let l=o;const h=Zt(l,r.shape.length);let d=r;h!=null&&(d=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),l=cn(l.length,r.shape.length)),Qn("any",l,d.shape.length);const[f,m]=Un(d.shape,l),y=he(m),b=Yn(he(f),d.dtype),x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const C=v*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];N=N||E}b[v]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(f,d.dtype,b);if(i){const v=un(f,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(w),C}return w}const rfe={kernelName:yb,backendName:"cpu",kernelFunc:sfe};function afe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;Oe(r,"argMax");let i=at(a,r.shape);const o=Zt(i,r.shape.length);let l=r;const h=[];o!=null&&(l=Fs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),i=cn(i.length,l.shape.length)),i=[i[0]],Qn("argMax",i,l.shape.length);const[d,f]=Un(l.shape,i),m=he(d),y=Yn(m,"int32"),b=he(f),x=t.data.get(l.dataId).values;for(let w=0;w<y.length;++w){const v=w*b;let C=x[v],N=0;for(let k=0;k<b;++k){const E=x[v+k];E>C&&(C=E,N=k)}y[w]=N}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const ife={kernelName:Tp,backendName:"cpu",kernelFunc:afe};function ofe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;Oe(r,"argMin");let i=at(a,r.shape);const o=Zt(i,r.shape.length);let l=r;const h=[];o!=null&&(l=Fs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),i=cn(i.length,l.shape.length)),i=[i[0]],Qn("argMin",i,l.shape.length);const[d,f]=Un(l.shape,i),m=he(d),y=Yn(m,"int32"),b=he(f),x=t.data.get(l.dataId).values;for(let w=0;w<y.length;++w){const v=w*b;let C=x[v],N=0;for(let k=0;k<b;++k){const E=x[v+k];E<C&&(C=E,N=k)}y[w]=N}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(d,"int32",y)}const lfe={kernelName:Cp,backendName:"cpu",kernelFunc:ofe};const ufe=Nt(nh,n=>Math.asin(n)),cfe={kernelName:nh,backendName:"cpu",kernelFunc:ufe};const hfe=Nt(sh,n=>Math.asinh(n)),dfe={kernelName:sh,backendName:"cpu",kernelFunc:hfe};const ffe=Nt(rh,n=>Math.atan(n)),pfe={kernelName:rh,backendName:"cpu",kernelFunc:ffe};const mfe=dn((n,e)=>Math.atan2(n,e)),gfe=An(ih,mfe),yfe={kernelName:ih,backendName:"cpu",kernelFunc:gfe};const bfe=Nt(ah,n=>Math.atanh(n)),xfe={kernelName:ah,backendName:"cpu",kernelFunc:bfe};function JE(n,e,t,s,r,a){const i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=tt(r.outShape,t),w=x.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],C=r.outShape[2]*r.outShape[3],N=r.outShape[3];for(let k=0;k<r.batchSize;++k){const E=k*v,_=k*s[0];for(let R=0;R<r.inChannels;++R)for(let D=0;D<r.outHeight;++D){const F=D*i-m,L=Math.max(0,F),A=Math.min(r.inHeight,d+F),V=E+D*C;for(let q=0;q<r.outWidth;++q){const ne=q*o-y,Q=Math.max(0,ne),B=Math.min(r.inWidth,f+ne);let U=b,X=0,K=0;for(let P=L;P<A;P+=l){const j=_+P*s[1];for(let te=Q;te<B;te+=h){const oe=j+te*s[2],pe=n[oe+R];a==="max"&&pe>U?U=pe:a==="avg"&&(X+=pe,K++)}if(isNaN(U))break}const se=V+q*N+R;w[se]=a==="avg"?X/K:U}}}return x}function TV(n,e,t,s,r=!1,a=!1){const i=tt(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,h=s.dilationHeight,d=s.dilationWidth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,y=s.padInfo.top,b=s.padInfo.left,x=tt(e,t,n);for(let w=0;w<s.batchSize;++w)for(let v=0;v<s.inChannels;++v)for(let C=0;C<s.outHeight;++C){const N=C*o-y;let k=N;for(;k<0;)k+=h;const E=Math.min(s.inHeight,f+N);for(let _=0;_<s.outWidth;++_){const R=_*l-b;let D=R;for(;D<0;)D+=d;const F=Math.min(s.inWidth,m+R);let L=Number.NEGATIVE_INFINITY,A=-1;for(let V=k;V<E;V+=h){const q=V-N;for(let ne=D;ne<F;ne+=d){const Q=ne-R,B=x.get(w,V,ne,v);B>L&&(L=B,r?A=a?((w*s.inHeight+V)*s.inWidth+ne)*s.inChannels+v:(V*s.inWidth+ne)*s.inChannels+v:A=q*m+Q)}}i.set(A,w,C,_,v)}}return i}function CV(n,e,t,s,r,a){const i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,h=r.dilationDepth,d=r.dilationHeight,f=r.dilationWidth,m=r.effectiveFilterDepth,y=r.effectiveFilterHeight,b=r.effectiveFilterWidth,x=r.padInfo.front,w=r.padInfo.top,v=r.padInfo.left,C=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=tt(r.outShape,t),k=N.values,E=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[3]*r.outShape[4],D=r.outShape[4];for(let F=0;F<r.batchSize;++F){const L=F*E,A=F*s[0];for(let V=0;V<r.inChannels;++V)for(let q=0;q<r.outDepth;++q){const ne=q*i-x;let Q=ne;for(;Q<0;)Q+=h;const B=Math.min(r.inDepth,m+ne),U=L+q*_;for(let X=0;X<r.outHeight;++X){const K=X*o-w;let se=K;for(;se<0;)se+=d;const P=Math.min(r.inHeight,y+K),j=U+X*R;for(let te=0;te<r.outWidth;++te){const oe=te*l-v;let pe=oe;for(;pe<0;)pe+=f;const xe=Math.min(r.inWidth,b+oe),Te=j+te*D;let _e=C,$e=0,Ue=0;for(let je=Q;je<B;je+=h){const Ye=A+je*s[1];for(let Ke=se;Ke<P;Ke+=d){const ot=Ye+Ke*s[2];for(let gt=pe;gt<xe;gt+=f){const Pt=ot+gt*s[3],_t=n[Pt+V];if(a==="max"&&_t>_e?_e=_t:a==="avg"&&($e+=_t,Ue++),isNaN(_e))break}if(isNaN(_e))break}if(isNaN(_e))break}const Se=Te+V;k[Se]=a==="avg"?$e/Math.max(Ue,1):_e}}}}return N}function wfe(n,e){const t=tt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,a=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let w=0;w<e.inChannels;++w)for(let v=0;v<e.outDepth;++v){const C=v*s-m;let N=C;for(;N<0;)N+=i;const k=Math.min(e.inDepth,h+C);for(let E=0;E<e.outHeight;++E){const _=E*r-y;let R=_;for(;R<0;)R+=o;const D=Math.min(e.inHeight,d+_);for(let F=0;F<e.outWidth;++F){const L=F*a-b;let A=L;for(;A<0;)A+=l;const V=Math.min(e.inWidth,f+L);let q=Number.NEGATIVE_INFINITY,ne=-1;for(let Q=N;Q<k;Q+=i){const B=Q-C;for(let U=R;U<D;U+=o){const X=U-_;for(let K=A;K<V;K+=l){const se=K-L,P=n.get(x,Q,U,K,w);P>=q&&(q=P,ne=B*d*f+X*d+se)}}}t.set(ne,x,v,E,F,w)}}}return t}function vfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Oe(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(i,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Kr(r.shape,a,i,h,o,l);let f;if(d.filterWidth===1&&d.filterHeight===1&&lt(d.inShape,d.outShape))f=Ka({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=Pe(r.shape),b=JE(m,r.shape,r.dtype,y,d,"avg");f=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return f}const Sfe={kernelName:Np,backendName:"cpu",kernelFunc:vfe};function Tfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:h}=s;Oe(r,"avgPool3d");const d=Fi(r.shape,a,i,1,o,l,h),f=t.data.get(r.dataId).values,m=CV(f,r.shape,r.dtype,Pe(r.shape),d,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}const Cfe={kernelName:kp,backendName:"cpu",kernelFunc:Tfe};function Nfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:h}=s;Oe([r,a],"avgPool3DGrad");const d=Fi(a.shape,i,o,1,l,h),f=d.strideDepth,m=d.strideHeight,y=d.strideWidth,b=d.filterDepth,x=d.filterHeight,w=d.filterWidth,v=d.dilationDepth,C=d.dilationHeight,N=d.dilationWidth,k=d.effectiveFilterDepth,E=d.effectiveFilterHeight,_=d.effectiveFilterWidth,R=k-1-d.padInfo.front,D=_-1-d.padInfo.left,F=E-1-d.padInfo.top,L=tt(a.shape,"float32"),A=1/(b*x*w),V=t.bufferSync(r);for(let q=0;q<d.batchSize;++q)for(let ne=0;ne<d.inChannels;++ne)for(let Q=0;Q<d.inDepth;++Q)for(let B=0;B<d.inHeight;++B)for(let U=0;U<d.inWidth;++U){const X=Q-R,K=B-F,se=U-D;let P=0;for(let j=0;j<k;j+=v){const te=(X+j)/f;if(!(te<0||te>=d.outDepth||Math.floor(te)!==te))for(let oe=0;oe<E;oe+=C){const pe=(K+oe)/m;if(!(pe<0||pe>=d.outHeight||Math.floor(pe)!==pe))for(let xe=0;xe<_;xe+=N){const Te=(se+xe)/y;if(Te<0||Te>=d.outWidth||Math.floor(Te)!==Te)continue;const _e=V.get(q,te,pe,Te,ne);P+=_e}}}L.set(P*A,q,Q,B,U,ne)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}const kfe={kernelName:xb,backendName:"cpu",kernelFunc:Nfe};function Efe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,i=a;Oe([r,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:h}=s,d=Kr(i.shape,o,l,1,h),f=d.strideHeight,m=d.strideWidth,y=d.filterHeight,b=d.filterWidth,x=d.dilationHeight,w=d.dilationWidth,v=d.effectiveFilterHeight,C=d.effectiveFilterWidth,N=C-1-d.padInfo.left,k=v-1-d.padInfo.top,E=tt(i.shape,"float32"),_=1/(y*b),R=t.data.get(r.dataId).values,D=tt(r.shape,"float32",R);for(let F=0;F<d.batchSize;++F)for(let L=0;L<d.inChannels;++L)for(let A=0;A<d.inHeight;++A)for(let V=0;V<d.inWidth;++V){const q=A-k,ne=V-N;let Q=0;for(let B=0;B<v;B+=x){const U=(q+B)/f;if(!(U<0||U>=d.outHeight||Math.floor(U)!==U))for(let X=0;X<C;X+=w){const K=(ne+X)/m;if(K<0||K>=d.outWidth||Math.floor(K)!==K)continue;const se=D.get(F,U,K,L);Q+=se}}E.set(Q*_,F,A,V,L)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const $fe={kernelName:bb,backendName:"cpu",kernelFunc:Efe};function Ife(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:a,offset:i,mean:o,variance:l}=e;O(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Oe([r,o,l,a,i],"batchNorm");let{varianceEpsilon:h}=s;h==null&&(h=.001);const d=t.data.get(r.dataId).values,f=t.data.get(o.dataId).values,m=t.data.get(l.dataId).values,y=a?t.data.get(a.dataId).values:new Float32Array([1]),b=i?t.data.get(i.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),w=b.length,v=y.length,C=m.length,N=f.length;let k=0,E=0,_=0,R=0;for(let D=0;D<d.length;++D)x[D]=b[k++]+(d[D]-f[E++])*y[_++]/Math.sqrt(m[R++]+h),k>=w&&(k=0),E>=N&&(E=0),_>=v&&(_=0),R>=C&&(R=0);return t.makeTensorInfo(r.shape,r.dtype,x)}const _fe={kernelName:Bp,backendName:"cpu",kernelFunc:Ife};function Afe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,crops:i}=s;Oe([r],"batchToSpaceND");const o=a.reduce((v,C)=>v*C),l=Wm(r.shape,a,o),h=Gm(l.length,a.length),d=Hm(r.shape,a,o),f=KN(i,a.length),m=XN(d,i,a.length),y=zt({inputs:{x:r},backend:t,attrs:{shape:l}}),b=Fs({inputs:{x:y},backend:t,attrs:{perm:h}}),x=zt({inputs:{x:b},backend:t,attrs:{shape:d}}),w=iu({inputs:{x},backend:t,attrs:{begin:f,size:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const Rfe={kernelName:$p,backendName:"cpu",kernelFunc:Afe};function Dfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:i}=s,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,h=HE(o,l,a.dtype,a.shape,i);return t.makeTensorInfo([i],a.dtype,h)}const Ofe={kernelName:wb,backendName:"cpu",kernelFunc:Dfe};function Ffe(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,a=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,o=Ze(Array.from(a),Array.from(i));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Lfe={kernelName:vb,backendName:"cpu",kernelFunc:Ffe};const Mfe=Nt(uh,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),zfe={kernelName:uh,backendName:"cpu",kernelFunc:Mfe};const Pfe=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(he(e.shape)),r=t.data.get(e.dataId),a=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=t.data.get(a.dataId).values,l=t.data.get(i.dataId).values;for(let h=0;h<o.length;h++){const d=o[h],f=l[h];s[h]=Math.hypot(d,f)}return t.makeOutput(s,e.shape,"float32")},Bfe={kernelName:_p,backendName:"cpu",kernelFunc:Pfe};function Xc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,a=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,a)}const Vfe={kernelName:Vb,backendName:"cpu",kernelFunc:Xc};function Yc(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,a=at(r,e[0].shape)[0],i=e.map(x=>x.shape);GN(i,a);let o=Va(e.map(x=>x.shape),a);if(he(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(x=>he(x.shape)>0);if(l.length===1)return Ka({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const x=l.map(k=>au({inputs:{input:k},backend:t})),w=l.map(k=>Xc({inputs:{input:k},backend:t})),v=Yc({inputs:x,backend:t,attrs:{axis:a}}),C=Yc({inputs:w,backend:t,attrs:{axis:a}}),N=qs({inputs:{real:v,imag:C},backend:t});return x.forEach(k=>t.disposeIntermediateTensorInfo(k)),w.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(C),N}const h=l.map(x=>{const v=[-1,he(x.shape.slice(a))];return zt({inputs:{x},backend:t,attrs:{shape:v}})}),d=h.map(x=>({vals:t.data.get(x.dataId).values,shape:x.shape}));o=Va(h.map(x=>x.shape),1);const f=h[0].shape[0]===1,m=E4(d,o,e[0].dtype,f),y=Va(l.map(x=>x.shape),a),b=t.makeTensorInfo(y,e[0].dtype,m);return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const Ufe={kernelName:Ap,backendName:"cpu",kernelFunc:Yc};function NV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:h,dimRoundingMode:d}=s;Oe([r,a],"conv2d");const f=Li(l),m=Vn(r.shape,a.shape,i,h,o,d,!1,f),y=m.filterHeight,b=m.filterWidth,x=m.dilationHeight,w=m.dilationWidth,v=m.padInfo.left,C=m.padInfo.top,N=m.dataFormat==="channelsLast",k=new bn(m.outShape,r.dtype),E=Pe(r.shape),_=Pe(a.shape),R=E[0],D=N?E[1]:E[2],F=N?E[2]:1,L=N?1:E[1],A=k.strides[0],V=N?k.strides[1]:k.strides[2],q=N?k.strides[2]:1,ne=N?1:k.strides[1],Q=t.data.get(r.dataId).values,B=t.data.get(a.dataId).values,U=k.values;for(let X=0;X<m.batchSize;++X){const K=X*R,se=X*A;for(let P=0;P<m.outHeight;++P){const j=se+P*V,te=P*m.strideHeight-C;for(let oe=0;oe<y;++oe){const pe=te+oe*x;if(pe<0||pe>=m.inHeight)continue;const xe=oe*_[0],Te=K+pe*D;for(let _e=0;_e<m.outWidth;++_e){const $e=j+_e*q,Ue=_e*m.strideWidth-v;for(let Se=0;Se<b;++Se){const je=Ue+Se*w;if(je<0||je>=m.inWidth)continue;const Ye=xe+Se*_[1],Ke=Te+je*F;let ot=Ye;for(let gt=0;gt<m.inChannels;++gt){const Pt=Q[Ke+gt*L];for(let _t=0;_t<m.outChannels;++_t)U[$e+_t*ne]+=Pt*B[ot+_t];ot+=m.outChannels}}}}}}return t.makeTensorInfo(k.shape,k.dtype,U)}const jfe={kernelName:Rp,backendName:"cpu",kernelFunc:NV};function Wfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:h,filterShape:d}=s;Oe([r,a],"conv2dBackpropFilter");const f=Li(l),m=Vn(r.shape,d,i,1,o,h,!1,f),{strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:w}=m,v=m.dataFormat==="channelsLast",C=new bn(m.filterShape,"float32"),N=m.padInfo.left,k=m.padInfo.top,E=t.data.get(r.dataId).values,_=t.data.get(a.dataId).values,R=new bn(r.shape,r.dtype,E),D=new bn(a.shape,a.dtype,_);for(let F=0;F<x;++F){const L=Math.max(0,Math.ceil((k-F)/y)),A=Math.min(m.outHeight,(m.inHeight+k-F)/y);for(let V=0;V<w;++V){const q=Math.max(0,Math.ceil((N-V)/b)),ne=Math.min(m.outWidth,(m.inWidth+N-V)/b);for(let Q=0;Q<m.inChannels;++Q)for(let B=0;B<m.outChannels;++B){let U=0;for(let X=0;X<m.batchSize;++X)for(let K=L;K<A;++K){const se=F+K*y-k;for(let P=q;P<ne;++P){const j=V+P*b-N;v?U+=R.get(X,se,j,Q)*D.get(X,K,P,B):U+=R.get(X,Q,se,j)*D.get(X,B,K,P)}}C.set(U,F,V,Q,B)}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Gfe={kernelName:Tb,backendName:"cpu",kernelFunc:Wfe};function Hfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:h,dimRoundingMode:d}=s;Oe([r,a],"conv2dBackpropInput");const f=Pe(a.shape),m=Pe(r.shape);let y=Li(h);const b=Vn(i,a.shape,o,1,l,d,!1,y),x=new bn(b.inShape,"float32"),w=x.values,v=t.data.get(r.dataId).values,C=t.data.get(a.dataId).values,[N,k,E]=f,{batchSize:_,filterHeight:R,filterWidth:D,inChannels:F,inHeight:L,inWidth:A,outChannels:V,outHeight:q,outWidth:ne,strideHeight:Q,strideWidth:B}=b;y=b.dataFormat;const U=R-1-b.padInfo.top,X=D-1-b.padInfo.left,K=y==="channelsLast",se=x.strides[0],P=K?x.strides[1]:x.strides[2],j=K?x.strides[2]:1,te=K?1:x.strides[1],oe=m[0],pe=K?m[1]:m[2],xe=K?m[2]:1,Te=K?1:m[1];for(let _e=0;_e<_;++_e)for(let $e=0;$e<F;++$e)for(let Ue=0;Ue<L;++Ue){const Se=Ue-U,je=Math.max(0,Math.ceil(Se/Q)),Ye=Math.min(q,(R+Se)/Q);for(let Ke=0;Ke<A;++Ke){const ot=Ke-X,gt=Math.max(0,Math.ceil(ot/B)),Pt=Math.min(ne,(D+ot)/B);let _t=0;for(let nn=je;nn<Ye;++nn){const kr=nn*Q-Se;for(let Ts=gt;Ts<Pt;++Ts){const Ja=Ts*B-ot,Vt=oe*_e+pe*nn+xe*Ts,Jr=N*(R-1-kr)+k*(D-1-Ja)+E*$e;for(let Zr=0;Zr<V;++Zr){const Qr=v[Vt+Te*Zr],sr=C[Jr+Zr];_t+=Qr*sr}}}const nr=se*_e+P*Ue+j*Ke+te*$e;w[nr]=_t}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const qfe={kernelName:Dp,backendName:"cpu",kernelFunc:Hfe};function Kfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l}=s;Oe([r,a],"conv3d");const h=Uo(r.shape,a.shape,i,l,o),{filterDepth:d,filterHeight:f,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:x,padInfo:w}=h,v=w.front,C=w.left,N=w.top,k=new bn(h.outShape,r.dtype),E=t.data.get(r.dataId).values,_=t.data.get(a.dataId).values,R=k.values,D=Pe(r.shape),F=Pe(a.shape);for(let L=0;L<h.batchSize;++L){const A=L*D[0],V=L*k.strides[0];for(let q=0;q<h.outDepth;++q){const ne=V+q*k.strides[1],Q=q*h.strideDepth-v;for(let B=0;B<d;++B){const U=Q+B*y;if(U<0||U>=h.inDepth)continue;const X=B*F[0],K=A+U*D[1];for(let se=0;se<h.outHeight;++se){const P=ne+se*k.strides[2],j=se*h.strideHeight-N;for(let te=0;te<f;++te){const oe=j+te*b;if(oe<0||oe>=h.inHeight)continue;const pe=X+te*F[1],xe=K+oe*D[2];for(let Te=0;Te<h.outWidth;++Te){const _e=P+Te*h.outChannels,$e=Te*h.strideWidth-C;for(let Ue=0;Ue<m;++Ue){const Se=$e+Ue*x;if(Se<0||Se>=h.inWidth)continue;const je=pe+Ue*F[2],Ye=xe+Se*h.inChannels;let Ke=je;for(let ot=0;ot<h.inChannels;++ot){const gt=E[Ye+ot];for(let Pt=0;Pt<h.outChannels;++Pt)R[_e+Pt]+=gt*_[Ke+Pt];Ke+=h.outChannels}}}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const Xfe={kernelName:Op,backendName:"cpu",kernelFunc:Kfe};function Yfe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:i,pad:o,filterShape:l}=s;Oe([r,a],"conv3dBackpropFilterV2");const h=Pe(r.shape),d=Pe(a.shape),f=Uo(r.shape,l,i,1,o),m=f.strideDepth,y=f.strideHeight,b=f.strideWidth,x=f.filterDepth,w=f.filterHeight,v=f.filterWidth,C=new bn(f.filterShape,"float32"),N=C.values,[k,E,_,R]=C.strides,D=t.data.get(a.dataId).values,[F,L,A,V]=d,q=t.data.get(r.dataId).values,[ne,Q,B,U]=h,X=f.padInfo.front,K=f.padInfo.left,se=f.padInfo.top;for(let P=0;P<x;++P){const j=Math.max(0,Math.ceil((X-P)/m)),te=Math.min(f.outDepth,(f.inDepth+X-P)/m),oe=P*k;for(let pe=0;pe<w;++pe){const xe=Math.max(0,Math.ceil((se-pe)/y)),Te=Math.min(f.outHeight,(f.inHeight+se-pe)/y),_e=pe*E+oe;for(let $e=0;$e<v;++$e){const Ue=Math.max(0,Math.ceil((K-$e)/b)),Se=Math.min(f.outWidth,(f.inWidth+K-$e)/b),je=$e*_+_e;for(let Ye=0;Ye<f.inChannels;++Ye){const Ke=Ye*R+je;for(let ot=0;ot<f.outChannels;++ot){let gt=0;for(let Pt=0;Pt<f.batchSize;++Pt){const _t=Pt*ne,nr=Pt*F;for(let nn=j;nn<te;++nn){const Ts=(P+nn*m-X)*Q+_t,Ja=nn*L+nr;for(let Vt=xe;Vt<Te;++Vt){const Zr=(pe+Vt*y-se)*B+Ts,Qr=Vt*A+Ja;for(let sr=Ue;sr<Se;++sr){const Nu=($e+sr*b-K)*U+Zr,bd=sr*V+Qr;gt+=q[Nu+Ye]*D[bd+ot]}}}}N[Ke+ot]=gt}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const Jfe={kernelName:Cb,backendName:"cpu",kernelFunc:Yfe};function Zfe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{pad:i,strides:o,inputShape:l}=s;Oe([r],"conv3dBackpropInputV2");const h=Pe(r.shape),d=Pe(a.shape),f=Uo(l,a.shape,o,1,i),m=new bn(f.inShape,"float32"),y=m.values,[b,x,w,v]=m.strides,C=t.data.get(r.dataId).values,[N,k,E,_]=h,R=t.data.get(a.dataId).values,[D,F,L,A]=d,{batchSize:V,filterDepth:q,filterHeight:ne,filterWidth:Q,inChannels:B,inDepth:U,inHeight:X,inWidth:K,outChannels:se,outDepth:P,outHeight:j,outWidth:te,strideDepth:oe,strideHeight:pe,strideWidth:xe}=f,Te=q-1-f.padInfo.front,_e=ne-1-f.padInfo.top,$e=Q-1-f.padInfo.left;for(let Ue=0;Ue<V;++Ue)for(let Se=0;Se<B;++Se)for(let je=0;je<U;++je){const Ye=je-Te,Ke=Math.max(0,Math.ceil(Ye/oe)),ot=Math.min(P,(q+Ye)/oe);for(let gt=0;gt<X;++gt){const Pt=gt-_e,_t=Math.max(0,Math.ceil(Pt/pe)),nr=Math.min(j,(ne+Pt)/pe);for(let nn=0;nn<K;++nn){const kr=nn-$e,Ts=Math.max(0,Math.ceil(kr/xe)),Ja=Math.min(te,(Q+kr)/xe);let Vt=0;for(let Jr=Ke;Jr<ot;++Jr){const Zr=Jr*oe-Ye;for(let Qr=_t;Qr<nr;++Qr){const sr=Qr*pe-Pt;for(let Jo=Ts;Jo<Ja;++Jo){const Nu=Jo*xe-kr,bd=N*Ue+k*Jr+E*Qr+_*Jo,zw=D*(q-1-Zr)+F*(ne-1-sr)+L*(Q-1-Nu)+A*Se;for(let ka=0;ka<se;++ka){const Cs=C[bd+ka],Ea=R[zw+ka];Vt+=Cs*Ea}}}}y[b*Ue+x*je+w*gt+v*nn+Se]=Vt}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const Qfe={kernelName:Nb,backendName:"cpu",kernelFunc:Zfe};const epe=Nt(ch,n=>Math.cos(n)),tpe={kernelName:ch,backendName:"cpu",kernelFunc:epe};const npe=Nt(hh,n=>Math.cosh(n)),spe={kernelName:hh,backendName:"cpu",kernelFunc:npe};function rpe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:h}=s,[d,f,m,y]=r.shape,b=a.shape[0],[x,w]=o,v=tt([b,x,w,y],"float32"),C=t.data.get(a.dataId).values,N=t.data.get(i.dataId).values,k=t.data.get(r.dataId).values,E=Pe(r.shape),_=Pe(v.shape);for(let R=0;R<b;R++){const D=R*4,F=C[D],L=C[D+1],A=C[D+2],V=C[D+3],q=N[R];if(q>=d)continue;const ne=x>1?(A-F)*(f-1)/(x-1):0,Q=w>1?(V-L)*(m-1)/(w-1):0;for(let B=0;B<x;B++){const U=x>1?F*(f-1)+B*ne:.5*(F+A)*(f-1);if(U<0||U>f-1){for(let X=0;X<w;X++)for(let K=0;K<y;K++){const se=K+X*_[2]+B*_[1]+R*_[0];v.values[se]=h}continue}if(l==="bilinear"){const X=Math.floor(U),K=Math.ceil(U),se=U-X;for(let P=0;P<w;P++){const j=w>1?L*(m-1)+P*Q:.5*(L+V)*(m-1);if(j<0||j>m-1){for(let xe=0;xe<y;xe++){const Te=xe+P*_[2]+B*_[1]+R*_[0];v.values[Te]=h}continue}const te=Math.floor(j),oe=Math.ceil(j),pe=j-te;for(let xe=0;xe<y;xe++){let Te=xe+te*E[2]+X*E[1]+q*E[0];const _e=k[Te];Te=xe+oe*E[2]+X*E[1]+q*E[0];const $e=k[Te];Te=xe+te*E[2]+K*E[1]+q*E[0];const Ue=k[Te];Te=xe+oe*E[2]+K*E[1]+q*E[0];const Se=k[Te],je=_e+($e-_e)*pe,Ye=Ue+(Se-Ue)*pe;Te=xe+P*_[2]+B*_[1]+R*_[0],v.values[Te]=je+(Ye-je)*se}}}else for(let X=0;X<w;++X){const K=w>1?L*(m-1)+X*Q:.5*(L+V)*(m-1);if(K<0||K>m-1){for(let j=0;j<y;j++){const te=j+X*_[2]+B*_[1]+R*_[0];v.values[te]=h}continue}const se=Math.round(K),P=Math.round(U);for(let j=0;j<y;j++){const te=j+se*E[2]+P*E[1]+q*E[0],oe=j+X*_[2]+B*_[1]+R*_[0];v.values[oe]=k[te]}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const ape={kernelName:Eb,backendName:"cpu",kernelFunc:rpe};function ipe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;Oe(r,"cumprod");const l=Zt([a],r.shape.length);let h=r;l!=null&&(h=Fs({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=cn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const f=_s(h.dtype,"int32"),m=mb(he(h.shape),f),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=o?(v,C)=>v+b-C-1:(v,C)=>v+C;for(let v=0;v<y.length;v+=b)for(let C=0;C<b;C++){const N=x(v,C);if(C===0)m[N]=i?1:y[N];else{const k=x(v,C-1);m[N]=i?y[k]*m[k]:y[N]*m[k]}}const w=t.makeTensorInfo(h.shape,f,m);if(l!=null){const v=jo(l),C=Fs({inputs:{x:w},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),C}return w}const ope={kernelName:kb,backendName:"cpu",kernelFunc:ipe};function lpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;Oe(r,"cumsum");const l=Zt([a],r.shape.length);let h=r;l!=null&&(h=Fs({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=cn(1,r.shape.length)[0];if(d!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${d}`);const f=_s(h.dtype,"int32"),m=Yn(he(h.shape),f),y=t.data.get(h.dataId).values,b=h.shape[h.shape.length-1],x=o?(v,C)=>v+b-C-1:(v,C)=>v+C;for(let v=0;v<y.length;v+=b)for(let C=0;C<b;C++){const N=x(v,C);if(C===0)m[N]=i?0:y[N];else{const k=x(v,C-1);m[N]=i?y[k]+m[k]:y[N]+m[k]}}const w=t.makeTensorInfo(h.shape,f,m);if(l!=null){const v=jo(l),C=Fs({inputs:{x:w},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(h),C}return w}const upe={kernelName:Fp,backendName:"cpu",kernelFunc:lpe};function cpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:i,binaryOutput:o}=s;if(r.shape.length===1){const l=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=HE(l,h,a.dtype,a.shape,i);return t.makeTensorInfo([i],a.dtype,d)}else if(r.shape.length===2){const l=t.bufferSync(r),h=t.bufferSync(a),d=C4(l,h,i,o);return t.makeTensorInfo(d.shape,a.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const hpe={kernelName:$b,backendName:"cpu",kernelFunc:cpe};function dpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:a,dataFormat:i}=s;O(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=r.shape[0],l=r.shape[1],h=r.shape[2],d=r.shape[3],f=l*a,m=h*a,y=d/(a*a),b=t.data.get(r.dataId).values,x=new Float32Array(o*f*m*y);let w=0;for(let v=0;v<o;++v)for(let C=0;C<f;++C){const N=Math.floor(C/a),k=C%a;for(let E=0;E<m;++E){const _=Math.floor(E/a),R=E%a,D=(k*a+R)*y;for(let F=0;F<y;++F){const A=F+D+d*(_+h*(N+l*v));x[w++]=b[A]}}}return t.makeTensorInfo([o,f,m,y],r.dtype,x)}const fpe={kernelName:Ib,backendName:"cpu",kernelFunc:dpe};function kV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l,dimRoundingMode:h}=s;Oe([r,a],"depthwiseConv2DNative");const d=Pe(r.shape),f=Pe(a.shape);let m=l;m==null&&(m=[1,1]),O(Zn(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);const y=Vn(r.shape,a.shape,i,m,o,h,!0),{filterHeight:b,filterWidth:x,dilationHeight:w,dilationWidth:v,padInfo:C}=y,N=C.left,k=C.top,E=y.outChannels/y.inChannels,_=new bn(y.outShape,r.dtype),R=t.data.get(r.dataId).values,D=t.data.get(a.dataId).values,F=_.values;for(let L=0;L<y.batchSize;++L){const A=L*d[0],V=L*_.strides[0];for(let q=0;q<y.outHeight;++q){const ne=V+q*_.strides[1],Q=q*y.strideHeight-k;for(let B=0;B<b;++B){const U=Q+B*w;if(U<0||U>=y.inHeight)continue;const X=B*f[0],K=A+U*d[1];for(let se=0;se<y.outWidth;++se){const P=ne+se*_.strides[2],j=se*y.strideWidth-N;for(let te=0;te<x;++te){const oe=j+te*v;if(oe<0||oe>=y.inWidth)continue;const pe=X+te*f[1],xe=K+oe*y.inChannels;let Te=P,_e=pe;for(let $e=0;$e<y.inChannels;++$e){const Ue=R[xe+$e];for(let Se=0;Se<E;++Se)F[Te+Se]+=Ue*D[_e+Se];Te+=E,_e+=E}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const ppe={kernelName:Lp,backendName:"cpu",kernelFunc:kV};function mpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:h,filterShape:d}=s;Oe([r,a],"depthwiseConv2dNativeBackpropFilter");const f=Vn(r.shape,d,i,o,l,h,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:x}=f,w=new bn(f.filterShape,"float32"),v=f.padInfo.left,C=f.padInfo.top,N=f.outChannels/f.inChannels,k=t.data.get(r.dataId).values,E=new bn(r.shape,r.dtype,k),_=t.data.get(a.dataId).values,R=new bn(a.shape,a.dtype,_);for(let D=0;D<b;++D){const F=Math.max(0,Math.ceil((C-D)/m)),L=Math.min(f.outHeight,(f.inHeight+C-D)/m);for(let A=0;A<x;++A){const V=Math.max(0,Math.ceil((v-A)/y)),q=Math.min(f.outWidth,(f.inWidth+v-A)/y);for(let ne=0;ne<f.outChannels;++ne){const Q=Math.trunc(ne/N),B=ne%N;let U=0;for(let X=0;X<f.batchSize;++X)for(let K=F;K<L;++K){const se=D+K*m-C;for(let P=V;P<q;++P){const j=A+P*y-v;U+=E.get(X,se,j,Q)*R.get(X,K,P,ne)}}w.set(U,D,A,Q,B)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const gpe={kernelName:_b,backendName:"cpu",kernelFunc:mpe};function ype(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:h,inputShape:d}=s;Oe([r,a],"depthwiseConv2DNativeBackpropInput");const f=Pe(r.shape),m=Pe(a.shape),y=Vn(d,a.shape,i,o,l,h,!0),b=new bn(y.inShape,"float32"),x=b.values,[w,v,C]=b.strides,N=t.data.get(r.dataId).values,[k,E,_]=f,R=t.data.get(a.dataId).values,[D,F,L]=m,{batchSize:A,filterHeight:V,filterWidth:q,inChannels:ne,inHeight:Q,inWidth:B,outChannels:U,outHeight:X,outWidth:K,strideHeight:se,strideWidth:P}=y,j=V-1-y.padInfo.top,te=q-1-y.padInfo.left,oe=U/ne;for(let pe=0;pe<A;++pe)for(let xe=0;xe<ne;++xe)for(let Te=0;Te<Q;++Te){const _e=Te-j,$e=Math.max(0,Math.ceil(_e/se)),Ue=Math.min(X,(V+_e)/se);for(let Se=0;Se<B;++Se){const je=Se-te,Ye=Math.max(0,Math.ceil(je/P)),Ke=Math.min(K,(q+je)/P);let ot=0;for(let gt=$e;gt<Ue;++gt){const Pt=gt*se-_e;for(let _t=Ye;_t<Ke;++_t){const nr=_t*P-je,nn=k*pe+E*gt+_*_t,kr=D*(V-1-Pt)+F*(q-1-nr)+L*xe;for(let Ts=0;Ts<oe;++Ts){const Ja=xe*oe+Ts,Vt=N[nn+Ja],Jr=R[kr+Ts];ot+=Vt*Jr}}}x[w*pe+v*Te+C*Se+xe]=ot}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const bpe={kernelName:Ab,backendName:"cpu",kernelFunc:ype};function xpe(n){const{inputs:e,backend:t}=n,{x:s}=e,r=he(s.shape),a=t.data.get(s.dataId).values,i=tt([r,r],s.dtype),o=i.values;for(let h=0;h<a.length;h++)o[h*r+h]=a[h];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,i.dtype,i.values)}const wpe={kernelName:Rb,backendName:"cpu",kernelFunc:xpe};const vpe={kernelName:Mp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:a,pad:i,dilations:o}=t,l=e,h=l.data.get(s.dataId).values,d=s.shape.length,f=l.data.get(r.dataId).values,m=r.shape.length,{batchSize:y,inHeight:b,inWidth:x,inChannels:w,outHeight:v,outWidth:C,padInfo:N,strideHeight:k,strideWidth:E,filterHeight:_,filterWidth:R,dilationHeight:D,dilationWidth:F,outShape:L}=km(s.shape,r.shape,a,i,"NHWC",o),A=he(L),V=L.length,q=tn(s.dtype,A);for(let Q=0;Q<y;++Q)for(let B=0;B<v;++B){const U=B*k-N.top;for(let X=0;X<C;++X){const K=X*E-N.left;for(let se=0;se<w;++se){let P=Number.MIN_SAFE_INTEGER;for(let te=0;te<_;++te){const oe=U+te*D;if(oe>=0&&oe<b)for(let pe=0;pe<R;++pe){const xe=K+pe*F;if(xe>=0&&xe<x){const Te=fa([Q,oe,xe,se],d,Pe(s.shape)),_e=fa([te,pe,se],m,Pe(r.shape)),$e=h[Te]+f[_e];$e>P&&(P=$e)}}}const j=fa([Q,B,X,se],V,Pe(L));q[j]=P}}}return{dataId:l.write(Bo(q,s.dtype),L,s.dtype),shape:L,dtype:s.dtype}}};const Spe={kernelName:_0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:a}=n,{strides:i,pad:o,dilations:l}=t,h=e,d=vr(s.shape,h.data.get(s.dataId).values),f=vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:v,padInfo:C,strideHeight:N,strideWidth:k,filterHeight:E,filterWidth:_,dilationHeight:R,dilationWidth:D,outShape:F}=km(s.shape,r.shape,i,o,"NHWC",l);O(a.rank===F.length,()=>`Error in ${_0}, dy must have the same rank as output ${F.length}, but got ${a.rank}`);const L=vr(F,h.data.get(a.dataId).values),A=f2(r.shape,r.dtype);for(let q=0;q<m;++q)for(let ne=0;ne<w;++ne){const Q=ne*N-C.top;for(let B=0;B<v;++B){const U=B*k-C.left;for(let X=0;X<x;++X){let K=Number.MIN_SAFE_INTEGER,se=0,P=0;for(let j=0;j<E;++j){const te=Q+j*R;if(te>=0&&te<y)for(let oe=0;oe<_;++oe){const pe=U+oe*D;if(pe>=0&&pe<b){const xe=d[q][te][pe][X]+f[j][oe][X];xe>K&&(K=xe,se=j,P=oe)}}}A[se][P][X]+=L[q][ne][B][X]}}}return{dataId:h.write(Bo(A,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const Tpe={kernelName:I0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:a}=n,{strides:i,pad:o,dilations:l}=t,h=e,d=vr(s.shape,h.data.get(s.dataId).values),f=vr(r.shape,h.data.get(r.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:x,outHeight:w,outWidth:v,padInfo:C,strideHeight:N,strideWidth:k,filterHeight:E,filterWidth:_,dilationHeight:R,dilationWidth:D,outShape:F}=km(s.shape,r.shape,i,o,"NHWC",l);O(a.rank===F.length,()=>`Error in ${I0}, dy must have the same rank as output ${F.length}, but got ${a.rank}`);const L=vr(F,h.data.get(a.dataId).values),A=f2(s.shape,s.dtype);for(let q=0;q<m;++q)for(let ne=0;ne<w;++ne){const Q=ne*N-C.top;for(let B=0;B<v;++B){const U=B*k-C.left;for(let X=0;X<x;++X){let K=Number.MIN_SAFE_INTEGER,se=Q<0?0:Q,P=U<0?0:U;for(let j=0;j<E;++j){const te=Q+j*R;if(te>=0&&te<y)for(let oe=0;oe<_;++oe){const pe=U+oe*D;if(pe>=0&&pe<b){const xe=d[q][te][pe][X]+f[j][oe][X];xe>K&&(K=xe,se=te,P=pe)}}}A[q][se][P][X]+=L[q][ne][B][X]}}}return{dataId:h.write(Bo(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Cpe(n){const{inputs:e,backend:t,attrs:s}=n,{image:r}=e,{canvas:a,options:i}=s,{contextOptions:o,imageOptions:l}=i||{},h=l?.alpha||1,d=o?.contextType||"2d";if(d!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const f=a.getContext(d,o?.contextAttributes||{});if(f==null)throw new Error(`Could not get the context with ${d} type.`);const[m,y]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],x=t.data.get(r.dataId).values,w=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(y*m*4);for(let N=0;N<m*y;++N){const k=[0,0,0,255*h];for(let _=0;_<b;_++){const R=x[N*b+_];if(r.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(r.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);b===1?(k[0]=R*w,k[1]=R*w,k[2]=R*w):k[_]=R*w}const E=N*4;v[E+0]=Math.round(k[0]),v[E+1]=Math.round(k[1]),v[E+2]=Math.round(k[2]),v[E+3]=Math.round(k[3])}a.width=y,a.height=m;const C=new ImageData(v,y,m);return f.putImageData(C,0,0),r}const Npe={kernelName:Db,backendName:"cpu",kernelFunc:Cpe};function sg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s;Oe(r,"sum");let o;r.dtype==="bool"?o=zo({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):o=Ka({inputs:{x:r},backend:t});const l=o.shape.length,h=at(a,o.shape),d=Zt(h,l);let f=h,m=o;d!=null&&(m=Fs({inputs:{x:o},backend:t,attrs:{perm:d}}),f=cn(f.length,l)),Qn("sum",f,m.shape.length);const[y,b]=Un(m.shape,f),x=_s(m.dtype,"int32");let w=K0(t,y,x);const v=he(b),C=t.data.get(w.dataId).values,N=t.data.get(m.dataId).values;for(let k=0;k<C.length;++k){const E=k*v;let _=0;for(let R=0;R<v;++R)_+=N[E+R];C[k]=_}if(i){const k=un(w.shape,h),E=w;w=zt({inputs:{x:w},backend:t,attrs:{shape:k}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(o),d!=null&&t.disposeIntermediateTensorInfo(m),w}const kpe={kernelName:gm,backendName:"cpu",kernelFunc:sg};function Epe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,a=e,{allDims:i,summedDims:o,idDims:l}=sk(r,a.length);ak(i.length,l,a);const{path:h,steps:d}=ik(o,l),f=d.length;let m=null,y=i.length;const b=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:v,expandDims:C}=rk(y,l[w]);let N;ok(v)?N=a[w]:(N=Fs({inputs:{x:a[w]},backend:t,attrs:{perm:v}}),b.push(N));const k=N.shape.slice();for(let E=0;E<C.length;++E)k.splice(C[E],0,1);lt(N.shape,k)||(N=zt({inputs:{x:N},backend:t,attrs:{shape:k}}),b.push(N)),m===null?m=N:(m=Dw({inputs:{a:N,b:m},backend:t}),b.push(m))}x<f-1&&(h[x]>=0&&(m=sg({inputs:{x:m},backend:t,attrs:{axis:h[x]-(i.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const $pe={kernelName:Ob,backendName:"cpu",kernelFunc:Epe};function Ipe(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;Oe([s,r],"eluGrad");const a=new Float32Array(he(r.shape)),i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values;for(let l=0;l<i.length;++l){const h=i[l];h>=0?a[l]=o[l]:a[l]=o[l]*(h+1)}return t.makeTensorInfo(r.shape,"float32",a)}const _pe={kernelName:Fb,backendName:"cpu",kernelFunc:Ipe};const Ape=YN,Rpe=JN,Dpe=ZN,Ope=QN,Fpe=ek,Lpe=tk,Mpe=Nt(ph,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Ape*t);return e*(1-((((Lpe*s+Fpe)*s+Ope)*s+Dpe)*s+Rpe)*s*Math.exp(-t*t))}),zpe={kernelName:ph,backendName:"cpu",kernelFunc:Mpe};function J0(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:a}=s,i=r.shape.length,o=r.shape.slice();let l=a;return a<0&&(O(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),zt({inputs:{x:r},backend:t,attrs:{shape:o}})}const Ppe={kernelName:Pp,backendName:"cpu",kernelFunc:J0};const Bpe=dn((n,e)=>n/e),ZE=An(dh,Bpe),dC={kernelName:dh,backendName:"cpu",kernelFunc:ZE};function EV(n,e,t){const s=n.shape,r=s[0],a=s[1],i=t.data.get(n.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,h=[r,a],d=he(h),f=zn("float32",d),m=zn("float32",d);for(let w=0;w<r;w++){const v=iu({inputs:{x:o},backend:t,attrs:{begin:[w,0],size:[1,a]}}),C=iu({inputs:{x:l},backend:t,attrs:{begin:[w,0],size:[1,a]}}),N=qs({inputs:{real:v,imag:C},backend:t}),{real:k,imag:E}=Vpe(N,e,t),_=_i(k,E);for(let R=0;R<a;R++){const D=nk(_,R);f[w*a+R]=D.real,m[w*a+R]=D.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(N)}const y=t.makeTensorInfo(h,"float32",f),b=t.makeTensorInfo(h,"float32",m),x=qs({inputs:{real:y,imag:b},backend:t});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}function Vpe(n,e,t){const s=he(n.shape),r=t.data.get(n.dataId),a=t.data.get(r.complexTensorInfos.real.dataId).values,i=t.data.get(r.complexTensorInfos.imag.dataId).values;if(Upe(s)){const o=fC(a,i,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const h=t.makeTensorInfo(l,"float32",o.real),d=t.makeTensorInfo(l,"float32",o.imag),f=t.makeTensorInfo([],"float32",Oi(s,"float32")),m=Ka({inputs:{x:f},backend:t}),y=dC.kernelFunc({inputs:{a:h,b:f},backend:t}),b=dC.kernelFunc({inputs:{a:d,b:m},backend:t}),x=t.data.get(y.dataId).values,w=t.data.get(b.dataId).values;return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),{real:x,imag:w}}return o}else{const o=_i(a,i),l=jpe(o,s,e);return xP(l)}}function Upe(n){return(n&n-1)===0}function fC(n,e,t,s,r){if(t===1)return{real:n,imag:e};const a=_i(n,e),i=t/2,o=wP(a),l=o.real,h=o.imag,d=[l.length],f=r.makeTensorInfo(d,"float32",l),m=r.makeTensorInfo(d,"float32",h),y=qs({inputs:{real:f,imag:m},backend:r}),b=vP(a),x=b.real,w=b.imag,v=[x.length],C=r.makeTensorInfo(v,"float32",x),N=r.makeTensorInfo(v,"float32",w),k=qs({inputs:{real:C,imag:N},backend:r}),E=fC(l,h,i,s,r),_=E.real,R=E.imag,D=[_.length],F=r.makeTensorInfo(D,"float32",_),L=r.makeTensorInfo(D,"float32",R),A=qs({inputs:{real:F,imag:L},backend:r}),V=fC(x,w,i,s,r),q=V.real,ne=V.imag,Q=[q.length],B=r.makeTensorInfo(Q,"float32",q),U=r.makeTensorInfo(Q,"float32",ne),X=qs({inputs:{real:B,imag:U},backend:r}),K=TP(t,s),se=[K.real.length],P=r.makeTensorInfo(se,"float32",K.real),j=r.makeTensorInfo(se,"float32",K.imag),te=qs({inputs:{real:P,imag:j},backend:r}),oe=Dw({inputs:{a:te,b:X},backend:r}),pe=Kc({inputs:{a:A,b:oe},backend:r}),xe=YE({inputs:{a:A,b:oe},backend:r}),Te=au({inputs:{input:pe},backend:r}),_e=au({inputs:{input:xe},backend:r}),$e=Xc({inputs:{input:pe},backend:r}),Ue=Xc({inputs:{input:xe},backend:r}),Se=Yc({inputs:[Te,_e],backend:r,attrs:{axis:0}}),je=Yc({inputs:[$e,Ue],backend:r,attrs:{axis:0}}),Ye=r.data.get(Se.dataId).values,Ke=r.data.get(je.dataId).values;return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo($e),r.disposeIntermediateTensorInfo(_e),r.disposeIntermediateTensorInfo(Ue),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(je),{real:Ye,imag:Ke}}function jpe(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let a=0,i=0;for(let o=0;o<e;o++){const l=CP(r*o,e,t),h=nk(n,o);a+=h.real*l.real-h.imag*l.imag,i+=h.real*l.imag+h.imag*l.real}t&&(a/=e,i/=e),SP(s,a,i,r)}return s}function Wpe(n){const{inputs:e,backend:t}=n,{input:s}=e,r=he(s.shape),a=s.shape[s.shape.length-1],i=r/a,o=zt({inputs:{x:s},backend:t,attrs:{shape:[i,a]}}),l=EV(o,!1,t),h=zt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),h}const Gpe={kernelName:Lb,backendName:"cpu",kernelFunc:Wpe};function QE(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:a}=t,i=a||hu(r),o=tn(i,he(s));return qpe(o,r,i),e.makeTensorInfo(s,i,o)}const Hpe={kernelName:Mb,backendName:"cpu",kernelFunc:QE};function qpe(n,e,t){n.fill(e)}const Kpe={kernelName:zb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,a=zn(s.dtype,he(s.shape)),[i,o,l,h]=s.shape,d=r.data.get(s.dataId).values;for(let m=0;m<i;m++){const y=m*l*o*h;for(let b=0;b<o;b++){const x=b*(l*h);for(let w=0;w<l;w++){const v=w*h;for(let C=0;C<h;C++){const N=Math.round(l-w-1),k=y+x+v+C;let E=d[k];if(N>=0&&N<l){const _=N*h,R=y+x+_+C;E=d[R]}a[k]=E}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};function Xpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=NV({inputs:{x:r,filter:a},backend:t,attrs:{strides:l,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m}});if(i){const w=x;if(d==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const v=zt({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});x=Kc({inputs:{a:x,b:v},backend:t}),t.disposeIntermediateTensorInfo(v)}else x=Kc({inputs:{a:x,b:i},backend:t});t.disposeIntermediateTensorInfo(w)}if(y){const w=x;if(d==="NCHW"&&y==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const v=zt({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});x=Y0(t,x,y,v,b),t.disposeIntermediateTensorInfo(v)}else x=Y0(t,x,y,o,b);t.disposeIntermediateTensorInfo(w)}return x}const Ype={kernelName:Zf,backendName:"cpu",kernelFunc:Xpe};function Jpe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s;let x=kV({inputs:{x:r,filter:a},backend:t,attrs:{strides:l,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m}});if(i){const w=x;x=Kc({inputs:{a:x,b:i},backend:t}),t.disposeIntermediateTensorInfo(w)}if(y){const w=x;x=Y0(t,x,y,o,b),t.disposeIntermediateTensorInfo(w)}return x}const Zpe={kernelName:Qf,backendName:"cpu",kernelFunc:Jpe};function Qpe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,a=he(s.shape),i=r.shape,o=i[i.length-1],[l,h,d,f]=ow(s,r);if(h===0)return t.makeTensorInfo(l,s.dtype,[]);const m=t.data.get(r.dataId).values,y=t.bufferSync(s),b=F4(m,y,s.dtype,h,o,d,f,s.shape,a);return t.makeTensorInfo(l,s.dtype,b.values)}const eme={kernelName:Pb,backendName:"cpu",kernelFunc:Qpe};function tme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:a}=e,{axis:i,batchDims:o}=s;Oe([r,a],"gatherV2");const l=at(i,r.shape)[0],h=t.data.get(a.dataId).values,d=r.shape[l];for(let k=0;k<h.length;++k){const E=h[k];O(E<=d-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${d-1}]`)}let f=o;o==null&&(f=0);const m=he(a.shape),y=uk(r,a,l,f),b=zt({inputs:{x:r},backend:t,attrs:{shape:[y.batchSize,y.outerSize,y.dimSize,y.sliceSize]}}),x=zt({inputs:{x:a},backend:t,attrs:{shape:[y.batchSize,m/y.batchSize]}}),w=[y.batchSize,y.outerSize,m/y.batchSize,y.sliceSize],v=t.bufferSync(x),C=t.bufferSync(b),N=L4(C,v,w);return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.makeTensorInfo(y.outputShape,N.dtype,N.values)}const nme={kernelName:Vp,backendName:"cpu",kernelFunc:tme};function sme(n){const{inputs:e,backend:t}=n,{input:s}=e,r=he(s.shape),a=s.shape[s.shape.length-1],i=r/a,o=zt({inputs:{x:s},backend:t,attrs:{shape:[i,a]}}),l=EV(o,!0,t),h=zt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),h}const rme={kernelName:Bb,backendName:"cpu",kernelFunc:sme};const ame=Nt(vh,n=>Number.isFinite(n)?1:0,"bool"),ime={kernelName:vh,backendName:"cpu",kernelFunc:ame};const ome=Nt(Sh,n=>Math.abs(n)===1/0?1:0,"bool"),lme={kernelName:Sh,backendName:"cpu",kernelFunc:ome};const ume=Nt(Th,n=>Number.isNaN(n)?1:0,"bool"),cme={kernelName:Th,backendName:"cpu",kernelFunc:ume};function hme(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:a}=t,i=V4(s,r,a);return e.makeTensorInfo([i.length],"float32",i)}const dme={kernelName:Ub,backendName:"cpu",kernelFunc:hme};const fme=Nt(Nh,n=>Math.log1p(n)),pme={kernelName:Nh,backendName:"cpu",kernelFunc:fme};const mme=dn((n,e)=>n&&e),gme=An(Hp,mme,null,"bool"),yme={kernelName:Hp,backendName:"cpu",kernelFunc:gme};const bme=Nt(qp,n=>n?0:1,"bool"),xme={kernelName:qp,backendName:"cpu",kernelFunc:bme};const wme=dn((n,e)=>n||e),vme=An(Kp,wme,null,"bool"),Sme={kernelName:Kp,backendName:"cpu",kernelFunc:vme};function Tme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=s;Oe(r,"LRN");const h=r.shape[3],d=h-1,f=t.data.get(r.dataId).values,m=he(r.shape),y=new Float32Array(m);function b(x){const w=x%h;let v=x-w+Math.max(0,w-a);const C=x-w+Math.min(w+a,d);let N=0;for(;v<=C;v++){const k=f[v];N+=k*k}return N}for(let x=0;x<m;x++){const w=b(x),v=f[x]*Math.pow(i+o*w,-l);y[x]=v}return t.makeTensorInfo(r.shape,r.dtype,y)}const Cme={kernelName:Xp,backendName:"cpu",kernelFunc:Tme};function Nme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:h,beta:d}=s;Oe(i,"LRNGrad");const f=he(i.shape),m=i.shape[3],y=t.data.get(i.dataId).values,b=t.data.get(r.dataId).values,x=t.data.get(a.dataId).values,w=new Float32Array(f),v=f;for(let C=0;C<v;C++){const N=C%m,k=C-N+Math.max(0,N-o),E=C-N+Math.min(m,N+o+1);let _=0;for(let R=k;R<E;R++)_+=Math.pow(b[R],2);_=h*_+l;for(let R=k;R<E;R++){let D=-2*h*d*b[R]*x[C]/_;C===R&&(D+=Math.pow(_,-d)),D*=y[C],w[R]+=D}}return t.makeTensorInfo(i.shape,r.dtype,w)}const kme={kernelName:jb,backendName:"cpu",kernelFunc:Nme};function $V(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:a,keepDims:i}=s,o=t;let l=r.shape;const h=l.length,d=at(a,l);let f=d;const m=Zt(f,h);let y=o.data.get(r.dataId).values;if(m!=null){const k=new Array(h);for(let E=0;E<k.length;E++)k[E]=l[m[E]];y=KE(y,l,r.dtype,m,k),f=cn(f.length,h),l=k}Oe(r,"max"),Qn("max",f,h);const[b,x]=Un(l,f),w=he(x),v=j4(y,w,b,r.dtype),C=o.write(v,b,r.dtype);let N=b;return i&&(N=un(b,d)),{dataId:C,shape:N,dtype:r.dtype}}const Eme={kernelName:Yp,backendName:"cpu",kernelFunc:$V};function $me(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;Oe(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Kr(r.shape,a,i,h,o,l);let f;if(d.filterWidth===1&&d.filterHeight===1&&lt(d.inShape,d.outShape))f=Ka({inputs:{x:r},backend:t});else{const m=t.data.get(r.dataId).values,y=Pe(r.shape),b=JE(m,r.shape,r.dtype,y,d,"max");f=t.makeTensorInfo(d.outShape,r.dtype,b.values)}return f}const Ime={kernelName:Jp,backendName:"cpu",kernelFunc:$me};function _me(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:h}=s;Oe(r,"maxPool3d");const d=Fi(r.shape,a,i,1,o,l,h),f=t.data.get(r.dataId).values,m=CV(f,r.shape,r.dtype,Pe(r.shape),d,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}const Ame={kernelName:Zp,backendName:"cpu",kernelFunc:_me};function Rme(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,{filterSize:i,strides:o,pad:l,dimRoundingMode:h}=s;Oe([r,a],"maxPool3DGrad");const d=Fi(a.shape,i,o,1,l,h),f=t.bufferSync(a),m=wfe(f,d),y=d.strideDepth,b=d.strideHeight,x=d.strideWidth,w=d.dilationDepth,v=d.dilationHeight,C=d.dilationWidth,N=d.effectiveFilterDepth,k=d.effectiveFilterHeight,E=d.effectiveFilterWidth,_=N-1-d.padInfo.front,R=E-1-d.padInfo.left,D=k-1-d.padInfo.top,F=tt(a.shape,"float32"),L=t.bufferSync(r);for(let A=0;A<d.batchSize;++A)for(let V=0;V<d.inChannels;++V)for(let q=0;q<d.inDepth;++q)for(let ne=0;ne<d.inHeight;++ne)for(let Q=0;Q<d.inWidth;++Q){const B=q-_,U=ne-D,X=Q-R;let K=0;for(let se=0;se<N;se+=w){const P=(B+se)/y;if(!(P<0||P>=d.outDepth||Math.floor(P)!==P))for(let j=0;j<k;j+=v){const te=(U+j)/b;if(!(te<0||te>=d.outHeight||Math.floor(te)!==te))for(let oe=0;oe<E;oe+=C){const pe=(X+oe)/x;if(pe<0||pe>=d.outWidth||Math.floor(pe)!==pe)continue;const xe=N*k*E-1-m.get(A,P,te,pe,V),Te=se*k*E+j*E+oe,_e=xe===Te?1:0;if(_e===0)continue;const $e=L.get(A,P,te,pe,V);K+=$e*_e}}}F.set(K,A,q,ne,Q,V)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}const Dme={kernelName:Gb,backendName:"cpu",kernelFunc:Rme};function Ome(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a,output:i}=e,o=a;Oe([a,i],"maxPoolGrad");const{filterSize:l,strides:h,pad:d,dimRoundingMode:f}=s,m=Kr(o.shape,l,h,1,d,f),y=t.data.get(o.dataId).values,b=tt(m.outShape,o.dtype,TV(y,o.shape,o.dtype,m).values),x=m.strideHeight,w=m.strideWidth,v=m.dilationHeight,C=m.dilationWidth,N=m.effectiveFilterHeight,k=m.effectiveFilterWidth,E=k-1-m.padInfo.left,_=N-1-m.padInfo.top,R=tt(o.shape,"float32"),D=t.data.get(r.dataId).values,F=tt(r.shape,"float32",D);for(let L=0;L<m.batchSize;++L)for(let A=0;A<m.inChannels;++A)for(let V=0;V<m.inHeight;++V)for(let q=0;q<m.inWidth;++q){const ne=V-_,Q=q-E;let B=0;for(let U=0;U<N;U+=v){const X=(ne+U)/x;if(!(X<0||X>=m.outHeight||Math.floor(X)!==X))for(let K=0;K<k;K+=C){const se=(Q+K)/w;if(se<0||se>=m.outWidth||Math.floor(se)!==se)continue;const P=N*k-1-b.get(L,X,se,A),j=U*k+K,te=P===j?1:0;if(te===0)continue;const oe=F.get(L,X,se,A);B+=oe*te}}R.set(B,L,V,q,A)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const Fme={kernelName:Wb,backendName:"cpu",kernelFunc:Ome};function Lme(n,e,t,s,r){const a=Pe(e),i=JE(n,e,t,a,r,"max"),o=TV(n,e,t,r,!0,s);return[i.values,o.values]}const Mme={kernelName:Hb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=e,l=t;Oe(s,"MaxPoolWithArgmax");const h=l.data.get(s.dataId).values,d=Kr(s.shape,r,a,[1,1],i),[f,m]=Lme(h,s.shape,s.dtype,o,d),y=l.write(f,d.outShape,s.dtype),b=l.write(m,d.outShape,s.dtype);return[{dataId:y,shape:d.outShape,dtype:s.dtype},{dataId:b,shape:d.outShape,dtype:"int32"}]}};function zme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s,o=at(a,r.shape),h=Un(r.shape,o)[1],d=he(h),f=[],m=t.makeTensorInfo([],"float32",new Float32Array([d]));f.push(m);const y=zo({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});f.push(y);const b=ZE({inputs:{a:y,b:m},backend:t});f.push(b);const x=sg({inputs:{x:b},backend:t,attrs:{axis:a,keepDims:i}});return f.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const Pme={kernelName:Qp,backendName:"cpu",kernelFunc:zme};function Bme(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s;Oe(r,"min");const o=at(a,r.shape);let l=o;const h=Zt(l,r.shape.length);let d=r;h!=null&&(d=Fs({inputs:{x:r},backend:t,attrs:{perm:h}}),l=cn(l.length,r.shape.length)),Qn("min",l,d.shape.length);const[f,m]=Un(d.shape,l),y=he(m),b=Yn(he(f),d.dtype),x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const C=v*y;let N=x[C];for(let k=0;k<y;++k){const E=x[C+k];(Number.isNaN(E)||E<N)&&(N=E)}b[v]=N}h!=null&&t.disposeIntermediateTensorInfo(d);const w=t.makeTensorInfo(f,d.dtype,b);if(i){const v=un(f,o),C=zt({inputs:{x:w},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(w),C}return w}const Vme={kernelName:em,backendName:"cpu",kernelFunc:Bme};function Ume(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:a,mode:i}=s;Oe(r,"mirrorPad");const o=a.map((N,k)=>N[0]+r.shape[k]+N[1]),l=a.map(N=>N[0]),h=a.map((N,k)=>N[0]+r.shape[k]),d=i==="reflect"?0:1,f=t.data.get(r.dataId).values,m=r.shape.length,y=Pe(r.shape),b=he(o),x=o.length,w=Pe(o),v=zn(r.dtype,b);for(let N=0;N<b;N++){let k=du(N,x,w);for(let _=0;_<x;_++)k[_]<l[_]?k[_]=l[_]*2-k[_]-d:k[_]>=h[_]&&(k[_]=(h[_]-1)*2-k[_]+d);k=k.map((_,R)=>_-l[R]);const E=fa(k,m,y);v[N]=f[E]}return{dataId:t.write(v,o,r.dtype),shape:o,dtype:r.dtype}}const jme={kernelName:tm,backendName:"cpu",kernelFunc:Ume};const Wme=dn(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),Gme=An($h,Wme),Hme={kernelName:$h,backendName:"cpu",kernelFunc:Gme};function IV(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:a}=s,i=r.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=at([o],r.shape),h=$V({inputs:{x:r},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),d=un(h.shape,l),f=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),m=YE({inputs:{a:r,b:f},backend:t}),y=A4({inputs:{x:m},backend:t}),b=sg({inputs:{x:y},backend:t,attrs:{axis:l,keepDims:!1}}),x=zt({inputs:{x:b},backend:t,attrs:{shape:d}}),w=ZE({inputs:{a:y,b:x},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),w}const qme={kernelName:xm,backendName:"cpu",kernelFunc:IV};function Kme(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:a,seed:i,normalized:o}=s;Oe(r,"multinomial");const l=o?r:IV({inputs:{logits:r},backend:t,attrs:{dim:-1}}),h=l.shape[0],d=l.shape[1],f=t.data.get(l.dataId).values,m=[h,a],y=Yn(he(m),"int32");for(let b=0;b<h;++b){const x=b*d,w=new Float32Array(d-1);w[0]=f[x];for(let N=1;N<w.length;++N)w[N]=w[N-1]+f[x+N];const v=td.alea(i.toString()),C=b*a;for(let N=0;N<a;++N){const k=v();y[C+N]=w.length;for(let E=0;E<w.length;E++)if(k<w[E]){y[C+N]=E;break}}}return o||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(m,"int32",y)}const Xme={kernelName:qb,backendName:"cpu",kernelFunc:Kme};const Yme=sw;function Jme(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=s;Oe(r,"NonMaxSuppression");const h=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,{selectedIndices:f}=Yme(h,d,i,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const Zme={kernelName:Kb,backendName:"cpu",kernelFunc:Jme};const Qme=rw;function ege(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:h}=s;Oe(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,f=t.data.get(a.dataId).values,{selectedIndices:m,validOutputs:y}=Qme(d,f,i,o,l,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const tge={kernelName:Xb,backendName:"cpu",kernelFunc:ege};const nge=aw;function sge(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:h}=s;Oe(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,f=t.data.get(a.dataId).values,m=i,y=o,b=l,x=h,{selectedIndices:w,selectedScores:v}=nge(d,f,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const rge={kernelName:Yb,backendName:"cpu",kernelFunc:sge};function age(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:a,depth:i,onValue:o,offValue:l}=s;Oe(r,"oneHot");const h=he(r.shape),d=new Float32Array(h*i);d.fill(l);const f=t.data.get(r.dataId).values;for(let m=0;m<h;++m)f[m]>=0&&f[m]<i&&(d[m*i+f[m]]=o);return t.makeTensorInfo([...r.shape,i],a,d)}const ige={kernelName:am,backendName:"cpu",kernelFunc:age};function Z0(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=au({inputs:{input:s},backend:t}),a=Z0({inputs:{x:r},backend:t}),i=Xc({inputs:{input:s},backend:t}),o=Z0({inputs:{x:i},backend:t}),l=qs({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),l}else return QE({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const oge={kernelName:Tm,backendName:"cpu",kernelFunc:Z0};function _V(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=au({inputs:{input:s},backend:t}),a=_V({inputs:{x:r},backend:t}),i=Xc({inputs:{input:s},backend:t}),o=Z0({inputs:{x:i},backend:t}),l=qs({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),l}else return QE({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const lge={kernelName:rm,backendName:"cpu",kernelFunc:_V};function AV(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return J0({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const a=e[0].shape,i=e[0].dtype;e.forEach(d=>{Jn(a,d.shape,"All tensors passed to stack must have matching shapes"),O(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const f=J0({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(f),f}),h=Yc({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const uge={kernelName:im,backendName:"cpu",kernelFunc:AV};function cge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:a,constantValue:i}=s;Oe(r,"pad");const o=a.map((C,N)=>C[0]+r.shape[N]+C[1]),l=a.map(C=>C[0]),h=t.data.get(r.dataId).values,d=he(r.shape),f=r.shape.length,m=Pe(r.shape),y=he(o),b=o.length,x=Pe(o),w=zn(r.dtype,y);i!==0&&w.fill(i);for(let C=0;C<d;C++){const k=du(C,f,m).map((_,R)=>_+l[R]),E=fa(k,b,x);w[E]=h[C]}return{dataId:t.write(w,o,r.dtype),shape:o,dtype:r.dtype}}const RV={kernelName:om,backendName:"cpu",kernelFunc:cge};const hge=dn((n,e)=>Math.pow(n,e)),dge=An(_h,hge),fge={kernelName:_h,backendName:"cpu",kernelFunc:dge};function pge(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=s,l=r.map(v=>t.data.get(v.dataId).values),h=r.map(v=>v.shape),d=t.data.get(a.dataId).values,f=t.data.get(i.dataId).values,[m,y,b]=X4(l,h,d,a.shape,a.dtype,f,i.shape),x=m.map(v=>t.makeTensorInfo([v.length],"int32",v)),w=t.makeTensorInfo(b,a.dtype,y);return x.concat([w])}const mge={kernelName:Jb,backendName:"cpu",kernelFunc:pge};function gge(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:a}=e,i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,[h,d]=Y4(i,s.shape,s.dtype,o,r.shape,l,a.shape),f=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[f,m]}const yge={kernelName:Zb,backendName:"cpu",kernelFunc:gge};function bge(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,h=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,f=t.data.get(i.dataId).values,m=o.map(w=>t.data.get(w.dataId).values),y=o.map(w=>w.shape),[b,x]=J4(h,r.shape,d,a.shape,a.dtype,f,i.shape,m,y,l);return t.makeTensorInfo(b,a.dtype,x)}const xge={kernelName:Qb,backendName:"cpu",kernelFunc:bge};function wge(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:a,step:i}=t,o=Z4(s,r,i,a);return e.makeTensorInfo([o.length],a,o)}const vge={kernelName:ex,backendName:"cpu",kernelFunc:wge};const Sge=Nt(Ah,n=>1/n),Tge={kernelName:Ah,backendName:"cpu",kernelFunc:Sge};function Cge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s;Oe(r,"resizeBilinear");const l=Pe(r.shape),[h,d]=o,[f,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(he([f,h,d,b])),v=[a&&h>1?m-1:m,a&&d>1?y-1:y],C=[a&&h>1?h-1:h,a&&d>1?d-1:d];let N=0;const k=v[0]/C[0],E=v[1]/C[1];for(let _=0;_<f;_++)for(let R=0;R<h;R++){let D;i?D=k*(R+.5)-.5:D=k*R;const F=Math.max(0,Math.floor(D)),L=D-F,A=Math.min(m-1,Math.ceil(D)),V=_*l[0]+F*l[1],q=_*l[0]+A*l[1];for(let ne=0;ne<d;ne++){let Q;i?Q=E*(ne+.5)-.5:Q=E*ne;const B=Math.max(0,Math.floor(Q)),U=Q-B,X=Math.min(y-1,Math.ceil(Q)),K=V+B*l[2],se=q+B*l[2],P=V+X*l[2],j=q+X*l[2];for(let te=0;te<b;te++){const oe=x[K+te],pe=x[se+te],xe=x[P+te],Te=x[j+te],_e=oe+(xe-oe)*U,$e=pe+(Te-pe)*U,Ue=_e+($e-_e)*L;w[N++]=Ue}}}return t.makeTensorInfo([f,h,d,b],"float32",w)}const Nge={kernelName:dm,backendName:"cpu",kernelFunc:Cge};function kge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:i}=s;Oe([a,r],"resizeBilinearGrad");const o=Pe(r.shape),[l,h,d,f]=r.shape,[,m,y]=a.shape,b=new Float32Array(l*h*d*f),x=[i&&m>1?h-1:h,i&&y>1?d-1:d],w=[i&&m>1?m-1:m,i&&y>1?y-1:y],v=x[0]/w[0],C=x[1]/w[1],N=t.data.get(a.dataId).values;let k=0;for(let E=0;E<l;E++){const _=E*o[0];for(let R=0;R<m;R++){const D=R*v,F=Math.floor(D),L=Math.min(Math.ceil(D),h-1),A=_+F*o[1],V=_+L*o[1],q=D-F,ne=1-q;for(let Q=0;Q<y;Q++){const B=Q*C,U=Math.floor(B),X=Math.min(Math.ceil(B),d-1),K=B-U,se=1-K,P=A+U*o[2],j=A+X*o[2],te=V+U*o[2],oe=V+X*o[2],pe=ne*se,xe=ne*K,Te=q*se,_e=q*K;for(let $e=0;$e<f;$e++){const Ue=N[k++];b[P+$e]+=Ue*pe,b[j+$e]+=Ue*xe,b[te+$e]+=Ue*Te,b[oe+$e]+=Ue*_e}}}}return t.makeTensorInfo([l,d,h,f],"float32",b)}const Ege={kernelName:sx,backendName:"cpu",kernelFunc:kge};function $ge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s;Oe(r,"resizeNearestNeighbor");const l=Pe(r.shape),[h,d]=o,[f,m,y,b]=r.shape,x=t.data.get(r.dataId).values,w=new Float32Array(f*h*d*b),v=[a&&h>1?m-1:m,a&&d>1?y-1:y],C=[a&&h>1?h-1:h,a&&d>1?d-1:d],N=v[0]/C[0],k=v[1]/C[1];let E=0;for(let _=0;_<f;_++){const R=_*l[0];for(let D=0;D<h;D++){const F=i?N*(D+.5):N*D;let L=Math.min(m-1,a?Math.round(F):Math.floor(F));i&&(L=Math.max(0,L));const A=R+L*l[1];for(let V=0;V<d;V++){const q=i?k*(V+.5):k*V;let ne=Math.min(y-1,a?Math.round(q):Math.floor(q));i&&(ne=Math.max(0,ne));const Q=A+ne*l[2];for(let B=0;B<b;B++){const U=x[Q+B];w[E++]=U}}}}return t.makeTensorInfo([f,h,d,b],r.dtype,w)}const Ige={kernelName:hm,backendName:"cpu",kernelFunc:$ge};function _ge(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:i}=s;Oe([a,r],"resizeNearestNeighborGrad");const o=Pe(r.shape),l=Pe(a.shape),[h,d,f,m]=r.shape,[,y,b]=a.shape,x=new Float32Array(h*d*f*m),w=t.data.get(a.dataId).values,v=[i&&y>1?d-1:d,i&&b>1?f-1:f],C=[i&&y>1?y-1:y,i&&b>1?b-1:b],N=v[0]/C[0],k=v[1]/C[1],E=1/N,_=1/k,R=Math.ceil(E)*2+2,D=Math.ceil(_)*2+2;for(let F=0;F<h;F++){const L=F*o[0];for(let A=0;A<d;A++){const V=L+A*o[1],q=Math.floor(A*E),ne=Math.floor(q-R/2);for(let Q=0;Q<f;Q++){const B=V+Q*o[2],U=Math.floor(Q*_),X=Math.floor(U-D/2);for(let K=0;K<m;K++){let se=0;for(let P=0;P<R;P++){const j=P+ne;if(j<0||j>=y)continue;const te=L+j*l[1],oe=j*N,pe=Math.min(d-1,i?Math.round(oe):Math.floor(oe));if(A===pe)for(let xe=0;xe<D;xe++){const Te=xe+X;if(Te<0||Te>=b)continue;const _e=te+Te*l[2],$e=Te*k,Ue=Math.min(f-1,i?Math.round($e):Math.floor($e));Q===Ue&&(se+=w[_e+K])}}x[B+K]=se}}}}return t.makeTensorInfo(r.shape,r.dtype,x)}const Age={kernelName:nx,backendName:"cpu",kernelFunc:_ge};function Rge(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:a}=s;Oe(r,"reverse");const i=r.shape.length,o=at(a,r.shape);if(i===0)return Ka({inputs:{x:r},backend:t});const l=new bn(r.shape,r.dtype),h=t.bufferSync(r);for(let d=0;d<l.size;d++){const f=l.indexToLoc(d),m=f.slice();o.forEach(y=>m[y]=r.shape[y]-1-m[y]),l.set(h.get(...m),...f)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Dge={kernelName:fm,backendName:"cpu",kernelFunc:Rge};const Oge={kernelName:wx,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:a,center:i}=e,o=t,l=zn(s.dtype,he(s.shape)),[h,d,f,m]=s.shape,[y,b]=qN(i,d,f),x=255,w=Math.sin(r),v=Math.cos(r),C=o.data.get(s.dataId).values;for(let k=0;k<h;k++){const E=k*f*d*m;for(let _=0;_<d;_++){const R=_*(f*m);for(let D=0;D<f;D++){const F=D*m;for(let L=0;L<m;L++){const A=[h,_,D,L],V=A[2],q=A[1];let ne=(V-y)*v-(q-b)*w,Q=(V-y)*w+(q-b)*v;ne=Math.round(ne+y),Q=Math.round(Q+b);let B=a;if(typeof a!="number"&&(L===3?B=x:B=a[L]),ne>=0&&ne<f&&Q>=0&&Q<d){const X=Q*(f*m),K=ne*m,se=E+X+K+L;B=C[se]}const U=E+R+F+L;l[U]=B}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const Fge=Nt(Oh,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Lge={kernelName:Oh,backendName:"cpu",kernelFunc:Fge};function Mge(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:a}=e,{shape:i}=s,{sliceRank:o,numUpdates:l,sliceSize:h,strides:d,outputSize:f}=qo(a,r,i),m=!0,y=t.bufferSync(r),b=t.bufferSync(a),x=Ml(y,b,i,f,h,l,o,d,0,m);return t.makeTensorInfo(i,x.dtype,x.values)}const zge={kernelName:rx,backendName:"cpu",kernelFunc:Mge};function Pge(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<e?t=r+1:s=r;return s}function Bge(n,e){let t=0,s=n.length,r=0;for(;t<s;)r=Math.floor((t+s)/2),n[r]<=e?t=r+1:s=r;return s}function Vge(n,e,t,s,r,a){const i=tn("int32",t*r);for(let o=0;o<t;++o){const l=n.slice(o*s,(o+1)*s),h=o*r;for(let d=0;d<r;++d)i[h+d]=a==="left"?Pge(l,e[d+h]):Bge(l,e[d+h])}return i}function Uge(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:a}=e,{side:i}=s,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,h=Vge(o,l,r.shape[0],r.shape[1],a.shape[1],i);return t.makeTensorInfo(a.shape,"int32",h)}const jge={kernelName:ix,backendName:"cpu",kernelFunc:Uge};function Wge(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:a}=e;Oe([s,r,a],"select");const i=s.shape.length,o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=_s(r.dtype,a.dtype),f=Yn(he(r.shape),d);let m=0;const y=i===0||i>1||r.shape.length===1?1:he(r.shape.slice(1));for(let b=0;b<o.length;b++)for(let x=0;x<y;x++)o[b]===1?f[m++]=l[b]:f[m++]=h[b];return t.makeTensorInfo(r.shape,d,f)}const Gge={kernelName:pm,backendName:"cpu",kernelFunc:Wge};const Hge=cw,qge=hw,Kge=Nt(Lh,n=>n>=0?qge*n:Hge*(Math.exp(n)-1)),Xge={kernelName:Lh,backendName:"cpu",kernelFunc:Kge};const Yge=Nt(Ph,n=>n<0?-1:n>0?1:0),Jge={kernelName:Ph,backendName:"cpu",kernelFunc:Yge};const Zge=Nt(Mh,n=>Math.sin(n)),Qge={kernelName:Mh,backendName:"cpu",kernelFunc:Zge};const eye=Nt(zh,n=>Math.sinh(n)),tye={kernelName:zh,backendName:"cpu",kernelFunc:eye};const nye=11920928955078125e-23,N3=Math.log(nye)+2,sye=Nt(Vh,n=>{const e=n>-N3,t=n<N3,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),rye={kernelName:Vh,backendName:"cpu",kernelFunc:sye};function aye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,paddings:i}=s;Oe([r],"spaceToBatchND");const o=he(a),l=[[0,0]];l.push(...i);for(let _=1+a.length;_<r.shape.length;++_)l.push([0,0]);const h=RV.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),d=Wm(h.shape,a,o,!1),f=Gm(d.length,a.length,!1),m=Hm(h.shape,a,o,!1),x=zt({inputs:{x:h},backend:t,attrs:{shape:d}}),C=Fs({inputs:{x},backend:t,attrs:{perm:f}}),E=zt({inputs:{x:C},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(C),E}const iye={kernelName:ym,backendName:"cpu",kernelFunc:aye};function oye(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=t.data.get(s.dataId).values,l=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(i.dataId).values[0],[f,m,y,b,x]=nV(o,s.shape,s.dtype,l,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,f),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const lye={kernelName:ox,backendName:"cpu",kernelFunc:oye};function uye(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(t.data.get(r.dataId).values),o=t.data.get(s.dataId).values,l=Array.from(t.data.get(a.dataId).values),[h,d,f]=sV(o,s.shape,s.dtype,i,l);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}const cye={kernelName:lx,backendName:"cpu",kernelFunc:uye};function hye(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,[h,d]=XE(i,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(d,s.dtype,h)}const dye={kernelName:ux,backendName:"cpu",kernelFunc:hye};function fye(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,[h,d]=XE(i,s.shape,s.dtype,o,l);return t.makeTensorInfo(d,s.dtype,h)}const pye={kernelName:cx,backendName:"cpu",kernelFunc:fye};function mye(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:i}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:h,sliceSize:d,strides:f,outputSize:m}=qo(a,r,o),y=!1,b=t.bufferSync(r);let x;switch(a.dtype){case"bool":{const w=t.bufferSync(a),v=!!t.data.get(i.dataId).values[0];x=Ml(b,w,o,m,d,h,l,f,v,y);break}case"float32":{const w=t.bufferSync(a),v=t.data.get(i.dataId).values[0];x=Ml(b,w,o,m,d,h,l,f,v,y);break}case"int32":{const w=t.bufferSync(a),v=t.data.get(i.dataId).values[0];x=Ml(b,w,o,m,d,h,l,f,v,y);break}case"string":{const w=t.bufferSync(a),v=ki(t.data.get(i.dataId).values[0]);x=Ml(b,w,o,m,d,h,l,f,v,y);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return t.makeTensorInfo(o,x.dtype,x.values)}const gye={kernelName:hx,backendName:"cpu",kernelFunc:mye};function yye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:a,axis:i}=s,o=at(i,r.shape)[0],l=lk(r,a,o),h=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(f=>{const m=[...d];m[o]=f;const y=iu({inputs:{x:r},backend:t,attrs:{begin:h,size:m}});return h[o]+=f,y})}const bye={kernelName:bm,backendName:"cpu",kernelFunc:yye};const xye={kernelName:dx,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Oe(t,"square");const r=s.data.get(t.dataId).values,a=new Float32Array(r.length);for(let o=0;o<r.length;++o){const l=r[o];a[o]=l*l}return{dataId:s.write(a,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};const wye=Nt(Kh,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),vye={kernelName:Kh,backendName:"cpu",kernelFunc:wye};function Sye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:h,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:m}=s;Oe(r,"stridedSlice");const{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:v,begin:C,end:N,strides:k}=jN(r.shape,a,i,o,l,h,d,f,m);let E;if(x)E=zt({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const _=BN(C,N,k),R=iu({inputs:{x:r},backend:t,attrs:{begin:C,size:_}});E=zt({inputs:{x:R},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(R)}else{const _=t.bufferSync(r),R=iV(y,_,k,C);E=t.makeTensorInfo(b,R.dtype,R.values)}return E}const Tye={kernelName:fx,backendName:"cpu",kernelFunc:Sye};function Cye(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:h}=s,{data:d,dataSplits:f}=e,m=t.data.get(d.dataId).values,y=t.data.get(f.dataId).values,[b,x]=oV(m,y,r,a,i,o,l,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(f.shape,"int32",x)]}const Nye={kernelName:px,backendName:"cpu",kernelFunc:Cye};function kye(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=t.data.get(a.dataId).values,l=t.data.get(i.dataId).values[0],[h,d,f]=lV(o,l,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const Eye={kernelName:mx,backendName:"cpu",kernelFunc:kye};function $ye(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.data.get(a.dataId).values,o=uV(i,r);return t.makeTensorInfo(a.shape,"int32",o)}const Iye={kernelName:gx,backendName:"cpu",kernelFunc:$ye};const _ye=Nt(Gh,n=>Math.tan(n)),Aye={kernelName:Gh,backendName:"cpu",kernelFunc:_ye};const Rye=Nt(Hh,n=>Math.tanh(n)),Dye={kernelName:Hh,backendName:"cpu",kernelFunc:Rye};function Oye(n){const{inputs:e,backend:t}=n,{tensor:s,indices:r,updates:a}=e,{sliceRank:i,numUpdates:o,sliceSize:l,strides:h,outputSize:d}=qo(a,r,s.shape),f=!1,m=t.bufferSync(r),y=t.bufferSync(a),b=t.bufferSync(s),x=Ml(m,y,s.shape,d,l,o,i,h,b,f);return t.makeTensorInfo(s.shape,x.dtype,x.values)}const Fye={kernelName:ax,backendName:"cpu",kernelFunc:Oye};function Lye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:a}=s;Oe(r,"tile");const i=hV(t.bufferSync(r),a);return t.makeTensorInfo(i.shape,i.dtype,i.values)}const Mye={kernelName:qh,backendName:"cpu",kernelFunc:Lye};function zye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:a,sorted:i}=s;Oe(r,"topk");const o=t.data.get(r.dataId).values,[l,h]=fV(o,r.shape,r.dtype,a,i);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(h.shape,h.dtype,h.values)]}const Pye={kernelName:yx,backendName:"cpu",kernelFunc:zye};function Bye(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:h}=t,[d,f,m,y]=r.shape,[b,x]=h??[f,m],w=[d,b,x,y],v=Pe(r.shape),C=v[0],N=v[1],k=v[2],E=Pe(w),_=E[0],R=E[1],D=E[2],F=zn(r.dtype,he(w));F.fill(l);const L=s.data.get(r.dataId).values,A=s.data.get(a.dataId).values;for(let q=0;q<d;++q){const ne=a.shape[0]===1?A:A.subarray(q*8,q*8+8);for(let Q=0;Q<b;++Q)for(let B=0;B<x;++B)for(let U=0;U<y;++U){let X;const K=ne[6]*B+ne[7]*Q+1;if(K===0)continue;const se=(ne[0]*B+ne[1]*Q+ne[2])/K,P=(ne[3]*B+ne[4]*Q+ne[5])/K,j=k3(se,m,o),te=k3(P,f,o);switch(i){case"nearest":X=Hye(L,f,m,C,N,k,q,te,j,U,l);break;case"bilinear":X=qye(L,f,m,C,N,k,q,te,j,U,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const oe=q*_+Q*R+B*D+U;F[oe]=X}return s.makeTensorInfo(w,r.dtype,F)}return{dataId:s.write(F,w,r.dtype),shape:r.shape,dtype:r.dtype}}const Vye={kernelName:bx,backendName:"cpu",kernelFunc:Bye};function k3(n,e,t){switch(t){case"reflect":return Uye(n,e);case"wrap":return jye(n,e);case"nearest":return Gye(n,e);default:return Wye(n)}}function Uye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return $o(0,t,e-1)}function jye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return $o(0,t,e-1)}function Wye(n,e){return n}function Gye(n,e){return $o(0,n,e-1)}function Nf(n,e,t,s,r,a,i,o,l,h,d){const f=i*s+o*r+l*a+h;return 0<=o&&o<e&&0<=l&&l<t?n[f]:d}function Hye(n,e,t,s,r,a,i,o,l,h,d){const f=Math.round(o),m=Math.round(l);return Nf(n,e,t,s,r,a,i,f,m,h,d)}function qye(n,e,t,s,r,a,i,o,l,h,d){const f=Math.floor(o),m=Math.floor(l),y=f+1,b=m+1,x=(b-l)*Nf(n,e,t,s,r,a,i,f,m,h,d)+(l-m)*Nf(n,e,t,s,r,a,i,f,b,h,d),w=(b-l)*Nf(n,e,t,s,r,a,i,y,m,h,d)+(l-m)*Nf(n,e,t,s,r,a,i,y,b,h,d);return(y-o)*x+(o-f)*w}function Kye(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:a}=e;Oe(a,"unique");const i=s.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:h}=pV(i,r,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const Xye={kernelName:xx,backendName:"cpu",kernelFunc:Kye};function Yye(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r.shape.length,o=r.shape[a],l=new Array(i-1);let h=0;for(let y=0;y<i;y++)y!==a&&(l[h++]=r.shape[y]);const d=new Array(i).fill(0),f=r.shape.slice();f[a]=1;const m=new Array(o);for(let y=0;y<m.length;y++){d[a]=y;const b=iu({inputs:{x:r},backend:t,attrs:{begin:d,size:f}});m[y]=zt({inputs:{x:b},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(b)}return m}const Jye={kernelName:vm,backendName:"cpu",kernelFunc:Yye};function Zye(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:a}=e,{numSegments:i}=s;Oe(r,"unsortedSegmentSum");const o=r.shape.length,l=a.shape.length,h=[],d=[],f=o-l;let m=a;for(let b=0;b<f;++b){const x=J0({inputs:{input:m},backend:t,attrs:{dim:b+1}});m=x,d.push(x)}for(let b=0;b<i;++b){const x=Oi(b,"int32"),w=t.makeTensorInfo([],"int32",x),v=I4({inputs:{a:w,b:m},backend:t}),C=zo({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),N=Dw({inputs:{a:C,b:r},backend:t}),k=sg({inputs:{x:N},backend:t,attrs:{axis:0,keepDims:!1}});h.push(k),d.push(w),d.push(v),d.push(C),d.push(N),d.push(k)}const y=AV({inputs:h,backend:t,attrs:{axis:0}});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const Qye={kernelName:Sm,backendName:"cpu",kernelFunc:Zye};const e0e=[Kde,Ihe,Yde,Zde,Fhe,efe,nfe,rfe,ife,lfe,cfe,dfe,pfe,yfe,xfe,Sfe,Cfe,kfe,$fe,Hde,_fe,Rfe,Ofe,Mhe,Lfe,Dhe,Phe,zfe,_he,Bfe,Ufe,jfe,Gfe,qfe,Xfe,Jfe,Qfe,tpe,spe,ape,ope,upe,hpe,fpe,ppe,gpe,bpe,wpe,vpe,Spe,Tpe,Npe,$pe,Pde,_pe,Bhe,zpe,Vhe,Ppe,jhe,Gpe,Hpe,Kpe,Ghe,qhe,Ype,Zpe,eme,nme,Xhe,Jhe,Ahe,rme,Vfe,ime,lme,cme,Bde,Qhe,tde,dme,sde,pme,yme,xme,Sme,Cme,kme,Eme,ade,Ime,Ame,Dme,Fme,Mme,Pme,Vme,ode,jme,Hme,Xme,ude,hde,Zme,tge,rge,fde,ige,lge,uge,RV,fge,Ude,gde,mge,yge,xge,vge,Rhe,dC,Tge,jde,Wde,Gde,Nge,Ege,Ige,Age,Dge,Oge,Lge,Cde,zge,jge,Gge,Xge,kde,Jge,Qge,tye,Ede,qme,rye,iye,lye,cye,dye,pye,gye,bye,_de,xye,Rde,Ode,vye,Tye,Nye,Eye,Iye,zde,kpe,Aye,Dye,Fye,Mye,Pye,Vye,pde,Xye,Jye,Qye,oge];for(const n of e0e)vx(n);const Rl={},jy={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function DV(n,e){Rl[n]=e}function wa(n,e){if(!(n in Rl)||e!=null){const s=n0e(n,e);if(s!==null)Rl[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=Rl[n];return t==null||t.isContextLost()?(delete Rl[n],wa(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Rl[n])}function t0e(n){if(!ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function n0e(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??t0e(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Rl[n]},!1),ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(jy.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",jy)||t.getContext("experimental-webgl",jy):t.getContext("webgl2",jy)}var hp;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(hp||(hp={}));var xr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(xr||(xr={}));var Kn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Kn||(Kn={}));function rg(n,e){return[e,n]}function s0e(n,e){return n*e}function Wy(n){const e=he(n),t=Math.ceil(e/4);return k0(t)}function ud(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function r0e(n,e){const[t,s]=ud(n,e);return t*s*4}function e$(n,e){const t=n;let s,r,a,i,o,l,h,d,f,m;return ie().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,a=t.RGBA16F,i=t.RGBA32F,o=t.RED,h=4,d=1,f=t.HALF_FLOAT,m=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,a=n.RGBA,i=t.RGBA,o=n.RGBA,h=4,d=4,f=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:h,defaultNumChannels:d,textureTypeHalfFloat:f,textureTypeFloat:m}}function Ie(n,e){const t=e();return ie().getBool("DEBUG")&&a0e(n),t}function a0e(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+FV(n,e))}const i0e=596e-10,o0e=65504;function OV(n){return!!(ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||i0e<Math.abs(n)&&Math.abs(n)<o0e)}function FV(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function kf(n,e){return Vi(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function LV(n,e){const t=Vi(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ie(n,()=>n.shaderSource(t,e)),Ie(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function MV(n,e){const t=Vi(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ie(n,()=>n.shaderSource(t,e)),Ie(n,()=>n.compileShader(t)),ie().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw t$(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const l0e=/ERROR: [0-9]+:([0-9]+):/g;function t$(n,e){const t=l0e.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),a=r.length.toString().length+2,i=r.map((f,m)=>Vl((m+1).toString(),a)+f);let o=0;for(let f=0;f<i.length;f++)o=Math.max(i[f].length,o);const l=i.slice(0,s-1),h=i.slice(s-1,s),d=i.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Vl(h[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function zV(n){return Vi(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function PV(n,e){if(Ie(n,()=>n.linkProgram(e)),!ie().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function l0(n,e){if(Ie(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function BV(n,e){const t=Vi(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Ie(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function VV(n,e){const t=Vi(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ie(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Ie(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function u0e(){return ie().getNumber("WEBGL_VERSION")===2?1:4}function UV(n){return Vi(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function jV(n,e){const t=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function WV(n){return Vi(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function pC(n,e,t,s,r,a,i){const o=n.getAttribLocation(e,t);return o===-1?!1:(Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Ie(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,a,i)),Ie(n,()=>n.enableVertexAttribArray(o)),!0)}function GV(n,e,t){YV(n,t),Ie(n,()=>n.activeTexture(n.TEXTURE0+t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function c0e(n,e){YV(n,e),Ie(n,()=>n.activeTexture(n.TEXTURE0+e)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function HV(n,e,t){return Vi(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function qV(n,e,t){return n.getUniformLocation(e,t)}function KV(n,e,t,s){Ie(n,()=>GV(n,e,s)),Ie(n,()=>n.uniform1i(t,s))}function h0e(n){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),Ie(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),Ie(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function u0(n,e,t){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Ie(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function mC(n,e){Ie(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Ie(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ef(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+XV(n,e))}function XV(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Vi(n,e,t){const s=Ie(n,()=>e());if(s==null)throw new Error(t);return s}function YV(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function ou(n,e=2){return he(n.slice(0,n.length-e))}function lu(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function $f(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ou(n),...lu(n)]),e}function JV(n,e=!1){let t=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,l)=>l>=n.length-2?pb(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Di(n).newShape);let r=he(n),a=null;n.length<=1&&r<=t?a=[1,r]:n.length===2&&n[0]<=t&&n[1]<=t?a=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?a=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?a=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?a=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(a=[n[0],n[1]*n[2]*n[3]]);const i=a!=null&&Math.max(...a)>s&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||i)if(e){const o=ou(n);let l=2,h=2;n.length&&([l,h]=lu(n)),r=o*(l/2)*(h/2),a=k0(r).map(d=>d*2)}else a=k0(r);return a}function Gy(n){return n%2===0}function dp(n,e){if(n=n.slice(-2),e=e.slice(-2),lt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Gy(t)&&Gy(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Gy(n[0])&&Gy(e[0])}let c0,h0;function ZV(n){if(c0==null){const e=wa(n);c0=e.getParameter(e.MAX_TEXTURE_SIZE)}return c0}function d0e(){c0=null}function f0e(){h0=null}function QV(n){if(h0==null){const e=wa(n);h0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,h0)}function eU(n){if(n===0)return 0;let e;const t=wa(n);return wr(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:wr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function wr(n,e){return n.getExtension(e)!=null}function gC(n){try{if(wa(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function tU(n){if(n===0)return!1;const e=wa(n);if(n===1){if(!wr(e,"OES_texture_float"))return!1}else if(!wr(e,"EXT_color_buffer_float"))return!1;return yC(e)}function nU(n){if(n===0)return!1;const e=wa(n);if(n===1){if(!wr(e,"OES_texture_float")||!wr(e,"WEBGL_color_buffer_float"))return!1}else{if(wr(e,"EXT_color_buffer_float"))return yC(e);const s="EXT_color_buffer_half_float";if(wr(e,s)){const r=e.getExtension(s);return p0e(e,r)}return!1}return yC(e)}function yC(n){const e=e$(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(a),i}function p0e(n,e){const t=e$(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(i),o}function sU(n){return n!==2?!1:wa(n).fenceSync!=null}function cd(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const m0e=Object.freeze(Object.defineProperty({__proto__:null,assertNotComplex:cd,bindCanvasToFramebuffer:h0e,bindColorTextureToFramebuffer:u0,bindTextureToProgramUniformSampler:KV,bindTextureUnit:GV,bindVertexBufferToProgramAttribute:pC,callAndCheck:Ie,canBeRepresented:OV,createFragmentShader:MV,createFramebuffer:WV,createProgram:zV,createStaticIndexBuffer:VV,createStaticVertexBuffer:BV,createTexture:UV,createVertexShader:LV,getBatchDim:ou,getExtensionOrThrow:kf,getFramebufferErrorMessage:XV,getMaxTexturesInShader:QV,getNumChannels:u0e,getProgramUniformLocation:qV,getProgramUniformLocationOrThrow:HV,getRowsCols:lu,getShapeAs3D:$f,getTextureShapeFromLogicalShape:JV,getWebGLDisjointQueryTimerVersion:eU,getWebGLErrorMessage:FV,getWebGLMaxTextureSize:ZV,hasExtension:wr,isCapableOfRenderingToFloatTexture:tU,isDownloadFloatTextureEnabled:nU,isReshapeFree:dp,isWebGLFenceEnabled:sU,isWebGLVersionEnabled:gC,linkProgram:PV,logShaderSourceAndInfoLog:t$,resetMaxTextureSize:d0e,resetMaxTexturesInShader:f0e,unbindColorTextureFromFramebuffer:mC,unbindTextureUnit:c0e,validateFramebuffer:Ef,validateProgram:l0,validateTextureSize:jV},Symbol.toStringTag,{value:"Module"}));const Le=ie();Le.registerFlag("HAS_WEBGL",()=>Le.getNumber("WEBGL_VERSION")>0);Le.registerFlag("WEBGL_VERSION",()=>gC(2)?2:gC(1)?1:0);Le.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Le.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Le.get("WEBGL_VERSION")===2);Le.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Le.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Le.registerFlag("WEBGL_PACK",()=>Le.getBool("HAS_WEBGL"));Le.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_CLIP",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_REDUCE",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_LAZILY_UNPACK",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_CONV_IM2COL",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>ZV(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>QV(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Le.getNumber("WEBGL_VERSION");return n===0?0:eU(n)});Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!y2());Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>tU(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Le.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>nU(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_FENCE_API_ENABLED",()=>sU(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Le.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Le.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>y2()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Le.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Le.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Le.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Le.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Le.registerFlag("WEBGL_EXP_CONV",()=>!1);Le.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Le.getBool("IS_TEST"));Le.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Le.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Le.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Le.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Ss(){let n,e,t,s,r,a,i,o,l,h;return ie().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",a="outputColor",i="out vec4 outputColor;",o=ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",h=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,h=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:h}}function vu(n,e,t="index"){const s=Pe(e);return s.map((r,a)=>{const i=`int ${n[a]} = ${t} / ${r}`,o=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r}`:`index -= ${n[a]} * ${r}`;return`${i}; ${o};`}).join("")}function Ow(n,e,t="index"){const s=Pe(e);return s.map((r,a)=>{const i=`int ${n[a]} = ${t} / outShapeStrides[${a}]`,o=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * outShapeStrides[${a}]`:`index -= ${n[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function g0e(n,e){const t=n.length,s=n.map(a=>`${e}[${a}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let a=t-3;a>=0;--a)r[a]=`(${r[a+1]} * ${s[a+1]})`;return r}function y0e(n,e,t="index"){const s=n.map((a,i)=>i),r=g0e(s,e);return r.map((a,i)=>{const o=`int ${n[i]} = ${t} / ${r[i]}`,l=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r[i]}`:`index -= ${n[i]} * ${r[i]}`;return`${o}; ${l};`}).join("")}function n$(n){const e=Pe(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function s$(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const rU=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:aU}=PP;function b0e(n,e,t){const s=[];if(n.forEach(y=>{const b=he(y.shapeInfo.logicalShape);if(y.shapeInfo.isUniform?s.push(`uniform float ${y.name}${b>1?`[${b}]`:""};`):(s.push(`uniform sampler2D ${y.name};`),s.push(`uniform int offset${y.name};`)),t.enableShapeUniforms){const{uniformShape:x}=r$(t.packedInputs,y.shapeInfo.logicalShape,y.shapeInfo.texShape);switch(x.length){case 1:s.push(`uniform int ${y.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${y.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${y.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${y.name}Shape;`);break}s.push(`uniform ivec2 ${y.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(y=>{s.push(`uniform ${y.type} ${y.name}${y.arrayIndex?`[${y.arrayIndex}]`:""};`)});const r=s.join(`
`),a=n.map(y=>x0e(y,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,o=Ss(),l=S0e(o);let h,d,f=N0e(o);return e.isPacked?(h=w0e(e.logicalShape,i,t.enableShapeUniforms),d=C0e(o)):(h=v0e(e.logicalShape,i,t.enableShapeUniforms),d=T0e(o)),t.packedInputs&&(f+=I0e),[f,l,d,r,h,a,t.userCode].join(`
`)}function hd(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return V0e(n,e);case 1:return j0e(n,e);case 2:return G0e(n,e);case 3:return q0e(n,e);case 4:return X0e(n,e);case 5:return Y0e(n);case 6:return J0e(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function iU(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return B0e(n);case 1:return U0e(n,e);case 2:return W0e(n,e);case 3:return H0e(n,e);default:return K0e(n,e)}}function x0e(n,e,t=!1,s){let r="";t?r+=iU(n,s):r+=hd(n,s);const a=n.shapeInfo.logicalShape,i=e.logicalShape;return a.length<=i.length&&(t?r+=Z0e(n,e):r+=Q0e(n,e)),r}function w0e(n,e,t){switch(n.length){case 0:return oU();case 1:return _0e(n,e,t);case 2:return z0e(n,e,t);case 3:return R0e(n,e,t);default:return O0e(n,e,t)}}function v0e(n,e,t){switch(n.length){case 0:return oU();case 1:return A0e(n,e,t);case 2:return P0e(n,e,t);case 3:return D0e(n,e,t);case 4:return F0e(n,e,t);case 5:return L0e(n,e);case 6:return M0e(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function S0e(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function T0e(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function C0e(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function N0e(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${k0e}
    ${E0e}
    ${$0e}
  `}const k0e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,E0e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$0e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,I0e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function oU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function _0e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function A0e(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function R0e(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),a=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function D0e(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ow(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=vu(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function O0e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),a=r*Math.ceil(n[n.length-2]/2);let i=a,o="",l="b, r, c";for(let h=2;h<n.length-1;h++)i*=n[n.length-h-1],o=`
      int b${h} = index / ${i};
      index -= b${h} * ${i};
    `+o,l=`b${h}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function F0e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ow(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=vu(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function L0e(n,e){const t=vu(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function M0e(n,e){const t=vu(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function z0e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(lt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function P0e(n,e,t){return lt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Su(n){return`offset${n}`}function B0e(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Ss();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function V0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,a]=n.shapeInfo.texShape;if(r===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Su(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;const[o,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function U0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,a=Ss();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${t}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }
  `}function j0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${dd(n)}
      }
    `;const r=n.shapeInfo.texShape,a=r[0],i=r[1];if(i===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Su(t);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${t}, uv);
      }
    `:a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function W0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,i=a[0],o=a[1],l=Ss();if(a!=null&&lt(t,a))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${h[0]}, ${h[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function G0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape;if(a!=null&&lt(t,a)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const m=a[0],y=a[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${y}.0, ${m}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:o}=Di(t),l=i;if(l.length<t.length){const m=fd(n,l),y=["row","col"];return`
      ${hd(m,e)}
      float ${r}(int row, int col) {
        return ${r}(${pd(y,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${dd(n)}
      }
    `;const h=a[0],d=a[1],f=Su(s);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `:h===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${h}, ${d}, index);
    return sampleTexture(${s}, uv);
  }
`}function H0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(t[0]===1){const m=t.slice(1),y=[1,2],b=fd(n,m),x=["b","row","col"];return`
        ${iU(b,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${pd(x,y)});
        }
      `}const o=Ss();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=i[0],h=i[1],d=Math.ceil(t[2]/2),f=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${h}, ${f}, ${d}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function q0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t[1]*t[2],i=t[2],{newShape:o,keptDims:l}=Di(t),h=o;if(h.length<t.length){const x=fd(n,h),w=["row","col","depth"];return`
        ${hd(x,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${pd(w,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${dd(n)}
      }
    `;const d=n.shapeInfo.texShape,f=d[0],m=d[1],y=n.shapeInfo.flatOffset;if(m===a&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(m===i&&y==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${s}, uv);
    }
  `;const b=Su(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${b};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${s}, uv);
      }
  `}function K0e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Ss();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const a=n.shapeInfo.logicalShape,i=a.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],h=l[0],d=l[1],f=Math.ceil(a[i-1]/2);let m=f*Math.ceil(a[i-2]/2),y="int b, int row, int col",b=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let x=2;x<i-1;x++)y=`int b${x}, `+y,m*=a[i-x-1],b=`b${x} * ${m} + `+b;return`
    vec4 ${s}(${y}) {
      int index = ${b};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${h});
      return ${r.texture2D}(${t}, uv);
    }
  `}function X0e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t[3],i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:h}=Di(t);if(l.length<t.length){const C=fd(n,l),N=["row","col","depth","depth2"];return`
      ${hd(C,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${pd(N,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],y=f[1],b=`int stride2 = ${s}Shape[3];`,x=`int stride1 = ${s}Shape[2] * stride2;`,w=`int stride0 = ${s}Shape[1] * stride1;`;if(y===o&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(y===a&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=Su(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${x}
      ${w}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${m}, ${y}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function Y0e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],a=e[3]*r,i=e[2]*a,o=e[1]*i,{newShape:l,keptDims:h}=Di(e);if(l.length<e.length){const x=fd(n,l),w=["row","col","depth","depth2","depth3"];return`
      ${hd(x)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${pd(w,h)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${r})) +
          depth3;
        ${dd(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],y=f[1];if(y===o&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(y===r&&d==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;const b=Su(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${y}, index);
      return sampleTexture(${t}, uv);
    }
  `}function J0e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:a}=Di(e);if(r.length<e.length){const w=fd(n,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${hd(w)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${pd(v,a)});
      }
    `}const i=e[5],o=e[4]*i,l=e[3]*o,h=e[2]*l,d=e[1]*h;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${h}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${dd(n)}
      }
    `;const f=n.shapeInfo.flatOffset,m=n.shapeInfo.texShape,y=m[0],b=m[1];if(b===d&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${h}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(b===i&&f==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${y}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=Su(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${h} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${x};
      vec2 uv = uvFromFlat(${y}, ${b}, index);
      return sampleTexture(${t}, uv);
    }
  `}function dd(n){const e=n.name,t=he(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Z0e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",a=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,o=aU(n.shapeInfo.logicalShape,e.logicalShape),l=It(i),h=i-a;let d;const f=["x","y","z","w","u","v"];a===0?d="":i<2&&o.length>=1?d="coords = 0;":d=o.map(C=>`coords.${f[C+h]} = 0;`).join(`
`);let m="";i<2&&a>0?m="coords":m=n.shapeInfo.logicalShape.map((C,N)=>`coords.${f[N+h]}`).join(", ");let y="return outputValue;";const x=he(n.shapeInfo.logicalShape)===1,v=he(e.logicalShape)===1;if(a===1&&!x&&!v)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!v)i===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(o.length){const C=a-2,N=a-1;o.indexOf(C)>-1&&o.indexOf(N)>-1?y="return vec4(outputValue.x);":o.indexOf(C)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(N)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${s}(${m});
      ${y}
    }
  `}function Q0e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",a=e.texShape,i=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&n.shapeInfo.flatOffset==null&&lt(i,a))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const h=It(l),d=aU(n.shapeInfo.logicalShape,e.logicalShape),f=l-o;let m;const y=["x","y","z","w","u","v"];o===0?m="":l<2&&d.length>=1?m="coords = 0;":m=d.map(x=>`coords.${y[x+f]} = 0;`).join(`
`);let b="";return l<2&&o>0?b="coords":b=n.shapeInfo.logicalShape.map((x,w)=>`coords.${y[w+f]}`).join(", "),`
    float ${r}() {
      ${h} coords = getOutputCoords();
      ${m}
      return get${s}(${b});
    }
  `}function It(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function r$(n,e,t){const{newShape:s,keptDims:r}=Di(e),a=e.length,i=n&&a===3&&e[0]===1,o=i?e.slice(1):s,l=!n&&a>1&&!lt(e,t)&&s.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:r}}function fd(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function pd(n,e){return e.map(t=>n[t]).join(", ")}function ebe(n,e,t,s){const r=t.map((d,f)=>{const m={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(m.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:m}}),a=r.map(d=>d.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=b0e(r,i,e),l=MV(n.gl,o),h=n.createProgram(l);return ie().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:h,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:h,inShapeInfos:a,outShapeInfo:i},lU(n,e,h)))}function lU(n,e,t){const s=[],r=[];let a,i,o,l=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ie().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const f of e.variableNames){const m={name:f,uniform:n.getUniformLocation(t,f,d),offset:n.getUniformLocation(t,`offset${f}`,d)};e.enableShapeUniforms&&(m.shape=n.getUniformLocation(t,`${f}Shape`,d),m.texShape=n.getUniformLocation(t,`${f}TexShape`,d)),s.push(m)}if(e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",d),o=n.getUniformLocation(t,"outShapeStrides",d),i=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const f of e.customUniforms)r.push(n.getUniformLocation(t,f.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:h,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function E3(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,a=e[s],i=a.shape;if(!lt(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(t.isUniform&&a.isUniform)return;const o=t.texShape,l=a.isUniform?null:a.texData.texShape;if(!lt(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function tbe(n,e,t,s,r){e.program.enableShapeUniforms||(E3(e.inShapeInfos,t),E3([e.outShapeInfo],[s]));const a=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):n.setOutputMatrixTexture(a.texture,i[0],i[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ie().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const h=t[l],{uniform:d,offset:f,shape:m,texShape:y}=e.variablesLocations[l];if(m){const{uniformShape:b}=r$(e.program.packedInputs,h.shape,h.texData.texShape);switch(b.length){case 1:n.gl.uniform1iv(m,new Int32Array(b));break;case 2:n.gl.uniform2iv(m,new Int32Array(b));break;case 3:n.gl.uniform3iv(m,new Int32Array(b));break;case 4:n.gl.uniform4iv(m,new Int32Array(b));break}}if(y&&n.gl.uniform2i(y,h.texData.texShape[0],h.texData.texShape[1]),d!=null){if(h.isUniform){if(he(h.shape)<2)n.gl.uniform1f(d,h.uniformValues[0]);else{let b=h.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),n.gl.uniform1fv(d,b)}continue}h.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture.texture,d,l)}}const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=Pe(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let l=0;l<e.program.customUniforms.length;++l){const h=e.program.customUniforms[l],d=e.customUniformLocations[l],f=r[l];if(h.type==="float")n.gl.uniform1fv(d,f);else if(h.type==="vec2")n.gl.uniform2fv(d,f);else if(h.type==="vec3")n.gl.uniform3fv(d,f);else if(h.type==="vec4")n.gl.uniform4fv(d,f);else if(h.type==="int")n.gl.uniform1iv(d,f);else if(h.type==="ivec2")n.gl.uniform2iv(d,f);else if(h.type==="ivec3")n.gl.uniform3iv(d,f);else if(h.type==="ivec4")n.gl.uniform4iv(d,f);else throw Error(`uniform type ${h.type} is not supported yet.`)}n.executeProgram()}function nbe(n,e,t){let s="";e.concat(t).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:h,uniformShape:d,keptDims:f}=r$(n.packedInputs,i.shape,l);let m="",y="",b="";if(d.length===1&&n.packedInputs){const E=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];m=`${E[0]>1}_${E[1]>1}`}else if(d.length===2&&!n.packedInputs)y=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!n.packedInputs){const E=Pe(d);b=`${E[0]===l[1]}_${E[E.length-1]===l[1]}`}const x=i.shape.length,w=d.length===2&&lt(i.shape,l),v=he(i.shape)===1,C=Zl(i.shape,t.shape),N=!n.packedInputs&&x===t.shape.length&&lt(l,t.texData.texShape),k=n.packedInputs||d.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${x}_${N}_${h?f:""}_${d.length}_${v}_${C}_${w}_${m}_${y}_${b}_${k}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${l}_${o}`}});const r=n.userCode;let a=n.constructor.name;return a+="_"+s+"_"+r+`${ie().getNumber("WEBGL_VERSION")}`,a}function hs(n){return ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class sbe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=hp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ow(["r","c","d"],e):vu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class rbe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=hp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ow(["r","c","d"],e):vu(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class abe{constructor(e){this.variableNames=["A"],this.outTexUsage=xr.DOWNLOAD;const t=Ss();this.outputShape=e,this.userCode=`
      ${rU}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class ibe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=xr.DOWNLOAD;const t=Ss();this.outputShape=e,this.userCode=`
      ${rU}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}const obe={R:0,G:1,B:2,A:3};class $3{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<s.length;o++){const l=s[o];i+=`
          if(offset == ${o}) {
            result = values[${obe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?s$():n$(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}class lbe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ss();this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;r+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?s$():n$(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${a};
        }
    `}}function uU(n){const e=Ss(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return LV(n,t)}function cU(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return BV(n,e)}function hU(n){const e=new Uint16Array([0,1,2,2,1,3]);return VV(n,e)}function ag(n,e,t,s,r,a){jV(e,t);const i=UV(n),o=n.TEXTURE_2D;return Ie(n,()=>n.bindTexture(o,i)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Ie(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),ie().getNumber("WEBGL_VERSION")===1?Ie(n,()=>n.texImage2D(o,0,s,e,t,0,r,a,null)):Ie(n,()=>n.texStorage2D(o,1,s,e,t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function a$(n){return n.internalFormatFloat}function dU(n,e,t,s){const[r,a]=rg(e,t);return ag(n,r,a,a$(s),s.textureFormatFloat,n.FLOAT)}function i$(n){return n.internalFormatHalfFloat}function fU(n,e,t,s){const[r,a]=rg(e,t);return ag(n,r,a,i$(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function o$(n){return n.downloadTextureFormat}function pU(n,e,t,s){const[r,a]=rg(e,t);return ag(n,r,a,o$(s),n.RGBA,n.UNSIGNED_BYTE)}function l$(n){return n.internalFormatPackedFloat}function mU(n,e,t,s){const[r,a]=ud(e,t);return ag(n,r,a,l$(s),n.RGBA,n.FLOAT)}function u$(n){return n.internalFormatPackedHalfFloat}function gU(n,e,t,s){const[r,a]=ud(e,t);return ag(n,r,a,u$(s),n.RGBA,s.textureTypeHalfFloat)}function yU(n,e,t){return Ie(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),pC(n,e,"clipSpacePos",t,3,20,0)&&pC(n,e,"uv",t,2,20,12)}function bU(n,e,t,s,r,a){Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(t*s*4),o=n.FLOAT,l=a.internalFormatPackedFloat),i.set(r),ie().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,i)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,o,i)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function xU(n,e,t){Ie(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ie().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ie().getNumber("WEBGL_VERSION")===2?Ie(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Ie(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Ie(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function wU(n,e,t,s){const r=n.createBuffer();Ie(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=4*4*e*t;return Ie(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Ie(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Ie(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function vU(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function SU(n,e,t,s){const[r,a]=rg(e,t),i=4,o=new Uint8Array(s0e(e*t,i));return Ie(n,()=>n.readPixels(0,0,r,a,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function TU(n,e,t,s,r,a,i,o){const l=n,h=new Float32Array(r0e(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,h),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),h}function CU(n,e,t){const s=new Float32Array(e*t*4);return Ie(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}const ube=Object.freeze(Object.defineProperty({__proto__:null,bindVertexProgramAttributeStreams:yU,createBufferFromOutputTexture:wU,createFloat16MatrixTexture:fU,createFloat16PackedMatrixTexture:gU,createFloat32MatrixTexture:dU,createIndexBuffer:hU,createPackedMatrixTexture:mU,createUnsignedBytesMatrixTexture:pU,createVertexBuffer:cU,createVertexShader:uU,downloadByteEncodedFloatMatrixFromOutputTexture:SU,downloadFloat32MatrixFromBuffer:vU,downloadMatrixFromPackedOutputTexture:CU,downloadPackedMatrixFromBuffer:TU,getInternalFormatForFloat16MatrixTexture:i$,getInternalFormatForFloat16PackedMatrixTexture:u$,getInternalFormatForFloat32MatrixTexture:a$,getInternalFormatForPackedMatrixTexture:l$,getInternalFormatForUnsignedBytesMatrixTexture:o$,uploadDenseMatrixToTexture:bU,uploadPixelDataToTexture:xU},Symbol.toStringTag,{value:"Module"}));class d0{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ie().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,DV(t,e)):this.gl=wa(t),e=this.gl,ie().getNumber("WEBGL_VERSION")===2){const a=e;this.createVertexArray=()=>Ie(a,()=>a.createVertexArray()),this.bindVertexArray=i=>Ie(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>Ie(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>Ie(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){const a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ie(e,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>Ie(e,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Ie(e,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>Ie(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ie().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=kf(this.gl,a),wr(this.gl,i))this.textureHalfFloatExtension=kf(this.gl,i);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),wr(this.gl,r))this.colorBufferHalfFloatExtension=kf(this.gl,r);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",wr(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(wr(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=cU(this.gl),this.indexBuffer=hU(this.gl),this.framebuffer=WV(this.gl),this.textureConfig=e$(this.gl,this.textureHalfFloatExtension)}get debug(){return ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ie(e,()=>e.finish()),Ie(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ie(e,()=>e.deleteFramebuffer(this.framebuffer)),Ie(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ie(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ie(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),dU(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),fU(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),pU(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),xU(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),bU(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),gU(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),mU(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(mC(this.gl,this.framebuffer),this.outputTexture=null),Ie(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>SU(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,a,i){return TU(this.gl,e,t,s,r,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return vU(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=wU(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ie().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(a,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},t=a}else ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>CU(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=uU(t));const s=zV(t);Ie(t,()=>t.attachShader(s,this.vertexShader)),Ie(t,()=>t.attachShader(s,e)),PV(t,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&l0(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Ie(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),yU(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ie(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&l0(this.gl,this.program),Ie(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?HV(this.gl,e,t):qV(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ie(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),KV(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,a]=ud(t,s);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&l0(this.gl,this.program),Ef(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ie(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ie(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=kf(this.gl,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await NT(()=>this.disposed||this.isQueryAvailable(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=cbe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ie().platform&&(s=ie().platform.setTimeoutCustom.bind(ie().platform)),NT(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),u0(this.gl,e,this.framebuffer),this.debug&&Ef(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(u0(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ef(this.gl)):mC(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;u0(r,e,this.framebuffer),this.debug&&Ef(r),this.outputTexture=e,Ie(r,()=>r.viewport(0,0,t,s)),Ie(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),Ie(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function cbe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}const{addImpl:hbe,bincountImpl:NU,bincountReduceImpl:dbe,bitwiseAndImpl:fbe,castImpl:pbe,ceilImpl:mbe,concatImpl:gbe,equalImpl:ybe,expImpl:bbe,expm1Impl:xbe,floorImpl:wbe,gatherNdImpl:vbe,gatherV2Impl:Sbe,greaterImpl:Tbe,greaterEqualImpl:Cbe,lessImpl:Nbe,lessEqualImpl:kbe,linSpaceImpl:Ebe,logImpl:$be,maxImpl:Ibe,maximumImpl:_be,minimumImpl:Abe,multiplyImpl:Rbe,negImpl:Dbe,notEqualImpl:Obe,prodImpl:Fbe,raggedGatherImpl:Lbe,raggedRangeImpl:Mbe,raggedTensorToTensorImpl:zbe,rangeImpl:Pbe,rsqrtImpl:Bbe,scatterImpl:Vbe,sigmoidImpl:Ube,simpleAbsImpl:kU,sliceImpl:jbe,sparseFillEmptyRowsImpl:Wbe,sparseReshapeImpl:Gbe,sparseSegmentReductionImpl:EU,sqrtImpl:Hbe,staticRegexReplaceImpl:qbe,stridedSliceImpl:Kbe,stringNGramsImpl:Xbe,stringSplitImpl:Ybe,stringToHashBucketFastImpl:Jbe,subImpl:Zbe,tileImpl:Qbe,topKImpl:exe,transposeImpl:c$,uniqueImpl:txe}=mV;function $U(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function gs(n,e){return e===1?[n]:$U(n,e)}function nxe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}class sxe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=hs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=gs("rc",this.rank),s=It(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${e[e.length-1-i]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}class IU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);let s="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),s+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${rxe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?s$():n$(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function rxe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?y0e(["r","c","d"],"inputShape"):vu(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class axe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const r=_3(t,s),a=A3(e,r,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=I3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let o;return r===Kn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===Kn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===Kn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===Kn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===Kn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const a=_3(s,r),i=A3(t,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=I3(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const h=this.usedTextures[i],d=h&&h.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h[d]=h[h.length-1],h.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function ixe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function I3(n,e,t,s,r){const a=oxe(e,s);let i;if(r){const[l,h]=ud(n[0],n[1]);i=l*h}else{const[l,h]=rg(n[0],n[1]);i=l*h}const o=ixe(t,a);return i*o}function oxe(n,e){switch(n){case Kn.PACKED_2X2_FLOAT32:return l$(e);case Kn.PACKED_2X2_FLOAT16:return u$(e);case Kn.UNPACKED_FLOAT32:return a$(e);case Kn.UNPACKED_FLOAT16:return i$(e);case Kn.PACKED_4X1_UNSIGNED_BYTE:return o$(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function lxe(n){return ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Kn.PACKED_2X2_FLOAT32:Kn.UNPACKED_FLOAT32:n?Kn.PACKED_2X2_FLOAT16:Kn.UNPACKED_FLOAT16}function _3(n,e){if(n===xr.UPLOAD)return Kn.PACKED_2X2_FLOAT32;if(n===xr.RENDER||n==null)return lxe(e);if(n===xr.DOWNLOAD||n===xr.PIXELS)return Kn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function A3(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class La{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Yr="if (isnan(x)) return x;",uxe="return x;",R3="return abs(x);",cxe="return (x >= 0.0) ? x : (exp(x) - 1.0);",hxe=Yr+`
  return (x < 0.0) ? 0.0 : x;
`,dxe=Yr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,go="return x;",fxe="return 1.0 / (1.0 + exp(-1.0 * x));";const pxe="return x;",mxe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,yxe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bxe="return 1.0 / (1.0 + exp(-1.0 * x));";class vo{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class xxe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);const t=e.length,s=gs("rc",t),r=It(t),a=nxe(t,s),i=s.slice(-2),o=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}const wxe=Jx,vxe=1e-7,Sxe=1e-4,Hy={};function Txe(n){return n in Hy||(Hy[n]={}),Hy[n]}const Cxe=ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Nxe=600;function kxe(){return ie().global.screen==null?1024:ie().global.screen.height*ie().global.screen.width*window.devicePixelRatio*Nxe/1024/1024}class ig extends fb{nextDataId(){return ig.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof d0)t=e;else{const s=wa(ie().getNumber("WEBGL_VERSION"),e);t=new d0(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=wa(ie().getNumber("WEBGL_VERSION"));t=new d0(s),this.binaryCache=Txe(ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new axe(this.gpgpu),this.numMBBeforeWarning=kxe(),this.texData=new u2(this,ua())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,r,a,i){const o=this.makeTensorInfo(t,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[r,a]},l.texShape=[r,a];const h=$f(t),d=new $3(h,!1,i),f=this.runWebGLProgram(d,[o],s,[[r,a]]);return f.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(e,t,s){if((ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:xr.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,a){if(ie().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:xr.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=t;if(i!=null){let m;l?m=new vo(o,go):m=new La(o,go);const y=this.runWebGLProgram(m,[{dataId:e,shape:o,dtype:r}],r),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const h=this.activeTimers!=null;let d;h&&(d=Gn());let f;if(r==="complex64"){const m=this.readSync(a.real.dataId),y=this.readSync(a.imag.dataId);f=_i(m,y)}else f=this.getValuesFromTexture(e);return h&&(this.downloadWaitMs+=Gn()-d),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const b=this.pendingRead.get(e);return new Promise(x=>b.push(x))}const t=this.texData.get(e),{values:s,shape:r,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=t;if(a!=null){let b;l?b=new vo(r,go):b=new La(r,go);const x=this.runWebGLProgram(b,[{dataId:e,shape:r,dtype:i}],i),w=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),w}if(s!=null)return this.convertAndCacheOnCPU(e);if(ie().getBool("DEBUG")&&!ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h=null,d;if(i!=="complex64"&&ie().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const b=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(b.texture.texture,...Wy(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(i==="complex64"){const b=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),x=b[0],w=b[1];f=_i(x,w)}else if(h==null)f=this.getValuesFromTexture(e);else{const b=he(r);f=this.gpgpu.downloadFloat32MatrixFromBuffer(h,b)}if(d!=null&&this.disposeIntermediateTensorInfo(d),h!=null){const b=this.gpgpu.gl;Ie(b,()=>b.deleteBuffer(h))}const m=this.convertAndCacheOnCPU(e,f),y=this.pendingRead.get(e);return this.pendingRead.delete(e),y.forEach(b=>b(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ua().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){const s=this.texData.get(e),{values:r,shape:a,slice:i,dtype:o,isPacked:l,texture:h}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let y;l?y=new vo(a,go):y=new La(a,go);const b=this.runWebGLProgram(y,[{dataId:e,shape:a,dtype:o}],o),x=this.readToGPU(b,t);return this.disposeIntermediateTensorInfo(b),x}if(h==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),f=ua().makeTensorFromTensorInfo(d),m=this.texData.get(d.dataId);return Object.assign({tensorRef:f},m.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(r=>ki(r));return tt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tt(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!OV(s))throw ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),a=he(t);if(ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...Wy(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(m),b}const i=ie().getBool("WEBGL_PACK")&&r===!0,o=i?$f(t):t,l=i?new ibe(o):new abe(o),h=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:e}],"float32"),d=this.texData.get(h.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}timerAvailable(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=Wa(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Wa(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=nM(l),o.getExtraProfileInfo=()=>l.map((h,d)=>({name:i[d],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gn(),endMs:null}}endTimer(e){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Gn(),e)}async getQueryTime(e){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:a,isPacked:i,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,h=this.dataRefCount.get(l);h>1?this.dataRefCount.set(l,h-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,a,i)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Cxe){return ie().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&he(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){gr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return wxe(e.shape,t)}packedUnaryOp(e,t,s){const r=new vo(e.shape,t),a=this.compileAndRun(r,[e],s);return ua().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=kU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,R3,e.dtype);const t=new La(e.shape,R3),s=this.compileAndRun(t,[e]);return ua().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Fa(s[0])){const a=s.map(i=>Pa(i));r=this.write(a,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new xxe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new sxe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[ou(e.shape),...lu(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},a=[ou(t),...lu(t)],i=new IU(a,s),o=!0,l=[s],h=this.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:h.dataId,shape:t,dtype:h.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:r,shape:a,dtype:i}=s;if(t!=null){const m=he(a),y=t[0]*t[1]*4;O(m<=y,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=$f(a);let l;r?l=new rbe(o):l=new sbe(o);const h=!0,d=[t??Wy(o)],f=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:e}],i,d,h,t);return{dtype:i,shape:a,dataId:f.dataId}}runWebGLProgram(e,t,s,r,a=!1,i){const o=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===hp.DENSE){const v=i??Wy(e.outputShape);l.texShape=v.map(C=>C*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),he(o.shape)===0)return l.values=zn(o.dtype,0),o;const h=[],d=t.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(v.dataId);if(C.texture==null){if(!e.packedInputs&&he(v.shape)<=ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:C.values};e.packedInputs&&(C.isPacked=!0,C.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!C.isPacked!=!!e.packedInputs)v=C.isPacked?this.unpackTensor(v):this.packTensor(v),h.push(v),C=this.texData.get(v.dataId);else if(C.isPacked&&!dp(C.shape,v.shape)){const N=v,k=v.shape;v.shape=C.shape,v=this.packedReshape(v,k),h.push(v),C=this.texData.get(v.dataId),N.shape=k}return{shape:v.shape,texData:C,isUniform:!1}});this.uploadToGPU(o.dataId);const f={shape:o.shape,texData:l,isUniform:!1},m=nbe(e,d,f),y=this.getAndSaveBinary(m,()=>ebe(this.gpgpu,e,d,f)),b=this.activeTimers!=null;let x;b&&(x=this.startTimer()),ie().get("ENGINE_COMPILE_ONLY")||tbe(this.gpgpu,y,d,f,r),h.forEach(v=>this.disposeIntermediateTensorInfo(v)),b&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const w=ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(w>0){const v=Gn();v-this.lastGlFlushTime>w&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!ie().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const v=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),v}return o}compileAndRun(e,t,s,r,a=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=re(()=>{if(!ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ie().getBool("DEBUG");ie().set("DEBUG",!1);const t=this.abs(ze(1e-8)).dataSync()[0];if(ie().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?vxe:Sxe}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:a,texture:i,usage:o,isPacked:l}=t;if(i!=null)return;const h=this.activeTimers!=null;let d;h&&(d=Gn());let f=t.texShape;if(f==null&&(f=JV(s,l),t.texShape=f),a!=null){const m=$f(s);let y,b=f[1],x=f[0];const w=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!w)&&([b,x]=ud(f[0],f[1])),l?y=new lbe(m,w):y=new $3(m,w);const v=w?[x,b]:f,C=this.makeTensorInfo(v,r),N=this.texData.get(C.dataId);w?N.usage=xr.PIXELS:N.usage=xr.UPLOAD,N.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),b,x,a);const k=[[x,b]],_=this.runWebGLProgram(y,[C],r,k,!0),R=this.texData.get(_.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(C),h&&(this.uploadWaitMs+=Gn()-d)}else{const m=this.acquireTexture(f,o,r,l);t.texture=m}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return t!=null&&(s.values=Exe(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Yf(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(a){throw a}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await WN(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(t$(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:r,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=lU(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=i,e.outShapeStridesLocation=o,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:i,channels:o}=e,l=ua().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=l.writeTexture(r,t,s,a,i,o);return ua().makeTensorFromDataId(h,t,s,l)}}ig.nextDataId=0;function Exe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}const _U="4.22.0";function AU(){ie().set("WEBGL_FORCE_F16_TEXTURES",!0)}b2()&&w2("webgl",()=>new ig,2);const $xe={forceHalfFloat:AU};const h$=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class uu{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Ze(t,s),this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Tu=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class md{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ze(t,s);const a=this.outputShape.length;this.enableShapeUniforms=hs(a);let i="";if(r)if(a===0||he(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${It(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=gs("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}function Qs(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Ixe={kernelName:wh,backendName:"webgl",kernelFunc:Qs};function Xo(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,a=t.makeTensorInfo(s.shape,"complex64"),i=t.texData.get(a.dataId),o=Qs({inputs:{x:s},backend:t}),l=Qs({inputs:{x:r},backend:t});return i.complexTensorInfos={real:o,imag:l},a}const _xe={kernelName:Sb,backendName:"webgl",kernelFunc:Xo};const RU="return (a < 0.) ? b * a : a;",DU=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Axe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:a}=s,i=t.makeTensorInfo([],"float32",Oi(a,"float32")),o=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(DU,r.shape,i.shape):new uu(RU,r.shape,i.shape),l=t.runWebGLProgram(o,[r,i],"float32");return t.disposeIntermediateTensorInfo(i),l}const Rxe={kernelName:jp,backendName:"webgl",kernelFunc:Axe};const OU="return (a < 0.) ? b * a : a;",FU=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Dxe(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,a=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(FU,s.shape,r.shape):new uu(OU,s.shape,r.shape);return t.runWebGLProgram(a,[s,r],"float32")}const Oxe={kernelName:lm,backendName:"webgl",kernelFunc:Dxe};const gd="if (isnan(x)) return x;";function xt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:a})=>{const{x:i}=r,o=a,l=s||i.dtype;if(o.shouldExecuteOnCPU([i])&&t!=null){const f=o.texData.get(i.dataId),m=t(f.values,l);return o.makeTensorInfo(i.shape,l,m)}const h=ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return h?d=new vo(i.shape,e):d=new La(i.shape,n),o.runWebGLProgram(d,[i],l)}}function ts({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:h}=i,d=o;if(s&&l.dtype==="complex64"){const b=d.texData.get(l.dataId),x=d.texData.get(h.dataId),[w,v]=[[b.complexTensorInfos.real,x.complexTensorInfos.real],[b.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(N=>{const[k,E]=N,_={dataId:k.dataId,dtype:k.dtype,shape:l.shape},R={dataId:E.dataId,dtype:E.dtype,shape:h.shape},D=new uu(n,l.shape,h.shape);return d.runWebGLProgram(D,[_,R],_s(k.dtype,E.dtype))}),C=Xo({inputs:{real:w,imag:v},backend:d});return d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(v),C}const f=a||_s(l.dtype,h.dtype);if((l.dtype==="string"||h.dtype==="string"||d.shouldExecuteOnCPU([l,h]))&&r!=null){const b=d.texData.get(l.dataId).values,x=d.texData.get(h.dataId).values,w=l.dtype==="string"?Ai(b):b,v=l.dtype==="string"?Ai(x):x,[C,N]=r(l.shape,h.shape,w,v,f),k=d.makeTensorInfo(N,f),E=d.texData.get(k.dataId);return E.values=C,k}const m=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let y;return m?y=new md(e,l.shape,h.shape,t):y=new uu(n,l.shape,h.shape),d.runWebGLProgram(y,[l,h],f)}}function fp(n,e=!1){if(n==="linear")return e?pxe:uxe;if(n==="relu")return e?gxe:hxe;if(n==="elu")return e?mxe:cxe;if(n==="relu6")return e?yxe:dxe;if(n==="prelu")return e?FU:OU;if(n==="leakyrelu")return e?DU:RU;if(n==="sigmoid")return e?bxe:fxe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class LU{constructor(e,t,s,r=!1,a=!1,i=!1,o=null,l=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=hs(this.outputShape.length);const d=r?e[1]:e[2],f=Math.ceil(d/2),m=r?"i * 2, rc.y":"rc.y, i * 2",y=a?"rc.z, i * 2":"i * 2, rc.z",b=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",v="";o&&(l?w=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:h?w=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:w=`vec4 activation(vec4 x) {
          ${o}
        }`,v="result = activation(result);");const C=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let N="rc.x",k="rc.x";e[0]<t[0]?N=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(k=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${N};
        int batchB = ${k};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${x[0]});
          result += (${b[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${C}

        ${v}

        setOutput(result);
      }
    `}}const D3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class O3{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ze(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const F3="return a * b;";function d$(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,a=_s(s.dtype,r.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),l=t.texData.get(r.dataId),h=new O3(D3.REAL,s.shape,r.shape),d=new O3(D3.IMAG,s.shape,r.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],m=t.runWebGLProgram(h,f,"float32"),y=t.runWebGLProgram(d,f,"float32"),b=Xo({inputs:{real:m,imag:y},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}if(t.shouldExecuteOnCPU([s,r])){const o=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[h,d]=Rbe(s.shape,r.shape,o.values,l.values,a),f=t.makeTensorInfo(d,a),m=t.texData.get(f.dataId);return m.values=h,f}let i;return ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new md(F3,s.shape,r.shape):i=new uu(F3,s.shape,r.shape),t.runWebGLProgram(i,[s,r],a)}const Fxe={kernelName:Ih,backendName:"webgl",kernelFunc:d$};function Lxe(n,e,t){const s=[ou(n.shape),...lu(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},a=[ou(e),...lu(e)],i=new IU(a,s),o=!0,l=[s],h=t.runWebGLProgram(i,[r],n.dtype,l,o);return{dataId:h.dataId,shape:e,dtype:h.dtype}}function Ee(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:a}=s,i=t,o=he(r.shape),l=h2(a,o),h=he(l);O(o===h,()=>`The new shape (${l}) has ${h} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=i.texData.get(r.dataId);return d.isPacked&&!dp(r.shape,l)&&!(d.texture!==null&&dp(d.shape,l))?Lxe(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const Mxe={kernelName:cm,backendName:"webgl",kernelFunc:Ee};class L3{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];const o=Math.floor(s/4)*4,l=s%4;let h="sumValue += dot(values, ones);";if(t!=null){const f=1/t;h=`sumValue += dot(values * ${Hl(f)?f.toPrecision(2):f}, ones);`}let d="";a%s>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${h}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${h}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${h}
        }
        setOutput(sumValue);
      }
    `}}class zxe{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let o="0.0",l="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",l="min"):t==="max"&&(o="-1.0 / 1e-20",l="max");let h=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?h="sumValue":t==="prod"?h="prodValue":t==="all"?h="allValue":t==="any"&&(h="anyValue");const d=Math.floor(s/4)*4,f=s%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";t==="all"?(o="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):t==="any"&&(o="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";a%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${f===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function Pxe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=uw(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Cu(n,e,t,s){const r=Pxe(n.shape);let a=n;for(let i=0;i<r.length;i++){const{inSize:o,windowSize:l,outSize:h}=r[i];let d,f;t==="mean"?d=i===0?new L3({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:h},o):new L3({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:h}):d=new zxe({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:h},t),f=a,a=s.runWebGLProgram(d,[a],e),f.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(f)}return a}class Bxe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.rank=s.length;const r=It(this.rank),a=Vxe(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function Vxe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}class Uxe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[t[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=It(this.rank),a=$U("rc",this.rank),i=new Array(this.rank);for(let d=0;d<t.length;d++)i[t[d]]=a[d];const o=`vec2(${i.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${s[this.rank-1]}`,h=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${h};
      if(${l}) {
        result[1] = ${h};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${h};
        if(${l}) {
          result[3] = ${h};
        }
      }
      setOutput(result);
    }
    `}}function Fw(n,e,t){const s=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uxe(n.shape,e):new Bxe(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}function jxe(n,e,t,s){const r=e,a=n.shape.length,i=at(r,n.shape);let o=i;const l=Zt(o,a),h=l!=null;let d=n;h&&(d=Fw(n,l,s),o=cn(o.length,a)),Qn("sum",o,a);const[f,m]=Un(d.shape,o);let y=f;t&&(y=un(f,i));const b=he(m),w=he(n.shape)/b,v=Ee({inputs:{x:d},attrs:{shape:[w,b]},backend:s}),C=Sx(n.dtype),N=Cu(v,C,"sum",s),k=Ee({inputs:{x:N},attrs:{shape:y},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(N),h&&s.disposeIntermediateTensorInfo(d),k}function Lw(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s;return jxe(r,a,i,t)}const Wxe={kernelName:gm,backendName:"webgl",kernelFunc:Lw};function xs(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:a}=s,i=t,o=r.shape.length,l=new Array(o);for(let d=0;d<l.length;d++)l[d]=r.shape[a[d]];let h;if(i.shouldExecuteOnCPU([r])){const f=i.texData.get(r.dataId).values,m=c$(f,r.shape,r.dtype,a,l);h=i.makeTensorInfo(l,r.dtype);const y=i.texData.get(h.dataId);y.values=m}else h=Fw(r,a,i);return h}const Gxe={kernelName:Ul,backendName:"webgl",kernelFunc:xs};const MU=1e3;function Q0({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const h=n.shape.length,d=e.shape.length,f=t?n.shape[h-2]:n.shape[h-1],m=s?e.shape[d-1]:e.shape[d-2],y=t?n.shape[h-1]:n.shape[h-2],b=s?e.shape[d-2]:e.shape[d-1],x=n.shape.slice(0,-2),w=e.shape.slice(0,-2),v=he(x),C=he(w),k=Ze(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([y,b]);O(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[v,f,y]:[v,y,f],_=s?[C,b,m]:[C,m,b],R=Ee({inputs:{x:n},backend:r,attrs:{shape:E}}),D=Ee({inputs:{x:e},backend:r,attrs:{shape:_}}),F=[R,D],L=Math.max(v,C),A=t?R.shape[1]:R.shape[2],V=a!=null,q=i!=null,ne=l==="leakyrelu",Q=l!=null?fp(l,!0):null,B=V||q||ne||Q!=null;let U;if((y===1||b===1)&&A>MU&&B===!1){let K=R,se=D;t&&(K=xs({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),F.push(K)),s&&(se=xs({inputs:{x:D},backend:r,attrs:{perm:[0,2,1]}}),F.push(se));const P=b!==1,j=b===1;let te=K;P&&(te=Ee({inputs:{x:K},backend:r,attrs:{shape:[L,A,1]}}),F.push(te));const oe=b===1?2:1;let pe=se;j&&(pe=Ee({inputs:{x:se},backend:r,attrs:{shape:[L,1,A]}}),F.push(pe));const xe=d$({inputs:{a:te,b:pe},backend:r});U=Lw({inputs:{x:xe},backend:r,attrs:{axis:oe,keepDims:!0}}),F.push(xe)}else{const K=_s(n.dtype,e.dtype),se=new LU(E,_,[L,y,b],t,s,V,Q,q,ne),P=[R,D];if(a!=null&&P.push(a),q&&P.push(i),ne){const j=r.makeTensorInfo([],"float32",Oi(o,"float32"));P.push(j),F.push(j)}U=r.runWebGLProgram(se,P,K)}const X=Ee({inputs:{x:U},backend:r,attrs:{shape:k}});F.push(U);for(const K of F)r.disposeIntermediateTensorInfo(K);return X}function Hxe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a,bias:i,preluActivationWeights:o}=e,{transposeA:l,transposeB:h,activation:d,leakyreluAlpha:f}=s;return Q0({a:r,b:a,transposeA:l,transposeB:h,backend:t,bias:i,preluActivationWeights:o,leakyreluAlpha:f,activation:d})}const qxe={kernelName:Jf,backendName:"webgl",kernelFunc:Hxe};const M3="return abs(x);";function Kxe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const a=t.texData.get(s.dataId),i=kU(a.values);return t.makeTensorInfo(s.shape,s.dtype,i)}let r;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new vo(s.shape,M3):r=new La(s.shape,M3),t.runWebGLProgram(r,[s],s.dtype)}const Xxe={kernelName:vp,backendName:"webgl",kernelFunc:Kxe};const Yxe=Yr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Jxe=xt({opSnippet:Yxe}),Zxe={kernelName:eh,backendName:"webgl",kernelFunc:Jxe};const Qxe=Yr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,ewe=xt({opSnippet:Qxe}),twe={kernelName:th,backendName:"webgl",kernelFunc:ewe};const z3="return a + b;",nwe=ts({opSnippet:z3,packedOpSnippet:z3,supportsComplex:!0,cpuKernelImpl:hbe}),swe={kernelName:fu,backendName:"webgl",kernelFunc:nwe};class rwe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}class awe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}function f0(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Qs({inputs:{x:s[0]},backend:t});if(s.length>ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),h=f0({inputs:s.slice(0,l),backend:t}),d=f0({inputs:s.slice(l),backend:t});return f0({inputs:[h,d],backend:t})}const r=s.map(l=>l.dtype).reduce((l,h)=>_s(l,h)),a=s.map(l=>l.shape),o=ie().getBool("WEBGL_PACK")?new awe(s[0].shape,a):new rwe(s[0].shape,a);return t.runWebGLProgram(o,s,r)}const iwe={kernelName:Sp,backendName:"webgl",kernelFunc:f0};function owe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=at(a,r.shape);let h=l;const d=Zt(h,o);let f=r;d!=null&&(f=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,o)),Qn("all",h,o);const[m,y]=Un(f.shape,h),b=he(y),x=Ee({inputs:{x:f},backend:t,attrs:{shape:[-1,b]}}),w=Cu(x,x.dtype,"all",t);let v;if(i){const C=un(m,l);v=Ee({inputs:{x:w},backend:t,attrs:{shape:C}})}else v=Ee({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(f),v}const lwe={kernelName:gb,backendName:"webgl",kernelFunc:owe};function uwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=at(a,r.shape);let h=l;const d=Zt(h,o);let f=r;d!=null&&(f=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,o)),Qn("any",h,o);const[m,y]=Un(f.shape,h),b=he(y),x=Ee({inputs:{x:f},backend:t,attrs:{shape:[-1,b]}}),w=Cu(x,x.dtype,"any",t);let v;if(i){const C=un(m,l);v=Ee({inputs:{x:w},backend:t,attrs:{shape:C}})}else v=Ee({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(f),v}const cwe={kernelName:yb,backendName:"webgl",kernelFunc:uwe};class hwe{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class dwe{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],i=Math.ceil(a/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,h=It(l),d=gs("coords",l);let f,m;if(i===1){m=l+1;const D=It(m);f=`
        ${D} sourceLocR = ${D}(${d.join()}, 0);
        ++${d[l-1]};
        ${D} sourceLocG = ${D}(${d.join()}, 0);
        ++${d[l-2]};
        ${D} sourceLocA = ${D}(${d.join()}, 0);
        --${d[l-1]};
        ${D} sourceLocB = ${D}(${d.join()}, 0);
        --${d[l-2]};`}else m=l,f=`
        ${h} sourceLocR = coords;
        ++${d[l-1]};
        ${h} sourceLocG = coords;
        ++${d[l-2]};
        ${h} sourceLocA = coords;
        --${d[l-1]};
        ${h} sourceLocB = coords;
        --${d[l-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],x=y.map(D=>"int "+D),w=gs("sourceLocR",m-1).concat("inIdx.r"),v=gs("sourceLocG",m-1).concat("inIdx.g"),C=gs("sourceLocB",m-1).concat("inIdx.b"),N=gs("sourceLocA",m-1).concat("inIdx.a"),k=s==="max"?"greaterThan":"lessThan",E=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${N.join()})));`,_=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${C.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${N.join()}) : 0.)`,R=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${h} coords = getOutputCoords();
        bool hasNextCol = ${d[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${d[l-2]} < ${o[l-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function zU(n,e,t,s=null){let r=e.shape[0],a=e.shape[1];s!=null&&(r=s.shape[0],a=s.shape[1]);const i=uw(a),o={windowSize:i,inSize:a,batchSize:r,outSize:Math.ceil(a/i)},l=new hwe(o,t,s==null),h=[e];s!=null&&h.push(s);const d=n.runWebGLProgram(l,h,"int32");if(d.shape[1]===1)return d;const f=zU(n,e,t,d);return n.disposeIntermediateTensorInfo(d),f}function PU(n,e,t,s=null){const r=s!=null?s.shape:e.shape,a=r[r.length-1],i=uw(a),o=new dwe(r,i,t,s==null),l=s==null?[e]:[e,s],h=n.runWebGLProgram(o,l,"int32");if(h.shape.length===e.shape.length){const d=PU(n,e,t,h);return n.disposeIntermediateTensorInfo(h),d}return h}function BU(n,e,t,s){const r=[t];if(Qn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ie().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],i=n.texData.get(e.dataId),o=i!==null&&i.isPacked;let l=e;o&&(l=n.unpackTensor(e),a.push(l));const[h,d]=Un(l.shape,r),f=he(d),m=Ee({inputs:{x:l},backend:n,attrs:{shape:[-1,f]}});a.push(m);const y=zU(n,m,s);a.push(y);const b=Ee({inputs:{x:y},backend:n,attrs:{shape:h}});return a.forEach(x=>n.disposeIntermediateTensorInfo(x)),b}return PU(n,e,s)}function fwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;let i=at(a,r.shape);const o=Zt(i,r.shape.length);let l=r;const h=[];o!=null&&(l=xs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),i=cn(i.length,l.shape.length)),Qn("argMax",[i[0]],l.shape.length);const d=BU(t,l,i[0],"max");return h.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}const pwe={kernelName:Tp,backendName:"webgl",kernelFunc:fwe};function mwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;let i=at(a,r.shape);const o=Zt(i,r.shape.length);let l=r;const h=[];o!=null&&(l=xs({inputs:{x:r},backend:t,attrs:{perm:o}}),h.push(l),i=cn(i.length,l.shape.length)),Qn("argMin",[i[0]],l.shape.length);const d=BU(t,l,i[0],"min");return h.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}const gwe={kernelName:Cp,backendName:"webgl",kernelFunc:mwe};const ywe=Yr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,bwe=xt({opSnippet:ywe}),xwe={kernelName:nh,backendName:"webgl",kernelFunc:bwe};const wwe=Yr+"return log(x + sqrt(x * x + 1.0));",vwe=xt({opSnippet:wwe}),Swe={kernelName:sh,backendName:"webgl",kernelFunc:vwe};const Twe=Yr+`
  return atan(x);
`,Cwe=xt({opSnippet:Twe}),Nwe={kernelName:rh,backendName:"webgl",kernelFunc:Cwe};const kwe=h$+`
  return atan(a, b);
`,Ewe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Tu+`
  return result;
`,$we=ts({opSnippet:kwe,packedOpSnippet:Ewe}),Iwe={kernelName:ih,backendName:"webgl",kernelFunc:$we};const _we=Yr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Awe=xt({opSnippet:_we}),Rwe={kernelName:ah,backendName:"webgl",kernelFunc:Awe};class pp{constructor(e,t,s,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,o=e.strideHeight,l=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let C="0.0";if(x||(C="-1.0 / 1e-20"),s){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?w:v:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const E=Math.floor(i/4)*4,_=i%4,R=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${h}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${E};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${k});
      }
    `}}class f${constructor(e,t,s,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,o=e.strideDepth,l=e.strideHeight,h=e.strideWidth,d=e.dilationDepth,f=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,x=e.effectiveFilterWidth,w=e.padInfo.front,v=e.padInfo.top,C=e.padInfo.left;this.outputShape=e.outShape;const N=t==="avg";let k="0.0";if(N||(k="-1.0 / 1e-20"),s){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${h});
        const ivec3 pads = ivec3(${w}, ${v}, ${C});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${b} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const R=Math.floor(i/4)*4,D=i%4,F=`
      if (${N}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${h});
      const ivec3 pads = ivec3(${w}, ${v}, ${C});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${R};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${F}
            }
          }
        }
        setOutput(${_});
      }
    `}}function Dwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;cd(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(i,h),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Kr(r.shape,a,i,h,o,l);if(d.filterWidth===1&&d.filterHeight===1&&lt(d.inShape,d.outShape))return Qs({inputs:{x:r},backend:t});const f=new pp(d,"avg",!1);return t.runWebGLProgram(f,[r],"float32")}const Owe={kernelName:Np,backendName:"webgl",kernelFunc:Dwe};function Fwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:h}=s,d=[1,1,1],f=Fi(r.shape,a,i,d,o,l,h),m=new f$(f,"avg",!1);return t.runWebGLProgram(m,[r],"float32")}const Lwe={kernelName:kp,backendName:"webgl",kernelFunc:Fwe};class Mwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=l-1-e.padInfo.top,f=h-1-e.padInfo.left,m=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${f});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${h};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class zwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,b=f-1-e.padInfo.front,x=m-1-e.padInfo.top,w=y-1-e.padInfo.left,v=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${w});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${h}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Pwe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,i=a,{filterSize:o,strides:l,pad:h,dimRoundingMode:d}=s,f=[1,1,1],m=Fi(i.shape,o,l,f,h,d),y=new zwe(m);return t.runWebGLProgram(y,[r],i.dtype)}const Bwe={kernelName:xb,backendName:"webgl",kernelFunc:Pwe};function Vwe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,i=a;cd([r,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:h}=s,d=Kr(i.shape,o,l,1,h),f=new Mwe(d);return t.runWebGLProgram(f,[r],i.dtype)}const Uwe={kernelName:bb,backendName:"webgl",kernelFunc:Vwe};function jwe(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a}=e,{transposeA:i,transposeB:o}=s;return Q0({a:r,b:a,transposeA:i,transposeB:o,backend:t})}const Wwe={kernelName:Ep,backendName:"webgl",kernelFunc:jwe};class Gwe{constructor(e,t,s,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Ze(e,t),Ze(e,s);let o="0.0";r!=null&&(Ze(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";a!=null&&(Ze(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class Hwe{constructor(e,t,s,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ze(e,t),Ze(e,s);let o="vec4(0.0)";r!=null&&(Ze(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(Ze(e,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const qwe=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:a,offset:i,scale:o}=n;O(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const h=[s,r,a];let d=null;i!=null&&(d=i.shape,h.push(i));let f=null;o!=null&&(f=o.shape,h.push(o));const m=ie().getBool("WEBGL_PACK_NORMALIZATION")?new Hwe(s.shape,r.shape,a.shape,d,f,l):new Gwe(s.shape,r.shape,a.shape,d,f,l);return e.runWebGLProgram(m,h,h[0].dtype)},Kwe={kernelName:Bp,backendName:"webgl",kernelFunc:qwe};class Xwe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=It(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=Ywe(this.rank);let r;const a=e.map((i,o)=>`sourceLoc.${bC[o]} = start[${o}] + coords.${bC[o]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const bC=["x","y","z","w","u","v"];function Ywe(n){if(n===1)return"sourceLoc";if(n<=6)return bC.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class Jwe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=It(this.rank),s=gs("coords",this.rank),r=gs("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,h=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,f)=>`start[${f}]`).join()});`:e.map((d,f)=>`${r[f]} = ${s[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${h}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}function Zwe(n,e,t,s){const r=s.texData.get(n.dataId),a=s.makeTensorInfo(t,n.dtype),i=s.texData.get(a.dataId);Object.assign(i,r),i.refCount=1,i.shape=t,i.dtype=n.dtype;let o=UN(e,Pe(n.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,l+1),a}function yd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,size:i}=s,[o,l]=lw(r,a,i);if(PN(r,o,l),he(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const f=t.texData.get(r.dataId),m=jbe(f.values,o,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,m)}const{isPacked:h}=t.texData.get(r.dataId),d=VN(r.shape,o,l);if(h||!d){const f=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jwe(l):new Xwe(l),m=[o];return t.runWebGLProgram(f,[r],r.dtype,m)}return t.uploadToGPU(r.dataId),Zwe(r,o,l,t)}const Qwe={kernelName:mm,backendName:"webgl",kernelFunc:yd};const eve=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,crops:i}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((C,N)=>C*N),l=Wm(r.shape,a,o),h=Gm(l.length,a.length),d=Hm(r.shape,a,o),f=KN(i,a.length),m=XN(d,i,a.length),y=[],b=Ee({inputs:{x:r},backend:t,attrs:{shape:l}}),x=xs({inputs:{x:b},backend:t,attrs:{perm:h}}),w=Ee({inputs:{x},backend:t,attrs:{shape:d}}),v=yd({inputs:{x:w},backend:t,attrs:{begin:f,size:m}});return y.push(b),y.push(x),y.push(w),y.forEach(C=>t.disposeIntermediateTensorInfo(C)),v},tve={kernelName:$p,backendName:"webgl",kernelFunc:eve};function nve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:i}=s,o=t.readSync(r.dataId),l=t.readSync(a.dataId),h=NU(o,l,a.dtype,a.shape,i);return t.makeTensorInfo([i],a.dtype,h)}const sve={kernelName:wb,backendName:"webgl",kernelFunc:nve};const rve=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,ave=`
  return float(int(a.r) & int(b.r));
`;function ive(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,a=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ie().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,r])||i===1){const l=t.texData.get(s.dataId).values,h=t.texData.get(r.dataId).values,[d,f]=fbe(s.shape,r.shape,l,h,s.dtype),m=t.makeTensorInfo(f,s.dtype),y=t.texData.get(m.dataId);return y.values=d,m}let o;return a?o=new md(rve,s.shape,r.shape,!1):o=new uu(ave,s.shape,r.shape),t.runWebGLProgram(o,[s,r],s.dtype)}const ove={kernelName:Ip,backendName:"webgl",kernelFunc:ive};function lve(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,a=t.readSync(s.dataId),i=t.readSync(r.dataId),o=Ze(Array.from(a),Array.from(i));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const uve={kernelName:vb,backendName:"webgl",kernelFunc:lve};const cve="return float(a != b);",VU=ts({opSnippet:cve,cpuKernelImpl:Obe,dtype:"bool"}),hve={kernelName:sm,backendName:"webgl",kernelFunc:VU};function og(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Qs({inputs:{x:r.complexTensorInfos.real},backend:t})}const dve={kernelName:tx,backendName:"webgl",kernelFunc:og};const fve="return float(int(x));";function pve(n,e){const t=new La(n.shape,fve),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}function xC(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return Qs({inputs:{x:r},backend:t});const i=gn(r.shape),o=xC({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Xo({inputs:{real:o,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(o),l}if(r.dtype==="complex64"){const i=og({inputs:{input:r},backend:t}),o=xC({inputs:{x:i},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(i),o}if(!d2(r.dtype,a)){const i=Qs({inputs:{x:r},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId).values,[o,l,h]=pbe(i,r.shape,r.dtype,a);return t.makeTensorInfo(o,l,h)}if(a==="int32")return pve(r,t);if(a==="bool"){const i=t.makeTensorInfo([],"bool",zn("bool",1)),l=VU({inputs:{a:r,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const mve={kernelName:oh,backendName:"webgl",kernelFunc:xC};const P3="return ceil(x);",gve=xt({opSnippet:P3,packedOpSnippet:P3,cpuKernelImpl:mbe}),yve={kernelName:lh,backendName:"webgl",kernelFunc:gve};class bve{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class xve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function wve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:a,clipValueMax:i}=s;let o;ie().getBool("WEBGL_PACK_CLIP")?o=new xve(r.shape):o=new bve(r.shape);const l=[[a],[i]];return t.runWebGLProgram(o,[r],r.dtype,l)}const vve={kernelName:uh,backendName:"webgl",kernelFunc:wve};class Sve{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function B3(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Tve(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),a=new Sve(s.shape),i=[B3(s,r.complexTensorInfos.real),B3(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(a,i,i[0].dtype)}const Cve={kernelName:_p,backendName:"webgl",kernelFunc:Tve};class Nve{constructor(e){this.outputShape=[],this.outputShape=Va(e,1),this.variableNames=e.map((i,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const o=t[i-1];s.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const r=t.length,a=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}class kve{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Va(e,t);const s=this.outputShape,r=s.length,a=It(r),i=gs("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((x,w)=>`T${w}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][t];const h=o[t],d=o.slice(-2),f=o.join();let m=`if (${h} < ${l[0]}) {
        return getChannel(
            getT0(${f}), vec2(${d.join()}));
        }`;for(let x=1;x<l.length;x++){const w=l[x-1];m+=`
        if (${h} < ${l[x]}  && ${h} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${qy(o,h,w)}),
            vec2(${qy(d,h,w)}));
        }`}const y=l.length,b=l[l.length-1];m+=`
        return getChannel(
          getT${y}(${qy(o,h,b)}),
          vec2(${qy(d,h,b)}));`,this.userCode=`
      float getValue(${o.map(x=>"int "+x)}) {
        ${m}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function qy(n,e,t){const s=n.indexOf(e);return n.map((a,i)=>i===s?`${a} - ${t}`:a).join()}function Mw(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Qs({inputs:{x:r.complexTensorInfos.imag},backend:t})}const Eve={kernelName:Vb,backendName:"webgl",kernelFunc:Mw};function If(n,e,t){const s=n[0].dtype;if(s==="complex64"){const y=n.map(C=>og({inputs:{input:C},backend:t})),b=n.map(C=>Mw({inputs:{input:C},backend:t})),x=If(y,e,t),w=If(b,e,t),v=Xo({inputs:{real:x,imag:w},backend:t});return y.forEach(C=>t.disposeIntermediateTensorInfo(C)),b.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),v}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const y=n.map(k=>{const _=[-1,he(k.shape.slice(e))];return Ee({inputs:{x:k},backend:t,attrs:{shape:_}})}),b=y.map(k=>({vals:t.readSync(k.dataId),shape:k.shape})),x=Va(y.map(k=>k.shape),1),w=y[0].shape[0]===1,v=gbe(b,x,s,w),C=Va(n.map(k=>k.shape),e),N=t.makeTensorInfo(C,s,v);return y.forEach(k=>t.disposeIntermediateTensorInfo(k)),N}const a=n.filter(y=>he(y.shape)>0),i=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const y=i?new La(n[0].shape,go):new vo(n[0].shape,go);return t.runWebGLProgram(y,n,s)}const o=ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const y=[];for(let x=0;x<a.length;x+=o){const w=a.slice(x,x+o);y.push(If(w,e,t))}const b=If(y,e,t);for(const x of y)t.disposeIntermediateTensorInfo(x);return b}if(i){const y=new kve(a.map(b=>b.shape),e);return t.runWebGLProgram(y,a,s)}const{tensors2D:l,outShape:h}=$ve(a,e,t),d=new Nve(l.map(y=>y.shape)),f=t.runWebGLProgram(d,l,s);l.forEach(y=>t.disposeIntermediateTensorInfo(y));const m=Ee({inputs:{x:f},attrs:{shape:h},backend:t});return t.disposeIntermediateTensorInfo(f),m}function $ve(n,e,t){const s=Va(n.map(a=>a.shape),e);return{tensors2D:n.map(a=>Ee({inputs:{x:a},attrs:{shape:[-1,he(a.shape.slice(e))]},backend:t})),outShape:s}}function UU(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,a=at(r,e[0].shape)[0],i=e.map(h=>h.shape);GN(i,a);const o=Va(e.map(h=>h.shape),a);if(he(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(h=>he(h.shape)>0);return l.length===1?Qs({inputs:{x:l[0]},backend:t}):If(l,a,t)}const Ive={kernelName:Ap,backendName:"webgl",kernelFunc:UU};class jU{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,f=e.dilationWidth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,w=e.dataFormat==="channelsLast",v=w?1:2,C=w?2:3,N=w?3:1;let k="",E="";s&&(r?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:k=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${l}, ${h});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${N}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${C}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${E}
        setOutput(result);
      }
    `}}class _ve{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,f=e.filterDepth,m=e.filterHeight,y=e.filterWidth,b=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${h};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class WU{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,f=d;let m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
           vec4 xTexelC${w*2};
           int xTexelC${w*2}Ready;
           vec4 xTexelC${w*2+1};
           int xTexelC${w*2+1}Ready;
           vec4 xC${w};`;m+=`
     for (int r = 0; r < ${h}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let w=0;w<d;w++)m+=`
           xTexelC${w*2} = vec4(0.0);
           xTexelC${w*2}Ready = 0;
           xTexelC${w*2+1} = vec4(0.0);
           xTexelC${w*2+1}Ready = 0;
           xC${w} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let w=0;w<(f+1)/2;w++){const v=w*2;if(m+=`
           xC = xCCorner + ${v*l};
           `,o===1){if(v<d&&(i%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?m+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<d)){const C=i%2===0?pb(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${C};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:m+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):C===1?m+=`
                     xC${v+1} = xTexelC${v};
                     `:m+=`
                     xCOffset = xC + ${C};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<d&&(i%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<d&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<d&&(m+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<d&&(m+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<d&&(m+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let y="",b="";s&&(r?y=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:a?y=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:y=`vec4 activation(vec4 x) {
           ${s}
         }`,b="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${y}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${b}
         setOutput(result);
       }
     `}}class Ave{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=hs(this.outputShape.length);const{dataFormat:s}=t,r=Ss(),a=s==="channelsLast",i=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let h="";for(let d=0;d<=1;d++)for(let f=0;f<=1;f++)h+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${d};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${h}

        ${r.output} = result;
      }
    `}}function eb(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function GU({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=n.shape,h=s.texData.get(n.dataId),d=t.inChannels,f=l[0]*l[1]*l[2],m=t.outChannels,y=t.dataFormat==="channelsLast",b=!1,x=!1;let w;const v=[];if(a!=null){const k=eb(a.shape,y);k!=null&&(a=Ee({inputs:{x:a},backend:s,attrs:{shape:k}}),v.push(a))}if(r!=null){const k=eb(r.shape,y);k!=null&&(r=Ee({inputs:{x:r},backend:s,attrs:{shape:k}}),v.push(r))}if(!((f===1||m===1)&&d>MU)&&h.isPacked&&y&&h.texture!=null&&l[2]%2!==0&&lt(h.shape.slice(-3),l.slice(-3))){const k=l[0]*l[1]*(l[2]+1),E={dataId:n.dataId,shape:[1,k,t.inChannels],dtype:n.dtype},_=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,O(dp(h.shape,E.shape),()=>`packed reshape ${h.shape} to ${E.shape} isn't free`);const R=Ee({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});v.push(R);const D=Q0({a:E,b:R,backend:s,transposeA:b,transposeB:x,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),F=s.texData.get(D.dataId);O(F.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=_,F.shape=t.outShape,w=Qs({inputs:{x:D},backend:s}),w.shape=t.outShape,v.push(D)}else{const k=t.outHeight*t.outWidth,E=Ee({inputs:{x:n},backend:s,attrs:{shape:y?[t.batchSize,k,t.inChannels]:[t.batchSize,t.inChannels,k]}}),_=Ee({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=Q0({a:y?E:_,b:y?_:E,transposeA:!y,transposeB:x,backend:s,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i});w=Ee({inputs:{x:R},backend:s,attrs:{shape:t.outShape}}),v.push(E),v.push(_),v.push(R)}for(const k of v)s.disposeIntermediateTensorInfo(k);return w}function HU({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:h,inChannels:d,outWidth:f,outHeight:m,dataFormat:y}=t,b=y==="channelsLast",x=l*h*d,w=m*f,v=[t.batchSize,x,w],C=!0,N=!1,k=[];if(a!=null){const X=eb(a.shape,b);X!=null&&(a=Ee({inputs:{x:a},backend:s,attrs:{shape:X}}),k.push(a))}if(r!=null){const X=eb(r.shape,b);X!=null&&(r=Ee({inputs:{x:r},backend:s,attrs:{shape:X}}),k.push(r))}const E=Ee({inputs:{x:e},backend:s,attrs:{shape:[1,x,he(e.shape)/x]}});k.push(E);const _=new Ave(v,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],D=s.runWebGLProgram(_,[n],"float32",R),F=Ee({inputs:{x:D},backend:s,attrs:{shape:v}});k.push(D),k.push(F);const L=r!=null,A=a!=null,V=o==="leakyrelu",q=o?fp(o,!0):null,ne=new LU(b?F.shape:E.shape,b?E.shape:F.shape,b?[t.batchSize,w,t.outChannels]:[t.batchSize,t.outChannels,w],C,N,L,q,A,V),Q=b?[F,E]:[E,F];if(r&&Q.push(r),A&&Q.push(a),V){const X=s.makeTensorInfo([],"float32",Oi(i,"float32"));Q.push(X),k.push(X)}const B=s.runWebGLProgram(ne,Q,"float32"),U=Ee({inputs:{x:B},backend:s,attrs:{shape:t.outShape}});k.push(B);for(const X of k)s.disposeIntermediateTensorInfo(X);return U}function Rve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dataFormat:l,dilations:h,dimRoundingMode:d}=s,f=Li(l),m=Vn(r.shape,a.shape,i,h,o,d,!1,f);let y;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=GU({x:r,filter:a,convInfo:m,backend:t});else if(m.strideWidth<=2&&f==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){const x=new WU(m),w=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];y=t.runWebGLProgram(x,[r,a],"float32",w)}else if(ie().getBool("WEBGL_CONV_IM2COL"))y=HU({x:r,filter:a,convInfo:m,backend:t});else{const x=new jU(m);y=t.runWebGLProgram(x,[r,a],"float32")}const b=Ee({inputs:{x:y},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(y),b}const Dve={kernelName:Rp,backendName:"webgl",kernelFunc:Rve};class Ove{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Fve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,h=i?1:2,d=i?2:3,f=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${h}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Lve{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Mve{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,l=t-1-e.padInfo.front,h=s-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${h}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function zve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:i,pad:o,dataFormat:l,dimRoundingMode:h,filterShape:d}=s,f=Li(l),m=Vn(r.shape,d,i,1,o,h,!1,f),y=new Ove(m);return t.runWebGLProgram(y,[r,a],"float32")}const Pve={kernelName:Tb,backendName:"webgl",kernelFunc:zve};class Bve{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=hs(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,r=t-1-e.padInfo.top,a=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function Vve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{inputShape:i,strides:o,pad:l,dataFormat:h,dimRoundingMode:d}=s,f=Li(h),m=Vn(i,a.shape,o,1,l,d,!1,f);if(ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const y=[[m.strideHeight,m.strideWidth]],b=new Bve(m);return t.runWebGLProgram(b,[r,a],"float32",y)}else{const y=new Fve(m);return t.runWebGLProgram(y,[r,a],"float32")}}const Uve={kernelName:Dp,backendName:"webgl",kernelFunc:Vve};function jve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l}=s,h=Uo(r.shape,a.shape,i,l,o),d=new _ve(h);return t.runWebGLProgram(d,[r,a],"float32")}const Wve={kernelName:Op,backendName:"webgl",kernelFunc:jve};function Gve(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:i,pad:o,filterShape:l}=s,h=Uo(r.shape,l,i,1,o),d=new Lve(h);return t.runWebGLProgram(d,[r,a],"float32")}const Hve={kernelName:Cb,backendName:"webgl",kernelFunc:Gve};function qve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{pad:i,strides:o,inputShape:l}=s,h=Uo(l,a.shape,o,1,i),d=new Mve(h);return t.runWebGLProgram(d,[r,a],"float32")}const Kve={kernelName:Nb,backendName:"webgl",kernelFunc:qve};const Xve=gd+`
  return cos(x);
`,Yve=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Tu}
  return result;
`,Jve=xt({opSnippet:Xve,packedOpSnippet:Yve}),Zve={kernelName:ch,backendName:"webgl",kernelFunc:Jve};const Qve=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,e1e=xt({opSnippet:Qve}),t1e={kernelName:hh,backendName:"webgl",kernelFunc:e1e};class n1e{constructor(e,t,s,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,l,h]=e,[d]=t,[f,m]=s;this.outputShape=[d,f,m,h];const y=r==="bilinear"?1:0,[b,x]=[`${o-1}.0`,`${l-1}.0`],[w,v,C]=f>1?[`${(o-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[N,k,E]=m>1?[`${(l-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${N});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${k};

        float in_y = ${C};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const s1e=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:a,boxInd:i}=e,{cropSize:o,method:l,extrapolationValue:h}=s,d=new n1e(r.shape,a.shape,o,l,h);return t.runWebGLProgram(d,[r,a,i],"float32")},r1e={kernelName:Eb,backendName:"webgl",kernelFunc:s1e};var mp;(function(n){n.Prod="*",n.Sum="+"})(mp||(mp={}));class V3{constructor(e,t,s,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===mp.Prod?"1.0":"0.0",o=s?i:`getX(${U3(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let h="",d="";s?(h=r?`end != ${l-1}`:"end != 0",d=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${l}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${It(a)} coords = getOutputCoords();
        int end = ${j3(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${d};
          ${j3(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${U3(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function U3(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function j3(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function qU(n,e,t,s,r,a){const i=e.shape.length,o=Zt([s],i);let l=e;o!=null&&(l=xs({inputs:{x:e},backend:t,attrs:{perm:o}}));const h=cn(1,i)[0];if(h!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const d=l.shape[h];let f=Qs({inputs:{x:l},backend:t});for(let m=0;m<=Math.ceil(Math.log2(d))-1;m++){const y=new V3(n,l.shape,!1,a),b=[[m]],x=f;f=t.runWebGLProgram(y,[f],f.dtype,b),t.disposeIntermediateTensorInfo(x)}if(r){const m=new V3(n,l.shape,r,a),y=f;f=t.runWebGLProgram(m,[f],f.dtype),t.disposeIntermediateTensorInfo(y)}if(o!=null){const m=jo(o),y=xs({inputs:{x:f},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(l),y}return f}function a1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;return qU(mp.Prod,r,t,a,i,o)}const i1e={kernelName:kb,backendName:"webgl",kernelFunc:a1e};function o1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,exclusive:i,reverse:o}=s;return qU(mp.Sum,r,t,a,i,o)}const l1e={kernelName:Fp,backendName:"webgl",kernelFunc:o1e};function u1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:i,binaryOutput:o}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),h=t.readSync(a.dataId),d=NU(l,h,a.dtype,a.shape,i);return t.makeTensorInfo([i],a.dtype,d)}else if(r.shape.length===2){const l=t.bufferSync(r),h=t.bufferSync(a),d=dbe(l,h,i,o);return t.makeTensorInfo(d.shape,a.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const c1e={kernelName:$b,backendName:"webgl",kernelFunc:u1e};class h1e{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function d1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:a,dataFormat:i}=s,o=r.shape[0],l=i==="NHWC"?r.shape[1]:r.shape[2],h=i==="NHWC"?r.shape[2]:r.shape[3],d=i==="NHWC"?r.shape[3]:r.shape[1],f=l*a,m=h*a,y=d/(a*a),b=i==="NHWC"?[o,f,m,y]:[o,y,f,m],x=new h1e(b,a,i);return t.runWebGLProgram(x,[r],r.dtype)}const f1e={kernelName:Ib,backendName:"webgl",kernelFunc:d1e};class KU{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const i=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let h="",d="";s&&(r?h=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?h=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:h=`
          float activation(float x) {
            ${s}
          }
        `,d="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${d}
        setOutput(result);
      }
    `}}class XU{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const i=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,h=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=f;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<f;v++)y+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;y+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let v=0;v<f;v++)y+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;y+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(m+1)/2;v++){const C=v*2;if(y+=`
          xC = xCCorner + ${C*h};
          `,l===1){if(C<f&&(o%2===1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }
              `,h===1&&C>0?y+=`
                xC${C} = vec4(xTexelC${C-2}.zw, xTexelC${C}.xy);
                `:y+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${C} = vec4(previous.zw, xTexelC${C}.xy);
                  } else {
                    xC${C} = vec4(0.0, 0.0, xTexelC${C}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xC${C} = xTexelC${C};
                `,C+1<f)){const N=o%2===0?pb(h):h;h%2===0&&o%2===1||h%2!==0&&o%2!==1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${N};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                    xTexelC${C+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${C+1}.zw = vec2(0.0);
                    }
                    xTexelC${C+1}Ready = 1;
                  }
                  `,h>1?y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${C+1} = vec4(previous.zw, xTexelC${C+1}.xy);
                    } else {
                     xC${C+1} = vec4(0.0, 0.0, xTexelC${C+1}.xy);
                    }
                    `:y+=`
                    xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.xy);
                    `):N===1?y+=`
                    xC${C+1} = xTexelC${C};
                    `:y+=`
                    xCOffset = xC + ${N};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                      xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${C+1}.zw = vec2(0.0);
                      }
                      xTexelC${C+1}Ready = 1;
                    }

                    xC${C+1} = xTexelC${C+1};
                    `}}else C<f&&(o%2===1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.0);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
              `,C+1<f&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${C+1} = vec4(xTexelC${C+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${C}Ready == 0) {
                  xTexelC${C} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${C}.zw = vec2(0.0);
                  }
                  xTexelC${C}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${C+1}Ready == 0) {
                  xTexelC${C+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${C+1}.zw = vec2(0.);
                  }
                  xTexelC${C+1}Ready = 1;
                }

                xC${C} = vec4(
                  xTexelC${C}.xy, xTexelC${C+1}.xy);
              `,C+1<f&&(y+=`
                  xC${C+1} = vec4(xTexelC${C}.zw, xTexelC${C+1}.zw);
                `)));C<f&&(y+=`
            wTexel = getW(r, ${C}, d1, q);
            dotProd += xC${C} * vec4(wTexel.xz, wTexel.xz);
          `,C+1<f&&(y+=`
              wTexel = getW(r, ${C+1}, d1, q);
              dotProd += xC${C+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
    }
  `,y+=`
      }
    `;let b="",x="";s&&(r?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:b=`vec4 activation(vec4 x) {
          ${s}
        }`,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${x}
        setOutput(result);
      }
    `}}function p1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l,dimRoundingMode:h}=s;let d=l;d==null&&(d=[1,1]),O(Zn(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=Vn(r.shape,a.shape,i,d,o,h,!0);let m;ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?m=new XU(f):m=new KU(f);const y=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return t.runWebGLProgram(m,[r,a],"float32",y)}const m1e={kernelName:Lp,backendName:"webgl",kernelFunc:p1e};class g1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class y1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=t-1-e.padInfo.top,o=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function b1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:h,filterShape:d}=s,f=Vn(r.shape,d,i,o,l,h,!0),m=new g1e(f);return t.runWebGLProgram(m,[r,a],"float32")}const x1e={kernelName:_b,backendName:"webgl",kernelFunc:b1e};function w1e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{strides:i,dilations:o,pad:l,dimRoundingMode:h,inputShape:d}=s,f=Vn(d,a.shape,i,o,l,h,!0),m=new y1e(f);return t.runWebGLProgram(m,[r,a],"float32")}const v1e={kernelName:Ab,backendName:"webgl",kernelFunc:w1e};class S1e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function T1e(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],a=he(s.shape),i=Ee({inputs:{x:s},backend:t,attrs:{shape:[a]}}),o=new S1e(a),l=t.runWebGLProgram(o,[i],i.dtype),h=Ee({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),h}const C1e={kernelName:Rb,backendName:"webgl",kernelFunc:T1e};class N1e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:l,dilationHeight:h,dilationWidth:d}=e,{top:f,left:m}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${f}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${h};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function k1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:i,pad:o,dilations:l}=s,h=km(r.shape,a.shape,i,o,"NHWC",l);let d;const f=new N1e(h);d=t.runWebGLProgram(f,[r,a],"float32");const m=Ee({inputs:{x:d},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(d),m}const E1e={kernelName:Mp,backendName:"webgl",kernelFunc:k1e};function $1e(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,a=e,{allDims:i,summedDims:o,idDims:l}=sk(r,a.length);ak(i.length,l,a);const{path:h,steps:d}=ik(o,l),f=d.length;let m=null,y=i.length;const b=[];for(let x=0;x<f;++x){for(const w of d[x]){const{permutationIndices:v,expandDims:C}=rk(y,l[w]);let N;ok(v)?N=a[w]:(N=xs({inputs:{x:a[w]},backend:t,attrs:{perm:v}}),b.push(N));const k=N.shape.slice();for(let E=0;E<C.length;++E)k.splice(C[E],0,1);lt(N.shape,k)||(N=Ee({inputs:{x:N},backend:t,attrs:{shape:k}}),b.push(N)),m===null?m=N:(m=d$({inputs:{a:N,b:m},backend:t}),b.push(m))}x<f-1&&(h[x]>=0&&(m=Lw({inputs:{x:m},backend:t,attrs:{axis:h[x]-(i.length-y),keepDims:!1}}),b.push(m)),y--)}for(const x of b)x!==m&&t.disposeIntermediateTensorInfo(x);return m}const I1e={kernelName:Ob,backendName:"webgl",kernelFunc:$1e};const _1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",A1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,R1e=xt({opSnippet:_1e,packedOpSnippet:A1e}),D1e={kernelName:fh,backendName:"webgl",kernelFunc:R1e};const O1e="return (b >= 0.0) ? a : a * (b + 1.0);",F1e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,L1e=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,a=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new md(F1e,s.shape,r.shape):new uu(O1e,s.shape,r.shape);return t.runWebGLProgram(a,[s,r],s.dtype)},M1e={kernelName:Fb,backendName:"webgl",kernelFunc:L1e};const z1e=`
  return vec4(equal(a, b));
`,P1e="return float(a == b);",B1e=ts({opSnippet:P1e,packedOpSnippet:z1e,dtype:"bool",cpuKernelImpl:ybe}),V1e={kernelName:zp,backendName:"webgl",kernelFunc:B1e};const U1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${YN};
  float a1 = ${JN};
  float a2 = ${ZN};
  float a3 = ${QN};
  float a4 = ${ek};
  float a5 = ${tk};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,j1e=xt({opSnippet:U1e}),W1e={kernelName:ph,backendName:"webgl",kernelFunc:j1e};const G1e=gd+`
  return exp(x);
`,H1e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,YU=xt({opSnippet:G1e,packedOpSnippet:H1e,cpuKernelImpl:bbe,dtype:"float32"}),q1e={kernelName:mh,backendName:"webgl",kernelFunc:YU};function wC(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:a}=e,i=a.shape.length,o=a.shape.slice();let l=r;return r<0&&(O(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),Ee({inputs:{x:a},backend:s,attrs:{shape:o}})}const K1e={kernelName:Pp,backendName:"webgl",kernelFunc:wC};const W3="return exp(x) - 1.0;",X1e=xt({opSnippet:W3,packedOpSnippet:W3,cpuKernelImpl:xbe}),Y1e={kernelName:gh,backendName:"webgl",kernelFunc:X1e};class G3{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function JU(n,e,t){const s=t.texData.get(n.dataId),r=he(n.shape),a=n.shape[n.shape.length-1],i=r/a,o=Ee({inputs:{x:n},backend:t,attrs:{shape:[i,a]}}),l=o.shape,h=new G3("real",l,e),d=new G3("imag",l,e),f=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],m=t.runWebGLProgram(h,f,"float32"),y=t.runWebGLProgram(d,f,"float32"),b=Xo({inputs:{real:m,imag:y},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y);const x=Ee({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(b),x}function J1e(n){const{inputs:e,backend:t}=n,{input:s}=e;return JU(s,!1,t)}const Z1e={kernelName:Lb,backendName:"webgl",kernelFunc:J1e};class Q1e{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function lg(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:a}=t;if(a=a||hu(r),a==="string"){const i=tn(a,he(s));return i.fill(r),e.makeTensorInfo(s,a,i)}else{const i=new Q1e(s,r),o=[[r]];return e.runWebGLProgram(i,[],a,o)}}const eSe={kernelName:Mb,backendName:"webgl",kernelFunc:lg};class tSe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const nSe={kernelName:zb,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new tSe(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};const H3="return floor(x);",sSe=xt({opSnippet:H3,packedOpSnippet:H3,cpuKernelImpl:wbe}),rSe={kernelName:yh,backendName:"webgl",kernelFunc:sSe};const aSe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,iSe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,oSe=ts({opSnippet:aSe,packedOpSnippet:iSe,dtype:"int32"}),lSe={kernelName:bh,backendName:"webgl",kernelFunc:oSe};class uSe{constructor(e){this.variableNames=["A"];const t=Ss(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class cSe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Ss(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const hSe={kernelName:A0,backendName:"webgl",kernelFunc:dSe};let yc,jS=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function dSe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:a}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[l,h]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,l],f=[h,l,a];if(o||i){const x=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(yc==null||x!==jS)&&(jS=x,yc=document.createElement("canvas").getContext("2d",{willReadFrequently:jS})),yc.canvas.width=l,yc.canvas.height=h,yc.drawImage(r,0,0,l,h),r=yc.canvas}const m=t.makeTensorInfo(d,"int32");t.texData.get(m.dataId).usage=xr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),r);const y=ie().getBool("WEBGL_PACK")?new cSe(f):new uSe(f),b=t.runWebGLProgram(y,[m],"int32");return t.disposeData(m.dataId),b}function fSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:h,dataFormat:d,dilations:f,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=s,x=Li(d),w=Vn(r.shape,a.shape,l,f,h,m,!1,x);let v;const C=[],N=i!=null,k=o!=null,E=y==="leakyrelu",_=()=>{const D=[r,a],F=(L,A)=>{if(A==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){const V=Ee({inputs:{x:L},backend:t,attrs:{shape:[L.shape[0],1,1]}});return C.push(V),V}return L};if(N&&D.push(F(i,d)),k&&D.push(F(o,d)),E){const L=t.makeTensorInfo([],"float32",Oi(b,"float32"));D.push(L),C.push(L)}return D};if(w.filterHeight===1&&w.filterWidth===1&&w.dilationHeight===1&&w.dilationWidth===1&&w.strideHeight===1&&w.strideWidth===1&&(w.padInfo.type==="SAME"||w.padInfo.type==="VALID"))v=GU({x:r,filter:a,convInfo:w,backend:t,bias:i,activation:y,preluActivationWeights:o,leakyreluAlpha:b});else if(w.strideWidth<=2&&x==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){const D=y?fp(y,!0):null,F=new WU(w,N,D,k,E),L=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],A=_();v=t.runWebGLProgram(F,A,"float32",L)}else if(ie().getBool("WEBGL_CONV_IM2COL"))v=HU({x:r,filter:a,convInfo:w,backend:t,bias:i,activation:y,preluActivationWeights:o,leakyreluAlpha:b});else{const D=y?fp(y,!1):null,F=new jU(w,N,D,k,E),L=_();v=t.runWebGLProgram(F,L,"float32")}const R=Ee({inputs:{x:v},backend:t,attrs:{shape:w.outShape}});return C.push(v),C.forEach(D=>t.disposeIntermediateTensorInfo(D)),R}const pSe={kernelName:Zf,backendName:"webgl",kernelFunc:fSe};function mSe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=e,{strides:l,pad:h,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:y}=s,b=[];let x=d;x==null&&(x=[1,1]),O(Zn(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const w=Vn(r.shape,a.shape,l,x,h,f,!0),v=ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels===1,C=m?fp(m,v):null,N=[r,a],k=i!=null,E=o!=null,_=m==="leakyrelu";if(k&&N.push(i),E&&N.push(o),_){const L=t.makeTensorInfo([],"float32",Oi(y,"float32"));N.push(L),b.push(L)}let R;v?R=new XU(w,k,C,E,_):R=new KU(w,k,C,E,_);const D=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],F=t.runWebGLProgram(R,N,"float32",D);return b.forEach(L=>t.disposeIntermediateTensorInfo(L)),F}const gSe={kernelName:Qf,backendName:"webgl",kernelFunc:mSe};class ySe{constructor(e,t,s,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const a=It(s.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function bSe(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,a=r.shape,i=a[a.length-1],o=he(s.shape),[l,h,d,f]=ow(s,r),m=Ee({inputs:{x:r},backend:t,attrs:{shape:[h,i]}}),y=Ee({inputs:{x:s},backend:t,attrs:{shape:[he(s.shape)/d,d]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const v=t.readSync(r.dataId),C=t.bufferSync(s),N=vbe(v,C,s.dtype,h,i,d,f,s.shape,o);return t.makeTensorInfo(l,s.dtype,N.values)}const b=new ySe(i,f,[h,d],s.shape),x=t.runWebGLProgram(b,[y,m],y.dtype),w=Ee({inputs:{x},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),w}const xSe={kernelName:Pb,backendName:"webgl",kernelFunc:bSe};class wSe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=It(this.rank),r=vSe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function vSe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("index"):s.push(`${t[r]}`);return s.join()}function ZU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:a}=e,{axis:i,batchDims:o}=s,l=at(i,r.shape)[0];if(ie().get("DEBUG")){const C=t.readSync(a.dataId),N=r.shape[l];for(let k=0;k<C.length;++k){const E=C[k];O(E<=N-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${N-1}]`)}}const h=uk(r,a,l,o),d=he(a.shape),f=[],m=Ee({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),y=Ee({inputs:{x:a},backend:t,attrs:{shape:[h.batchSize,d/h.batchSize]}});f.push(m),f.push(y);const b=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const C=t.bufferSync(y),N=t.bufferSync(m),k=Sbe(N,C,b);return f.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(h.outputShape,k.dtype,k.values)}const x=new wSe(m.shape,b),w=t.runWebGLProgram(x,[m,y],m.dtype);f.push(w);const v=Ee({inputs:{x:w},backend:t,attrs:{shape:h.outputShape}});return f.forEach(C=>t.disposeIntermediateTensorInfo(C)),v}const SSe={kernelName:Vp,backendName:"webgl",kernelFunc:ZU};const TSe="return float(a > b);",CSe=`
  return vec4(greaterThan(a, b));
`,NSe=ts({opSnippet:TSe,packedOpSnippet:CSe,cpuKernelImpl:Tbe,dtype:"bool"}),kSe={kernelName:Up,backendName:"webgl",kernelFunc:NSe};const ESe="return float(a >= b);",$Se=`
  return vec4(greaterThanEqual(a, b));
`,ISe=ts({opSnippet:ESe,packedOpSnippet:$Se,dtype:"bool",cpuKernelImpl:Cbe}),_Se={kernelName:xh,backendName:"webgl",kernelFunc:ISe};function ASe(n){const{inputs:e,backend:t}=n,{input:s}=e;return JU(s,!0,t)}const RSe={kernelName:Bb,backendName:"webgl",kernelFunc:ASe};const DSe="return float(!isnan(x) && !isinf(x));",OSe=xt({opSnippet:DSe,dtype:"bool"}),FSe={kernelName:vh,backendName:"webgl",kernelFunc:OSe};const LSe="return float(isinf(x));",MSe=xt({opSnippet:LSe,dtype:"bool"}),zSe={kernelName:Sh,backendName:"webgl",kernelFunc:MSe};const PSe="return float(isnan(x));",BSe=xt({opSnippet:PSe,dtype:"bool"}),VSe={kernelName:Th,backendName:"webgl",kernelFunc:BSe};const USe="return float(a < b);",jSe=`
  return vec4(lessThan(a, b));
`,WSe=ts({opSnippet:USe,packedOpSnippet:jSe,cpuKernelImpl:Nbe,dtype:"bool"}),GSe={kernelName:Wp,backendName:"webgl",kernelFunc:WSe};const HSe="return float(a <= b);",qSe=`
  return vec4(lessThanEqual(a, b));
`,KSe=ts({opSnippet:HSe,packedOpSnippet:qSe,cpuKernelImpl:kbe,dtype:"bool"}),XSe={kernelName:Gp,backendName:"webgl",kernelFunc:KSe};function YSe(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:a}=t,i=Ebe(s,r,a);return e.makeTensorInfo([i.length],"float32",i)}const JSe={kernelName:Ub,backendName:"webgl",kernelFunc:YSe};const ZSe=gd+`
  return x < 0.0 ? 0./0. : log(x);
`,QSe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,eTe=xt({opSnippet:ZSe,packedOpSnippet:QSe,cpuKernelImpl:$be}),tTe={kernelName:Ch,backendName:"webgl",kernelFunc:eTe};const nTe=gd+`
  return log(1.0 + x);
`,sTe=xt({opSnippet:nTe}),rTe={kernelName:Nh,backendName:"webgl",kernelFunc:sTe};const aTe="return float(a >= 1.0 && b >= 1.0);",iTe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,oTe=ts({opSnippet:aTe,packedOpSnippet:iTe,dtype:"bool"}),lTe={kernelName:Hp,backendName:"webgl",kernelFunc:oTe};const uTe="return float(!(x >= 1.0));",cTe=xt({opSnippet:uTe}),hTe={kernelName:qp,backendName:"webgl",kernelFunc:cTe};const dTe="return float(a >= 1.0 || b >= 1.0);",fTe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,pTe=ts({opSnippet:dTe,packedOpSnippet:fTe,dtype:"bool"}),mTe={kernelName:Kp,backendName:"webgl",kernelFunc:pTe};class gTe{constructor(e,t,s,r,a){this.variableNames=["x"],this.outputShape=[];const i=t,o=e[3]-1;this.outputShape=e;let l;const h=`float(${s}) + float(${r}) * sum`;a===.5?l=`inversesqrt(${h})`:a===1?l=`1.0/(${h})`:l=`exp(log(${h}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}class yTe{constructor(e,t,s,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,o=e[3]-1;this.outputShape=e;let l;const h=`float(${s}) + float(${r}) * sum`;a===.5?l=`inversesqrt(${h})`:a===1?l=`1.0/(${h})`:l=`exp(log(${h}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}const bTe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:a,bias:i,alpha:o,beta:l}=s,h=ie().getBool("WEBGL_PACK_NORMALIZATION")?new yTe(r.shape,a,i,o,l):new gTe(r.shape,a,i,o,l);return t.runWebGLProgram(h,[r],r.dtype)},xTe={kernelName:Xp,backendName:"webgl",kernelFunc:bTe};class wTe{constructor(e,t,s,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const vTe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:a,dy:i}=e,{depthRadius:o,bias:l,alpha:h,beta:d}=s,f=new wTe(r.shape,o,l,h,d);return t.runWebGLProgram(f,[r,a,i],r.dtype)},STe={kernelName:jb,backendName:"webgl",kernelFunc:vTe};function TTe(n,e,t,s){const r=he(e),i=he(n.shape)/r,o=Ee({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),l=Cu(o,n.dtype,"max",s),h=Ee({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),h}function QU(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:a,keepDims:i}=s,o=r.shape.length,l=at(a,r.shape);let h=l;const d=Zt(h,o),f=d!=null,m=t.shouldExecuteOnCPU([r]);let y=r;if(f){if(m){const N=t.texData.get(y.dataId).values,k=new Array(o);for(let R=0;R<k.length;R++)k[R]=r.shape[d[R]];const E=c$(N,r.shape,r.dtype,d,k);y=t.makeTensorInfo(k,r.dtype);const _=t.texData.get(y.dataId);_.values=E}else y=Fw(r,d,t);h=cn(h.length,o)}Qn("max",h,o);const[b,x]=Un(y.shape,h);let w=b;i&&(w=un(b,l));let v;if(m){const N=t.texData.get(y.dataId).values,k=Ibe(N,he(x),w,r.dtype);v=t.makeTensorInfo(w,r.dtype);const E=t.texData.get(v.dataId);E.values=k}else v=TTe(y,x,w,t);return f&&t.disposeIntermediateTensorInfo(y),v}const CTe={kernelName:Yp,backendName:"webgl",kernelFunc:QU};const NTe=h$+`
  return max(a, b);
`,kTe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Tu+`
  return result;
`,ETe=ts({opSnippet:NTe,packedOpSnippet:kTe,cpuKernelImpl:_be}),$Te={kernelName:kh,backendName:"webgl",kernelFunc:ETe};function ITe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;cd(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=s,h=1;O(Zn(i,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const d=Kr(r.shape,a,i,h,o,l);if(d.filterWidth===1&&d.filterHeight===1&&lt(d.inShape,d.outShape))return Qs({inputs:{x:r},backend:t});const f=new pp(d,"max",!1);return t.runWebGLProgram(f,[r],r.dtype)}const _Te={kernelName:Jp,backendName:"webgl",kernelFunc:ITe};function ATe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:h}=s,d=[1,1,1],f=Fi(r.shape,a,i,d,o,h,l),m=new f$(f,"max",!1);return t.runWebGLProgram(m,[r],r.dtype)}const RTe={kernelName:Zp,backendName:"webgl",kernelFunc:ATe};class DTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,o=a-1-e.padInfo.top,l=i-1-e.padInfo.left,h=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class OTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.front,m=h-1-e.padInfo.top,y=d-1-e.padInfo.left,b=l*h*d-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${h} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function FTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,i=a,{filterSize:o,strides:l,pad:h,dimRoundingMode:d}=s,f=[1,1,1],m=Fi(i.shape,o,l,f,h,d),y=new f$(m,"max",!0),b=t.runWebGLProgram(y,[i],i.dtype),x=new OTe(m),w=t.runWebGLProgram(x,[r,b],i.dtype);return t.disposeIntermediateTensorInfo(b),w}const LTe={kernelName:Gb,backendName:"webgl",kernelFunc:FTe};function MTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a,output:i}=e,o=a;cd([a,i],"maxPoolGrad");const{filterSize:l,strides:h,pad:d,dimRoundingMode:f}=s,m=Kr(o.shape,l,h,1,d,f),y=!0,b=new pp(m,"max",y),x=t.runWebGLProgram(b,[o],o.dtype),w=new DTe(m),v=t.runWebGLProgram(w,[r,x],o.dtype);return t.disposeIntermediateTensorInfo(x),v}const zTe={kernelName:Wb,backendName:"webgl",kernelFunc:MTe};function PTe(n,e,t,s){let r=new pp(t,"max",!1);const a=s.runWebGLProgram(r,[n],"float32");r=new pp(t,"max",!0,!0,e);const i=s.runWebGLProgram(r,[n],"float32");return[a,i]}const BTe={kernelName:Hb,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=e,l=t;O(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const h=[1,1];O(Zn(a,h),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${h}'`);const d=Kr(s.shape,r,a,h,i),[f,m]=PTe(s,o,d,l);return[f,m]}};function VTe(n,e,t,s){const r=he(e),i=he(n.shape)/r,o=Ee({inputs:{x:n},attrs:{shape:[i,r]},backend:s}),l=Cu(o,"float32","mean",s),h=Ee({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(l),h}const UTe={kernelName:Qp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:a}=e,i=t,o=s.shape.length,l=at(a,s.shape);let h=l;const d=Zt(h,o),f=d!=null,m=i.shouldExecuteOnCPU([s]),y=[];let b=s;if(f){if(m){const k=i.texData.get(b.dataId).values,E=new Array(o);for(let D=0;D<E.length;D++)E[D]=s.shape[d[D]];const _=c$(k,s.shape,s.dtype,d,E);b=i.makeTensorInfo(E,s.dtype);const R=i.texData.get(b.dataId);R.values=_}else b=Fw(s,d,i);y.push(b),h=cn(h.length,o)}Qn("sum",h,o);const[x,w]=Un(b.shape,h);let v=x;r&&(v=un(x,l));const C=VTe(b,w,v,i);for(const N of y)i.disposeIntermediateTensorInfo(N);return C}};function jTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=at(a,r.shape);let h=l;const d=Zt(h,o);let f=r;d!=null&&(f=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),h=cn(h.length,r.shape.length)),Qn("min",h,o);const[m,y]=Un(f.shape,h),b=he(y),x=Ee({inputs:{x:f},backend:t,attrs:{shape:[-1,b]}}),w=Cu(x,x.dtype,"min",t);let v;if(i){const C=un(m,l);v=Ee({inputs:{x:w},backend:t,attrs:{shape:C}})}else v=Ee({inputs:{x:w},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),d!=null&&t.disposeIntermediateTensorInfo(f),v}const WTe={kernelName:em,backendName:"webgl",kernelFunc:jTe};const GTe=h$+`
  return min(a, b);
`,HTe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Tu+`
  return result;
`,qTe=ts({opSnippet:GTe,packedOpSnippet:HTe,cpuKernelImpl:Abe}),KTe={kernelName:Eh,backendName:"webgl",kernelFunc:qTe};class XTe{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((d,f)=>d[0]+e[f]+d[1]);const r=e.length,a=It(r),i=t.map(d=>d[0]).join(","),o=t.map((d,f)=>d[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${h};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${h};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${h};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}class YTe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((b,x)=>b[0]+e[x]+b[1]);const r=e.length,a=It(r),i=t.map(b=>b[0]).join(","),o=t.map((b,x)=>b[0]+e[x]).join(","),l=gs("rc",r),h=gs("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${h.slice(-2).join()})`,m=s==="reflect"?0:1;let y="";if(r===1){const b=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${a} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${f});
        ${l[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${f});
        }
      `}else{const b=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${a} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${h.join()}), ${f});
        ${l[r-1]} += 1;
        if(${d}) {
          ${b}
          result[1] = getChannel(getX(${h.join()}), ${f});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${b}
          result[2] = getChannel(getX(${h.join()}), ${f});
          ${l[r-1]} += 1;
          if(${d}) {
            ${b}
            result[3] = getChannel(getX(${h.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const JTe=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:a}=t,i=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YTe(s.shape,r,a):new XTe(s.shape,r,a);return e.runWebGLProgram(i,[s],s.dtype)},ZTe={kernelName:tm,backendName:"webgl",kernelFunc:JTe};const QTe=`if (b == 0.0) return NAN;
  return mod(a, b);`,eCe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Tu+`
  return result;
`,tCe=ts({opSnippet:QTe,packedOpSnippet:eCe}),nCe={kernelName:$h,backendName:"webgl",kernelFunc:tCe};class sCe{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const rCe=`
if (a == b) {
  return 1.0;
};
return a / b;`,aCe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,ej=ts({opSnippet:rCe,packedOpSnippet:aCe,checkOutOfBounds:!0}),iCe={kernelName:dh,backendName:"webgl",kernelFunc:ej};const q3="return a - b;",tj=ts({opSnippet:q3,packedOpSnippet:q3,supportsComplex:!0,cpuKernelImpl:Zbe}),oCe={kernelName:Wh,backendName:"webgl",kernelFunc:tj};function nj(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:a}=s,i=at([a],r.shape),o=QU({inputs:{x:r},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),l=un(o.shape,i),h=Ee({inputs:{x:o},backend:t,attrs:{shape:l}}),d=tj({inputs:{a:r,b:h},backend:t}),f=YU({inputs:{x:d},backend:t}),m=Lw({inputs:{x:f},backend:t,attrs:{axis:i,keepDims:!1}}),y=Ee({inputs:{x:m},backend:t,attrs:{shape:l}}),b=ej({inputs:{a:f,b:y},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const lCe={kernelName:xm,backendName:"webgl",kernelFunc:nj};function uCe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:a,seed:i,normalized:o}=s,l=o?r:nj({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),h=l.shape[0],d=l.shape[1],f=new sCe(h,d,a),m=[[i]],y=t.runWebGLProgram(f,[l],"int32",m);return o||t.disposeIntermediateTensorInfo(l),y}const cCe={kernelName:qb,backendName:"webgl",kernelFunc:uCe};const hCe=Yr+`
  return -x;
`,dCe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function fCe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const a=t.texData.get(s.dataId),[i,o]=Dbe(a.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,i)}let r;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new vo(s.shape,dCe):r=new La(s.shape,hCe),t.runWebGLProgram(r,[s],s.dtype)}const pCe={kernelName:nm,backendName:"webgl",kernelFunc:fCe};const mCe=sw;function gCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=s,h=t.readSync(r.dataId),d=t.readSync(a.dataId),{selectedIndices:f}=mCe(h,d,i,o,l);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const yCe={kernelName:Kb,backendName:"webgl",kernelFunc:gCe};const bCe=rw;function xCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:h}=s,d=t.readSync(r.dataId),f=t.readSync(a.dataId),{selectedIndices:m,validOutputs:y}=bCe(d,f,i,o,l,h);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}const wCe={kernelName:Xb,backendName:"webgl",kernelFunc:xCe};const vCe=aw;function SCe(n){gr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:h}=s,d=t.readSync(r.dataId),f=t.readSync(a.dataId),m=i,y=o,b=l,x=h,{selectedIndices:w,selectedScores:v}=vCe(d,f,m,y,b,x);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const TCe={kernelName:Yb,backendName:"webgl",kernelFunc:SCe};class CCe{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}const NCe=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{dtype:a,depth:i,onValue:o,offValue:l}=s,h=he(r.shape),d=new CCe(h,i,o,l),f=Ee({inputs:{x:r},backend:t,attrs:{shape:[h]}}),m=t.runWebGLProgram(d,[f],a);t.disposeIntermediateTensorInfo(f);const y=[...r.shape,i],b=Ee({inputs:{x:m},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(m),b},kCe={kernelName:am,backendName:"webgl",kernelFunc:NCe};function tb(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=og({inputs:{input:s},backend:t}),a=tb({inputs:{x:r},backend:t}),i=Mw({inputs:{input:s},backend:t}),o=tb({inputs:{x:i},backend:t}),l=Xo({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),l}else return lg({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const ECe={kernelName:Tm,backendName:"webgl",kernelFunc:tb};function sj(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=og({inputs:{input:s},backend:t}),a=sj({inputs:{x:r},backend:t}),i=Mw({inputs:{input:s},backend:t}),o=tb({inputs:{x:i},backend:t}),l=Xo({inputs:{real:a,imag:o},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),l}else return lg({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const $Ce={kernelName:rm,backendName:"webgl",kernelFunc:sj};function ICe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return wC({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const a=e[0].shape,i=e[0].dtype;e.forEach(d=>{Jn(a,d.shape,"All tensors passed to stack must have matching shapes"),O(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(d=>{const f=wC({inputs:{input:d},backend:t,attrs:{dim:r}});return o.push(f),f}),h=UU({inputs:l,backend:t,attrs:{axis:r}});return o.forEach(d=>t.disposeIntermediateTensorInfo(d)),h}const _Ce={kernelName:im,backendName:"webgl",kernelFunc:ICe};class ACe{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,d)=>h[0]+e[d]+h[1]);const r=e.length,a=It(r),i=t.map(h=>h[0]).join(","),o=t.map((h,d)=>h[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}class RCe{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,w)=>x[0]+e[w]+x[1]);const r=e.length,a=It(r),i=t.map(x=>x[0]).join(","),o=t.map((x,w)=>x[0]+e[w]).join(","),l=gs("rc",r),h=gs("source",r),d=`${l[r-1]} < ${this.outputShape[r-1]}`,f=r===1?"source":`vec2(${h.slice(-2).join()})`,m=[`${a} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${d}) {`],y=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let x=0,w=r===1?2:4;x<w;x++)b+=`
        ${m[x]}
        if (${y}) {
          result[${x}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${x}] = getChannel(getX(${h.join()}), ${f});
        }
      `;b+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const rj=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:a,constantValue:i}=s;if(he(r.shape)===0){const h=a.map((d,f)=>d[0]+r.shape[f]+d[1]);return lg({backend:t,attrs:{shape:h,value:i,dtype:r.dtype}})}const o=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RCe(r.shape,a,i):new ACe(r.shape,a,i),l=[[i]];return t.runWebGLProgram(o,[r],r.dtype,l)},DCe={kernelName:om,backendName:"webgl",kernelFunc:rj};const OCe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,FCe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Tu+`
  return result;
`,LCe=ts({opSnippet:OCe,packedOpSnippet:FCe}),MCe={kernelName:_h,backendName:"webgl",kernelFunc:LCe};function zCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:i}=s,o=r.shape.length,l=[],h=at(a,r.shape);let d=h;const f=Zt(d,o);let m=r;f!=null&&(m=xs({inputs:{x:r},backend:t,attrs:{perm:f}}),d=cn(d.length,o),l.push(m)),Qn("prod",d,o);let y;if(t.shouldExecuteOnCPU([m])){const b=t.texData.get(m.dataId).values,{outVals:x,outShape:w,outDtype:v}=Fbe(m.shape,m.dtype,b,d);y=t.makeTensorInfo(w,v,x)}else{const[b,x]=Un(m.shape,d),w=he(x),v=Ee({inputs:{x:m},backend:t,attrs:{shape:[-1,w]}}),C=Sx(r.dtype),N=Cu(v,C,"prod",t);y=Ee({inputs:{x:N},backend:t,attrs:{shape:b}}),l.push(v),l.push(N)}if(i){l.push(y);const b=un(y.shape,h);y=Ee({inputs:{x:y},backend:t,attrs:{shape:b}})}return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const PCe={kernelName:um,backendName:"webgl",kernelFunc:zCe};function BCe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=e,{outputRaggedRank:o}=s,l=r.map(v=>t.readSync(v.dataId)),h=r.map(v=>v.shape),d=t.readSync(a.dataId),f=t.readSync(i.dataId),[m,y,b]=Lbe(l,h,d,a.shape,a.dtype,f,i.shape,o),x=m.map(v=>t.makeTensorInfo([v.length],"int32",v)),w=t.makeTensorInfo(b,a.dtype,y);return x.concat([w])}const VCe={kernelName:Jb,backendName:"webgl",kernelFunc:BCe};function UCe(n){const{inputs:e,backend:t}=n,{starts:s,limits:r,deltas:a}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(a.dataId),[h,d]=Mbe(i,s.shape,s.dtype,o,r.shape,l,a.shape),f=t.makeTensorInfo([h.length],"int32",h),m=t.makeTensorInfo([d.length],s.dtype,d);return[f,m]}const jCe={kernelName:Zb,backendName:"webgl",kernelFunc:UCe};function WCe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,h=t.readSync(r.dataId),d=t.readSync(a.dataId),f=t.readSync(i.dataId),m=o.map(w=>t.readSync(w.dataId)),y=o.map(w=>w.shape),[b,x]=zbe(h,r.shape,d,a.shape,a.dtype,f,i.shape,m,y,l);return t.makeTensorInfo(b,a.dtype,x)}const GCe={kernelName:Qb,backendName:"webgl",kernelFunc:WCe};const aj=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:a,dtype:i}=t,o=Pbe(s,r,a,i);return e.makeTensorInfo([o.length],i,o)},HCe={kernelName:ex,backendName:"webgl",kernelFunc:aj};const qCe="return 1.0 / x;",KCe=xt({opSnippet:qCe}),XCe={kernelName:Ah,backendName:"webgl",kernelFunc:KCe};const YCe=Yr+`
  return (x < 0.0) ? 0.0 : x;
`,JCe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZCe=xt({opSnippet:YCe,packedOpSnippet:JCe}),QCe={kernelName:Rh,backendName:"webgl",kernelFunc:ZCe};const e2e=Yr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,t2e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,n2e=xt({opSnippet:e2e,packedOpSnippet:t2e}),s2e={kernelName:Dh,backendName:"webgl",kernelFunc:n2e};class r2e{constructor(e,t,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,h]=e;this.outputShape=[i,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;a?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class a2e{constructor(e,t,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,h]=e;this.outputShape=[i,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s];let m;a?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function i2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s,[l,h]=o,d=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new a2e(r.shape,l,h,a,i):new r2e(r.shape,l,h,a,i);return t.runWebGLProgram(d,[r],"float32")}const o2e={kernelName:dm,backendName:"webgl",kernelFunc:i2e};class l2e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,i,o]=e,l=[s&&i>1?r-1:r,s&&o>1?a-1:a],h=[s&&i>1?i-1:i,s&&o>1?o-1:o],d=l[0]/h[0],f=l[1]/h[1],m=1/d,y=1/f,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function u2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:i}=s,o=new l2e(a.shape,r.shape,i);return t.runWebGLProgram(o,[a],a.dtype)}const c2e={kernelName:sx,backendName:"webgl",kernelFunc:u2e};class h2e{constructor(e,t,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,h]=e;this.outputShape=[i,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;a?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/f[0]},
          ${d[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class d2e{constructor(e,t,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,h]=e;this.outputShape=[i,t,s,h];const d=[r&&t>1?o-1:o,r&&s>1?l-1:l],f=[r&&t>1?t-1:t,r&&s>1?s-1:s],m=r?"0.5":"0.0";let y;a?y="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":y="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/f[0]},
          ${d[1]/f[1]},
          ${d[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${h-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function f2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:i,size:o}=s,[l,h]=o,d=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new d2e(r.shape,l,h,a,i):new h2e(r.shape,l,h,a,i);return t.runWebGLProgram(d,[r],r.dtype)}const p2e={kernelName:hm,backendName:"webgl",kernelFunc:f2e};class m2e{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,i,o]=e,l=[s&&i>1?r-1:r,s&&o>1?a-1:a],h=[s&&i>1?i-1:i,s&&o>1?o-1:o],d=l[0]/h[0],f=l[1]/h[1],m=1/d,y=1/f,b=Math.ceil(m)*2+2,x=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${f});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${h[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${h[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function g2e(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:i}=s,o=new m2e(a.shape,r.shape,i);return t.runWebGLProgram(o,[a],a.dtype)}const y2e={kernelName:nx,backendName:"webgl",kernelFunc:g2e};class b2e{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,a=e.map((o,l)=>r(l)).join(","),i=It(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}class x2e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=gs("rc",s),a=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=It(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${a}){
            result.g = ${h(r.slice())};
          }
          if(${i}) {
            result.b = ${d(r.slice())};
            if(${a}) {
              result.a = ${f(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(b){return m(b)}function h(b){return b[s-1]="("+b[s-1]+" + 1)",m(b)}function d(b){return b[s-2]="("+b[s-2]+" + 1)",m(b)}function f(b){return b[s-1]="("+b[s-1]+" + 1)",b[s-2]="("+b[s-2]+" + 1)",m(b)}function m(b){const x=e.map((C,N)=>y(N,b)),w=x.join(","),v=x.slice(-2).join(",");return`getChannel(getX(${w}), vec2(${v}))`}function y(b,x){return t.indexOf(b)!==-1&&e[b]!==1?`${e[b]} - ${x[b]} - 1`:`${x[b]}`}}}function w2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:a}=s,i=r.shape.length,o=at(a,r.shape);if(i===0)return Qs({inputs:{x:r},backend:t});const l=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new x2e(r.shape,o):new b2e(r.shape,o);return t.runWebGLProgram(l,[r],r.dtype)}const v2e={kernelName:fm,backendName:"webgl",kernelFunc:w2e};class S2e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const T2e={kernelName:wx,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:a,center:i}=e,o=t,l=new S2e(s.shape,a),[h,d]=qN(i,s.shape[1],s.shape[2]),f=[[h,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[s],s.dtype,f)}};const C2e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,N2e=xt({opSnippet:C2e}),k2e={kernelName:Oh,backendName:"webgl",kernelFunc:N2e};const E2e="return inversesqrt(x);",$2e=xt({opSnippet:E2e,cpuKernelImpl:Bbe}),I2e={kernelName:Fh,backendName:"webgl",kernelFunc:$2e};class p${constructor(e,t,s,r,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const h=It(a.length),d=It(i.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,v=t>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${a});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${b};
              found = true;
            }
          }
          setOutput(mix(${w}, sum, float(found)));
        }
      `}}class _2e{constructor(e,t,s,r,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const h=It(a.length),d=It(i.length);let f="";s===1?f="i":s===2&&(f="i, j");const m=`getIndices(${f})`;let y="";r===1?y="i":r===2&&(y="i, coords[1]");const b=`getUpdates(${y})`;let x="";l&&(x="coords[0], coords[1]");const w=`getDefaultValue(${x})`,v=t>1?"strides[j]":"strides",C=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${h} strides = ${h}(${a});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${m});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${C};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${b};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${w}, sum, found));
        }
      `}}function A2e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:a}=e,{shape:i}=s,{sliceRank:o,numUpdates:l,sliceSize:h,strides:d,outputSize:f}=qo(a,r,i),m=[f/h,h];if(f===0)return t.makeTensorInfo(i,r.dtype);const y=Ee({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),b=Ee({inputs:{x:a},backend:t,attrs:{shape:[l,h]}}),x=t.makeTensorInfo([],"float32",new Float32Array([0]));let w;ie().getBool("WEBGL_PACK")?w=new _2e(l,o,y.shape.length,b.shape.length,d,m):w=new p$(l,o,y.shape.length,b.shape.length,d,m);const v=t.runWebGLProgram(w,[b,y,x],b.dtype),C=Ee({inputs:{x:v},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(x),C}const R2e={kernelName:rx,backendName:"webgl",kernelFunc:A2e};class D2e{constructor(e,t,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=ie().getNumber("WEBGL_VERSION")===2?a:i,l=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function O2e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:r,values:a}=e,{side:i}=s,o=new D2e(r.shape[0],r.shape[1],a.shape[1],i),l=[[r.shape[1]]];return t.runWebGLProgram(o,[r,a],"int32",l)}const F2e={kernelName:ix,backendName:"webgl",kernelFunc:O2e};class L2e{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)a="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],h=[];for(let d=0;d<t.length;d++)h.push(`${o[d]}`),d<e&&l.push(`${o[d]}`);r=l.join(),a=h.join()}const i=It(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}function M2e(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:a}=e,i=new L2e(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(i,[s,r,a],_s(r.dtype,a.dtype))}const z2e={kernelName:pm,backendName:"webgl",kernelFunc:M2e};const P2e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${cw};
  float scale = ${hw};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,B2e=xt({opSnippet:P2e}),V2e={kernelName:Lh,backendName:"webgl",kernelFunc:B2e};const U2e=gd+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,j2e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,W2e=xt({opSnippet:U2e,packedOpSnippet:j2e,cpuKernelImpl:Ube}),G2e={kernelName:Bh,backendName:"webgl",kernelFunc:W2e};const H2e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,q2e=xt({opSnippet:H2e}),K2e={kernelName:Ph,backendName:"webgl",kernelFunc:q2e};const X2e=gd+`
  return sin(x);
`,Y2e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Tu}
  return result;
`,J2e=xt({opSnippet:X2e,packedOpSnippet:Y2e}),Z2e={kernelName:Mh,backendName:"webgl",kernelFunc:J2e};const Q2e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,eNe=xt({opSnippet:Q2e}),tNe={kernelName:zh,backendName:"webgl",kernelFunc:eNe};const nNe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,sNe=xt({opSnippet:nNe}),rNe={kernelName:Vh,backendName:"webgl",kernelFunc:sNe};const aNe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,paddings:i}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((v,C)=>v*C),l=[[0,0]];l.push(...i);for(let v=1+a.length;v<r.shape.length;++v)l.push([0,0]);const h=[],d=rj({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),f=Wm(d.shape,a,o,!1),m=Gm(f.length,a.length,!1),y=Hm(d.shape,a,o,!1),b=Ee({inputs:{x:d},backend:t,attrs:{shape:f}}),x=xs({inputs:{x:b},backend:t,attrs:{perm:m}}),w=Ee({inputs:{x},backend:t,attrs:{shape:y}});return h.push(d),h.push(b),h.push(x),h.forEach(v=>t.disposeIntermediateTensorInfo(v)),w},iNe={kernelName:ym,backendName:"webgl",kernelFunc:aNe};function oNe(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:a,defaultValue:i}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=t.readSync(s.dataId),l=t.readSync(r.dataId),h=t.readSync(a.dataId),d=t.readSync(i.dataId)[0],[f,m,y,b,x]=Wbe(o,s.shape,s.dtype,l,r.dtype,h,d);return[t.makeTensorInfo(m,s.dtype,f),t.makeTensorInfo([m[0]],r.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([x.length],s.dtype,new Int32Array(x))]}const lNe={kernelName:ox,backendName:"webgl",kernelFunc:oNe};function uNe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(t.readSync(r.dataId)),o=t.readSync(s.dataId),l=Array.from(t.readSync(a.dataId)),[h,d,f]=Gbe(o,s.shape,s.dtype,i,l);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}const cNe={kernelName:lx,backendName:"webgl",kernelFunc:uNe};function hNe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(a.dataId),[h,d]=EU(i,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(d,s.dtype,h)}const dNe={kernelName:ux,backendName:"webgl",kernelFunc:hNe};function fNe(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=t.readSync(s.dataId),o=t.readSync(r.dataId),l=t.readSync(a.dataId),[h,d]=EU(i,s.shape,s.dtype,o,l);return t.makeTensorInfo(d,s.dtype,h)}const pNe={kernelName:cx,backendName:"webgl",kernelFunc:fNe};function mNe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:i}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:h,sliceSize:d,strides:f,outputSize:m}=qo(a,r,o),y=!1;if(a.dtype==="string"){const v=t.bufferSync(r),C=t.bufferSync(a),N=ki(t.readSync(i.dataId)[0]),k=Vbe(v,C,o,m,d,h,l,f,N,y);return t.makeTensorInfo(o,k.dtype,k.values)}const b=new p$(h,l,r.shape.length,a.shape.length,f,[m,1],y),x=t.runWebGLProgram(b,[a,r,i],a.dtype),w=Ee({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(x),w}const gNe={kernelName:hx,backendName:"webgl",kernelFunc:mNe};function yNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:a,axis:i}=s,o=at(i,r.shape)[0],l=lk(r,a,o),h=r.shape.length,d=new Array(h).fill(0),f=r.shape.slice();return l.map(m=>{const y=[...f];y[o]=m;const b=yd({inputs:{x:r},backend:t,attrs:{begin:d,size:y}});return d[o]+=m,b})}const bNe={kernelName:bm,backendName:"webgl",kernelFunc:yNe};const K3="return sqrt(x);",xNe=xt({opSnippet:K3,packedOpSnippet:K3,cpuKernelImpl:Hbe}),wNe={kernelName:Uh,backendName:"webgl",kernelFunc:xNe};const vNe="return x * x;",SNe=xt({opSnippet:vNe}),TNe={kernelName:dx,backendName:"webgl",kernelFunc:SNe};const X3="return (a - b) * (a - b);",CNe=ts({opSnippet:X3,packedOpSnippet:X3}),NNe={kernelName:jh,backendName:"webgl",kernelFunc:CNe};function kNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const a=t.readSync(r.dataId),i=Ai(a),o=qbe(i,"string",s);return t.makeTensorInfo(r.shape,"string",o)}const ENe={kernelName:wm,backendName:"webgl",kernelFunc:kNe};function $Ne({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Yr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new La(s.shape,r);return t.runWebGLProgram(a,[s],s.dtype)}const INe={kernelName:Kh,backendName:"webgl",kernelFunc:$Ne};class _Ne{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,a=It(s.length),i=It(s.length);let o="";if(r===1)o="coords * strides + begin";else{let l=0;o=s.map((h,d)=>(l++,s.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${l-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}function ANe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,end:i,strides:o,beginMask:l,endMask:h,ellipsisMask:d,newAxisMask:f,shrinkAxisMask:m}=s,{finalShapeSparse:y,finalShape:b,isIdentity:x,sliceDim0:w,isSimpleSlice:v,begin:C,end:N,strides:k}=jN(r.shape,a,i,o,l,h,d,f,m);let E;if(x)E=Ee({inputs:{x:r},backend:t,attrs:{shape:b}});else if(w||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const R=BN(C,N,k),D=yd({inputs:{x:r},backend:t,attrs:{begin:C,size:R}});E=Ee({inputs:{x:D},backend:t,attrs:{shape:b}}),t.disposeIntermediateTensorInfo(D)}else if(t.shouldExecuteOnCPU([r])){const D=t.readSync(r.dataId),F=tt(r.shape,r.dtype,D),L=Kbe(y,F,k,C);E=t.makeTensorInfo(b,r.dtype,L.values)}else{const D=new _Ne(C,k,y);E=t.runWebGLProgram(D,[r],r.dtype)}const _=Ee({inputs:{x:E},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(E),_}const RNe={kernelName:fx,backendName:"webgl",kernelFunc:ANe};function DNe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:h}=s,{data:d,dataSplits:f}=e,m=t.readSync(d.dataId),y=t.readSync(f.dataId),[b,x]=Xbe(m,y,r,a,i,o,l,h);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(f.shape,"int32",x)]}const ONe={kernelName:px,backendName:"webgl",kernelFunc:DNe};function FNe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:i}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=t.readSync(a.dataId),l=t.readSync(i.dataId)[0],[h,d,f]=Ybe(o,l,r),m=d.length;return[t.makeTensorInfo([m,2],"int32",h),t.makeTensorInfo([m],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const LNe={kernelName:mx,backendName:"webgl",kernelFunc:FNe};function MNe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(a.dataId),o=Jbe(i,r);return t.makeTensorInfo(a.shape,"int32",o)}const zNe={kernelName:gx,backendName:"webgl",kernelFunc:MNe};const PNe="return tan(x);",BNe=xt({opSnippet:PNe}),VNe={kernelName:Gh,backendName:"webgl",kernelFunc:BNe};const UNe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,jNe=xt({opSnippet:UNe}),WNe={kernelName:Hh,backendName:"webgl",kernelFunc:jNe};function GNe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:r,indices:a,updates:i}=e,{sliceRank:o,numUpdates:l,sliceSize:h,strides:d,outputSize:f}=qo(i,a,r.shape),m=[f/h,h];if(f===0)return t.makeTensorInfo(r.shape,a.dtype);const y=Ee({inputs:{x:a},backend:t,attrs:{shape:[l,o]}}),b=Ee({inputs:{x:i},backend:t,attrs:{shape:[l,h]}}),x=Ee({inputs:{x:r},backend:t,attrs:{shape:m}}),w=new p$(l,o,y.shape.length,b.shape.length,d,m,!1,!0),v=t.runWebGLProgram(w,[b,y,x],x.dtype),C=Ee({inputs:{x:v},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(v),C}const HNe={kernelName:ax,backendName:"webgl",kernelFunc:GNe};class qNe{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*t[i];this.outputShape=s,this.rank=s.length;const r=It(this.rank),a=KNe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function KNe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}function ij(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:a}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),h=r.dtype==="string"?l.map(m=>ki(m)):l,d=tt(r.shape,r.dtype,h),f=Qbe(d,a);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const i=new qNe(r.shape,a);return t.runWebGLProgram(i,[r],r.dtype)}const XNe={kernelName:qh,backendName:"webgl",kernelFunc:ij};class YNe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class JNe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function vl(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Y3(n){let e=1;for(;e<n;)e*=2;return e}function ZNe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:a,sorted:i}=s,o=ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),h=r.shape,d=h[h.length-1];if(t.shouldExecuteOnCPU([r])||d<o||a>l){const L=t.readSync(r.dataId),[A,V]=exe(L,h,r.dtype,a,i);return[t.makeTensorInfo(A.shape,A.dtype,A.values),t.makeTensorInfo(V.shape,V.dtype,V.values)]}if(a===0)return h[h.length-1]=0,[t.makeTensorInfo(h,r.dtype,[]),t.makeTensorInfo(h,"int32",[])];if(d===1)return[r,lg({attrs:{shape:h,dtype:"int32",value:0},backend:t})];const f=t.texData.get(r.dataId),m=f!==null&&f.isPacked,y=m?t.unpackTensor(r):r,x=he(h)/d,w=Ee({inputs:{x:y},attrs:{shape:[x,d]},backend:t});m&&vl(t,y);const v=Y3(a),C=Y3(d);let N=null;const k=()=>N===null?[w,w]:[w,N],E=(L,A,V)=>{const q=k(),ne=new YNe(V),B=[[d],[N===null?1:0],[Number.NEGATIVE_INFINITY],[L],[A]],U=N;N=t.runWebGLProgram(ne,q,"int32",B),vl(t,U)};for(let L=1;L<v;L*=2){const A=L*2;for(let V=L;V>=1;V/=2)E(A,V,[x,C])}for(let L=C;L>v;L/=2){const A=k(),V=new JNe([x,L/2]),ne=[[d],[N===null?1:0],[v]],Q=N;N=t.runWebGLProgram(V,A,"int32",ne),vl(t,Q);const B=v/2,U=B*2;for(let X=B;X>=1;X/=2)E(U,X,N.shape)}let _=N;N=yd({inputs:{x:N},backend:t,attrs:{begin:0,size:[x,a]}}),vl(t,_);let R=ZU({inputs:{x:w,indices:N},backend:t,attrs:{axis:1,batchDims:1}});vl(t,w);const D=h.slice(0,-1);D.push(a),_=N,N=Ee({inputs:{x:N},attrs:{shape:D},backend:t}),vl(t,_);const F=R;return R=Ee({inputs:{x:R},attrs:{shape:D},backend:t}),vl(t,F),[R,N]}const QNe={kernelName:yx,backendName:"webgl",kernelFunc:ZNe};class eke{constructor(e,t,s,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function tke(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:a}=e,{interpolation:i,fillMode:o,fillValue:l,outputShape:h}=s,[d,f,m,y]=r.shape,[b,x]=h??[f,m],w=[d,b,x,y],v=new eke(f,m,i,o,l,w);return t.runWebGLProgram(v,[r,a],"float32")}const nke={kernelName:bx,backendName:"webgl",kernelFunc:tke};function ske(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:a}=e;cd(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(a.dataId),{outputValues:o,outputShape:l,indices:h}=txe(i,r,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,o),s.makeTensorInfo([h.length],"int32",h)]}const rke={kernelName:xx,backendName:"webgl",kernelFunc:ske};function ake(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r,o=i.shape.length,l=r.shape[a],h=new Array(o-1);let d=0;for(let x=0;x<o;x++)x!==a&&(h[d++]=i.shape[x]);const f=[],m=new Array(o).fill(0),y=i.shape.slice();y[a]=1;const b=new Array(l);for(let x=0;x<b.length;x++){m[a]=x;const w=yd({inputs:{x:i},backend:t,attrs:{begin:m,size:y}}),v=Ee({inputs:{x:w},backend:t,attrs:{shape:h}});b[x]=v,f.push(w)}return f.forEach(x=>t.disposeIntermediateTensorInfo(x)),b}const ike={kernelName:vm,backendName:"webgl",kernelFunc:ake};class oke{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,a=e.inSize,i=e.numSegments,o=i*Math.ceil(a/s);this.outputShape=[r,o];const l="0.0",h="sumValue",d=Math.floor(s/4)*4,f=s%4,m=`
        sumValue += dot(values, segFilter);
    `;let y="";a%s>0&&(y=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let b="";a%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${b}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${d};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${h});
      }
    `}}function lke(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:a}=e,{numSegments:i}=s,o=r.shape.length,l=[];let h=0;const d=Zt([h],o);let f=r;d!=null&&(f=xs({inputs:{x:r},backend:t,attrs:{perm:d}}),l.push(f),h=cn(1,o)[0]);const m=MP(f.shape,h,i),y=he([f.shape[h]]),b=Ee({inputs:{x:f},backend:t,attrs:{shape:[-1,y]}});l.push(b);const x=Sx(r.dtype),w=(k,E,_,R,D)=>{const F=k.shape[0],L=k.shape[1],A=LP(L,D),V={windowSize:A,inSize:L,batchSize:F,numSegments:D},q=new oke(V,E),ne=t.compileAndRun(q,[k,_],R);if(l.push(ne),ne.shape[1]===D)return ne;const Q=aj({backend:t,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),B=ij({inputs:{x:Q},backend:t,attrs:{reps:[L/A]}});return l.push(Q),l.push(B),w(ne,E,B,R,D)},v=w(b,"unsortedSegmentSum",a,x,i),C=Ee({inputs:{x:v},backend:t,attrs:{shape:m}});let N=C;if(d!=null){l.push(C);const k=jo(d);N=xs({inputs:{x:N},backend:t,attrs:{perm:k}})}return l.forEach(k=>t.disposeIntermediateTensorInfo(k)),N}const uke={kernelName:Sm,backendName:"webgl",kernelFunc:lke};const cke=[qxe,Xxe,Zxe,twe,swe,iwe,lwe,cwe,pwe,gwe,xwe,Swe,Nwe,Iwe,Rwe,Owe,Lwe,Bwe,Uwe,Wwe,Kwe,tve,sve,ove,uve,mve,yve,vve,_xe,Cve,Ive,Dve,Pve,Uve,Wve,Hve,Kve,Zve,t1e,r1e,i1e,l1e,c1e,f1e,m1e,x1e,v1e,C1e,E1e,I1e,D1e,M1e,V1e,W1e,q1e,K1e,Y1e,Z1e,eSe,nSe,rSe,lSe,hSe,pSe,gSe,xSe,SSe,kSe,_Se,Ixe,RSe,Eve,FSe,zSe,VSe,Rxe,GSe,XSe,JSe,tTe,rTe,lTe,hTe,mTe,xTe,STe,CTe,$Te,_Te,RTe,LTe,zTe,BTe,UTe,WTe,KTe,ZTe,nCe,cCe,Fxe,pCe,yCe,wCe,TCe,hve,kCe,$Ce,_Ce,DCe,MCe,Oxe,PCe,VCe,jCe,GCe,HCe,dve,iCe,XCe,QCe,s2e,Mxe,o2e,c2e,p2e,y2e,v2e,T2e,k2e,I2e,R2e,F2e,z2e,V2e,G2e,K2e,Z2e,tNe,Qwe,lCe,rNe,iNe,lNe,cNe,dNe,pNe,gNe,bNe,wNe,TNe,NNe,ENe,INe,RNe,ONe,LNe,zNe,oCe,Wxe,VNe,WNe,HNe,XNe,QNe,nke,Gxe,rke,ike,uke,ECe];for(const n of cke)vx(n);const hke="4.22.0";const dke={"tfjs-core":fP,"tfjs-backend-cpu":gV,"tfjs-backend-webgl":_U,"tfjs-data":w4,"tfjs-layers":Cw,"tfjs-converter":r4,tfjs:hke},p0=Object.freeze(Object.defineProperty({__proto__:null,Abs:vp,Acos:eh,Acosh:th,AdadeltaOptimizer:_N,AdagradOptimizer:AN,AdamOptimizer:RN,AdamaxOptimizer:DN,Add:fu,AddN:Sp,All:gb,Any:yb,ArgMax:Tp,ArgMin:Cp,Asin:nh,Asinh:sh,Atan:rh,Atan2:ih,Atanh:ah,AvgPool:Np,AvgPool3D:kp,AvgPool3DGrad:xb,AvgPoolGrad:bb,BatchMatMul:Ep,BatchToSpaceND:$p,Bincount:wb,BitwiseAnd:Ip,BroadcastArgs:vb,BroadcastTo:dM,Callback:QB,CallbackList:nB,Cast:oh,Ceil:lh,ClipByValue:uh,Complex:Sb,ComplexAbs:_p,Concat:Ap,Conv2D:Rp,Conv2DBackpropFilter:Tb,Conv2DBackpropInput:Dp,Conv3D:Op,Conv3DBackpropFilterV2:Cb,Conv3DBackpropInputV2:Nb,Cos:ch,Cosh:hh,CropAndResize:Eb,Cumprod:kb,Cumsum:Fp,CustomCallback:rB,DataStorage:u2,DenseBincount:$b,DepthToSpace:Ib,DepthwiseConv2dNative:Lp,DepthwiseConv2dNativeBackpropFilter:_b,DepthwiseConv2dNativeBackpropInput:Ab,Diag:Rb,Dilation2D:Mp,Dilation2DBackpropFilter:_0,Dilation2DBackpropInput:I0,Draw:Db,get ENV(){return p2},EarlyStopping:e4,Einsum:Ob,Elu:fh,EluGrad:Fb,Environment:cM,Equal:zp,Erf:ph,Exp:mh,ExpandDims:Pp,Expm1:gh,FFT:Lb,Fill:Mb,FlipLeftRight:zb,Floor:yh,FloorDiv:bh,FromPixels:A0,FusedBatchNorm:Bp,FusedConv2D:Zf,FusedDepthwiseConv2D:Qf,GPGPUContext:d0,GatherNd:Pb,GatherV2:Vp,GraphModel:BE,Greater:Up,GreaterEqual:xh,History:sB,IFFT:Bb,Identity:wh,Imag:Vb,InputSpec:yn,IsFinite:vh,IsInf:Sh,IsNan:Th,KernelBackend:fb,LRN:Xp,LRNGrad:jb,LayerVariable:ZP,LayersModel:Si,LeakyRelu:jp,Less:Wp,LessEqual:Gp,LinSpace:Ub,Log:Ch,Log1p:Nh,LogSoftmax:fM,LogicalAnd:Hp,LogicalNot:qp,LogicalOr:Kp,LogicalXor:ZX,LowerBound:QX,MathBackendCPU:ng,MathBackendWebGL:ig,MatrixBandPart:e7,Max:Yp,MaxPool:Jp,MaxPool3D:Zp,MaxPool3DGrad:Gb,MaxPoolGrad:Wb,MaxPoolWithArgmax:Hb,Maximum:kh,Mean:Qp,Min:em,Minimum:Eh,MirrorPad:tm,Mod:$h,MomentumOptimizer:ON,Multinomial:qb,Multiply:Ih,Neg:nm,NonMaxSuppressionV3:Kb,NonMaxSuppressionV4:Xb,NonMaxSuppressionV5:Yb,NotEqual:sm,OP_SCOPE_SUFFIX:x2,OneHot:am,OnesLike:rm,Optimizer:Bi,OptimizerConstructors:pP,Pack:im,PadV2:om,Pool:t7,Pow:_h,Prelu:lm,Prod:um,RMSPropOptimizer:FN,RNN:Na,RaggedGather:Jb,RaggedRange:Zb,RaggedTensorToTensor:Qb,Range:ex,get Rank(){return $T},Real:tx,RealDiv:dh,Reciprocal:Ah,get Reduction(){return ms},Relu:Rh,Relu6:Dh,Reshape:cm,ResizeBilinear:dm,ResizeBilinearGrad:sx,ResizeNearestNeighbor:hm,ResizeNearestNeighborGrad:nx,Reverse:fm,RotateWithOffset:wx,Round:Oh,Rsqrt:Fh,SGDOptimizer:iw,ScatterNd:rx,SearchSorted:ix,Select:pm,Selu:Lh,Sequential:su,Sigmoid:Bh,Sign:Ph,Sin:Mh,Sinh:zh,Slice:mm,Softmax:xm,Softplus:Vh,SpaceToBatchND:ym,SparseFillEmptyRows:ox,SparseReshape:lx,SparseSegmentMean:ux,SparseSegmentSum:cx,SparseToDense:hx,SplitV:bm,Sqrt:Uh,Square:dx,SquaredDifference:jh,StaticRegexReplace:wm,Step:Kh,StridedSlice:fx,StringNGrams:px,StringSplit:mx,StringToHashBucketFast:gx,Sub:Wh,Sum:gm,SymbolicTensor:xa,Tan:Gh,Tanh:Hh,Tensor:bt,TensorBuffer:bn,TensorScatterUpdate:ax,Tile:qh,TopK:yx,Transform:bx,Transpose:Ul,Unique:xx,Unpack:vm,UnsortedSegmentSum:Sm,UpperBound:n7,Variable:np,ZerosLike:Tm,_FusedMatMul:Jf,abs:mn,acos:E2,acosh:$2,add:we,addN:jM,all:Nx,any:rp,argMax:Yl,argMin:I2,asin:_2,asinh:A2,atan:R2,atan2:D2,atanh:O2,avgPool:Em,avgPool3d:L2,backend:v2,backend_util:PP,basicLSTMCell:WM,batchNorm:Xh,batchNorm2d:M2,batchNorm3d:z2,batchNorm4d:P2,batchToSpaceND:$m,bincount:B2,bitwiseAnd:GM,booleanMaskAsync:Iz,broadcastArgs:HM,broadcastTo:jl,broadcast_util:DJ,browser:Yne,buffer:tt,callbacks:fue,cast:Ne,ceil:V2,clipByValue:Rs,clone:Ba,complex:$i,concat:ln,concat1d:U2,concat2d:j2,concat3d:W2,concat4d:G2,constraints:Zae,conv1d:kx,conv2d:Ii,conv2dTranspose:Ex,conv3d:q2,conv3dTranspose:K2,copyRegisteredKernels:i7,cos:Im,cosh:$x,cosineWindow:Zx,cumprod:op,cumsum:Ix,customGrad:qa,data:khe,denseBincount:O0,deprecationWarn:M7,depthToSpace:X2,depthwiseConv2d:Yh,deregisterOp:gue,device_util:A7,diag:KM,dilation2d:Y2,disableDeprecationWarnings:L7,dispose:Je,disposeVariables:z7,div:Fe,divNoNan:J2,dot:Z2,dropout:NN,einsum:Il,elu:Jh,enableDebugMode:F7,enableProdMode:O7,enclosingPowerOfTwo:kN,engine:ua,ensureShape:XM,env:ie,equal:Ys,erf:_x,euclideanNorm:eN,exp:Ds,expandDims:Hn,expm1:tN,eye:Ax,fft:Um,fill:pu,findBackend:W7,findBackendFactory:G7,floor:Qh,floorDiv:Cx,forceHalfFloat:AU,fused:zz,gather:ed,gatherND:Dz,gather_util:Jne,getBackend:IM,getGradient:kT,getKernel:tp,getKernelsForBackend:R0,gpgpu_util:ube,grad:gZ,grads:yZ,greater:vs,greaterEqual:Mi,ifft:Wc,imag:_m,image:Wr,inTopKAsync:Oz,initializers:pie,input:bB,io:zN,irfft:Gx,isFinite:nN,isInf:sN,isNaN:rN,keep:En,kernel_impls:ise,layers:jle,leakyRelu:Am,less:Bc,lessEqual:Wo,linalg:IN,linspace:ZM,loadGraphModel:Vce,loadGraphModelSync:Uce,loadLayersModel:roe,localResponseNormalization:aN,log:Js,log1p:Rm,logSigmoid:iN,logSoftmax:Dx,logSumExp:Dm,logicalAnd:qr,logicalNot:Om,logicalOr:Ox,logicalXor:oN,losses:Gz,lowerBound:ez,matMul:rt,math:Vne,max:Sr,maxPool:Fm,maxPool3d:lN,maxPoolWithArgmax:tz,maximum:Xa,mean:Kt,memory:OT,meshgrid:nz,metrics:iue,min:Pc,minimum:Do,mirrorPad:uN,mod:cN,model:ooe,models:oue,moments:Lm,movingAverage:_z,mul:Y,multiRNNCell:sz,multinomial:rz,neg:Mt,nextFrame:WN,norm:Zh,notEqual:Ql,oneHot:Vc,ones:$s,onesLike:Zs,op:G,outerProduct:az,pad:zi,pad1d:iz,pad2d:oz,pad3d:lz,pad4d:uz,pool:hN,pow:Ha,prelu:zm,print:k2,prod:dN,profile:P7,raggedGather:cz,raggedRange:hz,raggedTensorToTensor:dz,rand:fz,randomGamma:gz,randomNormal:Lx,randomStandardNormal:yz,randomUniform:Go,randomUniformInt:bz,range:eu,ready:U7,real:Uc,reciprocal:gN,registerBackend:w2,registerCallbackConstructor:uoe,registerGradient:pM,registerKernel:vx,registerOp:mue,regularizers:hue,relu:Ta,relu6:Mx,removeBackend:j7,reshape:J,reverse:Tr,reverse1d:xz,reverse2d:wz,reverse3d:vz,reverse4d:Sz,rfft:jm,round:zx,rsqrt:Px,scalar:ze,scatterND:Az,scatter_util:vee,searchSorted:Fx,selu:Bx,separableConv2d:Vx,sequential:loe,serialization:Sne,setBackend:V7,setPlatform:H7,setWebGLContext:DV,setdiff1dAsync:Tz,shared:mV,sigmoid:pa,sign:yN,signal:Wz,sin:Ux,sinh:jx,slice:dt,slice1d:Pm,slice2d:Wx,slice3d:Bm,slice4d:jc,slice_util:dP,softmax:Vm,softplus:mu,spaceToBatchND:Mm,sparse:Hz,sparseToDense:Rz,spectral:jz,split:Is,sqrt:Pn,square:$t,squaredDifference:Hx,squeeze:Ho,stack:bs,step:gu,stridedSlice:bN,string:qz,sub:Ae,sum:Re,sumOutType:Sx,tan:xN,tanh:Ro,tensor:Xs,tensor1d:Xn,tensor2d:To,tensor3d:qx,tensor4d:Cz,tensor5d:Nz,tensor6d:kz,tensorScatterUpdate:Ez,tensor_util:k7,test_util:OQ,tidy:re,tile:br,time:B7,topk:vN,train:Nl,transpose:ut,truncatedNormal:Xx,unique:SN,unregisterGradient:a7,unregisterKernel:r7,unsortedSegmentSum:Yx,unstack:Cr,upcastType:_s,upperBound:$z,util:p7,valueAndGrad:bZ,valueAndGrads:xZ,variable:TN,variableGrads:QM,version:dke,version_converter:r4,version_core:fP,version_cpu:gV,version_layers:Cw,version_webgl:_U,webgl:$xe,webgl_util:m0e,where:Mn,whereAsync:CN,zeros:gn,zerosLike:ft},Symbol.toStringTag,{value:"Module"})),fke={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_SUPABASE_ANON_KEY:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",VITE_SUPABASE_URL:"https://brrjoheinakfhohesogc.supabase.co"};function oj(n,e){return n=n-494,nb()[n]}const lj=oj;(function(n,e){const t=oj,s=n();for(;;)try{if(-parseInt(t(511))/1*(-parseInt(t(505))/2)+-parseInt(t(510))/3*(-parseInt(t(503))/4)+parseInt(t(504))/5+-parseInt(t(494))/6+parseInt(t(497))/7*(parseInt(t(499))/8)+parseInt(t(498))/9+-parseInt(t(496))/10===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(nb,295389);const pke="https://brrjoheinakfhohesogc.supabase.co",uj=fke[lj(507)];function nb(){const n=["single","78cOvrJt","175271tJNzNO","3425226GtLhWR","update","3821400SfUTnc","146503NBsSxi","4367439EYUMJA","48ZcfUOt","subscription_tier, stripe_customer_id, stripe_subscription_id, billing_info","profiles","select","4912RYaabt","1275425vndlsI","4HmOnMP","error","VITE_SUPABASE_ANON_KEY","from"];return nb=function(){return n},nb()}!uj&&console[lj(506)]("Missing Supabase Environment Variables!");const cj=YL(pke,uj,{auth:{autoRefreshToken:!0,persistSession:!0,detectSessionInUrl:!0}});(function(n,e){const t=Yo,s=n();for(;;)try{if(-parseInt(t(404))/1*(parseInt(t(408))/2)+-parseInt(t(377))/3+-parseInt(t(420))/4*(parseInt(t(441))/5)+parseInt(t(390))/6*(parseInt(t(453))/7)+-parseInt(t(458))/8*(-parseInt(t(414))/9)+parseInt(t(429))/10+-parseInt(t(456))/11*(-parseInt(t(391))/12)===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(sb,394714);const mke=async()=>{const n=Yo;try{await p0[n(380)]("webgl"),await p0[n(423)]()}catch{console[n(393)](n(418)),await p0[n(380)]("cpu")}};mke();function Yo(n,e){return n=n-372,sb()[n]}const J3=3e5,gke=n=>new Promise((e,t)=>{const s=Yo,r=new Worker(new URL(s(411),import.meta.url),{type:"module"});let a=!1;const i=setTimeout(()=>{const o=s;!a&&(a=!0,r[o(415)](),t(new Error("Neural Training Timed Out ("+J3/1e3+"s Limit). Try again or use Fast Mode.")))},J3);if(r[s(455)]=o=>{const l=s,{type:h,data:d}=o.data;h===l(394)?!a&&(a=!0,clearTimeout(i),r[l(415)](),e(d)):h===l(431)&&!a&&(a=!0,clearTimeout(i),r[l(415)](),t(new Error(d)))},r[s(437)]=o=>{const l=s;!a&&(a=!0,clearTimeout(i),r[l(415)](),t(o))},n[s(440)]?.[s(421)]<Ur+20){clearTimeout(i),t(new Error("Insufficient price history for neural training. Got "+(n[s(440)]?.length||0)+s(410)+(Ur+20)+"."));return}r[s(451)]({type:s(399),data:n})}),Ur=45,vC=4,WS=(n,e,t)=>(n-e)/(t||1),yke=n=>{const e=Yo,{prices:t,rsi:s,macd:r,atr:a}=n,i=Math[e(426)](t[e(421)],s[e(421)],r.length,a?.[e(421)]||0),o=t.slice(-i),l=s[e(375)](-i),h=r[e(375)](-i),d=a[e(375)](-i);return[o,l,h,d][e(413)](f=>{const m=e,y=f[m(469)]((x,w)=>x+w,0)/f[m(421)],b=Math[m(461)](f.reduce((x,w)=>x+Math[m(388)](w-y,2),0)/f[m(421)])||1;return{mean:y,std:b}})};function sb(){const n=["upsert","2511290Nqzrlc","relu","ERROR","predict","user_id","sequential","tensor2d","fit","onerror","max","maybeSingle","historicalPrices","177335uIsYrp","select","tensor3d"," vs ","macd","meanSquaredError","Bearish","dense","rsi","random","postMessage","Neural Assessment Timed Out (","85239UUaFdR","save","onmessage","1260776yGUwoX","neural_models","978056ZzsWOF","histogram","layers","sqrt","error","user_id, name","). Discarding legacy model.","Bullish","std","mean","fromCharCode","reduce","Cloud Model Load Error:","sentiment","model_json","slice","ASSESS_ACCURACY","162033fOTePg","prices","glorotUniform","setBackend","tidy","push","data","string","predicted","buffer","regularizers","pow","s Limit).","222DveSXC","24yjFuDa","toFixed","warn","TRAIN_SUCCESS","technical","add","adam","trainOnBatch","TRAIN_AND_PREDICT","lstm","pattern","shape","actual","1pWUPuJ","byteLength","weightData","from","350166CTOnaZ","loadLayersModel"," bars, need ","./brain.worker.js","dropout","map","27FzcEXN","terminate","[Brain] Model shape mismatch detected (","dispose","WebGL failed, falling back to CPU. Performance will be reduced.","neural","76lqKPId","length","atr","ready","Cloud Artifact Save Error:","compile","min","train"];return sb=function(){return n},sb()}const bke=(n,e,t)=>{const s=Yo,r=e[s(378)][0],a=[];for(let h=0;h<Ur;h++)a[s(382)]([(e[s(378)][h]-r)/(r||1),WS(e[s(449)][h],t[1][s(467)],t[1][s(466)]),WS(e[s(445)][h],t[2][s(467)],t[2][s(466)]),WS(e[s(422)][h],t[3][s(467)],t[3][s(466)])]);const i=qx([a],[1,Ur,vC]),o=n[s(432)](i),l=o.dataSync()[0];return i[s(417)](),o.dispose(),l*r+r},xke=n=>{n&&n[Yo(417)]()},wke=async(n,e,t,s)=>{const r=Yo;if(n)try{if(e[r(406)]instanceof ArrayBuffer){const i=new Uint8Array(e.weightData);let o="";for(let l=0;l<i[r(405)];l++)o+=String[r(468)](i[l]);e[r(406)]=btoa(o)}const{error:a}=await cj[r(407)](r(457))[r(428)]([{user_id:n.id,name:t,model_json:e,accuracy:s,created_at:new Date().toISOString()}],{onConflict:r(463)});if(a)throw a;return!0}catch(a){return console[r(462)](r(424),a),!1}},vke=async(n,e)=>{const t=Yo;if(!n)return null;try{const{data:s,error:r}=await cj[t(407)](t(457))[t(442)]("model_json").eq(t(433),n.id).eq("name",e)[t(439)]();if(r||!s)return null;const a=s[t(374)];if(typeof a[t(406)]===t(384)){const l=atob(a[t(406)]),h=new Uint8Array(l[t(421)]);for(let d=0;d<l[t(421)];d++)h[d]=l.charCodeAt(d);a[t(406)]=h.buffer}else Array.isArray(a.weightData)&&(a[t(406)]=new Uint8Array(a.weightData)[t(386)]);const i=await p0[t(409)](eP(a)),o=i.inputs[0][t(402)];return o[1]!==Ur||o[2]!==vC?(console[t(393)](t(416)+o[1]+"x"+o[2]+t(444)+Ur+"x"+vC+t(464)),i[t(417)](),null):i}catch(s){return console[t(462)](t(372),s),null}},ke=hj;(function(n,e){const t=hj,s=n();for(;;)try{if(parseInt(t(186))/1+parseInt(t(182))/2+parseInt(t(244))/3*(parseInt(t(142))/4)+parseInt(t(213))/5+-parseInt(t(119))/6+parseInt(t(179))/7+-parseInt(t(211))/8===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(rb,316756);function rb(){const n=["DAILY","close","solana","https://api.coingecko.com/api/v3/simple/price?ids=","binancecoin","BTC","4PeIfwV","Intel Corp.","prices","ETH","?interval=1d&range=1y","Coca-Cola Co.","iotex","dogecoin","Home Depot Inc.","Costco Wholesale Corp.","chainlink","PepsiCo Inc.","flow","price","Walmart Inc.","monero","slice","split","Broadcom Inc.","indicators","replace","vechain","aave","celo","maker","tezos","entries","usd","havven","-USD","https://finnhub.io/api/v1/stock/candle?symbol=","algorand","Visa Inc.","harmony","shiba-inu","filter","the-sandbox","3131905KdLrWj","&to=","total_volumes","315018cehosN","cache_","Finnhub","ripple","187410eVLIoq","&token=","NVIDIA Corp.","result","error","https://api.allorigins.win/raw?url=","now","previousClose","match","Amazon.com Inc.","SOL","usd_24h_vol","tron","floor","O H L","https://query1.finance.yahoo.com/v8/finance/chart/","XRP","getItem","axie-infinity","OPEN","UnitedHealth Group","Honeywell","volume","SPDR S&P 500 ETF","Procter & Gamble Co.","12071488AulUJl","dash","2670065acDyKV","litecoin","aptos","stellar","clear","eos","theta-token","Mastercard Inc.","regularMarketPrice","Berkshire Hathaway","Texas Instruments","elrond-erd-2","bitcoin-cash","ADA","quote","IBM Corp.","https://corsproxy.io/?","fantom","immutable-x","pop","bitcoin","json","includes","Advanced Micro Devices","Qualcomm Inc.","CRYPTOCURRENCY","cardano","quant-network","near","HIGH","CoinGecko","1832121BoJQDI","zcash","chart","LOW","Microsoft Corp.","Chevron Corp.","zilliqa","avalanche-2","curve-dao-token","enjincoin","kusama","DOGE","Oracle Corp.","holo","VISUAL-SCAN","iShares Russell 2000","Cache read compile error","min","ethereum-classic","high","low","matic-network","reduce","&resolution=D&from=","CoinGecko Fetch Error:","https://api.coingecko.com/api/v3/coins/","warn","CLOSE","Invesco QQQ Trust","map","All proxies failed","convex-finance","668172slOlpY","&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true","MARKET","Alphabet Inc.","meta","change24h","CRYPTO","SPDR Dow Jones","https://finnhub.io/api/v1/quote?symbol=","basic-attention-token","Eli Lilly and Co.","TIME","usd_24h_change","Merck & Co.","BITCOIN","length","Fetch failed for "];return rb=function(){return n},rb()}const zf={BTC:ke(233),ETH:"ethereum",SOL:ke(138),XRP:ke(185),ADA:ke(239),DOGE:ke(149),AVAX:ke(251),DOT:"polkadot",MATIC:ke(108),LINK:ke(152),LTC:ke(214),SHIB:ke(176),TRX:ke(198),UNI:"uniswap",ATOM:"cosmos",XMR:ke(157),ETC:ke(262),XLM:ke(216),BCH:ke(225),FIL:"filecoin",APT:ke(215),QNT:ke(240),NEAR:ke(241),ARB:"arbitrum",VET:ke(163),MKR:ke(166),AAVE:ke(164),GRT:"the-graph",ALGO:ke(173),AXS:ke(204),SAND:ke(178),EOS:ke(218),MANA:"decentraland",THETA:ke(219),EGLD:ke(224),FTM:ke(230),XTZ:ke(167),FLOW:ke(154),IMX:ke(231),SNX:ke(170),NEO:"neo",CVX:ke(118),CRV:ke(252),BAT:ke(128),CHZ:"chiliz",ENJ:ke(253),DASH:ke(212),COMP:"compound-governance-token",ZEC:ke(245),XEM:"nem",HOT:ke(257),IOTX:ke(148),RUNE:"thorchain",KSM:ke(254),ZIL:ke(250),RVN:"ravencoin",CELO:ke(165),ONE:ke(175),QTUM:"qtum",BNB:ke(140)},Ske=120*1e3,Tke=n=>{const e=ke;try{const t=localStorage.getItem(e(183)+n);if(t){const{data:s,timestamp:r}=JSON.parse(t);if(Date[e(192)]()-r<Ske)return s}}catch(t){console[e(113)](e(260),t)}return null},Cke=(n,e)=>{const t=ke;try{localStorage.setItem(t(183)+n,JSON.stringify({data:e,timestamp:Date.now()}))}catch{try{localStorage[t(217)]()}catch{}}};function hj(n,e){return n=n-108,rb()[n]}const SC={AAPL:"Apple Inc.",MSFT:ke(248),GOOGL:ke(122),AMZN:ke(195),NVDA:ke(188),TSLA:"Tesla Inc.",META:"Meta Platforms Inc.","BRK.B":ke(222),V:ke(174),JNJ:"Johnson & Johnson",WMT:ke(156),JPM:"JPMorgan Chase & Co.",PG:ke(210),MA:ke(220),LLY:ke(129),HD:ke(150),CVX:ke(249),MRK:ke(132),KO:ke(147),PEP:ke(153),AVGO:ke(160),COST:ke(151),ORCL:ke(256),AMD:ke(236),NFLX:"Netflix Inc.",INTC:ke(143),IBM:ke(228),QCOM:ke(237),TXN:ke(223),HON:ke(207),UNH:ke(206),SPY:ke(209),QQQ:ke(115),IWM:ke(259),DIA:ke(126)},dj=n=>{const e=ke;if(!n)return null;const t=n[e(194)](/\b\d{1,3}(?:[.,]\d{3})*[.,]\d{1,8}\b/g),s=n[e(194)](/\b\d{1,3}(?:,\d{3})+\b/g),r=n[e(194)](/\b\d{4,7}\b/g),a=[...t||[],...s||[],...r||[]],i=a.map(l=>{const h=e,d=l[h(162)](/,/g,""),f=d.split(".");if(f[h(134)]>2){const m=f[h(232)]();return parseFloat(f.join("")+"."+m)}return parseFloat(d)}).filter(l=>l>=2e3&&l<=3e3||l===24||l===1||l===7||l===30||l===15||l===60?!1:l>1e-4&&l<2e7);return i[e(134)]===0?null:i.sort((l,h)=>{const d=l>.1&&l<15e4,f=h>.1&&h<15e4;if(d&&!f)return-1;if(!d&&f)return 1;const m=l%1!==0,y=h%1!==0;return m&&!y?-1:!m&&y?1:l-h})[0]},Nke=n=>{const e=ke;if(!n)return null;const t=n.toUpperCase(),s=["VOL","USD","USDT","UTC",e(125),e(238),"PRICE",e(121),"CHANGE",e(130),"TOTAL",e(247),e(242),e(205),e(114),e(136),"WEEKLY"],r=t[e(159)](/[^A-Z0-9]/)[e(177)](l=>l[e(134)]>=2);for(const l of Object.keys(zf))if(r[e(235)](l))return l;const a=t.match(/\b([A-Z0-9]{2,10})[\/\-\\]?(?:USDT|USD|BUSD|USDC|PERP|FRAX|DAI)\b/);if(a){const l=a[1];if(zf[l]||SC[l]||l[e(134)]>=2&&!s[e(235)](l))return l}if((t[e(235)](e(125))||t[e(235)](e(200)))&&!t.includes(e(133))){const l=dj(n);if(l>4e4&&l<15e4)return"BTC";if(l>1500&&l<1e4)return e(145)}const i={BITCOIN:e(141),ETHEREUM:e(145),SOLANA:e(196),RIPPLE:e(202),CARDANO:e(226),DOGECOIN:e(255),AVALANCHE:"AVAX"};for(const[l,h]of Object[e(168)](i))if(t.includes(l))return h;const o=t.match(/\(([A-Z0-9]{2,6})\)[ -]|^([A-Z0-9]{2,6})\s+\d/);if(o){const l=o[1]||o[2];if(zf[l]||SC[l]||l[e(134)]>=2&&!s.includes(l))return l}return null},kke=async n=>{const e=ke,t=zf[n];if(!t)return null;try{const s=await fetch(e(139)+t+e(120)),r=await s[e(234)](),a=r[t];return{price:a[e(169)],change24h:a[e(131)],volume:a[e(197)],source:e(243)}}catch(s){return console[e(190)](e(111),s),null}},Eke=async(n,e=90)=>{const t=ke,s=zf[n];if(!s)return null;const r=Tke(s+"_"+e);if(r)return r;try{const a=await fetch(t(112)+s+"/market_chart?vs_currency=usd&days="+e),i=await a[t(234)](),o=i[t(144)][t(116)](d=>d[1]),l=i[t(181)][t(116)](d=>d[1]),h={closes:o,highs:o[t(116)](d=>d*1.002),lows:o[t(116)](d=>d*.998),volumes:l};return Cke(s+"_"+e,h),h}catch(a){return console[t(190)]("CoinGecko History Error:",a),null}},$ke=async n=>{const e=ke,t=n.includes("-")?n[e(162)]("-",""):n;try{const s=e(201)+t+"?interval=1d&range=3mo",r=["https://corsproxy.io/?"+encodeURIComponent(s),e(191)+encodeURIComponent(s)];let a=null;for(const b of r)try{const x=await fetch(b);if(!x.ok)continue;if(a=await x.json(),a?.[e(246)]?.[e(189)])break}catch{continue}if(!a)throw new Error(e(117));const i=a[e(246)][e(189)][0],o=i.indicators[e(227)][0][e(137)][e(177)](b=>b!==null),l=i.indicators[e(227)][0][e(263)].filter(b=>b!==null),h=i[e(161)].quote[0][e(264)][e(177)](b=>b!==null),d=i.indicators[e(227)][0][e(208)][e(177)](b=>b!==null),f=i[e(123)][e(221)],m=i[e(123)].previousClose,y=(f-m)/m*100;return{marketStats:{price:f,change24h:y,volume:d[d[e(134)]-1],source:"Yahoo Finance"},historicalData:{closes:o,highs:l,lows:h,volumes:d}}}catch(s){return console[e(113)]("Yahoo data fetch failed for",n,s),null}},Z3=async n=>{const e=ke;if(!n||n===e(258))return null;const t=n[e(235)]("-")?n.replace("-",""):n;try{const s=e(201)+t+e(146),r=[e(229)+encodeURIComponent(s),e(191)+encodeURIComponent(s)];let a=null;for(const o of r)try{const l=await fetch(o);if(!l.ok)continue;if(a=await l.json(),a?.[e(246)]?.result)break}catch{continue}return a?.[e(246)]?.result?.[0]?.indicators?.quote?.[0]?.[e(137)]?.[e(177)](o=>o!==null)||null}catch{return null}},Ike=n=>{const e=ke;if(!n||n.length<10)return .5;const t=n[n[e(134)]-1],s=n[e(158)](-50).reduce((o,l)=>o+l,0)/Math[e(261)](n.length,50),r=n[e(158)](-200)[e(109)]((o,l)=>o+l,0)/Math[e(261)](n[e(134)],200);let a=.5;t>s&&(a+=.1),t>r&&(a+=.15),s>r&&(a+=.1),t>n[0]&&(a+=.1);const i=(t-n[n.length-20])/n[n.length-20];return a+=i*.5,Math.max(.1,Math[e(261)](.9,a))};(function(n,e){const t=m$,s=n();for(;;)try{if(-parseInt(t(301))/1*(parseInt(t(345))/2)+-parseInt(t(300))/3+parseInt(t(284))/4*(-parseInt(t(281))/5)+-parseInt(t(337))/6*(-parseInt(t(307))/7)+parseInt(t(282))/8*(parseInt(t(311))/9)+parseInt(t(324))/10+parseInt(t(305))/11===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(ab,921470);function ab(){const n=["Deep LSTM detects aggressive institutional accumulation. ","modelArtifacts","Moderate Bullish","5200150LitmVy","[ScaleGuardian] Correcting OCR price scale: ","warn","sqrt","Running V4 Predictive Inference...","** pattern suggests a dominant ","Internal V4 Engine","Bullish","Aligning Multi-Timeframe Bias (Daily)...","V5 Institutional analysis of **","Neutral","stats","Macro Sentiment","6EEpEKY","The detection of a **","volumes","pow","log","sentiment","min","opens","26052EvMHWY","round","Calibrating Cloud Intelligence V4...","lstm_v4_","Gathering Macro V4 Context...","toISOString","omega","Technical Alpha","High implied volatility suggests widened discovery ranges. ","Insufficient historical data for precision analysis","predictedPrice","slice","Moderate Bearish"," with strength ","rsi","includes","10Y-Alpha","Confluence","toFixed","lows","name","V4-RMSE-PRECISION (Iter: ","58755fYjnmz","166920rbbosG","price","316luwUep","** structure with **","alpha","** identified a **","gamma","Strong Bullish"," detected at $","prices","max","Bearish"," sentiment in the current fractal. ","Heuristic","Training Deep LSTM V4 (Parallel Core)...","histogram","MTF Alignment","Strong Bearish","3573744zhHTXq","86jZMQDS"," -> ","Neural inference highlights terminal distribution phases. ","MTF Alignment failed, using neutral bias:","29160274idHHuh","abs","1236193LWfwJr","source","support","strength","351grRbrg","now","V5 Bias","iterations","log10","length"," (Factor: ","toLowerCase","resistance","Major "];return ab=function(){return n},ab()}function m$(n,e){return n=n-264,ab()[n]}const _ke=(n,e,t,s,r=.95,a=.5,i=.02,o=.5)=>{const l=m$,h=.5,d=.15+(i>.04?.05:0),f=s[l(265)]+s[l(286)]+s[l(288)]+d,m=Q=>(Q-.5)*2,y=m(n),b=s[l(265)]/f,x=r;let w=.5;e===l(331)?w=.85:e==="Bearish"&&(w=.15);const v=m(w),C=s.alpha/f,N=t[l(273)][t[l(273)][l(316)]-1];let k=.5;N<30?k=.85:N<40?k=.7:N>70?k=.15:N>60&&(k=.3);const E=m(k),_=s[l(288)]/f,R=N<25||N>75?1.3:1,D=m(a),F=d/f,L=m(o),A=.15,V=[{w:b,p:y,c:x,f:1},{w:C,p:v,c:.9,f:1},{w:_,p:E,c:1,f:R},{w:F,p:D,c:1,f:1},{w:A,p:L,c:1,f:1}],q=V.reduce((Q,B)=>{const U=l,X=B.w*B.p*B.c*B.f;return Q*(1-Math[U(292)](-.99,Math[U(343)](.99,X)))},1-h),ne=1-q;return Math.min(.995,Math[l(292)](.005,ne))},Ake=async(n,e,t,s,r,a,i=.95,o=!1)=>{const l=m$,h=Array.isArray(t)?t:t.closes||[],d=t.highs||h,f=t[l(278)]||h;t[l(339)];let m=e[l(283)]||h[h.length-1];const y=h[h[l(316)]-1];if(e[l(283)]&&y){const Se=Math[l(315)](y/e[l(283)]);if(Math[l(306)](Se)>.6){const je=Math[l(340)](10,Math[l(346)](Se));console[l(341)](l(325)+e[l(283)]+l(302)+e[l(283)]*je+l(317)+je+")"),m=e[l(283)]*je}}if(h.length<20)throw new Error(l(268));const b=AX(h,14),x=DX(h),w=x[l(297)],v=t[l(344)]||[],C=OX(h,d,f,v),N=C[0].sentiment,k=FX(d,f,h,14),E=LX(h,d,f);t[l(339)]&&t[l(339)][l(316)]>0&&MX(d,f,h,t.volumes);let _=.5;try{a(l(332));const Se=await Z3(n);Se?.prices&&(_=zX(Se.prices))}catch(Se){console[l(326)](l(304),Se)}let R=.5,D=null;const F=k[k.length-1]||m*.02,L=F/m;if(h[l(316)]>=Ur)if(o){const Se=h[h[l(316)]-1],je=h[h[l(316)]-15],Ye=(Se-je)/je;R=.5+Math[l(343)](.45,Math[l(292)](-.45,Ye/(L*5))),a("Rapid Precision Heuristic Applied...")}else{let Se=null;try{const je={prices:h,rsi:b,macd:w,atr:k};if(s&&(Se=await vke(s,l(348)+n)),Se){if(a(l(347)),D=yke(je),Se&&h.length>=Ur&&D){a(l(328));const Ye={prices:h[l(270)](-Ur),rsi:b.slice(-Ur),macd:w.slice(-Ur),atr:k[l(270)](-Ur)},Ke=bke(Se,Ye,D),ot=1/(L*10||1);R=.5+(Ke-m)/m*ot,R=Math[l(292)](.02,Math[l(343)](.98,R))}}else{a(l(296));const Ye=await gke({ticker:n,historicalPrices:h,rsi:b,macdHist:w,atr:k});if(Ye){const Ke=1/(L*10||1);R=.5+(Ye[l(269)]-m)/m*Ke,R=Math.max(.02,Math[l(343)](.98,R)),D=Ye[l(335)],s&&Ye[l(322)]&&(a("Syncing V4 Brain to Cloud..."),await wke(s,Ye[l(322)],l(348)+n,.99))}}}finally{Se&&xke(Se)}}a(l(349));const A=await Z3(n),V=Ike(A?.[l(291)]);let q=_ke(R,N,{rsi:b,macd:w},r,i,V,L,_);const ne=b[b[l(316)]-1]<45&&N===l(331),Q=b[b.length-1]>55&&N==="Bearish";if(R>.75&&ne){const Se=.05+.1*(R-.75);q=Math[l(343)](.99,q+Se)}else if(R<.25&&Q){const Se=.05+.1*(.25-R);q=Math[l(292)](.01,q-Se)}const B=[{name:"Neural Net (V5 LSTM)",type:"Deep Intelligence",w:r.omega,p:R,value:o?l(295):"RMSE-Optimized"},{name:"Primary Pattern: "+C[0][l(279)],type:"Geometric",w:r[l(286)],p:N==="Bullish"?.8:N===l(293)?.2:.5,value:C[0].name},{name:l(266),type:l(276),w:r[l(288)],p:b[b.length-1]<45?.8:b[b[l(316)]-1]>55?.2:.5,value:"RSI-ATR Sync"},{name:l(336),type:"Ensemble",w:.15,p:V,value:l(275)},{name:l(298),type:l(313),w:.15,p:_,value:_>.6?l(331):_<.4?l(293):l(334)},{name:"Visual Alignment",type:"Sync",w:.1,p:i,value:(i*100).toFixed(0)+"%"}];let U=l(334);q>.68?U=l(289):q>.55?U=l(323):q<.32?U=l(299):q<.45&&(U=l(271));const X=U[l(274)](l(331)),K=m<1?5:m<100?3:2,se=X?E[l(310)].s:E[l(310)].r,P=1.8-se*.1,j=Math[l(292)](m*.005,F*P),te=2+r[l(314)]*.02;let oe,pe,xe;X?(oe=Math[l(343)](m*.99,m-j),E[l(309)]<m&&E[l(309)]>oe&&(oe=E[l(309)]*.998),pe=m+j*te,xe=m+j*te*1.6):(oe=Math[l(292)](m*1.01,m+j),E[l(319)]>m&&E[l(319)]<oe&&(oe=E.resistance*1.002),pe=Math.max(0,m-j*te),xe=Math[l(292)](0,m-j*te*1.6));const Te={entry:m[l(277)](K),sl:oe[l(277)](K),tp1:pe[l(277)](K),tp2:xe[l(277)](K),rr:te[l(277)](1)},_e=((q>.5?q:1-q)*100)[l(277)](1),$e=()=>{const Se=l;b[b[Se(316)]-1];let je=Se(333)+n+Se(287)+U+Se(285)+_e+"%** mathematical confidence. ";if(C[Se(316)]>0){const Ye=C[0];je+=Se(338)+Ye[Se(279)]+Se(329)+Ye[Se(342)][Se(318)]()+Se(294)}return R>.7?je+=Se(321):R<.3&&(je+=Se(303)),(E[Se(310)].s>3||E[Se(310)].r>3)&&(je+=Se(320)+(E[Se(310)].s>E[Se(310)].r?Se(309):Se(319))+Se(290)+(E.strength.s>E[Se(310)].r?E.support[Se(277)](K):E.resistance[Se(277)](K))+Se(272)+Math[Se(292)](E.strength.s,E[Se(310)].r)+"/5. "),L>.05&&(je+=Se(267)),je},Ue={volatility:(L*100)[l(277)](2),sharpeRatio:(((m-h[0])/h[0]*100*(252/h[l(316)])-4.5)/(L*Math[l(327)](252)*100||1))[l(277)](2),maxDrawdown:((Math[l(343)](...h[l(270)](-90))-Math.max(...h.slice(-90)))/Math[l(292)](...h[l(270)](-90))*100)[l(277)](2),calibration:{rmse:(Math[l(327)](Math[l(340)](1-q,2))*.08)[l(277)](4),brier:Math[l(340)](q-(X?1:0),2).toFixed(4)}};return{id:Date[l(312)]().toString(),date:new Date()[l(264)](),p0:r[l(286)].toFixed(2),finalProb:Number(q),direction:U,confidence:_e,patterns:C,factors:B,targets:Te,riskMetrics:Ue,macroTrend:{...A,source:A?.[l(308)]||l(330)},overview:$e(),ticker:n||"UNKNOWN",version:l(280)+r[l(314)]+")",raw_prices:h}},bc="https://diverai.flisoft.agency",Rke=()=>{const{user:n,profile:e,refreshProfile:t,neuralState:s}=_X(),[r,a]=Ce.useState("idle"),[i,o]=Ce.useState(null),[l,h]=Ce.useState(null),[d,f]=Ce.useState(""),[m,y]=Ce.useState(""),[b,x]=Ce.useState(!1),[w,v]=Ce.useState(""),[C,N]=Ce.useState("guest"),[k,E]=Ce.useState(null),[_,R]=Ce.useState([]),[D,F]=Ce.useState("analyze"),[L,A]=Ce.useState(!1);Ce.useEffect(()=>{V();const K=async se=>{if(se.type==="AUTH_SYNC"&&se.session){const{access_token:P,refresh_token:j}=se.session;await Vr.auth.setSession({access_token:P,refresh_token:j}),t()}};return chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.addListener(K),()=>{chrome.runtime.onMessageExternal&&chrome.runtime.onMessageExternal.removeListener(K)}},[]);const V=async()=>{try{const K=await fetch("https://api.ipify.org?format=json");if(!K.ok)throw new Error("Network response was not ok");const se=await K.json();E(se.ip)}catch{console.info("IP tracking disabled/blocked. Using session fallback."),E("unknown-client")}};Ce.useEffect(()=>{q()},[n]);const q=async()=>{if(!n){const P=localStorage.getItem("diver_ai_guest_history");R(P?JSON.parse(P):[]);return}const{data:K,error:se}=await Vr.from("prediction_history").select("*").eq("user_id",n.id).order("created_at",{ascending:!1}).limit(10);!se&&K&&R(K.map(P=>({...P.data,db_id:P.id,created_at:P.created_at})))},ne=async K=>{if(n){const{data:se}=await Vr.from("prediction_history").insert([{user_id:n.id,data:K}]).select();if(se?.[0]){const P={...K,db_id:se[0].id,created_at:se[0].created_at};R(j=>[P,...j].slice(0,10))}}else{const se=new Date().toISOString(),P={...K,db_id:"local-"+Date.now(),created_at:se};R(j=>{const te=[P,...j].slice(0,5);return localStorage.setItem("diver_ai_guest_history",JSON.stringify(te)),te})}},Q=()=>{if(n)return;const K=new Date().toISOString().split("T")[0],se=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}"),P=k||"unknown",j=se[P]||{count:0,date:K};j.date!==K?(j.count=1,j.date=K):j.count+=1,se[P]=j,localStorage.setItem("diver_ai_guest_ip_logs",JSON.stringify(se))},B=()=>{const K=new Date().toISOString().split("T")[0];if(!n){const P=JSON.parse(localStorage.getItem("diver_ai_guest_ip_logs")||"{}")[k||"unknown"]||{count:0,date:K};return P.date!==K&&(P.count=0,P.date=K),P.count>=3?(v("IP Limit Reached: 3 guest analysis/day. Please log in for expanded access."),N("guest"),x(!0),!1):!0}return n.email_confirmed_at?e&&e.subscription_tier!=="pro"&&(e.upload_count||0)>=3&&e.last_upload_date===K?(v("Neural Capacity Reached: 3/day. Upgrade to Pro for unlimited terminal access."),N("free"),x(!0),!1):!0:(v("Security Protocol: Email verification required. Check your inbox to unlock terminal scanning."),N("verify"),x(!0),!1)},U=async()=>{if(B()){a("scanning"),f("Capturing Visual Stream..."),o(null);try{const K=await new Promise(Ke=>{chrome.runtime.sendMessage({action:"CAPTURE_SCREENSHOT"},ot=>{chrome.runtime.lastError?Ke({error:"Connection to extension background lost. Please refresh the page."}):Ke(ot)})});if(K.error)throw new Error(K.error);const se=K.dataUrl;h(se),a("analyzing"),f("Deep Scan (Cloud OCR)...");const{data:{session:P}}=await Vr.auth.getSession();let j=P?.access_token||"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",te=0,oe,pe=!1;for(;!pe&&te<3;)try{if(oe=await fetch("https://brrjoheinakfhohesogc.supabase.co/functions/v1/detect_ticker",{method:"POST",headers:{"Content-Type":"application/json",apikey:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A",Authorization:`Bearer ${te===2?"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJycmpvaGVpbmFrZmhvaGVzb2djIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5OTgwMjcsImV4cCI6MjA4MjU3NDAyN30.8rgluaQ0SmV2XffVsaOL--1ejcqGssDm7jD6OWVql0A":j}`},body:JSON.stringify({image:se})}),oe.ok)pe=!0;else if(oe.status===401&&te===0){const{data:{session:ot},error:gt}=await Vr.auth.refreshSession();if(gt||!ot)throw new Error("Refresh Failed");j=ot.access_token,te++}else if(oe.status===401&&te===1)te++;else throw new Error(`Service Error (${oe.status})`)}catch(Ke){if(te===2)throw Ke;te++}if(!oe||!oe.ok)throw new Error("Visualization Service Unavailable");const Te=(await oe.json())?.text||"",_e=Nke(Te),$e=dj(Te);if(console.log("[Sidebar] OCR Detected:",{ticker:_e,anchorPrice:$e}),!_e&&!$e)throw new Error("Neural Core Rejected: No valid asset or price identified.");f(`Target Locked: ${_e}. Syncing Data...`);let Ue,Se;if(SC[_e]){const Ke=await $ke(_e);if(Ke)Ue=Ke.marketStats,Se=Ke.historicalPrices;else throw new Error("Institutional data access error for stocks.")}else Ue=await kke(_e),Se=await Eke(_e,90);f("Synchronizing Global Intelligence...");const Ye=await Ake(_e,Ue,Se,n,s,f,.95,!0);if(n&&e){const Ke=new Date().toISOString().split("T")[0],ot=e.last_upload_date!==Ke?1:(e.upload_count||0)+1;await Vr.from("profiles").update({upload_count:ot,last_upload_date:Ke}).eq("id",n.id),t()}else Q();await ne(Ye),o(Ye),a("success")}catch(K){console.error(K),y(K.message),a("error")}}},X=({id:K,label:se,icon:P})=>me.jsxs("button",{onClick:()=>F(K),className:`flex-1 flex items-center justify-center gap-2 py-2 text-[11px] font-bold uppercase tracking-wider transition-all relative ${D===K?"text-white":"text-slate-500 hover:text-slate-400"}`,children:[me.jsx(P,{className:"w-3.5 h-3.5"}),se,D===K&&me.jsx(yl.div,{layoutId:"activeTab",className:"absolute bottom-0 left-0 right-0 h-0.5 bg-blue-500"})]});return me.jsxs("div",{className:"h-screen flex flex-col bg-slate-950 font-sans text-white overflow-hidden selection:bg-blue-500/30",children:[b&&me.jsx("div",{className:"fixed inset-0 z-[100] bg-slate-950/90 backdrop-blur-md flex items-center justify-center p-6 text-center animate-in fade-in",children:me.jsxs("div",{className:"space-y-6 max-w-xs",children:[me.jsx("div",{className:"w-16 h-16 bg-rose-500/10 rounded-2xl flex items-center justify-center mx-auto border border-rose-500/20",children:me.jsx(M8,{className:"text-rose-500"})}),me.jsx("h3",{className:"text-xl font-black uppercase tracking-tight",children:"Access Restricted"}),me.jsx("p",{className:"text-slate-500 text-xs font-bold leading-relaxed",children:w}),me.jsxs("div",{className:"space-y-3",children:[C==="free"?me.jsx("button",{onClick:()=>window.open(`${bc}/pricing?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Upgrade to Pro"}):C==="guest"?me.jsx("button",{onClick:()=>window.open(`${bc}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"w-full py-3 bg-emerald-500 text-slate-950 font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Initialize Login"}):me.jsx("button",{onClick:()=>x(!1),className:"w-full py-3 bg-slate-800 text-white font-black rounded-xl uppercase tracking-widest text-[10px]",children:"Check Inbox"}),me.jsx("button",{onClick:()=>x(!1),className:"w-full py-2 text-slate-500 font-bold uppercase tracking-widest text-[9px]",children:"Close"})]})]})}),me.jsxs("div",{className:"shrink-0 bg-slate-950 border-b border-slate-800/50",children:[me.jsxs("div",{className:"px-4 py-3 flex items-center justify-between",children:[me.jsxs("div",{className:"flex items-center gap-2",children:[me.jsx("div",{className:"bg-blue-600 rounded-md p-1",children:me.jsx($8,{className:"w-3.5 h-3.5 text-white"})}),me.jsxs("span",{className:"font-bold text-sm tracking-tight",children:["Diver",me.jsx("span",{className:"text-blue-500",children:"AI"})]})]}),n?me.jsxs("div",{className:"flex items-center gap-3",children:[me.jsx("div",{className:"text-right",children:me.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase",children:e?.subscription_tier==="pro"?"PRO":"BASIC"})}),me.jsx("button",{onClick:()=>Vr.auth.signOut(),className:"text-slate-500 hover:text-white transition-colors",children:me.jsx(P8,{className:"w-4 h-4"})})]}):me.jsx("button",{onClick:()=>window.open(`${bc}/login?source=extension&extId=${chrome.runtime.id}`,"_blank"),className:"text-[10px] font-bold text-blue-400 hover:text-blue-300 uppercase tracking-wide",children:"Login"})]}),me.jsxs("div",{className:"flex px-2 border-t border-slate-900",children:[me.jsx(X,{id:"analyze",label:"Analysis",icon:PD}),me.jsx(X,{id:"history",label:"History",icon:LD}),n&&me.jsx(X,{id:"referral",label:"Rewards",icon:X8})]})]}),me.jsx("div",{className:"flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-800 scrollbar-track-transparent p-4",children:me.jsxs(GH,{mode:"wait",children:[D==="history"&&me.jsx(yl.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:-10},className:"space-y-3",children:_.length===0?me.jsxs("div",{className:"text-center py-12 text-slate-600",children:[me.jsx(LD,{className:"w-10 h-10 mx-auto mb-3 opacity-50"}),me.jsx("p",{className:"text-xs font-medium",children:"No past analyses found."})]}):_.map((K,se)=>me.jsxs("div",{onClick:()=>{o(K),a("success"),F("analyze")},className:"bg-slate-900/50 hover:bg-slate-900 border border-slate-800 rounded-xl p-3 cursor-pointer transition-all flex items-center justify-between group",children:[me.jsxs("div",{className:"flex items-center gap-3",children:[me.jsx("div",{className:`w-8 h-8 rounded-lg flex items-center justify-center ${K.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:K.direction.includes("Bullish")?me.jsx(zD,{className:"w-4 h-4"}):me.jsx(MD,{className:"w-4 h-4"})}),me.jsxs("div",{children:[me.jsx("h4",{className:"text-sm font-bold text-white group-hover:text-blue-400 transition-colors",children:K.ticker}),me.jsx("p",{className:"text-[10px] text-slate-500 uppercase tracking-wider",children:new Date(K.created_at).toLocaleDateString()})]})]}),me.jsxs("span",{className:`text-xs font-mono font-bold ${K.direction.includes("Bullish")?"text-emerald-500":"text-rose-500"}`,children:[(K.finalProb*100).toFixed(0),"%"]})]},K.db_id||se))},"history"),D==="referral"&&n&&me.jsxs(yl.div,{initial:{opacity:0,x:10},animate:{opacity:1,x:0},className:"space-y-4",children:[me.jsxs("div",{className:"bg-gradient-to-br from-blue-600 to-indigo-700 rounded-2xl p-5 border border-white/10 shadow-xl relative overflow-hidden",children:[me.jsx("div",{className:"absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 mix-blend-overlay"}),me.jsxs("div",{className:"relative z-10 space-y-3",children:[me.jsx("h3",{className:"text-sm font-black uppercase tracking-tight",children:"Earn Pro Status"}),me.jsx("p",{className:"text-[10px] text-blue-100 font-medium leading-relaxed",children:"Refer a friend. You both get 30 days of Pro analysis upon their signup."}),me.jsx("div",{className:"pt-2",children:me.jsxs("div",{className:"flex gap-2",children:[me.jsx("div",{className:"flex-1 bg-slate-950/40 border border-white/10 rounded-lg px-3 py-2 text-[9px] font-mono text-blue-200 truncate",children:e?.referral_code?`${bc}/signup?ref=${e.referral_code}`:"Generating..."}),me.jsx("button",{onClick:()=>{navigator.clipboard.writeText(`${bc}/signup?ref=${e?.referral_code}`),A(!0),setTimeout(()=>A(!1),2e3)},className:"bg-white text-slate-950 p-2 rounded-lg hover:bg-blue-100 transition-colors",children:L?me.jsx(_8,{className:"w-3.5 h-3.5"}):me.jsx(R8,{className:"w-3.5 h-3.5"})})]})})]})]}),me.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[me.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[me.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Total Referrals"}),me.jsx("p",{className:"text-xl font-black text-white",children:e?.referral_count||0})]}),me.jsxs("div",{className:"bg-slate-900/50 border border-slate-800 rounded-xl p-3",children:[me.jsx("p",{className:"text-[8px] font-bold text-slate-500 uppercase mb-1",children:"Days Granted"}),me.jsx("p",{className:"text-xl font-black text-emerald-400",children:(e?.referral_count||0)*30})]})]}),me.jsxs("button",{onClick:()=>window.open(`${bc}/referral`,"_blank"),className:"w-full py-3 bg-slate-900 border border-slate-800 hover:border-blue-500/50 text-slate-300 hover:text-white text-[10px] font-bold uppercase tracking-widest rounded-xl transition-all flex items-center justify-center gap-2",children:[me.jsx(j8,{className:"w-3.5 h-3.5"})," View Full Dashboard"]})]},"referral"),D==="analyze"&&r==="idle"&&me.jsxs(yl.div,{initial:{opacity:0,scale:.98},animate:{opacity:1,scale:1},exit:{opacity:0,scale:.98},className:"flex flex-col items-center justify-center h-full text-center space-y-6 pt-12",children:[me.jsx("div",{className:"w-20 h-20 bg-slate-900 rounded-full flex items-center justify-center border border-slate-800 shadow-xl",children:me.jsx(V8,{className:"w-8 h-8 text-blue-500"})}),me.jsxs("div",{className:"space-y-2 max-w-[200px]",children:[me.jsx("h3",{className:"text-lg font-bold text-white",children:"Ready to Analyze"}),me.jsx("p",{className:"text-xs text-slate-500 leading-relaxed",children:"Navigate to any chart (TradingView, Yahoo, etc.) and click scan below."})]})]},"idle"),(r==="scanning"||r==="analyzing")&&me.jsxs(yl.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"flex flex-col items-center justify-center h-full space-y-8 pt-12",children:[me.jsxs("div",{className:"relative w-16 h-16",children:[me.jsx("div",{className:"absolute inset-0 border-4 border-slate-800 rounded-full"}),me.jsx("div",{className:"absolute inset-0 border-4 border-t-blue-500 rounded-full animate-spin"})]}),me.jsxs("div",{className:"text-center space-y-2",children:[me.jsx("p",{className:"text-xs font-bold uppercase tracking-widest text-blue-400 animate-pulse",children:d}),me.jsx("p",{className:"text-[10px] text-slate-600",children:"Please wait while we process the data."})]})]},"loading"),r==="success"&&i&&D==="analyze"&&me.jsxs(yl.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},className:"space-y-4 pb-20",children:[me.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-2xl p-5 relative overflow-hidden",children:[me.jsxs("div",{className:"flex justify-between items-start relative z-10",children:[me.jsxs("div",{children:[me.jsx("h2",{className:"text-3xl font-black text-white tracking-tight",children:i.ticker}),me.jsxs("div",{className:"flex items-center gap-2 mt-1",children:[me.jsxs("span",{className:`px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${i.direction.includes("Bullish")?"bg-emerald-500/10 text-emerald-500":"bg-rose-500/10 text-rose-500"}`,children:[i.direction.split(" ")[0]," Signal"]}),me.jsxs("span",{className:"text-[10px] text-slate-500 font-mono",children:[(i.finalProb*100).toFixed(1),"% Conf."]})]})]}),me.jsx("div",{className:`p-2 rounded-xl ${i.direction.includes("Bullish")?"bg-emerald-500/10":"bg-rose-500/10"}`,children:i.direction.includes("Bullish")?me.jsx(zD,{className:"w-5 h-5 text-emerald-500"}):me.jsx(MD,{className:"w-5 h-5 text-rose-500"})})]}),me.jsx("div",{className:`absolute top-0 right-0 w-32 h-32 bg-${i.direction.includes("Bullish")?"emerald":"rose"}-500/10 blur-3xl -translate-y-1/2 translate-x-1/2 rounded-full`})]}),me.jsxs("div",{className:"grid grid-cols-2 gap-3",children:[me.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[me.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Entry Zone"}),me.jsx("p",{className:"text-lg font-mono font-bold text-white",children:i.targets.entry})]}),me.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[me.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Risk/Reward"}),me.jsxs("p",{className:"text-lg font-mono font-bold text-blue-400",children:["1:",i.targets.rr]})]}),me.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[me.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Take Profit"}),me.jsx("p",{className:"text-lg font-mono font-bold text-emerald-500",children:i.targets.tp1})]}),me.jsxs("div",{className:"bg-slate-900 border border-slate-800 rounded-xl p-3",children:[me.jsx("p",{className:"text-[9px] font-bold text-slate-500 uppercase mb-1",children:"Stop Loss"}),me.jsx("p",{className:"text-lg font-mono font-bold text-rose-500",children:i.targets.sl})]})]}),me.jsxs("div",{className:"bg-slate-900/50 border border-slate-800/50 rounded-xl p-4",children:[me.jsxs("h4",{className:"text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 flex items-center gap-2",children:[me.jsx(O8,{className:"w-3 h-3"})," AI Analysis"]}),me.jsx("p",{className:"text-xs text-slate-300 leading-relaxed font-medium",dangerouslySetInnerHTML:{__html:i.overview.replace(/\*\*(.*?)\*\*/g,'<span class="text-white font-bold">$1</span>')}})]}),me.jsx("div",{className:"pt-2 border-t border-slate-800/50 mt-4 text-center",children:me.jsxs("p",{className:"text-[9px] text-slate-500 font-bold uppercase tracking-wider",children:["Logic: ",i.version.split(" ")[0],"  Data: ",i.macroTrend?.source||"Institutional Feed"]})}),me.jsx("button",{onClick:()=>a("idle"),className:"w-full py-3 text-xs font-bold text-slate-500 hover:text-white transition-colors uppercase tracking-widest",children:"Start New Analysis"})]},"result"),r==="error"&&me.jsxs(yl.div,{initial:{opacity:0},animate:{opacity:1},className:"flex flex-col items-center justify-center h-full text-center px-6",children:[me.jsx("div",{className:"w-12 h-12 bg-rose-500/10 rounded-full flex items-center justify-center mb-4",children:me.jsx(q8,{className:"w-6 h-6 text-rose-500"})}),me.jsx("h3",{className:"text-sm font-bold text-white mb-2",children:"Analysis Failed"}),me.jsx("p",{className:"text-xs text-slate-500 mb-6",children:m}),me.jsx("button",{onClick:()=>a("idle"),className:"px-6 py-2 bg-slate-800 hover:bg-slate-700 text-white text-xs font-bold rounded-lg transition-colors",children:"Try Again"})]},"error")]})}),D==="analyze"&&r==="idle"&&me.jsx("div",{className:"shrink-0 p-4 bg-slate-950 border-t border-slate-800/50",children:me.jsxs("button",{onClick:U,className:"w-full py-3.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded-xl shadow-lg shadow-blue-600/20 active:scale-[0.98] transition-all flex items-center justify-center gap-2 text-xs uppercase tracking-wider",children:[me.jsx(PD,{className:"w-4 h-4 fill-current"}),"Execute Scan"]})})]})};UG.createRoot(document.getElementById("root")).render(me.jsx(OG.StrictMode,{children:me.jsx(IX,{children:me.jsx(Rke,{})})}));
